diff -r TrackAnalyzer_/BackgroundSubtracter.java procyon/BackgroundSubtracter.java
2,3c2,3
< import ij.process.ByteProcessor;
< import ij.process.ColorProcessor;
---
> import ij.util.Tools;
> import ij.process.ShortProcessor;
6,7d5
< import ij.process.ShortProcessor;
< import ij.util.Tools;
8a7,8
> import ij.process.ByteProcessor;
> import ij.process.ColorProcessor;
10,684c10,566
< public class BackgroundSubtracter {
<    private static double staticRadius = 50.0D;
<    private static boolean staticLightBackground = false;
<    private static boolean staticSeparateColors;
<    private static boolean staticCreateBackground;
<    private static boolean staticUseParaboloid;
<    private static boolean staticDoPresmooth = false;
<    private double radius;
<    private boolean lightBackground;
<    private boolean separateColors;
<    private boolean createBackground;
<    private boolean useParaboloid;
<    private boolean doPresmooth;
<    private boolean isRGB;
<    private boolean previewing;
<    private static final int MAXIMUM = 0;
<    private static final int MEAN = 1;
<    private static final int X_DIRECTION = 0;
<    private static final int Y_DIRECTION = 1;
<    private static final int DIAGONAL_1A = 2;
<    private static final int DIAGONAL_1B = 3;
<    private static final int DIAGONAL_2A = 4;
<    private static final int DIAGONAL_2B = 5;
<    private static final int DIRECTION_PASSES = 9;
<    private int nPasses;
<    private int pass;
<    private boolean calledAsPlugin;
<    double meanValue;
< 
<    public BackgroundSubtracter() {
<       this.radius = staticRadius;
<       this.lightBackground = staticLightBackground;
<       this.separateColors = staticSeparateColors;
<       this.createBackground = staticCreateBackground;
<       this.useParaboloid = staticUseParaboloid;
<       this.doPresmooth = staticDoPresmooth;
<       this.nPasses = 9;
<    }
< 
<    public void rollingBallBrightnessBackground(ColorProcessor ip, double radius, boolean createBackground, boolean lightBackground, boolean useParaboloid, boolean doPresmooth, boolean correctCorners) {
<       int width = ip.getWidth();
<       int height = ip.getHeight();
<       byte[] H = new byte[width * height];
<       byte[] S = new byte[width * height];
<       byte[] B = new byte[width * height];
<       ip.getHSB(H, S, B);
<       ByteProcessor bp = new ByteProcessor(width, height, B, (ColorModel)null);
<       this.rollingBallBackground(bp, radius, createBackground, lightBackground, useParaboloid, doPresmooth, correctCorners);
<       ip.setHSB(H, S, (byte[])bp.getPixels());
<    }
< 
<    public double rollingBallBackground(ImageProcessor ip, double radius, boolean createBackground, boolean lightBackground, boolean useParaboloid, boolean doPresmooth, boolean correctCorners) {
<       boolean invertedLut = ip.isInvertedLut();
<       boolean invert = invertedLut && !lightBackground || !invertedLut && lightBackground;
<       RollingBall ball = null;
<       if (!useParaboloid) {
<          ball = new RollingBall(radius);
<       }
< 
<       FloatProcessor fp = null;
< 
<       for(int channelNumber = 0; channelNumber < ip.getNChannels(); ++channelNumber) {
<          fp = ip.toFloat(channelNumber, fp);
<          if (ip instanceof FloatProcessor && !this.calledAsPlugin && !createBackground) {
<             fp.snapshot();
<          }
< 
<          this.rollingBallFloatBackground(fp, (float)radius, invert, doPresmooth, ball);
<          if (createBackground) {
<             ip.setPixels(channelNumber, fp);
<          } else {
<             float[] bgPixels = (float[])fp.getPixels();
<             if (ip instanceof FloatProcessor) {
<                float[] snapshotPixels = (float[])fp.getSnapshotPixels();
< 
<                for(int p = 0; p < bgPixels.length; ++p) {
<                   bgPixels[p] = snapshotPixels[p] - bgPixels[p];
<                }
<             } else {
<                float offset;
<                int shift;
<                int resetMask;
<                double total;
<                float value;
<                float valueToSubtract;
<                if (ip instanceof ShortProcessor) {
<                   offset = invert ? 65535.5F : 0.5F;
<                   short[] pixels = (short[])ip.getPixels();
<                   short[] pixelsToSubtract = (short[])ip.getPixels();
< 
<                   for(shift = 0; shift < bgPixels.length; ++shift) {
<                      value = (float)(pixels[shift] & '\uffff') - bgPixels[shift] + offset;
<                      valueToSubtract = bgPixels[shift] + offset;
<                      if (value < 0.0F) {
<                         value = 0.0F;
<                      }
< 
<                      if (valueToSubtract < 0.0F) {
<                         valueToSubtract = 0.0F;
<                      }
< 
<                      if (value > 65535.0F) {
<                         value = 65535.0F;
<                      }
< 
<                      if (valueToSubtract > 65535.0F) {
<                         valueToSubtract = 65535.0F;
<                      }
< 
<                      pixels[shift] = (short)((int)value);
<                      pixelsToSubtract[shift] = (short)((int)valueToSubtract);
<                   }
< 
<                   total = 0.0D;
< 
<                   for(resetMask = 0; resetMask < pixelsToSubtract.length; ++resetMask) {
<                      total += (double)pixelsToSubtract[resetMask];
<                   }
< 
<                   this.meanValue = total / (double)pixelsToSubtract.length;
<                } else if (ip instanceof ByteProcessor) {
<                   offset = invert ? 255.5F : 0.5F;
<                   byte[] pixels = (byte[])ip.getPixels();
<                   byte[] pixelsToSubtract = (byte[])ip.getPixels();
< 
<                   for(shift = 0; shift < bgPixels.length; ++shift) {
<                      value = (float)(pixels[shift] & 255) - bgPixels[shift] + offset;
<                      valueToSubtract = bgPixels[shift] + offset;
<                      if (value < 0.0F) {
<                         value = 0.0F;
<                      }
< 
<                      if (valueToSubtract < 0.0F) {
<                         valueToSubtract = 0.0F;
<                      }
< 
<                      if (value > 255.0F) {
<                         value = 255.0F;
<                      }
< 
<                      if (valueToSubtract > 255.0F) {
<                         valueToSubtract = 255.0F;
<                      }
< 
<                      pixels[shift] = (byte)((int)value);
<                      pixelsToSubtract[shift] = (byte)((int)valueToSubtract);
<                   }
< 
<                   total = 0.0D;
< 
<                   for(resetMask = 0; resetMask < pixelsToSubtract.length; ++resetMask) {
<                      total += (double)pixelsToSubtract[resetMask];
<                   }
< 
<                   this.meanValue = total / (double)pixelsToSubtract.length;
<                } else if (ip instanceof ColorProcessor) {
<                   offset = invert ? 255.5F : 0.5F;
<                   int[] pixels = (int[])ip.getPixels();
<                   int[] pixelsToSubtract = (int[])ip.getPixels();
<                   shift = 16 - 8 * channelNumber;
<                   int byteMask = 255 << shift;
<                   resetMask = ~(255 << shift);
< 
<                   for(int p = 0; p < bgPixels.length; ++p) {
<                      int pxl = pixels[p];
<                      float value = (float)((pxl & byteMask) >> shift) - bgPixels[p] + offset;
<                      float valueToSubtract = bgPixels[p] + offset;
<                      if (value < 0.0F) {
<                         value = 0.0F;
<                      }
< 
<                      if (valueToSubtract < 0.0F) {
<                         valueToSubtract = 0.0F;
<                      }
< 
<                      if (value > 255.0F) {
<                         value = 255.0F;
<                      }
< 
<                      if (valueToSubtract > 255.0F) {
<                         valueToSubtract = 255.0F;
<                      }
< 
<                      pixels[p] = pxl & resetMask | (int)value << shift;
<                      pixelsToSubtract[p] = pxl & resetMask | (int)valueToSubtract << shift;
<                   }
< 
<                   double total = 0.0D;
< 
<                   for(int i = 0; i < pixelsToSubtract.length; ++i) {
<                      total += (double)pixelsToSubtract[i];
<                   }
< 
<                   this.meanValue = total / (double)pixelsToSubtract.length;
<                }
<             }
<          }
<       }
< 
<       return this.meanValue;
<    }
< 
<    static float[] lineSlideParabola(float[] pixels, int start, int inc, int length, float coeff2, float[] cache, int[] nextPoint, float[] correctedEdges) {
<       float minValue = Float.MAX_VALUE;
<       int lastpoint = 0;
<       int firstCorner = length - 1;
<       int lastCorner = 0;
<       float vPrevious1 = 0.0F;
<       float vPrevious2 = 0.0F;
<       float curvatureTest = 1.999F * coeff2;
<       int i1 = 0;
< 
<       float minSlope;
<       for(int p = start; i1 < length; p += inc) {
<          minSlope = pixels[p];
<          cache[i1] = minSlope;
<          if (minSlope < minValue) {
<             minValue = minSlope;
<          }
< 
<          if (i1 >= 2 && vPrevious1 + vPrevious1 - vPrevious2 - minSlope < curvatureTest) {
<             nextPoint[lastpoint] = i1 - 1;
<             lastpoint = i1 - 1;
<          }
< 
<          vPrevious2 = vPrevious1;
<          vPrevious1 = minSlope;
<          ++i1;
<       }
< 
<       nextPoint[lastpoint] = length - 1;
<       nextPoint[length - 1] = Integer.MAX_VALUE;
< 
<       int i2;
<       float dx;
<       float dx;
<       float v1;
<       int i;
<       for(i1 = 0; i1 < length - 1; i1 = i2) {
<          v1 = cache[i1];
<          minSlope = Float.MAX_VALUE;
<          i2 = 0;
<          int searchTo = length;
<          int recalculateLimitNow = 0;
< 
<          int j;
<          for(j = nextPoint[i1]; j < searchTo; ++recalculateLimitNow) {
<             dx = cache[j];
<             dx = (dx - v1) / (float)(j - i1) + coeff2 * (float)(j - i1);
<             if (dx < minSlope) {
<                minSlope = dx;
<                i2 = j;
<                recalculateLimitNow = -3;
<             }
< 
<             if (recalculateLimitNow == 0) {
<                double b = (double)(0.5F * minSlope / coeff2);
<                int maxSearch = i1 + (int)(b + Math.sqrt(b * b + (double)((v1 - minValue) / coeff2)) + 1.0D);
<                if (maxSearch < searchTo && maxSearch > 0) {
<                   searchTo = maxSearch;
<                }
<             }
< 
<             j = nextPoint[j];
<          }
< 
<          if (i1 == 0) {
<             firstCorner = i2;
<          }
< 
<          if (i2 == length - 1) {
<             lastCorner = i1;
<          }
< 
<          j = i1 + 1;
< 
<          for(i = start + j * inc; j < i2; i += inc) {
<             pixels[i] = v1 + (float)(j - i1) * (minSlope - (float)(j - i1) * coeff2);
<             ++j;
<          }
<       }
< 
<       if (correctedEdges != null) {
<          if (4 * firstCorner >= length) {
<             firstCorner = 0;
<          }
< 
<          if (4 * (length - 1 - lastCorner) >= length) {
<             lastCorner = length - 1;
<          }
< 
<          v1 = cache[firstCorner];
<          minSlope = cache[lastCorner];
<          float slope = (minSlope - v1) / (float)(lastCorner - firstCorner);
<          float value0 = v1 - slope * (float)firstCorner;
<          float coeff6 = 0.0F;
<          float mid = 0.5F * (float)(lastCorner + firstCorner);
< 
<          for(i = (length + 2) / 3; i <= 2 * length / 3; ++i) {
<             dx = ((float)i - mid) * 2.0F / (float)(lastCorner - firstCorner);
<             float poly6 = dx * dx * dx * dx * dx * dx - 1.0F;
<             if (cache[i] < value0 + slope * (float)i + coeff6 * poly6) {
<                coeff6 = -(value0 + slope * (float)i - cache[i]) / poly6;
<             }
<          }
< 
<          dx = ((float)firstCorner - mid) * 2.0F / (float)(lastCorner - firstCorner);
<          correctedEdges[0] = value0 + coeff6 * (dx * dx * dx * dx * dx * dx - 1.0F) + coeff2 * (float)firstCorner * (float)firstCorner;
<          dx = ((float)lastCorner - mid) * 2.0F / (float)(lastCorner - firstCorner);
<          correctedEdges[1] = value0 + (float)(length - 1) * slope + coeff6 * (dx * dx * dx * dx * dx * dx - 1.0F) + coeff2 * (float)(length - 1 - lastCorner) * (float)(length - 1 - lastCorner);
<       }
< 
<       return correctedEdges;
<    }
< 
<    void correctCorners(FloatProcessor fp, float coeff2, float[] cache, int[] nextPoint) {
<       int width = fp.getWidth();
<       int height = fp.getHeight();
<       float[] pixels = (float[])fp.getPixels();
<       float[] corners = new float[4];
<       float[] correctedEdges = new float[2];
<       correctedEdges = lineSlideParabola(pixels, 0, 1, width, coeff2, cache, nextPoint, correctedEdges);
<       corners[0] = correctedEdges[0];
<       corners[1] = correctedEdges[1];
<       correctedEdges = lineSlideParabola(pixels, (height - 1) * width, 1, width, coeff2, cache, nextPoint, correctedEdges);
<       corners[2] = correctedEdges[0];
<       corners[3] = correctedEdges[1];
<       correctedEdges = lineSlideParabola(pixels, 0, width, height, coeff2, cache, nextPoint, correctedEdges);
<       corners[0] += correctedEdges[0];
<       corners[2] += correctedEdges[1];
<       correctedEdges = lineSlideParabola(pixels, width - 1, width, height, coeff2, cache, nextPoint, correctedEdges);
<       corners[1] += correctedEdges[0];
<       corners[3] += correctedEdges[1];
<       int diagLength = Math.min(width, height);
<       float coeff2diag = 2.0F * coeff2;
<       correctedEdges = lineSlideParabola(pixels, 0, 1 + width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
<       corners[0] += correctedEdges[0];
<       correctedEdges = lineSlideParabola(pixels, width - 1, -1 + width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
<       corners[1] += correctedEdges[0];
<       correctedEdges = lineSlideParabola(pixels, (height - 1) * width, 1 - width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
<       corners[2] += correctedEdges[0];
<       correctedEdges = lineSlideParabola(pixels, width * height - 1, -1 - width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
<       corners[3] += correctedEdges[0];
<       if (pixels[0] > corners[0] / 3.0F) {
<          pixels[0] = corners[0] / 3.0F;
<       }
< 
<       if (pixels[width - 1] > corners[1] / 3.0F) {
<          pixels[width - 1] = corners[1] / 3.0F;
<       }
< 
<       if (pixels[(height - 1) * width] > corners[2] / 3.0F) {
<          pixels[(height - 1) * width] = corners[2] / 3.0F;
<       }
< 
<       if (pixels[width * height - 1] > corners[3] / 3.0F) {
<          pixels[width * height - 1] = corners[3] / 3.0F;
<       }
< 
<    }
< 
<    void rollingBallFloatBackground(FloatProcessor fp, float radius, boolean invert, boolean doPresmooth, RollingBall ball) {
<       float[] pixels = (float[])fp.getPixels();
<       boolean shrink = ball.shrinkFactor > 1;
<       this.showProgress(0.0D);
<       if (invert) {
<          for(int i = 0; i < pixels.length; ++i) {
<             pixels[i] = -pixels[i];
<          }
<       }
< 
<       if (doPresmooth) {
<          this.filter3x3(fp, 1);
<       }
< 
<       double[] minmax = Tools.getMinMax(pixels);
<       if (!Thread.currentThread().isInterrupted()) {
<          FloatProcessor smallImage = shrink ? this.shrinkImage(fp, ball.shrinkFactor) : fp;
<          if (!Thread.currentThread().isInterrupted()) {
<             this.rollBall(ball, smallImage);
<             if (!Thread.currentThread().isInterrupted()) {
<                this.showProgress(0.9D);
<                if (shrink) {
<                   this.enlargeImage(smallImage, fp, ball.shrinkFactor);
<                }
< 
<                if (!Thread.currentThread().isInterrupted()) {
<                   if (invert) {
<                      for(int i = 0; i < pixels.length; ++i) {
<                         pixels[i] = -pixels[i];
<                      }
<                   }
< 
<                   ++this.pass;
<                }
<             }
<          }
<       }
<    }
< 
<    FloatProcessor shrinkImage(FloatProcessor ip, int shrinkFactor) {
<       int width = ip.getWidth();
<       int height = ip.getHeight();
<       float[] pixels = (float[])ip.getPixels();
<       int sWidth = (width + shrinkFactor - 1) / shrinkFactor;
<       int sHeight = (height + shrinkFactor - 1) / shrinkFactor;
<       this.showProgress(0.1D);
<       FloatProcessor smallImage = new FloatProcessor(sWidth, sHeight);
<       float[] sPixels = (float[])smallImage.getPixels();
< 
<       for(int ySmall = 0; ySmall < sHeight; ++ySmall) {
<          for(int xSmall = 0; xSmall < sWidth; ++xSmall) {
<             float min = Float.MAX_VALUE;
<             int j = 0;
< 
<             for(int y = shrinkFactor * ySmall; j < shrinkFactor && y < height; ++y) {
<                int k = 0;
< 
<                for(int x = shrinkFactor * xSmall; k < shrinkFactor && x < width; ++x) {
<                   float thispixel = pixels[x + y * width];
<                   if (thispixel < min) {
<                      min = thispixel;
<                   }
< 
<                   ++k;
<                }
< 
<                ++j;
<             }
< 
<             sPixels[xSmall + ySmall * sWidth] = min;
<          }
<       }
< 
<       return smallImage;
<    }
< 
<    void rollBall(RollingBall ball, FloatProcessor fp) {
<       float[] pixels = (float[])fp.getPixels();
<       int width = fp.getWidth();
<       int height = fp.getHeight();
<       float[] zBall = ball.data;
<       int ballWidth = ball.width;
<       int radius = ballWidth / 2;
<       float[] cache = new float[width * ballWidth];
<       Thread thread = Thread.currentThread();
<       long lastTime = System.currentTimeMillis();
< 
<       for(int y = -radius; y < height + radius; ++y) {
<          long time = System.currentTimeMillis();
<          if (time - lastTime > 100L) {
<             lastTime = time;
<             if (thread.isInterrupted()) {
<                return;
<             }
< 
<             this.showProgress(0.1D + 0.8D * (double)y / (double)(height + ballWidth));
<          }
< 
<          int nextLineToWriteInCache = (y + radius) % ballWidth;
<          int nextLineToRead = y + radius;
<          int y0;
<          int yBall0;
<          if (nextLineToRead < height) {
<             System.arraycopy(pixels, nextLineToRead * width, cache, nextLineToWriteInCache * width, width);
<             y0 = 0;
< 
<             for(yBall0 = nextLineToRead * width; y0 < width; ++yBall0) {
<                pixels[yBall0] = -3.4028235E38F;
<                ++y0;
<             }
<          }
< 
<          y0 = y - radius;
<          if (y0 < 0) {
<             y0 = 0;
<          }
< 
<          yBall0 = y0 - y + radius;
<          int yend = y + radius;
<          if (yend >= height) {
<             yend = height - 1;
<          }
< 
<          for(int x = -radius; x < width + radius; ++x) {
<             float z = Float.MAX_VALUE;
<             int x0 = x - radius;
<             if (x0 < 0) {
<                x0 = 0;
<             }
< 
<             int xBall0 = x0 - x + radius;
<             int xend = x + radius;
<             if (xend >= width) {
<                xend = width - 1;
<             }
< 
<             int yp = y0;
< 
<             int yBall;
<             int xp;
<             int p;
<             int bp;
<             float zMin;
<             for(yBall = yBall0; yp <= yend; ++yBall) {
<                xp = yp % ballWidth * width + x0;
<                p = x0;
< 
<                for(bp = xBall0 + yBall * ballWidth; p <= xend; ++bp) {
<                   zMin = cache[xp] - zBall[bp];
<                   if (z > zMin) {
<                      z = zMin;
<                   }
< 
<                   ++p;
<                   ++xp;
<                }
< 
<                ++yp;
<             }
< 
<             yp = y0;
< 
<             for(yBall = yBall0; yp <= yend; ++yBall) {
<                xp = x0;
<                p = x0 + yp * width;
< 
<                for(bp = xBall0 + yBall * ballWidth; xp <= xend; ++bp) {
<                   zMin = z + zBall[bp];
<                   if (pixels[p] < zMin) {
<                      pixels[p] = zMin;
<                   }
< 
<                   ++xp;
<                   ++p;
<                }
< 
<                ++yp;
<             }
<          }
<       }
< 
<    }
< 
<    void enlargeImage(FloatProcessor smallImage, FloatProcessor fp, int shrinkFactor) {
<       int width = fp.getWidth();
<       int height = fp.getHeight();
<       int smallWidth = smallImage.getWidth();
<       int smallHeight = smallImage.getHeight();
<       float[] pixels = (float[])fp.getPixels();
<       float[] sPixels = (float[])smallImage.getPixels();
<       int[] xSmallIndices = new int[width];
<       float[] xWeights = new float[width];
<       this.makeInterpolationArrays(xSmallIndices, xWeights, width, smallWidth, shrinkFactor);
<       int[] ySmallIndices = new int[height];
<       float[] yWeights = new float[height];
<       this.makeInterpolationArrays(ySmallIndices, yWeights, height, smallHeight, shrinkFactor);
<       float[] line0 = new float[width];
<       float[] line1 = new float[width];
< 
<       int ySmallLine0;
<       for(ySmallLine0 = 0; ySmallLine0 < width; ++ySmallLine0) {
<          line1[ySmallLine0] = sPixels[xSmallIndices[ySmallLine0]] * xWeights[ySmallLine0] + sPixels[xSmallIndices[ySmallLine0] + 1] * (1.0F - xWeights[ySmallLine0]);
<       }
< 
<       ySmallLine0 = -1;
< 
<       for(int y = 0; y < height; ++y) {
<          int x;
<          int p;
<          if (ySmallLine0 < ySmallIndices[y]) {
<             float[] swap = line0;
<             line0 = line1;
<             line1 = swap;
<             ++ySmallLine0;
<             x = (ySmallIndices[y] + 1) * smallWidth;
< 
<             for(p = 0; p < width; ++p) {
<                line1[p] = sPixels[x + xSmallIndices[p]] * xWeights[p] + sPixels[x + xSmallIndices[p] + 1] * (1.0F - xWeights[p]);
<             }
<          }
< 
<          float weight = yWeights[y];
<          x = 0;
< 
<          for(p = y * width; x < width; ++p) {
<             pixels[p] = line0[x] * weight + line1[x] * (1.0F - weight);
<             ++x;
<          }
<       }
< 
<    }
< 
<    void makeInterpolationArrays(int[] smallIndices, float[] weights, int length, int smallLength, int shrinkFactor) {
<       for(int i = 0; i < length; ++i) {
<          int smallIndex = (i - shrinkFactor / 2) / shrinkFactor;
<          if (smallIndex >= smallLength - 1) {
<             smallIndex = smallLength - 2;
<          }
< 
<          smallIndices[i] = smallIndex;
<          float distance = ((float)i + 0.5F) / (float)shrinkFactor - ((float)smallIndex + 0.5F);
<          weights[i] = 1.0F - distance;
<       }
< 
<    }
< 
<    double filter3x3(FloatProcessor fp, int type) {
<       int width = fp.getWidth();
<       int height = fp.getHeight();
<       double shiftBy = 0.0D;
<       float[] pixels = (float[])fp.getPixels();
< 
<       int x;
<       for(x = 0; x < height; ++x) {
<          shiftBy += this.filter3(pixels, width, x * width, 1, type);
<       }
< 
<       for(x = 0; x < width; ++x) {
<          shiftBy += this.filter3(pixels, height, x, width, type);
<       }
< 
<       return shiftBy / (double)width / (double)height;
<    }
< 
<    double filter3(float[] pixels, int length, int pixel0, int inc, int type) {
<       double shiftBy = 0.0D;
<       float v3 = pixels[pixel0];
<       float v2 = v3;
<       int i = 0;
< 
<       for(int p = pixel0; i < length; p += inc) {
<          float v1 = v2;
<          v2 = v3;
<          if (i < length - 1) {
<             v3 = pixels[p + inc];
<          }
< 
<          if (type == 0) {
<             float max = v1 > v3 ? v1 : v3;
<             if (v2 > max) {
<                max = v2;
<             }
< 
<             shiftBy += (double)(max - v2);
<             pixels[p] = max;
<          } else {
<             pixels[p] = (v1 + v3 + v3) * 0.33333334F;
<          }
< 
<          ++i;
<       }
< 
<       return shiftBy;
<    }
< 
<    public void setNPasses(int nPasses) {
<       if (this.isRGB && this.separateColors) {
<          nPasses *= 3;
<       }
< 
<       if (this.useParaboloid) {
<          nPasses *= this.doPresmooth ? 11 : 9;
<       }
< 
<       this.nPasses = nPasses;
<       this.pass = 0;
<    }
< 
<    private void showProgress(double percent) {
<       if (this.nPasses > 0) {
<          percent = (double)this.pass / (double)this.nPasses + percent / (double)this.nPasses;
<          IJ.showProgress(percent);
<       }
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class BackgroundSubtracter
> {
>     private static double staticRadius;
>     private static boolean staticLightBackground;
>     private static boolean staticSeparateColors;
>     private static boolean staticCreateBackground;
>     private static boolean staticUseParaboloid;
>     private static boolean staticDoPresmooth;
>     private double radius;
>     private boolean lightBackground;
>     private boolean separateColors;
>     private boolean createBackground;
>     private boolean useParaboloid;
>     private boolean doPresmooth;
>     private boolean isRGB;
>     private boolean previewing;
>     private static final int MAXIMUM = 0;
>     private static final int MEAN = 1;
>     private static final int X_DIRECTION = 0;
>     private static final int Y_DIRECTION = 1;
>     private static final int DIAGONAL_1A = 2;
>     private static final int DIAGONAL_1B = 3;
>     private static final int DIAGONAL_2A = 4;
>     private static final int DIAGONAL_2B = 5;
>     private static final int DIRECTION_PASSES = 9;
>     private int nPasses;
>     private int pass;
>     private boolean calledAsPlugin;
>     double meanValue;
>     
>     static {
>         BackgroundSubtracter.staticRadius = 50.0;
>         BackgroundSubtracter.staticLightBackground = false;
>         BackgroundSubtracter.staticDoPresmooth = false;
>     }
>     
>     public BackgroundSubtracter() {
>         this.radius = BackgroundSubtracter.staticRadius;
>         this.lightBackground = BackgroundSubtracter.staticLightBackground;
>         this.separateColors = BackgroundSubtracter.staticSeparateColors;
>         this.createBackground = BackgroundSubtracter.staticCreateBackground;
>         this.useParaboloid = BackgroundSubtracter.staticUseParaboloid;
>         this.doPresmooth = BackgroundSubtracter.staticDoPresmooth;
>         this.nPasses = 9;
>     }
>     
>     public void rollingBallBrightnessBackground(final ColorProcessor ip, final double radius, final boolean createBackground, final boolean lightBackground, final boolean useParaboloid, final boolean doPresmooth, final boolean correctCorners) {
>         final int width = ip.getWidth();
>         final int height = ip.getHeight();
>         final byte[] H = new byte[width * height];
>         final byte[] S = new byte[width * height];
>         final byte[] B = new byte[width * height];
>         ip.getHSB(H, S, B);
>         final ByteProcessor bp = new ByteProcessor(width, height, B, (ColorModel)null);
>         this.rollingBallBackground((ImageProcessor)bp, radius, createBackground, lightBackground, useParaboloid, doPresmooth, correctCorners);
>         ip.setHSB(H, S, (byte[])bp.getPixels());
>     }
>     
>     public double rollingBallBackground(final ImageProcessor ip, final double radius, final boolean createBackground, final boolean lightBackground, final boolean useParaboloid, final boolean doPresmooth, final boolean correctCorners) {
>         final boolean invertedLut = ip.isInvertedLut();
>         final boolean invert = (invertedLut && !lightBackground) || (!invertedLut && lightBackground);
>         RollingBall ball = null;
>         if (!useParaboloid) {
>             ball = new RollingBall(radius);
>         }
>         FloatProcessor fp = null;
>         for (int channelNumber = 0; channelNumber < ip.getNChannels(); ++channelNumber) {
>             fp = ip.toFloat(channelNumber, fp);
>             if (ip instanceof FloatProcessor && !this.calledAsPlugin && !createBackground) {
>                 fp.snapshot();
>             }
>             this.rollingBallFloatBackground(fp, (float)radius, invert, doPresmooth, ball);
>             if (createBackground) {
>                 ip.setPixels(channelNumber, fp);
>             }
>             else {
>                 final float[] bgPixels = (float[])fp.getPixels();
>                 if (ip instanceof FloatProcessor) {
>                     final float[] snapshotPixels = (float[])fp.getSnapshotPixels();
>                     for (int p = 0; p < bgPixels.length; ++p) {
>                         bgPixels[p] = snapshotPixels[p] - bgPixels[p];
>                     }
>                 }
>                 else if (ip instanceof ShortProcessor) {
>                     final float offset = invert ? 65535.5f : 0.5f;
>                     final short[] pixels = (short[])ip.getPixels();
>                     final short[] pixelsToSubtract = (short[])ip.getPixels();
>                     for (int p2 = 0; p2 < bgPixels.length; ++p2) {
>                         float value = (pixels[p2] & 0xFFFF) - bgPixels[p2] + offset;
>                         float valueToSubtract = bgPixels[p2] + offset;
>                         if (value < 0.0f) {
>                             value = 0.0f;
>                         }
>                         if (valueToSubtract < 0.0f) {
>                             valueToSubtract = 0.0f;
>                         }
>                         if (value > 65535.0f) {
>                             value = 65535.0f;
>                         }
>                         if (valueToSubtract > 65535.0f) {
>                             valueToSubtract = 65535.0f;
>                         }
>                         pixels[p2] = (short)value;
>                         pixelsToSubtract[p2] = (short)valueToSubtract;
>                     }
>                     double total = 0.0;
>                     for (int i = 0; i < pixelsToSubtract.length; ++i) {
>                         total += pixelsToSubtract[i];
>                     }
>                     this.meanValue = total / pixelsToSubtract.length;
>                 }
>                 else if (ip instanceof ByteProcessor) {
>                     final float offset = invert ? 255.5f : 0.5f;
>                     final byte[] pixels2 = (byte[])ip.getPixels();
>                     final byte[] pixelsToSubtract2 = (byte[])ip.getPixels();
>                     for (int p2 = 0; p2 < bgPixels.length; ++p2) {
>                         float value = (pixels2[p2] & 0xFF) - bgPixels[p2] + offset;
>                         float valueToSubtract = bgPixels[p2] + offset;
>                         if (value < 0.0f) {
>                             value = 0.0f;
>                         }
>                         if (valueToSubtract < 0.0f) {
>                             valueToSubtract = 0.0f;
>                         }
>                         if (value > 255.0f) {
>                             value = 255.0f;
>                         }
>                         if (valueToSubtract > 255.0f) {
>                             valueToSubtract = 255.0f;
>                         }
>                         pixels2[p2] = (byte)value;
>                         pixelsToSubtract2[p2] = (byte)valueToSubtract;
>                     }
>                     double total = 0.0;
>                     for (int i = 0; i < pixelsToSubtract2.length; ++i) {
>                         total += pixelsToSubtract2[i];
>                     }
>                     this.meanValue = total / pixelsToSubtract2.length;
>                 }
>                 else if (ip instanceof ColorProcessor) {
>                     final float offset = invert ? 255.5f : 0.5f;
>                     final int[] pixels3 = (int[])ip.getPixels();
>                     final int[] pixelsToSubtract3 = (int[])ip.getPixels();
>                     final int shift = 16 - 8 * channelNumber;
>                     final int byteMask = 255 << shift;
>                     final int resetMask = -1 ^ 255 << shift;
>                     for (int p3 = 0; p3 < bgPixels.length; ++p3) {
>                         final int pxl = pixels3[p3];
>                         float value2 = ((pxl & byteMask) >> shift) - bgPixels[p3] + offset;
>                         float valueToSubtract2 = bgPixels[p3] + offset;
>                         if (value2 < 0.0f) {
>                             value2 = 0.0f;
>                         }
>                         if (valueToSubtract2 < 0.0f) {
>                             valueToSubtract2 = 0.0f;
>                         }
>                         if (value2 > 255.0f) {
>                             value2 = 255.0f;
>                         }
>                         if (valueToSubtract2 > 255.0f) {
>                             valueToSubtract2 = 255.0f;
>                         }
>                         pixels3[p3] = ((pxl & resetMask) | (int)value2 << shift);
>                         pixelsToSubtract3[p3] = ((pxl & resetMask) | (int)valueToSubtract2 << shift);
>                     }
>                     double total2 = 0.0;
>                     for (int j = 0; j < pixelsToSubtract3.length; ++j) {
>                         total2 += pixelsToSubtract3[j];
>                     }
>                     this.meanValue = total2 / pixelsToSubtract3.length;
>                 }
>             }
>         }
>         return this.meanValue;
>     }
>     
>     static float[] lineSlideParabola(final float[] pixels, final int start, final int inc, final int length, final float coeff2, final float[] cache, final int[] nextPoint, final float[] correctedEdges) {
>         float minValue = Float.MAX_VALUE;
>         int lastpoint = 0;
>         int firstCorner = length - 1;
>         int lastCorner = 0;
>         float vPrevious1 = 0.0f;
>         float vPrevious2 = 0.0f;
>         final float curvatureTest = 1.999f * coeff2;
>         for (int i = 0, p = start; i < length; ++i, p += inc) {
>             final float v = pixels[p];
>             cache[i] = v;
>             if (v < minValue) {
>                 minValue = v;
>             }
>             if (i >= 2 && vPrevious1 + vPrevious1 - vPrevious2 - v < curvatureTest) {
>                 nextPoint[lastpoint] = i - 1;
>                 lastpoint = i - 1;
>             }
>             vPrevious2 = vPrevious1;
>             vPrevious1 = v;
>         }
>         nextPoint[nextPoint[lastpoint] = length - 1] = Integer.MAX_VALUE;
>         int i3;
>         for (int i2 = 0; i2 < length - 1; i2 = i3) {
>             final float v2 = cache[i2];
>             float minSlope = Float.MAX_VALUE;
>             i3 = 0;
>             for (int searchTo = length, recalculateLimitNow = 0, j = nextPoint[i2]; j < searchTo; j = nextPoint[j], ++recalculateLimitNow) {
>                 final float v3 = cache[j];
>                 final float slope = (v3 - v2) / (j - i2) + coeff2 * (j - i2);
>                 if (slope < minSlope) {
>                     minSlope = slope;
>                     i3 = j;
>                     recalculateLimitNow = -3;
>                 }
>                 if (recalculateLimitNow == 0) {
>                     final double b = 0.5f * minSlope / coeff2;
>                     final int maxSearch = i2 + (int)(b + Math.sqrt(b * b + (v2 - minValue) / coeff2) + 1.0);
>                     if (maxSearch < searchTo && maxSearch > 0) {
>                         searchTo = maxSearch;
>                     }
>                 }
>             }
>             if (i2 == 0) {
>                 firstCorner = i3;
>             }
>             if (i3 == length - 1) {
>                 lastCorner = i2;
>             }
>             for (int j = i2 + 1, p2 = start + j * inc; j < i3; ++j, p2 += inc) {
>                 pixels[p2] = v2 + (j - i2) * (minSlope - (j - i2) * coeff2);
>             }
>         }
>         if (correctedEdges != null) {
>             if (4 * firstCorner >= length) {
>                 firstCorner = 0;
>             }
>             if (4 * (length - 1 - lastCorner) >= length) {
>                 lastCorner = length - 1;
>             }
>             final float v2 = cache[firstCorner];
>             final float v4 = cache[lastCorner];
>             final float slope2 = (v4 - v2) / (lastCorner - firstCorner);
>             final float value0 = v2 - slope2 * firstCorner;
>             float coeff3 = 0.0f;
>             final float mid = 0.5f * (lastCorner + firstCorner);
>             for (int k = (length + 2) / 3; k <= 2 * length / 3; ++k) {
>                 final float dx = (k - mid) * 2.0f / (lastCorner - firstCorner);
>                 final float poly6 = dx * dx * dx * dx * dx * dx - 1.0f;
>                 if (cache[k] < value0 + slope2 * k + coeff3 * poly6) {
>                     coeff3 = -(value0 + slope2 * k - cache[k]) / poly6;
>                 }
>             }
>             float dx2 = (firstCorner - mid) * 2.0f / (lastCorner - firstCorner);
>             correctedEdges[0] = value0 + coeff3 * (dx2 * dx2 * dx2 * dx2 * dx2 * dx2 - 1.0f) + coeff2 * firstCorner * firstCorner;
>             dx2 = (lastCorner - mid) * 2.0f / (lastCorner - firstCorner);
>             correctedEdges[1] = value0 + (length - 1) * slope2 + coeff3 * (dx2 * dx2 * dx2 * dx2 * dx2 * dx2 - 1.0f) + coeff2 * (length - 1 - lastCorner) * (length - 1 - lastCorner);
>         }
>         return correctedEdges;
>     }
>     
>     void correctCorners(final FloatProcessor fp, final float coeff2, final float[] cache, final int[] nextPoint) {
>         final int width = fp.getWidth();
>         final int height = fp.getHeight();
>         final float[] pixels = (float[])fp.getPixels();
>         final float[] corners = new float[4];
>         float[] correctedEdges = new float[2];
>         correctedEdges = lineSlideParabola(pixels, 0, 1, width, coeff2, cache, nextPoint, correctedEdges);
>         corners[0] = correctedEdges[0];
>         corners[1] = correctedEdges[1];
>         correctedEdges = lineSlideParabola(pixels, (height - 1) * width, 1, width, coeff2, cache, nextPoint, correctedEdges);
>         corners[2] = correctedEdges[0];
>         corners[3] = correctedEdges[1];
>         correctedEdges = lineSlideParabola(pixels, 0, width, height, coeff2, cache, nextPoint, correctedEdges);
>         final float[] array = corners;
>         final int n = 0;
>         array[n] += correctedEdges[0];
>         final float[] array2 = corners;
>         final int n2 = 2;
>         array2[n2] += correctedEdges[1];
>         correctedEdges = lineSlideParabola(pixels, width - 1, width, height, coeff2, cache, nextPoint, correctedEdges);
>         final float[] array3 = corners;
>         final int n3 = 1;
>         array3[n3] += correctedEdges[0];
>         final float[] array4 = corners;
>         final int n4 = 3;
>         array4[n4] += correctedEdges[1];
>         final int diagLength = Math.min(width, height);
>         final float coeff2diag = 2.0f * coeff2;
>         correctedEdges = lineSlideParabola(pixels, 0, 1 + width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
>         final float[] array5 = corners;
>         final int n5 = 0;
>         array5[n5] += correctedEdges[0];
>         correctedEdges = lineSlideParabola(pixels, width - 1, -1 + width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
>         final float[] array6 = corners;
>         final int n6 = 1;
>         array6[n6] += correctedEdges[0];
>         correctedEdges = lineSlideParabola(pixels, (height - 1) * width, 1 - width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
>         final float[] array7 = corners;
>         final int n7 = 2;
>         array7[n7] += correctedEdges[0];
>         correctedEdges = lineSlideParabola(pixels, width * height - 1, -1 - width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
>         final float[] array8 = corners;
>         final int n8 = 3;
>         array8[n8] += correctedEdges[0];
>         if (pixels[0] > corners[0] / 3.0f) {
>             pixels[0] = corners[0] / 3.0f;
>         }
>         if (pixels[width - 1] > corners[1] / 3.0f) {
>             pixels[width - 1] = corners[1] / 3.0f;
>         }
>         if (pixels[(height - 1) * width] > corners[2] / 3.0f) {
>             pixels[(height - 1) * width] = corners[2] / 3.0f;
>         }
>         if (pixels[width * height - 1] > corners[3] / 3.0f) {
>             pixels[width * height - 1] = corners[3] / 3.0f;
>         }
>     }
>     
>     void rollingBallFloatBackground(final FloatProcessor fp, final float radius, final boolean invert, final boolean doPresmooth, final RollingBall ball) {
>         final float[] pixels = (float[])fp.getPixels();
>         final boolean shrink = ball.shrinkFactor > 1;
>         this.showProgress(0.0);
>         if (invert) {
>             for (int i = 0; i < pixels.length; ++i) {
>                 pixels[i] = -pixels[i];
>             }
>         }
>         if (doPresmooth) {
>             this.filter3x3(fp, 1);
>         }
>         final double[] minmax = Tools.getMinMax(pixels);
>         if (Thread.currentThread().isInterrupted()) {
>             return;
>         }
>         final FloatProcessor smallImage = shrink ? this.shrinkImage(fp, ball.shrinkFactor) : fp;
>         if (Thread.currentThread().isInterrupted()) {
>             return;
>         }
>         this.rollBall(ball, smallImage);
>         if (Thread.currentThread().isInterrupted()) {
>             return;
>         }
>         this.showProgress(0.9);
>         if (shrink) {
>             this.enlargeImage(smallImage, fp, ball.shrinkFactor);
>         }
>         if (Thread.currentThread().isInterrupted()) {
>             return;
>         }
>         if (invert) {
>             for (int j = 0; j < pixels.length; ++j) {
>                 pixels[j] = -pixels[j];
>             }
>         }
>         ++this.pass;
>     }
>     
>     FloatProcessor shrinkImage(final FloatProcessor ip, final int shrinkFactor) {
>         final int width = ip.getWidth();
>         final int height = ip.getHeight();
>         final float[] pixels = (float[])ip.getPixels();
>         final int sWidth = (width + shrinkFactor - 1) / shrinkFactor;
>         final int sHeight = (height + shrinkFactor - 1) / shrinkFactor;
>         this.showProgress(0.1);
>         final FloatProcessor smallImage = new FloatProcessor(sWidth, sHeight);
>         final float[] sPixels = (float[])smallImage.getPixels();
>         for (int ySmall = 0; ySmall < sHeight; ++ySmall) {
>             for (int xSmall = 0; xSmall < sWidth; ++xSmall) {
>                 float min = Float.MAX_VALUE;
>                 for (int j = 0, y = shrinkFactor * ySmall; j < shrinkFactor && y < height; ++j, ++y) {
>                     for (int k = 0, x = shrinkFactor * xSmall; k < shrinkFactor && x < width; ++k, ++x) {
>                         final float thispixel = pixels[x + y * width];
>                         if (thispixel < min) {
>                             min = thispixel;
>                         }
>                     }
>                 }
>                 sPixels[xSmall + ySmall * sWidth] = min;
>             }
>         }
>         return smallImage;
>     }
>     
>     void rollBall(final RollingBall ball, final FloatProcessor fp) {
>         final float[] pixels = (float[])fp.getPixels();
>         final int width = fp.getWidth();
>         final int height = fp.getHeight();
>         final float[] zBall = ball.data;
>         final int ballWidth = ball.width;
>         final int radius = ballWidth / 2;
>         final float[] cache = new float[width * ballWidth];
>         final Thread thread = Thread.currentThread();
>         long lastTime = System.currentTimeMillis();
>         for (int y = -radius; y < height + radius; ++y) {
>             final long time = System.currentTimeMillis();
>             if (time - lastTime > 100L) {
>                 lastTime = time;
>                 if (thread.isInterrupted()) {
>                     return;
>                 }
>                 this.showProgress(0.1 + 0.8 * y / (height + ballWidth));
>             }
>             final int nextLineToWriteInCache = (y + radius) % ballWidth;
>             final int nextLineToRead = y + radius;
>             if (nextLineToRead < height) {
>                 System.arraycopy(pixels, nextLineToRead * width, cache, nextLineToWriteInCache * width, width);
>                 for (int x = 0, p = nextLineToRead * width; x < width; ++x, ++p) {
>                     pixels[p] = -3.4028235E38f;
>                 }
>             }
>             int y2 = y - radius;
>             if (y2 < 0) {
>                 y2 = 0;
>             }
>             final int yBall0 = y2 - y + radius;
>             int yend = y + radius;
>             if (yend >= height) {
>                 yend = height - 1;
>             }
>             for (int x2 = -radius; x2 < width + radius; ++x2) {
>                 float z = Float.MAX_VALUE;
>                 int x3 = x2 - radius;
>                 if (x3 < 0) {
>                     x3 = 0;
>                 }
>                 final int xBall0 = x3 - x2 + radius;
>                 int xend = x2 + radius;
>                 if (xend >= width) {
>                     xend = width - 1;
>                 }
>                 for (int yp = y2, yBall2 = yBall0; yp <= yend; ++yp, ++yBall2) {
>                     for (int cachePointer = yp % ballWidth * width + x3, xp = x3, bp = xBall0 + yBall2 * ballWidth; xp <= xend; ++xp, ++cachePointer, ++bp) {
>                         final float zReduced = cache[cachePointer] - zBall[bp];
>                         if (z > zReduced) {
>                             z = zReduced;
>                         }
>                     }
>                 }
>                 for (int yp = y2, yBall2 = yBall0; yp <= yend; ++yp, ++yBall2) {
>                     for (int xp2 = x3, p2 = xp2 + yp * width, bp = xBall0 + yBall2 * ballWidth; xp2 <= xend; ++xp2, ++p2, ++bp) {
>                         final float zMin = z + zBall[bp];
>                         if (pixels[p2] < zMin) {
>                             pixels[p2] = zMin;
>                         }
>                     }
>                 }
>             }
>         }
>     }
>     
>     void enlargeImage(final FloatProcessor smallImage, final FloatProcessor fp, final int shrinkFactor) {
>         final int width = fp.getWidth();
>         final int height = fp.getHeight();
>         final int smallWidth = smallImage.getWidth();
>         final int smallHeight = smallImage.getHeight();
>         final float[] pixels = (float[])fp.getPixels();
>         final float[] sPixels = (float[])smallImage.getPixels();
>         final int[] xSmallIndices = new int[width];
>         final float[] xWeights = new float[width];
>         this.makeInterpolationArrays(xSmallIndices, xWeights, width, smallWidth, shrinkFactor);
>         final int[] ySmallIndices = new int[height];
>         final float[] yWeights = new float[height];
>         this.makeInterpolationArrays(ySmallIndices, yWeights, height, smallHeight, shrinkFactor);
>         float[] line0 = new float[width];
>         float[] line2 = new float[width];
>         for (int x = 0; x < width; ++x) {
>             line2[x] = sPixels[xSmallIndices[x]] * xWeights[x] + sPixels[xSmallIndices[x] + 1] * (1.0f - xWeights[x]);
>         }
>         int ySmallLine0 = -1;
>         for (int y = 0; y < height; ++y) {
>             if (ySmallLine0 < ySmallIndices[y]) {
>                 final float[] swap = line0;
>                 line0 = line2;
>                 line2 = swap;
>                 ++ySmallLine0;
>                 final int sYPointer = (ySmallIndices[y] + 1) * smallWidth;
>                 for (int x2 = 0; x2 < width; ++x2) {
>                     line2[x2] = sPixels[sYPointer + xSmallIndices[x2]] * xWeights[x2] + sPixels[sYPointer + xSmallIndices[x2] + 1] * (1.0f - xWeights[x2]);
>                 }
>             }
>             final float weight = yWeights[y];
>             for (int x3 = 0, p = y * width; x3 < width; ++x3, ++p) {
>                 pixels[p] = line0[x3] * weight + line2[x3] * (1.0f - weight);
>             }
>         }
>     }
>     
>     void makeInterpolationArrays(final int[] smallIndices, final float[] weights, final int length, final int smallLength, final int shrinkFactor) {
>         for (int i = 0; i < length; ++i) {
>             int smallIndex = (i - shrinkFactor / 2) / shrinkFactor;
>             if (smallIndex >= smallLength - 1) {
>                 smallIndex = smallLength - 2;
>             }
>             smallIndices[i] = smallIndex;
>             final float distance = (i + 0.5f) / shrinkFactor - (smallIndex + 0.5f);
>             weights[i] = 1.0f - distance;
>         }
>     }
>     
>     double filter3x3(final FloatProcessor fp, final int type) {
>         final int width = fp.getWidth();
>         final int height = fp.getHeight();
>         double shiftBy = 0.0;
>         final float[] pixels = (float[])fp.getPixels();
>         for (int y = 0; y < height; ++y) {
>             shiftBy += this.filter3(pixels, width, y * width, 1, type);
>         }
>         for (int x = 0; x < width; ++x) {
>             shiftBy += this.filter3(pixels, height, x, width, type);
>         }
>         return shiftBy / width / height;
>     }
>     
>     double filter3(final float[] pixels, final int length, final int pixel0, final int inc, final int type) {
>         double shiftBy = 0.0;
>         float v4;
>         float v3 = v4 = pixels[pixel0];
>         for (int i = 0, p = pixel0; i < length; ++i, p += inc) {
>             final float v5 = v4;
>             v4 = v3;
>             if (i < length - 1) {
>                 v3 = pixels[p + inc];
>             }
>             if (type == 0) {
>                 float max = (v5 > v3) ? v5 : v3;
>                 if (v4 > max) {
>                     max = v4;
>                 }
>                 shiftBy += max - v4;
>                 pixels[p] = max;
>             }
>             else {
>                 pixels[p] = (v5 + v4 + v3) * 0.33333334f;
>             }
>         }
>         return shiftBy;
>     }
>     
>     public void setNPasses(int nPasses) {
>         if (this.isRGB && this.separateColors) {
>             nPasses *= 3;
>         }
>         if (this.useParaboloid) {
>             nPasses *= (this.doPresmooth ? 11 : 9);
>         }
>         this.nPasses = nPasses;
>         this.pass = 0;
>     }
>     
>     private void showProgress(double percent) {
>         if (this.nPasses <= 0) {
>             return;
>         }
>         percent = this.pass / (double)this.nPasses + percent / this.nPasses;
>         IJ.showProgress(percent);
>     }
diff -r TrackAnalyzer_/checkable/CheckableItem.java procyon/checkable/CheckableItem.java
1,10c1,3
< package checkable;
< 
< public class CheckableItem {
<    public final String text;
<    private boolean selected;
< 
<    public CheckableItem(String text, boolean selected) {
<       this.text = text;
<       this.selected = selected;
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
12,18c5
<    public boolean isSelected() {
<       return this.selected;
<    }
< 
<    public void setSelected(boolean selected) {
<       this.selected = selected;
<    }
---
> package checkable;
20,22c7,28
<    public String toString() {
<       return this.text;
<    }
---
> public class CheckableItem
> {
>     public final String text;
>     private boolean selected;
>     
>     public CheckableItem(final String text, final boolean selected) {
>         this.text = text;
>         this.selected = selected;
>     }
>     
>     public boolean isSelected() {
>         return this.selected;
>     }
>     
>     public void setSelected(final boolean selected) {
>         this.selected = selected;
>     }
>     
>     @Override
>     public String toString() {
>         return this.text;
>     }
diff -r TrackAnalyzer_/checkable/CheckBoxCellRenderer.java procyon/checkable/CheckBoxCellRenderer.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,4c7
< import java.awt.Component;
< import java.util.Objects;
---
> import java.util.stream.Collector;
5a9,10
> import java.util.function.Function;
> import java.util.function.IntFunction;
6a12,15
> import javax.swing.ListModel;
> import java.util.Objects;
> import java.awt.Component;
> import javax.swing.JList;
9d17
< import javax.swing.JList;
11d18
< import javax.swing.ListModel;
13,25c20,39
< class CheckBoxCellRenderer<E extends CheckableItem> implements ListCellRenderer<E> {
<    private final JLabel label = new JLabel(" ");
<    private final JCheckBox check = new JCheckBox(" ");
< 
<    public Component getListCellRendererComponent(JList<? extends E> list, E value, int index, boolean isSelected, boolean cellHasFocus) {
<       if (index < 0) {
<          String txt = this.getCheckedItemString(list.getModel());
<          this.label.setText(txt.isEmpty() ? " " : txt);
<          return this.label;
<       } else {
<          this.check.setText(Objects.toString(value, ""));
<          this.check.setSelected(value.isSelected());
<          if (isSelected) {
---
> class CheckBoxCellRenderer<E extends CheckableItem> implements ListCellRenderer<E>
> {
>     private final JLabel label;
>     private final JCheckBox check;
>     
>     CheckBoxCellRenderer() {
>         this.label = new JLabel(" ");
>         this.check = new JCheckBox(" ");
>     }
>     
>     @Override
>     public Component getListCellRendererComponent(final JList<? extends E> list, final E value, final int index, final boolean isSelected, final boolean cellHasFocus) {
>         if (index < 0) {
>             final String txt = this.<? extends E>getCheckedItemString(list.getModel());
>             this.label.setText(txt.isEmpty() ? " " : txt);
>             return this.label;
>         }
>         this.check.setText(Objects.toString(value, ""));
>         this.check.setSelected(value.isSelected());
>         if (isSelected) {
28c42,43
<          } else {
---
>         }
>         else {
31,41c46,52
<          }
< 
<          return this.check;
<       }
<    }
< 
<    private <E extends CheckableItem> String getCheckedItemString(ListModel<E> model) {
<       IntStream var10000 = IntStream.range(0, model.getSize());
<       model.getClass();
<       return (String)var10000.mapToObj(model::getElementAt).filter(CheckableItem::isSelected).map(Objects::toString).sorted().collect(Collectors.joining(", "));
<    }
---
>         }
>         return this.check;
>     }
>     
>     private <E extends CheckableItem> String getCheckedItemString(final ListModel<E> model) {
>         return IntStream.range(0, model.getSize()).<Object>mapToObj((IntFunction<?>)model::getElementAt).filter(CheckableItem::isSelected).<Object>map((Function<? super Object, ?>)Objects::toString).sorted().<String, ?>collect((Collector<? super Object, ?, String>)Collectors.joining(", "));
>     }
diff -r TrackAnalyzer_/checkable/CheckedComboBox.java procyon/checkable/CheckedComboBox.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,5c7
< import java.awt.Dimension;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
---
> import javax.swing.Action;
6a9,10
> import javax.swing.plaf.basic.ComboPopup;
> import java.awt.event.ActionEvent;
8,9d11
< import javax.swing.ComboBoxModel;
< import javax.swing.JComboBox;
12,37c14,17
< import javax.swing.plaf.basic.ComboPopup;
< 
< public class CheckedComboBox<E extends CheckableItem> extends JComboBox<E> {
<    private boolean keepOpen;
<    private transient ActionListener listener;
< 
<    public CheckedComboBox() {
<    }
< 
<    public CheckedComboBox(ComboBoxModel<E> model) {
<       super(model);
<    }
< 
<    public Dimension getPreferredSize() {
<       return new Dimension(200, 20);
<    }
< 
<    public void updateUI() {
<       this.setRenderer((ListCellRenderer)null);
<       this.removeActionListener(this.listener);
<       super.updateUI();
<       this.listener = (e) -> {
<          if (((long)e.getModifiers() & 16L) != 0L) {
<             this.updateItem(this.getSelectedIndex());
<             this.keepOpen = true;
<          }
---
> import java.awt.Dimension;
> import javax.swing.ComboBoxModel;
> import java.awt.event.ActionListener;
> import javax.swing.JComboBox;
39,47c19,44
<       };
<       this.setRenderer(new CheckBoxCellRenderer());
<       this.addActionListener(this.listener);
<       this.getInputMap(0).put(KeyStroke.getKeyStroke(32, 0), "checkbox-select");
<       this.getActionMap().put("checkbox-select", new AbstractAction() {
<          public void actionPerformed(ActionEvent e) {
<             Accessible a = CheckedComboBox.this.getAccessibleContext().getAccessibleChild(0);
<             if (a instanceof ComboPopup) {
<                CheckedComboBox.this.updateItem(((ComboPopup)a).getList().getSelectedIndex());
---
> public class CheckedComboBox<E extends CheckableItem> extends JComboBox<E>
> {
>     private boolean keepOpen;
>     private transient ActionListener listener;
>     
>     public CheckedComboBox() {
>     }
>     
>     public CheckedComboBox(final ComboBoxModel<E> model) {
>         super(model);
>     }
>     
>     @Override
>     public Dimension getPreferredSize() {
>         return new Dimension(200, 20);
>     }
>     
>     @Override
>     public void updateUI() {
>         this.setRenderer(null);
>         this.removeActionListener(this.listener);
>         super.updateUI();
>         this.listener = (e -> {
>             if (((long)e.getModifiers() & 0x10L) != 0x0L) {
>                 this.updateItem(this.getSelectedIndex());
>                 this.keepOpen = true;
49,71c46,79
< 
<          }
<       });
<    }
< 
<    public void updateItem(int index) {
<       if (this.isPopupVisible()) {
<          E item = (CheckableItem)this.getItemAt(index);
<          item.setSelected(!item.isSelected());
<          this.setSelectedIndex(-1);
<          this.setSelectedItem(item);
<       }
< 
<    }
< 
<    public void setPopupVisible(boolean v) {
<       if (this.keepOpen) {
<          this.keepOpen = false;
<       } else {
<          super.setPopupVisible(v);
<       }
< 
<    }
---
>             return;
>         });
>         this.setRenderer(new CheckBoxCellRenderer<Object>());
>         this.addActionListener(this.listener);
>         this.getInputMap(0).put(KeyStroke.getKeyStroke(32, 0), "checkbox-select");
>         this.getActionMap().put("checkbox-select", new AbstractAction() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 final Accessible a = CheckedComboBox.this.getAccessibleContext().getAccessibleChild(0);
>                 if (a instanceof ComboPopup) {
>                     CheckedComboBox.this.updateItem(((ComboPopup)a).getList().getSelectedIndex());
>                 }
>             }
>         });
>     }
>     
>     public void updateItem(final int index) {
>         if (this.isPopupVisible()) {
>             final E item = this.getItemAt(index);
>             item.setSelected(!item.isSelected());
>             this.setSelectedIndex(-1);
>             this.setSelectedItem(item);
>         }
>     }
>     
>     @Override
>     public void setPopupVisible(final boolean v) {
>         if (this.keepOpen) {
>             this.keepOpen = false;
>         }
>         else {
>             super.setPopupVisible(v);
>         }
>     }
diff -r TrackAnalyzer_/Chemotaxis_ToolModified.java procyon/Chemotaxis_ToolModified.java
1,7d0
< import ij.IJ;
< import ij.WindowManager;
< import ij.gui.Plot;
< import ij.gui.PlotWindow;
< import ij.measure.ResultsTable;
< import ij.plugin.PlugIn;
< import java.awt.Color;
8a2,3
> import ij.WindowManager;
> import javax.swing.JFrame;
9a5,10
> import javax.swing.JTabbedPane;
> import javax.swing.event.ChangeEvent;
> import java.io.FileNotFoundException;
> import ij.IJ;
> import java.awt.Color;
> import ij.gui.Plot;
12,14c13,14
< import java.io.FileNotFoundException;
< import java.io.IOException;
< import java.util.ArrayList;
---
> import ij.measure.ResultsTable;
> import java.util.Collection;
16c16,19
< import java.util.Hashtable;
---
> import java.io.IOException;
> import java.awt.Component;
> import javax.swing.JOptionPane;
> import ij.gui.PlotWindow;
17a21
> import java.util.Hashtable;
19,112c23,24
< import javax.swing.JFrame;
< import javax.swing.JOptionPane;
< import javax.swing.JTabbedPane;
< import javax.swing.event.ChangeEvent;
< 
< public class Chemotaxis_ToolModified implements PlugIn {
<    ChemotaxisGUI gui;
<    ScalingDialog _dialog;
<    float[][] x_values;
<    float[][] y_values;
<    float _angleBetweenCircle;
<    float _angleBetweenDiagram;
<    ArrayList _openInfoWindows;
<    ArrayList _selectedDatasets;
<    ArrayList _currentOpenWindows;
<    ArrayList _currentOpenDiagrams;
<    Vector _maxVector;
<    int _maxPosition;
<    float _anglePosition;
<    int _currentSelectedDataset;
<    ArrayList _variableSliceNumber;
<    ArrayList _importedData;
<    Hashtable _hashSliceNumber;
<    LinkedList _listArrayList;
<    Hashtable _hashImportedDataset;
<    Hashtable _hashSlicesImported;
<    Hashtable _hashTracks;
<    Hashtable _hashCurrentDataset;
<    Hashtable _hashCurrentPosition;
<    Hashtable _hashPlot;
<    Hashtable _hashWindow;
<    float _coordSize;
<    float _calxy;
<    double _timeInterval;
<    String _unitsPath;
<    String _unitsTime;
<    int _plotHeight;
<    int _plotWidth;
<    ArrayList arrayToImport;
< 
<    public Chemotaxis_ToolModified(ArrayList arrayToImport) {
<       this.arrayToImport = arrayToImport;
<       this.gui = null;
<       this._dialog = null;
<       this._angleBetweenCircle = 66.0F;
<       this._angleBetweenDiagram = 66.0F;
<       this._maxVector = null;
<       this._maxPosition = 0;
<       this._anglePosition = 0.0F;
<       this._variableSliceNumber = null;
<       this._coordSize = 0.0F;
<       this._calxy = 1.0F;
<       this._timeInterval = 2.0D;
<    }
< 
<    public void run(String var1) {
<       PlotWindow.plotHeight = 500;
<       PlotWindow.plotWidth = 500;
<       this._plotHeight = 500;
<       this._plotWidth = 500;
<       (this._dialog = new ScalingDialog(this.gui)).setHeight(this._plotHeight);
<       this._dialog.setWidth(this._plotWidth);
<       this._openInfoWindows = new ArrayList();
<       this._hashImportedDataset = new Hashtable();
<       this._hashSlicesImported = new Hashtable();
<       this._hashTracks = new Hashtable();
<       this._hashCurrentDataset = new Hashtable();
<       this._hashCurrentPosition = new Hashtable();
<       this._hashPlot = new Hashtable();
<       this._hashWindow = new Hashtable();
<       this._currentOpenWindows = new ArrayList();
<       this._currentOpenDiagrams = new ArrayList();
<       this._importedData = new ArrayList();
<       this._hashSliceNumber = new Hashtable();
<       this._selectedDatasets = new ArrayList();
<       this._listArrayList = new LinkedList();
<       this._maxVector = new Vector();
<       this._selectedDatasets.clear();
<       this._hashSlicesImported.clear();
<       this._hashImportedDataset.clear();
<       this._importedData.clear();
<       this._hashSliceNumber.clear();
<       this._listArrayList.clear();
<       this._hashTracks.clear();
<       this._hashCurrentDataset.clear();
<       this._hashCurrentPosition.clear();
<       this._hashPlot.clear();
<       this._hashWindow.clear();
< 
<       try {
<          this.readData("prueba2.xls");
<       } catch (IOException var42) {
<          JOptionPane.showMessageDialog(this.gui, "Error reading from file");
<       }
---
> import java.util.ArrayList;
> import ij.plugin.PlugIn;
114,137c26,164
<       boolean b4 = true;
<       String item = "1: prueba2.xls";
<       ArrayList list16;
<       ArrayList value7;
<       if (this._hashSlicesImported.containsKey("1: prueba2.xls")) {
<          list16 = (ArrayList)this._hashSlicesImported.get("1: prueba2.xls");
<          if (list16.size() == 1) {
<             try {
<                list16 = new ArrayList();
<                this._hashSlicesImported.remove("1: prueba2.xls");
<                list16.add(1);
<                list16.add(SPTBatch_.imps.getStackSize());
<                if (Integer.valueOf(SPTBatch_.imps.getStackSize()) < Integer.valueOf("1")) {
<                   JOptionPane.showMessageDialog(this.gui, "Second value can`t be smaller than the first");
<                } else {
<                   this._hashSlicesImported.put("1: prueba2.xls", list16);
<                }
<             } catch (NumberFormatException var41) {
<                this.gui.firstSlicesField.setText("0");
<                this.gui.secondSlicesField.setText("0");
<                list16.add(new Integer(0));
<                list16.add(new Integer(0));
<                this._hashSlicesImported.put("1: prueba2.xls", list16);
<                JOptionPane.showMessageDialog(this.gui, "Please enter correct value for number of slices!");
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class Chemotaxis_ToolModified implements PlugIn
> {
>     ChemotaxisGUI gui;
>     ScalingDialog _dialog;
>     float[][] x_values;
>     float[][] y_values;
>     float _angleBetweenCircle;
>     float _angleBetweenDiagram;
>     ArrayList _openInfoWindows;
>     ArrayList _selectedDatasets;
>     ArrayList _currentOpenWindows;
>     ArrayList _currentOpenDiagrams;
>     Vector _maxVector;
>     int _maxPosition;
>     float _anglePosition;
>     int _currentSelectedDataset;
>     ArrayList _variableSliceNumber;
>     ArrayList _importedData;
>     Hashtable _hashSliceNumber;
>     LinkedList _listArrayList;
>     Hashtable _hashImportedDataset;
>     Hashtable _hashSlicesImported;
>     Hashtable _hashTracks;
>     Hashtable _hashCurrentDataset;
>     Hashtable _hashCurrentPosition;
>     Hashtable _hashPlot;
>     Hashtable _hashWindow;
>     float _coordSize;
>     float _calxy;
>     double _timeInterval;
>     String _unitsPath;
>     String _unitsTime;
>     int _plotHeight;
>     int _plotWidth;
>     ArrayList arrayToImport;
>     
>     public Chemotaxis_ToolModified(final ArrayList arrayToImport) {
>         this.arrayToImport = arrayToImport;
>         this.gui = null;
>         this._dialog = null;
>         this._angleBetweenCircle = 66.0f;
>         this._angleBetweenDiagram = 66.0f;
>         this._maxVector = null;
>         this._maxPosition = 0;
>         this._anglePosition = 0.0f;
>         this._variableSliceNumber = null;
>         this._coordSize = 0.0f;
>         this._calxy = 1.0f;
>         this._timeInterval = 2.0;
>     }
>     
>     public void run(final String var1) {
>         PlotWindow.plotHeight = 500;
>         PlotWindow.plotWidth = 500;
>         this._plotHeight = 500;
>         this._plotWidth = 500;
>         (this._dialog = new ScalingDialog(this.gui)).setHeight(this._plotHeight);
>         this._dialog.setWidth(this._plotWidth);
>         this._openInfoWindows = new ArrayList();
>         this._hashImportedDataset = new Hashtable();
>         this._hashSlicesImported = new Hashtable();
>         this._hashTracks = new Hashtable();
>         this._hashCurrentDataset = new Hashtable();
>         this._hashCurrentPosition = new Hashtable();
>         this._hashPlot = new Hashtable();
>         this._hashWindow = new Hashtable();
>         this._currentOpenWindows = new ArrayList();
>         this._currentOpenDiagrams = new ArrayList();
>         this._importedData = new ArrayList();
>         this._hashSliceNumber = new Hashtable();
>         this._selectedDatasets = new ArrayList();
>         this._listArrayList = new LinkedList();
>         this._maxVector = new Vector();
>         this._selectedDatasets.clear();
>         this._hashSlicesImported.clear();
>         this._hashImportedDataset.clear();
>         this._importedData.clear();
>         this._hashSliceNumber.clear();
>         this._listArrayList.clear();
>         this._hashTracks.clear();
>         this._hashCurrentDataset.clear();
>         this._hashCurrentPosition.clear();
>         this._hashPlot.clear();
>         this._hashWindow.clear();
>         try {
>             this.readData("prueba2.xls");
>         }
>         catch (IOException ex5) {
>             JOptionPane.showMessageDialog((Component)this.gui, "Error reading from file");
>         }
>         boolean b4 = true;
>         final String item = "1: prueba2.xls";
>         if (this._hashSlicesImported.containsKey("1: prueba2.xls")) {
>             ArrayList list16 = this._hashSlicesImported.get("1: prueba2.xls");
>             if (list16.size() == 1) {
>                 try {
>                     list16 = new ArrayList();
>                     this._hashSlicesImported.remove("1: prueba2.xls");
>                     list16.add(1);
>                     list16.add(SPTBatch_.imps.getStackSize());
>                     if (SPTBatch_.imps.getStackSize() < Integer.valueOf("1")) {
>                         JOptionPane.showMessageDialog((Component)this.gui, "Second value can`t be smaller than the first");
>                     }
>                     else {
>                         this._hashSlicesImported.put("1: prueba2.xls", list16);
>                     }
>                 }
>                 catch (NumberFormatException ex6) {
>                     this.gui.firstSlicesField.setText("0");
>                     this.gui.secondSlicesField.setText("0");
>                     list16.add(new Integer(0));
>                     list16.add(new Integer(0));
>                     this._hashSlicesImported.put("1: prueba2.xls", list16);
>                     JOptionPane.showMessageDialog((Component)this.gui, "Please enter correct value for number of slices!");
>                 }
>             }
>             if (list16.size() == 2) {
>                 try {
>                     if (Integer.valueOf(1) != list16.get(0) || Integer.valueOf(SPTBatch_.imps.getStackSize()) != list16.get(1)) {
>                         this._hashSlicesImported.remove("1: prueba2.xls");
>                         final ArrayList<Integer> value7 = new ArrayList<Integer>();
>                         value7.add(Integer.valueOf("1"));
>                         value7.add(SPTBatch_.imps.getStackSize());
>                         if (SPTBatch_.imps.getStackSize() < Integer.valueOf("1.0")) {
>                             JOptionPane.showMessageDialog((Component)this.gui, "Second value can`t be smaller than the first");
>                         }
>                         else {
>                             this._hashSlicesImported.put("1: prueba2.xls", value7);
>                         }
>                     }
>                 }
>                 catch (NumberFormatException ex7) {
>                     final ArrayList<Integer> list17 = this._hashSlicesImported.get("1: prueba2.xls");
>                     JOptionPane.showMessageDialog((Component)this.gui, "Setting old values!");
>                 }
139,141c166,167
<          }
< 
<          if (list16.size() == 2) {
---
>         }
>         else {
143,609c169,798
<                if (1 != list16.get(0) || SPTBatch_.imps.getStackSize() != list16.get(1)) {
<                   this._hashSlicesImported.remove("1: prueba2.xls");
<                   value7 = new ArrayList();
<                   value7.add(Integer.valueOf("1"));
<                   value7.add(SPTBatch_.imps.getStackSize());
<                   if (Integer.valueOf(SPTBatch_.imps.getStackSize()) < Integer.valueOf("1.0")) {
<                      JOptionPane.showMessageDialog(this.gui, "Second value can`t be smaller than the first");
<                   } else {
<                      this._hashSlicesImported.put("1: prueba2.xls", value7);
<                   }
<                }
<             } catch (NumberFormatException var43) {
<                ArrayList<Integer> list17 = (ArrayList)this._hashSlicesImported.get("1: prueba2.xls");
<                JOptionPane.showMessageDialog(this.gui, "Setting old values!");
<             }
<          }
<       } else {
<          try {
<             list16 = new ArrayList();
<             list16.add(Integer.valueOf("1"));
<             list16.add(SPTBatch_.imps.getStackSize());
<             if (Integer.valueOf(SPTBatch_.imps.getStackSize()) < Integer.valueOf("1")) {
<                b4 = false;
<                JOptionPane.showMessageDialog(this.gui, "Second value can`t be smaller than the first");
<             } else {
<                this._hashSlicesImported.put("1: prueba2.xls", list16);
<             }
<          } catch (NumberFormatException var40) {
<             b4 = false;
<             JOptionPane.showMessageDialog(this.gui, "Please enter correct value for number of slices!");
<          }
<       }
< 
<       boolean b5 = true;
<       this._maxVector.clear();
<       value7 = new ArrayList();
<       String s20 = "1: prueba2.xls";
<       if (!value7.contains("1: prueba2.xls")) {
<          value7.add("1: prueba2.xls");
<       }
< 
<       this._unitsPath = "m";
<       this._unitsTime = "min";
<       int intValue31 = false;
<       int intValue32 = false;
<       int n68 = false;
<       double n69 = 0.0D;
<       double doubleValue = 0.0D;
<       int n70 = false;
<       double n71 = 0.0D;
<       double doubleValue2 = 0.0D;
<       this._calxy = new Float(1.0D);
<       this._timeInterval = new Double(1.0D);
<       b5 = true;
<       int n72;
<       String s10;
<       ArrayList list20;
<       int intValue16;
<       ArrayList list14;
<       ArrayList list23;
<       ArrayList list15;
<       int n94;
<       int n13;
<       int index27;
<       int index21;
<       int intValue30;
<       int index28;
<       int intValue44;
<       int n93;
<       if (b5) {
<          this._listArrayList.clear();
<          this._hashCurrentDataset.clear();
<          this._hashSliceNumber.clear();
< 
<          for(n72 = 0; n72 < value7.size(); ++n72) {
<             this._variableSliceNumber = new ArrayList();
<             s10 = (String)value7.get(n72);
<             this._hashCurrentDataset.put(new Integer(n72), s10);
<             this._hashCurrentPosition.put(s10, new Integer(n72));
<             list20 = (ArrayList)this._hashSlicesImported.get(s10);
<             intValue16 = (Integer)this._hashImportedDataset.get(s10);
<             list14 = new ArrayList();
<             ArrayList<Float> list22 = new ArrayList();
<             list23 = new ArrayList();
<             list15 = (ArrayList)this._importedData.get(intValue16 - 1);
< 
<             for(n94 = 0; n94 < list15.size(); n94 += 4) {
<                list14.add(list15.get(n94));
<                list22.add((Float)list15.get(n94 + 2));
<                list23.add((Float)list15.get(n94 + 3));
<             }
< 
<             n94 = Math.round((Float)list14.get(list14.size() - 1));
<             int[] array70 = new int[3 * n94];
<             n13 = 1;
< 
<             for(index27 = 0; index27 <= 3 * n94 - 3; index27 += 3) {
<                array70[index27] = list14.indexOf(new Float((float)n13));
<                array70[index27 + 1] = list14.lastIndexOf(new Float((float)n13));
<                array70[index27 + 2] = n13++;
<             }
< 
<             ArrayList<Float> list25 = new ArrayList();
<             ArrayList<Float> list26 = new ArrayList();
<             int n75 = 0;
<             if (list20.size() == 1) {
<                index21 = (Integer)list20.get(0);
< 
<                for(intValue30 = 0; intValue30 <= array70.length - 3; intValue30 += 3) {
<                   if (array70[intValue30 + 1] != -1 && array70[intValue30] != -1 && array70[intValue30 + 1] - array70[intValue30] == index21 - 1) {
<                      ++n75;
<                      this._variableSliceNumber.add(new Integer(array70[intValue30 + 1] - array70[intValue30] + 1));
< 
<                      for(index28 = array70[intValue30]; index28 <= array70[intValue30 + 1]; ++index28) {
<                         list25.add(new Float((Float)list22.get(index28) * this._calxy));
<                         list26.add(new Float((Float)list23.get(index28) * this._calxy));
<                      }
<                   }
<                }
<             }
< 
<             if (list20.size() == 2) {
<                index21 = (Integer)list20.get(0);
<                intValue30 = (Integer)list20.get(1);
< 
<                for(index28 = 0; index28 <= array70.length - 3; index28 += 3) {
<                   if (array70[index28 + 1] != -1 && array70[index28] != -1 && array70[index28 + 1] - array70[index28] >= index21 - 1 && array70[index28 + 1] - array70[index28] <= intValue30 - 1) {
<                      ++n75;
<                      this._variableSliceNumber.add(new Integer(array70[index28 + 1] - array70[index28] + 1));
< 
<                      for(intValue44 = array70[index28]; intValue44 <= array70[index28 + 1]; ++intValue44) {
<                         list25.add(new Float((Float)list22.get(intValue44) * this._calxy));
<                         list26.add(new Float((Float)list23.get(intValue44) * this._calxy));
<                      }
<                   }
<                }
<             }
< 
<             this.updateNumberofTracks(s10, n75);
<             if (this._variableSliceNumber.isEmpty()) {
<                if (list20.size() == 1) {
<                   JOptionPane.showMessageDialog(this.gui, "No tracks available for current number of slices");
<                }
< 
<                if (list20.size() == 2) {
<                   JOptionPane.showMessageDialog(this.gui, "No tracks available for current range of used number of slices");
<                }
<             } else {
<                index21 = (Integer)Collections.max(this._variableSliceNumber);
<                intValue30 = 0;
<                this.x_values = new float[n75][index21];
<                this.y_values = new float[n75][index21];
< 
<                for(index28 = 0; index28 < n75; ++index28) {
<                   this.x_values[index28][0] = 0.0F;
<                   this.y_values[index28][0] = 0.0F;
<                   intValue44 = 1;
< 
<                   for(n93 = (Integer)this._variableSliceNumber.get(index28); intValue44 < n93; ++intValue44) {
<                      float n90 = (Float)list25.get(intValue44 + intValue30) - (Float)list25.get(intValue30);
<                      float n91 = -((Float)list26.get(intValue44 + intValue30) - (Float)list26.get(intValue30));
<                      this.x_values[index28][intValue44] = n90;
<                      this.y_values[index28][intValue44] = n91;
<                   }
< 
<                   intValue30 += n93;
<                }
< 
<                this._listArrayList.add(this.x_values);
<                this._listArrayList.add(this.y_values);
<                this._hashSliceNumber.put(new Integer(n72), this._variableSliceNumber);
<             }
<          }
<       }
< 
<       int n65;
<       float[][] array16;
<       float[][] array13;
<       ResultsTable resultsTable3;
<       String[] array11;
<       int intValue29;
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          n65 = (Integer)Collections.max(list20);
<          array16 = (float[][])this._listArrayList.get(n72);
<          array13 = (float[][])this._listArrayList.get(n72 + 1);
<          resultsTable3 = new ResultsTable();
<          array11 = new String[]{"Slice", "Center of mass x [" + this._unitsPath + "]", "Center of mass y [" + this._unitsPath + "]", "Center of mass length [" + this._unitsPath + "]"};
< 
<          for(intValue29 = 0; intValue29 < array11.length; ++intValue29) {
<             resultsTable3.setHeading(intValue29, array11[intValue29]);
<          }
< 
<          for(intValue29 = 1; intValue29 <= n65; ++intValue29) {
<             double[] centerofMassSeries = ChemotaxisStatistic.centerofMassSeries(intValue29, array16, array13, intValue16, list20);
<             resultsTable3.incrementCounter();
<             resultsTable3.addValue(0, (double)intValue29);
<             resultsTable3.addValue(1, centerofMassSeries[0]);
<             resultsTable3.addValue(2, centerofMassSeries[1]);
<             resultsTable3.addValue(3, centerofMassSeries[2]);
<          }
< 
<          resultsTable3.save(SPTBatch_.directChemo + File.separator + "Center of mass series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       double n9;
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)Collections.max(list20);
<          n65 = (Integer)this._hashTracks.get(s10);
<          array16 = (float[][])this._listArrayList.get(n72);
<          array13 = (float[][])this._listArrayList.get(n72 + 1);
<          resultsTable3 = new ResultsTable();
<          array11 = new String[]{"Slice", "Directionality"};
< 
<          for(intValue29 = 0; intValue29 < array11.length; ++intValue29) {
<             resultsTable3.setHeading(intValue29, array11[intValue29]);
<          }
< 
<          for(intValue29 = 1; intValue29 <= intValue16; ++intValue29) {
<             n9 = ChemotaxisStatistic.computeChemotaxisIndex(array16, array13, intValue29, n65, list20);
<             resultsTable3.incrementCounter();
<             resultsTable3.addValue(0, (double)intValue29);
<             resultsTable3.addValue(1, n9);
<          }
< 
<          resultsTable3.save(SPTBatch_.directChemo + File.separator + "Directionality series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          n65 = (Integer)Collections.max(list20);
<          array16 = (float[][])this._listArrayList.get(n72);
<          array13 = (float[][])this._listArrayList.get(n72 + 1);
<          resultsTable3 = new ResultsTable();
<          array11 = new String[]{"Slice", "x FMI", "y FMI"};
< 
<          for(intValue29 = 0; intValue29 < array11.length; ++intValue29) {
<             resultsTable3.setHeading(intValue29, array11[intValue29]);
<          }
< 
<          for(intValue29 = 1; intValue29 <= n65; ++intValue29) {
<             n9 = ChemotaxisStatistic.computeFMIIndex(array16, array13, intValue29, intValue16, 1, list20);
<             double computeFMIIndex2 = ChemotaxisStatistic.computeFMIIndex(array16, array13, intValue29, intValue16, 2, list20);
<             resultsTable3.incrementCounter();
<             resultsTable3.addValue(0, (double)intValue29);
<             resultsTable3.addValue(1, computeFMIIndex2);
<             resultsTable3.addValue(2, n9);
<          }
< 
<          resultsTable3.save(SPTBatch_.directChemo + File.separator + "FMI index series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       float[][] array15;
<       float roundFloatNumbers2;
<       float roundFloatNumbers3;
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          array15 = (float[][])this._listArrayList.get(n72);
<          array16 = (float[][])this._listArrayList.get(n72 + 1);
<          list23 = ChemotaxisStatistic.computeDirectionality(array15, array16, list20, intValue16);
<          resultsTable3 = new ResultsTable();
<          array11 = new String[]{"Track Number", "Directionality", "Endpoint X Value", "Endpoint Y Value"};
< 
<          for(intValue29 = 0; intValue29 < array11.length; ++intValue29) {
<             resultsTable3.setHeading(intValue29, array11[intValue29]);
<          }
< 
<          for(intValue29 = 0; intValue29 < intValue16; ++intValue29) {
<             n13 = (Integer)list20.get(intValue29);
<             roundFloatNumbers2 = array15[intValue29][n13 - 1];
<             roundFloatNumbers3 = array16[intValue29][n13 - 1];
<             resultsTable3.incrementCounter();
<             resultsTable3.addValue(0, (double)(intValue29 + 1));
<             resultsTable3.addValue(1, (Double)list23.get(intValue29));
<             resultsTable3.addValue(2, (double)new Float(roundFloatNumbers2));
<             resultsTable3.addValue(3, (double)new Float(roundFloatNumbers3));
<          }
< 
<          resultsTable3.save(SPTBatch_.directChemo + File.separator + "Directionality track series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       int intValue43;
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          array15 = (float[][])this._listArrayList.get(n72);
<          array16 = (float[][])this._listArrayList.get(n72 + 1);
<          ResultsTable resultsTable5 = new ResultsTable();
<          String[] array17 = new String[]{"Track Number", "x FMI", "y FMI", "Endpoint X Value", "Endpoint Y Value"};
< 
<          for(n94 = 0; n94 < array17.length; ++n94) {
<             resultsTable5.setHeading(n94, array17[n94]);
<          }
< 
<          for(n94 = 0; n94 < intValue16; ++n94) {
<             intValue29 = (Integer)list20.get(n94);
<             n9 = 0.0D;
< 
<             for(intValue43 = 0; intValue43 < intValue29 - 1; ++intValue43) {
<                n9 += Point2D.distance((double)new Float(array15[n94][intValue43]), (double)new Float(array16[n94][intValue43]), (double)new Float(array15[n94][intValue43 + 1]), (double)new Float(array16[n94][intValue43 + 1]));
<             }
< 
<             roundFloatNumbers3 = array16[n94][intValue29 - 1];
<             float value4 = array15[n94][intValue29 - 1];
<             double roundDoubleNumbers = this.roundDoubleNumbers((double)value4 / n9);
<             double roundDoubleNumbers2 = this.roundDoubleNumbers((double)roundFloatNumbers3 / n9);
<             resultsTable5.incrementCounter();
<             resultsTable5.addValue(0, (double)(n94 + 1));
<             resultsTable5.addValue(1, roundDoubleNumbers);
<             resultsTable5.addValue(2, roundDoubleNumbers2);
<             resultsTable5.addValue(3, (double)new Float(value4));
<             resultsTable5.addValue(4, (double)new Float(roundFloatNumbers3));
<          }
< 
<          resultsTable5.save(SPTBatch_.directChemo + File.separator + "FMI track series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       float abs;
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          list14 = ChemotaxisStatistic.computeDistandVelocity("velocity", (float[][])this._listArrayList.get(n72), (float[][])this._listArrayList.get(n72 + 1), list20, intValue16, this._timeInterval);
<          ResultsTable resultsTable6 = new ResultsTable();
<          String[] array18 = new String[]{"Track Number", "Velocity [" + this._unitsPath + "/" + this._unitsTime + "]"};
< 
<          int index9;
<          for(index9 = 0; index9 < array18.length; ++index9) {
<             resultsTable6.setHeading(index9, array18[index9]);
<          }
< 
<          for(index9 = 0; index9 < intValue16; ++index9) {
<             abs = this.roundFloatNumbers(Float.valueOf(list14.get(index9).toString()));
<             resultsTable6.incrementCounter();
<             resultsTable6.addValue(0, (double)(index9 + 1));
<             resultsTable6.addValue(1, (double)abs);
<          }
< 
<          resultsTable6.save(SPTBatch_.directChemo + File.separator + "Velocity series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          array15 = (float[][])this._listArrayList.get(n72);
<          array16 = (float[][])this._listArrayList.get(n72 + 1);
<          list23 = ChemotaxisStatistic.computeDistandVelocity("accumulated distance", array15, array16, list20, intValue16, this._timeInterval);
<          list15 = ChemotaxisStatistic.computeDistandVelocity("euclid distance", array15, array16, list20, intValue16, this._timeInterval);
<          ResultsTable resultsTable7 = new ResultsTable();
<          String[] array21 = new String[]{"Track Number", "Accumulated distance [" + this._unitsPath + "]", "Euclidean distance [" + this._unitsPath + "]"};
< 
<          for(n13 = 0; n13 < array21.length; ++n13) {
<             resultsTable7.setHeading(n13, array21[n13]);
<          }
< 
<          for(n13 = 0; n13 < intValue16; ++n13) {
<             roundFloatNumbers2 = this.roundFloatNumbers(Float.valueOf(list23.get(n13).toString()));
<             roundFloatNumbers3 = this.roundFloatNumbers(Float.valueOf(list15.get(n13).toString()));
<             resultsTable7.incrementCounter();
<             resultsTable7.addValue(0, (double)(n13 + 1));
<             resultsTable7.addValue(1, (double)roundFloatNumbers2);
<             resultsTable7.addValue(2, (double)roundFloatNumbers3);
<          }
< 
<          resultsTable7.save(SPTBatch_.directChemo + File.separator + "Distance series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       String s18 = "1: prueba2.xls";
<       int intValue27 = (Integer)this._hashImportedDataset.get("1: prueba2.xls");
<       ResultsTable resultsTable13 = new ResultsTable();
<       String[] array66 = new String[]{"Track n", "Slice n", "X", "Y"};
< 
<       for(n65 = 0; n65 < array66.length; ++n65) {
<          resultsTable13.setHeading(n65, array66[n65]);
<       }
< 
<       list14 = (ArrayList)this._importedData.get(intValue27 - 1);
< 
<       for(int index19 = 0; index19 < list14.size(); index19 += 4) {
<          resultsTable13.incrementCounter();
<          resultsTable13.addValue(0, (double)(Float)list14.get(index19));
<          resultsTable13.addValue(1, (double)(Float)list14.get(index19 + 1));
<          resultsTable13.addValue(2, (double)(Float)list14.get(index19 + 2));
<          resultsTable13.addValue(3, (double)(Float)list14.get(index19 + 3));
<       }
< 
<       resultsTable13.save(SPTBatch_.directChemo + File.separator + "Original data for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       String s19 = "1: prueba2.xls";
<       if (this._hashCurrentDataset.contains("1: prueba2.xls")) {
<          int intValue28 = (Integer)this._hashCurrentPosition.get("1: prueba2.xls");
<          list15 = (ArrayList)this._hashSliceNumber.get(new Integer(intValue28));
<          n94 = intValue28 * 2;
<          intValue29 = (Integer)this._hashTracks.get("1: prueba2.xls");
<          float[][] array67 = (float[][])this._listArrayList.get(n94);
<          float[][] array68 = (float[][])this._listArrayList.get(n94 + 1);
<          ResultsTable resultsTable14 = new ResultsTable();
<          String[] array69 = new String[]{"Track n", "Slice n", "X [" + this._unitsPath + "]", "Y [" + this._unitsPath + "]"};
< 
<          for(index21 = 0; index21 < array69.length; ++index21) {
<             resultsTable14.setHeading(index21, array69[index21]);
<          }
< 
<          for(index21 = 0; index21 < intValue29; ++index21) {
<             intValue30 = (Integer)list15.get(index21);
< 
<             for(index28 = 0; index28 < intValue30; ++index28) {
<                resultsTable14.incrementCounter();
<                resultsTable14.addValue(0, (double)new Integer(index21 + 1));
<                resultsTable14.addValue(1, (double)new Integer(index28 + 1));
<                resultsTable14.addValue(2, (double)new Float(array67[index21][index28]));
<                resultsTable14.addValue(3, (double)new Float(array68[index21][index28]));
<             }
<          }
< 
<          resultsTable14.save(SPTBatch_.directChemo + File.separator + "Current used data for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       } else {
<          JOptionPane.showMessageDialog(this.gui, "No current data available!");
<       }
< 
<       this._hashPlot.clear();
<       int n92 = 0;
<       String s27 = "Mark up/down";
<       if ("Mark up/down".equals("Mark up/down")) {
<          n92 = 3;
<       }
< 
<       if (this._dialog.auto) {
<          abs = 0.0F;
<          float abs2 = 0.0F;
<          if (this._listArrayList.size() > 1) {
<             ArrayList coll4 = new ArrayList();
< 
<             for(index27 = 0; index27 < this._listArrayList.size(); index27 += 2) {
<                intValue43 = (Integer)this._hashTracks.get(this._hashCurrentDataset.get(new Integer(index27 / 2)));
<                ArrayList<Integer> list27 = (ArrayList)this._hashSliceNumber.get(new Integer(index27 / 2));
<                float[][] array71 = (float[][])this._listArrayList.get(index27);
<                float[][] array72 = (float[][])this._listArrayList.get(index27 + 1);
< 
<                for(index28 = 0; index28 < intValue43; ++index28) {
<                   intValue44 = (Integer)list27.get(index28);
< 
<                   for(n93 = 1; n93 < intValue44; ++n93) {
<                      if (abs < Math.abs(array71[index28][n93])) {
<                         abs = Math.abs(array71[index28][n93]);
<                      }
< 
<                      if (abs2 < Math.abs(array72[index28][n93])) {
<                         abs2 = Math.abs(array72[index28][n93]);
<                      }
<                   }
<                }
< 
<                if (abs > abs2) {
<                   coll4.add(new Float(abs));
<                } else {
<                   coll4.add(new Float(abs2));
<                }
---
>                 final ArrayList<Integer> value8 = new ArrayList<Integer>();
>                 value8.add(Integer.valueOf("1"));
>                 value8.add(SPTBatch_.imps.getStackSize());
>                 if (SPTBatch_.imps.getStackSize() < Integer.valueOf("1")) {
>                     b4 = false;
>                     JOptionPane.showMessageDialog((Component)this.gui, "Second value can`t be smaller than the first");
>                 }
>                 else {
>                     this._hashSlicesImported.put("1: prueba2.xls", value8);
>                 }
>             }
>             catch (NumberFormatException ex8) {
>                 b4 = false;
>                 JOptionPane.showMessageDialog((Component)this.gui, "Please enter correct value for number of slices!");
>             }
>         }
>         boolean b5 = true;
>         this._maxVector.clear();
>         final ArrayList<String> list18 = new ArrayList<String>();
>         final String s20 = "1: prueba2.xls";
>         if (!list18.contains("1: prueba2.xls")) {
>             list18.add("1: prueba2.xls");
>         }
>         this._unitsPath = "m";
>         this._unitsTime = "min";
>         final int intValue31 = 0;
>         final int intValue32 = 0;
>         final int n68 = 0;
>         final double n69 = 0.0;
>         final double doubleValue = 0.0;
>         final int n70 = 0;
>         final double n71 = 0.0;
>         final double doubleValue2 = 0.0;
>         this._calxy = new Float(1.0);
>         this._timeInterval = new Double(1.0);
>         b5 = true;
>         if (b5) {
>             this._listArrayList.clear();
>             this._hashCurrentDataset.clear();
>             this._hashSliceNumber.clear();
>             for (int n72 = 0; n72 < list18.size(); ++n72) {
>                 this._variableSliceNumber = new ArrayList();
>                 final String s21 = list18.get(n72);
>                 this._hashCurrentDataset.put(new Integer(n72), s21);
>                 this._hashCurrentPosition.put(s21, new Integer(n72));
>                 final ArrayList<Integer> list19 = this._hashSlicesImported.get(s21);
>                 final int intValue33 = this._hashImportedDataset.get(s21);
>                 final ArrayList list20 = new ArrayList();
>                 final ArrayList<Float> list21 = new ArrayList<Float>();
>                 final ArrayList<Float> list22 = new ArrayList<Float>();
>                 final ArrayList<Object> list23 = this._importedData.get(intValue33 - 1);
>                 for (int index24 = 0; index24 < list23.size(); index24 += 4) {
>                     list20.add(list23.get(index24));
>                     list21.add(list23.get(index24 + 2));
>                     list22.add(list23.get(index24 + 3));
>                 }
>                 final int intValue34 = Math.round(list20.get(list20.size() - 1));
>                 final int[] array70 = new int[3 * intValue34];
>                 int n73 = 1;
>                 for (int n74 = 0; n74 <= 3 * intValue34 - 3; n74 += 3) {
>                     array70[n74] = list20.indexOf(new Float((float)n73));
>                     array70[n74 + 1] = list20.lastIndexOf(new Float((float)n73));
>                     array70[n74 + 2] = n73;
>                     ++n73;
>                 }
>                 final ArrayList<Float> list24 = new ArrayList<Float>();
>                 final ArrayList<Float> list25 = new ArrayList<Float>();
>                 int n75 = 0;
>                 if (list19.size() == 1) {
>                     final int intValue35 = list19.get(0);
>                     for (int n76 = 0; n76 <= array70.length - 3; n76 += 3) {
>                         if (array70[n76 + 1] != -1 && array70[n76] != -1 && array70[n76 + 1] - array70[n76] == intValue35 - 1) {
>                             ++n75;
>                             this._variableSliceNumber.add(new Integer(array70[n76 + 1] - array70[n76] + 1));
>                             for (int n77 = array70[n76]; n77 <= array70[n76 + 1]; ++n77) {
>                                 list24.add(new Float(list21.get(n77) * this._calxy));
>                                 list25.add(new Float(list22.get(n77) * this._calxy));
>                             }
>                         }
>                     }
>                 }
>                 if (list19.size() == 2) {
>                     final int intValue36 = list19.get(0);
>                     final int intValue37 = list19.get(1);
>                     for (int n78 = 0; n78 <= array70.length - 3; n78 += 3) {
>                         if (array70[n78 + 1] != -1 && array70[n78] != -1 && array70[n78 + 1] - array70[n78] >= intValue36 - 1 && array70[n78 + 1] - array70[n78] <= intValue37 - 1) {
>                             ++n75;
>                             this._variableSliceNumber.add(new Integer(array70[n78 + 1] - array70[n78] + 1));
>                             for (int n79 = array70[n78]; n79 <= array70[n78 + 1]; ++n79) {
>                                 list24.add(new Float(list21.get(n79) * this._calxy));
>                                 list25.add(new Float(list22.get(n79) * this._calxy));
>                             }
>                         }
>                     }
>                 }
>                 this.updateNumberofTracks(s21, n75);
>                 if (this._variableSliceNumber.isEmpty()) {
>                     if (list19.size() == 1) {
>                         JOptionPane.showMessageDialog((Component)this.gui, "No tracks available for current number of slices");
>                     }
>                     if (list19.size() == 2) {
>                         JOptionPane.showMessageDialog((Component)this.gui, "No tracks available for current range of used number of slices");
>                     }
>                 }
>                 else {
>                     final int intValue38 = Collections.<Integer>max((Collection<? extends Integer>)this._variableSliceNumber);
>                     int n80 = 0;
>                     this.x_values = new float[n75][intValue38];
>                     this.y_values = new float[n75][intValue38];
>                     for (int index25 = 0; index25 < n75; ++index25) {
>                         this.x_values[index25][0] = 0.0f;
>                         this.y_values[index25][0] = 0.0f;
>                         int n81;
>                         int intValue39;
>                         for (n81 = 1, intValue39 = this._variableSliceNumber.get(index25); n81 < intValue39; ++n81) {
>                             final float n82 = list24.get(n81 + n80) - list24.get(n80);
>                             final float n83 = -(list25.get(n81 + n80) - list25.get(n80));
>                             this.x_values[index25][n81] = n82;
>                             this.y_values[index25][n81] = n83;
>                         }
>                         n80 += intValue39;
>                     }
>                     this._listArrayList.add(this.x_values);
>                     this._listArrayList.add(this.y_values);
>                     this._hashSliceNumber.put(new Integer(n72), this._variableSliceNumber);
>                 }
>             }
>         }
>         for (int j = 0; j < this._listArrayList.size(); j += 2) {
>             final String s22 = this._hashCurrentDataset.get(new Integer(j / 2));
>             final ArrayList coll = this._hashSliceNumber.get(new Integer(j / 2));
>             final int intValue40 = this._hashTracks.get(s22);
>             final int intValue41 = Collections.<Integer>max((Collection<? extends Integer>)coll);
>             final float[][] array71 = this._listArrayList.get(j);
>             final float[][] array72 = this._listArrayList.get(j + 1);
>             final ResultsTable resultsTable = new ResultsTable();
>             final String[] array73 = { "Slice", "Center of mass x [" + this._unitsPath + "]", "Center of mass y [" + this._unitsPath + "]", "Center of mass length [" + this._unitsPath + "]" };
>             for (int k = 0; k < array73.length; ++k) {
>                 resultsTable.setHeading(k, array73[k]);
>             }
>             for (int l = 1; l <= intValue41; ++l) {
>                 final double[] centerofMassSeries = ChemotaxisStatistic.centerofMassSeries(l, array71, array72, intValue40, coll);
>                 resultsTable.incrementCounter();
>                 resultsTable.addValue(0, (double)l);
>                 resultsTable.addValue(1, centerofMassSeries[0]);
>                 resultsTable.addValue(2, centerofMassSeries[1]);
>                 resultsTable.addValue(3, centerofMassSeries[2]);
>             }
>             resultsTable.save(SPTBatch_.directChemo + File.separator + "Center of mass series for " + SPTBatch_.imps.getShortTitle() + ".xls");
>         }
>         for (int index26 = 0; index26 < this._listArrayList.size(); index26 += 2) {
>             final String s23 = this._hashCurrentDataset.get(new Integer(index26 / 2));
>             final ArrayList coll2 = this._hashSliceNumber.get(new Integer(index26 / 2));
>             final int intValue42 = Collections.<Integer>max((Collection<? extends Integer>)coll2);
>             final int intValue43 = this._hashTracks.get(s23);
>             final float[][] array74 = this._listArrayList.get(index26);
>             final float[][] array75 = this._listArrayList.get(index26 + 1);
>             final ResultsTable resultsTable2 = new ResultsTable();
>             final String[] array76 = { "Slice", "Directionality" };
>             for (int n84 = 0; n84 < array76.length; ++n84) {
>                 resultsTable2.setHeading(n84, array76[n84]);
>             }
>             for (int n85 = 1; n85 <= intValue42; ++n85) {
>                 final double computeChemotaxisIndex = ChemotaxisStatistic.computeChemotaxisIndex(array74, array75, n85, intValue43, coll2);
>                 resultsTable2.incrementCounter();
>                 resultsTable2.addValue(0, (double)n85);
>                 resultsTable2.addValue(1, computeChemotaxisIndex);
>             }
>             resultsTable2.save(SPTBatch_.directChemo + File.separator + "Directionality series for " + SPTBatch_.imps.getShortTitle() + ".xls");
>         }
>         for (int index27 = 0; index27 < this._listArrayList.size(); index27 += 2) {
>             final String s24 = this._hashCurrentDataset.get(new Integer(index27 / 2));
>             final ArrayList coll3 = this._hashSliceNumber.get(new Integer(index27 / 2));
>             final int intValue44 = this._hashTracks.get(s24);
>             final int intValue45 = Collections.<Integer>max((Collection<? extends Integer>)coll3);
>             final float[][] array77 = this._listArrayList.get(index27);
>             final float[][] array78 = this._listArrayList.get(index27 + 1);
>             final ResultsTable resultsTable3 = new ResultsTable();
>             final String[] array79 = { "Slice", "x FMI", "y FMI" };
>             for (int n86 = 0; n86 < array79.length; ++n86) {
>                 resultsTable3.setHeading(n86, array79[n86]);
>             }
>             for (int n87 = 1; n87 <= intValue45; ++n87) {
>                 final double computeFMIIndex = ChemotaxisStatistic.computeFMIIndex(array77, array78, n87, intValue44, 1, coll3);
>                 final double computeFMIIndex2 = ChemotaxisStatistic.computeFMIIndex(array77, array78, n87, intValue44, 2, coll3);
>                 resultsTable3.incrementCounter();
>                 resultsTable3.addValue(0, (double)n87);
>                 resultsTable3.addValue(1, computeFMIIndex2);
>                 resultsTable3.addValue(2, computeFMIIndex);
>             }
>             resultsTable3.save(SPTBatch_.directChemo + File.separator + "FMI index series for " + SPTBatch_.imps.getShortTitle() + ".xls");
>         }
>         for (int index28 = 0; index28 < this._listArrayList.size(); index28 += 2) {
>             final String s25 = this._hashCurrentDataset.get(new Integer(index28 / 2));
>             final ArrayList<Integer> list26 = this._hashSliceNumber.get(new Integer(index28 / 2));
>             final int intValue46 = this._hashTracks.get(s25);
>             final float[][] array80 = this._listArrayList.get(index28);
>             final float[][] array81 = this._listArrayList.get(index28 + 1);
>             final ArrayList computeDirectionality = ChemotaxisStatistic.computeDirectionality(array80, array81, (ArrayList)list26, intValue46);
>             final ResultsTable resultsTable4 = new ResultsTable();
>             final String[] array82 = { "Track Number", "Directionality", "Endpoint X Value", "Endpoint Y Value" };
>             for (int n88 = 0; n88 < array82.length; ++n88) {
>                 resultsTable4.setHeading(n88, array82[n88]);
>             }
>             for (int n89 = 0; n89 < intValue46; ++n89) {
>                 final int intValue47 = list26.get(n89);
>                 final float value9 = array80[n89][intValue47 - 1];
>                 final float value10 = array81[n89][intValue47 - 1];
>                 resultsTable4.incrementCounter();
>                 resultsTable4.addValue(0, (double)(n89 + 1));
>                 resultsTable4.addValue(1, (double)computeDirectionality.get(n89));
>                 resultsTable4.addValue(2, (double)new Float(value9));
>                 resultsTable4.addValue(3, (double)new Float(value10));
>             }
>             resultsTable4.save(SPTBatch_.directChemo + File.separator + "Directionality track series for " + SPTBatch_.imps.getShortTitle() + ".xls");
>         }
>         for (int index29 = 0; index29 < this._listArrayList.size(); index29 += 2) {
>             final String s26 = this._hashCurrentDataset.get(new Integer(index29 / 2));
>             final ArrayList<Integer> list27 = this._hashSliceNumber.get(new Integer(index29 / 2));
>             final int intValue48 = this._hashTracks.get(s26);
>             final float[][] array83 = this._listArrayList.get(index29);
>             final float[][] array84 = this._listArrayList.get(index29 + 1);
>             final ResultsTable resultsTable5 = new ResultsTable();
>             final String[] array85 = { "Track Number", "x FMI", "y FMI", "Endpoint X Value", "Endpoint Y Value" };
>             for (int n90 = 0; n90 < array85.length; ++n90) {
>                 resultsTable5.setHeading(n90, array85[n90]);
>             }
>             for (int index30 = 0; index30 < intValue48; ++index30) {
>                 final int intValue49 = list27.get(index30);
>                 double n91 = 0.0;
>                 for (int n92 = 0; n92 < intValue49 - 1; ++n92) {
>                     n91 += Point2D.distance(new Float(array83[index30][n92]), new Float(array84[index30][n92]), new Float(array83[index30][n92 + 1]), new Float(array84[index30][n92 + 1]));
>                 }
>                 final float value11 = array84[index30][intValue49 - 1];
>                 final float value12 = array83[index30][intValue49 - 1];
>                 final double roundDoubleNumbers = this.roundDoubleNumbers(value12 / n91);
>                 final double roundDoubleNumbers2 = this.roundDoubleNumbers(value11 / n91);
>                 resultsTable5.incrementCounter();
>                 resultsTable5.addValue(0, (double)(index30 + 1));
>                 resultsTable5.addValue(1, roundDoubleNumbers);
>                 resultsTable5.addValue(2, roundDoubleNumbers2);
>                 resultsTable5.addValue(3, (double)new Float(value12));
>                 resultsTable5.addValue(4, (double)new Float(value11));
>             }
>             resultsTable5.save(SPTBatch_.directChemo + File.separator + "FMI track series for " + SPTBatch_.imps.getShortTitle() + ".xls");
>         }
>         for (int index31 = 0; index31 < this._listArrayList.size(); index31 += 2) {
>             final String s27 = this._hashCurrentDataset.get(new Integer(index31 / 2));
>             final ArrayList list28 = this._hashSliceNumber.get(new Integer(index31 / 2));
>             final int intValue50 = this._hashTracks.get(s27);
>             final ArrayList computeDistandVelocity = ChemotaxisStatistic.computeDistandVelocity("velocity", (float[][])this._listArrayList.get(index31), (float[][])this._listArrayList.get(index31 + 1), list28, intValue50, this._timeInterval);
>             final ResultsTable resultsTable6 = new ResultsTable();
>             final String[] array86 = { "Track Number", "Velocity [" + this._unitsPath + "/" + this._unitsTime + "]" };
>             for (int n93 = 0; n93 < array86.length; ++n93) {
>                 resultsTable6.setHeading(n93, array86[n93]);
>             }
>             for (int index32 = 0; index32 < intValue50; ++index32) {
>                 final float roundFloatNumbers = this.roundFloatNumbers(Float.valueOf(computeDistandVelocity.get(index32).toString()));
>                 resultsTable6.incrementCounter();
>                 resultsTable6.addValue(0, (double)(index32 + 1));
>                 resultsTable6.addValue(1, (double)roundFloatNumbers);
>             }
>             resultsTable6.save(SPTBatch_.directChemo + File.separator + "Velocity series for " + SPTBatch_.imps.getShortTitle() + ".xls");
>         }
>         for (int index33 = 0; index33 < this._listArrayList.size(); index33 += 2) {
>             final String s28 = this._hashCurrentDataset.get(new Integer(index33 / 2));
>             final ArrayList list29 = this._hashSliceNumber.get(new Integer(index33 / 2));
>             final int intValue51 = this._hashTracks.get(s28);
>             final float[][] array87 = this._listArrayList.get(index33);
>             final float[][] array88 = this._listArrayList.get(index33 + 1);
>             final ArrayList computeDistandVelocity2 = ChemotaxisStatistic.computeDistandVelocity("accumulated distance", array87, array88, list29, intValue51, this._timeInterval);
>             final ArrayList computeDistandVelocity3 = ChemotaxisStatistic.computeDistandVelocity("euclid distance", array87, array88, list29, intValue51, this._timeInterval);
>             final ResultsTable resultsTable7 = new ResultsTable();
>             final String[] array89 = { "Track Number", "Accumulated distance [" + this._unitsPath + "]", "Euclidean distance [" + this._unitsPath + "]" };
>             for (int n94 = 0; n94 < array89.length; ++n94) {
>                 resultsTable7.setHeading(n94, array89[n94]);
>             }
>             for (int n95 = 0; n95 < intValue51; ++n95) {
>                 final float roundFloatNumbers2 = this.roundFloatNumbers(Float.valueOf(computeDistandVelocity2.get(n95).toString()));
>                 final float roundFloatNumbers3 = this.roundFloatNumbers(Float.valueOf(computeDistandVelocity3.get(n95).toString()));
>                 resultsTable7.incrementCounter();
>                 resultsTable7.addValue(0, (double)(n95 + 1));
>                 resultsTable7.addValue(1, (double)roundFloatNumbers2);
>                 resultsTable7.addValue(2, (double)roundFloatNumbers3);
>             }
>             resultsTable7.save(SPTBatch_.directChemo + File.separator + "Distance series for " + SPTBatch_.imps.getShortTitle() + ".xls");
>         }
>         final String s29 = "1: prueba2.xls";
>         final int intValue52 = this._hashImportedDataset.get("1: prueba2.xls");
>         final ResultsTable resultsTable8 = new ResultsTable();
>         final String[] array90 = { "Track n", "Slice n", "X", "Y" };
>         for (int n96 = 0; n96 < array90.length; ++n96) {
>             resultsTable8.setHeading(n96, array90[n96]);
>         }
>         final ArrayList<Float> list30 = this._importedData.get(intValue52 - 1);
>         for (int index34 = 0; index34 < list30.size(); index34 += 4) {
>             resultsTable8.incrementCounter();
>             resultsTable8.addValue(0, (double)list30.get(index34));
>             resultsTable8.addValue(1, (double)list30.get(index34 + 1));
>             resultsTable8.addValue(2, (double)list30.get(index34 + 2));
>             resultsTable8.addValue(3, (double)list30.get(index34 + 3));
>         }
>         resultsTable8.save(SPTBatch_.directChemo + File.separator + "Original data for " + SPTBatch_.imps.getShortTitle() + ".xls");
>         final String s30 = "1: prueba2.xls";
>         if (this._hashCurrentDataset.contains("1: prueba2.xls")) {
>             final int intValue53 = this._hashCurrentPosition.get("1: prueba2.xls");
>             final ArrayList<Integer> list31 = this._hashSliceNumber.get(new Integer(intValue53));
>             final int index35 = intValue53 * 2;
>             final int intValue54 = this._hashTracks.get("1: prueba2.xls");
>             final float[][] array91 = this._listArrayList.get(index35);
>             final float[][] array92 = this._listArrayList.get(index35 + 1);
>             final ResultsTable resultsTable9 = new ResultsTable();
>             final String[] array93 = { "Track n", "Slice n", "X [" + this._unitsPath + "]", "Y [" + this._unitsPath + "]" };
>             for (int n97 = 0; n97 < array93.length; ++n97) {
>                 resultsTable9.setHeading(n97, array93[n97]);
>             }
>             for (int index36 = 0; index36 < intValue54; ++index36) {
>                 for (int intValue55 = list31.get(index36), n98 = 0; n98 < intValue55; ++n98) {
>                     resultsTable9.incrementCounter();
>                     resultsTable9.addValue(0, (double)new Integer(index36 + 1));
>                     resultsTable9.addValue(1, (double)new Integer(n98 + 1));
>                     resultsTable9.addValue(2, (double)new Float(array91[index36][n98]));
>                     resultsTable9.addValue(3, (double)new Float(array92[index36][n98]));
>                 }
>             }
>             resultsTable9.save(SPTBatch_.directChemo + File.separator + "Current used data for " + SPTBatch_.imps.getShortTitle() + ".xls");
>         }
>         else {
>             JOptionPane.showMessageDialog((Component)this.gui, "No current data available!");
>         }
>         this._hashPlot.clear();
>         int n99 = 0;
>         final String s31 = "Mark up/down";
>         if ("Mark up/down".equals("Mark up/down")) {
>             n99 = 3;
>         }
>         if (this._dialog.auto) {
>             float abs = 0.0f;
>             float abs2 = 0.0f;
>             if (this._listArrayList.size() > 1) {
>                 final ArrayList coll4 = new ArrayList();
>                 for (int index37 = 0; index37 < this._listArrayList.size(); index37 += 2) {
>                     final int intValue56 = this._hashTracks.get(this._hashCurrentDataset.get(new Integer(index37 / 2)));
>                     final ArrayList<Integer> list32 = this._hashSliceNumber.get(new Integer(index37 / 2));
>                     final float[][] array94 = this._listArrayList.get(index37);
>                     final float[][] array95 = this._listArrayList.get(index37 + 1);
>                     for (int index38 = 0; index38 < intValue56; ++index38) {
>                         for (int intValue57 = list32.get(index38), n100 = 1; n100 < intValue57; ++n100) {
>                             if (abs < Math.abs(array94[index38][n100])) {
>                                 abs = Math.abs(array94[index38][n100]);
>                             }
>                             if (abs2 < Math.abs(array95[index38][n100])) {
>                                 abs2 = Math.abs(array95[index38][n100]);
>                             }
>                         }
>                     }
>                     if (abs > abs2) {
>                         coll4.add(new Float(abs));
>                     }
>                     else {
>                         coll4.add(new Float(abs2));
>                     }
>                 }
>                 this._coordSize = Collections.<Float>max((Collection<? extends Float>)coll4) + 5.0f;
>             }
>         }
>         for (int n101 = 0; n101 < this._listArrayList.size(); n101 += 2) {
>             this.plotGraph(n99, n101);
>         }
>     }
>     
>     float angleCorrection(final float n) {
>         float n2 = n;
>         if (n2 < 0.0f) {
>             n2 = n2 % 360.0f + 360.0f;
>         }
>         if (n2 > 360.0f) {
>             n2 %= 360.0f;
>         }
>         return n2;
>     }
>     
>     float[] calculatePoints(final float n) {
>         final float n2 = this._coordSize * 2.0f;
>         return new float[] { this.roundNumber(new Float(n2 * Math.cos(Math.toRadians(n)))), this.roundNumber(new Float(n2 * Math.sin(Math.toRadians(n)))) };
>     }
>     
>     int countCells(final float n, final int index) {
>         final String key = this._hashCurrentDataset.get(new Integer(index / 2));
>         final ArrayList<Integer> list = this._hashSliceNumber.get(new Integer(index / 2));
>         final int intValue = this._hashTracks.get(key);
>         final float[][] array = this._listArrayList.get(index);
>         final float[][] array2 = this._listArrayList.get(index + 1);
>         int n2 = 0;
>         final float angleCorrection = this.angleCorrection(this._anglePosition + n / 2.0f);
>         final float angleCorrection2 = this.angleCorrection(this._anglePosition - n / 2.0f);
>         final float roundNumber = this.roundNumber(new Float(Math.tan(Math.toRadians(angleCorrection))));
>         final float roundNumber2 = this.roundNumber(new Float(Math.tan(Math.toRadians(angleCorrection2))));
>         for (int i = 0; i < intValue; ++i) {
>             final int intValue2 = list.get(i);
>             final float n3 = array[i][intValue2 - 1];
>             final float n4 = array2[i][intValue2 - 1];
>             if (((angleCorrection > 0.0f && angleCorrection < 90.0f && angleCorrection2 > 0.0f && angleCorrection2 < 90.0f) || (angleCorrection > 270.0f && angleCorrection < 360.0f && angleCorrection2 > 270.0f && angleCorrection2 < 360.0f)) && n4 <= roundNumber * n3 && n4 >= roundNumber2 * n3) {
>                 ++n2;
>             }
>             if (((angleCorrection > 90.0f && angleCorrection < 180.0f && angleCorrection2 > 90.0f && angleCorrection2 < 180.0f) || (angleCorrection > 180.0f && angleCorrection < 270.0f && angleCorrection2 > 180.0f && angleCorrection2 < 270.0f)) && n4 >= roundNumber * n3 && n4 <= roundNumber2 * n3) {
>                 ++n2;
>             }
>             if (angleCorrection > 0.0f && angleCorrection < 90.0f) {
>                 if (angleCorrection2 > 180.0f && angleCorrection2 < 270.0f && n4 <= roundNumber * n3 && n4 <= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 > 270.0f && angleCorrection2 < 360.0f && n4 <= roundNumber * n3 && n4 >= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 270.0f && n3 >= 0.0f && n4 <= roundNumber * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 0.0f && n4 >= 0.0f && n4 <= roundNumber * n3) {
>                     ++n2;
>                 }
>             }
>             if (angleCorrection > 90.0f && angleCorrection < 180.0f) {
>                 if (angleCorrection2 > 0.0f && angleCorrection2 < 90.0f && n4 >= roundNumber * n3 && n4 >= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 > 270.0f && angleCorrection2 < 360.0f && n4 >= roundNumber * n3 && n4 >= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 90.0f && n3 <= 0.0f && n4 >= roundNumber * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 0.0f && n4 >= 0.0f && n4 >= roundNumber * n3) {
>                     ++n2;
>                 }
>             }
>             if (angleCorrection > 180.0f && angleCorrection < 270.0f) {
>                 if (angleCorrection2 > 90.0f && angleCorrection2 < 180.0f && n4 >= roundNumber * n3 && n4 <= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 > 0.0f && angleCorrection2 < 90.0f && n4 >= roundNumber * n3 && n4 >= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 90.0f && n3 <= 0.0f && n4 >= roundNumber * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 180.0f && n4 <= 0.0f && n4 >= roundNumber * n3) {
>                     ++n2;
>                 }
>             }
>             if (angleCorrection > 270.0f && angleCorrection < 360.0f) {
>                 if (angleCorrection2 > 180.0f && angleCorrection2 < 270.0f && n4 <= roundNumber * n3 && n4 <= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 > 90.0f && angleCorrection2 < 180.0f && n4 <= roundNumber * n3 && n4 <= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 180.0f && n4 <= 0.0f && n4 <= roundNumber * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 270.0f && n3 >= 0.0f && n4 <= roundNumber * n3) {
>                     ++n2;
>                 }
>             }
>             if (angleCorrection == 90.0f) {
>                 if (((angleCorrection2 > 0.0f && angleCorrection2 < 90.0f) || (angleCorrection2 > 270.0f && angleCorrection2 < 360.0f)) && n3 >= 0.0f && n4 >= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 0.0f && n3 >= 0.0f && n4 >= 0.0f) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 270.0f && n3 >= 0.0f) {
>                     ++n2;
>                 }
>             }
>             if (angleCorrection == 180.0f) {
>                 if (((angleCorrection2 > 0.0f && angleCorrection2 < 90.0f) || (angleCorrection2 > 90.0f && angleCorrection2 < 180.0f)) && n4 >= 0.0f && n4 <= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 0.0f && n4 >= 0.0f) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 90.0f && n3 <= 0.0f && n4 >= 0.0f) {
>                     ++n2;
>                 }
>             }
>             if (angleCorrection == 270.0f) {
>                 if (((angleCorrection2 > 90.0f && angleCorrection2 < 180.0f) || (angleCorrection2 > 180.0f && angleCorrection2 < 270.0f)) && n3 <= 0.0f && n4 <= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 90.0f && n3 <= 0.0f) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 180.0f && n3 <= 0.0f && n4 <= 0.0f) {
>                     ++n2;
>                 }
>             }
>             if (angleCorrection == 360.0f) {
>                 if (angleCorrection2 > 180.0f && angleCorrection2 < 270.0f && n4 <= 0.0f && n4 <= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 > 270.0f && angleCorrection2 < 360.0f && n4 <= 0.0f && n4 >= roundNumber2 * n3) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 180.0f && n4 <= 0.0f) {
>                     ++n2;
>                 }
>                 if (angleCorrection2 == 270.0f && n3 >= 0.0f && n4 <= 0.0f) {
>                     ++n2;
>                 }
>             }
>         }
>         return n2;
>     }
>     
>     void plotGraph(final int value, final int n) {
>         final String s = this._hashCurrentDataset.get(new Integer(n / 2));
>         final ArrayList<Integer> list = this._hashSliceNumber.get(new Integer(n / 2));
>         final int intValue = this._hashTracks.get(s);
>         final float[][] array = this._listArrayList.get(n);
>         final float[][] array2 = this._listArrayList.get(n + 1);
>         double roundDoubleNumbers = 0.0;
>         double roundDoubleNumbers2 = 0.0;
>         int i = 0;
>         int j = 0;
>         final ArrayList<Double> list2 = null;
>         for (int k = 0; k < intValue; ++k) {
>             final int intValue2 = list.get(k);
>             roundDoubleNumbers += array[k][intValue2 - 1];
>             roundDoubleNumbers2 += array2[k][intValue2 - 1];
>         }
>         if (intValue != 0) {
>             roundDoubleNumbers /= intValue;
>             roundDoubleNumbers2 /= intValue;
>         }
>         roundDoubleNumbers = this.roundDoubleNumbers(roundDoubleNumbers);
>         roundDoubleNumbers2 = this.roundDoubleNumbers(roundDoubleNumbers2);
>         final float[] array3 = { 0.0f };
>         final Plot plot = new Plot(s, "x axis [" + this._unitsPath + "]", "y axis  [" + this._unitsPath + "]", array3, array3);
>         if (SPTBatch_.chemoScaling.getText().contains("...") == Boolean.TRUE) {
>             final float[] array4 = { this._coordSize, -this._coordSize };
>             final float[] array5 = new float[2];
>             plot.setLimits((double)(-this._coordSize), (double)this._coordSize, (double)(-this._coordSize), (double)this._coordSize);
>             plot.addPoints(array4, array5, 2);
>             plot.addPoints(array5, array4, 2);
>         }
>         if (SPTBatch_.chemoScaling.getText().contains("...") == Boolean.FALSE) {
>             final float[] array6 = { -Integer.valueOf(SPTBatch_.chemoScaling.getText()), Integer.valueOf(SPTBatch_.chemoScaling.getText()) };
>             final float[] array7 = new float[2];
>             final float[] array8 = { -Integer.valueOf(SPTBatch_.chemoScaling.getText()), Integer.valueOf(SPTBatch_.chemoScaling.getText()) };
>             plot.setLimits(-Double.valueOf(SPTBatch_.chemoScaling.getText()), (double)Double.valueOf(SPTBatch_.chemoScaling.getText()), -Double.valueOf(SPTBatch_.chemoScaling.getText()), (double)Double.valueOf(SPTBatch_.chemoScaling.getText()));
>             plot.addPoints(array6, array7, 2);
>             plot.addPoints(array7, array8, 2);
>         }
>         plot.draw();
>         plot.setLineWidth(1);
>         final float[] array9 = { 0.0f };
>         final float[] array10 = { 0.0f };
>         if (value == 3) {
>             for (int index = 0; index < intValue; ++index) {
>                 final int intValue3 = list.get(index);
>                 final float[] array11 = new float[intValue3];
>                 final float[] array12 = new float[intValue3];
>                 array9[0] = array[index][intValue3 - 1];
>                 array10[0] = array2[index][intValue3 - 1];
>                 if (array10[0] >= 0.0f) {
>                     plot.setColor(Color.black);
>                     ++i;
>                 }
>                 else {
>                     plot.setColor(Color.red);
>                     ++j;
>                 }
>                 for (int n2 = 0; n2 < intValue3; ++n2) {
>                     array11[n2] = array[index][n2];
>                     array12[n2] = array2[index][n2];
>                 }
>                 plot.setLineWidth(1);
>                 plot.addPoints(array11, array12, 2);
>                 plot.setLineWidth(3);
>                 plot.addPoints(array9, array10, 0);
>             }
>             plot.setColor(Color.black);
>             plot.addLabel(0.0, 0.0, "Number of tracks: " + intValue + "  Counts up: " + i + "  Counts down: " + j);
>             plot.addLabel(0.0, 0.04, "Center of mass [" + this._unitsPath + "]: x=" + roundDoubleNumbers + " y=" + roundDoubleNumbers2);
>         }
>         final float[] array13 = { new Float(roundDoubleNumbers) };
>         final float[] array14 = { new Float(roundDoubleNumbers2) };
>         plot.setColor(Color.blue);
>         plot.setLineWidth(3);
>         plot.addPoints(array13, array14, 5);
>         this._currentOpenWindows.size();
>         final int n3 = this._listArrayList.size() / 2;
>         final ArrayList<Integer> value2 = new ArrayList<Integer>();
>         value2.add(new Integer(value));
>         value2.add(new Integer(n));
>         value2.add(new Integer(intValue));
>         this._hashPlot.put(s, value2);
>         IJ.save(plot.getImagePlus(), SPTBatch_.directChemo + File.separator + "Chemotaxis Plot for " + SPTBatch_.imps.getShortTitle() + ".png");
>     }
>     
>     void readData(String string) throws FileNotFoundException, IOException {
>         this._importedData.add(this.arrayToImport);
>         IJ.showStatus("Dataset imported");
>         string = String.valueOf(this._importedData.size()) + ": " + string;
>         this._hashImportedDataset.put(string, new Integer(this._importedData.size()));
>     }
>     
>     double roundDoubleNumbers(final double n) {
>         return Math.round(n * 100.0) / 100.0;
>     }
>     
>     float roundFloatNumbers(final float n) {
>         return Math.round(n * 100.0f) / 100.0f;
>     }
>     
>     float roundNumber(final float n) {
>         return Math.round(n * 10000.0f) / 10000.0f;
>     }
>     
>     public void stateChanged(final ChangeEvent changeEvent) {
>         final int selectedIndex = ((JTabbedPane)changeEvent.getSource()).getSelectedIndex();
>         if (selectedIndex == 1) {
>             if (this._dialog.auto) {
>                 PlotWindow.plotHeight = this._plotHeight;
>                 PlotWindow.plotWidth = this._plotWidth;
>             }
>             else {
>                 PlotWindow.plotHeight = (int)(this._dialog.fraction * (Math.abs(this._dialog.minimumY) + Math.abs(this._dialog.maximumY)));
>                 PlotWindow.plotWidth = (int)(this._dialog.fraction * (Math.abs(this._dialog.minimumX) + Math.abs(this._dialog.maximumX)));
611,919c800,801
< 
<             this._coordSize = (Float)Collections.max(coll4) + 5.0F;
<          }
<       }
< 
<       for(n94 = 0; n94 < this._listArrayList.size(); n94 += 2) {
<          this.plotGraph(n92, n94);
<       }
< 
<    }
< 
<    float angleCorrection(float n) {
<       float n2 = n;
<       if (n < 0.0F) {
<          n2 = n % 360.0F + 360.0F;
<       }
< 
<       if (n2 > 360.0F) {
<          n2 %= 360.0F;
<       }
< 
<       return n2;
<    }
< 
<    float[] calculatePoints(float n) {
<       float n2 = this._coordSize * 2.0F;
<       return new float[]{this.roundNumber(new Float((double)n2 * Math.cos(Math.toRadians((double)n)))), this.roundNumber(new Float((double)n2 * Math.sin(Math.toRadians((double)n))))};
<    }
< 
<    int countCells(float n, int index) {
<       String key = (String)this._hashCurrentDataset.get(new Integer(index / 2));
<       ArrayList<Integer> list = (ArrayList)this._hashSliceNumber.get(new Integer(index / 2));
<       int intValue = (Integer)this._hashTracks.get(key);
<       float[][] array = (float[][])this._listArrayList.get(index);
<       float[][] array2 = (float[][])this._listArrayList.get(index + 1);
<       int n2 = 0;
<       float angleCorrection = this.angleCorrection(this._anglePosition + n / 2.0F);
<       float angleCorrection2 = this.angleCorrection(this._anglePosition - n / 2.0F);
<       float roundNumber = this.roundNumber(new Float(Math.tan(Math.toRadians((double)angleCorrection))));
<       float roundNumber2 = this.roundNumber(new Float(Math.tan(Math.toRadians((double)angleCorrection2))));
< 
<       for(int i = 0; i < intValue; ++i) {
<          int intValue2 = (Integer)list.get(i);
<          float n3 = array[i][intValue2 - 1];
<          float n4 = array2[i][intValue2 - 1];
<          if ((angleCorrection > 0.0F && angleCorrection < 90.0F && angleCorrection2 > 0.0F && angleCorrection2 < 90.0F || angleCorrection > 270.0F && angleCorrection < 360.0F && angleCorrection2 > 270.0F && angleCorrection2 < 360.0F) && n4 <= roundNumber * n3 && n4 >= roundNumber2 * n3) {
<             ++n2;
<          }
< 
<          if ((angleCorrection > 90.0F && angleCorrection < 180.0F && angleCorrection2 > 90.0F && angleCorrection2 < 180.0F || angleCorrection > 180.0F && angleCorrection < 270.0F && angleCorrection2 > 180.0F && angleCorrection2 < 270.0F) && n4 >= roundNumber * n3 && n4 <= roundNumber2 * n3) {
<             ++n2;
<          }
< 
<          if (angleCorrection > 0.0F && angleCorrection < 90.0F) {
<             if (angleCorrection2 > 180.0F && angleCorrection2 < 270.0F && n4 <= roundNumber * n3 && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 > 270.0F && angleCorrection2 < 360.0F && n4 <= roundNumber * n3 && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 270.0F && n3 >= 0.0F && n4 <= roundNumber * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 0.0F && n4 >= 0.0F && n4 <= roundNumber * n3) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection > 90.0F && angleCorrection < 180.0F) {
<             if (angleCorrection2 > 0.0F && angleCorrection2 < 90.0F && n4 >= roundNumber * n3 && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 > 270.0F && angleCorrection2 < 360.0F && n4 >= roundNumber * n3 && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 90.0F && n3 <= 0.0F && n4 >= roundNumber * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 0.0F && n4 >= 0.0F && n4 >= roundNumber * n3) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection > 180.0F && angleCorrection < 270.0F) {
<             if (angleCorrection2 > 90.0F && angleCorrection2 < 180.0F && n4 >= roundNumber * n3 && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 > 0.0F && angleCorrection2 < 90.0F && n4 >= roundNumber * n3 && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 90.0F && n3 <= 0.0F && n4 >= roundNumber * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 180.0F && n4 <= 0.0F && n4 >= roundNumber * n3) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection > 270.0F && angleCorrection < 360.0F) {
<             if (angleCorrection2 > 180.0F && angleCorrection2 < 270.0F && n4 <= roundNumber * n3 && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 > 90.0F && angleCorrection2 < 180.0F && n4 <= roundNumber * n3 && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 180.0F && n4 <= 0.0F && n4 <= roundNumber * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 270.0F && n3 >= 0.0F && n4 <= roundNumber * n3) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection == 90.0F) {
<             if ((angleCorrection2 > 0.0F && angleCorrection2 < 90.0F || angleCorrection2 > 270.0F && angleCorrection2 < 360.0F) && n3 >= 0.0F && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 0.0F && n3 >= 0.0F && n4 >= 0.0F) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 270.0F && n3 >= 0.0F) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection == 180.0F) {
<             if ((angleCorrection2 > 0.0F && angleCorrection2 < 90.0F || angleCorrection2 > 90.0F && angleCorrection2 < 180.0F) && n4 >= 0.0F && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 0.0F && n4 >= 0.0F) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 90.0F && n3 <= 0.0F && n4 >= 0.0F) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection == 270.0F) {
<             if ((angleCorrection2 > 90.0F && angleCorrection2 < 180.0F || angleCorrection2 > 180.0F && angleCorrection2 < 270.0F) && n3 <= 0.0F && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 90.0F && n3 <= 0.0F) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 180.0F && n3 <= 0.0F && n4 <= 0.0F) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection == 360.0F) {
<             if (angleCorrection2 > 180.0F && angleCorrection2 < 270.0F && n4 <= 0.0F && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 > 270.0F && angleCorrection2 < 360.0F && n4 <= 0.0F && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 180.0F && n4 <= 0.0F) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 270.0F && n3 >= 0.0F && n4 <= 0.0F) {
<                ++n2;
<             }
<          }
<       }
< 
<       return n2;
<    }
< 
<    void plotGraph(int value, int n) {
<       String s = (String)this._hashCurrentDataset.get(new Integer(n / 2));
<       ArrayList<Integer> list = (ArrayList)this._hashSliceNumber.get(new Integer(n / 2));
<       int intValue = (Integer)this._hashTracks.get(s);
<       float[][] array = (float[][])this._listArrayList.get(n);
<       float[][] array2 = (float[][])this._listArrayList.get(n + 1);
<       double roundDoubleNumbers = 0.0D;
<       double roundDoubleNumbers2 = 0.0D;
<       int i = 0;
<       int j = 0;
<       ArrayList<Double> list2 = null;
< 
<       for(int k = 0; k < intValue; ++k) {
<          int intValue2 = (Integer)list.get(k);
<          roundDoubleNumbers += (double)array[k][intValue2 - 1];
<          roundDoubleNumbers2 += (double)array2[k][intValue2 - 1];
<       }
< 
<       if (intValue != 0) {
<          roundDoubleNumbers /= (double)intValue;
<          roundDoubleNumbers2 /= (double)intValue;
<       }
< 
<       roundDoubleNumbers = this.roundDoubleNumbers(roundDoubleNumbers);
<       roundDoubleNumbers2 = this.roundDoubleNumbers(roundDoubleNumbers2);
<       float[] array3 = new float[]{0.0F};
<       Plot plot = new Plot(s, "x axis [" + this._unitsPath + "]", "y axis  [" + this._unitsPath + "]", array3, array3);
<       float[] array9;
<       float[] array10;
<       if (SPTBatch_.chemoScaling.getText().contains("...") == Boolean.TRUE) {
<          array9 = new float[]{this._coordSize, -this._coordSize};
<          array10 = new float[2];
<          plot.setLimits((double)(-this._coordSize), (double)this._coordSize, (double)(-this._coordSize), (double)this._coordSize);
<          plot.addPoints(array9, array10, 2);
<          plot.addPoints(array10, array9, 2);
<       }
< 
<       float[] array19;
<       if (SPTBatch_.chemoScaling.getText().contains("...") == Boolean.FALSE) {
<          array9 = new float[]{(float)(-Integer.valueOf(SPTBatch_.chemoScaling.getText())), (float)Integer.valueOf(SPTBatch_.chemoScaling.getText())};
<          array10 = new float[2];
<          array19 = new float[]{(float)(-Integer.valueOf(SPTBatch_.chemoScaling.getText())), (float)Integer.valueOf(SPTBatch_.chemoScaling.getText())};
<          plot.setLimits(-Double.valueOf(SPTBatch_.chemoScaling.getText()), Double.valueOf(SPTBatch_.chemoScaling.getText()), -Double.valueOf(SPTBatch_.chemoScaling.getText()), Double.valueOf(SPTBatch_.chemoScaling.getText()));
<          plot.addPoints(array9, array10, 2);
<          plot.addPoints(array10, array19, 2);
<       }
< 
<       plot.draw();
<       plot.setLineWidth(1);
<       array9 = new float[]{0.0F};
<       array10 = new float[]{0.0F};
<       if (value == 3) {
<          for(int index = 0; index < intValue; ++index) {
<             int intValue4 = (Integer)list.get(index);
<             float[] array13 = new float[intValue4];
<             float[] array14 = new float[intValue4];
<             array9[0] = array[index][intValue4 - 1];
<             array10[0] = array2[index][intValue4 - 1];
<             if (array10[0] >= 0.0F) {
<                plot.setColor(Color.black);
<                ++i;
<             } else {
<                plot.setColor(Color.red);
<                ++j;
<             }
< 
<             for(int n3 = 0; n3 < intValue4; ++n3) {
<                array13[n3] = array[index][n3];
<                array14[n3] = array2[index][n3];
<             }
< 
<             plot.setLineWidth(1);
<             plot.addPoints(array13, array14, 2);
<             plot.setLineWidth(3);
<             plot.addPoints(array9, array10, 0);
<          }
< 
<          plot.setColor(Color.black);
<          plot.addLabel(0.0D, 0.0D, "Number of tracks: " + intValue + "  Counts up: " + i + "  Counts down: " + j);
<          plot.addLabel(0.0D, 0.04D, "Center of mass [" + this._unitsPath + "]: x=" + roundDoubleNumbers + " y=" + roundDoubleNumbers2);
<       }
< 
<       array19 = new float[]{new Float(roundDoubleNumbers)};
<       float[] array20 = new float[]{new Float(roundDoubleNumbers2)};
<       plot.setColor(Color.blue);
<       plot.setLineWidth(3);
<       plot.addPoints(array19, array20, 5);
<       this._currentOpenWindows.size();
<       int var10000 = this._listArrayList.size() / 2;
<       ArrayList<Integer> value2 = new ArrayList();
<       value2.add(new Integer(value));
<       value2.add(new Integer(n));
<       value2.add(new Integer(intValue));
<       this._hashPlot.put(s, value2);
<       IJ.save(plot.getImagePlus(), SPTBatch_.directChemo + File.separator + "Chemotaxis Plot for " + SPTBatch_.imps.getShortTitle() + ".png");
<    }
< 
<    void readData(String string) throws FileNotFoundException, IOException {
<       this._importedData.add(this.arrayToImport);
<       IJ.showStatus("Dataset imported");
<       string = this._importedData.size() + ": " + string;
<       this._hashImportedDataset.put(string, new Integer(this._importedData.size()));
<    }
< 
<    double roundDoubleNumbers(double n) {
<       return (double)Math.round(n * 100.0D) / 100.0D;
<    }
< 
<    float roundFloatNumbers(float n) {
<       return (float)Math.round(n * 100.0F) / 100.0F;
<    }
< 
<    float roundNumber(float n) {
<       return (float)Math.round(n * 10000.0F) / 10000.0F;
<    }
< 
<    public void stateChanged(ChangeEvent changeEvent) {
<       int selectedIndex = ((JTabbedPane)changeEvent.getSource()).getSelectedIndex();
<       if (selectedIndex == 1) {
<          if (this._dialog.auto) {
---
>         }
>         if (selectedIndex == 3) {
922,1003c804,868
<          } else {
<             PlotWindow.plotHeight = (int)(this._dialog.fraction * (double)(Math.abs(this._dialog.minimumY) + Math.abs(this._dialog.maximumY)));
<             PlotWindow.plotWidth = (int)(this._dialog.fraction * (double)(Math.abs(this._dialog.minimumX) + Math.abs(this._dialog.maximumX)));
<          }
<       }
< 
<       if (selectedIndex == 3) {
<          PlotWindow.plotHeight = this._plotHeight;
<          PlotWindow.plotWidth = this._plotWidth;
<       }
< 
<    }
< 
<    void updateNumberofTracks(String s, int n) {
<       if (this._hashTracks.containsKey(s)) {
<          this._hashTracks.remove(s);
<          this._hashTracks.put(s, new Integer(n));
<       } else {
<          this._hashTracks.put(s, new Integer(n));
<       }
< 
<    }
< 
<    public void windowActivated(WindowEvent windowEvent) {
<    }
< 
<    public void windowClosed(WindowEvent windowEvent) {
<    }
< 
<    public void windowClosing(WindowEvent windowEvent) {
<       int k;
<       if (windowEvent.getSource() == this.gui) {
<          if (this._openInfoWindows != null) {
<             for(k = 0; k < this._openInfoWindows.size(); ++k) {
<                ((JFrame)this._openInfoWindows.get(k)).dispose();
<             }
< 
<             this._openInfoWindows.clear();
<          }
< 
<          this._currentOpenWindows.clear();
<          this._currentOpenDiagrams.clear();
<          WindowManager.closeAllWindows();
<          this.gui.dispose();
<       } else {
<          if (windowEvent.getSource() instanceof JFrame && this._openInfoWindows.contains(windowEvent.getSource())) {
<             this._openInfoWindows.remove(windowEvent.getSource());
<          }
< 
<          if (windowEvent.getSource() instanceof PlotWindow) {
<             if (this._currentOpenWindows.contains(windowEvent.getSource())) {
<                for(k = 0; k < this._currentOpenWindows.size(); ++k) {
<                   ((Window)this._currentOpenWindows.get(k)).dispose();
<                }
< 
<                this._currentOpenWindows.clear();
<                this.gui.plotClosed();
<             }
< 
<             if (this._currentOpenDiagrams.contains(windowEvent.getSource())) {
<                for(k = 0; k < this._currentOpenDiagrams.size(); ++k) {
<                   ((Window)this._currentOpenDiagrams.get(k)).dispose();
<                }
< 
<                this._currentOpenDiagrams.clear();
<             }
<          }
<       }
< 
<    }
< 
<    public void windowDeactivated(WindowEvent windowEvent) {
<    }
< 
<    public void windowDeiconified(WindowEvent windowEvent) {
<    }
< 
<    public void windowIconified(WindowEvent windowEvent) {
<    }
< 
<    public void windowOpened(WindowEvent windowEvent) {
<    }
---
>         }
>     }
>     
>     void updateNumberofTracks(final String s, final int n) {
>         if (this._hashTracks.containsKey(s)) {
>             this._hashTracks.remove(s);
>             this._hashTracks.put(s, new Integer(n));
>         }
>         else {
>             this._hashTracks.put(s, new Integer(n));
>         }
>     }
>     
>     public void windowActivated(final WindowEvent windowEvent) {
>     }
>     
>     public void windowClosed(final WindowEvent windowEvent) {
>     }
>     
>     public void windowClosing(final WindowEvent windowEvent) {
>         if (windowEvent.getSource() == this.gui) {
>             if (this._openInfoWindows != null) {
>                 for (int i = 0; i < this._openInfoWindows.size(); ++i) {
>                     this._openInfoWindows.get(i).dispose();
>                 }
>                 this._openInfoWindows.clear();
>             }
>             this._currentOpenWindows.clear();
>             this._currentOpenDiagrams.clear();
>             WindowManager.closeAllWindows();
>             this.gui.dispose();
>         }
>         else {
>             if (windowEvent.getSource() instanceof JFrame && this._openInfoWindows.contains(windowEvent.getSource())) {
>                 this._openInfoWindows.remove(windowEvent.getSource());
>             }
>             if (windowEvent.getSource() instanceof PlotWindow) {
>                 if (this._currentOpenWindows.contains(windowEvent.getSource())) {
>                     for (int j = 0; j < this._currentOpenWindows.size(); ++j) {
>                         this._currentOpenWindows.get(j).dispose();
>                     }
>                     this._currentOpenWindows.clear();
>                     this.gui.plotClosed();
>                 }
>                 if (this._currentOpenDiagrams.contains(windowEvent.getSource())) {
>                     for (int k = 0; k < this._currentOpenDiagrams.size(); ++k) {
>                         this._currentOpenDiagrams.get(k).dispose();
>                     }
>                     this._currentOpenDiagrams.clear();
>                 }
>             }
>         }
>     }
>     
>     public void windowDeactivated(final WindowEvent windowEvent) {
>     }
>     
>     public void windowDeiconified(final WindowEvent windowEvent) {
>     }
>     
>     public void windowIconified(final WindowEvent windowEvent) {
>     }
>     
>     public void windowOpened(final WindowEvent windowEvent) {
>     }
diff -r TrackAnalyzer_/ChooserWizardPanel.java procyon/ChooserWizardPanel.java
1c1,8
< import ij.IJ;
---
> import ij.measure.Calibration;
> import javax.swing.table.TableCellRenderer;
> import javax.swing.table.DefaultTableCellRenderer;
> import ij.gui.Roi;
> import javax.swing.event.ChangeEvent;
> import javax.swing.event.ChangeListener;
> import java.awt.Rectangle;
> import java.io.File;
2a10,13
> import ij.process.ImageProcessor;
> import java.awt.Image;
> import ij.process.ColorProcessor;
> import java.awt.image.BufferedImage;
4,5c15,17
< import ij.gui.Roi;
< import ij.measure.Calibration;
---
> import javax.swing.JFileChooser;
> import javax.swing.JFrame;
> import ij.IJ;
7,14c19
< import ij.process.ColorProcessor;
< import java.awt.BasicStroke;
< import java.awt.BorderLayout;
< import java.awt.Color;
< import java.awt.Dimension;
< import java.awt.FlowLayout;
< import java.awt.Font;
< import java.awt.Rectangle;
---
> import java.util.ArrayList;
19,23c24,33
< import java.awt.image.BufferedImage;
< import java.io.File;
< import java.util.ArrayList;
< import java.util.List;
< import javax.swing.BorderFactory;
---
> import javax.swing.ListModel;
> import java.awt.BorderLayout;
> import java.awt.Stroke;
> import java.awt.Paint;
> import org.jfree.chart.plot.IntervalMarker;
> import java.awt.BasicStroke;
> import java.awt.Color;
> import javax.swing.JSlider;
> import javax.swing.SpinnerModel;
> import javax.swing.SpinnerNumberModel;
24a35,43
> import java.awt.Font;
> import javax.swing.JSeparator;
> import javax.swing.JToggleButton;
> import java.awt.FlowLayout;
> import javax.swing.JButton;
> import javax.swing.ImageIcon;
> import javax.swing.JTabbedPane;
> import java.awt.LayoutManager;
> import java.awt.Container;
26c45,51
< import javax.swing.DefaultListModel;
---
> import javax.swing.JPanel;
> import javax.swing.border.Border;
> import javax.swing.BorderFactory;
> import java.awt.Dimension;
> import java.awt.Component;
> import javax.swing.table.TableModel;
> import jwizardcomponent.JWizardComponents;
28,33c53
< import javax.swing.ImageIcon;
< import javax.swing.JButton;
< import javax.swing.JCheckBox;
< import javax.swing.JComboBox;
< import javax.swing.JFileChooser;
< import javax.swing.JFrame;
---
> import java.util.List;
36,39c56,58
< import javax.swing.JPanel;
< import javax.swing.JScrollPane;
< import javax.swing.JSeparator;
< import javax.swing.JSlider;
---
> import javax.swing.DefaultListModel;
> import javax.swing.JComboBox;
> import org.jfree.chart.ChartPanel;
41,47c60
< import javax.swing.JTabbedPane;
< import javax.swing.JTable;
< import javax.swing.JToggleButton;
< import javax.swing.SpinnerNumberModel;
< import javax.swing.event.ChangeEvent;
< import javax.swing.event.ChangeListener;
< import javax.swing.table.DefaultTableCellRenderer;
---
> import javax.swing.JScrollPane;
49c62,63
< import jwizardcomponent.JWizardComponents;
---
> import javax.swing.JTable;
> import javax.swing.JCheckBox;
51,344d64
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.plot.IntervalMarker;
< 
< public class ChooserWizardPanel extends JWizardPanel {
<    JCheckBox checkRPicker;
<    static JTable tableTrack;
<    static JTable tableImages;
<    static DefaultTableModel modelTrack;
<    JScrollPane jScrollPaneTrack;
<    JScrollPane jScrollPaneImages;
<    JSpinner filterMin;
<    JSpinner filterMax;
<    HistogramFilterVersion hs2 = new HistogramFilterVersion();
<    ChartPanel histogram;
<    JComboBox<String> comboFilters;
<    static DefaultListModel<String> modelListClass;
<    static DefaultListModel<String> modelListFeature;
<    static JList<String> classList;
<    static JList<String> featureList;
<    static JLabel labelReset;
<    static String trackEnable = "";
<    static String command;
<    List<Integer> indexesToReset;
<    List<Integer> indexesToReset1;
<    List<Integer> tracksID;
<    List<Integer> tracksID1;
<    List<Integer> indexesTI;
<    static Icon iconTrackCell;
<    static Object[] columnNamesTrack;
<    Thread refreshThread;
<    Thread csvThread;
<    Thread pngThread;
<    Thread paintThread;
<    Thread tInsideThread;
<    Thread tOutsideThread;
<    Thread enableThread;
<    Thread disableThread;
<    Thread slMinThread;
<    Thread filterMinThread;
<    Thread slMaxThread;
<    Thread filterMaxThread;
<    Thread filtersThread;
<    Thread pickerThread;
<    Thread classThread;
<    Thread remClassThread;
<    Thread addThread;
<    Thread remThread;
< 
<    public ChooserWizardPanel(JWizardComponents wizardComponents) {
<       super(wizardComponents, "");
<       tableTrack = new JTable();
<       tableImages = new JTable();
<       tableImages.setModel(FirstWizardPanel.modelImages);
<       tableImages.getColumnModel().getColumn(0).setPreferredWidth(90);
<       tableImages.getColumnModel().getColumn(1).setPreferredWidth(460);
<       tableImages.getColumnModel().getColumn(2).setPreferredWidth(80);
<       modelTrack = new DefaultTableModel();
<       columnNamesTrack = new Object[]{"Label", "TRACK_ID", "TRACK_INDEX", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "TOTAL_ABSOLUTE_ANGLE_XY", "TOTAL_ABSOLUTE_ANGLE_YZ", "TOTAL_ABSOLUTE_ANGLE_ZX"};
<       tableTrack.setModel(modelTrack);
<       tableTrack.setSelectionMode(1);
<       this.jScrollPaneTrack = new JScrollPane(tableTrack);
<       this.jScrollPaneTrack.setPreferredSize(new Dimension(590, 240));
<       this.jScrollPaneTrack.setBorder(BorderFactory.createTitledBorder(""));
<       this.jScrollPaneImages = new JScrollPane(tableImages);
<       this.jScrollPaneImages.setPreferredSize(new Dimension(590, 240));
<       this.jScrollPaneImages.setBorder(BorderFactory.createTitledBorder(""));
<       JPanel mainPanel = new JPanel();
<       mainPanel.setLayout(new BoxLayout(mainPanel, 1));
<       JTabbedPane tabbedPaneTrack = new JTabbedPane(1);
<       ImageIcon iconTrack = FirstWizardPanel.createImageIcon("images/track.jpg");
<       iconTrackCell = new ImageIcon(iconTrack.getImage().getScaledInstance(18, 20, 4));
<       JButton pngButton = new JButton();
<       ImageIcon iconPng = FirstWizardPanel.createImageIcon("images/save.png");
<       Icon pngCell = new ImageIcon(iconPng.getImage().getScaledInstance(18, 20, 4));
<       pngButton.setIcon(pngCell);
<       pngButton.setToolTipText("Click to capture spots overlay.");
<       JPanel panelPng = new JPanel(new FlowLayout(0));
<       panelPng.add(pngButton);
<       JButton csvButton = new JButton();
<       ImageIcon iconCsv = FirstWizardPanel.createImageIcon("images/csv.png");
<       Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
<       csvButton.setIcon(csvCell);
<       csvButton.setToolTipText("Click to export your spots table selection.");
<       JPanel panelCsv = new JPanel(new FlowLayout(0));
<       panelCsv.add(csvButton);
<       JPanel panelPngCsv = new JPanel(new FlowLayout(0));
<       panelPngCsv.add(panelPng);
<       panelPngCsv.add(panelCsv);
<       tabbedPaneTrack.addTab("TRACKS ", iconTrackCell, mainPanel, "Display Track Analysis");
<       tabbedPaneTrack.setTabLayoutPolicy(1);
<       JButton refreshButton = new JButton();
<       ImageIcon iconRefresh = FirstWizardPanel.createImageIcon("images/refresh.png");
<       Icon refreshCell = new ImageIcon(iconRefresh.getImage().getScaledInstance(18, 20, 4));
<       refreshButton.setIcon(refreshCell);
<       refreshButton.setToolTipText("Click this button to get Track analysis");
<       JToggleButton paintButton = new JToggleButton();
<       ImageIcon iconPaint = FirstWizardPanel.createImageIcon("images/paint.png");
<       Icon paintCell = new ImageIcon(iconPaint.getImage().getScaledInstance(18, 20, 4));
<       paintButton.setIcon(paintCell);
<       paintButton.setToolTipText("Click this button to display labeled-Tracks");
<       JToggleButton tInsideButton = new JToggleButton();
<       ImageIcon iconTI = FirstWizardPanel.createImageIcon("images/tinside.png");
<       Icon TICell = new ImageIcon(iconTI.getImage().getScaledInstance(18, 20, 4));
<       tInsideButton.setIcon(TICell);
<       tInsideButton.setToolTipText("Click this button to toggle inside Tracks.");
<       JToggleButton tOutsideButton = new JToggleButton();
<       ImageIcon iconTO = FirstWizardPanel.createImageIcon("images/toutside.png");
<       Icon TOCell = new ImageIcon(iconTO.getImage().getScaledInstance(18, 20, 4));
<       tOutsideButton.setIcon(TOCell);
<       tOutsideButton.setToolTipText("Click this button to toggle outside Tracks.");
<       JButton enableButton = new JButton();
<       ImageIcon iconEnable = FirstWizardPanel.createImageIcon("images/enable.png");
<       Icon enableCell = new ImageIcon(iconEnable.getImage().getScaledInstance(18, 20, 4));
<       enableButton.setIcon(enableCell);
<       enableButton.setToolTipText("Click this button to enable your selection");
<       JButton disableButton = new JButton();
<       ImageIcon iconDisable = FirstWizardPanel.createImageIcon("images/disable.png");
<       Icon disableCell = new ImageIcon(iconDisable.getImage().getScaledInstance(18, 20, 4));
<       disableButton.setIcon(disableCell);
<       disableButton.setToolTipText("Click this button to disable your selection");
<       JPanel buttonPanel = new JPanel(new FlowLayout(2));
<       JSeparator separator1 = new JSeparator(1);
<       JSeparator separator2 = new JSeparator(1);
<       Dimension dime = separator1.getPreferredSize();
<       dime.height = refreshButton.getPreferredSize().height;
<       separator1.setPreferredSize(dime);
<       separator2.setPreferredSize(dime);
<       this.checkRPicker = new JCheckBox(" Track Picker");
<       JLabel filterLabel = new JLabel("   Track Analysis : ");
<       filterLabel.setFont(new Font("Dialog", 1, 13));
<       filterLabel.setBorder(BorderFactory.createRaisedBevelBorder());
<       JPanel filterPanel = new JPanel(new FlowLayout(0));
<       filterPanel.add(filterLabel);
<       filterPanel.add(this.checkRPicker);
<       filterPanel.add(Box.createHorizontalStrut(20));
<       JPanel filterMain = new JPanel(new FlowLayout(0));
<       filterMain.add(filterPanel);
<       buttonPanel.add(refreshButton);
<       buttonPanel.add(paintButton);
<       buttonPanel.add(separator1);
<       buttonPanel.add(enableButton);
<       buttonPanel.add(disableButton);
<       buttonPanel.add(separator2);
<       buttonPanel.add(tInsideButton);
<       buttonPanel.add(tOutsideButton);
<       filterMain.add(buttonPanel);
<       mainPanel.add(this.jScrollPaneImages);
<       mainPanel.add(Box.createVerticalStrut(5));
<       mainPanel.add(filterMain);
<       mainPanel.add(this.jScrollPaneTrack);
<       JLabel settingsLabel = new JLabel("   Settings for Filters/Classes : ");
<       settingsLabel.setFont(new Font("Dialog", 1, 13));
<       settingsLabel.setBorder(BorderFactory.createRaisedBevelBorder());
<       JPanel settingsPanel = new JPanel(new FlowLayout(0));
<       settingsPanel.add(settingsLabel);
<       mainPanel.add(settingsPanel);
<       JPanel filtersMin = new JPanel(new FlowLayout(0));
<       this.filterMin = new JSpinner(new SpinnerNumberModel(30, 0, 5000, 1));
<       this.filterMin.setPreferredSize(new Dimension(60, 20));
<       final JSlider sliderMin = new JSlider(0, 300, 50);
<       sliderMin.setPreferredSize(new Dimension(150, 15));
<       JLabel filterMinLabel = new JLabel("              Min :  ");
<       filtersMin.add(filterMinLabel);
<       filtersMin.add(sliderMin);
<       filtersMin.add(Box.createHorizontalStrut(2));
<       filtersMin.add(this.filterMin);
<       JPanel filtersMax = new JPanel(new FlowLayout(0));
<       this.filterMax = new JSpinner(new SpinnerNumberModel(200, 0, 5000, 1));
<       this.filterMax.setPreferredSize(new Dimension(60, 20));
<       final JSlider sliderMax = new JSlider(0, 300, 150);
<       sliderMax.setPreferredSize(new Dimension(150, 15));
<       JLabel filterMaxLabel = new JLabel("              Max :  ");
<       filtersMax.add(filterMaxLabel);
<       filtersMax.add(sliderMax);
<       filtersMax.add(Box.createHorizontalStrut(2));
<       filtersMax.add(this.filterMax);
<       JPanel boxPanel2 = new JPanel();
<       boxPanel2.setLayout(new BoxLayout(boxPanel2, 1));
<       final IntervalMarker intervalMarker = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.5F);
<       this.histogram = this.hs2.createChartPanel("", new double[]{0.0D, 0.0D, 0.0D}, 100, intervalMarker);
<       JPanel chartPanel2 = new JPanel(new BorderLayout());
<       chartPanel2.setPreferredSize(new Dimension(390, 180));
<       chartPanel2.add(this.histogram);
<       boxPanel2.add(chartPanel2);
<       JPanel controlPanel2 = this.hs2.createControlPanel();
<       boxPanel2.add(controlPanel2);
<       JPanel filtersMain2 = new JPanel();
<       filtersMain2.setLayout(new BoxLayout(filtersMain2, 1));
<       filtersMain2.add(boxPanel2);
<       filtersMain2.add(filtersMin);
<       filtersMain2.add(filtersMax);
<       JLabel featureTrack = new JLabel("  Track-Features :  ");
<       featureTrack.setFont(new Font("Dialog", 1, 13));
<       this.comboFilters = new JComboBox();
< 
<       for(int i = 1; i < columnNamesTrack.length; ++i) {
<          this.comboFilters.addItem((String)columnNamesTrack[i]);
<       }
< 
<       this.comboFilters.setPreferredSize(new Dimension(130, 25));
<       this.comboFilters.setSelectedIndex(0);
<       this.comboFilters.setOpaque(true);
<       JPanel panelFilters = new JPanel(new FlowLayout(0));
<       JSeparator separator3 = new JSeparator(1);
<       Dimension dime2 = separator3.getPreferredSize();
<       dime2.height = filtersMain2.getPreferredSize().height;
<       separator3.setPreferredSize(dime2);
<       panelFilters.add(filtersMain2);
<       panelFilters.add(separator3);
<       modelListClass = new DefaultListModel();
<       classList = new JList(modelListClass);
<       modelListFeature = new DefaultListModel();
<       featureList = new JList(modelListFeature);
<       final ColorEditorTrack colorEditor = new ColorEditorTrack(featureList);
<       JScrollPane scrollListFilter = new JScrollPane(featureList);
<       JScrollPane scrollListClass = new JScrollPane(classList);
<       Dimension d = featureList.getPreferredSize();
<       d.width = 150;
<       d.height = 90;
<       scrollListFilter.setPreferredSize(d);
<       scrollListClass.setPreferredSize(d);
<       JPanel filterPanelButtons = new JPanel(new FlowLayout(0));
<       JPanel classPanelButtons = new JPanel();
<       classPanelButtons.setLayout(new BoxLayout(classPanelButtons, 1));
<       filterPanelButtons.add(scrollListFilter);
<       JPanel fButtonsPanel = new JPanel();
<       fButtonsPanel.setLayout(new BoxLayout(fButtonsPanel, 1));
<       JButton addButton = new JButton();
<       ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
<       Icon addCell = new ImageIcon(iconAdd.getImage().getScaledInstance(14, 16, 4));
<       addButton.setIcon(addCell);
<       addButton.setToolTipText("Click this button to add features");
<       JButton remButton = new JButton();
<       ImageIcon iconRem = FirstWizardPanel.createImageIcon("images/remove.png");
<       Icon remCell = new ImageIcon(iconRem.getImage().getScaledInstance(14, 16, 4));
<       remButton.setIcon(remCell);
<       remButton.setToolTipText("Click this button to remove features");
<       JButton classButton = new JButton();
<       ImageIcon iconClass = FirstWizardPanel.createImageIcon("images/classes.png");
<       Icon classCell = new ImageIcon(iconClass.getImage().getScaledInstance(14, 16, 4));
<       classButton.setIcon(classCell);
<       classButton.setToolTipText("Click this button to create a class.");
<       JButton remClassButton = new JButton();
<       remClassButton.setIcon(remCell);
<       remClassButton.setToolTipText("Click this button to remove a class.");
<       fButtonsPanel.add(addButton);
<       fButtonsPanel.add(remButton);
<       filterPanelButtons.add(fButtonsPanel);
<       classPanelButtons.add(classButton);
<       classPanelButtons.add(remClassButton);
<       JPanel classPanel = new JPanel(new FlowLayout(0));
<       classPanel.add(scrollListClass);
<       classPanel.add(classPanelButtons);
<       JPanel boxPanel = new JPanel();
<       boxPanel.setLayout(new BoxLayout(boxPanel, 1));
<       boxPanel.add(this.comboFilters);
<       boxPanel.add(Box.createHorizontalStrut(5));
<       boxPanel.add(filterPanelButtons);
<       boxPanel.add(Box.createHorizontalStrut(5));
<       boxPanel.add(classPanel);
<       boxPanel.add(panelPngCsv);
<       panelFilters.add(boxPanel);
<       mainPanel.add(panelFilters);
<       this.add(tabbedPaneTrack);
<       this.createMovieTable();
<       paintButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             ChooserWizardPanel.this.paintThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      ChooserWizardPanel.this.paintAndDisableAction();
<                   } else if (ev.getStateChange() == 2) {
<                      ChooserWizardPanel.this.resetAndEnableAction();
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.paintThread.start();
<          }
<       });
<       csvButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.csvThread = new Thread(new Runnable() {
<                public void run() {
<                   List<String> columnTrackHead = new ArrayList();
< 
<                   for(int j = 0; j < ChooserWizardPanel.modelTrack.getColumnCount(); ++j) {
<                      columnTrackHead.add(ChooserWizardPanel.modelTrack.getColumnName(j));
<                   }
< 
<                   ResultsTable rt = new ResultsTable(ChooserWizardPanel.modelTrack.getRowCount());
<                   if (rt != null) {
<                      rt.reset();
<                   }
346,353c66,338
<                   for(int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<                      for(int jx = 0; jx < ChooserWizardPanel.modelTrack.getColumnCount(); ++jx) {
<                         if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE) {
<                            if (((String)columnTrackHead.get(jx)).equals(columnTrackHead.get(0)) == Boolean.TRUE) {
<                               rt.setValue((String)columnTrackHead.get(jx), i, ((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, jx)).getText());
<                            } else {
<                               rt.setValue((String)columnTrackHead.get(jx), i, ChooserWizardPanel.modelTrack.getValueAt(i, jx).toString());
<                            }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class ChooserWizardPanel extends JWizardPanel
> {
>     JCheckBox checkRPicker;
>     static JTable tableTrack;
>     static JTable tableImages;
>     static DefaultTableModel modelTrack;
>     JScrollPane jScrollPaneTrack;
>     JScrollPane jScrollPaneImages;
>     JSpinner filterMin;
>     JSpinner filterMax;
>     HistogramFilterVersion hs2;
>     ChartPanel histogram;
>     JComboBox<String> comboFilters;
>     static DefaultListModel<String> modelListClass;
>     static DefaultListModel<String> modelListFeature;
>     static JList<String> classList;
>     static JList<String> featureList;
>     static JLabel labelReset;
>     static String trackEnable;
>     static String command;
>     List<Integer> indexesToReset;
>     List<Integer> indexesToReset1;
>     List<Integer> tracksID;
>     List<Integer> tracksID1;
>     List<Integer> indexesTI;
>     static Icon iconTrackCell;
>     static Object[] columnNamesTrack;
>     Thread refreshThread;
>     Thread csvThread;
>     Thread pngThread;
>     Thread paintThread;
>     Thread tInsideThread;
>     Thread tOutsideThread;
>     Thread enableThread;
>     Thread disableThread;
>     Thread slMinThread;
>     Thread filterMinThread;
>     Thread slMaxThread;
>     Thread filterMaxThread;
>     Thread filtersThread;
>     Thread pickerThread;
>     Thread classThread;
>     Thread remClassThread;
>     Thread addThread;
>     Thread remThread;
>     
>     static {
>         ChooserWizardPanel.trackEnable = "";
>     }
>     
>     public ChooserWizardPanel(final JWizardComponents wizardComponents) {
>         super(wizardComponents, "");
>         this.hs2 = new HistogramFilterVersion();
>         ChooserWizardPanel.tableTrack = new JTable();
>         (ChooserWizardPanel.tableImages = new JTable()).setModel(FirstWizardPanel.modelImages);
>         ChooserWizardPanel.tableImages.getColumnModel().getColumn(0).setPreferredWidth(90);
>         ChooserWizardPanel.tableImages.getColumnModel().getColumn(1).setPreferredWidth(460);
>         ChooserWizardPanel.tableImages.getColumnModel().getColumn(2).setPreferredWidth(80);
>         ChooserWizardPanel.modelTrack = new DefaultTableModel();
>         ChooserWizardPanel.columnNamesTrack = new Object[] { "Label", "TRACK_ID", "TRACK_INDEX", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "TOTAL_ABSOLUTE_ANGLE_XY", "TOTAL_ABSOLUTE_ANGLE_YZ", "TOTAL_ABSOLUTE_ANGLE_ZX" };
>         ChooserWizardPanel.tableTrack.setModel(ChooserWizardPanel.modelTrack);
>         ChooserWizardPanel.tableTrack.setSelectionMode(1);
>         (this.jScrollPaneTrack = new JScrollPane(ChooserWizardPanel.tableTrack)).setPreferredSize(new Dimension(590, 240));
>         this.jScrollPaneTrack.setBorder(BorderFactory.createTitledBorder(""));
>         (this.jScrollPaneImages = new JScrollPane(ChooserWizardPanel.tableImages)).setPreferredSize(new Dimension(590, 240));
>         this.jScrollPaneImages.setBorder(BorderFactory.createTitledBorder(""));
>         final JPanel mainPanel = new JPanel();
>         mainPanel.setLayout(new BoxLayout(mainPanel, 1));
>         final JTabbedPane tabbedPaneTrack = new JTabbedPane(1);
>         final ImageIcon iconTrack = FirstWizardPanel.createImageIcon("images/track.jpg");
>         ChooserWizardPanel.iconTrackCell = new ImageIcon(iconTrack.getImage().getScaledInstance(18, 20, 4));
>         final JButton pngButton = new JButton();
>         final ImageIcon iconPng = FirstWizardPanel.createImageIcon("images/save.png");
>         final Icon pngCell = new ImageIcon(iconPng.getImage().getScaledInstance(18, 20, 4));
>         pngButton.setIcon(pngCell);
>         pngButton.setToolTipText("Click to capture spots overlay.");
>         final JPanel panelPng = new JPanel(new FlowLayout(0));
>         panelPng.add(pngButton);
>         final JButton csvButton = new JButton();
>         final ImageIcon iconCsv = FirstWizardPanel.createImageIcon("images/csv.png");
>         final Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
>         csvButton.setIcon(csvCell);
>         csvButton.setToolTipText("Click to export your spots table selection.");
>         final JPanel panelCsv = new JPanel(new FlowLayout(0));
>         panelCsv.add(csvButton);
>         final JPanel panelPngCsv = new JPanel(new FlowLayout(0));
>         panelPngCsv.add(panelPng);
>         panelPngCsv.add(panelCsv);
>         tabbedPaneTrack.addTab("TRACKS ", ChooserWizardPanel.iconTrackCell, mainPanel, "Display Track Analysis");
>         tabbedPaneTrack.setTabLayoutPolicy(1);
>         final JButton refreshButton = new JButton();
>         final ImageIcon iconRefresh = FirstWizardPanel.createImageIcon("images/refresh.png");
>         final Icon refreshCell = new ImageIcon(iconRefresh.getImage().getScaledInstance(18, 20, 4));
>         refreshButton.setIcon(refreshCell);
>         refreshButton.setToolTipText("Click this button to get Track analysis");
>         final JToggleButton paintButton = new JToggleButton();
>         final ImageIcon iconPaint = FirstWizardPanel.createImageIcon("images/paint.png");
>         final Icon paintCell = new ImageIcon(iconPaint.getImage().getScaledInstance(18, 20, 4));
>         paintButton.setIcon(paintCell);
>         paintButton.setToolTipText("Click this button to display labeled-Tracks");
>         final JToggleButton tInsideButton = new JToggleButton();
>         final ImageIcon iconTI = FirstWizardPanel.createImageIcon("images/tinside.png");
>         final Icon TICell = new ImageIcon(iconTI.getImage().getScaledInstance(18, 20, 4));
>         tInsideButton.setIcon(TICell);
>         tInsideButton.setToolTipText("Click this button to toggle inside Tracks.");
>         final JToggleButton tOutsideButton = new JToggleButton();
>         final ImageIcon iconTO = FirstWizardPanel.createImageIcon("images/toutside.png");
>         final Icon TOCell = new ImageIcon(iconTO.getImage().getScaledInstance(18, 20, 4));
>         tOutsideButton.setIcon(TOCell);
>         tOutsideButton.setToolTipText("Click this button to toggle outside Tracks.");
>         final JButton enableButton = new JButton();
>         final ImageIcon iconEnable = FirstWizardPanel.createImageIcon("images/enable.png");
>         final Icon enableCell = new ImageIcon(iconEnable.getImage().getScaledInstance(18, 20, 4));
>         enableButton.setIcon(enableCell);
>         enableButton.setToolTipText("Click this button to enable your selection");
>         final JButton disableButton = new JButton();
>         final ImageIcon iconDisable = FirstWizardPanel.createImageIcon("images/disable.png");
>         final Icon disableCell = new ImageIcon(iconDisable.getImage().getScaledInstance(18, 20, 4));
>         disableButton.setIcon(disableCell);
>         disableButton.setToolTipText("Click this button to disable your selection");
>         final JPanel buttonPanel = new JPanel(new FlowLayout(2));
>         final JSeparator separator1 = new JSeparator(1);
>         final JSeparator separator2 = new JSeparator(1);
>         final Dimension dime = separator1.getPreferredSize();
>         dime.height = refreshButton.getPreferredSize().height;
>         separator1.setPreferredSize(dime);
>         separator2.setPreferredSize(dime);
>         this.checkRPicker = new JCheckBox(" Track Picker");
>         final JLabel filterLabel = new JLabel("   Track Analysis : ");
>         filterLabel.setFont(new Font("Dialog", 1, 13));
>         filterLabel.setBorder(BorderFactory.createRaisedBevelBorder());
>         final JPanel filterPanel = new JPanel(new FlowLayout(0));
>         filterPanel.add(filterLabel);
>         filterPanel.add(this.checkRPicker);
>         filterPanel.add(Box.createHorizontalStrut(20));
>         final JPanel filterMain = new JPanel(new FlowLayout(0));
>         filterMain.add(filterPanel);
>         buttonPanel.add(refreshButton);
>         buttonPanel.add(paintButton);
>         buttonPanel.add(separator1);
>         buttonPanel.add(enableButton);
>         buttonPanel.add(disableButton);
>         buttonPanel.add(separator2);
>         buttonPanel.add(tInsideButton);
>         buttonPanel.add(tOutsideButton);
>         filterMain.add(buttonPanel);
>         mainPanel.add(this.jScrollPaneImages);
>         mainPanel.add(Box.createVerticalStrut(5));
>         mainPanel.add(filterMain);
>         mainPanel.add(this.jScrollPaneTrack);
>         final JLabel settingsLabel = new JLabel("   Settings for Filters/Classes : ");
>         settingsLabel.setFont(new Font("Dialog", 1, 13));
>         settingsLabel.setBorder(BorderFactory.createRaisedBevelBorder());
>         final JPanel settingsPanel = new JPanel(new FlowLayout(0));
>         settingsPanel.add(settingsLabel);
>         mainPanel.add(settingsPanel);
>         final JPanel filtersMin = new JPanel(new FlowLayout(0));
>         (this.filterMin = new JSpinner(new SpinnerNumberModel(30, 0, 5000, 1))).setPreferredSize(new Dimension(60, 20));
>         final JSlider sliderMin = new JSlider(0, 300, 50);
>         sliderMin.setPreferredSize(new Dimension(150, 15));
>         final JLabel filterMinLabel = new JLabel("              Min :  ");
>         filtersMin.add(filterMinLabel);
>         filtersMin.add(sliderMin);
>         filtersMin.add(Box.createHorizontalStrut(2));
>         filtersMin.add(this.filterMin);
>         final JPanel filtersMax = new JPanel(new FlowLayout(0));
>         (this.filterMax = new JSpinner(new SpinnerNumberModel(200, 0, 5000, 1))).setPreferredSize(new Dimension(60, 20));
>         final JSlider sliderMax = new JSlider(0, 300, 150);
>         sliderMax.setPreferredSize(new Dimension(150, 15));
>         final JLabel filterMaxLabel = new JLabel("              Max :  ");
>         filtersMax.add(filterMaxLabel);
>         filtersMax.add(sliderMax);
>         filtersMax.add(Box.createHorizontalStrut(2));
>         filtersMax.add(this.filterMax);
>         final JPanel boxPanel2 = new JPanel();
>         boxPanel2.setLayout(new BoxLayout(boxPanel2, 1));
>         final IntervalMarker intervalMarker = new IntervalMarker(0.0, 0.0, (Paint)new Color(229, 255, 204), (Stroke)new BasicStroke(), (Paint)new Color(0, 102, 0), (Stroke)new BasicStroke(1.5f), 0.5f);
>         this.histogram = this.hs2.createChartPanel("", new double[] { 0.0, 0.0, 0.0 }, 100, intervalMarker);
>         final JPanel chartPanel2 = new JPanel(new BorderLayout());
>         chartPanel2.setPreferredSize(new Dimension(390, 180));
>         chartPanel2.add((Component)this.histogram);
>         boxPanel2.add(chartPanel2);
>         final JPanel controlPanel2 = this.hs2.createControlPanel();
>         boxPanel2.add(controlPanel2);
>         final JPanel filtersMain2 = new JPanel();
>         filtersMain2.setLayout(new BoxLayout(filtersMain2, 1));
>         filtersMain2.add(boxPanel2);
>         filtersMain2.add(filtersMin);
>         filtersMain2.add(filtersMax);
>         final JLabel featureTrack = new JLabel("  Track-Features :  ");
>         featureTrack.setFont(new Font("Dialog", 1, 13));
>         this.comboFilters = new JComboBox<String>();
>         for (int i = 1; i < ChooserWizardPanel.columnNamesTrack.length; ++i) {
>             this.comboFilters.addItem((String)ChooserWizardPanel.columnNamesTrack[i]);
>         }
>         this.comboFilters.setPreferredSize(new Dimension(130, 25));
>         this.comboFilters.setSelectedIndex(0);
>         this.comboFilters.setOpaque(true);
>         final JPanel panelFilters = new JPanel(new FlowLayout(0));
>         final JSeparator separator3 = new JSeparator(1);
>         final Dimension dime2 = separator3.getPreferredSize();
>         dime2.height = filtersMain2.getPreferredSize().height;
>         separator3.setPreferredSize(dime2);
>         panelFilters.add(filtersMain2);
>         panelFilters.add(separator3);
>         ChooserWizardPanel.modelListClass = new DefaultListModel<String>();
>         ChooserWizardPanel.classList = new JList<String>(ChooserWizardPanel.modelListClass);
>         ChooserWizardPanel.modelListFeature = new DefaultListModel<String>();
>         ChooserWizardPanel.featureList = new JList<String>(ChooserWizardPanel.modelListFeature);
>         final ColorEditorTrack colorEditor = new ColorEditorTrack(ChooserWizardPanel.featureList);
>         final JScrollPane scrollListFilter = new JScrollPane(ChooserWizardPanel.featureList);
>         final JScrollPane scrollListClass = new JScrollPane(ChooserWizardPanel.classList);
>         final Dimension d = ChooserWizardPanel.featureList.getPreferredSize();
>         d.width = 150;
>         d.height = 90;
>         scrollListFilter.setPreferredSize(d);
>         scrollListClass.setPreferredSize(d);
>         final JPanel filterPanelButtons = new JPanel(new FlowLayout(0));
>         final JPanel classPanelButtons = new JPanel();
>         classPanelButtons.setLayout(new BoxLayout(classPanelButtons, 1));
>         filterPanelButtons.add(scrollListFilter);
>         final JPanel fButtonsPanel = new JPanel();
>         fButtonsPanel.setLayout(new BoxLayout(fButtonsPanel, 1));
>         final JButton addButton = new JButton();
>         final ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
>         final Icon addCell = new ImageIcon(iconAdd.getImage().getScaledInstance(14, 16, 4));
>         addButton.setIcon(addCell);
>         addButton.setToolTipText("Click this button to add features");
>         final JButton remButton = new JButton();
>         final ImageIcon iconRem = FirstWizardPanel.createImageIcon("images/remove.png");
>         final Icon remCell = new ImageIcon(iconRem.getImage().getScaledInstance(14, 16, 4));
>         remButton.setIcon(remCell);
>         remButton.setToolTipText("Click this button to remove features");
>         final JButton classButton = new JButton();
>         final ImageIcon iconClass = FirstWizardPanel.createImageIcon("images/classes.png");
>         final Icon classCell = new ImageIcon(iconClass.getImage().getScaledInstance(14, 16, 4));
>         classButton.setIcon(classCell);
>         classButton.setToolTipText("Click this button to create a class.");
>         final JButton remClassButton = new JButton();
>         remClassButton.setIcon(remCell);
>         remClassButton.setToolTipText("Click this button to remove a class.");
>         fButtonsPanel.add(addButton);
>         fButtonsPanel.add(remButton);
>         filterPanelButtons.add(fButtonsPanel);
>         classPanelButtons.add(classButton);
>         classPanelButtons.add(remClassButton);
>         final JPanel classPanel = new JPanel(new FlowLayout(0));
>         classPanel.add(scrollListClass);
>         classPanel.add(classPanelButtons);
>         final JPanel boxPanel3 = new JPanel();
>         boxPanel3.setLayout(new BoxLayout(boxPanel3, 1));
>         boxPanel3.add(this.comboFilters);
>         boxPanel3.add(Box.createHorizontalStrut(5));
>         boxPanel3.add(filterPanelButtons);
>         boxPanel3.add(Box.createHorizontalStrut(5));
>         boxPanel3.add(classPanel);
>         boxPanel3.add(panelPngCsv);
>         panelFilters.add(boxPanel3);
>         mainPanel.add(panelFilters);
>         this.add((Component)tabbedPaneTrack);
>         this.createMovieTable();
>         paintButton.addItemListener(new ItemListener() {
>             @Override
>             public void itemStateChanged(final ItemEvent ev) {
>                 (ChooserWizardPanel.this.paintThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (ev.getStateChange() == 1) {
>                             ChooserWizardPanel.this.paintAndDisableAction();
355,384c340,341
<                      }
<                   }
< 
<                   rt.show("Resutls tracks");
<                }
<             });
<             ChooserWizardPanel.this.csvThread.start();
<          }
<       });
<       pngButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.pngThread = new Thread(new Runnable() {
<                public void run() {
<                   if (IJ.getImage() == null) {
<                      IJ.error("You must have an image window active.");
<                   }
< 
<                   if (IJ.getImage() != null) {
<                      JFrame pngFrame = new JFrame();
<                      JFileChooser fileChooser = new JFileChooser();
<                      fileChooser.setFileSelectionMode(1);
<                      fileChooser.setDialogTitle("Specify a directory to save");
<                      int userSelection = fileChooser.showSaveDialog(pngFrame);
<                      if (userSelection == 0) {
<                         File fileToSave = fileChooser.getSelectedFile();
<                         int firstFrame = 0;
<                         int lastFrame = 0;
<                         if (ProcessTrackMateXml.displayer.getImp().getNFrames() > 1) {
<                            firstFrame = Math.max(1, Math.min(IJ.getImage().getNFrames(), 1));
<                            lastFrame = Math.min(IJ.getImage().getNFrames(), Math.max(IJ.getImage().getNFrames(), 1));
---
>                         else if (ev.getStateChange() == 2) {
>                             ChooserWizardPanel.this.resetAndEnableAction();
386,389c343,355
< 
<                         if (ProcessTrackMateXml.displayer.getImp().getNSlices() > 1) {
<                            firstFrame = Math.max(1, Math.min(IJ.getImage().getNSlices(), 1));
<                            lastFrame = Math.min(IJ.getImage().getNSlices(), Math.max(IJ.getImage().getNSlices(), 1));
---
>                     }
>                 })).start();
>             }
>         });
>         csvButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (ChooserWizardPanel.this.csvThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         final List<String> columnTrackHead = new ArrayList<String>();
>                         for (int j = 0; j < ChooserWizardPanel.modelTrack.getColumnCount(); ++j) {
>                             columnTrackHead.add(ChooserWizardPanel.modelTrack.getColumnName(j));
391,407c357,359
< 
<                         Rectangle bounds = ProcessTrackMateXml.displayer.getImp().getCanvas().getBounds();
<                         int width = bounds.width;
<                         int height = bounds.height;
<                         int nCaptures = lastFrame - firstFrame + 1;
<                         ImageStack stack = new ImageStack(width, height);
<                         int channel = ProcessTrackMateXml.displayer.getImp().getChannel();
<                         int slice = ProcessTrackMateXml.displayer.getImp().getSlice();
<                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(true);
< 
<                         for(int frame = firstFrame; frame <= lastFrame; ++frame) {
<                            ProcessTrackMateXml.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
<                            BufferedImage bi = new BufferedImage(width, height, 2);
<                            ProcessTrackMateXml.displayer.getImp().getCanvas().paint(bi.getGraphics());
<                            ColorProcessor cp = new ColorProcessor(bi);
<                            int index = ProcessTrackMateXml.displayer.getImp().getStackIndex(channel, slice, frame);
<                            stack.addSlice(ProcessTrackMateXml.displayer.getImp().getImageStack().getSliceLabel(index), cp);
---
>                         final ResultsTable rt = new ResultsTable(Integer.valueOf(ChooserWizardPanel.modelTrack.getRowCount()));
>                         if (rt != null) {
>                             rt.reset();
409,677c361,725
< 
<                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(false);
<                         ImagePlus capture = new ImagePlus("TrackMate capture of " + ProcessTrackMateXml.displayer.getImp().getShortTitle(), stack);
<                         ChooserWizardPanel.transferCalibration(ProcessTrackMateXml.displayer.getImp(), capture);
<                         IJ.saveAs(capture, "Tiff", fileToSave.getAbsolutePath() + File.separator + "Capture Overlay for " + IJ.getImage().getShortTitle());
<                      }
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.pngThread.start();
<          }
<       });
<       refreshButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.refreshThread = new Thread(new Runnable() {
<                public void run() {
<                   ChooserWizardPanel.trackEnable = "trackEnable";
<                   ProcessTrackMateXml.tracksVisible = true;
<                   ProcessTrackMateXml.spotsVisible = false;
<                   ProcessTrackMateXml ptx = new ProcessTrackMateXml();
<                   ptx.processTrackMateXml();
<                }
<             });
<             ChooserWizardPanel.this.refreshThread.start();
<          }
<       });
<       enableButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.enableThread = new Thread(new Runnable() {
<                public void run() {
<                   ChooserWizardPanel.this.enableTracks();
<                }
<             });
<             ChooserWizardPanel.this.enableThread.start();
<          }
<       });
<       disableButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.disableThread = new Thread(new Runnable() {
<                public void run() {
<                   ChooserWizardPanel.this.disableTracks();
<                }
<             });
<             ChooserWizardPanel.this.disableThread.start();
<          }
<       });
<       this.checkRPicker.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent e) {
<             ChooserWizardPanel.this.pickerThread = new Thread(new Runnable() {
<                public void run() {
<                   if (e.getStateChange() == 1) {
<                      ChooserWizardPanel.command = "enable";
<                   }
< 
<                   if (e.getStateChange() == 2) {
<                      ChooserWizardPanel.command = null;
<                      ProcessTrackMateXml.selectionModel.clearSpotSelection();
<                      ProcessTrackMateXml.selectionModel.clearSelection();
<                   }
<                }
<             });
<             ChooserWizardPanel.this.pickerThread.start();
<          }
<       });
<       sliderMin.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             ChooserWizardPanel.this.slMinThread = new Thread(new Runnable() {
<                public void run() {
<                   ChooserWizardPanel.this.filterMin.setValue(sliderMin.getValue());
<                   intervalMarker.setStartValue((double)sliderMin.getValue());
<                }
<             });
<             ChooserWizardPanel.this.slMinThread.start();
<          }
<       });
<       this.filterMin.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             ChooserWizardPanel.this.filterMinThread = new Thread(new Runnable() {
<                public void run() {
<                   sliderMin.setValue((Integer)ChooserWizardPanel.this.filterMin.getValue());
<                   intervalMarker.setStartValue((double)(Integer)ChooserWizardPanel.this.filterMin.getValue());
<                }
<             });
<             ChooserWizardPanel.this.filterMinThread.start();
<          }
<       });
<       sliderMax.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             ChooserWizardPanel.this.slMaxThread = new Thread(new Runnable() {
<                public void run() {
<                   ChooserWizardPanel.this.filterMax.setValue(sliderMax.getValue());
<                   intervalMarker.setEndValue((double)sliderMax.getValue());
<                }
<             });
<             ChooserWizardPanel.this.slMaxThread.start();
<          }
<       });
<       this.filterMax.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             ChooserWizardPanel.this.filterMaxThread = new Thread(new Runnable() {
<                public void run() {
<                   sliderMax.setValue((Integer)ChooserWizardPanel.this.filterMax.getValue());
<                   intervalMarker.setEndValue((double)(Integer)ChooserWizardPanel.this.filterMax.getValue());
<                }
<             });
<             ChooserWizardPanel.this.filterMaxThread.start();
<          }
<       });
<       tInsideButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             ChooserWizardPanel.this.tInsideThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      ChooserWizardPanel.this.toggleInsideAction();
<                   } else if (ev.getStateChange() == 2) {
<                      ChooserWizardPanel.this.resetToggleInsideAction();
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.tInsideThread.start();
<          }
<       });
<       this.comboFilters.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.filtersThread = new Thread(new Runnable() {
<                public void run() {
<                   String selectedName = (String)ChooserWizardPanel.this.comboFilters.getSelectedItem();
<                   int selectedIndex = ChooserWizardPanel.this.comboFilters.getSelectedIndex();
<                   double[] valuesx = null;
<                   double[] values = new double[ChooserWizardPanel.tableTrack.getRowCount()];
< 
<                   int i;
<                   for(i = 0; i < ChooserWizardPanel.tableTrack.getRowCount(); ++i) {
<                      for(int c = 0; c < ChooserWizardPanel.tableTrack.getColumnCount(); ++c) {
<                         values[i] = Double.parseDouble((String)ChooserWizardPanel.tableTrack.getValueAt(i, selectedIndex + 2));
<                      }
<                   }
< 
<                   double max = values[0];
< 
<                   for(i = 1; i < values.length; ++i) {
<                      if (values[i] > max) {
<                         max = values[i];
<                      }
<                   }
< 
<                   sliderMin.setMinimum(0);
<                   sliderMin.setMaximum((int)max);
<                   sliderMax.setMinimum(0);
<                   sliderMax.setMaximum((int)max);
<                   ChooserWizardPanel.this.hs2.addHistogramSeries(selectedName, values, (int)max, intervalMarker);
<                }
<             });
<             ChooserWizardPanel.this.filtersThread.start();
<          }
<       });
<       classButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.classThread = new Thread(new Runnable() {
<                public void run() {
<                   ColorEditorTrack.myFrame.setVisible(true);
<                   colorEditor.setClassAction();
<                }
<             });
<             ChooserWizardPanel.this.classThread.start();
<          }
<       });
<       remClassButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.remClassThread = new Thread(new Runnable() {
<                public void run() {
<                   String classSelectedValue = (String)ChooserWizardPanel.classList.getSelectedValue();
<                   int[] classSelectedIndex = ChooserWizardPanel.classList.getSelectedIndices();
< 
<                   int i;
<                   for(i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<                      if (((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1))).getText().equals(classSelectedValue)) {
<                         ChooserWizardPanel.modelTrack.setValueAt(ChooserWizardPanel.labelReset, i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
<                      }
<                   }
< 
<                   for(i = 0; i < classSelectedIndex.length; ++i) {
<                      ChooserWizardPanel.modelListClass.removeElementAt(classSelectedIndex[i]);
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.remClassThread.start();
<          }
<       });
<       addButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.addThread = new Thread(new Runnable() {
<                public void run() {
<                   List<String> listFilters = new ArrayList();
<                   if (ChooserWizardPanel.featureList.getModel().getSize() < 1) {
<                      ChooserWizardPanel.modelListFeature.addElement((String)ChooserWizardPanel.this.comboFilters.getSelectedItem() + ":  [" + ChooserWizardPanel.this.filterMin.getValue() + "," + ChooserWizardPanel.this.filterMax.getValue() + "]");
<                   }
< 
<                   if (ChooserWizardPanel.featureList.getModel().getSize() >= 1) {
<                      for(int i = 0; i < ChooserWizardPanel.featureList.getModel().getSize(); ++i) {
<                         listFilters.add(String.valueOf(((String)ChooserWizardPanel.featureList.getModel().getElementAt(i)).substring(0, ((String)ChooserWizardPanel.featureList.getModel().getElementAt(i)).lastIndexOf(":"))));
<                      }
< 
<                      if (!listFilters.contains(ChooserWizardPanel.this.comboFilters.getSelectedItem().toString())) {
<                         ChooserWizardPanel.modelListFeature.addElement((String)ChooserWizardPanel.this.comboFilters.getSelectedItem() + ":  [" + ChooserWizardPanel.this.filterMin.getValue() + "," + ChooserWizardPanel.this.filterMax.getValue() + "]");
<                      }
< 
<                      if (listFilters.contains(ChooserWizardPanel.this.comboFilters.getSelectedItem().toString())) {
<                         return;
<                      }
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.addThread.start();
<          }
<       });
<       remButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.remThread = new Thread(new Runnable() {
<                public void run() {
<                   try {
<                      int[] indexes = ChooserWizardPanel.featureList.getSelectedIndices();
< 
<                      for(int i = 0; i < indexes.length; ++i) {
<                         ChooserWizardPanel.modelListFeature.remove(indexes[i]);
<                      }
<                   } catch (Exception var3) {
<                      var3.printStackTrace();
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.remThread.start();
<          }
<       });
<       tOutsideButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             ChooserWizardPanel.this.tOutsideThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      ChooserWizardPanel.this.toggleOutsideAction();
<                   } else if (ev.getStateChange() == 2) {
<                      ChooserWizardPanel.this.resetToggleInsideAction();
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.tOutsideThread.start();
<          }
<       });
<    }
< 
<    public void toggleOutsideAction() {
<       Roi mainRoi = null;
<       if (IJ.getImage().getRoi().getType() == 0) {
<          mainRoi = IJ.getImage().getRoi();
<       }
< 
<       this.indexesTI = new ArrayList();
< 
<       for(int i = 0; i < modelTrack.getRowCount(); ++i) {
<          if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(modelTrack.getValueAt(i, tableTrack.convertColumnIndexToModel(13)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(modelTrack.getValueAt(i, tableTrack.convertColumnIndexToModel(14)).toString()))) == Boolean.FALSE) {
<             this.indexesTI.add(i);
<             modelTrack.setValueAt(false, i, tableTrack.convertColumnIndexToModel(0));
<             int trackID = Integer.parseInt((String)tableTrack.getValueAt(i, 2));
---
>                         for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
>                             for (int k = 0; k < ChooserWizardPanel.modelTrack.getColumnCount(); ++k) {
>                                 if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE) {
>                                     if (columnTrackHead.get(k).equals(columnTrackHead.get(0)) == Boolean.TRUE) {
>                                         rt.setValue((String)columnTrackHead.get(k), i, ((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, k)).getText());
>                                     }
>                                     else {
>                                         rt.setValue((String)columnTrackHead.get(k), i, ChooserWizardPanel.modelTrack.getValueAt(i, k).toString());
>                                     }
>                                 }
>                             }
>                         }
>                         rt.show("Resutls tracks");
>                     }
>                 })).start();
>             }
>         });
>         pngButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (ChooserWizardPanel.this.pngThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (IJ.getImage() == null) {
>                             IJ.error("You must have an image window active.");
>                         }
>                         if (IJ.getImage() != null) {
>                             final JFrame pngFrame = new JFrame();
>                             final JFileChooser fileChooser = new JFileChooser();
>                             fileChooser.setFileSelectionMode(1);
>                             fileChooser.setDialogTitle("Specify a directory to save");
>                             final int userSelection = fileChooser.showSaveDialog(pngFrame);
>                             if (userSelection == 0) {
>                                 final File fileToSave = fileChooser.getSelectedFile();
>                                 int firstFrame = 0;
>                                 int lastFrame = 0;
>                                 if (ProcessTrackMateXml.displayer.getImp().getNFrames() > 1) {
>                                     firstFrame = Math.max(1, Math.min(IJ.getImage().getNFrames(), 1));
>                                     lastFrame = Math.min(IJ.getImage().getNFrames(), Math.max(IJ.getImage().getNFrames(), 1));
>                                 }
>                                 if (ProcessTrackMateXml.displayer.getImp().getNSlices() > 1) {
>                                     firstFrame = Math.max(1, Math.min(IJ.getImage().getNSlices(), 1));
>                                     lastFrame = Math.min(IJ.getImage().getNSlices(), Math.max(IJ.getImage().getNSlices(), 1));
>                                 }
>                                 final Rectangle bounds = ProcessTrackMateXml.displayer.getImp().getCanvas().getBounds();
>                                 final int width = bounds.width;
>                                 final int height = bounds.height;
>                                 final int nCaptures = lastFrame - firstFrame + 1;
>                                 final ImageStack stack = new ImageStack(width, height);
>                                 final int channel = ProcessTrackMateXml.displayer.getImp().getChannel();
>                                 final int slice = ProcessTrackMateXml.displayer.getImp().getSlice();
>                                 ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(true);
>                                 for (int frame = firstFrame; frame <= lastFrame; ++frame) {
>                                     ProcessTrackMateXml.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
>                                     final BufferedImage bi = new BufferedImage(width, height, 2);
>                                     ProcessTrackMateXml.displayer.getImp().getCanvas().paint(bi.getGraphics());
>                                     final ColorProcessor cp = new ColorProcessor((Image)bi);
>                                     final int index = ProcessTrackMateXml.displayer.getImp().getStackIndex(channel, slice, frame);
>                                     stack.addSlice(ProcessTrackMateXml.displayer.getImp().getImageStack().getSliceLabel(index), (ImageProcessor)cp);
>                                 }
>                                 ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(false);
>                                 final ImagePlus capture = new ImagePlus("TrackMate capture of " + ProcessTrackMateXml.displayer.getImp().getShortTitle(), stack);
>                                 transferCalibration(ProcessTrackMateXml.displayer.getImp(), capture);
>                                 IJ.saveAs(capture, "Tiff", String.valueOf(fileToSave.getAbsolutePath()) + File.separator + "Capture Overlay for " + IJ.getImage().getShortTitle());
>                             }
>                         }
>                     }
>                 })).start();
>             }
>         });
>         refreshButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (ChooserWizardPanel.this.refreshThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         ChooserWizardPanel.trackEnable = "trackEnable";
>                         ProcessTrackMateXml.tracksVisible = true;
>                         ProcessTrackMateXml.spotsVisible = false;
>                         final ProcessTrackMateXml ptx = new ProcessTrackMateXml();
>                         ptx.processTrackMateXml();
>                     }
>                 })).start();
>             }
>         });
>         enableButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (ChooserWizardPanel.this.enableThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         ChooserWizardPanel.this.enableTracks();
>                     }
>                 })).start();
>             }
>         });
>         disableButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (ChooserWizardPanel.this.disableThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         ChooserWizardPanel.this.disableTracks();
>                     }
>                 })).start();
>             }
>         });
>         this.checkRPicker.addItemListener(new ItemListener() {
>             @Override
>             public void itemStateChanged(final ItemEvent e) {
>                 (ChooserWizardPanel.this.pickerThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (e.getStateChange() == 1) {
>                             ChooserWizardPanel.command = "enable";
>                         }
>                         if (e.getStateChange() == 2) {
>                             ChooserWizardPanel.command = null;
>                             ProcessTrackMateXml.selectionModel.clearSpotSelection();
>                             ProcessTrackMateXml.selectionModel.clearSelection();
>                         }
>                     }
>                 })).start();
>             }
>         });
>         sliderMin.addChangeListener(new ChangeListener() {
>             @Override
>             public void stateChanged(final ChangeEvent e) {
>                 (ChooserWizardPanel.this.slMinThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         ChooserWizardPanel.this.filterMin.setValue(sliderMin.getValue());
>                         intervalMarker.setStartValue((double)sliderMin.getValue());
>                     }
>                 })).start();
>             }
>         });
>         this.filterMin.addChangeListener(new ChangeListener() {
>             @Override
>             public void stateChanged(final ChangeEvent e) {
>                 (ChooserWizardPanel.this.filterMinThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         sliderMin.setValue((int)ChooserWizardPanel.this.filterMin.getValue());
>                         intervalMarker.setStartValue((double)(int)ChooserWizardPanel.this.filterMin.getValue());
>                     }
>                 })).start();
>             }
>         });
>         sliderMax.addChangeListener(new ChangeListener() {
>             @Override
>             public void stateChanged(final ChangeEvent e) {
>                 (ChooserWizardPanel.this.slMaxThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         ChooserWizardPanel.this.filterMax.setValue(sliderMax.getValue());
>                         intervalMarker.setEndValue((double)sliderMax.getValue());
>                     }
>                 })).start();
>             }
>         });
>         this.filterMax.addChangeListener(new ChangeListener() {
>             @Override
>             public void stateChanged(final ChangeEvent e) {
>                 (ChooserWizardPanel.this.filterMaxThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         sliderMax.setValue((int)ChooserWizardPanel.this.filterMax.getValue());
>                         intervalMarker.setEndValue((double)(int)ChooserWizardPanel.this.filterMax.getValue());
>                     }
>                 })).start();
>             }
>         });
>         tInsideButton.addItemListener(new ItemListener() {
>             @Override
>             public void itemStateChanged(final ItemEvent ev) {
>                 (ChooserWizardPanel.this.tInsideThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (ev.getStateChange() == 1) {
>                             ChooserWizardPanel.this.toggleInsideAction();
>                         }
>                         else if (ev.getStateChange() == 2) {
>                             ChooserWizardPanel.this.resetToggleInsideAction();
>                         }
>                     }
>                 })).start();
>             }
>         });
>         this.comboFilters.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (ChooserWizardPanel.this.filtersThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         final String selectedName = (String)ChooserWizardPanel.this.comboFilters.getSelectedItem();
>                         final int selectedIndex = ChooserWizardPanel.this.comboFilters.getSelectedIndex();
>                         double[] values = null;
>                         values = new double[ChooserWizardPanel.tableTrack.getRowCount()];
>                         for (int r = 0; r < ChooserWizardPanel.tableTrack.getRowCount(); ++r) {
>                             for (int c = 0; c < ChooserWizardPanel.tableTrack.getColumnCount(); ++c) {
>                                 values[r] = Double.parseDouble((String)ChooserWizardPanel.tableTrack.getValueAt(r, selectedIndex + 2));
>                             }
>                         }
>                         double max = values[0];
>                         for (int i = 1; i < values.length; ++i) {
>                             if (values[i] > max) {
>                                 max = values[i];
>                             }
>                         }
>                         sliderMin.setMinimum(0);
>                         sliderMin.setMaximum((int)max);
>                         sliderMax.setMinimum(0);
>                         sliderMax.setMaximum((int)max);
>                         ChooserWizardPanel.this.hs2.addHistogramSeries(selectedName, values, (int)max, intervalMarker);
>                     }
>                 })).start();
>             }
>         });
>         classButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (ChooserWizardPanel.this.classThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         ColorEditorTrack.myFrame.setVisible(true);
>                         colorEditor.setClassAction();
>                     }
>                 })).start();
>             }
>         });
>         remClassButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (ChooserWizardPanel.this.remClassThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         final String classSelectedValue = ChooserWizardPanel.classList.getSelectedValue();
>                         final int[] classSelectedIndex = ChooserWizardPanel.classList.getSelectedIndices();
>                         for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
>                             if (((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1))).getText().equals(classSelectedValue)) {
>                                 ChooserWizardPanel.modelTrack.setValueAt(ChooserWizardPanel.labelReset, i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
>                             }
>                         }
>                         for (int i = 0; i < classSelectedIndex.length; ++i) {
>                             ChooserWizardPanel.modelListClass.removeElementAt(classSelectedIndex[i]);
>                         }
>                     }
>                 })).start();
>             }
>         });
>         addButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (ChooserWizardPanel.this.addThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         final List<String> listFilters = new ArrayList<String>();
>                         if (ChooserWizardPanel.featureList.getModel().getSize() < 1) {
>                             ChooserWizardPanel.modelListFeature.addElement(String.valueOf(ChooserWizardPanel.this.comboFilters.getSelectedItem()) + ":  [" + ChooserWizardPanel.this.filterMin.getValue() + "," + ChooserWizardPanel.this.filterMax.getValue() + "]");
>                         }
>                         if (ChooserWizardPanel.featureList.getModel().getSize() >= 1) {
>                             for (int i = 0; i < ChooserWizardPanel.featureList.getModel().getSize(); ++i) {
>                                 listFilters.add(String.valueOf(ChooserWizardPanel.featureList.getModel().getElementAt(i).substring(0, ChooserWizardPanel.featureList.getModel().getElementAt(i).lastIndexOf(":"))));
>                             }
>                             if (!listFilters.contains(ChooserWizardPanel.this.comboFilters.getSelectedItem().toString())) {
>                                 ChooserWizardPanel.modelListFeature.addElement(String.valueOf(ChooserWizardPanel.this.comboFilters.getSelectedItem()) + ":  [" + ChooserWizardPanel.this.filterMin.getValue() + "," + ChooserWizardPanel.this.filterMax.getValue() + "]");
>                             }
>                             if (listFilters.contains(ChooserWizardPanel.this.comboFilters.getSelectedItem().toString())) {
>                                 return;
>                             }
>                         }
>                     }
>                 })).start();
>             }
>         });
>         remButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (ChooserWizardPanel.this.remThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         try {
>                             final int[] indexes = ChooserWizardPanel.featureList.getSelectedIndices();
>                             for (int i = 0; i < indexes.length; ++i) {
>                                 ChooserWizardPanel.modelListFeature.remove(indexes[i]);
>                             }
>                         }
>                         catch (Exception e1) {
>                             e1.printStackTrace();
>                         }
>                     }
>                 })).start();
>             }
>         });
>         tOutsideButton.addItemListener(new ItemListener() {
>             @Override
>             public void itemStateChanged(final ItemEvent ev) {
>                 (ChooserWizardPanel.this.tOutsideThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (ev.getStateChange() == 1) {
>                             ChooserWizardPanel.this.toggleOutsideAction();
>                         }
>                         else if (ev.getStateChange() == 2) {
>                             ChooserWizardPanel.this.resetToggleInsideAction();
>                         }
>                     }
>                 })).start();
>             }
>         });
>     }
>     
>     public void toggleOutsideAction() {
>         Roi mainRoi = null;
>         if (IJ.getImage().getRoi().getType() == 0) {
>             mainRoi = IJ.getImage().getRoi();
>         }
>         this.indexesTI = new ArrayList<Integer>();
>         for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
>             if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(13)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(14)).toString()))) == Boolean.FALSE) {
>                 this.indexesTI.add(i);
>                 ChooserWizardPanel.modelTrack.setValueAt(false, i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(0));
>                 final int trackID = Integer.parseInt((String)ChooserWizardPanel.tableTrack.getValueAt(i, 2));
>                 ProcessTrackMateXml.model.beginUpdate();
>                 try {
>                     ProcessTrackMateXml.model.setTrackVisibility(Integer.valueOf(trackID), false);
>                 }
>                 finally {
>                     ProcessTrackMateXml.model.endUpdate();
>                 }
>                 ProcessTrackMateXml.model.endUpdate();
>                 ProcessTrackMateXml.displayer.refresh();
>             }
>         }
>     }
>     
>     public void toggleInsideAction() {
>         Roi mainRoi = null;
>         if (IJ.getImage().getRoi().getType() == 0) {
>             mainRoi = IJ.getImage().getRoi();
>         }
>         this.indexesTI = new ArrayList<Integer>();
>         for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
>             if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(13)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(14)).toString()))) == Boolean.TRUE) {
>                 this.indexesTI.add(i);
>                 ChooserWizardPanel.modelTrack.setValueAt(false, i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(0));
>                 final int trackID = Integer.parseInt((String)ChooserWizardPanel.tableTrack.getValueAt(i, 2));
>                 ProcessTrackMateXml.model.beginUpdate();
>                 try {
>                     ProcessTrackMateXml.model.setTrackVisibility(Integer.valueOf(trackID), false);
>                 }
>                 finally {
>                     ProcessTrackMateXml.model.endUpdate();
>                 }
>                 ProcessTrackMateXml.model.endUpdate();
>                 ProcessTrackMateXml.displayer.refresh();
>             }
>         }
>     }
>     
>     public void resetToggleInsideAction() {
>         for (int row = 0; row < ChooserWizardPanel.modelTrack.getRowCount(); ++row) {
>             ChooserWizardPanel.modelTrack.setValueAt(true, ChooserWizardPanel.tableTrack.convertRowIndexToModel(row), ChooserWizardPanel.tableTrack.convertColumnIndexToModel(0));
>             final int trackID = Integer.parseInt((String)ChooserWizardPanel.tableTrack.getValueAt(row, 2));
679d726
< 
681,683c728
<                ProcessTrackMateXml.model.setTrackVisibility(trackID, false);
<             } finally {
<                ProcessTrackMateXml.model.endUpdate();
---
>                 ProcessTrackMateXml.model.setTrackVisibility(Integer.valueOf(trackID), true);
685c730,733
< 
---
>             finally {
>                 ProcessTrackMateXml.model.endUpdate();
>             }
>             ProcessTrackMateXml.model.endUpdate();
687,704c735,789
<          }
<       }
< 
<    }
< 
<    public void toggleInsideAction() {
<       Roi mainRoi = null;
<       if (IJ.getImage().getRoi().getType() == 0) {
<          mainRoi = IJ.getImage().getRoi();
<       }
< 
<       this.indexesTI = new ArrayList();
< 
<       for(int i = 0; i < modelTrack.getRowCount(); ++i) {
<          if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(modelTrack.getValueAt(i, tableTrack.convertColumnIndexToModel(13)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(modelTrack.getValueAt(i, tableTrack.convertColumnIndexToModel(14)).toString()))) == Boolean.TRUE) {
<             this.indexesTI.add(i);
<             modelTrack.setValueAt(false, i, tableTrack.convertColumnIndexToModel(0));
<             int trackID = Integer.parseInt((String)tableTrack.getValueAt(i, 2));
---
>         }
>     }
>     
>     public static void createTrackTable() {
>         (ChooserWizardPanel.modelTrack = new DefaultTableModel(ProcessTrackMateXml.dataTrack, ProcessTrackMateXml.columnHeadersTrack) {
>             @Override
>             public Class<?> getColumnClass(final int column) {
>                 if (this.getRowCount() > 0) {
>                     final Object value = this.getValueAt(0, column);
>                     if (value != null) {
>                         return this.getValueAt(0, column).getClass();
>                     }
>                 }
>                 return super.getColumnClass(column);
>             }
>         }).addColumn("Enable");
>         ChooserWizardPanel.tableTrack.setModel(ChooserWizardPanel.modelTrack);
>         ChooserWizardPanel.tableTrack.moveColumn(ChooserWizardPanel.tableTrack.getColumnCount() - 1, 0);
>         ChooserWizardPanel.tableTrack.setSelectionBackground(new Color(229, 255, 204));
>         ChooserWizardPanel.tableTrack.setSelectionForeground(new Color(0, 102, 0));
>         final DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
>         centerRenderer.setHorizontalAlignment(0);
>         ChooserWizardPanel.tableTrack.setDefaultRenderer(String.class, centerRenderer);
>         ChooserWizardPanel.tableTrack.setAutoResizeMode(0);
>         ChooserWizardPanel.tableTrack.setRowHeight(45);
>         ChooserWizardPanel.tableTrack.setAutoCreateRowSorter(true);
>         ChooserWizardPanel.tableTrack.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
>         for (int u = 0; u < ChooserWizardPanel.tableTrack.getColumnCount(); ++u) {
>             ChooserWizardPanel.tableTrack.getColumnModel().getColumn(u).setPreferredWidth(90);
>         }
>         for (int u = 3; u < ChooserWizardPanel.tableTrack.getColumnCount(); ++u) {
>             ChooserWizardPanel.tableTrack.getColumnModel().getColumn(u).setPreferredWidth(130);
>         }
>         for (int i = 0; i < ChooserWizardPanel.tableTrack.getRowCount(); ++i) {
>             ChooserWizardPanel.tableTrack.setValueAt(true, i, 0);
>         }
>         ChooserWizardPanel.tableTrack.getColumnModel().getColumn(1).setCellRenderer(new Renderer());
>         (ChooserWizardPanel.labelReset = new JLabel()).setText("");
>         ChooserWizardPanel.labelReset.setOpaque(true);
>         ChooserWizardPanel.labelReset.setBackground(new Color(214, 217, 223));
>         for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
>             ChooserWizardPanel.modelTrack.setValueAt(ChooserWizardPanel.labelReset, i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
>         }
>     }
>     
>     public void enableTracks() {
>         this.indexesToReset1 = new ArrayList<Integer>();
>         this.tracksID1 = new ArrayList<Integer>();
>         final int[] selectedRows = ChooserWizardPanel.tableTrack.getSelectedRows();
>         for (int i = 0; i < selectedRows.length; ++i) {
>             this.indexesToReset1.add(selectedRows[i]);
>             ChooserWizardPanel.modelTrack.setValueAt(true, selectedRows[i], ChooserWizardPanel.tableTrack.convertColumnIndexToModel(0));
>             this.tracksID1.add(Integer.parseInt((String)ChooserWizardPanel.tableTrack.getValueAt(selectedRows[i], 2)));
>         }
>         for (int row = 0; row < this.tracksID1.size(); ++row) {
706d790
< 
708,710c792
<                ProcessTrackMateXml.model.setTrackVisibility(trackID, false);
<             } finally {
<                ProcessTrackMateXml.model.endUpdate();
---
>                 ProcessTrackMateXml.model.setTrackVisibility(Integer.valueOf(this.tracksID1.get(row)), true);
712,743c794,795
< 
<             ProcessTrackMateXml.displayer.refresh();
<          }
<       }
< 
<    }
< 
<    public void resetToggleInsideAction() {
<       for(int row = 0; row < modelTrack.getRowCount(); ++row) {
<          modelTrack.setValueAt(true, tableTrack.convertRowIndexToModel(row), tableTrack.convertColumnIndexToModel(0));
<          int trackID = Integer.parseInt((String)tableTrack.getValueAt(row, 2));
<          ProcessTrackMateXml.model.beginUpdate();
< 
<          try {
<             ProcessTrackMateXml.model.setTrackVisibility(trackID, true);
<          } finally {
<             ProcessTrackMateXml.model.endUpdate();
<          }
< 
<          ProcessTrackMateXml.displayer.refresh();
<       }
< 
<    }
< 
<    public static void createTrackTable() {
<       modelTrack = new DefaultTableModel(ProcessTrackMateXml.dataTrack, ProcessTrackMateXml.columnHeadersTrack) {
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
---
>             finally {
>                 ProcessTrackMateXml.model.endUpdate();
745,804d796
< 
<             return super.getColumnClass(column);
<          }
<       };
<       modelTrack.addColumn("Enable");
<       tableTrack.setModel(modelTrack);
<       tableTrack.moveColumn(tableTrack.getColumnCount() - 1, 0);
<       tableTrack.setSelectionBackground(new Color(229, 255, 204));
<       tableTrack.setSelectionForeground(new Color(0, 102, 0));
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableTrack.setDefaultRenderer(String.class, centerRenderer);
<       tableTrack.setAutoResizeMode(0);
<       tableTrack.setRowHeight(45);
<       tableTrack.setAutoCreateRowSorter(true);
<       tableTrack.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
< 
<       int i;
<       for(i = 0; i < tableTrack.getColumnCount(); ++i) {
<          tableTrack.getColumnModel().getColumn(i).setPreferredWidth(90);
<       }
< 
<       for(i = 3; i < tableTrack.getColumnCount(); ++i) {
<          tableTrack.getColumnModel().getColumn(i).setPreferredWidth(130);
<       }
< 
<       for(i = 0; i < tableTrack.getRowCount(); ++i) {
<          tableTrack.setValueAt(true, i, 0);
<       }
< 
<       tableTrack.getColumnModel().getColumn(1).setCellRenderer(new Renderer());
<       labelReset = new JLabel();
<       labelReset.setText("");
<       labelReset.setOpaque(true);
<       labelReset.setBackground(new Color(214, 217, 223));
< 
<       for(i = 0; i < modelTrack.getRowCount(); ++i) {
<          modelTrack.setValueAt(labelReset, i, tableTrack.convertColumnIndexToModel(1));
<       }
< 
<    }
< 
<    public void enableTracks() {
<       this.indexesToReset1 = new ArrayList();
<       this.tracksID1 = new ArrayList();
<       int[] selectedRows = tableTrack.getSelectedRows();
< 
<       int row;
<       for(row = 0; row < selectedRows.length; ++row) {
<          this.indexesToReset1.add(selectedRows[row]);
<          modelTrack.setValueAt(true, selectedRows[row], tableTrack.convertColumnIndexToModel(0));
<          this.tracksID1.add(Integer.parseInt((String)tableTrack.getValueAt(selectedRows[row], 2)));
<       }
< 
<       for(row = 0; row < this.tracksID1.size(); ++row) {
<          ProcessTrackMateXml.model.beginUpdate();
< 
<          try {
<             ProcessTrackMateXml.model.setTrackVisibility((Integer)this.tracksID1.get(row), true);
<          } finally {
806,830c798,818
<          }
< 
<          ProcessTrackMateXml.displayer.refresh();
<       }
< 
<    }
< 
<    public void disableTracks() {
<       this.indexesToReset1 = new ArrayList();
<       this.tracksID1 = new ArrayList();
<       int[] selectedRows = tableTrack.getSelectedRows();
< 
<       int row;
<       for(row = 0; row < selectedRows.length; ++row) {
<          this.indexesToReset1.add(selectedRows[row]);
<          modelTrack.setValueAt(false, selectedRows[row], tableTrack.convertColumnIndexToModel(0));
<          this.tracksID1.add(Integer.parseInt((String)tableTrack.getValueAt(selectedRows[row], 2)));
<       }
< 
<       for(row = 0; row < this.tracksID1.size(); ++row) {
<          ProcessTrackMateXml.model.beginUpdate();
< 
<          try {
<             ProcessTrackMateXml.model.setTrackVisibility((Integer)this.tracksID1.get(row), false);
<          } finally {
---
>             ProcessTrackMateXml.displayer.refresh();
>         }
>     }
>     
>     public void disableTracks() {
>         this.indexesToReset1 = new ArrayList<Integer>();
>         this.tracksID1 = new ArrayList<Integer>();
>         final int[] selectedRows = ChooserWizardPanel.tableTrack.getSelectedRows();
>         for (int i = 0; i < selectedRows.length; ++i) {
>             this.indexesToReset1.add(selectedRows[i]);
>             ChooserWizardPanel.modelTrack.setValueAt(false, selectedRows[i], ChooserWizardPanel.tableTrack.convertColumnIndexToModel(0));
>             this.tracksID1.add(Integer.parseInt((String)ChooserWizardPanel.tableTrack.getValueAt(selectedRows[i], 2)));
>         }
>         for (int row = 0; row < this.tracksID1.size(); ++row) {
>             ProcessTrackMateXml.model.beginUpdate();
>             try {
>                 ProcessTrackMateXml.model.setTrackVisibility(Integer.valueOf(this.tracksID1.get(row)), false);
>             }
>             finally {
>                 ProcessTrackMateXml.model.endUpdate();
>             }
832,870c820,854
<          }
< 
<          ProcessTrackMateXml.displayer.refresh();
<       }
< 
<    }
< 
<    public void createMovieTable() {
<       tableImages.setSelectionBackground(new Color(229, 255, 204));
<       tableImages.setSelectionForeground(new Color(0, 102, 0));
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableImages.setDefaultRenderer(String.class, centerRenderer);
<       tableImages.setAutoResizeMode(0);
<       tableImages.setRowHeight(95);
<       tableImages.setAutoCreateRowSorter(true);
<       tableImages.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
<       tableImages.setModel(FirstWizardPanel.modelImages);
<    }
< 
<    public void paintAndDisableAction() {
<       this.indexesToReset = new ArrayList();
<       this.tracksID = new ArrayList();
< 
<       int row;
<       for(row = 0; row < modelTrack.getRowCount(); ++row) {
<          if (((JLabel)modelTrack.getValueAt(row, tableTrack.convertColumnIndexToModel(1))).getBackground().equals(new Color(214, 217, 223)) == Boolean.TRUE) {
<             this.indexesToReset.add(row);
<             modelTrack.setValueAt(false, row, tableTrack.convertColumnIndexToModel(0));
<             this.tracksID.add(Integer.parseInt((String)tableTrack.getValueAt(row, 2)));
<          }
<       }
< 
<       for(row = 0; row < this.tracksID.size(); ++row) {
<          ProcessTrackMateXml.model.beginUpdate();
< 
<          try {
<             ProcessTrackMateXml.model.setTrackVisibility((Integer)this.tracksID.get(row), false);
<          } finally {
---
>             ProcessTrackMateXml.displayer.refresh();
>         }
>     }
>     
>     public void createMovieTable() {
>         ChooserWizardPanel.tableImages.setSelectionBackground(new Color(229, 255, 204));
>         ChooserWizardPanel.tableImages.setSelectionForeground(new Color(0, 102, 0));
>         final DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
>         centerRenderer.setHorizontalAlignment(0);
>         ChooserWizardPanel.tableImages.setDefaultRenderer(String.class, centerRenderer);
>         ChooserWizardPanel.tableImages.setAutoResizeMode(0);
>         ChooserWizardPanel.tableImages.setRowHeight(95);
>         ChooserWizardPanel.tableImages.setAutoCreateRowSorter(true);
>         ChooserWizardPanel.tableImages.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
>         ChooserWizardPanel.tableImages.setModel(FirstWizardPanel.modelImages);
>     }
>     
>     public void paintAndDisableAction() {
>         this.indexesToReset = new ArrayList<Integer>();
>         this.tracksID = new ArrayList<Integer>();
>         for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
>             if (((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1))).getBackground().equals(new Color(214, 217, 223)) == Boolean.TRUE) {
>                 this.indexesToReset.add(i);
>                 ChooserWizardPanel.modelTrack.setValueAt(false, i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(0));
>                 this.tracksID.add(Integer.parseInt((String)ChooserWizardPanel.tableTrack.getValueAt(i, 2)));
>             }
>         }
>         for (int row = 0; row < this.tracksID.size(); ++row) {
>             ProcessTrackMateXml.model.beginUpdate();
>             try {
>                 ProcessTrackMateXml.model.setTrackVisibility(Integer.valueOf(this.tracksID.get(row)), false);
>             }
>             finally {
>                 ProcessTrackMateXml.model.endUpdate();
>             }
872,890c856,871
<          }
< 
<          ProcessTrackMateXml.displayer.refresh();
<       }
< 
<    }
< 
<    public void resetAndEnableAction() {
<       int row;
<       for(row = 0; row < this.indexesToReset.size(); ++row) {
<          modelTrack.setValueAt(true, tableTrack.convertRowIndexToModel((Integer)this.indexesToReset.get(row)), tableTrack.convertColumnIndexToModel(0));
<       }
< 
<       for(row = 0; row < this.tracksID.size(); ++row) {
<          ProcessTrackMateXml.model.beginUpdate();
< 
<          try {
<             ProcessTrackMateXml.model.setTrackVisibility((Integer)this.tracksID.get(row), true);
<          } finally {
---
>             ProcessTrackMateXml.displayer.refresh();
>         }
>     }
>     
>     public void resetAndEnableAction() {
>         for (int i = 0; i < this.indexesToReset.size(); ++i) {
>             ChooserWizardPanel.modelTrack.setValueAt(true, ChooserWizardPanel.tableTrack.convertRowIndexToModel(this.indexesToReset.get(i)), ChooserWizardPanel.tableTrack.convertColumnIndexToModel(0));
>         }
>         for (int row = 0; row < this.tracksID.size(); ++row) {
>             ProcessTrackMateXml.model.beginUpdate();
>             try {
>                 ProcessTrackMateXml.model.setTrackVisibility(Integer.valueOf(this.tracksID.get(row)), true);
>             }
>             finally {
>                 ProcessTrackMateXml.model.endUpdate();
>             }
892,922c873,901
<          }
<       }
< 
<       ProcessTrackMateXml.displayer.refresh();
<    }
< 
<    public void update() {
<       this.setNextButtonEnabled(true);
<       this.setFinishButtonEnabled(true);
<       this.setBackButtonEnabled(true);
<    }
< 
<    public void next() {
<       this.switchPanel(2);
<    }
< 
<    public void back() {
<       this.switchPanel(0);
<    }
< 
<    private static final void transferCalibration(ImagePlus from, ImagePlus to) {
<       Calibration fc = from.getCalibration();
<       Calibration tc = to.getCalibration();
<       tc.setUnit(fc.getUnit());
<       tc.setTimeUnit(fc.getTimeUnit());
<       tc.frameInterval = fc.frameInterval;
<       double mag = from.getCanvas().getMagnification();
<       tc.pixelWidth = fc.pixelWidth / mag;
<       tc.pixelHeight = fc.pixelHeight / mag;
<       tc.pixelDepth = fc.pixelDepth;
<    }
---
>         }
>         ProcessTrackMateXml.displayer.refresh();
>     }
>     
>     public void update() {
>         this.setNextButtonEnabled(true);
>         this.setFinishButtonEnabled(true);
>         this.setBackButtonEnabled(true);
>     }
>     
>     public void next() {
>         this.switchPanel(2);
>     }
>     
>     public void back() {
>         this.switchPanel(0);
>     }
>     
>     private static final void transferCalibration(final ImagePlus from, final ImagePlus to) {
>         final Calibration fc = from.getCalibration();
>         final Calibration tc = to.getCalibration();
>         tc.setUnit(fc.getUnit());
>         tc.setTimeUnit(fc.getTimeUnit());
>         tc.frameInterval = fc.frameInterval;
>         final double mag = from.getCanvas().getMagnification();
>         tc.pixelWidth = fc.pixelWidth / mag;
>         tc.pixelHeight = fc.pixelHeight / mag;
>         tc.pixelDepth = fc.pixelDepth;
>     }
diff -r TrackAnalyzer_/ClusterSizeAnalysis.java procyon/ClusterSizeAnalysis.java
0a1,2
> import smileModified.MixtureModified;
> import smileModified.GaussianMixtureModified;
3c5
< import java.util.List;
---
> import org.jfree.chart.renderer.xy.XYBarRenderer;
6d7
< import org.jfree.chart.renderer.xy.XYBarRenderer;
8,23c9
< import smileModified.GaussianMixtureModified;
< import smileModified.MixtureModified;
< 
< public class ClusterSizeAnalysis {
<    List<Double> pdf = new ArrayList();
<    double[] values;
<    int BINS;
<    HistogramDataset dataset;
<    XYPlot plot;
<    ChartPanel panel;
<    XYBarRenderer renderer;
<    Integer nOfTrack;
< 
<    public void Compute(List<Double> xData, Integer nOfTrack) {
<       double[] xDataArray = new double[xData.size()];
<       float[] xDataArrayFloat = new float[xData.size()];
---
> import java.util.List;
25,28c11,13
<       for(int i = 0; i < xData.size(); ++i) {
<          xDataArray[i] = (Double)xData.get(i);
<          xDataArrayFloat[i] = ((Double)xData.get(i)).floatValue();
<       }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
30,42c15,47
<       double meanValue = Double.valueOf(xData.stream().mapToDouble((a) -> {
<          return a;
<       }).average().getAsDouble());
<       Histogram histogram = new Histogram(xDataArrayFloat);
<       int BINS = histogram.getBinCount();
<       long[] counts = histogram.getCounts();
<       float[] densities = histogram.getDensities();
<       GaussianMixtureModified gm2 = GaussianMixtureModified.fit(xDataArray);
<       int k = gm2.size();
<       MixtureModified.Component[] components = gm2.components;
<       NormalDistributionMine nd = new NormalDistributionMine(nOfTrack, components, xDataArray.length, meanValue);
<       nd.runNormalDistribution();
<    }
---
> public class ClusterSizeAnalysis
> {
>     List<Double> pdf;
>     double[] values;
>     int BINS;
>     HistogramDataset dataset;
>     XYPlot plot;
>     ChartPanel panel;
>     XYBarRenderer renderer;
>     Integer nOfTrack;
>     
>     public ClusterSizeAnalysis() {
>         this.pdf = new ArrayList<Double>();
>     }
>     
>     public void Compute(final List<Double> xData, final Integer nOfTrack) {
>         final double[] xDataArray = new double[xData.size()];
>         final float[] xDataArrayFloat = new float[xData.size()];
>         for (int i = 0; i < xData.size(); ++i) {
>             xDataArray[i] = xData.get(i);
>             xDataArrayFloat[i] = xData.get(i).floatValue();
>         }
>         final double meanValue = xData.stream().mapToDouble(a -> a).average().getAsDouble();
>         final Histogram histogram = new Histogram(xDataArrayFloat);
>         final int BINS = histogram.getBinCount();
>         final long[] counts = histogram.getCounts();
>         final float[] densities = histogram.getDensities();
>         final GaussianMixtureModified gm2 = GaussianMixtureModified.fit(xDataArray);
>         final int k = gm2.size();
>         final MixtureModified.Component[] components = gm2.components;
>         final NormalDistributionMine nd = new NormalDistributionMine(nOfTrack, components, xDataArray.length, meanValue);
>         nd.runNormalDistribution();
>     }
diff -r TrackAnalyzer_/ColorEditorSpot.java procyon/ColorEditorSpot.java
1,9c1
< import java.awt.Color;
< import java.awt.Component;
< import java.awt.Dimension;
< import java.awt.FlowLayout;
< import java.awt.Point;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.WindowEvent;
< import java.util.ArrayList;
---
> import javax.swing.JOptionPane;
10a3,6
> import java.util.ArrayList;
> import javax.swing.table.TableColumn;
> import javax.swing.JColorChooser;
> import javax.swing.JComponent;
12c8,13
< import javax.swing.AbstractCellEditor;
---
> import java.awt.AWTEvent;
> import java.awt.Window;
> import java.awt.event.WindowEvent;
> import java.awt.event.ActionEvent;
> import java.awt.event.ActionListener;
> import java.awt.Dimension;
13a15,24
> import javax.swing.JScrollPane;
> import java.awt.Component;
> import java.awt.FlowLayout;
> import javax.swing.RowSorter;
> import javax.swing.table.DefaultTableCellRenderer;
> import javax.swing.table.TableModel;
> import javax.swing.table.TableRowSorter;
> import javax.swing.table.TableCellRenderer;
> import java.awt.LayoutManager;
> import java.awt.Container;
15,16c26
< import javax.swing.DefaultListModel;
< import javax.swing.Icon;
---
> import java.awt.Point;
18,19c28
< import javax.swing.JButton;
< import javax.swing.JColorChooser;
---
> import javax.swing.Icon;
21c30,32
< import javax.swing.JLabel;
---
> import java.awt.Color;
> import javax.swing.JTextField;
> import javax.swing.DefaultListModel;
23,25c34
< import javax.swing.JOptionPane;
< import javax.swing.JPanel;
< import javax.swing.JScrollPane;
---
> import javax.swing.JButton;
27,28d35
< import javax.swing.JTextField;
< import javax.swing.table.DefaultTableCellRenderer;
29a37,38
> import javax.swing.JLabel;
> import javax.swing.JPanel;
31,425c40
< import javax.swing.table.TableColumn;
< import javax.swing.table.TableModel;
< import javax.swing.table.TableRowSorter;
< 
< public class ColorEditorSpot extends AbstractCellEditor implements TableCellEditor {
<    private JPanel myPanel;
<    private JPanel panelAdd;
<    private JPanel panelEdit;
<    private JLabel labelInitt;
<    private int result;
<    private int input;
<    static DefaultTableModel modelC;
<    static JTable tableC;
<    private JButton addButton;
<    private JButton editButton;
<    private JButton deleteButton;
<    private JButton colorButtonAdd;
<    private JButton colorButtonEdit;
<    private JButton okButton;
<    private JButton okButtonEdit;
<    private JButton cancelButton;
<    private JButton cancelButtonEdit;
<    private JButton okButtonAdd;
<    private JButton cancelButtonAdd;
<    static JList<String> featureList;
<    static JList<String> classList;
<    static DefaultListModel<String> modelListFeature;
<    static DefaultListModel<String> modelListClass;
<    private JLabel addTextAdd;
<    private JLabel addTextEdit;
<    private JTextField addTextFAdd;
<    private JTextField addTextFEdit;
<    private Color currentColorAdd;
<    private Color currentColorEdit;
<    private Color colorCInitial;
<    private Color colorCFinal;
<    private Object labelC;
<    private Object colorC;
<    private Object featureC;
<    private String addTextInitial;
<    private String addTextFinal;
<    private String featureInitial;
<    private String featureFinal;
<    static JFrame myFrame;
<    static JFrame myFrameAdd;
<    static JFrame myFrameEdit;
<    private Icon iconOKCell;
<    private Icon iconCancelCell;
<    private int indexRowC;
< 
<    public ColorEditorSpot(final JList<String> featureList) {
<       ColorEditorSpot.featureList = featureList;
<       this.addButton = new JButton("");
<       this.addButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
<       Icon iconAddCell = new ImageIcon(iconAdd.getImage().getScaledInstance(17, 15, 4));
<       this.addButton.setIcon(iconAddCell);
<       this.addButton.setToolTipText("Click this button to add your class-label.");
<       this.editButton = new JButton("");
<       this.editButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconEdit = FirstWizardPanel.createImageIcon("images/edit.png");
<       Icon iconEditCell = new ImageIcon(iconEdit.getImage().getScaledInstance(17, 15, 4));
<       this.editButton.setIcon(iconEditCell);
<       this.editButton.setToolTipText("Click this button to edit your class-label.");
<       this.deleteButton = new JButton("");
<       this.deleteButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconDelete = FirstWizardPanel.createImageIcon("images/bin.png");
<       Icon iconDeleteCell = new ImageIcon(iconDelete.getImage().getScaledInstance(22, 20, 4));
<       this.deleteButton.setIcon(iconDeleteCell);
<       this.deleteButton.setToolTipText("Click this button to delete your class-label.");
<       myFrame = new JFrame("Manage Labels");
<       myFrame.setLocation(new Point(100, 100));
<       myFrame.setDefaultCloseOperation(2);
<       this.myPanel = new JPanel();
<       this.myPanel.setLayout(new BoxLayout(this.myPanel, 1));
<       Object[][] rowData2 = new Object[0][];
<       Object[] columnNames = new Object[]{"Name", "Color", "Feature"};
<       modelC = new DefaultTableModel(rowData2, columnNames) {
<          private static final long serialVersionUID = 1L;
< 
<          public boolean isCellEditable(int row, int col) {
<             return false;
<          }
< 
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
<             }
< 
<             return super.getColumnClass(column);
<          }
<       };
<       tableC = new JTable();
<       tableC.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
<       tableC.setSelectionBackground(new Color(229, 255, 204));
<       tableC.setSelectionForeground(new Color(0, 102, 0));
<       TableRowSorter<TableModel> rowSorter = new TableRowSorter(modelC);
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableC.setDefaultRenderer(JLabel.class, centerRenderer);
<       tableC.setRowSorter(rowSorter);
<       JPanel panelButtons = new JPanel();
<       panelButtons.setLayout(new FlowLayout());
<       panelButtons.add(this.addButton);
<       panelButtons.add(this.editButton);
<       panelButtons.add(this.deleteButton);
<       tableC.setAutoCreateRowSorter(true);
<       tableC.setEnabled(true);
<       tableC.setCellSelectionEnabled(true);
<       tableC.setRowSelectionAllowed(true);
<       tableC.setColumnSelectionAllowed(false);
<       tableC.setSelectionMode(2);
<       tableC.setDefaultRenderer(JLabel.class, new Renderer());
<       tableC.setDefaultRenderer(Color.class, new ColorRenderer(true));
<       tableC.setModel(modelC);
<       TableColumn column1 = null;
<       column1 = tableC.getColumnModel().getColumn(0);
<       column1.setPreferredWidth(7);
<       column1.setCellRenderer(new ResultRendererC());
<       TableColumn column2 = null;
<       column2 = tableC.getColumnModel().getColumn(1);
<       column2.setPreferredWidth(5);
<       column2.setCellRenderer(new ResultRendererC());
<       TableColumn column3 = null;
<       column3 = tableC.getColumnModel().getColumn(2);
<       column3.setPreferredWidth(15);
<       column3.setCellRenderer(new ResultRendererC());
<       JScrollPane scrollPane = new JScrollPane(tableC);
< 
<       for(int u = 0; u < tableC.getColumnCount(); ++u) {
<          tableC.getColumnModel().getColumn(u).setPreferredWidth(90);
<       }
< 
<       tableC.setRowHeight(25);
<       this.myPanel.add(Box.createHorizontalStrut(15));
<       this.myPanel.add(panelButtons);
<       this.myPanel.add(scrollPane, "Center");
<       this.myPanel.setSize(300, 150);
<       this.myPanel.add(Box.createHorizontalStrut(15));
<       this.okButton = new JButton("");
<       this.okButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconOk = FirstWizardPanel.createImageIcon("images/add.png");
<       this.iconOKCell = new ImageIcon(iconOk.getImage().getScaledInstance(17, 15, 4));
<       this.okButton.setIcon(this.iconOKCell);
<       this.okButton.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButton = new JButton("");
<       this.cancelButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconCancel = FirstWizardPanel.createImageIcon("images/cancel.png");
<       this.iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(17, 15, 4));
<       this.cancelButton.setIcon(this.iconCancelCell);
<       this.cancelButton.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancel = new JPanel();
<       panelOkCancel.setLayout(new FlowLayout());
<       panelOkCancel.add(this.okButton);
<       panelOkCancel.add(this.cancelButton);
<       this.myPanel.add(panelOkCancel);
<       myFrame.getContentPane().add(this.myPanel);
<       myFrame.pack();
<       myFrame.setLocationByPlatform(true);
<       this.panelAdd = new JPanel();
<       this.panelAdd.setPreferredSize(new Dimension(200, 100));
<       JPanel panel1 = new JPanel();
<       panel1.setLayout(new FlowLayout());
<       this.panelAdd.setLayout(new FlowLayout());
<       this.addTextAdd = new JLabel("Label Name: ");
<       this.addTextFAdd = new JTextField(8);
<       panel1.add(this.addTextAdd);
<       panel1.add(this.addTextFAdd);
<       JLabel pickC = new JLabel("Pick a color: ");
<       this.panelAdd.add(pickC);
<       this.colorButtonAdd = new JButton();
<       this.colorButtonAdd.setPreferredSize(new Dimension(200, 75));
<       this.panelAdd.add(this.colorButtonAdd);
<       this.okButtonAdd = new JButton("");
<       this.okButtonAdd.setBounds(50, 100, 95, 30);
<       this.okButtonAdd.setIcon(this.iconOKCell);
<       this.okButtonAdd.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButtonAdd = new JButton("");
<       this.cancelButtonAdd.setBounds(50, 100, 95, 30);
<       this.cancelButtonAdd.setIcon(this.iconCancelCell);
<       this.cancelButtonAdd.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancelAdd = new JPanel();
<       panelOkCancelAdd.setLayout(new FlowLayout());
<       panelOkCancelAdd.add(this.okButtonAdd);
<       panelOkCancelAdd.add(this.cancelButtonAdd);
<       myFrameAdd = new JFrame("Add Label");
<       JPanel mainPanel = new JPanel();
<       mainPanel.add(panel1);
<       mainPanel.add(this.panelAdd);
<       mainPanel.add(panelOkCancelAdd);
<       myFrameAdd.setPreferredSize(new Dimension(250, 250));
<       myFrameAdd.getContentPane().add(mainPanel);
<       myFrameAdd.pack();
<       myFrameAdd.setLocationByPlatform(true);
<       JPanel panel = new JPanel();
<       panel.setPreferredSize(new Dimension(200, 100));
<       JPanel panel2 = new JPanel();
<       panel2.setLayout(new FlowLayout());
<       panel.setLayout(new FlowLayout());
<       this.addTextEdit = new JLabel("Label Name: ");
<       this.addTextFEdit = new JTextField(8);
<       panel2.add(this.addTextEdit);
<       panel2.add(this.addTextFEdit);
<       JLabel pickEdit = new JLabel("Pick a Color: ");
<       panel.add(pickEdit);
<       this.colorButtonEdit = new JButton();
<       this.colorButtonEdit.setPreferredSize(new Dimension(200, 75));
<       panel.add(this.colorButtonEdit);
<       this.okButtonEdit = new JButton("");
<       this.okButtonEdit.setBounds(50, 100, 95, 30);
<       this.okButtonEdit.setIcon(this.iconOKCell);
<       this.okButtonEdit.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButtonEdit = new JButton("");
<       this.cancelButtonEdit.setBounds(50, 100, 95, 30);
<       this.cancelButtonEdit.setIcon(this.iconCancelCell);
<       this.cancelButtonEdit.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancelEdit = new JPanel();
<       panelOkCancelEdit.setLayout(new FlowLayout());
<       panelOkCancelEdit.add(this.okButtonEdit);
<       panelOkCancelEdit.add(this.cancelButtonEdit);
<       myFrameEdit = new JFrame("Edit Label");
<       JPanel mainPanelEdit = new JPanel();
<       mainPanelEdit.add(panel2);
<       mainPanelEdit.add(panel);
<       mainPanelEdit.add(panelOkCancelEdit);
<       myFrameEdit.setPreferredSize(new Dimension(250, 250));
<       myFrameEdit.getContentPane().add(mainPanelEdit);
<       myFrameEdit.pack();
<       myFrameEdit.setLocationByPlatform(true);
<       this.addButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorSpot.tableC.setRowHeight(featureList.getHeight());
<             ColorEditorSpot.myFrameAdd.setVisible(true);
<          }
<       });
<       this.okButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             JLabel labelString = new JLabel();
<             JLabel labelColor = new JLabel();
<             JLabel labelFeature = new JLabel();
<             labelColor.setText("");
<             labelColor.setBackground(ColorEditorSpot.this.currentColorAdd);
<             labelString.setText(ColorEditorSpot.this.addTextFAdd.getText());
<             labelString.setHorizontalAlignment(0);
<             labelString.setBackground(ColorEditorSpot.this.currentColorAdd);
<             labelColor.setOpaque(true);
<             StringBuilder filterItems = new StringBuilder();
< 
<             for(int x = 0; x < featureList.getModel().getSize(); ++x) {
<                filterItems.append((String)featureList.getModel().getElementAt(x)).append("<br>");
<             }
< 
<             labelFeature.setText("<html>" + filterItems.toString() + "</html>");
<             ColorEditorSpot.modelC.addRow(new Object[]{labelString, labelColor, labelFeature});
<             ColorEditorSpot.modelC.fireTableDataChanged();
<             ColorEditorSpot.tableC.repaint();
<             ColorEditorSpot.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameAdd, 201));
<          }
<       });
<       this.cancelButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorSpot.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameAdd, 201));
<          }
<       });
<       this.editButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorSpot.myFrameEdit.setVisible(true);
<             ColorEditorSpot.this.indexRowC = ColorEditorSpot.tableC.getSelectedRow();
<             if (ColorEditorSpot.tableC.getSelectedRowCount() != 0) {
<                if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
<                   ColorEditorSpot.this.labelC = new Object();
<                   ColorEditorSpot.this.colorC = new Object();
<                   ColorEditorSpot.this.labelC = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<                   ColorEditorSpot.this.colorC = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<                   ColorEditorSpot.this.addTextInitial = ((JLabel)ColorEditorSpot.this.labelC).getText();
<                   ColorEditorSpot.this.colorCInitial = ((JLabel)ColorEditorSpot.this.colorC).getBackground();
<                }
< 
<                ColorEditorSpot.this.colorButtonEdit.setBackground(((JLabel)ColorEditorSpot.this.colorC).getBackground());
<                ColorEditorSpot.this.currentColorEdit = ((JLabel)ColorEditorSpot.this.colorC).getBackground();
<                ColorEditorSpot.this.colorButtonEdit.setContentAreaFilled(false);
<                ColorEditorSpot.this.colorButtonEdit.setOpaque(true);
<                ColorEditorSpot.this.addTextFEdit.setText(((JLabel)ColorEditorSpot.this.labelC).getText());
<             }
<          }
<       });
<       this.colorButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Locale.setDefault(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.getDefault());
<             ColorEditorSpot.this.currentColorAdd = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorSpot.this.colorButtonAdd.getBackground());
<             if (ColorEditorSpot.this.currentColorAdd != null) {
<                ColorEditorSpot.this.colorButtonAdd.setBackground(ColorEditorSpot.this.currentColorAdd);
<             }
< 
<          }
<       });
<       this.okButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             JLabel labelString = new JLabel();
<             JLabel labelColor = new JLabel();
<             labelColor.setText("");
<             labelColor.setBackground(ColorEditorSpot.this.currentColorEdit);
<             labelString.setText(ColorEditorSpot.this.addTextFEdit.getText());
<             labelString.setHorizontalAlignment(0);
<             labelString.setBackground(ColorEditorSpot.this.currentColorEdit);
<             labelColor.setOpaque(true);
<             ColorEditorSpot.this.addTextFinal = labelString.getText();
<             ColorEditorSpot.this.colorCFinal = labelColor.getBackground();
<             if (!ColorEditorSpot.this.addTextFinal.equals(ColorEditorSpot.this.addTextInitial)) {
<                ColorEditorSpot.modelC.setValueAt(labelString, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<             }
< 
<             if (ColorEditorSpot.this.addTextFinal.equals(ColorEditorSpot.this.addTextInitial)) {
<                ColorEditorSpot.modelC.setValueAt(ColorEditorSpot.this.labelC, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<             }
< 
<             if (ColorEditorSpot.this.currentColorEdit != ColorEditorSpot.this.colorCInitial) {
<                ColorEditorSpot.modelC.setValueAt(labelColor, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<             }
< 
<             if (ColorEditorSpot.this.currentColorEdit == ColorEditorSpot.this.colorCInitial) {
<                ColorEditorSpot.modelC.setValueAt(ColorEditorSpot.this.colorC, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<             }
< 
<             ColorEditorSpot.modelC.fireTableCellUpdated(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<             ColorEditorSpot.modelC.fireTableCellUpdated(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<             ColorEditorSpot.tableC.repaint();
<             ColorEditorSpot.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameEdit, 201));
<          }
<       });
<       this.cancelButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorSpot.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameEdit, 201));
<          }
<       });
<    }
< 
<    public void setClassAction() {
<       this.colorButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Locale.setDefault(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.getDefault());
<             ColorEditorSpot.this.currentColorEdit = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorSpot.this.colorButtonEdit.getBackground());
<             if (ColorEditorSpot.this.currentColorEdit != null) {
<                ColorEditorSpot.this.colorButtonEdit.setBackground(ColorEditorSpot.this.currentColorEdit);
<             }
< 
<          }
<       });
<       this.okButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             if (ColorEditorSpot.tableC.getSelectedRowCount() <= 0) {
<                ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
<             }
< 
<             if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
<                List<String> listClasses = new ArrayList();
<                ColorEditorSpot.classList = FirstWizardPanel.classList;
<                ColorEditorSpot.modelListClass = FirstWizardPanel.modelListClass;
<                int selectedRow = ColorEditorSpot.tableC.getSelectedRow();
<                JLabel labelsTableC;
<                int ix;
<                ArrayList features;
<                ArrayList featureMin;
<                ArrayList featureMax;
<                int x;
<                int u;
<                String[] filterFeature;
<                if (ColorEditorSpot.modelListClass.getSize() == 0) {
<                   ColorEditorSpot.modelListClass.addElement(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
<                   labelsTableC = new JLabel();
< 
<                   for(ix = 0; ix < ColorEditorSpot.tableC.getModel().getRowCount(); ++ix) {
<                      labelsTableC.setText(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
<                      labelsTableC.setHorizontalAlignment(0);
<                      labelsTableC.setBackground(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(1))).getBackground());
<                      labelsTableC.setOpaque(true);
<                   }
< 
<                   filterFeature = ((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
<                   features = new ArrayList();
<                   featureMin = new ArrayList();
<                   featureMax = new ArrayList();
< 
<                   for(x = 0; x < filterFeature.length; ++x) {
<                      features.add(filterFeature[x].substring(0, filterFeature[x].indexOf(":")));
<                      featureMin.add(filterFeature[x].substring(filterFeature[x].indexOf("[") + 1, filterFeature[x].indexOf(",")));
<                      featureMax.add(filterFeature[x].substring(filterFeature[x].indexOf(",") + 1, filterFeature[x].indexOf("]")));
<                   }
---
> import javax.swing.AbstractCellEditor;
427,430c42,401
<                   for(x = 0; x < FirstWizardPanel.modelSpot.getRowCount(); ++x) {
<                      for(u = 0; u < features.size(); ++u) {
<                         if (Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble((String)featureMin.get(u)) && Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble((String)featureMax.get(u))) {
<                            FirstWizardPanel.tableSpot.getModel().setValueAt(labelsTableC, FirstWizardPanel.tableSpot.convertRowIndexToModel(x), FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class ColorEditorSpot extends AbstractCellEditor implements TableCellEditor
> {
>     private JPanel myPanel;
>     private JPanel panelAdd;
>     private JPanel panelEdit;
>     private JLabel labelInitt;
>     private int result;
>     private int input;
>     static DefaultTableModel modelC;
>     static JTable tableC;
>     private JButton addButton;
>     private JButton editButton;
>     private JButton deleteButton;
>     private JButton colorButtonAdd;
>     private JButton colorButtonEdit;
>     private JButton okButton;
>     private JButton okButtonEdit;
>     private JButton cancelButton;
>     private JButton cancelButtonEdit;
>     private JButton okButtonAdd;
>     private JButton cancelButtonAdd;
>     static JList<String> featureList;
>     static JList<String> classList;
>     static DefaultListModel<String> modelListFeature;
>     static DefaultListModel<String> modelListClass;
>     private JLabel addTextAdd;
>     private JLabel addTextEdit;
>     private JTextField addTextFAdd;
>     private JTextField addTextFEdit;
>     private Color currentColorAdd;
>     private Color currentColorEdit;
>     private Color colorCInitial;
>     private Color colorCFinal;
>     private Object labelC;
>     private Object colorC;
>     private Object featureC;
>     private String addTextInitial;
>     private String addTextFinal;
>     private String featureInitial;
>     private String featureFinal;
>     static JFrame myFrame;
>     static JFrame myFrameAdd;
>     static JFrame myFrameEdit;
>     private Icon iconOKCell;
>     private Icon iconCancelCell;
>     private int indexRowC;
>     
>     public ColorEditorSpot(final JList<String> featureList) {
>         ColorEditorSpot.featureList = featureList;
>         (this.addButton = new JButton("")).setBounds(50, 100, 95, 30);
>         final ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
>         final Icon iconAddCell = new ImageIcon(iconAdd.getImage().getScaledInstance(17, 15, 4));
>         this.addButton.setIcon(iconAddCell);
>         this.addButton.setToolTipText("Click this button to add your class-label.");
>         (this.editButton = new JButton("")).setBounds(50, 100, 95, 30);
>         final ImageIcon iconEdit = FirstWizardPanel.createImageIcon("images/edit.png");
>         final Icon iconEditCell = new ImageIcon(iconEdit.getImage().getScaledInstance(17, 15, 4));
>         this.editButton.setIcon(iconEditCell);
>         this.editButton.setToolTipText("Click this button to edit your class-label.");
>         (this.deleteButton = new JButton("")).setBounds(50, 100, 95, 30);
>         final ImageIcon iconDelete = FirstWizardPanel.createImageIcon("images/bin.png");
>         final Icon iconDeleteCell = new ImageIcon(iconDelete.getImage().getScaledInstance(22, 20, 4));
>         this.deleteButton.setIcon(iconDeleteCell);
>         this.deleteButton.setToolTipText("Click this button to delete your class-label.");
>         (ColorEditorSpot.myFrame = new JFrame("Manage Labels")).setLocation(new Point(100, 100));
>         ColorEditorSpot.myFrame.setDefaultCloseOperation(2);
>         (this.myPanel = new JPanel()).setLayout(new BoxLayout(this.myPanel, 1));
>         final Object[][] rowData2 = new Object[0][];
>         final Object[] columnNames = { "Name", "Color", "Feature" };
>         ColorEditorSpot.modelC = new DefaultTableModel(rowData2, columnNames) {
>             private static final long serialVersionUID = 1L;
>             
>             @Override
>             public boolean isCellEditable(final int row, final int col) {
>                 return false;
>             }
>             
>             @Override
>             public Class<?> getColumnClass(final int column) {
>                 if (this.getRowCount() > 0) {
>                     final Object value = this.getValueAt(0, column);
>                     if (value != null) {
>                         return this.getValueAt(0, column).getClass();
>                     }
>                 }
>                 return super.getColumnClass(column);
>             }
>         };
>         ColorEditorSpot.tableC = new JTable();
>         ColorEditorSpot.tableC.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
>         ColorEditorSpot.tableC.setSelectionBackground(new Color(229, 255, 204));
>         ColorEditorSpot.tableC.setSelectionForeground(new Color(0, 102, 0));
>         final TableRowSorter<TableModel> rowSorter = new TableRowSorter<TableModel>(ColorEditorSpot.modelC);
>         final DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
>         centerRenderer.setHorizontalAlignment(0);
>         ColorEditorSpot.tableC.setDefaultRenderer(JLabel.class, centerRenderer);
>         ColorEditorSpot.tableC.setRowSorter((RowSorter<? extends TableModel>)rowSorter);
>         final JPanel panelButtons = new JPanel();
>         panelButtons.setLayout(new FlowLayout());
>         panelButtons.add(this.addButton);
>         panelButtons.add(this.editButton);
>         panelButtons.add(this.deleteButton);
>         ColorEditorSpot.tableC.setAutoCreateRowSorter(true);
>         ColorEditorSpot.tableC.setEnabled(true);
>         ColorEditorSpot.tableC.setCellSelectionEnabled(true);
>         ColorEditorSpot.tableC.setRowSelectionAllowed(true);
>         ColorEditorSpot.tableC.setColumnSelectionAllowed(false);
>         ColorEditorSpot.tableC.setSelectionMode(2);
>         ColorEditorSpot.tableC.setDefaultRenderer(JLabel.class, new Renderer());
>         ColorEditorSpot.tableC.setDefaultRenderer(Color.class, new ColorRenderer(true));
>         ColorEditorSpot.tableC.setModel(ColorEditorSpot.modelC);
>         TableColumn column1 = null;
>         column1 = ColorEditorSpot.tableC.getColumnModel().getColumn(0);
>         column1.setPreferredWidth(7);
>         column1.setCellRenderer((TableCellRenderer)new ResultRendererC());
>         TableColumn column2 = null;
>         column2 = ColorEditorSpot.tableC.getColumnModel().getColumn(1);
>         column2.setPreferredWidth(5);
>         column2.setCellRenderer((TableCellRenderer)new ResultRendererC());
>         TableColumn column3 = null;
>         column3 = ColorEditorSpot.tableC.getColumnModel().getColumn(2);
>         column3.setPreferredWidth(15);
>         column3.setCellRenderer((TableCellRenderer)new ResultRendererC());
>         final JScrollPane scrollPane = new JScrollPane(ColorEditorSpot.tableC);
>         for (int u = 0; u < ColorEditorSpot.tableC.getColumnCount(); ++u) {
>             ColorEditorSpot.tableC.getColumnModel().getColumn(u).setPreferredWidth(90);
>         }
>         ColorEditorSpot.tableC.setRowHeight(25);
>         this.myPanel.add(Box.createHorizontalStrut(15));
>         this.myPanel.add(panelButtons);
>         this.myPanel.add(scrollPane, "Center");
>         this.myPanel.setSize(300, 150);
>         this.myPanel.add(Box.createHorizontalStrut(15));
>         (this.okButton = new JButton("")).setBounds(50, 100, 95, 30);
>         final ImageIcon iconOk = FirstWizardPanel.createImageIcon("images/add.png");
>         this.iconOKCell = new ImageIcon(iconOk.getImage().getScaledInstance(17, 15, 4));
>         this.okButton.setIcon(this.iconOKCell);
>         this.okButton.setToolTipText("Click this button to edit your color selection.");
>         (this.cancelButton = new JButton("")).setBounds(50, 100, 95, 30);
>         final ImageIcon iconCancel = FirstWizardPanel.createImageIcon("images/cancel.png");
>         this.iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(17, 15, 4));
>         this.cancelButton.setIcon(this.iconCancelCell);
>         this.cancelButton.setToolTipText("Click this button to cancel your color selection.");
>         final JPanel panelOkCancel = new JPanel();
>         panelOkCancel.setLayout(new FlowLayout());
>         panelOkCancel.add(this.okButton);
>         panelOkCancel.add(this.cancelButton);
>         this.myPanel.add(panelOkCancel);
>         ColorEditorSpot.myFrame.getContentPane().add(this.myPanel);
>         ColorEditorSpot.myFrame.pack();
>         ColorEditorSpot.myFrame.setLocationByPlatform(true);
>         (this.panelAdd = new JPanel()).setPreferredSize(new Dimension(200, 100));
>         final JPanel panel1 = new JPanel();
>         panel1.setLayout(new FlowLayout());
>         this.panelAdd.setLayout(new FlowLayout());
>         this.addTextAdd = new JLabel("Label Name: ");
>         this.addTextFAdd = new JTextField(8);
>         panel1.add(this.addTextAdd);
>         panel1.add(this.addTextFAdd);
>         final JLabel pickC = new JLabel("Pick a color: ");
>         this.panelAdd.add(pickC);
>         (this.colorButtonAdd = new JButton()).setPreferredSize(new Dimension(200, 75));
>         this.panelAdd.add(this.colorButtonAdd);
>         (this.okButtonAdd = new JButton("")).setBounds(50, 100, 95, 30);
>         this.okButtonAdd.setIcon(this.iconOKCell);
>         this.okButtonAdd.setToolTipText("Click this button to edit your color selection.");
>         (this.cancelButtonAdd = new JButton("")).setBounds(50, 100, 95, 30);
>         this.cancelButtonAdd.setIcon(this.iconCancelCell);
>         this.cancelButtonAdd.setToolTipText("Click this button to cancel your color selection.");
>         final JPanel panelOkCancelAdd = new JPanel();
>         panelOkCancelAdd.setLayout(new FlowLayout());
>         panelOkCancelAdd.add(this.okButtonAdd);
>         panelOkCancelAdd.add(this.cancelButtonAdd);
>         ColorEditorSpot.myFrameAdd = new JFrame("Add Label");
>         final JPanel mainPanel = new JPanel();
>         mainPanel.add(panel1);
>         mainPanel.add(this.panelAdd);
>         mainPanel.add(panelOkCancelAdd);
>         ColorEditorSpot.myFrameAdd.setPreferredSize(new Dimension(250, 250));
>         ColorEditorSpot.myFrameAdd.getContentPane().add(mainPanel);
>         ColorEditorSpot.myFrameAdd.pack();
>         ColorEditorSpot.myFrameAdd.setLocationByPlatform(true);
>         final JPanel panel2 = new JPanel();
>         panel2.setPreferredSize(new Dimension(200, 100));
>         final JPanel panel3 = new JPanel();
>         panel3.setLayout(new FlowLayout());
>         panel2.setLayout(new FlowLayout());
>         this.addTextEdit = new JLabel("Label Name: ");
>         this.addTextFEdit = new JTextField(8);
>         panel3.add(this.addTextEdit);
>         panel3.add(this.addTextFEdit);
>         final JLabel pickEdit = new JLabel("Pick a Color: ");
>         panel2.add(pickEdit);
>         (this.colorButtonEdit = new JButton()).setPreferredSize(new Dimension(200, 75));
>         panel2.add(this.colorButtonEdit);
>         (this.okButtonEdit = new JButton("")).setBounds(50, 100, 95, 30);
>         this.okButtonEdit.setIcon(this.iconOKCell);
>         this.okButtonEdit.setToolTipText("Click this button to edit your color selection.");
>         (this.cancelButtonEdit = new JButton("")).setBounds(50, 100, 95, 30);
>         this.cancelButtonEdit.setIcon(this.iconCancelCell);
>         this.cancelButtonEdit.setToolTipText("Click this button to cancel your color selection.");
>         final JPanel panelOkCancelEdit = new JPanel();
>         panelOkCancelEdit.setLayout(new FlowLayout());
>         panelOkCancelEdit.add(this.okButtonEdit);
>         panelOkCancelEdit.add(this.cancelButtonEdit);
>         ColorEditorSpot.myFrameEdit = new JFrame("Edit Label");
>         final JPanel mainPanelEdit = new JPanel();
>         mainPanelEdit.add(panel3);
>         mainPanelEdit.add(panel2);
>         mainPanelEdit.add(panelOkCancelEdit);
>         ColorEditorSpot.myFrameEdit.setPreferredSize(new Dimension(250, 250));
>         ColorEditorSpot.myFrameEdit.getContentPane().add(mainPanelEdit);
>         ColorEditorSpot.myFrameEdit.pack();
>         ColorEditorSpot.myFrameEdit.setLocationByPlatform(true);
>         this.addButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 ColorEditorSpot.tableC.setRowHeight(featureList.getHeight());
>                 ColorEditorSpot.myFrameAdd.setVisible(true);
>             }
>         });
>         this.okButtonAdd.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 final JLabel labelString = new JLabel();
>                 final JLabel labelColor = new JLabel();
>                 final JLabel labelFeature = new JLabel();
>                 labelColor.setText("");
>                 labelColor.setBackground(ColorEditorSpot.this.currentColorAdd);
>                 labelString.setText(ColorEditorSpot.this.addTextFAdd.getText());
>                 labelString.setHorizontalAlignment(0);
>                 labelString.setBackground(ColorEditorSpot.this.currentColorAdd);
>                 labelColor.setOpaque(true);
>                 final StringBuilder filterItems = new StringBuilder();
>                 for (int x = 0; x < featureList.getModel().getSize(); ++x) {
>                     filterItems.append(featureList.getModel().getElementAt(x)).append("<br>");
>                 }
>                 labelFeature.setText("<html>" + filterItems.toString() + "</html>");
>                 ColorEditorSpot.modelC.addRow(new Object[] { labelString, labelColor, labelFeature });
>                 ColorEditorSpot.modelC.fireTableDataChanged();
>                 ColorEditorSpot.tableC.repaint();
>                 ColorEditorSpot.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameAdd, 201));
>             }
>         });
>         this.cancelButtonAdd.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 ColorEditorSpot.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameAdd, 201));
>             }
>         });
>         this.editButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 ColorEditorSpot.myFrameEdit.setVisible(true);
>                 ColorEditorSpot.access$2(ColorEditorSpot.this, ColorEditorSpot.tableC.getSelectedRow());
>                 if (ColorEditorSpot.tableC.getSelectedRowCount() == 0) {
>                     return;
>                 }
>                 if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
>                     ColorEditorSpot.access$3(ColorEditorSpot.this, new Object());
>                     ColorEditorSpot.access$4(ColorEditorSpot.this, new Object());
>                     ColorEditorSpot.access$3(ColorEditorSpot.this, ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0)));
>                     ColorEditorSpot.access$4(ColorEditorSpot.this, ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1)));
>                     ColorEditorSpot.access$7(ColorEditorSpot.this, ((JLabel)ColorEditorSpot.this.labelC).getText());
>                     ColorEditorSpot.access$9(ColorEditorSpot.this, ((JLabel)ColorEditorSpot.this.colorC).getBackground());
>                 }
>                 ColorEditorSpot.this.colorButtonEdit.setBackground(((JLabel)ColorEditorSpot.this.colorC).getBackground());
>                 ColorEditorSpot.access$11(ColorEditorSpot.this, ((JLabel)ColorEditorSpot.this.colorC).getBackground());
>                 ColorEditorSpot.this.colorButtonEdit.setContentAreaFilled(false);
>                 ColorEditorSpot.this.colorButtonEdit.setOpaque(true);
>                 ColorEditorSpot.this.addTextFEdit.setText(((JLabel)ColorEditorSpot.this.labelC).getText());
>             }
>         });
>         this.colorButtonAdd.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 Locale.setDefault(Locale.ENGLISH);
>                 JComponent.setDefaultLocale(Locale.ENGLISH);
>                 JComponent.setDefaultLocale(Locale.getDefault());
>                 ColorEditorSpot.access$14(ColorEditorSpot.this, JColorChooser.showDialog(null, "Pick a Color: ", ColorEditorSpot.this.colorButtonAdd.getBackground()));
>                 if (ColorEditorSpot.this.currentColorAdd != null) {
>                     ColorEditorSpot.this.colorButtonAdd.setBackground(ColorEditorSpot.this.currentColorAdd);
>                 }
>             }
>         });
>         this.okButtonEdit.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 final JLabel labelString = new JLabel();
>                 final JLabel labelColor = new JLabel();
>                 labelColor.setText("");
>                 labelColor.setBackground(ColorEditorSpot.this.currentColorEdit);
>                 labelString.setText(ColorEditorSpot.this.addTextFEdit.getText());
>                 labelString.setHorizontalAlignment(0);
>                 labelString.setBackground(ColorEditorSpot.this.currentColorEdit);
>                 labelColor.setOpaque(true);
>                 ColorEditorSpot.access$16(ColorEditorSpot.this, labelString.getText());
>                 ColorEditorSpot.access$17(ColorEditorSpot.this, labelColor.getBackground());
>                 if (!ColorEditorSpot.this.addTextFinal.equals(ColorEditorSpot.this.addTextInitial)) {
>                     ColorEditorSpot.modelC.setValueAt(labelString, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
>                 }
>                 if (ColorEditorSpot.this.addTextFinal.equals(ColorEditorSpot.this.addTextInitial)) {
>                     ColorEditorSpot.modelC.setValueAt(ColorEditorSpot.this.labelC, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
>                 }
>                 if (ColorEditorSpot.this.currentColorEdit != ColorEditorSpot.this.colorCInitial) {
>                     ColorEditorSpot.modelC.setValueAt(labelColor, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
>                 }
>                 if (ColorEditorSpot.this.currentColorEdit == ColorEditorSpot.this.colorCInitial) {
>                     ColorEditorSpot.modelC.setValueAt(ColorEditorSpot.this.colorC, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
>                 }
>                 ColorEditorSpot.modelC.fireTableCellUpdated(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
>                 ColorEditorSpot.modelC.fireTableCellUpdated(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
>                 ColorEditorSpot.tableC.repaint();
>                 ColorEditorSpot.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameEdit, 201));
>             }
>         });
>         this.cancelButtonEdit.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 ColorEditorSpot.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameEdit, 201));
>             }
>         });
>     }
>     
>     public void setClassAction() {
>         this.colorButtonEdit.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 Locale.setDefault(Locale.ENGLISH);
>                 JComponent.setDefaultLocale(Locale.ENGLISH);
>                 JComponent.setDefaultLocale(Locale.getDefault());
>                 ColorEditorSpot.access$11(ColorEditorSpot.this, JColorChooser.showDialog(null, "Pick a Color: ", ColorEditorSpot.this.colorButtonEdit.getBackground()));
>                 if (ColorEditorSpot.this.currentColorEdit != null) {
>                     ColorEditorSpot.this.colorButtonEdit.setBackground(ColorEditorSpot.this.currentColorEdit);
>                 }
>             }
>         });
>         this.okButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 if (ColorEditorSpot.tableC.getSelectedRowCount() <= 0) {
>                     ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
>                 }
>                 if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
>                     final List<String> listClasses = new ArrayList<String>();
>                     ColorEditorSpot.classList = FirstWizardPanel.classList;
>                     ColorEditorSpot.modelListClass = FirstWizardPanel.modelListClass;
>                     final int selectedRow = ColorEditorSpot.tableC.getSelectedRow();
>                     if (ColorEditorSpot.modelListClass.getSize() == 0) {
>                         ColorEditorSpot.modelListClass.addElement(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
>                         final JLabel labelsTableC = new JLabel();
>                         for (int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
>                             labelsTableC.setText(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
>                             labelsTableC.setHorizontalAlignment(0);
>                             labelsTableC.setBackground(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(1))).getBackground());
>                             labelsTableC.setOpaque(true);
432,467c403,410
<                      }
<                   }
<                }
< 
<                if (ColorEditorSpot.modelListClass.getSize() >= 1) {
<                   for(int i = 0; i < ColorEditorSpot.modelListClass.getSize(); ++i) {
<                      listClasses.add((String)ColorEditorSpot.modelListClass.getElementAt(i));
<                   }
< 
<                   if (!listClasses.contains(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText())) {
<                      ColorEditorSpot.modelListClass.addElement(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
<                      labelsTableC = new JLabel();
< 
<                      for(ix = 0; ix < ColorEditorSpot.tableC.getModel().getRowCount(); ++ix) {
<                         labelsTableC.setText(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
<                         labelsTableC.setHorizontalAlignment(0);
<                         labelsTableC.setBackground(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(1))).getBackground());
<                         labelsTableC.setOpaque(true);
<                      }
< 
<                      filterFeature = ((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
<                      features = new ArrayList();
<                      featureMin = new ArrayList();
<                      featureMax = new ArrayList();
< 
<                      for(x = 0; x < filterFeature.length; ++x) {
<                         features.add(filterFeature[x].substring(0, filterFeature[x].indexOf(":")));
<                         featureMin.add(filterFeature[x].substring(filterFeature[x].indexOf("[") + 1, filterFeature[x].indexOf(",")));
<                         featureMax.add(filterFeature[x].substring(filterFeature[x].indexOf(",") + 1, filterFeature[x].indexOf("]")));
<                      }
< 
<                      for(x = 0; x < FirstWizardPanel.modelSpot.getRowCount(); ++x) {
<                         for(u = 0; u < features.size(); ++u) {
<                            if (Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble((String)featureMin.get(u)) && Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble((String)featureMax.get(u))) {
<                               FirstWizardPanel.tableSpot.getModel().setValueAt(labelsTableC, FirstWizardPanel.tableSpot.convertRowIndexToModel(x), FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
<                            }
---
>                         final String[] filterFeature = ((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
>                         final List<String> features = new ArrayList<String>();
>                         final List<String> featureMin = new ArrayList<String>();
>                         final List<String> featureMax = new ArrayList<String>();
>                         for (int j = 0; j < filterFeature.length; ++j) {
>                             features.add(filterFeature[j].substring(0, filterFeature[j].indexOf(":")));
>                             featureMin.add(filterFeature[j].substring(filterFeature[j].indexOf("[") + 1, filterFeature[j].indexOf(",")));
>                             featureMax.add(filterFeature[j].substring(filterFeature[j].indexOf(",") + 1, filterFeature[j].indexOf("]")));
469,553c412,454
<                      }
<                   }
< 
<                   if (listClasses.contains(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText())) {
<                      ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
<                   }
<                }
<             }
< 
<          }
<       });
<       this.cancelButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
<          }
<       });
<       this.deleteButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Object labelC = null;
<             Object colorC = null;
<             Object[] labelsC = null;
<             Object[] colorsC = null;
<             int[] indexesRowC = ColorEditorSpot.tableC.getSelectedRows();
<             int indexRowC = ColorEditorSpot.tableC.getSelectedRow();
<             if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
<                new Object();
<                new Object();
<                labelC = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<                colorC = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<             }
< 
<             labelsC = new Object[indexesRowC.length];
<             colorsC = new Object[indexesRowC.length];
<             if (ColorEditorSpot.tableC.getSelectedRowCount() > 1) {
<                for(int k = 0; k < indexesRowC.length; ++k) {
<                   labelsC[k] = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<                   colorsC[k] = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<                }
<             }
< 
<             Locale.setDefault(Locale.ENGLISH);
<             Locale var10000 = Locale.ENGLISH;
<             JOptionPane.setDefaultLocale(Locale.getDefault());
<             if (ColorEditorSpot.tableC.getSelectedRowCount() > 1) {
<                String[] labelsCtoString = new String[indexesRowC.length];
< 
<                int f;
<                for(f = 0; f < indexesRowC.length; ++f) {
<                   labelsCtoString[f] = ((JLabel)labelsC[f]).getText();
<                }
< 
<                ColorEditorSpot.this.input = JOptionPane.showConfirmDialog((Component)null, "Are you sure to delete the selected labels?", "Delete a label", 1, 0);
<                if (ColorEditorSpot.this.input == 0) {
<                   for(f = 0; f < indexesRowC.length; ++f) {
<                      ColorEditorSpot.modelC.removeRow(indexesRowC[f] - f);
<                   }
< 
<                   ColorEditorSpot.modelC.fireTableDataChanged();
<                   ColorEditorSpot.tableC.repaint();
<                }
< 
<                if (ColorEditorSpot.this.input == 1) {
<                   return;
<                }
< 
<                if (ColorEditorSpot.this.input == 2) {
<                   return;
<                }
<             }
< 
<             if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
<                String labelCtoString = ((JLabel)labelC).getText();
<                ColorEditorSpot.this.input = JOptionPane.showConfirmDialog((Component)null, "Are you sure to delete the following label?----- " + labelCtoString, "Delete a label", 1, 0);
<                if (ColorEditorSpot.this.input == 0) {
<                   ColorEditorSpot.modelC.removeRow(indexRowC);
<                   ColorEditorSpot.modelC.fireTableDataChanged();
<                }
< 
<                if (ColorEditorSpot.this.input == 1) {
<                   return;
<                }
< 
<                if (ColorEditorSpot.this.input == 2) {
<                   return;
<                }
---
>                         for (int x = 0; x < FirstWizardPanel.modelSpot.getRowCount(); ++x) {
>                             for (int u = 0; u < features.size(); ++u) {
>                                 if (Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble(featureMin.get(u)) && Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble(featureMax.get(u))) {
>                                     FirstWizardPanel.tableSpot.getModel().setValueAt(labelsTableC, FirstWizardPanel.tableSpot.convertRowIndexToModel(x), FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
>                                 }
>                             }
>                         }
>                     }
>                     if (ColorEditorSpot.modelListClass.getSize() >= 1) {
>                         for (int k = 0; k < ColorEditorSpot.modelListClass.getSize(); ++k) {
>                             listClasses.add(ColorEditorSpot.modelListClass.getElementAt(k));
>                         }
>                         if (!listClasses.contains(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText())) {
>                             ColorEditorSpot.modelListClass.addElement(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
>                             final JLabel labelsTableC = new JLabel();
>                             for (int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
>                                 labelsTableC.setText(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
>                                 labelsTableC.setHorizontalAlignment(0);
>                                 labelsTableC.setBackground(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(1))).getBackground());
>                                 labelsTableC.setOpaque(true);
>                             }
>                             final String[] filterFeature = ((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
>                             final List<String> features = new ArrayList<String>();
>                             final List<String> featureMin = new ArrayList<String>();
>                             final List<String> featureMax = new ArrayList<String>();
>                             for (int j = 0; j < filterFeature.length; ++j) {
>                                 features.add(filterFeature[j].substring(0, filterFeature[j].indexOf(":")));
>                                 featureMin.add(filterFeature[j].substring(filterFeature[j].indexOf("[") + 1, filterFeature[j].indexOf(",")));
>                                 featureMax.add(filterFeature[j].substring(filterFeature[j].indexOf(",") + 1, filterFeature[j].indexOf("]")));
>                             }
>                             for (int x = 0; x < FirstWizardPanel.modelSpot.getRowCount(); ++x) {
>                                 for (int u = 0; u < features.size(); ++u) {
>                                     if (Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble(featureMin.get(u)) && Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble(featureMax.get(u))) {
>                                         FirstWizardPanel.tableSpot.getModel().setValueAt(labelsTableC, FirstWizardPanel.tableSpot.convertRowIndexToModel(x), FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
>                                     }
>                                 }
>                             }
>                         }
>                         if (listClasses.contains(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText())) {
>                             ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
>                         }
>                     }
>                 }
555,584c456,593
< 
<          }
<       });
<    }
< 
<    public Object getCellEditorValueAdd() {
<       return this.currentColorAdd;
<    }
< 
<    public Object getCellEditorValueEdit() {
<       return this.currentColorEdit;
<    }
< 
<    public Component getTableCellEditorComponentAdd(JTable table, Object value, boolean isSelected, int row, int column) {
<       this.currentColorAdd = (Color)value;
<       return this.colorButtonAdd;
<    }
< 
<    public Component getTableCellEditorComponentEdit(JTable table, Object value, boolean isSelected, int row, int column) {
<       this.currentColorEdit = (Color)value;
<       return this.colorButtonEdit;
<    }
< 
<    public Component getTableCellEditorComponent(JTable arg0, Object arg1, boolean arg2, int arg3, int arg4) {
<       return null;
<    }
< 
<    public Object getCellEditorValue() {
<       return null;
<    }
---
>         });
>         this.cancelButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
>             }
>         });
>         this.deleteButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 Object labelC = null;
>                 Object colorC = null;
>                 Object[] labelsC = null;
>                 Object[] colorsC = null;
>                 final int[] indexesRowC = ColorEditorSpot.tableC.getSelectedRows();
>                 final int indexRowC = ColorEditorSpot.tableC.getSelectedRow();
>                 if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
>                     labelC = new Object();
>                     colorC = new Object();
>                     labelC = ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
>                     colorC = ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
>                 }
>                 labelsC = new Object[indexesRowC.length];
>                 colorsC = new Object[indexesRowC.length];
>                 if (ColorEditorSpot.tableC.getSelectedRowCount() > 1) {
>                     for (int k = 0; k < indexesRowC.length; ++k) {
>                         labelsC[k] = ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
>                         colorsC[k] = ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
>                     }
>                 }
>                 Locale.setDefault(Locale.ENGLISH);
>                 final Locale english = Locale.ENGLISH;
>                 JComponent.setDefaultLocale(Locale.getDefault());
>                 if (ColorEditorSpot.tableC.getSelectedRowCount() > 1) {
>                     final String[] labelsCtoString = new String[indexesRowC.length];
>                     for (int i = 0; i < indexesRowC.length; ++i) {
>                         labelsCtoString[i] = ((JLabel)labelsC[i]).getText();
>                     }
>                     ColorEditorSpot.access$21(ColorEditorSpot.this, JOptionPane.showConfirmDialog(null, "Are you sure to delete the selected labels?", "Delete a label", 1, 0));
>                     if (ColorEditorSpot.this.input == 0) {
>                         for (int f = 0; f < indexesRowC.length; ++f) {
>                             ColorEditorSpot.modelC.removeRow(indexesRowC[f] - f);
>                         }
>                         ColorEditorSpot.modelC.fireTableDataChanged();
>                         ColorEditorSpot.tableC.repaint();
>                     }
>                     if (ColorEditorSpot.this.input == 1) {
>                         return;
>                     }
>                     if (ColorEditorSpot.this.input == 2) {
>                         return;
>                     }
>                 }
>                 if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
>                     final String labelCtoString = ((JLabel)labelC).getText();
>                     ColorEditorSpot.access$21(ColorEditorSpot.this, JOptionPane.showConfirmDialog(null, "Are you sure to delete the following label?----- " + labelCtoString, "Delete a label", 1, 0));
>                     if (ColorEditorSpot.this.input == 0) {
>                         ColorEditorSpot.modelC.removeRow(indexRowC);
>                         ColorEditorSpot.modelC.fireTableDataChanged();
>                     }
>                     if (ColorEditorSpot.this.input == 1) {
>                         return;
>                     }
>                     if (ColorEditorSpot.this.input == 2) {
>                         return;
>                     }
>                 }
>             }
>         });
>     }
>     
>     public Object getCellEditorValueAdd() {
>         return this.currentColorAdd;
>     }
>     
>     public Object getCellEditorValueEdit() {
>         return this.currentColorEdit;
>     }
>     
>     public Component getTableCellEditorComponentAdd(final JTable table, final Object value, final boolean isSelected, final int row, final int column) {
>         this.currentColorAdd = (Color)value;
>         return this.colorButtonAdd;
>     }
>     
>     public Component getTableCellEditorComponentEdit(final JTable table, final Object value, final boolean isSelected, final int row, final int column) {
>         this.currentColorEdit = (Color)value;
>         return this.colorButtonEdit;
>     }
>     
>     @Override
>     public Component getTableCellEditorComponent(final JTable arg0, final Object arg1, final boolean arg2, final int arg3, final int arg4) {
>         return null;
>     }
>     
>     @Override
>     public Object getCellEditorValue() {
>         return null;
>     }
>     
>     static /* synthetic */ void access$2(final ColorEditorSpot colorEditorSpot, final int indexRowC) {
>         colorEditorSpot.indexRowC = indexRowC;
>     }
>     
>     static /* synthetic */ void access$3(final ColorEditorSpot colorEditorSpot, final Object labelC) {
>         colorEditorSpot.labelC = labelC;
>     }
>     
>     static /* synthetic */ void access$4(final ColorEditorSpot colorEditorSpot, final Object colorC) {
>         colorEditorSpot.colorC = colorC;
>     }
>     
>     static /* synthetic */ void access$7(final ColorEditorSpot colorEditorSpot, final String addTextInitial) {
>         colorEditorSpot.addTextInitial = addTextInitial;
>     }
>     
>     static /* synthetic */ void access$9(final ColorEditorSpot colorEditorSpot, final Color colorCInitial) {
>         colorEditorSpot.colorCInitial = colorCInitial;
>     }
>     
>     static /* synthetic */ void access$11(final ColorEditorSpot colorEditorSpot, final Color currentColorEdit) {
>         colorEditorSpot.currentColorEdit = currentColorEdit;
>     }
>     
>     static /* synthetic */ void access$14(final ColorEditorSpot colorEditorSpot, final Color currentColorAdd) {
>         colorEditorSpot.currentColorAdd = currentColorAdd;
>     }
>     
>     static /* synthetic */ void access$16(final ColorEditorSpot colorEditorSpot, final String addTextFinal) {
>         colorEditorSpot.addTextFinal = addTextFinal;
>     }
>     
>     static /* synthetic */ void access$17(final ColorEditorSpot colorEditorSpot, final Color colorCFinal) {
>         colorEditorSpot.colorCFinal = colorCFinal;
>     }
>     
>     static /* synthetic */ void access$21(final ColorEditorSpot colorEditorSpot, final int input) {
>         colorEditorSpot.input = input;
>     }
diff -r TrackAnalyzer_/ColorEditorTrack.java procyon/ColorEditorTrack.java
1,9c1
< import java.awt.Color;
< import java.awt.Component;
< import java.awt.Dimension;
< import java.awt.FlowLayout;
< import java.awt.Point;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.WindowEvent;
< import java.util.ArrayList;
---
> import javax.swing.JOptionPane;
10a3,6
> import java.util.ArrayList;
> import javax.swing.table.TableColumn;
> import javax.swing.JColorChooser;
> import javax.swing.JComponent;
12c8,13
< import javax.swing.AbstractCellEditor;
---
> import java.awt.AWTEvent;
> import java.awt.Window;
> import java.awt.event.WindowEvent;
> import java.awt.event.ActionEvent;
> import java.awt.event.ActionListener;
> import java.awt.Dimension;
13a15,24
> import javax.swing.JScrollPane;
> import java.awt.Component;
> import java.awt.FlowLayout;
> import javax.swing.RowSorter;
> import javax.swing.table.DefaultTableCellRenderer;
> import javax.swing.table.TableModel;
> import javax.swing.table.TableRowSorter;
> import javax.swing.table.TableCellRenderer;
> import java.awt.LayoutManager;
> import java.awt.Container;
15,16c26
< import javax.swing.DefaultListModel;
< import javax.swing.Icon;
---
> import java.awt.Point;
18,19c28
< import javax.swing.JButton;
< import javax.swing.JColorChooser;
---
> import javax.swing.Icon;
21c30,32
< import javax.swing.JLabel;
---
> import java.awt.Color;
> import javax.swing.JTextField;
> import javax.swing.DefaultListModel;
23,25c34
< import javax.swing.JOptionPane;
< import javax.swing.JPanel;
< import javax.swing.JScrollPane;
---
> import javax.swing.JButton;
27,28d35
< import javax.swing.JTextField;
< import javax.swing.table.DefaultTableCellRenderer;
29a37,38
> import javax.swing.JLabel;
> import javax.swing.JPanel;
31,425c40
< import javax.swing.table.TableColumn;
< import javax.swing.table.TableModel;
< import javax.swing.table.TableRowSorter;
< 
< public class ColorEditorTrack extends AbstractCellEditor implements TableCellEditor {
<    private JPanel myPanel;
<    private JPanel panelAdd;
<    private JPanel panelEdit;
<    private JLabel labelInitt;
<    private int result;
<    private int input;
<    static DefaultTableModel modelC;
<    static JTable tableC;
<    private JButton addButton;
<    private JButton editButton;
<    private JButton deleteButton;
<    private JButton colorButtonAdd;
<    private JButton colorButtonEdit;
<    private JButton okButton;
<    private JButton okButtonEdit;
<    private JButton cancelButton;
<    private JButton cancelButtonEdit;
<    private JButton okButtonAdd;
<    private JButton cancelButtonAdd;
<    static JList<String> featureList;
<    static JList<String> classList;
<    static DefaultListModel<String> modelListFeature;
<    static DefaultListModel<String> modelListClass;
<    private JLabel addTextAdd;
<    private JLabel addTextEdit;
<    private JTextField addTextFAdd;
<    private JTextField addTextFEdit;
<    private Color currentColorAdd;
<    private Color currentColorEdit;
<    private Color colorCInitial;
<    private Color colorCFinal;
<    private Object labelC;
<    private Object colorC;
<    private Object featureC;
<    private String addTextInitial;
<    private String addTextFinal;
<    private String featureInitial;
<    private String featureFinal;
<    static JFrame myFrame;
<    static JFrame myFrameAdd;
<    static JFrame myFrameEdit;
<    private Icon iconOKCell;
<    private Icon iconCancelCell;
<    private int indexRowC;
< 
<    public ColorEditorTrack(final JList<String> featureList) {
<       ColorEditorTrack.featureList = featureList;
<       this.addButton = new JButton("");
<       this.addButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
<       Icon iconAddCell = new ImageIcon(iconAdd.getImage().getScaledInstance(17, 15, 4));
<       this.addButton.setIcon(iconAddCell);
<       this.addButton.setToolTipText("Click this button to add your class-label.");
<       this.editButton = new JButton("");
<       this.editButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconEdit = FirstWizardPanel.createImageIcon("images/edit.png");
<       Icon iconEditCell = new ImageIcon(iconEdit.getImage().getScaledInstance(17, 15, 4));
<       this.editButton.setIcon(iconEditCell);
<       this.editButton.setToolTipText("Click this button to edit your class-label.");
<       this.deleteButton = new JButton("");
<       this.deleteButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconDelete = FirstWizardPanel.createImageIcon("images/bin.png");
<       Icon iconDeleteCell = new ImageIcon(iconDelete.getImage().getScaledInstance(22, 20, 4));
<       this.deleteButton.setIcon(iconDeleteCell);
<       this.deleteButton.setToolTipText("Click this button to delete your class-label.");
<       myFrame = new JFrame("Manage Labels");
<       myFrame.setLocation(new Point(100, 100));
<       myFrame.setDefaultCloseOperation(2);
<       this.myPanel = new JPanel();
<       this.myPanel.setLayout(new BoxLayout(this.myPanel, 1));
<       Object[][] rowData2 = new Object[0][];
<       Object[] columnNames = new Object[]{"Name", "Color", "Feature"};
<       modelC = new DefaultTableModel(rowData2, columnNames) {
<          private static final long serialVersionUID = 1L;
< 
<          public boolean isCellEditable(int row, int col) {
<             return false;
<          }
< 
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
<             }
< 
<             return super.getColumnClass(column);
<          }
<       };
<       tableC = new JTable();
<       tableC.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
<       tableC.setSelectionBackground(new Color(229, 255, 204));
<       tableC.setSelectionForeground(new Color(0, 102, 0));
<       TableRowSorter<TableModel> rowSorter = new TableRowSorter(modelC);
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableC.setDefaultRenderer(JLabel.class, centerRenderer);
<       tableC.setRowSorter(rowSorter);
<       JPanel panelButtons = new JPanel();
<       panelButtons.setLayout(new FlowLayout());
<       panelButtons.add(this.addButton);
<       panelButtons.add(this.editButton);
<       panelButtons.add(this.deleteButton);
<       tableC.setAutoCreateRowSorter(true);
<       tableC.setEnabled(true);
<       tableC.setCellSelectionEnabled(true);
<       tableC.setRowSelectionAllowed(true);
<       tableC.setColumnSelectionAllowed(false);
<       tableC.setSelectionMode(2);
<       tableC.setDefaultRenderer(JLabel.class, new Renderer());
<       tableC.setDefaultRenderer(Color.class, new ColorRenderer(true));
<       tableC.setModel(modelC);
<       TableColumn column1 = null;
<       column1 = tableC.getColumnModel().getColumn(0);
<       column1.setPreferredWidth(7);
<       column1.setCellRenderer(new ResultRendererC());
<       TableColumn column2 = null;
<       column2 = tableC.getColumnModel().getColumn(1);
<       column2.setPreferredWidth(5);
<       column2.setCellRenderer(new ResultRendererC());
<       TableColumn column3 = null;
<       column3 = tableC.getColumnModel().getColumn(2);
<       column3.setPreferredWidth(15);
<       column3.setCellRenderer(new ResultRendererC());
<       JScrollPane scrollPane = new JScrollPane(tableC);
< 
<       for(int u = 0; u < tableC.getColumnCount(); ++u) {
<          tableC.getColumnModel().getColumn(u).setPreferredWidth(90);
<       }
< 
<       tableC.setRowHeight(25);
<       this.myPanel.add(Box.createHorizontalStrut(15));
<       this.myPanel.add(panelButtons);
<       this.myPanel.add(scrollPane, "Center");
<       this.myPanel.setSize(300, 150);
<       this.myPanel.add(Box.createHorizontalStrut(15));
<       this.okButton = new JButton("");
<       this.okButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconOk = FirstWizardPanel.createImageIcon("images/add.png");
<       this.iconOKCell = new ImageIcon(iconOk.getImage().getScaledInstance(17, 15, 4));
<       this.okButton.setIcon(this.iconOKCell);
<       this.okButton.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButton = new JButton("");
<       this.cancelButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconCancel = FirstWizardPanel.createImageIcon("images/cancel.png");
<       this.iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(17, 15, 4));
<       this.cancelButton.setIcon(this.iconCancelCell);
<       this.cancelButton.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancel = new JPanel();
<       panelOkCancel.setLayout(new FlowLayout());
<       panelOkCancel.add(this.okButton);
<       panelOkCancel.add(this.cancelButton);
<       this.myPanel.add(panelOkCancel);
<       myFrame.getContentPane().add(this.myPanel);
<       myFrame.pack();
<       myFrame.setLocationByPlatform(true);
<       this.panelAdd = new JPanel();
<       this.panelAdd.setPreferredSize(new Dimension(200, 100));
<       JPanel panel1 = new JPanel();
<       panel1.setLayout(new FlowLayout());
<       this.panelAdd.setLayout(new FlowLayout());
<       this.addTextAdd = new JLabel("Label Name: ");
<       this.addTextFAdd = new JTextField(8);
<       panel1.add(this.addTextAdd);
<       panel1.add(this.addTextFAdd);
<       JLabel pickC = new JLabel("Pick a color: ");
<       this.panelAdd.add(pickC);
<       this.colorButtonAdd = new JButton();
<       this.colorButtonAdd.setPreferredSize(new Dimension(200, 75));
<       this.panelAdd.add(this.colorButtonAdd);
<       this.okButtonAdd = new JButton("");
<       this.okButtonAdd.setBounds(50, 100, 95, 30);
<       this.okButtonAdd.setIcon(this.iconOKCell);
<       this.okButtonAdd.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButtonAdd = new JButton("");
<       this.cancelButtonAdd.setBounds(50, 100, 95, 30);
<       this.cancelButtonAdd.setIcon(this.iconCancelCell);
<       this.cancelButtonAdd.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancelAdd = new JPanel();
<       panelOkCancelAdd.setLayout(new FlowLayout());
<       panelOkCancelAdd.add(this.okButtonAdd);
<       panelOkCancelAdd.add(this.cancelButtonAdd);
<       myFrameAdd = new JFrame("Add Label");
<       JPanel mainPanel = new JPanel();
<       mainPanel.add(panel1);
<       mainPanel.add(this.panelAdd);
<       mainPanel.add(panelOkCancelAdd);
<       myFrameAdd.setPreferredSize(new Dimension(250, 250));
<       myFrameAdd.getContentPane().add(mainPanel);
<       myFrameAdd.pack();
<       myFrameAdd.setLocationByPlatform(true);
<       JPanel panel = new JPanel();
<       panel.setPreferredSize(new Dimension(200, 100));
<       JPanel panel2 = new JPanel();
<       panel2.setLayout(new FlowLayout());
<       panel.setLayout(new FlowLayout());
<       this.addTextEdit = new JLabel("Label Name: ");
<       this.addTextFEdit = new JTextField(8);
<       panel2.add(this.addTextEdit);
<       panel2.add(this.addTextFEdit);
<       JLabel pickEdit = new JLabel("Pick a Color: ");
<       panel.add(pickEdit);
<       this.colorButtonEdit = new JButton();
<       this.colorButtonEdit.setPreferredSize(new Dimension(200, 75));
<       panel.add(this.colorButtonEdit);
<       this.okButtonEdit = new JButton("");
<       this.okButtonEdit.setBounds(50, 100, 95, 30);
<       this.okButtonEdit.setIcon(this.iconOKCell);
<       this.okButtonEdit.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButtonEdit = new JButton("");
<       this.cancelButtonEdit.setBounds(50, 100, 95, 30);
<       this.cancelButtonEdit.setIcon(this.iconCancelCell);
<       this.cancelButtonEdit.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancelEdit = new JPanel();
<       panelOkCancelEdit.setLayout(new FlowLayout());
<       panelOkCancelEdit.add(this.okButtonEdit);
<       panelOkCancelEdit.add(this.cancelButtonEdit);
<       myFrameEdit = new JFrame("Edit Label");
<       JPanel mainPanelEdit = new JPanel();
<       mainPanelEdit.add(panel2);
<       mainPanelEdit.add(panel);
<       mainPanelEdit.add(panelOkCancelEdit);
<       myFrameEdit.setPreferredSize(new Dimension(250, 250));
<       myFrameEdit.getContentPane().add(mainPanelEdit);
<       myFrameEdit.pack();
<       myFrameEdit.setLocationByPlatform(true);
<       this.addButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorTrack.tableC.setRowHeight(featureList.getHeight());
<             ColorEditorTrack.myFrameAdd.setVisible(true);
<          }
<       });
<       this.okButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             JLabel labelString = new JLabel();
<             JLabel labelColor = new JLabel();
<             JLabel labelFeature = new JLabel();
<             labelColor.setText("");
<             labelColor.setBackground(ColorEditorTrack.this.currentColorAdd);
<             labelString.setText(ColorEditorTrack.this.addTextFAdd.getText());
<             labelString.setHorizontalAlignment(0);
<             labelString.setBackground(ColorEditorTrack.this.currentColorAdd);
<             labelColor.setOpaque(true);
<             StringBuilder filterItems = new StringBuilder();
< 
<             for(int x = 0; x < featureList.getModel().getSize(); ++x) {
<                filterItems.append((String)featureList.getModel().getElementAt(x)).append("<br>");
<             }
< 
<             labelFeature.setText("<html>" + filterItems.toString() + "</html>");
<             ColorEditorTrack.modelC.addRow(new Object[]{labelString, labelColor, labelFeature});
<             ColorEditorTrack.modelC.fireTableDataChanged();
<             ColorEditorTrack.tableC.repaint();
<             ColorEditorTrack.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameAdd, 201));
<          }
<       });
<       this.cancelButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorTrack.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameAdd, 201));
<          }
<       });
<       this.editButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorTrack.myFrameEdit.setVisible(true);
<             ColorEditorTrack.this.indexRowC = ColorEditorTrack.tableC.getSelectedRow();
<             if (ColorEditorTrack.tableC.getSelectedRowCount() != 0) {
<                if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
<                   ColorEditorTrack.this.labelC = new Object();
<                   ColorEditorTrack.this.colorC = new Object();
<                   ColorEditorTrack.this.labelC = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<                   ColorEditorTrack.this.colorC = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<                   ColorEditorTrack.this.addTextInitial = ((JLabel)ColorEditorTrack.this.labelC).getText();
<                   ColorEditorTrack.this.colorCInitial = ((JLabel)ColorEditorTrack.this.colorC).getBackground();
<                }
< 
<                ColorEditorTrack.this.colorButtonEdit.setBackground(((JLabel)ColorEditorTrack.this.colorC).getBackground());
<                ColorEditorTrack.this.currentColorEdit = ((JLabel)ColorEditorTrack.this.colorC).getBackground();
<                ColorEditorTrack.this.colorButtonEdit.setContentAreaFilled(false);
<                ColorEditorTrack.this.colorButtonEdit.setOpaque(true);
<                ColorEditorTrack.this.addTextFEdit.setText(((JLabel)ColorEditorTrack.this.labelC).getText());
<             }
<          }
<       });
<       this.colorButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Locale.setDefault(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.getDefault());
<             ColorEditorTrack.this.currentColorAdd = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorTrack.this.colorButtonAdd.getBackground());
<             if (ColorEditorTrack.this.currentColorAdd != null) {
<                ColorEditorTrack.this.colorButtonAdd.setBackground(ColorEditorTrack.this.currentColorAdd);
<             }
< 
<          }
<       });
<       this.okButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             JLabel labelString = new JLabel();
<             JLabel labelColor = new JLabel();
<             labelColor.setText("");
<             labelColor.setBackground(ColorEditorTrack.this.currentColorEdit);
<             labelString.setText(ColorEditorTrack.this.addTextFEdit.getText());
<             labelString.setHorizontalAlignment(0);
<             labelString.setBackground(ColorEditorTrack.this.currentColorEdit);
<             labelColor.setOpaque(true);
<             ColorEditorTrack.this.addTextFinal = labelString.getText();
<             ColorEditorTrack.this.colorCFinal = labelColor.getBackground();
<             if (!ColorEditorTrack.this.addTextFinal.equals(ColorEditorTrack.this.addTextInitial)) {
<                ColorEditorTrack.modelC.setValueAt(labelString, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<             }
< 
<             if (ColorEditorTrack.this.addTextFinal.equals(ColorEditorTrack.this.addTextInitial)) {
<                ColorEditorTrack.modelC.setValueAt(ColorEditorTrack.this.labelC, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<             }
< 
<             if (ColorEditorTrack.this.currentColorEdit != ColorEditorTrack.this.colorCInitial) {
<                ColorEditorTrack.modelC.setValueAt(labelColor, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<             }
< 
<             if (ColorEditorTrack.this.currentColorEdit == ColorEditorTrack.this.colorCInitial) {
<                ColorEditorTrack.modelC.setValueAt(ColorEditorTrack.this.colorC, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<             }
< 
<             ColorEditorTrack.modelC.fireTableCellUpdated(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<             ColorEditorTrack.modelC.fireTableCellUpdated(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<             ColorEditorTrack.tableC.repaint();
<             ColorEditorTrack.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameEdit, 201));
<          }
<       });
<       this.cancelButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorTrack.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameEdit, 201));
<          }
<       });
<    }
< 
<    public void setClassAction() {
<       this.colorButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Locale.setDefault(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.getDefault());
<             ColorEditorTrack.this.currentColorEdit = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorTrack.this.colorButtonEdit.getBackground());
<             if (ColorEditorTrack.this.currentColorEdit != null) {
<                ColorEditorTrack.this.colorButtonEdit.setBackground(ColorEditorTrack.this.currentColorEdit);
<             }
< 
<          }
<       });
<       this.okButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             if (ColorEditorTrack.tableC.getSelectedRowCount() <= 0) {
<                ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
<             }
< 
<             if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
<                List<String> listClasses = new ArrayList();
<                ColorEditorTrack.classList = ChooserWizardPanel.classList;
<                ColorEditorTrack.modelListClass = ChooserWizardPanel.modelListClass;
<                int selectedRow = ColorEditorTrack.tableC.getSelectedRow();
<                JLabel labelsTableC;
<                int ix;
<                ArrayList features;
<                ArrayList featureMin;
<                ArrayList featureMax;
<                int x;
<                int u;
<                String[] filterFeature;
<                if (ColorEditorTrack.modelListClass.getSize() == 0) {
<                   ColorEditorTrack.modelListClass.addElement(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
<                   labelsTableC = new JLabel();
< 
<                   for(ix = 0; ix < ColorEditorTrack.tableC.getModel().getRowCount(); ++ix) {
<                      labelsTableC.setText(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
<                      labelsTableC.setHorizontalAlignment(0);
<                      labelsTableC.setBackground(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(1))).getBackground());
<                      labelsTableC.setOpaque(true);
<                   }
< 
<                   filterFeature = ((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
<                   features = new ArrayList();
<                   featureMin = new ArrayList();
<                   featureMax = new ArrayList();
< 
<                   for(x = 0; x < filterFeature.length; ++x) {
<                      features.add(filterFeature[x].substring(0, filterFeature[x].indexOf(":")));
<                      featureMin.add(filterFeature[x].substring(filterFeature[x].indexOf("[") + 1, filterFeature[x].indexOf(",")));
<                      featureMax.add(filterFeature[x].substring(filterFeature[x].indexOf(",") + 1, filterFeature[x].indexOf("]")));
<                   }
---
> import javax.swing.AbstractCellEditor;
427,430c42,401
<                   for(x = 0; x < ChooserWizardPanel.modelTrack.getRowCount(); ++x) {
<                      for(u = 0; u < features.size(); ++u) {
<                         if (Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble((String)featureMin.get(u)) && Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble((String)featureMax.get(u))) {
<                            ChooserWizardPanel.tableTrack.getModel().setValueAt(labelsTableC, ChooserWizardPanel.tableTrack.convertRowIndexToModel(x), ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class ColorEditorTrack extends AbstractCellEditor implements TableCellEditor
> {
>     private JPanel myPanel;
>     private JPanel panelAdd;
>     private JPanel panelEdit;
>     private JLabel labelInitt;
>     private int result;
>     private int input;
>     static DefaultTableModel modelC;
>     static JTable tableC;
>     private JButton addButton;
>     private JButton editButton;
>     private JButton deleteButton;
>     private JButton colorButtonAdd;
>     private JButton colorButtonEdit;
>     private JButton okButton;
>     private JButton okButtonEdit;
>     private JButton cancelButton;
>     private JButton cancelButtonEdit;
>     private JButton okButtonAdd;
>     private JButton cancelButtonAdd;
>     static JList<String> featureList;
>     static JList<String> classList;
>     static DefaultListModel<String> modelListFeature;
>     static DefaultListModel<String> modelListClass;
>     private JLabel addTextAdd;
>     private JLabel addTextEdit;
>     private JTextField addTextFAdd;
>     private JTextField addTextFEdit;
>     private Color currentColorAdd;
>     private Color currentColorEdit;
>     private Color colorCInitial;
>     private Color colorCFinal;
>     private Object labelC;
>     private Object colorC;
>     private Object featureC;
>     private String addTextInitial;
>     private String addTextFinal;
>     private String featureInitial;
>     private String featureFinal;
>     static JFrame myFrame;
>     static JFrame myFrameAdd;
>     static JFrame myFrameEdit;
>     private Icon iconOKCell;
>     private Icon iconCancelCell;
>     private int indexRowC;
>     
>     public ColorEditorTrack(final JList<String> featureList) {
>         ColorEditorTrack.featureList = featureList;
>         (this.addButton = new JButton("")).setBounds(50, 100, 95, 30);
>         final ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
>         final Icon iconAddCell = new ImageIcon(iconAdd.getImage().getScaledInstance(17, 15, 4));
>         this.addButton.setIcon(iconAddCell);
>         this.addButton.setToolTipText("Click this button to add your class-label.");
>         (this.editButton = new JButton("")).setBounds(50, 100, 95, 30);
>         final ImageIcon iconEdit = FirstWizardPanel.createImageIcon("images/edit.png");
>         final Icon iconEditCell = new ImageIcon(iconEdit.getImage().getScaledInstance(17, 15, 4));
>         this.editButton.setIcon(iconEditCell);
>         this.editButton.setToolTipText("Click this button to edit your class-label.");
>         (this.deleteButton = new JButton("")).setBounds(50, 100, 95, 30);
>         final ImageIcon iconDelete = FirstWizardPanel.createImageIcon("images/bin.png");
>         final Icon iconDeleteCell = new ImageIcon(iconDelete.getImage().getScaledInstance(22, 20, 4));
>         this.deleteButton.setIcon(iconDeleteCell);
>         this.deleteButton.setToolTipText("Click this button to delete your class-label.");
>         (ColorEditorTrack.myFrame = new JFrame("Manage Labels")).setLocation(new Point(100, 100));
>         ColorEditorTrack.myFrame.setDefaultCloseOperation(2);
>         (this.myPanel = new JPanel()).setLayout(new BoxLayout(this.myPanel, 1));
>         final Object[][] rowData2 = new Object[0][];
>         final Object[] columnNames = { "Name", "Color", "Feature" };
>         ColorEditorTrack.modelC = new DefaultTableModel(rowData2, columnNames) {
>             private static final long serialVersionUID = 1L;
>             
>             @Override
>             public boolean isCellEditable(final int row, final int col) {
>                 return false;
>             }
>             
>             @Override
>             public Class<?> getColumnClass(final int column) {
>                 if (this.getRowCount() > 0) {
>                     final Object value = this.getValueAt(0, column);
>                     if (value != null) {
>                         return this.getValueAt(0, column).getClass();
>                     }
>                 }
>                 return super.getColumnClass(column);
>             }
>         };
>         ColorEditorTrack.tableC = new JTable();
>         ColorEditorTrack.tableC.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
>         ColorEditorTrack.tableC.setSelectionBackground(new Color(229, 255, 204));
>         ColorEditorTrack.tableC.setSelectionForeground(new Color(0, 102, 0));
>         final TableRowSorter<TableModel> rowSorter = new TableRowSorter<TableModel>(ColorEditorTrack.modelC);
>         final DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
>         centerRenderer.setHorizontalAlignment(0);
>         ColorEditorTrack.tableC.setDefaultRenderer(JLabel.class, centerRenderer);
>         ColorEditorTrack.tableC.setRowSorter((RowSorter<? extends TableModel>)rowSorter);
>         final JPanel panelButtons = new JPanel();
>         panelButtons.setLayout(new FlowLayout());
>         panelButtons.add(this.addButton);
>         panelButtons.add(this.editButton);
>         panelButtons.add(this.deleteButton);
>         ColorEditorTrack.tableC.setAutoCreateRowSorter(true);
>         ColorEditorTrack.tableC.setEnabled(true);
>         ColorEditorTrack.tableC.setCellSelectionEnabled(true);
>         ColorEditorTrack.tableC.setRowSelectionAllowed(true);
>         ColorEditorTrack.tableC.setColumnSelectionAllowed(false);
>         ColorEditorTrack.tableC.setSelectionMode(2);
>         ColorEditorTrack.tableC.setDefaultRenderer(JLabel.class, new Renderer());
>         ColorEditorTrack.tableC.setDefaultRenderer(Color.class, new ColorRenderer(true));
>         ColorEditorTrack.tableC.setModel(ColorEditorTrack.modelC);
>         TableColumn column1 = null;
>         column1 = ColorEditorTrack.tableC.getColumnModel().getColumn(0);
>         column1.setPreferredWidth(7);
>         column1.setCellRenderer((TableCellRenderer)new ResultRendererC());
>         TableColumn column2 = null;
>         column2 = ColorEditorTrack.tableC.getColumnModel().getColumn(1);
>         column2.setPreferredWidth(5);
>         column2.setCellRenderer((TableCellRenderer)new ResultRendererC());
>         TableColumn column3 = null;
>         column3 = ColorEditorTrack.tableC.getColumnModel().getColumn(2);
>         column3.setPreferredWidth(15);
>         column3.setCellRenderer((TableCellRenderer)new ResultRendererC());
>         final JScrollPane scrollPane = new JScrollPane(ColorEditorTrack.tableC);
>         for (int u = 0; u < ColorEditorTrack.tableC.getColumnCount(); ++u) {
>             ColorEditorTrack.tableC.getColumnModel().getColumn(u).setPreferredWidth(90);
>         }
>         ColorEditorTrack.tableC.setRowHeight(25);
>         this.myPanel.add(Box.createHorizontalStrut(15));
>         this.myPanel.add(panelButtons);
>         this.myPanel.add(scrollPane, "Center");
>         this.myPanel.setSize(300, 150);
>         this.myPanel.add(Box.createHorizontalStrut(15));
>         (this.okButton = new JButton("")).setBounds(50, 100, 95, 30);
>         final ImageIcon iconOk = FirstWizardPanel.createImageIcon("images/add.png");
>         this.iconOKCell = new ImageIcon(iconOk.getImage().getScaledInstance(17, 15, 4));
>         this.okButton.setIcon(this.iconOKCell);
>         this.okButton.setToolTipText("Click this button to edit your color selection.");
>         (this.cancelButton = new JButton("")).setBounds(50, 100, 95, 30);
>         final ImageIcon iconCancel = FirstWizardPanel.createImageIcon("images/cancel.png");
>         this.iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(17, 15, 4));
>         this.cancelButton.setIcon(this.iconCancelCell);
>         this.cancelButton.setToolTipText("Click this button to cancel your color selection.");
>         final JPanel panelOkCancel = new JPanel();
>         panelOkCancel.setLayout(new FlowLayout());
>         panelOkCancel.add(this.okButton);
>         panelOkCancel.add(this.cancelButton);
>         this.myPanel.add(panelOkCancel);
>         ColorEditorTrack.myFrame.getContentPane().add(this.myPanel);
>         ColorEditorTrack.myFrame.pack();
>         ColorEditorTrack.myFrame.setLocationByPlatform(true);
>         (this.panelAdd = new JPanel()).setPreferredSize(new Dimension(200, 100));
>         final JPanel panel1 = new JPanel();
>         panel1.setLayout(new FlowLayout());
>         this.panelAdd.setLayout(new FlowLayout());
>         this.addTextAdd = new JLabel("Label Name: ");
>         this.addTextFAdd = new JTextField(8);
>         panel1.add(this.addTextAdd);
>         panel1.add(this.addTextFAdd);
>         final JLabel pickC = new JLabel("Pick a color: ");
>         this.panelAdd.add(pickC);
>         (this.colorButtonAdd = new JButton()).setPreferredSize(new Dimension(200, 75));
>         this.panelAdd.add(this.colorButtonAdd);
>         (this.okButtonAdd = new JButton("")).setBounds(50, 100, 95, 30);
>         this.okButtonAdd.setIcon(this.iconOKCell);
>         this.okButtonAdd.setToolTipText("Click this button to edit your color selection.");
>         (this.cancelButtonAdd = new JButton("")).setBounds(50, 100, 95, 30);
>         this.cancelButtonAdd.setIcon(this.iconCancelCell);
>         this.cancelButtonAdd.setToolTipText("Click this button to cancel your color selection.");
>         final JPanel panelOkCancelAdd = new JPanel();
>         panelOkCancelAdd.setLayout(new FlowLayout());
>         panelOkCancelAdd.add(this.okButtonAdd);
>         panelOkCancelAdd.add(this.cancelButtonAdd);
>         ColorEditorTrack.myFrameAdd = new JFrame("Add Label");
>         final JPanel mainPanel = new JPanel();
>         mainPanel.add(panel1);
>         mainPanel.add(this.panelAdd);
>         mainPanel.add(panelOkCancelAdd);
>         ColorEditorTrack.myFrameAdd.setPreferredSize(new Dimension(250, 250));
>         ColorEditorTrack.myFrameAdd.getContentPane().add(mainPanel);
>         ColorEditorTrack.myFrameAdd.pack();
>         ColorEditorTrack.myFrameAdd.setLocationByPlatform(true);
>         final JPanel panel2 = new JPanel();
>         panel2.setPreferredSize(new Dimension(200, 100));
>         final JPanel panel3 = new JPanel();
>         panel3.setLayout(new FlowLayout());
>         panel2.setLayout(new FlowLayout());
>         this.addTextEdit = new JLabel("Label Name: ");
>         this.addTextFEdit = new JTextField(8);
>         panel3.add(this.addTextEdit);
>         panel3.add(this.addTextFEdit);
>         final JLabel pickEdit = new JLabel("Pick a Color: ");
>         panel2.add(pickEdit);
>         (this.colorButtonEdit = new JButton()).setPreferredSize(new Dimension(200, 75));
>         panel2.add(this.colorButtonEdit);
>         (this.okButtonEdit = new JButton("")).setBounds(50, 100, 95, 30);
>         this.okButtonEdit.setIcon(this.iconOKCell);
>         this.okButtonEdit.setToolTipText("Click this button to edit your color selection.");
>         (this.cancelButtonEdit = new JButton("")).setBounds(50, 100, 95, 30);
>         this.cancelButtonEdit.setIcon(this.iconCancelCell);
>         this.cancelButtonEdit.setToolTipText("Click this button to cancel your color selection.");
>         final JPanel panelOkCancelEdit = new JPanel();
>         panelOkCancelEdit.setLayout(new FlowLayout());
>         panelOkCancelEdit.add(this.okButtonEdit);
>         panelOkCancelEdit.add(this.cancelButtonEdit);
>         ColorEditorTrack.myFrameEdit = new JFrame("Edit Label");
>         final JPanel mainPanelEdit = new JPanel();
>         mainPanelEdit.add(panel3);
>         mainPanelEdit.add(panel2);
>         mainPanelEdit.add(panelOkCancelEdit);
>         ColorEditorTrack.myFrameEdit.setPreferredSize(new Dimension(250, 250));
>         ColorEditorTrack.myFrameEdit.getContentPane().add(mainPanelEdit);
>         ColorEditorTrack.myFrameEdit.pack();
>         ColorEditorTrack.myFrameEdit.setLocationByPlatform(true);
>         this.addButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 ColorEditorTrack.tableC.setRowHeight(featureList.getHeight());
>                 ColorEditorTrack.myFrameAdd.setVisible(true);
>             }
>         });
>         this.okButtonAdd.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 final JLabel labelString = new JLabel();
>                 final JLabel labelColor = new JLabel();
>                 final JLabel labelFeature = new JLabel();
>                 labelColor.setText("");
>                 labelColor.setBackground(ColorEditorTrack.this.currentColorAdd);
>                 labelString.setText(ColorEditorTrack.this.addTextFAdd.getText());
>                 labelString.setHorizontalAlignment(0);
>                 labelString.setBackground(ColorEditorTrack.this.currentColorAdd);
>                 labelColor.setOpaque(true);
>                 final StringBuilder filterItems = new StringBuilder();
>                 for (int x = 0; x < featureList.getModel().getSize(); ++x) {
>                     filterItems.append(featureList.getModel().getElementAt(x)).append("<br>");
>                 }
>                 labelFeature.setText("<html>" + filterItems.toString() + "</html>");
>                 ColorEditorTrack.modelC.addRow(new Object[] { labelString, labelColor, labelFeature });
>                 ColorEditorTrack.modelC.fireTableDataChanged();
>                 ColorEditorTrack.tableC.repaint();
>                 ColorEditorTrack.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameAdd, 201));
>             }
>         });
>         this.cancelButtonAdd.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 ColorEditorTrack.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameAdd, 201));
>             }
>         });
>         this.editButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 ColorEditorTrack.myFrameEdit.setVisible(true);
>                 ColorEditorTrack.access$2(ColorEditorTrack.this, ColorEditorTrack.tableC.getSelectedRow());
>                 if (ColorEditorTrack.tableC.getSelectedRowCount() == 0) {
>                     return;
>                 }
>                 if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
>                     ColorEditorTrack.access$3(ColorEditorTrack.this, new Object());
>                     ColorEditorTrack.access$4(ColorEditorTrack.this, new Object());
>                     ColorEditorTrack.access$3(ColorEditorTrack.this, ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0)));
>                     ColorEditorTrack.access$4(ColorEditorTrack.this, ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1)));
>                     ColorEditorTrack.access$7(ColorEditorTrack.this, ((JLabel)ColorEditorTrack.this.labelC).getText());
>                     ColorEditorTrack.access$9(ColorEditorTrack.this, ((JLabel)ColorEditorTrack.this.colorC).getBackground());
>                 }
>                 ColorEditorTrack.this.colorButtonEdit.setBackground(((JLabel)ColorEditorTrack.this.colorC).getBackground());
>                 ColorEditorTrack.access$11(ColorEditorTrack.this, ((JLabel)ColorEditorTrack.this.colorC).getBackground());
>                 ColorEditorTrack.this.colorButtonEdit.setContentAreaFilled(false);
>                 ColorEditorTrack.this.colorButtonEdit.setOpaque(true);
>                 ColorEditorTrack.this.addTextFEdit.setText(((JLabel)ColorEditorTrack.this.labelC).getText());
>             }
>         });
>         this.colorButtonAdd.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 Locale.setDefault(Locale.ENGLISH);
>                 JComponent.setDefaultLocale(Locale.ENGLISH);
>                 JComponent.setDefaultLocale(Locale.getDefault());
>                 ColorEditorTrack.access$14(ColorEditorTrack.this, JColorChooser.showDialog(null, "Pick a Color: ", ColorEditorTrack.this.colorButtonAdd.getBackground()));
>                 if (ColorEditorTrack.this.currentColorAdd != null) {
>                     ColorEditorTrack.this.colorButtonAdd.setBackground(ColorEditorTrack.this.currentColorAdd);
>                 }
>             }
>         });
>         this.okButtonEdit.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 final JLabel labelString = new JLabel();
>                 final JLabel labelColor = new JLabel();
>                 labelColor.setText("");
>                 labelColor.setBackground(ColorEditorTrack.this.currentColorEdit);
>                 labelString.setText(ColorEditorTrack.this.addTextFEdit.getText());
>                 labelString.setHorizontalAlignment(0);
>                 labelString.setBackground(ColorEditorTrack.this.currentColorEdit);
>                 labelColor.setOpaque(true);
>                 ColorEditorTrack.access$16(ColorEditorTrack.this, labelString.getText());
>                 ColorEditorTrack.access$17(ColorEditorTrack.this, labelColor.getBackground());
>                 if (!ColorEditorTrack.this.addTextFinal.equals(ColorEditorTrack.this.addTextInitial)) {
>                     ColorEditorTrack.modelC.setValueAt(labelString, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
>                 }
>                 if (ColorEditorTrack.this.addTextFinal.equals(ColorEditorTrack.this.addTextInitial)) {
>                     ColorEditorTrack.modelC.setValueAt(ColorEditorTrack.this.labelC, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
>                 }
>                 if (ColorEditorTrack.this.currentColorEdit != ColorEditorTrack.this.colorCInitial) {
>                     ColorEditorTrack.modelC.setValueAt(labelColor, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
>                 }
>                 if (ColorEditorTrack.this.currentColorEdit == ColorEditorTrack.this.colorCInitial) {
>                     ColorEditorTrack.modelC.setValueAt(ColorEditorTrack.this.colorC, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
>                 }
>                 ColorEditorTrack.modelC.fireTableCellUpdated(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
>                 ColorEditorTrack.modelC.fireTableCellUpdated(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
>                 ColorEditorTrack.tableC.repaint();
>                 ColorEditorTrack.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameEdit, 201));
>             }
>         });
>         this.cancelButtonEdit.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 ColorEditorTrack.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameEdit, 201));
>             }
>         });
>     }
>     
>     public void setClassAction() {
>         this.colorButtonEdit.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 Locale.setDefault(Locale.ENGLISH);
>                 JComponent.setDefaultLocale(Locale.ENGLISH);
>                 JComponent.setDefaultLocale(Locale.getDefault());
>                 ColorEditorTrack.access$11(ColorEditorTrack.this, JColorChooser.showDialog(null, "Pick a Color: ", ColorEditorTrack.this.colorButtonEdit.getBackground()));
>                 if (ColorEditorTrack.this.currentColorEdit != null) {
>                     ColorEditorTrack.this.colorButtonEdit.setBackground(ColorEditorTrack.this.currentColorEdit);
>                 }
>             }
>         });
>         this.okButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 if (ColorEditorTrack.tableC.getSelectedRowCount() <= 0) {
>                     ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
>                 }
>                 if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
>                     final List<String> listClasses = new ArrayList<String>();
>                     ColorEditorTrack.classList = ChooserWizardPanel.classList;
>                     ColorEditorTrack.modelListClass = ChooserWizardPanel.modelListClass;
>                     final int selectedRow = ColorEditorTrack.tableC.getSelectedRow();
>                     if (ColorEditorTrack.modelListClass.getSize() == 0) {
>                         ColorEditorTrack.modelListClass.addElement(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
>                         final JLabel labelsTableC = new JLabel();
>                         for (int i = 0; i < ColorEditorTrack.tableC.getModel().getRowCount(); ++i) {
>                             labelsTableC.setText(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
>                             labelsTableC.setHorizontalAlignment(0);
>                             labelsTableC.setBackground(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(1))).getBackground());
>                             labelsTableC.setOpaque(true);
432,467c403,410
<                      }
<                   }
<                }
< 
<                if (ColorEditorTrack.modelListClass.getSize() >= 1) {
<                   for(int i = 0; i < ColorEditorTrack.modelListClass.getSize(); ++i) {
<                      listClasses.add((String)ColorEditorTrack.modelListClass.getElementAt(i));
<                   }
< 
<                   if (!listClasses.contains(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText())) {
<                      ColorEditorTrack.modelListClass.addElement(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
<                      labelsTableC = new JLabel();
< 
<                      for(ix = 0; ix < ColorEditorTrack.tableC.getModel().getRowCount(); ++ix) {
<                         labelsTableC.setText(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
<                         labelsTableC.setHorizontalAlignment(0);
<                         labelsTableC.setBackground(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(1))).getBackground());
<                         labelsTableC.setOpaque(true);
<                      }
< 
<                      filterFeature = ((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
<                      features = new ArrayList();
<                      featureMin = new ArrayList();
<                      featureMax = new ArrayList();
< 
<                      for(x = 0; x < filterFeature.length; ++x) {
<                         features.add(filterFeature[x].substring(0, filterFeature[x].indexOf(":")));
<                         featureMin.add(filterFeature[x].substring(filterFeature[x].indexOf("[") + 1, filterFeature[x].indexOf(",")));
<                         featureMax.add(filterFeature[x].substring(filterFeature[x].indexOf(",") + 1, filterFeature[x].indexOf("]")));
<                      }
< 
<                      for(x = 0; x < ChooserWizardPanel.modelTrack.getRowCount(); ++x) {
<                         for(u = 0; u < features.size(); ++u) {
<                            if (Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble((String)featureMin.get(u)) && Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble((String)featureMax.get(u))) {
<                               ChooserWizardPanel.tableTrack.getModel().setValueAt(labelsTableC, ChooserWizardPanel.tableTrack.convertRowIndexToModel(x), ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
<                            }
---
>                         final String[] filterFeature = ((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
>                         final List<String> features = new ArrayList<String>();
>                         final List<String> featureMin = new ArrayList<String>();
>                         final List<String> featureMax = new ArrayList<String>();
>                         for (int j = 0; j < filterFeature.length; ++j) {
>                             features.add(filterFeature[j].substring(0, filterFeature[j].indexOf(":")));
>                             featureMin.add(filterFeature[j].substring(filterFeature[j].indexOf("[") + 1, filterFeature[j].indexOf(",")));
>                             featureMax.add(filterFeature[j].substring(filterFeature[j].indexOf(",") + 1, filterFeature[j].indexOf("]")));
469,553c412,454
<                      }
<                   }
< 
<                   if (listClasses.contains(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText())) {
<                      ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
<                   }
<                }
<             }
< 
<          }
<       });
<       this.cancelButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
<          }
<       });
<       this.deleteButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Object labelC = null;
<             Object colorC = null;
<             Object[] labelsC = null;
<             Object[] colorsC = null;
<             int[] indexesRowC = ColorEditorTrack.tableC.getSelectedRows();
<             int indexRowC = ColorEditorTrack.tableC.getSelectedRow();
<             if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
<                new Object();
<                new Object();
<                labelC = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<                colorC = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<             }
< 
<             labelsC = new Object[indexesRowC.length];
<             colorsC = new Object[indexesRowC.length];
<             if (ColorEditorTrack.tableC.getSelectedRowCount() > 1) {
<                for(int k = 0; k < indexesRowC.length; ++k) {
<                   labelsC[k] = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<                   colorsC[k] = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<                }
<             }
< 
<             Locale.setDefault(Locale.ENGLISH);
<             Locale var10000 = Locale.ENGLISH;
<             JOptionPane.setDefaultLocale(Locale.getDefault());
<             if (ColorEditorTrack.tableC.getSelectedRowCount() > 1) {
<                String[] labelsCtoString = new String[indexesRowC.length];
< 
<                int f;
<                for(f = 0; f < indexesRowC.length; ++f) {
<                   labelsCtoString[f] = ((JLabel)labelsC[f]).getText();
<                }
< 
<                ColorEditorTrack.this.input = JOptionPane.showConfirmDialog((Component)null, "Are you sure to delete the selected labels?", "Delete a label", 1, 0);
<                if (ColorEditorTrack.this.input == 0) {
<                   for(f = 0; f < indexesRowC.length; ++f) {
<                      ColorEditorTrack.modelC.removeRow(indexesRowC[f] - f);
<                   }
< 
<                   ColorEditorTrack.modelC.fireTableDataChanged();
<                   ColorEditorTrack.tableC.repaint();
<                }
< 
<                if (ColorEditorTrack.this.input == 1) {
<                   return;
<                }
< 
<                if (ColorEditorTrack.this.input == 2) {
<                   return;
<                }
<             }
< 
<             if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
<                String labelCtoString = ((JLabel)labelC).getText();
<                ColorEditorTrack.this.input = JOptionPane.showConfirmDialog((Component)null, "Are you sure to delete the following label?----- " + labelCtoString, "Delete a label", 1, 0);
<                if (ColorEditorTrack.this.input == 0) {
<                   ColorEditorTrack.modelC.removeRow(indexRowC);
<                   ColorEditorTrack.modelC.fireTableDataChanged();
<                }
< 
<                if (ColorEditorTrack.this.input == 1) {
<                   return;
<                }
< 
<                if (ColorEditorTrack.this.input == 2) {
<                   return;
<                }
---
>                         for (int x = 0; x < ChooserWizardPanel.modelTrack.getRowCount(); ++x) {
>                             for (int u = 0; u < features.size(); ++u) {
>                                 if (Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble(featureMin.get(u)) && Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble(featureMax.get(u))) {
>                                     ChooserWizardPanel.tableTrack.getModel().setValueAt(labelsTableC, ChooserWizardPanel.tableTrack.convertRowIndexToModel(x), ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
>                                 }
>                             }
>                         }
>                     }
>                     if (ColorEditorTrack.modelListClass.getSize() >= 1) {
>                         for (int k = 0; k < ColorEditorTrack.modelListClass.getSize(); ++k) {
>                             listClasses.add(ColorEditorTrack.modelListClass.getElementAt(k));
>                         }
>                         if (!listClasses.contains(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText())) {
>                             ColorEditorTrack.modelListClass.addElement(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
>                             final JLabel labelsTableC = new JLabel();
>                             for (int i = 0; i < ColorEditorTrack.tableC.getModel().getRowCount(); ++i) {
>                                 labelsTableC.setText(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
>                                 labelsTableC.setHorizontalAlignment(0);
>                                 labelsTableC.setBackground(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(1))).getBackground());
>                                 labelsTableC.setOpaque(true);
>                             }
>                             final String[] filterFeature = ((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
>                             final List<String> features = new ArrayList<String>();
>                             final List<String> featureMin = new ArrayList<String>();
>                             final List<String> featureMax = new ArrayList<String>();
>                             for (int j = 0; j < filterFeature.length; ++j) {
>                                 features.add(filterFeature[j].substring(0, filterFeature[j].indexOf(":")));
>                                 featureMin.add(filterFeature[j].substring(filterFeature[j].indexOf("[") + 1, filterFeature[j].indexOf(",")));
>                                 featureMax.add(filterFeature[j].substring(filterFeature[j].indexOf(",") + 1, filterFeature[j].indexOf("]")));
>                             }
>                             for (int x = 0; x < ChooserWizardPanel.modelTrack.getRowCount(); ++x) {
>                                 for (int u = 0; u < features.size(); ++u) {
>                                     if (Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble(featureMin.get(u)) && Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble(featureMax.get(u))) {
>                                         ChooserWizardPanel.tableTrack.getModel().setValueAt(labelsTableC, ChooserWizardPanel.tableTrack.convertRowIndexToModel(x), ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
>                                     }
>                                 }
>                             }
>                         }
>                         if (listClasses.contains(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText())) {
>                             ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
>                         }
>                     }
>                 }
555,584c456,593
< 
<          }
<       });
<    }
< 
<    public Object getCellEditorValueAdd() {
<       return this.currentColorAdd;
<    }
< 
<    public Object getCellEditorValueEdit() {
<       return this.currentColorEdit;
<    }
< 
<    public Component getTableCellEditorComponentAdd(JTable table, Object value, boolean isSelected, int row, int column) {
<       this.currentColorAdd = (Color)value;
<       return this.colorButtonAdd;
<    }
< 
<    public Component getTableCellEditorComponentEdit(JTable table, Object value, boolean isSelected, int row, int column) {
<       this.currentColorEdit = (Color)value;
<       return this.colorButtonEdit;
<    }
< 
<    public Component getTableCellEditorComponent(JTable arg0, Object arg1, boolean arg2, int arg3, int arg4) {
<       return null;
<    }
< 
<    public Object getCellEditorValue() {
<       return null;
<    }
---
>         });
>         this.cancelButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
>             }
>         });
>         this.deleteButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 Object labelC = null;
>                 Object colorC = null;
>                 Object[] labelsC = null;
>                 Object[] colorsC = null;
>                 final int[] indexesRowC = ColorEditorTrack.tableC.getSelectedRows();
>                 final int indexRowC = ColorEditorTrack.tableC.getSelectedRow();
>                 if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
>                     labelC = new Object();
>                     colorC = new Object();
>                     labelC = ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
>                     colorC = ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
>                 }
>                 labelsC = new Object[indexesRowC.length];
>                 colorsC = new Object[indexesRowC.length];
>                 if (ColorEditorTrack.tableC.getSelectedRowCount() > 1) {
>                     for (int k = 0; k < indexesRowC.length; ++k) {
>                         labelsC[k] = ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
>                         colorsC[k] = ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
>                     }
>                 }
>                 Locale.setDefault(Locale.ENGLISH);
>                 final Locale english = Locale.ENGLISH;
>                 JComponent.setDefaultLocale(Locale.getDefault());
>                 if (ColorEditorTrack.tableC.getSelectedRowCount() > 1) {
>                     final String[] labelsCtoString = new String[indexesRowC.length];
>                     for (int i = 0; i < indexesRowC.length; ++i) {
>                         labelsCtoString[i] = ((JLabel)labelsC[i]).getText();
>                     }
>                     ColorEditorTrack.access$21(ColorEditorTrack.this, JOptionPane.showConfirmDialog(null, "Are you sure to delete the selected labels?", "Delete a label", 1, 0));
>                     if (ColorEditorTrack.this.input == 0) {
>                         for (int f = 0; f < indexesRowC.length; ++f) {
>                             ColorEditorTrack.modelC.removeRow(indexesRowC[f] - f);
>                         }
>                         ColorEditorTrack.modelC.fireTableDataChanged();
>                         ColorEditorTrack.tableC.repaint();
>                     }
>                     if (ColorEditorTrack.this.input == 1) {
>                         return;
>                     }
>                     if (ColorEditorTrack.this.input == 2) {
>                         return;
>                     }
>                 }
>                 if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
>                     final String labelCtoString = ((JLabel)labelC).getText();
>                     ColorEditorTrack.access$21(ColorEditorTrack.this, JOptionPane.showConfirmDialog(null, "Are you sure to delete the following label?----- " + labelCtoString, "Delete a label", 1, 0));
>                     if (ColorEditorTrack.this.input == 0) {
>                         ColorEditorTrack.modelC.removeRow(indexRowC);
>                         ColorEditorTrack.modelC.fireTableDataChanged();
>                     }
>                     if (ColorEditorTrack.this.input == 1) {
>                         return;
>                     }
>                     if (ColorEditorTrack.this.input == 2) {
>                         return;
>                     }
>                 }
>             }
>         });
>     }
>     
>     public Object getCellEditorValueAdd() {
>         return this.currentColorAdd;
>     }
>     
>     public Object getCellEditorValueEdit() {
>         return this.currentColorEdit;
>     }
>     
>     public Component getTableCellEditorComponentAdd(final JTable table, final Object value, final boolean isSelected, final int row, final int column) {
>         this.currentColorAdd = (Color)value;
>         return this.colorButtonAdd;
>     }
>     
>     public Component getTableCellEditorComponentEdit(final JTable table, final Object value, final boolean isSelected, final int row, final int column) {
>         this.currentColorEdit = (Color)value;
>         return this.colorButtonEdit;
>     }
>     
>     @Override
>     public Component getTableCellEditorComponent(final JTable arg0, final Object arg1, final boolean arg2, final int arg3, final int arg4) {
>         return null;
>     }
>     
>     @Override
>     public Object getCellEditorValue() {
>         return null;
>     }
>     
>     static /* synthetic */ void access$2(final ColorEditorTrack colorEditorTrack, final int indexRowC) {
>         colorEditorTrack.indexRowC = indexRowC;
>     }
>     
>     static /* synthetic */ void access$3(final ColorEditorTrack colorEditorTrack, final Object labelC) {
>         colorEditorTrack.labelC = labelC;
>     }
>     
>     static /* synthetic */ void access$4(final ColorEditorTrack colorEditorTrack, final Object colorC) {
>         colorEditorTrack.colorC = colorC;
>     }
>     
>     static /* synthetic */ void access$7(final ColorEditorTrack colorEditorTrack, final String addTextInitial) {
>         colorEditorTrack.addTextInitial = addTextInitial;
>     }
>     
>     static /* synthetic */ void access$9(final ColorEditorTrack colorEditorTrack, final Color colorCInitial) {
>         colorEditorTrack.colorCInitial = colorCInitial;
>     }
>     
>     static /* synthetic */ void access$11(final ColorEditorTrack colorEditorTrack, final Color currentColorEdit) {
>         colorEditorTrack.currentColorEdit = currentColorEdit;
>     }
>     
>     static /* synthetic */ void access$14(final ColorEditorTrack colorEditorTrack, final Color currentColorAdd) {
>         colorEditorTrack.currentColorAdd = currentColorAdd;
>     }
>     
>     static /* synthetic */ void access$16(final ColorEditorTrack colorEditorTrack, final String addTextFinal) {
>         colorEditorTrack.addTextFinal = addTextFinal;
>     }
>     
>     static /* synthetic */ void access$17(final ColorEditorTrack colorEditorTrack, final Color colorCFinal) {
>         colorEditorTrack.colorCFinal = colorCFinal;
>     }
>     
>     static /* synthetic */ void access$21(final ColorEditorTrack colorEditorTrack, final int input) {
>         colorEditorTrack.input = input;
>     }
diff -r TrackAnalyzer_/ColorRenderer.java procyon/ColorRenderer.java
0a1
> import javax.swing.BorderFactory;
3,4d3
< import javax.swing.BorderFactory;
< import javax.swing.JLabel;
7a7
> import javax.swing.JLabel;
9,26c9,37
< public class ColorRenderer extends JLabel implements TableCellRenderer {
<    private static final long serialVersionUID = 1L;
<    Border unselectedBorder = null;
<    Border selectedBorder = null;
<    boolean isBordered = true;
< 
<    public ColorRenderer(boolean isBordered) {
<       this.isBordered = isBordered;
<       this.setOpaque(true);
<    }
< 
<    public Component getTableCellRendererComponent(JTable table, Object color, boolean isSelected, boolean hasFocus, int row, int column) {
<       Color newColor = (Color)color;
<       this.setBackground(newColor);
<       if (this.isBordered) {
<          if (isSelected) {
<             if (this.selectedBorder == null) {
<                this.selectedBorder = BorderFactory.createMatteBorder(2, 5, 2, 5, table.getSelectionBackground());
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class ColorRenderer extends JLabel implements TableCellRenderer
> {
>     private static final long serialVersionUID = 1L;
>     Border unselectedBorder;
>     Border selectedBorder;
>     boolean isBordered;
>     
>     public ColorRenderer(final boolean isBordered) {
>         this.unselectedBorder = null;
>         this.selectedBorder = null;
>         this.isBordered = true;
>         this.isBordered = isBordered;
>         this.setOpaque(true);
>     }
>     
>     @Override
>     public Component getTableCellRendererComponent(final JTable table, final Object color, final boolean isSelected, final boolean hasFocus, final int row, final int column) {
>         final Color newColor = (Color)color;
>         this.setBackground(newColor);
>         if (this.isBordered) {
>             if (isSelected) {
>                 if (this.selectedBorder == null) {
>                     this.selectedBorder = BorderFactory.createMatteBorder(2, 5, 2, 5, table.getSelectionBackground());
>                 }
>                 this.setBorder(this.selectedBorder);
28,32c39,43
< 
<             this.setBorder(this.selectedBorder);
<          } else {
<             if (this.unselectedBorder == null) {
<                this.unselectedBorder = BorderFactory.createMatteBorder(2, 5, 2, 5, table.getBackground());
---
>             else {
>                 if (this.unselectedBorder == null) {
>                     this.unselectedBorder = BorderFactory.createMatteBorder(2, 5, 2, 5, table.getBackground());
>                 }
>                 this.setBorder(this.unselectedBorder);
34,41c45,48
< 
<             this.setBorder(this.unselectedBorder);
<          }
<       }
< 
<       this.setToolTipText("RGB value: " + newColor.getRed() + ", " + newColor.getGreen() + ", " + newColor.getBlue());
<       return this;
<    }
---
>         }
>         this.setToolTipText("RGB value: " + newColor.getRed() + ", " + newColor.getGreen() + ", " + newColor.getBlue());
>         return this;
>     }
diff -r TrackAnalyzer_/ComputeMSD.java procyon/ComputeMSD.java
1,2c1
< import ij.measure.ResultsTable;
< import java.io.File;
---
> import org.jfree.chart.JFreeChart;
4,8d2
< import java.util.ArrayList;
< import java.util.List;
< import math.PowerLawCurveFitModified;
< import org.apache.commons.math3.stat.regression.SimpleRegression;
< import org.jfree.chart.ChartFactory;
10c4,6
< import org.jfree.chart.JFreeChart;
---
> import java.io.File;
> import org.jfree.data.xy.XYDataset;
> import org.jfree.chart.ChartFactory;
11a8,9
> import math.PowerLawCurveFitModified;
> import org.apache.commons.math3.stat.regression.SimpleRegression;
12a11,13
> import java.util.ArrayList;
> import ij.measure.ResultsTable;
> import java.util.List;
14,222c15,190
< public class ComputeMSD {
<    static List<Double> d14Values;
<    static List<Double> alphaValues;
<    static List<Double> diffValues;
<    static List<Double> msd1Values;
<    static List<Double> msd2Values;
<    static List<Double> msd3Values;
<    static List<Double> msdValues;
<    static List<Double> mssValues;
< 
<    public void Compute(List<Integer> nOfTracks, ResultsTable rtSpots) {
<       List<List<Double>> imported2SpotX = new ArrayList();
<       List<List<Double>> imported2SpotY = new ArrayList();
<       List<List<Double>> imported2SpotT = new ArrayList();
<       List<List<Double>> imported2SpotF = new ArrayList();
<       List<Integer> trackName = new ArrayList();
< 
<       int i;
<       for(i = 0; i < nOfTracks.size(); ++i) {
<          trackName.add((Integer)nOfTracks.get(i));
<          List<Double> imported1SpotX = new ArrayList();
<          List<Double> imported1SpotY = new ArrayList();
<          List<Double> imported1SpotT = new ArrayList();
<          List<Double> imported1SpotF = new ArrayList();
< 
<          for(int i = 0; i < rtSpots.size(); ++i) {
<             if (rtSpots.getStringValue(2, i).equals(String.valueOf((Integer)nOfTracks.get(i))) == Boolean.TRUE) {
<                imported1SpotX.add(Double.valueOf(rtSpots.getStringValue(4, i)));
<                imported1SpotY.add(Double.valueOf(rtSpots.getStringValue(5, i)));
<                imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(7, i)));
<                imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(8, i)));
<             }
<          }
< 
<          imported2SpotX.add(imported1SpotX);
<          imported2SpotY.add(imported1SpotY);
<          imported2SpotT.add(imported1SpotT);
<          imported2SpotF.add(imported1SpotF);
<       }
< 
<       diffValues = new ArrayList();
<       d14Values = new ArrayList();
<       alphaValues = new ArrayList();
<       msd1Values = new ArrayList();
<       msd2Values = new ArrayList();
<       msd3Values = new ArrayList();
<       msdValues = new ArrayList();
<       mssValues = new ArrayList();
< 
<       for(i = 0; i < imported2SpotX.size(); ++i) {
<          XYSeriesCollection datasetMSS = new XYSeriesCollection();
<          double frameInterval = (Double)((List)imported2SpotT.get(i)).get(2) - (Double)((List)imported2SpotT.get(i)).get(1);
<          int nMSD = ((List)imported2SpotX.get(i)).size();
<          int[] tau = new int[4];
< 
<          for(int z = 0; z < 4; ++z) {
<             tau[z] = 1 + z;
<          }
< 
<          double[] msdArray = new double[tau.length];
<          double[] timeArray = new double[tau.length];
<          double[] DArray = new double[tau.length];
<          double msd = -1.0D;
<          SimpleRegression regD14 = new SimpleRegression(true);
<          double msdhelp123 = 0.0D;
<          double msdhelp1 = 0.0D;
<          double msdhelp2 = 0.0D;
<          double msdhelp3 = 0.0D;
< 
<          for(int dt = 0; dt < tau.length; ++dt) {
<             double N = 0.0D;
<             msd = 0.0D;
< 
<             for(int j = tau[dt]; j < ((List)imported2SpotX.get(i)).size(); ++j) {
<                msd += (Math.pow((Double)((List)imported2SpotX.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotX.get(i)).get(j), 2.0D) + Math.pow((Double)((List)imported2SpotY.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotY.get(i)).get(j), 2.0D)) / Math.abs((Double)((List)imported2SpotF.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotF.get(i)).get(j));
<                ++N;
<             }
< 
<             msd /= N;
<             if (tau[dt] == 1) {
<                msdhelp1 = msd;
<             }
< 
<             if (tau[dt] == 2) {
<                msdhelp2 = msd;
<             }
< 
<             if (tau[dt] == 3) {
<                msdhelp3 = msd;
<             }
< 
<             regD14.addData((double)tau[dt] * frameInterval, msd);
<             msdArray[dt] = msd;
<             DArray[dt] = msd / ((double)(4 * tau[dt]) * frameInterval);
<             timeArray[dt] = (double)tau[dt] * frameInterval;
<          }
< 
<          double sum = 0.0D;
< 
<          for(int x = 0; x < msdArray.length; ++x) {
<             sum += msdArray[x];
<          }
< 
<          double sumD = 0.0D;
< 
<          for(int x = 0; x < DArray.length - 1; ++x) {
<             sumD += DArray[x];
<          }
< 
<          double DAvg = sumD / (double)(DArray.length - 1);
<          double slopeDiff14 = regD14.getSlope() / 4.0D;
<          double msdT = -1.0D;
<          SimpleRegression regMSD = new SimpleRegression(true);
<          int[] tauMSD = new int[nMSD - 1];
< 
<          int dt;
<          for(dt = 0; dt < nMSD - 1 - 1 + 1; ++dt) {
<             tauMSD[dt] = 1 + dt;
<          }
< 
<          for(dt = 0; dt < tauMSD.length; ++dt) {
<             double NMSD = 0.0D;
<             msdT = 0.0D;
< 
<             for(int j = tauMSD[dt]; j < ((List)imported2SpotX.get(i)).size(); ++j) {
<                msdT += (Math.pow((Double)((List)imported2SpotX.get(i)).get(j - tauMSD[dt]) - (Double)((List)imported2SpotX.get(i)).get(j), 2.0D) + Math.pow((Double)((List)imported2SpotY.get(i)).get(j - tauMSD[dt]) - (Double)((List)imported2SpotY.get(i)).get(j), 2.0D)) / Math.abs((Double)((List)imported2SpotF.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotF.get(i)).get(j));
<                ++NMSD;
<             }
< 
<             msdT /= NMSD;
<             regMSD.addData((double)tauMSD[dt] * frameInterval, msdT);
<          }
< 
<          double msdReg = regMSD.getSlope();
<          PowerLawCurveFitModified pwf = new PowerLawCurveFitModified();
<          pwf.doFit(timeArray, msdArray);
<          alphaValues.add(Math.abs(pwf.getAlpha()));
<          diffValues.add(Math.abs(DAvg));
<          d14Values.add(Math.abs(slopeDiff14));
<          msdValues.add(Math.abs(msdReg));
<          msd1Values.add(Math.abs(msdhelp1));
<          msd2Values.add(Math.abs(msdhelp2));
<          msd3Values.add(Math.abs(msdhelp3));
<          int[] tauMSS = new int[10];
< 
<          for(int z = 0; z < 10; ++z) {
<             tauMSS[z] = 1 + z;
<          }
< 
<          double[] order = new double[]{1.0D, 2.0D, 3.0D, 4.0D, 5.0D, 6.0D};
<          double[] scalingCoef = new double[order.length];
<          XYSeriesCollection dataset = new XYSeriesCollection();
< 
<          for(int o = 0; o < order.length; ++o) {
<             XYSeries series1 = new XYSeries(order[o]);
<             SimpleRegression regMSS = new SimpleRegression(true);
<             double momenthelp = 0.0D;
<             double moments = -1.0D;
< 
<             for(int dt = 0; dt < tauMSS.length; ++dt) {
<                double Nmoments = 0.0D;
<                moments = 0.0D;
< 
<                for(int j = tauMSS[dt]; j < ((List)imported2SpotX.get(i)).size(); ++j) {
<                   moments += (Math.pow(Math.abs((Double)((List)imported2SpotX.get(i)).get(j - tauMSS[dt]) - (Double)((List)imported2SpotX.get(i)).get(j)), order[o]) + Math.pow(Math.abs((Double)((List)imported2SpotY.get(i)).get(j - tauMSS[dt]) - (Double)((List)imported2SpotY.get(i)).get(j)), order[o])) / Math.abs((Double)((List)imported2SpotF.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotF.get(i)).get(j));
<                   ++Nmoments;
<                }
< 
<                if (moments != 0.0D) {
<                   moments /= Nmoments;
<                   regMSS.addData(Math.log(Math.abs((double)tauMSS[dt] * frameInterval)), Math.log(moments));
<                   series1.add(Math.log(Math.abs((double)tauMSS[dt] * frameInterval)), Math.log(moments));
<                }
<             }
< 
<             dataset.addSeries(series1);
<             scalingCoef[o] = Math.abs(regMSS.getSlope());
<          }
< 
<          JFreeChart chart1 = ChartFactory.createXYLineChart("log ,i(nt) vs. log nt for " + String.valueOf(nOfTracks.get(i)), "log nt", "log ,i(nt)", dataset);
< 
<          try {
<             ChartUtils.saveChartAsPNG(new File(SPTBatch_.directMSS.getAbsolutePath() + File.separator + "log ,i(nt) vs. log nt for " + nOfTracks.get(i)), chart1, 640, 480);
<          } catch (IOException var59) {
<             System.err.println(var59);
<          }
< 
<          SimpleRegression regScal = new SimpleRegression(true);
<          XYSeries series2 = new XYSeries((Comparable)nOfTracks.get(i));
< 
<          for(int z = 0; z < scalingCoef.length; ++z) {
<             regScal.addData((double)(z + 1), scalingCoef[z]);
<             series2.add((double)(z + 1), scalingCoef[z]);
<          }
< 
<          datasetMSS.addSeries(series2);
<          JFreeChart chart2 = ChartFactory.createScatterPlot("MSS  vs. for " + String.valueOf(nOfTracks.get(i)), "", "", datasetMSS);
< 
<          try {
<             ChartUtils.saveChartAsPNG(new File(SPTBatch_.directMSS.getAbsolutePath() + File.separator + "MSS  vs. for " + nOfTracks.get(i)), chart2, 640, 480);
<          } catch (IOException var58) {
<             System.err.println(var58);
<          }
< 
<          double sMss = Math.abs(regScal.getSlope());
<          mssValues.add(sMss);
<       }
< 
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class ComputeMSD
> {
>     static List<Double> d14Values;
>     static List<Double> alphaValues;
>     static List<Double> diffValues;
>     static List<Double> msd1Values;
>     static List<Double> msd2Values;
>     static List<Double> msd3Values;
>     static List<Double> msdValues;
>     static List<Double> mssValues;
>     
>     public void Compute(final List<Integer> nOfTracks, final ResultsTable rtSpots) {
>         final List<List<Double>> imported2SpotX = new ArrayList<List<Double>>();
>         final List<List<Double>> imported2SpotY = new ArrayList<List<Double>>();
>         final List<List<Double>> imported2SpotT = new ArrayList<List<Double>>();
>         final List<List<Double>> imported2SpotF = new ArrayList<List<Double>>();
>         final List<Integer> trackName = new ArrayList<Integer>();
>         for (int id = 0; id < nOfTracks.size(); ++id) {
>             trackName.add(nOfTracks.get(id));
>             final List<Double> imported1SpotX = new ArrayList<Double>();
>             final List<Double> imported1SpotY = new ArrayList<Double>();
>             final List<Double> imported1SpotT = new ArrayList<Double>();
>             final List<Double> imported1SpotF = new ArrayList<Double>();
>             for (int i = 0; i < rtSpots.size(); ++i) {
>                 if (rtSpots.getStringValue(2, i).equals(String.valueOf((int)nOfTracks.get(id))) == Boolean.TRUE) {
>                     imported1SpotX.add(Double.valueOf(rtSpots.getStringValue(4, i)));
>                     imported1SpotY.add(Double.valueOf(rtSpots.getStringValue(5, i)));
>                     imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(7, i)));
>                     imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(8, i)));
>                 }
>             }
>             imported2SpotX.add(imported1SpotX);
>             imported2SpotY.add(imported1SpotY);
>             imported2SpotT.add(imported1SpotT);
>             imported2SpotF.add(imported1SpotF);
>         }
>         ComputeMSD.diffValues = new ArrayList<Double>();
>         ComputeMSD.d14Values = new ArrayList<Double>();
>         ComputeMSD.alphaValues = new ArrayList<Double>();
>         ComputeMSD.msd1Values = new ArrayList<Double>();
>         ComputeMSD.msd2Values = new ArrayList<Double>();
>         ComputeMSD.msd3Values = new ArrayList<Double>();
>         ComputeMSD.msdValues = new ArrayList<Double>();
>         ComputeMSD.mssValues = new ArrayList<Double>();
>         for (int j = 0; j < imported2SpotX.size(); ++j) {
>             final XYSeriesCollection datasetMSS = new XYSeriesCollection();
>             final double frameInterval = imported2SpotT.get(j).get(2) - imported2SpotT.get(j).get(1);
>             final int nMSD = imported2SpotX.get(j).size();
>             final int[] tau = new int[4];
>             for (int z = 0; z < 4; ++z) {
>                 tau[z] = 1 + z;
>             }
>             final double[] msdArray = new double[tau.length];
>             final double[] timeArray = new double[tau.length];
>             final double[] DArray = new double[tau.length];
>             double msd = -1.0;
>             final SimpleRegression regD14 = new SimpleRegression(true);
>             double msdhelp123 = 0.0;
>             double msdhelp124 = 0.0;
>             double msdhelp125 = 0.0;
>             double msdhelp126 = 0.0;
>             for (int dt = 0; dt < tau.length; ++dt) {
>                 double N = 0.0;
>                 msd = 0.0;
>                 for (int k = tau[dt]; k < imported2SpotX.get(j).size(); ++k) {
>                     msd += (Math.pow(imported2SpotX.get(j).get(k - tau[dt]) - imported2SpotX.get(j).get(k), 2.0) + Math.pow(imported2SpotY.get(j).get(k - tau[dt]) - imported2SpotY.get(j).get(k), 2.0)) / Math.abs(imported2SpotF.get(j).get(k - tau[dt]) - imported2SpotF.get(j).get(k));
>                     ++N;
>                 }
>                 msd = (msdhelp123 = msd / N);
>                 if (tau[dt] == 1) {
>                     msdhelp124 = msd;
>                 }
>                 if (tau[dt] == 2) {
>                     msdhelp125 = msd;
>                 }
>                 if (tau[dt] == 3) {
>                     msdhelp126 = msd;
>                 }
>                 regD14.addData(tau[dt] * frameInterval, msdhelp123);
>                 msdArray[dt] = msd;
>                 DArray[dt] = msd / (4 * tau[dt] * frameInterval);
>                 timeArray[dt] = tau[dt] * frameInterval;
>             }
>             double sum = 0.0;
>             for (int x = 0; x < msdArray.length; ++x) {
>                 sum += msdArray[x];
>             }
>             double sumD = 0.0;
>             for (int x2 = 0; x2 < DArray.length - 1; ++x2) {
>                 sumD += DArray[x2];
>             }
>             final double DAvg = sumD / (DArray.length - 1);
>             final double slopeDiff14 = regD14.getSlope() / 4.0;
>             double msdT = -1.0;
>             final SimpleRegression regMSD = new SimpleRegression(true);
>             final int[] tauMSD = new int[nMSD - 1];
>             for (int z2 = 0; z2 < nMSD - 1 - 1 + 1; ++z2) {
>                 tauMSD[z2] = 1 + z2;
>             }
>             for (int dt2 = 0; dt2 < tauMSD.length; ++dt2) {
>                 double NMSD = 0.0;
>                 msdT = 0.0;
>                 for (int l = tauMSD[dt2]; l < imported2SpotX.get(j).size(); ++l) {
>                     msdT += (Math.pow(imported2SpotX.get(j).get(l - tauMSD[dt2]) - imported2SpotX.get(j).get(l), 2.0) + Math.pow(imported2SpotY.get(j).get(l - tauMSD[dt2]) - imported2SpotY.get(j).get(l), 2.0)) / Math.abs(imported2SpotF.get(j).get(l - tau[dt2]) - imported2SpotF.get(j).get(l));
>                     ++NMSD;
>                 }
>                 msdT /= NMSD;
>                 regMSD.addData(tauMSD[dt2] * frameInterval, msdT);
>             }
>             final double msdReg = regMSD.getSlope();
>             final PowerLawCurveFitModified pwf = new PowerLawCurveFitModified();
>             pwf.doFit(timeArray, msdArray);
>             ComputeMSD.alphaValues.add(Math.abs(pwf.getAlpha()));
>             ComputeMSD.diffValues.add(Math.abs(DAvg));
>             ComputeMSD.d14Values.add(Math.abs(slopeDiff14));
>             ComputeMSD.msdValues.add(Math.abs(msdReg));
>             ComputeMSD.msd1Values.add(Math.abs(msdhelp124));
>             ComputeMSD.msd2Values.add(Math.abs(msdhelp125));
>             ComputeMSD.msd3Values.add(Math.abs(msdhelp126));
>             final int[] tauMSS = new int[10];
>             for (int z3 = 0; z3 < 10; ++z3) {
>                 tauMSS[z3] = 1 + z3;
>             }
>             final double[] order = { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 };
>             final double[] scalingCoef = new double[order.length];
>             final XYSeriesCollection dataset = new XYSeriesCollection();
>             for (int o = 0; o < order.length; ++o) {
>                 final XYSeries series1 = new XYSeries((Comparable)order[o]);
>                 final SimpleRegression regMSS = new SimpleRegression(true);
>                 double momenthelp = 0.0;
>                 double moments = -1.0;
>                 for (int dt3 = 0; dt3 < tauMSS.length; ++dt3) {
>                     double Nmoments = 0.0;
>                     moments = 0.0;
>                     for (int m = tauMSS[dt3]; m < imported2SpotX.get(j).size(); ++m) {
>                         moments += (Math.pow(Math.abs(imported2SpotX.get(j).get(m - tauMSS[dt3]) - imported2SpotX.get(j).get(m)), order[o]) + Math.pow(Math.abs(imported2SpotY.get(j).get(m - tauMSS[dt3]) - imported2SpotY.get(j).get(m)), order[o])) / Math.abs(imported2SpotF.get(j).get(m - tau[dt3]) - imported2SpotF.get(j).get(m));
>                         ++Nmoments;
>                     }
>                     if (moments != 0.0) {
>                         moments = (momenthelp = moments / Nmoments);
>                         regMSS.addData(Math.log(Math.abs(tauMSS[dt3] * frameInterval)), Math.log(momenthelp));
>                         series1.add(Math.log(Math.abs(tauMSS[dt3] * frameInterval)), Math.log(momenthelp));
>                     }
>                 }
>                 dataset.addSeries(series1);
>                 scalingCoef[o] = Math.abs(regMSS.getSlope());
>             }
>             final JFreeChart chart1 = ChartFactory.createXYLineChart("log ,i(nt) vs. log nt for " + String.valueOf(nOfTracks.get(j)), "log nt", "log ,i(nt)", (XYDataset)dataset);
>             try {
>                 ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directMSS.getAbsolutePath()) + File.separator + "log ,i(nt) vs. log nt for " + String.valueOf(nOfTracks.get(j))), chart1, 640, 480);
>             }
>             catch (IOException ex) {
>                 System.err.println(ex);
>             }
>             final SimpleRegression regScal = new SimpleRegression(true);
>             final XYSeries series2 = new XYSeries((Comparable)nOfTracks.get(j));
>             for (int z4 = 0; z4 < scalingCoef.length; ++z4) {
>                 regScal.addData((double)(z4 + 1), scalingCoef[z4]);
>                 series2.add((double)(z4 + 1), scalingCoef[z4]);
>             }
>             datasetMSS.addSeries(series2);
>             final JFreeChart chart2 = ChartFactory.createScatterPlot("MSS  vs. for " + String.valueOf(nOfTracks.get(j)), "", "", (XYDataset)datasetMSS);
>             try {
>                 ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directMSS.getAbsolutePath()) + File.separator + "MSS  vs. for " + String.valueOf(nOfTracks.get(j))), chart2, 640, 480);
>             }
>             catch (IOException ex2) {
>                 System.err.println(ex2);
>             }
>             final double sMss = Math.abs(regScal.getSlope());
>             ComputeMSD.mssValues.add(sMss);
>         }
>     }
diff -r TrackAnalyzer_/Dialog4BgSub0.java procyon/Dialog4BgSub0.java
1,3c1
< import ij.IJ;
< import ij.gui.GUI;
< import ij.gui.MultiLineLabel;
---
> import java.awt.event.KeyEvent;
5,6c3,8
< import ij.plugin.frame.RoiManager;
< import java.awt.Font;
---
> import java.awt.event.ActionEvent;
> import java.awt.Window;
> import ij.gui.GUI;
> import java.awt.Component;
> import java.awt.Insets;
> import java.awt.LayoutManager;
9,13c11,15
< import java.awt.Insets;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.KeyEvent;
< import java.awt.event.KeyListener;
---
> import ij.plugin.frame.RoiManager;
> import java.awt.Font;
> import java.awt.Frame;
> import ij.IJ;
> import ij.gui.MultiLineLabel;
14a17,18
> import java.awt.event.KeyListener;
> import java.awt.event.ActionListener;
17,145c21,156
< public class Dialog4BgSub0 extends JDialog implements ActionListener, KeyListener {
<    public JButton button;
<    public MultiLineLabel label;
<    protected static int xloc = -1;
<    protected static int yloc = -1;
<    private boolean escPressed;
< 
<    public Dialog4BgSub0(String title, String text) {
<       super(IJ.getInstance(), title, false);
<       IJ.protectStatusBar(false);
<       if (text != null && text.startsWith("IJ: ")) {
<          text = text.substring(4);
<       }
< 
<       this.label = new MultiLineLabel(text, 175);
<       if (!IJ.isLinux()) {
<          this.label.setFont(new Font("SansSerif", 0, 14));
<       }
< 
<       if (IJ.isMacOSX()) {
<          RoiManager rm = RoiManager.getInstance();
<          if (rm != null) {
<             rm.runCommand("enable interrupts");
<          }
<       }
< 
<       GridBagLayout gridbag = new GridBagLayout();
<       GridBagConstraints c = new GridBagConstraints();
<       this.setLayout(gridbag);
<       c.insets = new Insets(6, 6, 0, 6);
<       c.gridx = 0;
<       c.gridy = 0;
<       c.anchor = 17;
<       this.add(this.label, c);
<       this.button = new JButton("  OK  ");
<       this.button.setBounds(50, 100, 95, 30);
<       this.button.setToolTipText("Click this button to process next image.");
<       this.button.addActionListener(this);
<       this.button.addKeyListener(this);
<       c.insets = new Insets(2, 6, 6, 6);
<       c.gridx = 0;
<       c.gridy = 2;
<       c.anchor = 13;
<       this.add(this.button, c);
<       this.setResizable(false);
<       this.addKeyListener(this);
<       GUI.scale(this);
<       this.pack();
<       if (xloc == -1) {
<          GUI.centerOnImageJScreen(this);
<       } else {
<          this.setLocation(xloc, yloc);
<       }
< 
<       this.setAlwaysOnTop(true);
<    }
< 
<    public Dialog4BgSub0(String text) {
<       this("Action Required", text);
<    }
< 
<    public void show() {
<       super.show();
<       synchronized(this) {
<          try {
<             this.wait();
<          } catch (InterruptedException var3) {
<             return;
<          }
< 
<       }
<    }
< 
<    public void close() {
<       synchronized(this) {
<          this.notify();
<       }
< 
<       xloc = this.getLocation().x;
<       yloc = this.getLocation().y;
<       this.dispose();
<    }
< 
<    public void actionPerformed(ActionEvent e) {
<       SPTBatch_.impMaxProject.hide();
<       int[] indexes = SPTBatch_.roiManager.getIndexes();
<       SPTBatch_.roiManager.setSelectedIndexes(indexes);
<       SPTBatch_.roiManager.runCommand(SPTBatch_.impMaxProject, "Combine");
<       Roi roiToMeasure = SPTBatch_.impMaxProject.getRoi();
<       SPTBatch_.roiManager.close();
< 
<       for(int i = 0; i < SPTBatch_.slices.length; ++i) {
<          SPTBatch_.slices[i].setRoi(roiToMeasure);
<          SPTBatch_.slicesIntensitySpot[i] = SPTBatch_.slices[i].getStatistics().mean;
<       }
< 
<       this.close();
<    }
< 
<    public void keyPressed(KeyEvent e) {
<       int keyCode = e.getKeyCode();
<       IJ.setKeyDown(keyCode);
<       if (keyCode == 10 || keyCode == 27) {
<          this.escPressed = keyCode == 27;
<          this.close();
<       }
< 
<    }
< 
<    public boolean escPressed() {
<       return this.escPressed;
<    }
< 
<    public void keyReleased(KeyEvent e) {
<       int keyCode = e.getKeyCode();
<       IJ.setKeyUp(keyCode);
<    }
< 
<    public void keyTyped(KeyEvent e) {
<    }
< 
<    public JButton getButton() {
<       return this.button;
<    }
< 
<    public static void setNextLocation(int x, int y) {
<       xloc = x;
<       yloc = y;
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class Dialog4BgSub0 extends JDialog implements ActionListener, KeyListener
> {
>     public JButton button;
>     public MultiLineLabel label;
>     protected static int xloc;
>     protected static int yloc;
>     private boolean escPressed;
>     
>     static {
>         Dialog4BgSub0.xloc = -1;
>         Dialog4BgSub0.yloc = -1;
>     }
>     
>     public Dialog4BgSub0(final String title, String text) {
>         super((Frame)IJ.getInstance(), title, false);
>         IJ.protectStatusBar(false);
>         if (text != null && text.startsWith("IJ: ")) {
>             text = text.substring(4);
>         }
>         this.label = new MultiLineLabel(text, 175);
>         if (!IJ.isLinux()) {
>             this.label.setFont(new Font("SansSerif", 0, 14));
>         }
>         if (IJ.isMacOSX()) {
>             final RoiManager rm = RoiManager.getInstance();
>             if (rm != null) {
>                 rm.runCommand("enable interrupts");
>             }
>         }
>         final GridBagLayout gridbag = new GridBagLayout();
>         final GridBagConstraints c = new GridBagConstraints();
>         this.setLayout(gridbag);
>         c.insets = new Insets(6, 6, 0, 6);
>         c.gridx = 0;
>         c.gridy = 0;
>         c.anchor = 17;
>         this.add((Component)this.label, c);
>         (this.button = new JButton("  OK  ")).setBounds(50, 100, 95, 30);
>         this.button.setToolTipText("Click this button to process next image.");
>         this.button.addActionListener(this);
>         this.button.addKeyListener(this);
>         c.insets = new Insets(2, 6, 6, 6);
>         c.gridx = 0;
>         c.gridy = 2;
>         c.anchor = 13;
>         this.add(this.button, c);
>         this.setResizable(false);
>         this.addKeyListener(this);
>         GUI.scale((Component)this);
>         this.pack();
>         if (Dialog4BgSub0.xloc == -1) {
>             GUI.centerOnImageJScreen((Window)this);
>         }
>         else {
>             this.setLocation(Dialog4BgSub0.xloc, Dialog4BgSub0.yloc);
>         }
>         this.setAlwaysOnTop(true);
>     }
>     
>     public Dialog4BgSub0(final String text) {
>         this("Action Required", text);
>     }
>     
>     @Override
>     public void show() {
>         super.show();
>         synchronized (this) {
>             try {
>                 this.wait();
>             }
>             catch (InterruptedException e) {
>             }
>             // monitorexit(this)
>         }
>     }
>     
>     public void close() {
>         synchronized (this) {
>             this.notify();
>         }
>         Dialog4BgSub0.xloc = this.getLocation().x;
>         Dialog4BgSub0.yloc = this.getLocation().y;
>         this.dispose();
>     }
>     
>     @Override
>     public void actionPerformed(final ActionEvent e) {
>         SPTBatch_.impMaxProject.hide();
>         final int[] indexes = SPTBatch_.roiManager.getIndexes();
>         SPTBatch_.roiManager.setSelectedIndexes(indexes);
>         SPTBatch_.roiManager.runCommand(SPTBatch_.impMaxProject, "Combine");
>         final Roi roiToMeasure = SPTBatch_.impMaxProject.getRoi();
>         SPTBatch_.roiManager.close();
>         for (int i = 0; i < SPTBatch_.slices.length; ++i) {
>             SPTBatch_.slices[i].setRoi(roiToMeasure);
>             SPTBatch_.slicesIntensitySpot[i] = SPTBatch_.slices[i].getStatistics().mean;
>         }
>         this.close();
>     }
>     
>     @Override
>     public void keyPressed(final KeyEvent e) {
>         final int keyCode = e.getKeyCode();
>         IJ.setKeyDown(keyCode);
>         if (keyCode == 10 || keyCode == 27) {
>             this.escPressed = (keyCode == 27);
>             this.close();
>         }
>     }
>     
>     public boolean escPressed() {
>         return this.escPressed;
>     }
>     
>     @Override
>     public void keyReleased(final KeyEvent e) {
>         final int keyCode = e.getKeyCode();
>         IJ.setKeyUp(keyCode);
>     }
>     
>     @Override
>     public void keyTyped(final KeyEvent e) {
>     }
>     
>     public JButton getButton() {
>         return this.button;
>     }
>     
>     public static void setNextLocation(final int x, final int y) {
>         Dialog4BgSub0.xloc = x;
>         Dialog4BgSub0.yloc = y;
>     }
diff -r TrackAnalyzer_/DiffusionCoefficientEstimator/AbstractDiffusionCoefficientEstimatorModified.java procyon/DiffusionCoefficientEstimator/AbstractDiffusionCoefficientEstimatorModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,6c9,11
< public interface AbstractDiffusionCoefficientEstimatorModified {
<    double[] getDiffusionCoefficient(TrajectoryModified var1, double var2);
---
> public interface AbstractDiffusionCoefficientEstimatorModified
> {
>     double[] getDiffusionCoefficient(final TrajectoryModified p0, final double p1);
diff -r TrackAnalyzer_/DiffusionCoefficientEstimator/CovarianceDiffusionCoefficientEstimatorModified.java procyon/DiffusionCoefficientEstimator/CovarianceDiffusionCoefficientEstimatorModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,4d6
< import features.AbstractTrajectoryFeatureModified;
< import traJ.TrajectoryModified;
6a9,10
> import traJ.TrajectoryModified;
> import features.AbstractTrajectoryFeatureModified;
8,103c12,110
< public class CovarianceDiffusionCoefficientEstimatorModified extends AbstractTrajectoryFeatureModified implements AbstractDiffusionCoefficientEstimatorModified {
<    private TrajectoryModified t;
<    private double fps;
< 
<    public CovarianceDiffusionCoefficientEstimatorModified() {
<    }
< 
<    public CovarianceDiffusionCoefficientEstimatorModified(TrajectoryModified t, double fps) {
<       this.t = t;
<       this.fps = fps;
<    }
< 
<    private double getDistanceProductX(TrajectoryModified t, int n, int m) {
<       double xn = ((Point3dModified)t.get(n + 1)).x - ((Point3dModified)t.get(n)).x;
<       double xm = ((Point3dModified)t.get(m + 1)).x - ((Point3dModified)t.get(m)).x;
<       return xn * xm;
<    }
< 
<    private double getDistanceProductY(TrajectoryModified t, int n, int m) {
<       double xn = ((Point3dModified)t.get(n + 1)).y - ((Point3dModified)t.get(n)).y;
<       double xm = ((Point3dModified)t.get(m + 1)).y - ((Point3dModified)t.get(m)).y;
<       return xn * xm;
<    }
< 
<    private double getDistanceProductZ(TrajectoryModified t, int n, int m) {
<       double xn = ((Point3dModified)t.get(n + 1)).z - ((Point3dModified)t.get(n)).z;
<       double xm = ((Point3dModified)t.get(m + 1)).z - ((Point3dModified)t.get(m)).z;
<       return xn * xm;
<    }
< 
<    public double[] getDiffusionCoefficient(TrajectoryModified t, double fps) {
<       double[] cov = this.getCovData(t, fps, 0.0D);
<       return cov;
<    }
< 
<    private double[] getCovData(TrajectoryModified track, double fps, double R) {
<       double sumX = 0.0D;
<       double sumX2 = 0.0D;
<       double sumY = 0.0D;
<       double sumY2 = 0.0D;
<       double sumZ = 0.0D;
<       double sumZ2 = 0.0D;
<       int N = 0;
<       int M = 0;
<       TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(track, 1);
< 
<       while(it.hasNext()) {
<          int i = it.next();
<          sumX += this.getDistanceProductX(track, i, i);
<          sumY += this.getDistanceProductY(track, i, i);
<          sumZ += this.getDistanceProductZ(track, i, i);
<          ++N;
<          if (i + 2 < track.size() && track.get(i + 2) != null) {
<             sumX2 += this.getDistanceProductX(track, i, i + 1);
<             sumY2 += this.getDistanceProductY(track, i, i + 1);
<             sumZ2 += this.getDistanceProductZ(track, i, i + 1);
<             ++M;
<          }
<       }
< 
<       double msdX = sumX / (double)N;
<       double msdY = sumY / (double)N;
<       double msdZ = sumZ / (double)N;
<       double covX = sumX2 / (double)M;
<       double covY = sumY2 / (double)M;
<       double covZ = sumZ2 / (double)M;
<       double termXA = msdX / 2.0D * fps;
<       double termXB = covX * fps;
<       double termYA = msdY / 2.0D * fps;
<       double termYB = covY * fps;
<       double termZA = msdZ / 2.0D * fps;
<       double termZB = covZ * fps;
<       double DX = termXA + termXB;
<       double DY = termYA + termYB;
<       double DZ = termZA + termZB;
<       double D = (DX + DY + DZ) / (double)track.getDimension();
<       double[] data = new double[]{D, Math.sqrt(Math.abs(covX)), Math.sqrt(Math.abs(covY)), Math.sqrt(Math.abs(covZ))};
<       return data;
<    }
< 
<    public double[] evaluate() {
<       this.result = this.getDiffusionCoefficient(this.t, this.fps);
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Diffusion coefficient (Covariance)";
<    }
< 
<    public String getShortName() {
<       return "DC-COV";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<    }
---
> public class CovarianceDiffusionCoefficientEstimatorModified extends AbstractTrajectoryFeatureModified implements AbstractDiffusionCoefficientEstimatorModified
> {
>     private TrajectoryModified t;
>     private double fps;
>     
>     public CovarianceDiffusionCoefficientEstimatorModified() {
>     }
>     
>     public CovarianceDiffusionCoefficientEstimatorModified(final TrajectoryModified t, final double fps) {
>         this.t = t;
>         this.fps = fps;
>     }
>     
>     private double getDistanceProductX(final TrajectoryModified t, final int n, final int m) {
>         final double xn = t.get(n + 1).x - t.get(n).x;
>         final double xm = t.get(m + 1).x - t.get(m).x;
>         return xn * xm;
>     }
>     
>     private double getDistanceProductY(final TrajectoryModified t, final int n, final int m) {
>         final double xn = t.get(n + 1).y - t.get(n).y;
>         final double xm = t.get(m + 1).y - t.get(m).y;
>         return xn * xm;
>     }
>     
>     private double getDistanceProductZ(final TrajectoryModified t, final int n, final int m) {
>         final double xn = t.get(n + 1).z - t.get(n).z;
>         final double xm = t.get(m + 1).z - t.get(m).z;
>         return xn * xm;
>     }
>     
>     @Override
>     public double[] getDiffusionCoefficient(final TrajectoryModified t, final double fps) {
>         final double[] cov = this.getCovData(t, fps, 0.0);
>         return cov;
>     }
>     
>     private double[] getCovData(final TrajectoryModified track, final double fps, final double R) {
>         double sumX = 0.0;
>         double sumX2 = 0.0;
>         double sumY = 0.0;
>         double sumY2 = 0.0;
>         double sumZ = 0.0;
>         double sumZ2 = 0.0;
>         int N = 0;
>         int M = 0;
>         final TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(track, 1);
>         while (it.hasNext()) {
>             final int i = it.next();
>             sumX += this.getDistanceProductX(track, i, i);
>             sumY += this.getDistanceProductY(track, i, i);
>             sumZ += this.getDistanceProductZ(track, i, i);
>             ++N;
>             if (i + 2 < track.size() && track.get(i + 2) != null) {
>                 sumX2 += this.getDistanceProductX(track, i, i + 1);
>                 sumY2 += this.getDistanceProductY(track, i, i + 1);
>                 sumZ2 += this.getDistanceProductZ(track, i, i + 1);
>                 ++M;
>             }
>         }
>         final double msdX = sumX / N;
>         final double msdY = sumY / N;
>         final double msdZ = sumZ / N;
>         final double covX = sumX2 / M;
>         final double covY = sumY2 / M;
>         final double covZ = sumZ2 / M;
>         final double termXA = msdX / 2.0 * fps;
>         final double termXB = covX * fps;
>         final double termYA = msdY / 2.0 * fps;
>         final double termYB = covY * fps;
>         final double termZA = msdZ / 2.0 * fps;
>         final double termZB = covZ * fps;
>         final double DX = termXA + termXB;
>         final double DY = termYA + termYB;
>         final double DZ = termZA + termZB;
>         final double D = (DX + DY + DZ) / track.getDimension();
>         final double[] data = { D, Math.sqrt(Math.abs(covX)), Math.sqrt(Math.abs(covY)), Math.sqrt(Math.abs(covZ)) };
>         return data;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         return this.result = this.getDiffusionCoefficient(this.t, this.fps);
>     }
>     
>     @Override
>     public String getName() {
>         return "Diffusion coefficient (Covariance)";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "DC-COV";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>     }
diff -r TrackAnalyzer_/DiffusionCoefficientEstimator/RegressionDiffusionCoefficientEstimatorModified.java procyon/DiffusionCoefficientEstimator/RegressionDiffusionCoefficientEstimatorModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,6d6
< import features.AbstractMeanSquaredDisplacmentEvaluatorModified;
< import features.AbstractTrajectoryFeatureModified;
< import features.MeanSquaredDisplacmentFeatureModified;
< import java.util.ArrayList;
8a9,10
> import java.util.ArrayList;
> import features.MeanSquaredDisplacmentFeatureModified;
9a12,13
> import features.AbstractMeanSquaredDisplacmentEvaluatorModified;
> import features.AbstractTrajectoryFeatureModified;
11,48c15,51
< public class RegressionDiffusionCoefficientEstimatorModified extends AbstractTrajectoryFeatureModified implements AbstractDiffusionCoefficientEstimatorModified {
<    private int lagMin;
<    private int lagMax;
<    private AbstractMeanSquaredDisplacmentEvaluatorModified msdevaluator;
<    private TrajectoryModified t;
<    private double fps;
< 
<    public RegressionDiffusionCoefficientEstimatorModified(int lagMin, int lagMax) {
<       this.lagMin = lagMin;
<       this.lagMax = lagMax;
<       this.msdevaluator = new MeanSquaredDisplacmentFeatureModified((TrajectoryModified)null, lagMin);
<    }
< 
<    public RegressionDiffusionCoefficientEstimatorModified(TrajectoryModified t, double fps, int lagMin, int lagMax) {
<       this.lagMin = lagMin;
<       this.lagMax = lagMax;
<       this.msdevaluator = new MeanSquaredDisplacmentFeatureModified((TrajectoryModified)null, lagMin);
<       this.t = t;
<       this.fps = fps;
<    }
< 
<    public double[] getDiffusionCoefficient(TrajectoryModified t, double fps) {
<       if (t.size() == 1) {
<          return null;
<       } else {
<          ArrayList<Double> xDataList = new ArrayList();
<          ArrayList<Double> yDataList = new ArrayList();
<          double msdhelp = 0.0D;
<          if (this.lagMin == this.lagMax) {
<             xDataList.add(0.0D);
<             yDataList.add(0.0D);
<          }
< 
<          this.msdevaluator.setTrajectory(t);
<          this.msdevaluator.setTimelag(this.lagMin);
< 
<          double[] ydata;
<          for(int i = this.lagMin; i < this.lagMax + 1; ++i) {
---
> public class RegressionDiffusionCoefficientEstimatorModified extends AbstractTrajectoryFeatureModified implements AbstractDiffusionCoefficientEstimatorModified
> {
>     private int lagMin;
>     private int lagMax;
>     private AbstractMeanSquaredDisplacmentEvaluatorModified msdevaluator;
>     private TrajectoryModified t;
>     private double fps;
>     
>     public RegressionDiffusionCoefficientEstimatorModified(final int lagMin, final int lagMax) {
>         this.lagMin = lagMin;
>         this.lagMax = lagMax;
>         this.msdevaluator = new MeanSquaredDisplacmentFeatureModified(null, lagMin);
>     }
>     
>     public RegressionDiffusionCoefficientEstimatorModified(final TrajectoryModified t, final double fps, final int lagMin, final int lagMax) {
>         this.lagMin = lagMin;
>         this.lagMax = lagMax;
>         this.msdevaluator = new MeanSquaredDisplacmentFeatureModified(null, lagMin);
>         this.t = t;
>         this.fps = fps;
>     }
>     
>     @Override
>     public double[] getDiffusionCoefficient(final TrajectoryModified t, final double fps) {
>         if (t.size() == 1) {
>             return null;
>         }
>         final ArrayList<Double> xDataList = new ArrayList<Double>();
>         final ArrayList<Double> yDataList = new ArrayList<Double>();
>         double msdhelp = 0.0;
>         if (this.lagMin == this.lagMax) {
>             xDataList.add(0.0);
>             yDataList.add(0.0);
>         }
>         this.msdevaluator.setTrajectory(t);
>         this.msdevaluator.setTimelag(this.lagMin);
>         for (int i = this.lagMin; i < this.lagMax + 1; ++i) {
50,56c53,57
<             ydata = this.msdevaluator.evaluate();
<             msdhelp = ydata[0];
<             int N = (int)ydata[2];
< 
<             for(int j = 0; j < N; ++j) {
<                xDataList.add((double)i * 1.0D / fps);
<                yDataList.add(msdhelp);
---
>             final double[] res = this.msdevaluator.evaluate();
>             msdhelp = res[0];
>             for (int N = (int)res[2], j = 0; j < N; ++j) {
>                 xDataList.add(i * 1.0 / fps);
>                 yDataList.add(msdhelp);
58,93c59,94
<          }
< 
<          double[] xdata = ArrayUtils.toPrimitive((Double[])xDataList.toArray(new Double[0]));
<          ydata = ArrayUtils.toPrimitive((Double[])yDataList.toArray(new Double[0]));
<          StraightLineFitModified fdf = new StraightLineFitModified();
<          fdf.doFit(xdata, ydata);
<          this.result = new double[]{fdf.getB() / (2.0D * (double)t.getDimension()), fdf.getB() * 2.0D * (double)t.getDimension(), fdf.getA(), fdf.getGoodness()};
<          return this.result;
<       }
<    }
< 
<    public void setTimelags(int lagMin, int lagMax) {
<       this.lagMin = lagMin;
<       this.lagMax = lagMax;
<    }
< 
<    public void setMeanSquaredDisplacementEvaluator(AbstractMeanSquaredDisplacmentEvaluatorModified msdeval) {
<       this.msdevaluator = msdeval;
<    }
< 
<    public double[] evaluate() {
<       this.result = this.getDiffusionCoefficient(this.t, this.fps);
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Diffusion coefficient (Regression)";
<    }
< 
<    public String getShortName() {
<       return "DC-REG";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<    }
---
>         }
>         final double[] xdata = ArrayUtils.toPrimitive((Double[])xDataList.<Double>toArray(new Double[0]));
>         final double[] ydata = ArrayUtils.toPrimitive((Double[])yDataList.<Double>toArray(new Double[0]));
>         final StraightLineFitModified fdf = new StraightLineFitModified();
>         fdf.doFit(xdata, ydata);
>         return this.result = new double[] { fdf.getB() / (2.0 * t.getDimension()), fdf.getB() * 2.0 * t.getDimension(), fdf.getA(), fdf.getGoodness() };
>     }
>     
>     public void setTimelags(final int lagMin, final int lagMax) {
>         this.lagMin = lagMin;
>         this.lagMax = lagMax;
>     }
>     
>     public void setMeanSquaredDisplacementEvaluator(final AbstractMeanSquaredDisplacmentEvaluatorModified msdeval) {
>         this.msdevaluator = msdeval;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         return this.result = this.getDiffusionCoefficient(this.t, this.fps);
>     }
>     
>     @Override
>     public String getName() {
>         return "Diffusion coefficient (Regression)";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "DC-REG";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>     }
diff -r TrackAnalyzer_/DirectoryListener.java procyon/DirectoryListener.java
2c2,3
< import java.awt.TextField;
---
> import javax.swing.JFileChooser;
> import java.io.File;
3a5
> import java.awt.TextField;
5,34d6
< import java.io.File;
< import javax.swing.JFileChooser;
< 
< public class DirectoryListener implements ActionListener {
<    String title;
<    TextField text;
<    int fileSelectionMode;
< 
<    public DirectoryListener(String title, TextField text) {
<       this(title, text, 1);
<    }
< 
<    public DirectoryListener(String title, TextField text, int fileSelectionMode) {
<       this.title = title;
<       this.text = text;
<       this.fileSelectionMode = fileSelectionMode;
<    }
< 
<    public void actionPerformed(ActionEvent e) {
<       File directory;
<       for(directory = new File(this.text.getText()); directory != null && !directory.exists(); directory = directory.getParentFile()) {
<       }
< 
<       JFileChooser fc = new JFileChooser(directory);
<       fc.setFileSelectionMode(this.fileSelectionMode);
<       fc.showOpenDialog((Component)null);
<       File selFile = fc.getSelectedFile();
<       if (selFile != null) {
<          this.text.setText(selFile.getAbsolutePath());
<       }
36c8,39
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class DirectoryListener implements ActionListener
> {
>     String title;
>     TextField text;
>     int fileSelectionMode;
>     
>     public DirectoryListener(final String title, final TextField text) {
>         this(title, text, 1);
>     }
>     
>     public DirectoryListener(final String title, final TextField text, final int fileSelectionMode) {
>         this.title = title;
>         this.text = text;
>         this.fileSelectionMode = fileSelectionMode;
>     }
>     
>     @Override
>     public void actionPerformed(final ActionEvent e) {
>         File directory;
>         for (directory = new File(this.text.getText()); directory != null && !directory.exists(); directory = directory.getParentFile()) {}
>         final JFileChooser fc = new JFileChooser(directory);
>         fc.setFileSelectionMode(this.fileSelectionMode);
>         fc.showOpenDialog(null);
>         final File selFile = fc.getSelectedFile();
>         if (selFile != null) {
>             this.text.setText(selFile.getAbsolutePath());
>         }
>     }
diff -r TrackAnalyzer_/drift/StaticDriftCalculatorModified.java procyon/drift/StaticDriftCalculatorModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
2a7,8
> import vecmath.Point3dModified;
> import traJ.TrajectoryValidIndexTimelagIteratorModified;
5,25d10
< import traJ.TrajectoryValidIndexTimelagIteratorModified;
< import vecmath.Point3dModified;
< 
< public class StaticDriftCalculatorModified<T extends TrajectoryModified> {
<    public double[] calculateDrift(ArrayList<T> tracks) {
<       double[] result = new double[3];
<       double sumX = 0.0D;
<       double sumY = 0.0D;
<       double sumZ = 0.0D;
<       int N = 0;
< 
<       for(int i = 0; i < tracks.size(); ++i) {
<          T t = (TrajectoryModified)tracks.get(i);
< 
<          for(TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(t, 1); it.hasNext(); ++N) {
<             int j = it.next();
<             sumX += ((Point3dModified)t.get(j + 1)).x - ((Point3dModified)t.get(j)).x;
<             sumY += ((Point3dModified)t.get(j + 1)).y - ((Point3dModified)t.get(j)).y;
<             sumZ += ((Point3dModified)t.get(j + 1)).z - ((Point3dModified)t.get(j)).z;
<          }
<       }
27,31c12,35
<       result[0] = sumX / (double)N;
<       result[1] = sumY / (double)N;
<       result[2] = sumZ / (double)N;
<       return result;
<    }
---
> public class StaticDriftCalculatorModified<T extends TrajectoryModified>
> {
>     public double[] calculateDrift(final ArrayList<T> tracks) {
>         final double[] result = new double[3];
>         double sumX = 0.0;
>         double sumY = 0.0;
>         double sumZ = 0.0;
>         int N = 0;
>         for (int i = 0; i < tracks.size(); ++i) {
>             final T t = tracks.get(i);
>             final TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(t, 1);
>             while (it.hasNext()) {
>                 final int j = it.next();
>                 sumX += t.get(j + 1).x - t.get(j).x;
>                 sumY += t.get(j + 1).y - t.get(j).y;
>                 sumZ += t.get(j + 1).z - t.get(j).z;
>                 ++N;
>             }
>         }
>         result[0] = sumX / N;
>         result[1] = sumY / N;
>         result[2] = sumZ / N;
>         return result;
>     }
diff -r TrackAnalyzer_/features/AbstractMeanSquaredDisplacmentEvaluatorModified.java procyon/features/AbstractMeanSquaredDisplacmentEvaluatorModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,10c9,15
< public interface AbstractMeanSquaredDisplacmentEvaluatorModified {
<    void setTimelag(int var1);
< 
<    void setTrajectory(TrajectoryModified var1);
< 
<    double[] evaluate();
---
> public interface AbstractMeanSquaredDisplacmentEvaluatorModified
> {
>     void setTimelag(final int p0);
>     
>     void setTrajectory(final TrajectoryModified p0);
>     
>     double[] evaluate();
diff -r TrackAnalyzer_/features/AbstractTrajectoryFeatureModified.java procyon/features/AbstractTrajectoryFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,22c9,30
< public abstract class AbstractTrajectoryFeatureModified {
<    protected double[] result = null;
< 
<    public abstract double[] evaluate();
< 
<    public double[] getValue() {
<       if (this.result == null) {
<          this.result = this.evaluate();
<       }
< 
<       return this.result;
<    }
< 
<    public abstract String getName();
< 
<    public abstract String getShortName();
< 
<    public abstract void setTrajectory(TrajectoryModified var1);
---
> public abstract class AbstractTrajectoryFeatureModified
> {
>     protected double[] result;
>     
>     public AbstractTrajectoryFeatureModified() {
>         this.result = null;
>     }
>     
>     public abstract double[] evaluate();
>     
>     public double[] getValue() {
>         if (this.result == null) {
>             this.result = this.evaluate();
>         }
>         return this.result;
>     }
>     
>     public abstract String getName();
>     
>     public abstract String getShortName();
>     
>     public abstract void setTrajectory(final TrajectoryModified p0);
diff -r TrackAnalyzer_/features/ActiveTransportParametersFeatureModified.java procyon/features/ActiveTransportParametersFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import java.util.ArrayList;
5a9
> import java.util.ArrayList;
8,54c12,57
< public class ActiveTransportParametersFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private double timelag;
< 
<    public ActiveTransportParametersFeatureModified(TrajectoryModified t, double timelag) {
<       this.t = t;
<       this.timelag = timelag;
<    }
< 
<    public double[] evaluate() {
<       MeanSquaredDisplacmentFeatureModified msdevaluator = new MeanSquaredDisplacmentFeatureModified(this.t, 1);
<       msdevaluator.setTrajectory(this.t);
<       ArrayList<Double> xDataList = new ArrayList();
<       ArrayList<Double> yDataList = new ArrayList();
< 
<       double[] ydata;
<       for(int i = 1; i < this.t.size() / 3; ++i) {
<          msdevaluator.setTimelag(i);
<          ydata = msdevaluator.evaluate();
<          double msdhelp = ydata[0];
<          int N = (int)ydata[2];
< 
<          for(int j = 0; j < N; ++j) {
<             xDataList.add((double)i * this.timelag);
<             yDataList.add(msdhelp);
<          }
<       }
< 
<       double[] xdata = ArrayUtils.toPrimitive((Double[])xDataList.toArray(new Double[0]));
<       ydata = ArrayUtils.toPrimitive((Double[])yDataList.toArray(new Double[0]));
<       ActiveTransportMSDLineFitModified afit = new ActiveTransportMSDLineFitModified();
<       afit.doFit(xdata, ydata);
<       this.result = new double[]{afit.getDiffusionCoefficient(), afit.getVelocity(), afit.getFitGoodness()};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Active transport parameters";
<    }
< 
<    public String getShortName() {
<       return "ACTPARAM";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<    }
---
> public class ActiveTransportParametersFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     private double timelag;
>     
>     public ActiveTransportParametersFeatureModified(final TrajectoryModified t, final double timelag) {
>         this.t = t;
>         this.timelag = timelag;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         final MeanSquaredDisplacmentFeatureModified msdevaluator = new MeanSquaredDisplacmentFeatureModified(this.t, 1);
>         msdevaluator.setTrajectory(this.t);
>         final ArrayList<Double> xDataList = new ArrayList<Double>();
>         final ArrayList<Double> yDataList = new ArrayList<Double>();
>         for (int i = 1; i < this.t.size() / 3; ++i) {
>             msdevaluator.setTimelag(i);
>             final double[] res = msdevaluator.evaluate();
>             final double msdhelp = res[0];
>             for (int N = (int)res[2], j = 0; j < N; ++j) {
>                 xDataList.add(i * this.timelag);
>                 yDataList.add(msdhelp);
>             }
>         }
>         final double[] xdata = ArrayUtils.toPrimitive((Double[])xDataList.<Double>toArray(new Double[0]));
>         final double[] ydata = ArrayUtils.toPrimitive((Double[])yDataList.<Double>toArray(new Double[0]));
>         final ActiveTransportMSDLineFitModified afit = new ActiveTransportMSDLineFitModified();
>         afit.doFit(xdata, ydata);
>         return this.result = new double[] { afit.getDiffusionCoefficient(), afit.getVelocity(), afit.getFitGoodness() };
>     }
>     
>     @Override
>     public String getName() {
>         return "Active transport parameters";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "ACTPARAM";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>     }
diff -r TrackAnalyzer_/features/Asymmetry3FeatureModified.java procyon/features/Asymmetry3FeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import math.RadiusGyrationTensor2DModified;
4a8
> import org.apache.commons.math3.linear.RealMatrix;
5a10
> import math.RadiusGyrationTensor2DModified;
8,36c13,45
< public class Asymmetry3FeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public Asymmetry3FeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       Array2DRowRealMatrix gyr = RadiusGyrationTensor2DModified.getRadiusOfGyrationTensor(this.t);
<       EigenDecomposition eigdec = new EigenDecomposition(gyr);
<       double e1 = eigdec.getRealEigenvalue(0);
<       double e2 = eigdec.getRealEigenvalue(1);
<       double asym = -1.0D * Math.log(1.0D - Math.pow(e1 - e2, 2.0D) / (2.0D * Math.pow(e1 + e2, 2.0D)));
<       this.result = new double[]{asym};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Assymetry3";
<    }
< 
<    public String getShortName() {
<       return "ASYM3";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
> public class Asymmetry3FeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     
>     public Asymmetry3FeatureModified(final TrajectoryModified t) {
>         this.t = t;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         final Array2DRowRealMatrix gyr = RadiusGyrationTensor2DModified.getRadiusOfGyrationTensor(this.t);
>         final EigenDecomposition eigdec = new EigenDecomposition((RealMatrix)gyr);
>         final double e1 = eigdec.getRealEigenvalue(0);
>         final double e2 = eigdec.getRealEigenvalue(1);
>         final double asym = -1.0 * Math.log(1.0 - Math.pow(e1 - e2, 2.0) / (2.0 * Math.pow(e1 + e2, 2.0)));
>         return this.result = new double[] { asym };
>     }
>     
>     @Override
>     public String getName() {
>         return "Assymetry3";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "ASYM3";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/features/CenterOfGravityFeatureModified.java procyon/features/CenterOfGravityFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import traJ.TrajectoryModified;
4a8
> import traJ.TrajectoryModified;
6,42c10,48
< public class CenterOfGravityFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public CenterOfGravityFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       double x = 0.0D;
<       double y = 0.0D;
<       double z = 0.0D;
< 
<       for(int i = 0; i < this.t.size(); ++i) {
<          x += ((Point3dModified)this.t.get(i)).x;
<          y += ((Point3dModified)this.t.get(i)).y;
<          z += ((Point3dModified)this.t.get(i)).z;
<       }
< 
<       x /= (double)this.t.size();
<       y /= (double)this.t.size();
<       z /= (double)this.t.size();
<       this.result = new double[]{x, y, z};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Center of gravity";
<    }
< 
<    public String getShortName() {
<       return "COG";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
> public class CenterOfGravityFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     
>     public CenterOfGravityFeatureModified(final TrajectoryModified t) {
>         this.t = t;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         double x = 0.0;
>         double y = 0.0;
>         double z = 0.0;
>         for (int i = 0; i < this.t.size(); ++i) {
>             x += this.t.get(i).x;
>             y += this.t.get(i).y;
>             z += this.t.get(i).z;
>         }
>         x /= this.t.size();
>         y /= this.t.size();
>         z /= this.t.size();
>         return this.result = new double[] { x, y, z };
>     }
>     
>     @Override
>     public String getName() {
>         return "Center of gravity";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "COG";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/features/ConfinedDiffusionParametersFeatureModified.java procyon/features/ConfinedDiffusionParametersFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,5d6
< import DiffusionCoefficientEstimator.AbstractDiffusionCoefficientEstimatorModified;
< import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
< import java.util.ArrayList;
7a9,11
> import java.util.ArrayList;
> import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
> import DiffusionCoefficientEstimator.AbstractDiffusionCoefficientEstimatorModified;
10,78c14,82
< public class ConfinedDiffusionParametersFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private double timelag;
<    private AbstractDiffusionCoefficientEstimatorModified dcEst;
<    private boolean useReducedModel;
< 
<    public ConfinedDiffusionParametersFeatureModified(TrajectoryModified t, double timelag, boolean useReducedModel) {
<       this.t = t;
<       this.timelag = timelag;
<       this.dcEst = new RegressionDiffusionCoefficientEstimatorModified((TrajectoryModified)null, 1.0D / timelag, 1, 2);
<       this.useReducedModel = useReducedModel;
<    }
< 
<    public ConfinedDiffusionParametersFeatureModified(TrajectoryModified t, double timelag, boolean useReducedModel, AbstractDiffusionCoefficientEstimatorModified dcEst) {
<       this.t = t;
<       this.timelag = timelag;
<       this.dcEst = dcEst;
<       this.useReducedModel = useReducedModel;
<    }
< 
<    public double[] evaluate() {
<       MeanSquaredDisplacmentFeatureModified msd = new MeanSquaredDisplacmentFeatureModified(this.t, 1);
<       msd.setOverlap(false);
<       ArrayList<Double> xDataList = new ArrayList();
<       ArrayList<Double> yDataList = new ArrayList();
< 
<       double[] yData;
<       for(int i = 1; i < this.t.size() / 3; ++i) {
<          msd.setTimelag(i);
<          yData = msd.evaluate();
<          double msdvalue = yData[0];
<          int N = (int)yData[2];
< 
<          for(int j = 0; j < N; ++j) {
<             xDataList.add((double)i * this.timelag);
<             yDataList.add(msdvalue);
<          }
<       }
< 
<       double[] xData = ArrayUtils.toPrimitive((Double[])xDataList.toArray(new Double[0]));
<       yData = ArrayUtils.toPrimitive((Double[])yDataList.toArray(new Double[0]));
<       MaxDistanceBetweenTwoPositionsFeatureModified maxdist = new MaxDistanceBetweenTwoPositionsFeatureModified(this.t);
<       double estdia = maxdist.evaluate()[0];
<       double estDC = this.dcEst.getDiffusionCoefficient(this.t, 1.0D / this.timelag)[0];
<       double[] initialParams = new double[]{estdia * estdia, 0.0D, 0.0D, estDC};
<       ConfinedDiffusionMSDCurveFitModified cmsdfit = new ConfinedDiffusionMSDCurveFitModified();
<       cmsdfit.setInitParameters(initialParams);
<       cmsdfit.doFit(xData, yData, this.useReducedModel);
<       if (this.useReducedModel) {
<          this.result = new double[]{cmsdfit.getA(), cmsdfit.getD(), cmsdfit.getGoodness()};
<       } else {
<          this.result = new double[]{cmsdfit.getA(), cmsdfit.getD(), cmsdfit.getB(), cmsdfit.getC(), cmsdfit.getGoodness()};
<       }
< 
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Confinement Parameters";
<    }
< 
<    public String getShortName() {
<       return "CONFPARAM";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
> public class ConfinedDiffusionParametersFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     private double timelag;
>     private AbstractDiffusionCoefficientEstimatorModified dcEst;
>     private boolean useReducedModel;
>     
>     public ConfinedDiffusionParametersFeatureModified(final TrajectoryModified t, final double timelag, final boolean useReducedModel) {
>         this.t = t;
>         this.timelag = timelag;
>         this.dcEst = new RegressionDiffusionCoefficientEstimatorModified(null, 1.0 / timelag, 1, 2);
>         this.useReducedModel = useReducedModel;
>     }
>     
>     public ConfinedDiffusionParametersFeatureModified(final TrajectoryModified t, final double timelag, final boolean useReducedModel, final AbstractDiffusionCoefficientEstimatorModified dcEst) {
>         this.t = t;
>         this.timelag = timelag;
>         this.dcEst = dcEst;
>         this.useReducedModel = useReducedModel;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         final MeanSquaredDisplacmentFeatureModified msd = new MeanSquaredDisplacmentFeatureModified(this.t, 1);
>         msd.setOverlap(false);
>         final ArrayList<Double> xDataList = new ArrayList<Double>();
>         final ArrayList<Double> yDataList = new ArrayList<Double>();
>         for (int i = 1; i < this.t.size() / 3; ++i) {
>             msd.setTimelag(i);
>             final double[] res = msd.evaluate();
>             final double msdvalue = res[0];
>             for (int N = (int)res[2], j = 0; j < N; ++j) {
>                 xDataList.add(i * this.timelag);
>                 yDataList.add(msdvalue);
>             }
>         }
>         final double[] xData = ArrayUtils.toPrimitive((Double[])xDataList.<Double>toArray(new Double[0]));
>         final double[] yData = ArrayUtils.toPrimitive((Double[])yDataList.<Double>toArray(new Double[0]));
>         final MaxDistanceBetweenTwoPositionsFeatureModified maxdist = new MaxDistanceBetweenTwoPositionsFeatureModified(this.t);
>         final double estdia = maxdist.evaluate()[0];
>         final double estDC = this.dcEst.getDiffusionCoefficient(this.t, 1.0 / this.timelag)[0];
>         final double[] initialParams = { estdia * estdia, 0.0, 0.0, estDC };
>         final ConfinedDiffusionMSDCurveFitModified cmsdfit = new ConfinedDiffusionMSDCurveFitModified();
>         cmsdfit.setInitParameters(initialParams);
>         cmsdfit.doFit(xData, yData, this.useReducedModel);
>         if (this.useReducedModel) {
>             this.result = new double[] { cmsdfit.getA(), cmsdfit.getD(), cmsdfit.getGoodness() };
>         }
>         else {
>             this.result = new double[] { cmsdfit.getA(), cmsdfit.getD(), cmsdfit.getB(), cmsdfit.getC(), cmsdfit.getGoodness() };
>         }
>         return this.result;
>     }
>     
>     @Override
>     public String getName() {
>         return "Confinement Parameters";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "CONFPARAM";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/features/EfficiencyFeatureModified.java procyon/features/EfficiencyFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import traJ.TrajectoryModified;
4a8
> import traJ.TrajectoryModified;
6,46c10,51
< public class EfficiencyFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public EfficiencyFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       this.result = new double[]{this.getEfficiency()};
<       return this.result;
<    }
< 
<    public double getEfficiency() {
<       double sum = 0.0D;
< 
<       for(int i = 1; i < this.t.size(); ++i) {
<          double d = ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(i - 1));
<          sum += d * d;
<       }
< 
<       if (sum < Math.pow(10.0D, -10.0D)) {
<          return 0.0D;
<       } else {
<          double d = ((Point3dModified)this.t.get(0)).distance((Point3dModified)this.t.get(this.t.size() - 1));
<          double eff = d * d / ((double)this.t.size() * sum);
<          return eff;
<       }
<    }
< 
<    public String getName() {
<       return "Efficiency";
<    }
< 
<    public String getShortName() {
<       return "EFFICENCY";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
> public class EfficiencyFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     
>     public EfficiencyFeatureModified(final TrajectoryModified t) {
>         this.t = t;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         return this.result = new double[] { this.getEfficiency() };
>     }
>     
>     public double getEfficiency() {
>         double sum = 0.0;
>         for (int i = 1; i < this.t.size(); ++i) {
>             final double d = this.t.get(i).distance(this.t.get(i - 1));
>             sum += d * d;
>         }
>         if (sum < Math.pow(10.0, -10.0)) {
>             return 0.0;
>         }
>         final double d2 = this.t.get(0).distance(this.t.get(this.t.size() - 1));
>         final double eff = d2 * d2 / (this.t.size() * sum);
>         return eff;
>     }
>     
>     @Override
>     public String getName() {
>         return "Efficiency";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "EFFICENCY";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/features/FractalDimensionFeatureModified.java procyon/features/FractalDimensionFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import traJ.TrajectoryModified;
4a8
> import traJ.TrajectoryModified;
6,25c10,30
< public class FractalDimensionFeatureModified extends AbstractTrajectoryFeatureModified {
<    TrajectoryModified t;
< 
<    public FractalDimensionFeatureModified(TrajectoryModified t) {
<       this.t = t;
<       if (t.getDimension() != 2) {
<          throw new IllegalArgumentException("The fractal dimension feature only supoorts planer (2D) trajetorys");
<       }
<    }
< 
<    public double[] evaluate() {
<       double largestDistance = Double.MIN_VALUE;
<       double totalLength = 0.0D;
< 
<       double d;
<       for(int i = 0; i < this.t.size(); ++i) {
<          for(int j = i + 1; j < this.t.size(); ++j) {
<             d = ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(j));
<             if (d > largestDistance) {
<                largestDistance = d;
---
> public class FractalDimensionFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     TrajectoryModified t;
>     
>     public FractalDimensionFeatureModified(final TrajectoryModified t) {
>         this.t = t;
>         if (t.getDimension() != 2) {
>             throw new IllegalArgumentException("The fractal dimension feature only supoorts planer (2D) trajetorys");
>         }
>     }
>     
>     @Override
>     public double[] evaluate() {
>         double largestDistance = Double.MIN_VALUE;
>         double totalLength = 0.0;
>         for (int i = 0; i < this.t.size(); ++i) {
>             for (int j = i + 1; j < this.t.size(); ++j) {
>                 final double d = this.t.get(i).distance(this.t.get(j));
>                 if (d > largestDistance) {
>                     largestDistance = d;
>                 }
27,54c32,58
<          }
< 
<          if (i > 0) {
<             totalLength += ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(i - 1));
<          }
<       }
< 
<       double n = (double)(this.t.size() - 1);
<       d = Math.log(n) / (Math.log(n) + Math.log(largestDistance / totalLength));
<       this.result = new double[]{d};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Fractal Dimension";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<       if (t.getDimension() != 2) {
<          throw new IllegalArgumentException("The fractal dimension feature only supoorts planer (2D) trajetorys");
<       }
<    }
< 
<    public String getShortName() {
<       return "FD";
<    }
---
>             if (i > 0) {
>                 totalLength += this.t.get(i).distance(this.t.get(i - 1));
>             }
>         }
>         final double n = this.t.size() - 1;
>         final double fractalDImension = Math.log(n) / (Math.log(n) + Math.log(largestDistance / totalLength));
>         return this.result = new double[] { fractalDImension };
>     }
>     
>     @Override
>     public String getName() {
>         return "Fractal Dimension";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>         if (t.getDimension() != 2) {
>             throw new IllegalArgumentException("The fractal dimension feature only supoorts planer (2D) trajetorys");
>         }
>     }
>     
>     @Override
>     public String getShortName() {
>         return "FD";
>     }
diff -r TrackAnalyzer_/features/GaussianityFeautureModified.java procyon/features/GaussianityFeautureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,37c9,47
< public class GaussianityFeautureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private int timelag;
<    private String name = "Gaussianity";
<    private String sname = "GAUSS";
< 
<    public GaussianityFeautureModified(TrajectoryModified t, int timelag) {
<       this.t = t;
<       this.timelag = timelag;
<    }
< 
<    public double[] evaluate() {
<       MeanSquaredDisplacmentFeatureModified msdf = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag);
<       QuartricMomentFeatureModified qart = new QuartricMomentFeatureModified(this.t, this.timelag);
<       double msd = msdf.evaluate()[0];
<       double q = qart.evaluate()[0];
<       double res = 2.0D * q / (3.0D * msd * msd) - 1.0D;
<       this.result = new double[]{res};
<       return this.result;
<    }
< 
<    public String getName() {
<       return this.name;
<    }
< 
<    public String getShortName() {
<       return this.sname;
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
> public class GaussianityFeautureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     private int timelag;
>     private String name;
>     private String sname;
>     
>     public GaussianityFeautureModified(final TrajectoryModified t, final int timelag) {
>         this.name = "Gaussianity";
>         this.sname = "GAUSS";
>         this.t = t;
>         this.timelag = timelag;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         final MeanSquaredDisplacmentFeatureModified msdf = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag);
>         final QuartricMomentFeatureModified qart = new QuartricMomentFeatureModified(this.t, this.timelag);
>         final double msd = msdf.evaluate()[0];
>         final double q = qart.evaluate()[0];
>         final double res = 2.0 * q / (3.0 * msd * msd) - 1.0;
>         return this.result = new double[] { res };
>     }
>     
>     @Override
>     public String getName() {
>         return this.name;
>     }
>     
>     @Override
>     public String getShortName() {
>         return this.sname;
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/features/KurtosisFeatureModified.java procyon/features/KurtosisFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
6,30c10,38
< public class KurtosisFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public KurtosisFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       MomentsCalculatorModified moments = new MomentsCalculatorModified(this.t);
<       this.result = new double[]{moments.calculateNthMoment(4)};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Kurtosis";
<    }
< 
<    public String getShortName() {
<       return "KURT";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
> public class KurtosisFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     
>     public KurtosisFeatureModified(final TrajectoryModified t) {
>         this.t = t;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         final MomentsCalculatorModified moments = new MomentsCalculatorModified(this.t);
>         return this.result = new double[] { moments.calculateNthMoment(4) };
>     }
>     
>     @Override
>     public String getName() {
>         return "Kurtosis";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "KURT";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/features/MaxDistanceBetweenTwoPositionsFeatureModified.java procyon/features/MaxDistanceBetweenTwoPositionsFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import traJ.TrajectoryModified;
4a8
> import traJ.TrajectoryModified;
6,20c10,26
< public class MaxDistanceBetweenTwoPositionsFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public MaxDistanceBetweenTwoPositionsFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       double maxDistance = Double.MIN_VALUE;
< 
<       for(int i = 0; i < this.t.size(); ++i) {
<          for(int j = i + 1; j < this.t.size(); ++j) {
<             double d = ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(j));
<             if (d > maxDistance) {
<                maxDistance = d;
---
> public class MaxDistanceBetweenTwoPositionsFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     
>     public MaxDistanceBetweenTwoPositionsFeatureModified(final TrajectoryModified t) {
>         this.t = t;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         double maxDistance = Double.MIN_VALUE;
>         for (int i = 0; i < this.t.size(); ++i) {
>             for (int j = i + 1; j < this.t.size(); ++j) {
>                 final double d = this.t.get(i).distance(this.t.get(j));
>                 if (d > maxDistance) {
>                     maxDistance = d;
>                 }
22,40c28,46
<          }
<       }
< 
<       this.result = new double[]{maxDistance};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Maximum distance between two positions";
<    }
< 
<    public String getShortName() {
<       return "MAX-DIST-POS";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
>         }
>         return this.result = new double[] { maxDistance };
>     }
>     
>     @Override
>     public String getName() {
>         return "Maximum distance between two positions";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "MAX-DIST-POS";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/features/MeanSpeedFeatureModified.java procyon/features/MeanSpeedFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import traJ.TrajectoryModified;
4a8
> import traJ.TrajectoryModified;
6,40c10,46
< public class MeanSpeedFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private double timelag;
< 
<    public MeanSpeedFeatureModified(TrajectoryModified t, double timelag) {
<       this.t = t;
<       this.timelag = timelag;
<    }
< 
<    public double[] evaluate() {
<       double sum = 0.0D;
< 
<       for(int i = 1; i < this.t.size(); ++i) {
<          sum += ((Point3dModified)this.t.get(i - 1)).distance((Point3dModified)this.t.get(i)) / this.timelag;
<       }
< 
<       double meanspeed = sum / (double)(this.t.size() - 1);
<       double netDistance = ((Point3dModified)this.t.get(0)).distance((Point3dModified)this.t.get(this.t.size() - 1));
<       double straightLineSpeed = netDistance / ((double)(this.t.size() - 1) * this.timelag);
<       this.result = new double[]{meanspeed, straightLineSpeed};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Mean Speed Feature";
<    }
< 
<    public String getShortName() {
<       return "MEANSPEED";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
> public class MeanSpeedFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     private double timelag;
>     
>     public MeanSpeedFeatureModified(final TrajectoryModified t, final double timelag) {
>         this.t = t;
>         this.timelag = timelag;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         double sum = 0.0;
>         for (int i = 1; i < this.t.size(); ++i) {
>             sum += this.t.get(i - 1).distance(this.t.get(i)) / this.timelag;
>         }
>         final double meanspeed = sum / (this.t.size() - 1);
>         final double netDistance = this.t.get(0).distance(this.t.get(this.t.size() - 1));
>         final double straightLineSpeed = netDistance / ((this.t.size() - 1) * this.timelag);
>         return this.result = new double[] { meanspeed, straightLineSpeed };
>     }
>     
>     @Override
>     public String getName() {
>         return "Mean Speed Feature";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "MEANSPEED";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/features/MeanSquaredDisplacmentFeatureModified.java procyon/features/MeanSquaredDisplacmentFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,4d6
< import traJ.TrajectoryModified;
< import traJ.TrajectoryValidIndexTimelagIteratorModified;
5a8,9
> import traJ.TrajectoryValidIndexTimelagIteratorModified;
> import traJ.TrajectoryModified;
7,71c11,80
< public class MeanSquaredDisplacmentFeatureModified extends AbstractTrajectoryFeatureModified implements AbstractMeanSquaredDisplacmentEvaluatorModified {
<    private TrajectoryModified t;
<    private int timelag;
<    private boolean overlap = false;
< 
<    public MeanSquaredDisplacmentFeatureModified(TrajectoryModified t, int timelag) {
<       this.t = t;
<       this.timelag = timelag;
<    }
< 
<    public void setTimelag(int timelag) {
<       this.timelag = timelag;
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< 
<    private double[] getMeanSquaredDisplacment(TrajectoryModified t, int timelag) {
<       double msd = 0.0D;
<       double[] result = new double[3];
<       if (t.size() == 1) {
<          result[0] = 0.0D;
<          result[1] = 0.0D;
<          result[2] = 1.0D;
<          return result;
<       } else if (timelag < 1) {
<          throw new IllegalArgumentException("Timelag can not be smaller than 1");
<       } else {
<          TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(t, timelag, this.overlap);
< 
<          int N;
<          for(N = 0; it.hasNext(); ++N) {
<             int i = it.next();
<             msd = msd + Math.pow(((Point3dModified)t.get(i)).x - ((Point3dModified)t.get(i + timelag)).x, 2.0D) + Math.pow(((Point3dModified)t.get(i)).y - ((Point3dModified)t.get(i + timelag)).y, 2.0D) + Math.pow(((Point3dModified)t.get(i)).z - ((Point3dModified)t.get(i + timelag)).z, 2.0D);
<          }
< 
<          msd /= (double)N;
<          result[0] = msd;
<          result[1] = (double)timelag * ((double)(2 * timelag * timelag) + 1.0D) / ((double)(N - timelag) + 1.0D);
<          result[2] = (double)N;
<          return result;
<       }
<    }
< 
<    public double[] evaluate() {
<       return this.getMeanSquaredDisplacment(this.t, this.timelag);
<    }
< 
<    public double getRelativeVariance() {
<       return this.getMeanSquaredDisplacment(this.t, this.timelag)[1];
<    }
< 
<    public String getName() {
<       return "Mean squared displacement-dt-" + this.timelag;
<    }
< 
<    public String getShortName() {
<       return "MSD";
<    }
< 
<    public void setOverlap(boolean overlap) {
<       this.overlap = overlap;
<    }
---
> public class MeanSquaredDisplacmentFeatureModified extends AbstractTrajectoryFeatureModified implements AbstractMeanSquaredDisplacmentEvaluatorModified
> {
>     private TrajectoryModified t;
>     private int timelag;
>     private boolean overlap;
>     
>     public MeanSquaredDisplacmentFeatureModified(final TrajectoryModified t, final int timelag) {
>         this.overlap = false;
>         this.t = t;
>         this.timelag = timelag;
>     }
>     
>     @Override
>     public void setTimelag(final int timelag) {
>         this.timelag = timelag;
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
>     
>     private double[] getMeanSquaredDisplacment(final TrajectoryModified t, final int timelag) {
>         double msd = 0.0;
>         final double[] result = new double[3];
>         if (t.size() == 1) {
>             result[1] = (result[0] = 0.0);
>             result[2] = 1.0;
>             return result;
>         }
>         if (timelag < 1) {
>             throw new IllegalArgumentException("Timelag can not be smaller than 1");
>         }
>         final TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(t, timelag, this.overlap);
>         int N = 0;
>         while (it.hasNext()) {
>             final int i = it.next();
>             msd = msd + Math.pow(t.get(i).x - t.get(i + timelag).x, 2.0) + Math.pow(t.get(i).y - t.get(i + timelag).y, 2.0) + Math.pow(t.get(i).z - t.get(i + timelag).z, 2.0);
>             ++N;
>         }
>         msd /= N;
>         result[0] = msd;
>         result[1] = timelag * (2 * timelag * timelag + 1.0) / (N - timelag + 1.0);
>         result[2] = N;
>         return result;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         return this.getMeanSquaredDisplacment(this.t, this.timelag);
>     }
>     
>     public double getRelativeVariance() {
>         return this.getMeanSquaredDisplacment(this.t, this.timelag)[1];
>     }
>     
>     @Override
>     public String getName() {
>         return "Mean squared displacement-dt-" + this.timelag;
>     }
>     
>     @Override
>     public String getShortName() {
>         return "MSD";
>     }
>     
>     public void setOverlap(final boolean overlap) {
>         this.overlap = overlap;
>     }
diff -r TrackAnalyzer_/features/MSDRatioFeatureModified.java procyon/features/MSDRatioFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,37c9,45
< public class MSDRatioFeatureModified extends AbstractTrajectoryFeatureModified {
<    private int timelag1;
<    private int timelag2;
<    private TrajectoryModified t;
< 
<    public MSDRatioFeatureModified(TrajectoryModified t, int timelag1, int timelag2) {
<       this.t = t;
<       this.timelag1 = timelag1;
<       this.timelag2 = timelag2;
<    }
< 
<    public double[] evaluate() {
<       MeanSquaredDisplacmentFeatureModified msdf1 = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag1);
<       MeanSquaredDisplacmentFeatureModified msdf2 = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag2);
<       double msd1 = msdf1.evaluate()[0];
<       double msd2 = msdf2.evaluate()[0];
<       double res = msd1 / msd2 - 1.0D * (double)this.timelag1 / (double)this.timelag2;
<       this.result = new double[]{res};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Mean squared displacment ratio";
<    }
< 
<    public String getShortName() {
<       return "MSDR";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
> public class MSDRatioFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private int timelag1;
>     private int timelag2;
>     private TrajectoryModified t;
>     
>     public MSDRatioFeatureModified(final TrajectoryModified t, final int timelag1, final int timelag2) {
>         this.t = t;
>         this.timelag1 = timelag1;
>         this.timelag2 = timelag2;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         final MeanSquaredDisplacmentFeatureModified msdf1 = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag1);
>         final MeanSquaredDisplacmentFeatureModified msdf2 = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag2);
>         final double msd1 = msdf1.evaluate()[0];
>         final double msd2 = msdf2.evaluate()[0];
>         final double res = msd1 / msd2 - 1.0 * this.timelag1 / this.timelag2;
>         return this.result = new double[] { res };
>     }
>     
>     @Override
>     public String getName() {
>         return "Mean squared displacment ratio";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "MSDR";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/features/PowerLawFeatureModified.java procyon/features/PowerLawFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import java.util.ArrayList;
5a9
> import java.util.ArrayList;
8,105c12,108
< public class PowerLawFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private int minlag;
<    private int maxlag;
<    private AbstractMeanSquaredDisplacmentEvaluatorModified msdeval;
<    private int evaluateIndex = 0;
<    private boolean useInitialGuess;
<    private double initalDiffusionCoefficient;
<    private double initalAlpha;
<    private double fps;
<    private double timelag;
< 
<    public PowerLawFeatureModified(TrajectoryModified t, double fps, int minlag, int maxlag) {
<       this.t = t;
<       this.minlag = minlag;
<       this.maxlag = maxlag;
<       this.fps = fps;
<       this.timelag = 1.0D / fps;
<       this.msdeval = new MeanSquaredDisplacmentFeatureModified((TrajectoryModified)null, 0);
<       ((MeanSquaredDisplacmentFeatureModified)this.msdeval).setOverlap(false);
<       this.evaluateIndex = 0;
<       this.useInitialGuess = false;
<    }
< 
<    public PowerLawFeatureModified(TrajectoryModified t, double fps, int minlag, int maxlag, double initalAlpha, double initialDiffusionCoefficient) {
<       this.t = t;
<       this.minlag = minlag;
<       this.maxlag = maxlag;
<       this.fps = fps;
<       this.timelag = 1.0D / fps;
<       this.msdeval = new MeanSquaredDisplacmentFeatureModified((TrajectoryModified)null, 0);
<       ((MeanSquaredDisplacmentFeatureModified)this.msdeval).setOverlap(false);
<       this.evaluateIndex = 0;
<       this.useInitialGuess = true;
<       this.initalAlpha = initalAlpha;
<       this.initalDiffusionCoefficient = initialDiffusionCoefficient;
<    }
< 
<    public double[] evaluate() {
<       ArrayList<Double> xDataList = new ArrayList();
<       ArrayList<Double> yDataList = new ArrayList();
<       this.msdeval.setTrajectory(this.t);
<       double[][] data = new double[this.maxlag - this.minlag + 1][3];
< 
<       int i;
<       double[] yData;
<       for(i = this.minlag; i <= this.maxlag; ++i) {
<          this.msdeval.setTimelag(i);
<          data[i - this.minlag][0] = (double)i * this.timelag;
<          yData = this.msdeval.evaluate();
<          data[i - this.minlag][1] = yData[this.evaluateIndex];
<          data[i - this.minlag][2] = (double)((int)yData[2]);
<       }
< 
<       for(i = 0; i < this.maxlag - this.minlag + 1; ++i) {
<          double x = data[i][0];
<          double y = data[i][1];
<          int np = (int)data[i][2];
< 
<          for(int j = 0; j < np; ++j) {
<             xDataList.add(x);
<             yDataList.add(y);
<          }
<       }
< 
<       double[] xData = ArrayUtils.toPrimitive((Double[])xDataList.toArray(new Double[0]));
<       yData = ArrayUtils.toPrimitive((Double[])yDataList.toArray(new Double[0]));
<       PowerLawCurveFitModified pwFit = new PowerLawCurveFitModified();
<       if (this.useInitialGuess) {
<          pwFit.doFit(xData, yData, this.initalAlpha, this.initalDiffusionCoefficient);
<       } else {
<          pwFit.doFit(xData, yData);
<       }
< 
<       this.result = new double[]{pwFit.getAlpha(), pwFit.getDiffusionCoefficient(), pwFit.getGoodness()};
<       return this.result;
<    }
< 
<    public void setEvaluateIndex(int evaluateIndex) {
<       this.evaluateIndex = evaluateIndex;
<    }
< 
<    public void setMeanSquaredDisplacmentEvaluator(AbstractMeanSquaredDisplacmentEvaluatorModified msdeval) {
<       this.msdeval = msdeval;
<    }
< 
<    public String getName() {
<       return "Power-Law-Feature";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< 
<    public String getShortName() {
<       return "POWER";
<    }
---
> public class PowerLawFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     private int minlag;
>     private int maxlag;
>     private AbstractMeanSquaredDisplacmentEvaluatorModified msdeval;
>     private int evaluateIndex;
>     private boolean useInitialGuess;
>     private double initalDiffusionCoefficient;
>     private double initalAlpha;
>     private double fps;
>     private double timelag;
>     
>     public PowerLawFeatureModified(final TrajectoryModified t, final double fps, final int minlag, final int maxlag) {
>         this.evaluateIndex = 0;
>         this.t = t;
>         this.minlag = minlag;
>         this.maxlag = maxlag;
>         this.fps = fps;
>         this.timelag = 1.0 / fps;
>         this.msdeval = new MeanSquaredDisplacmentFeatureModified(null, 0);
>         ((MeanSquaredDisplacmentFeatureModified)this.msdeval).setOverlap(false);
>         this.evaluateIndex = 0;
>         this.useInitialGuess = false;
>     }
>     
>     public PowerLawFeatureModified(final TrajectoryModified t, final double fps, final int minlag, final int maxlag, final double initalAlpha, final double initialDiffusionCoefficient) {
>         this.evaluateIndex = 0;
>         this.t = t;
>         this.minlag = minlag;
>         this.maxlag = maxlag;
>         this.fps = fps;
>         this.timelag = 1.0 / fps;
>         this.msdeval = new MeanSquaredDisplacmentFeatureModified(null, 0);
>         ((MeanSquaredDisplacmentFeatureModified)this.msdeval).setOverlap(false);
>         this.evaluateIndex = 0;
>         this.useInitialGuess = true;
>         this.initalAlpha = initalAlpha;
>         this.initalDiffusionCoefficient = initialDiffusionCoefficient;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         final ArrayList<Double> xDataList = new ArrayList<Double>();
>         final ArrayList<Double> yDataList = new ArrayList<Double>();
>         this.msdeval.setTrajectory(this.t);
>         final double[][] data = new double[this.maxlag - this.minlag + 1][3];
>         for (int i = this.minlag; i <= this.maxlag; ++i) {
>             this.msdeval.setTimelag(i);
>             data[i - this.minlag][0] = i * this.timelag;
>             final double[] res = this.msdeval.evaluate();
>             data[i - this.minlag][1] = res[this.evaluateIndex];
>             data[i - this.minlag][2] = (int)res[2];
>         }
>         for (int i = 0; i < this.maxlag - this.minlag + 1; ++i) {
>             final double x = data[i][0];
>             final double y = data[i][1];
>             for (int np = (int)data[i][2], j = 0; j < np; ++j) {
>                 xDataList.add(x);
>                 yDataList.add(y);
>             }
>         }
>         final double[] xData = ArrayUtils.toPrimitive((Double[])xDataList.<Double>toArray(new Double[0]));
>         final double[] yData = ArrayUtils.toPrimitive((Double[])yDataList.<Double>toArray(new Double[0]));
>         final PowerLawCurveFitModified pwFit = new PowerLawCurveFitModified();
>         if (this.useInitialGuess) {
>             pwFit.doFit(xData, yData, this.initalAlpha, this.initalDiffusionCoefficient);
>         }
>         else {
>             pwFit.doFit(xData, yData);
>         }
>         return this.result = new double[] { pwFit.getAlpha(), pwFit.getDiffusionCoefficient(), pwFit.getGoodness() };
>     }
>     
>     public void setEvaluateIndex(final int evaluateIndex) {
>         this.evaluateIndex = evaluateIndex;
>     }
>     
>     public void setMeanSquaredDisplacmentEvaluator(final AbstractMeanSquaredDisplacmentEvaluatorModified msdeval) {
>         this.msdeval = msdeval;
>     }
>     
>     @Override
>     public String getName() {
>         return "Power-Law-Feature";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
>     
>     @Override
>     public String getShortName() {
>         return "POWER";
>     }
diff -r TrackAnalyzer_/features/QuartricMomentFeatureModified.java procyon/features/QuartricMomentFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,4d6
< import traJ.TrajectoryModified;
< import traJ.TrajectoryValidIndexTimelagIteratorModified;
5a8,9
> import traJ.TrajectoryValidIndexTimelagIteratorModified;
> import traJ.TrajectoryModified;
7,50c11,58
< public class QuartricMomentFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private int timelag;
<    private String shortname = "QMOMENT";
< 
<    public QuartricMomentFeatureModified(TrajectoryModified t, int timelag) {
<       this.t = t;
<       this.timelag = timelag;
<    }
< 
<    public double[] evaluate() {
<       double sum = 0.0D;
<       TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(this.t, this.timelag);
< 
<       int N;
<       for(N = 0; it.hasNext(); ++N) {
<          int i = it.next();
<          sum = sum + Math.pow(((Point3dModified)this.t.get(i)).x - ((Point3dModified)this.t.get(i + this.timelag)).x, 4.0D) + Math.pow(((Point3dModified)this.t.get(i)).y - ((Point3dModified)this.t.get(i + this.timelag)).y, 4.0D) + Math.pow(((Point3dModified)this.t.get(i)).z - ((Point3dModified)this.t.get(i + this.timelag)).z, 4.0D);
<       }
< 
<       this.result = new double[]{sum / (double)N};
<       return this.result;
<    }
< 
<    public void setTimelag(int timelag) {
<       this.timelag = timelag;
<    }
< 
<    public String getName() {
<       return "Quartric Moment";
<    }
< 
<    public String getShortName() {
<       return this.shortname;
<    }
< 
<    public void setShortName(String name) {
<       this.shortname = name;
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
> public class QuartricMomentFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     private int timelag;
>     private String shortname;
>     
>     public QuartricMomentFeatureModified(final TrajectoryModified t, final int timelag) {
>         this.shortname = "QMOMENT";
>         this.t = t;
>         this.timelag = timelag;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         double sum = 0.0;
>         final TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(this.t, this.timelag);
>         int N = 0;
>         while (it.hasNext()) {
>             final int i = it.next();
>             sum = sum + Math.pow(this.t.get(i).x - this.t.get(i + this.timelag).x, 4.0) + Math.pow(this.t.get(i).y - this.t.get(i + this.timelag).y, 4.0) + Math.pow(this.t.get(i).z - this.t.get(i + this.timelag).z, 4.0);
>             ++N;
>         }
>         return this.result = new double[] { sum / N };
>     }
>     
>     public void setTimelag(final int timelag) {
>         this.timelag = timelag;
>     }
>     
>     @Override
>     public String getName() {
>         return "Quartric Moment";
>     }
>     
>     @Override
>     public String getShortName() {
>         return this.shortname;
>     }
>     
>     public void setShortName(final String name) {
>         this.shortname = name;
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/features/StraightnessFeatureModified.java procyon/features/StraightnessFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import traJ.TrajectoryModified;
4a8
> import traJ.TrajectoryModified;
6,44c10,49
< public class StraightnessFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public StraightnessFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       this.result = new double[]{this.getStraightness()};
<       return this.result;
<    }
< 
<    public double getStraightness() {
<       double sum = 0.0D;
< 
<       for(int i = 1; i < this.t.size(); ++i) {
<          sum += ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(i - 1));
<       }
< 
<       if (sum < Math.pow(10.0D, -10.0D)) {
<          return 0.0D;
<       } else {
<          double straightness = ((Point3dModified)this.t.get(0)).distance((Point3dModified)this.t.get(this.t.size() - 1)) / sum;
<          return straightness;
<       }
<    }
< 
<    public String getName() {
<       return "Straightness";
<    }
< 
<    public String getShortName() {
<       return "STRAIGHTNESS";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
> public class StraightnessFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     
>     public StraightnessFeatureModified(final TrajectoryModified t) {
>         this.t = t;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         return this.result = new double[] { this.getStraightness() };
>     }
>     
>     public double getStraightness() {
>         double sum = 0.0;
>         for (int i = 1; i < this.t.size(); ++i) {
>             sum += this.t.get(i).distance(this.t.get(i - 1));
>         }
>         if (sum < Math.pow(10.0, -10.0)) {
>             return 0.0;
>         }
>         final double straightness = this.t.get(0).distance(this.t.get(this.t.size() - 1)) / sum;
>         return straightness;
>     }
>     
>     @Override
>     public String getName() {
>         return "Straightness";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "STRAIGHTNESS";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/features/TrappedProbabilityFeatureModified.java procyon/features/TrappedProbabilityFeatureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
6,35c10,43
< public class TrappedProbabilityFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public TrappedProbabilityFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       MaxDistanceBetweenTwoPositionsFeatureModified dtwop = new MaxDistanceBetweenTwoPositionsFeatureModified(this.t);
<       double r = dtwop.evaluate()[0] / 2.0D;
<       RegressionDiffusionCoefficientEstimatorModified dcEst = new RegressionDiffusionCoefficientEstimatorModified(this.t, 1.0D, 1, 2);
<       double D = dcEst.evaluate()[0];
<       double time = (double)this.t.size();
<       double p = 1.0D - Math.exp(0.2048D - 2.5117D * (D * time / (r * r)));
<       this.result = new double[]{p};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Trapped trajectory probability";
<    }
< 
<    public String getShortName() {
<       return "TRAPPED";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
---
> public class TrappedProbabilityFeatureModified extends AbstractTrajectoryFeatureModified
> {
>     private TrajectoryModified t;
>     
>     public TrappedProbabilityFeatureModified(final TrajectoryModified t) {
>         this.t = t;
>     }
>     
>     @Override
>     public double[] evaluate() {
>         final MaxDistanceBetweenTwoPositionsFeatureModified dtwop = new MaxDistanceBetweenTwoPositionsFeatureModified(this.t);
>         final double r = dtwop.evaluate()[0] / 2.0;
>         final RegressionDiffusionCoefficientEstimatorModified dcEst = new RegressionDiffusionCoefficientEstimatorModified(this.t, 1.0, 1, 2);
>         final double D = dcEst.evaluate()[0];
>         final double time = this.t.size();
>         final double p = 1.0 - Math.exp(0.2048 - 2.5117 * (D * time / (r * r)));
>         return this.result = new double[] { p };
>     }
>     
>     @Override
>     public String getName() {
>         return "Trapped trajectory probability";
>     }
>     
>     @Override
>     public String getShortName() {
>         return "TRAPPED";
>     }
>     
>     @Override
>     public void setTrajectory(final TrajectoryModified t) {
>         this.t = t;
>         this.result = null;
>     }
diff -r TrackAnalyzer_/FirstWizardPanel.java procyon/FirstWizardPanel.java
1,7d0
< import fiji.plugin.trackmate.Spot;
< import fiji.plugin.trackmate.SpotCollection;
< import ij.IJ;
< import ij.ImagePlus;
< import ij.ImageStack;
< import ij.gui.Roi;
< import ij.io.FileInfo;
9,16c2,3
< import ij.measure.ResultsTable;
< import ij.process.ColorProcessor;
< import java.awt.BasicStroke;
< import java.awt.BorderLayout;
< import java.awt.Color;
< import java.awt.Dimension;
< import java.awt.FlowLayout;
< import java.awt.Font;
---
> import ij.io.FileInfo;
> import java.net.URL;
18,19c5
< import java.awt.Image;
< import java.awt.Rectangle;
---
> import java.awt.image.ImageObserver;
21,22c7,13
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
---
> import javax.swing.table.TableCellRenderer;
> import javax.swing.table.DefaultTableCellRenderer;
> import javax.swing.ListSelectionModel;
> import ij.gui.Roi;
> import fiji.plugin.trackmate.SpotCollection;
> import javax.swing.event.ChangeEvent;
> import javax.swing.event.ChangeListener;
24a16,19
> import java.awt.Rectangle;
> import ij.process.ImageProcessor;
> import java.awt.Image;
> import ij.process.ColorProcessor;
26,27c21
< import java.awt.image.ImageObserver;
< import java.io.File;
---
> import ij.ImageStack;
29c23,25
< import java.net.URL;
---
> import javax.swing.JFileChooser;
> import javax.swing.JFrame;
> import ij.measure.ResultsTable;
31,32c27,37
< import java.util.List;
< import javax.swing.BorderFactory;
---
> import java.awt.event.ActionEvent;
> import java.awt.event.ActionListener;
> import javax.swing.ListModel;
> import java.awt.BorderLayout;
> import java.awt.Stroke;
> import java.awt.Paint;
> import java.awt.BasicStroke;
> import java.awt.Color;
> import javax.swing.JSlider;
> import javax.swing.SpinnerModel;
> import javax.swing.SpinnerNumberModel;
33a39,48
> import java.awt.Font;
> import javax.swing.JSeparator;
> import javax.swing.JToggleButton;
> import java.awt.FlowLayout;
> import javax.swing.JButton;
> import javax.swing.JTabbedPane;
> import javax.swing.border.Border;
> import javax.swing.BorderFactory;
> import java.awt.LayoutManager;
> import java.awt.Container;
35c50,56
< import javax.swing.DefaultListModel;
---
> import javax.swing.JPanel;
> import java.awt.Dimension;
> import java.awt.Component;
> import javax.swing.table.TableModel;
> import ij.IJ;
> import java.io.File;
> import jwizardcomponent.JWizardComponents;
37,42c58
< import javax.swing.ImageIcon;
< import javax.swing.JButton;
< import javax.swing.JCheckBox;
< import javax.swing.JComboBox;
< import javax.swing.JFileChooser;
< import javax.swing.JFrame;
---
> import javax.swing.JScrollPane;
43a60,61
> import javax.swing.JComboBox;
> import javax.swing.DefaultListModel;
45,48c63,65
< import javax.swing.JPanel;
< import javax.swing.JScrollPane;
< import javax.swing.JSeparator;
< import javax.swing.JSlider;
---
> import javax.swing.JCheckBox;
> import org.jfree.chart.plot.IntervalMarker;
> import org.jfree.chart.ChartPanel;
50,57c67,70
< import javax.swing.JTabbedPane;
< import javax.swing.JTable;
< import javax.swing.JToggleButton;
< import javax.swing.ListSelectionModel;
< import javax.swing.SpinnerNumberModel;
< import javax.swing.event.ChangeEvent;
< import javax.swing.event.ChangeListener;
< import javax.swing.table.DefaultTableCellRenderer;
---
> import fiji.plugin.trackmate.Spot;
> import java.util.List;
> import javax.swing.ImageIcon;
> import ij.ImagePlus;
59,158c72
< import jwizardcomponent.JWizardComponents;
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.plot.IntervalMarker;
< 
< public class FirstWizardPanel extends LabelWizardPanel {
<    private static final long serialVersionUID = 1L;
<    static JTable tableImages;
<    static JTable tableSpot;
<    static DefaultTableModel modelImages;
<    static DefaultTableModel modelSpot;
<    static ImagePlus[] imps;
<    static ImagePlus[] impsPZ;
<    ImageIcon[] icons;
<    Thread mainProcess;
<    ImagePlus impAnal;
<    static String command = "";
<    static String spotEnable = "";
<    List<Spot> removedSpots;
<    List<Spot> spots;
<    JSpinner filterMin;
<    JSpinner filterMax;
<    ChartPanel histogram;
<    HistogramFilterVersion hs2 = new HistogramFilterVersion();
<    IntervalMarker intervalMarker;
<    JCheckBox checkRPicker;
<    static JList<String> classList;
<    static JList<String> featureList;
<    static DefaultListModel<String> modelListClass;
<    static DefaultListModel<String> modelListFeature;
<    static JComboBox<String> comboFilters;
<    static JLabel labelReset;
<    List<Integer> indexesToReset;
<    List<Integer> spotID;
<    List<Integer> spotIDTI;
<    List<Integer> spotIDTO;
<    List<Integer> indexesTI;
<    List<Integer> indexesTO;
<    static JScrollPane jScrollPaneImages;
<    static JScrollPane jScrollPaneSpot;
<    static Icon iconSpotCell;
<    static Icon refreshCell;
<    static Object[] columnNamesSpot;
<    Thread refreshThread;
<    Thread csvThread;
<    Thread pngThread;
<    Thread paintThread;
<    Thread tInsideThread;
<    Thread tOutsideThread;
<    Thread enableThread;
<    Thread disableThread;
<    Thread slMinThread;
<    Thread filterMinThread;
<    Thread slMaxThread;
<    Thread filterMaxThread;
<    Thread filtersThread;
<    Thread pickerThread;
<    Thread classThread;
<    Thread remClassThread;
<    Thread addThread;
<    Thread remThread;
< 
<    public FirstWizardPanel(JWizardComponents wizardComponents) {
<       super(wizardComponents, "");
<       File imageFolder = new File(TrackAnalyzer_.textImages.getText());
<       File[] listOfFiles = imageFolder.listFiles();
<       String[] imageTitles = new String[listOfFiles.length];
<       File[] filesXML = new File[listOfFiles.length];
< 
<       int i;
<       for(i = 0; i < filesXML.length; ++i) {
<          filesXML[i] = new File(TrackAnalyzer_.textXml.getText());
<       }
< 
<       impsPZ = new ImagePlus[imageTitles.length];
<       imps = new ImagePlus[imageTitles.length];
<       this.icons = new ImageIcon[imps.length];
< 
<       for(i = 0; i < listOfFiles.length; ++i) {
<          if (listOfFiles[i].isFile()) {
<             imageTitles[i] = listOfFiles[i].getName();
<          }
< 
<          imps[i] = IJ.openImage(TrackAnalyzer_.textImages.getText() + "/" + imageTitles[i]);
<          impsPZ[i] = this.extractTFrame(imps[i], 1);
<          this.icons[i] = new ImageIcon(getScaledImage(impsPZ[i].getImage(), 90, 95));
<       }
< 
<       tableImages = new JTable();
<       tableSpot = new JTable();
<       modelImages = new DefaultTableModel();
<       modelSpot = new DefaultTableModel();
<       Object[] columnNames = new Object[]{"Movie", "Title", "Extension"};
<       columnNamesSpot = new Object[]{"ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MEAN_INTENSITY", "MEDIAN_INTENSITY", "MIN_INTENSITY", "MAX_INTENSITY", "TOTAL_INTENSITY", "STANDARD_DEVIATION", "CONTRAST", "SNR", "ESTIMATED_DIAMETER", "MORPHOLOGY", "ELLIPSOIDFIT_SEMIAXISLENGTH_C", "ELLIPSOIDFIT_SEMIAXISLENGTH_B", "ELLIPSOIDFIT_SEMIAXISLENGTH_A", "ELLIPSOIDFIT_AXISPHI_C", "ELLIPSOIDFIT_AXISPHI_B", "ELLIPSOIDFIT_AXISPHI_A", "ELLIPSOIDFIT_AXISTHETA_C", "ELLIPSOIDFIT_AXISTHETA_B", "ELLIPSOIDFIT_AXISTHETA_A", "MANUAL_COLOR"};
<       Object[][] data = new Object[imps.length][columnNames.length];
< 
<       for(int i = 0; i < data.length; ++i) {
<          for(int j = 0; j < data[i].length; ++j) {
<             data[i][j] = "";
<          }
<       }
---
> import javax.swing.JTable;
160,167c74,156
<       modelSpot = new DefaultTableModel();
<       modelImages = new DefaultTableModel(data, columnNames) {
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class FirstWizardPanel extends LabelWizardPanel
> {
>     private static final long serialVersionUID = 1L;
>     static JTable tableImages;
>     static JTable tableSpot;
>     static DefaultTableModel modelImages;
>     static DefaultTableModel modelSpot;
>     static ImagePlus[] imps;
>     static ImagePlus[] impsPZ;
>     ImageIcon[] icons;
>     Thread mainProcess;
>     ImagePlus impAnal;
>     static String command;
>     static String spotEnable;
>     List<Spot> removedSpots;
>     List<Spot> spots;
>     JSpinner filterMin;
>     JSpinner filterMax;
>     ChartPanel histogram;
>     HistogramFilterVersion hs2;
>     IntervalMarker intervalMarker;
>     JCheckBox checkRPicker;
>     static JList<String> classList;
>     static JList<String> featureList;
>     static DefaultListModel<String> modelListClass;
>     static DefaultListModel<String> modelListFeature;
>     static JComboBox<String> comboFilters;
>     static JLabel labelReset;
>     List<Integer> indexesToReset;
>     List<Integer> spotID;
>     List<Integer> spotIDTI;
>     List<Integer> spotIDTO;
>     List<Integer> indexesTI;
>     List<Integer> indexesTO;
>     static JScrollPane jScrollPaneImages;
>     static JScrollPane jScrollPaneSpot;
>     static Icon iconSpotCell;
>     static Icon refreshCell;
>     static Object[] columnNamesSpot;
>     Thread refreshThread;
>     Thread csvThread;
>     Thread pngThread;
>     Thread paintThread;
>     Thread tInsideThread;
>     Thread tOutsideThread;
>     Thread enableThread;
>     Thread disableThread;
>     Thread slMinThread;
>     Thread filterMinThread;
>     Thread slMaxThread;
>     Thread filterMaxThread;
>     Thread filtersThread;
>     Thread pickerThread;
>     Thread classThread;
>     Thread remClassThread;
>     Thread addThread;
>     Thread remThread;
>     
>     static {
>         FirstWizardPanel.command = "";
>         FirstWizardPanel.spotEnable = "";
>     }
>     
>     public FirstWizardPanel(final JWizardComponents wizardComponents) {
>         super(wizardComponents, "");
>         this.hs2 = new HistogramFilterVersion();
>         final File imageFolder = new File(TrackAnalyzer_.textImages.getText());
>         final File[] listOfFiles = imageFolder.listFiles();
>         final String[] imageTitles = new String[listOfFiles.length];
>         final File[] filesXML = new File[listOfFiles.length];
>         for (int u = 0; u < filesXML.length; ++u) {
>             filesXML[u] = new File(TrackAnalyzer_.textXml.getText());
>         }
>         FirstWizardPanel.impsPZ = new ImagePlus[imageTitles.length];
>         FirstWizardPanel.imps = new ImagePlus[imageTitles.length];
>         this.icons = new ImageIcon[FirstWizardPanel.imps.length];
>         for (int i = 0; i < listOfFiles.length; ++i) {
>             if (listOfFiles[i].isFile()) {
>                 imageTitles[i] = listOfFiles[i].getName();
169,420c158,416
< 
<             return super.getColumnClass(column);
<          }
<       };
<       tableImages.setModel(modelImages);
<       tableSpot.setModel(modelSpot);
<       tableSpot.setSelectionMode(1);
<       tableImages.getColumnModel().getColumn(0).setPreferredWidth(90);
<       tableImages.getColumnModel().getColumn(1).setPreferredWidth(460);
<       tableImages.getColumnModel().getColumn(2).setPreferredWidth(80);
<       jScrollPaneImages = new JScrollPane(tableImages);
<       jScrollPaneSpot = new JScrollPane(tableSpot);
<       jScrollPaneImages.setPreferredSize(new Dimension(590, 240));
<       jScrollPaneSpot.setPreferredSize(new Dimension(590, 240));
<       JPanel mainPanel = new JPanel();
<       mainPanel.setLayout(new BoxLayout(mainPanel, 1));
<       jScrollPaneImages.setBorder(BorderFactory.createTitledBorder(""));
<       jScrollPaneSpot.setBorder(BorderFactory.createTitledBorder(""));
<       JTabbedPane tabbedPaneSpot = new JTabbedPane(1);
<       ImageIcon iconSpot = createImageIcon("images/spot.png");
<       iconSpotCell = new ImageIcon(iconSpot.getImage().getScaledInstance(18, 20, 4));
<       JButton pngButton = new JButton();
<       ImageIcon iconPng = createImageIcon("images/save.png");
<       Icon pngCell = new ImageIcon(iconPng.getImage().getScaledInstance(18, 20, 4));
<       pngButton.setIcon(pngCell);
<       pngButton.setToolTipText("Click to capture spots overlay.");
<       JPanel panelPng = new JPanel(new FlowLayout(0));
<       panelPng.add(pngButton);
<       JButton csvButton = new JButton();
<       ImageIcon iconCsv = createImageIcon("images/csv.png");
<       Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
<       csvButton.setIcon(csvCell);
<       csvButton.setToolTipText("Click to export your spots table selection.");
<       JPanel panelCsv = new JPanel(new FlowLayout(0));
<       panelCsv.add(csvButton);
<       JPanel panelPngCsv = new JPanel(new FlowLayout(0));
<       panelPngCsv.add(panelPng);
<       panelPngCsv.add(panelCsv);
<       tabbedPaneSpot.addTab("SPOTS ", iconSpotCell, mainPanel, "Display Spot Analysis");
<       tabbedPaneSpot.setTabLayoutPolicy(1);
<       JButton refreshButton = new JButton();
<       ImageIcon iconRefresh = createImageIcon("images/refresh.png");
<       refreshCell = new ImageIcon(iconRefresh.getImage().getScaledInstance(18, 20, 4));
<       refreshButton.setIcon(refreshCell);
<       refreshButton.setToolTipText("Click this button to get spot analysis");
<       JToggleButton paintButton = new JToggleButton();
<       ImageIcon iconPaint = createImageIcon("images/paint.png");
<       Icon paintCell = new ImageIcon(iconPaint.getImage().getScaledInstance(18, 20, 4));
<       paintButton.setIcon(paintCell);
<       paintButton.setToolTipText("Click this button to display labeled-spots");
<       JToggleButton tInsideButton = new JToggleButton();
<       ImageIcon iconTI = createImageIcon("images/tinside.png");
<       Icon TICell = new ImageIcon(iconTI.getImage().getScaledInstance(18, 20, 4));
<       tInsideButton.setIcon(TICell);
<       tInsideButton.setToolTipText("Click this button to toggle inside spots.");
<       JToggleButton tOutsideButton = new JToggleButton();
<       ImageIcon iconTO = createImageIcon("images/toutside.png");
<       Icon TOCell = new ImageIcon(iconTO.getImage().getScaledInstance(18, 20, 4));
<       tOutsideButton.setIcon(TOCell);
<       tOutsideButton.setToolTipText("Click this button to toggle outside spots.");
<       JButton enableButton = new JButton();
<       ImageIcon iconEnable = createImageIcon("images/enable.png");
<       Icon enableCell = new ImageIcon(iconEnable.getImage().getScaledInstance(18, 20, 4));
<       enableButton.setIcon(enableCell);
<       enableButton.setToolTipText("Click this button to enable your selection");
<       JButton disableButton = new JButton();
<       ImageIcon iconDisable = createImageIcon("images/disable.png");
<       Icon disableCell = new ImageIcon(iconDisable.getImage().getScaledInstance(18, 20, 4));
<       disableButton.setIcon(disableCell);
<       disableButton.setToolTipText("Click this button to disable your selection");
<       JPanel buttonPanel = new JPanel(new FlowLayout(2));
<       JSeparator separator1 = new JSeparator(1);
<       JSeparator separator2 = new JSeparator(1);
<       Dimension dime = separator1.getPreferredSize();
<       dime.height = refreshButton.getPreferredSize().height;
<       separator1.setPreferredSize(dime);
<       separator2.setPreferredSize(dime);
<       this.checkRPicker = new JCheckBox(" Spot Picker");
<       JLabel filterLabel = new JLabel("   Spot Analysis : ");
<       filterLabel.setFont(new Font("Dialog", 1, 13));
<       filterLabel.setBorder(BorderFactory.createRaisedBevelBorder());
<       JPanel filterPanel = new JPanel(new FlowLayout(0));
<       filterPanel.add(filterLabel);
<       filterPanel.add(this.checkRPicker);
<       filterPanel.add(Box.createHorizontalStrut(20));
<       JPanel filterMain = new JPanel(new FlowLayout(0));
<       filterMain.add(filterPanel);
<       buttonPanel.add(refreshButton);
<       buttonPanel.add(paintButton);
<       buttonPanel.add(separator1);
<       buttonPanel.add(enableButton);
<       buttonPanel.add(disableButton);
<       buttonPanel.add(separator2);
<       buttonPanel.add(tInsideButton);
<       buttonPanel.add(tOutsideButton);
<       filterMain.add(buttonPanel);
<       mainPanel.add(jScrollPaneImages);
<       mainPanel.add(Box.createVerticalStrut(5));
<       mainPanel.add(filterMain);
<       mainPanel.add(jScrollPaneSpot);
<       JLabel settingsLabel = new JLabel("   Settings for Filters/Classes : ");
<       settingsLabel.setFont(new Font("Dialog", 1, 13));
<       settingsLabel.setBorder(BorderFactory.createRaisedBevelBorder());
<       JPanel settingsPanel = new JPanel(new FlowLayout(0));
<       settingsPanel.add(settingsLabel);
<       mainPanel.add(settingsPanel);
<       JPanel filtersMin = new JPanel(new FlowLayout(0));
<       this.filterMin = new JSpinner(new SpinnerNumberModel(30, 0, 5000, 1));
<       this.filterMin.setPreferredSize(new Dimension(60, 20));
<       final JSlider sliderMin = new JSlider(0, 300, 50);
<       sliderMin.setPreferredSize(new Dimension(150, 15));
<       JLabel filterMinLabel = new JLabel("              Min :  ");
<       filtersMin.add(filterMinLabel);
<       filtersMin.add(sliderMin);
<       filtersMin.add(Box.createHorizontalStrut(2));
<       filtersMin.add(this.filterMin);
<       JPanel filtersMax = new JPanel(new FlowLayout(0));
<       this.filterMax = new JSpinner(new SpinnerNumberModel(200, 0, 5000, 1));
<       this.filterMax.setPreferredSize(new Dimension(60, 20));
<       final JSlider sliderMax = new JSlider(0, 300, 150);
<       sliderMax.setPreferredSize(new Dimension(150, 15));
<       JLabel filterMaxLabel = new JLabel("              Max :  ");
<       filtersMax.add(filterMaxLabel);
<       filtersMax.add(sliderMax);
<       filtersMax.add(Box.createHorizontalStrut(2));
<       filtersMax.add(this.filterMax);
<       JPanel boxPanel2 = new JPanel();
<       boxPanel2.setLayout(new BoxLayout(boxPanel2, 1));
<       final IntervalMarker intervalMarker = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.5F);
<       this.histogram = this.hs2.createChartPanel("", new double[]{0.0D, 0.0D, 0.0D}, 100, intervalMarker);
<       JPanel chartPanel2 = new JPanel(new BorderLayout());
<       chartPanel2.setPreferredSize(new Dimension(390, 180));
<       chartPanel2.add(this.histogram);
<       boxPanel2.add(chartPanel2);
<       JPanel controlPanel2 = this.hs2.createControlPanel();
<       boxPanel2.add(controlPanel2);
<       JPanel filtersMain2 = new JPanel();
<       filtersMain2.setLayout(new BoxLayout(filtersMain2, 1));
<       filtersMain2.add(boxPanel2);
<       filtersMain2.add(filtersMin);
<       filtersMain2.add(filtersMax);
<       JLabel featureSpot = new JLabel("  Spot-Features :  ");
<       featureSpot.setFont(new Font("Dialog", 1, 13));
<       comboFilters = new JComboBox();
< 
<       for(int i = 0; i < columnNamesSpot.length; ++i) {
<          comboFilters.addItem((String)columnNamesSpot[i]);
<       }
< 
<       comboFilters.setPreferredSize(new Dimension(130, 25));
<       comboFilters.setSelectedIndex(0);
<       comboFilters.setOpaque(true);
<       JPanel panelFilters = new JPanel(new FlowLayout(0));
<       JSeparator separator3 = new JSeparator(1);
<       Dimension dime2 = separator3.getPreferredSize();
<       dime2.height = filtersMain2.getPreferredSize().height;
<       separator3.setPreferredSize(dime2);
<       panelFilters.add(filtersMain2);
<       panelFilters.add(separator3);
<       modelListClass = new DefaultListModel();
<       classList = new JList(modelListClass);
<       modelListFeature = new DefaultListModel();
<       featureList = new JList(modelListFeature);
<       final ColorEditorSpot colorEditor = new ColorEditorSpot(featureList);
<       JScrollPane scrollListFilter = new JScrollPane(featureList);
<       JScrollPane scrollListClass = new JScrollPane(classList);
<       Dimension d = featureList.getPreferredSize();
<       d.width = 150;
<       d.height = 90;
<       scrollListFilter.setPreferredSize(d);
<       scrollListClass.setPreferredSize(d);
<       JPanel filterPanelButtons = new JPanel(new FlowLayout(0));
<       JPanel classPanelButtons = new JPanel();
<       classPanelButtons.setLayout(new BoxLayout(classPanelButtons, 1));
<       filterPanelButtons.add(scrollListFilter);
<       JPanel fButtonsPanel = new JPanel();
<       fButtonsPanel.setLayout(new BoxLayout(fButtonsPanel, 1));
<       JButton addButton = new JButton();
<       ImageIcon iconAdd = createImageIcon("images/add.png");
<       Icon addCell = new ImageIcon(iconAdd.getImage().getScaledInstance(14, 16, 4));
<       addButton.setIcon(addCell);
<       addButton.setToolTipText("Click this button to add features");
<       JButton remButton = new JButton();
<       ImageIcon iconRem = createImageIcon("images/remove.png");
<       Icon remCell = new ImageIcon(iconRem.getImage().getScaledInstance(14, 16, 4));
<       remButton.setIcon(remCell);
<       remButton.setToolTipText("Click this button to remove features");
<       JButton classButton = new JButton();
<       ImageIcon iconClass = createImageIcon("images/classes.png");
<       Icon classCell = new ImageIcon(iconClass.getImage().getScaledInstance(14, 16, 4));
<       classButton.setIcon(classCell);
<       classButton.setToolTipText("Click this button to create a class.");
<       JButton remClassButton = new JButton();
<       remClassButton.setIcon(remCell);
<       remClassButton.setToolTipText("Click this button to remove a class.");
<       fButtonsPanel.add(addButton);
<       fButtonsPanel.add(remButton);
<       filterPanelButtons.add(fButtonsPanel);
<       classPanelButtons.add(classButton);
<       classPanelButtons.add(remClassButton);
<       JPanel classPanel = new JPanel(new FlowLayout(0));
<       classPanel.add(scrollListClass);
<       classPanel.add(classPanelButtons);
<       JPanel boxPanel = new JPanel();
<       boxPanel.setLayout(new BoxLayout(boxPanel, 1));
<       boxPanel.add(comboFilters);
<       boxPanel.add(Box.createHorizontalStrut(5));
<       boxPanel.add(filterPanelButtons);
<       boxPanel.add(Box.createHorizontalStrut(5));
<       boxPanel.add(classPanel);
<       boxPanel.add(panelPngCsv);
<       panelFilters.add(boxPanel);
<       mainPanel.add(panelFilters);
<       this.add(tabbedPaneSpot);
<       this.createMovieTable();
<       refreshButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.refreshThread = new Thread(new Runnable() {
<                public void run() {
<                   FirstWizardPanel.spotEnable = "spotEnable";
<                   ProcessTrackMateXml.tracksVisible = false;
<                   ProcessTrackMateXml.spotsVisible = true;
<                   ProcessTrackMateXml ptx = new ProcessTrackMateXml();
<                   ptx.processTrackMateXml();
<                }
<             });
<             FirstWizardPanel.this.refreshThread.start();
<          }
<       });
<       csvButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.csvThread = new Thread(new Runnable() {
<                public void run() {
<                   List<String> columnSpotHead = new ArrayList();
< 
<                   for(int j = 0; j < FirstWizardPanel.modelSpot.getColumnCount(); ++j) {
<                      columnSpotHead.add(FirstWizardPanel.modelSpot.getColumnName(j));
<                   }
< 
<                   ResultsTable rt = new ResultsTable(FirstWizardPanel.modelSpot.getRowCount());
<                   if (rt != null) {
<                      rt.reset();
<                   }
< 
<                   for(int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<                      for(int jx = 0; jx < FirstWizardPanel.modelSpot.getColumnCount(); ++jx) {
<                         if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE) {
<                            if (((String)columnSpotHead.get(jx)).equals(columnSpotHead.get(0)) == Boolean.TRUE) {
<                               rt.setValue((String)columnSpotHead.get(jx), i, ((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, jx)).getText());
<                            } else {
<                               rt.setValue((String)columnSpotHead.get(jx), i, FirstWizardPanel.modelSpot.getValueAt(i, jx).toString());
<                            }
---
>             FirstWizardPanel.imps[i] = IJ.openImage(String.valueOf(TrackAnalyzer_.textImages.getText()) + "/" + imageTitles[i]);
>             FirstWizardPanel.impsPZ[i] = this.extractTFrame(FirstWizardPanel.imps[i], 1);
>             this.icons[i] = new ImageIcon(getScaledImage(FirstWizardPanel.impsPZ[i].getImage(), 90, 95));
>         }
>         FirstWizardPanel.tableImages = new JTable();
>         FirstWizardPanel.tableSpot = new JTable();
>         FirstWizardPanel.modelImages = new DefaultTableModel();
>         FirstWizardPanel.modelSpot = new DefaultTableModel();
>         final Object[] columnNames = { "Movie", "Title", "Extension" };
>         FirstWizardPanel.columnNamesSpot = new Object[] { "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MEAN_INTENSITY", "MEDIAN_INTENSITY", "MIN_INTENSITY", "MAX_INTENSITY", "TOTAL_INTENSITY", "STANDARD_DEVIATION", "CONTRAST", "SNR", "ESTIMATED_DIAMETER", "MORPHOLOGY", "ELLIPSOIDFIT_SEMIAXISLENGTH_C", "ELLIPSOIDFIT_SEMIAXISLENGTH_B", "ELLIPSOIDFIT_SEMIAXISLENGTH_A", "ELLIPSOIDFIT_AXISPHI_C", "ELLIPSOIDFIT_AXISPHI_B", "ELLIPSOIDFIT_AXISPHI_A", "ELLIPSOIDFIT_AXISTHETA_C", "ELLIPSOIDFIT_AXISTHETA_B", "ELLIPSOIDFIT_AXISTHETA_A", "MANUAL_COLOR" };
>         final Object[][] data = new Object[FirstWizardPanel.imps.length][columnNames.length];
>         for (int j = 0; j < data.length; ++j) {
>             for (int k = 0; k < data[j].length; ++k) {
>                 data[j][k] = "";
>             }
>         }
>         FirstWizardPanel.modelSpot = new DefaultTableModel();
>         FirstWizardPanel.modelImages = new DefaultTableModel(data, columnNames) {
>             @Override
>             public Class<?> getColumnClass(final int column) {
>                 if (this.getRowCount() > 0) {
>                     final Object value = this.getValueAt(0, column);
>                     if (value != null) {
>                         return this.getValueAt(0, column).getClass();
>                     }
>                 }
>                 return super.getColumnClass(column);
>             }
>         };
>         FirstWizardPanel.tableImages.setModel(FirstWizardPanel.modelImages);
>         FirstWizardPanel.tableSpot.setModel(FirstWizardPanel.modelSpot);
>         FirstWizardPanel.tableSpot.setSelectionMode(1);
>         FirstWizardPanel.tableImages.getColumnModel().getColumn(0).setPreferredWidth(90);
>         FirstWizardPanel.tableImages.getColumnModel().getColumn(1).setPreferredWidth(460);
>         FirstWizardPanel.tableImages.getColumnModel().getColumn(2).setPreferredWidth(80);
>         FirstWizardPanel.jScrollPaneImages = new JScrollPane(FirstWizardPanel.tableImages);
>         FirstWizardPanel.jScrollPaneSpot = new JScrollPane(FirstWizardPanel.tableSpot);
>         FirstWizardPanel.jScrollPaneImages.setPreferredSize(new Dimension(590, 240));
>         FirstWizardPanel.jScrollPaneSpot.setPreferredSize(new Dimension(590, 240));
>         final JPanel mainPanel = new JPanel();
>         mainPanel.setLayout(new BoxLayout(mainPanel, 1));
>         FirstWizardPanel.jScrollPaneImages.setBorder(BorderFactory.createTitledBorder(""));
>         FirstWizardPanel.jScrollPaneSpot.setBorder(BorderFactory.createTitledBorder(""));
>         final JTabbedPane tabbedPaneSpot = new JTabbedPane(1);
>         final ImageIcon iconSpot = createImageIcon("images/spot.png");
>         FirstWizardPanel.iconSpotCell = new ImageIcon(iconSpot.getImage().getScaledInstance(18, 20, 4));
>         final JButton pngButton = new JButton();
>         final ImageIcon iconPng = createImageIcon("images/save.png");
>         final Icon pngCell = new ImageIcon(iconPng.getImage().getScaledInstance(18, 20, 4));
>         pngButton.setIcon(pngCell);
>         pngButton.setToolTipText("Click to capture spots overlay.");
>         final JPanel panelPng = new JPanel(new FlowLayout(0));
>         panelPng.add(pngButton);
>         final JButton csvButton = new JButton();
>         final ImageIcon iconCsv = createImageIcon("images/csv.png");
>         final Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
>         csvButton.setIcon(csvCell);
>         csvButton.setToolTipText("Click to export your spots table selection.");
>         final JPanel panelCsv = new JPanel(new FlowLayout(0));
>         panelCsv.add(csvButton);
>         final JPanel panelPngCsv = new JPanel(new FlowLayout(0));
>         panelPngCsv.add(panelPng);
>         panelPngCsv.add(panelCsv);
>         tabbedPaneSpot.addTab("SPOTS ", FirstWizardPanel.iconSpotCell, mainPanel, "Display Spot Analysis");
>         tabbedPaneSpot.setTabLayoutPolicy(1);
>         final JButton refreshButton = new JButton();
>         final ImageIcon iconRefresh = createImageIcon("images/refresh.png");
>         refreshButton.setIcon(FirstWizardPanel.refreshCell = new ImageIcon(iconRefresh.getImage().getScaledInstance(18, 20, 4)));
>         refreshButton.setToolTipText("Click this button to get spot analysis");
>         final JToggleButton paintButton = new JToggleButton();
>         final ImageIcon iconPaint = createImageIcon("images/paint.png");
>         final Icon paintCell = new ImageIcon(iconPaint.getImage().getScaledInstance(18, 20, 4));
>         paintButton.setIcon(paintCell);
>         paintButton.setToolTipText("Click this button to display labeled-spots");
>         final JToggleButton tInsideButton = new JToggleButton();
>         final ImageIcon iconTI = createImageIcon("images/tinside.png");
>         final Icon TICell = new ImageIcon(iconTI.getImage().getScaledInstance(18, 20, 4));
>         tInsideButton.setIcon(TICell);
>         tInsideButton.setToolTipText("Click this button to toggle inside spots.");
>         final JToggleButton tOutsideButton = new JToggleButton();
>         final ImageIcon iconTO = createImageIcon("images/toutside.png");
>         final Icon TOCell = new ImageIcon(iconTO.getImage().getScaledInstance(18, 20, 4));
>         tOutsideButton.setIcon(TOCell);
>         tOutsideButton.setToolTipText("Click this button to toggle outside spots.");
>         final JButton enableButton = new JButton();
>         final ImageIcon iconEnable = createImageIcon("images/enable.png");
>         final Icon enableCell = new ImageIcon(iconEnable.getImage().getScaledInstance(18, 20, 4));
>         enableButton.setIcon(enableCell);
>         enableButton.setToolTipText("Click this button to enable your selection");
>         final JButton disableButton = new JButton();
>         final ImageIcon iconDisable = createImageIcon("images/disable.png");
>         final Icon disableCell = new ImageIcon(iconDisable.getImage().getScaledInstance(18, 20, 4));
>         disableButton.setIcon(disableCell);
>         disableButton.setToolTipText("Click this button to disable your selection");
>         final JPanel buttonPanel = new JPanel(new FlowLayout(2));
>         final JSeparator separator1 = new JSeparator(1);
>         final JSeparator separator2 = new JSeparator(1);
>         final Dimension dime = separator1.getPreferredSize();
>         dime.height = refreshButton.getPreferredSize().height;
>         separator1.setPreferredSize(dime);
>         separator2.setPreferredSize(dime);
>         this.checkRPicker = new JCheckBox(" Spot Picker");
>         final JLabel filterLabel = new JLabel("   Spot Analysis : ");
>         filterLabel.setFont(new Font("Dialog", 1, 13));
>         filterLabel.setBorder(BorderFactory.createRaisedBevelBorder());
>         final JPanel filterPanel = new JPanel(new FlowLayout(0));
>         filterPanel.add(filterLabel);
>         filterPanel.add(this.checkRPicker);
>         filterPanel.add(Box.createHorizontalStrut(20));
>         final JPanel filterMain = new JPanel(new FlowLayout(0));
>         filterMain.add(filterPanel);
>         buttonPanel.add(refreshButton);
>         buttonPanel.add(paintButton);
>         buttonPanel.add(separator1);
>         buttonPanel.add(enableButton);
>         buttonPanel.add(disableButton);
>         buttonPanel.add(separator2);
>         buttonPanel.add(tInsideButton);
>         buttonPanel.add(tOutsideButton);
>         filterMain.add(buttonPanel);
>         mainPanel.add(FirstWizardPanel.jScrollPaneImages);
>         mainPanel.add(Box.createVerticalStrut(5));
>         mainPanel.add(filterMain);
>         mainPanel.add(FirstWizardPanel.jScrollPaneSpot);
>         final JLabel settingsLabel = new JLabel("   Settings for Filters/Classes : ");
>         settingsLabel.setFont(new Font("Dialog", 1, 13));
>         settingsLabel.setBorder(BorderFactory.createRaisedBevelBorder());
>         final JPanel settingsPanel = new JPanel(new FlowLayout(0));
>         settingsPanel.add(settingsLabel);
>         mainPanel.add(settingsPanel);
>         final JPanel filtersMin = new JPanel(new FlowLayout(0));
>         (this.filterMin = new JSpinner(new SpinnerNumberModel(30, 0, 5000, 1))).setPreferredSize(new Dimension(60, 20));
>         final JSlider sliderMin = new JSlider(0, 300, 50);
>         sliderMin.setPreferredSize(new Dimension(150, 15));
>         final JLabel filterMinLabel = new JLabel("              Min :  ");
>         filtersMin.add(filterMinLabel);
>         filtersMin.add(sliderMin);
>         filtersMin.add(Box.createHorizontalStrut(2));
>         filtersMin.add(this.filterMin);
>         final JPanel filtersMax = new JPanel(new FlowLayout(0));
>         (this.filterMax = new JSpinner(new SpinnerNumberModel(200, 0, 5000, 1))).setPreferredSize(new Dimension(60, 20));
>         final JSlider sliderMax = new JSlider(0, 300, 150);
>         sliderMax.setPreferredSize(new Dimension(150, 15));
>         final JLabel filterMaxLabel = new JLabel("              Max :  ");
>         filtersMax.add(filterMaxLabel);
>         filtersMax.add(sliderMax);
>         filtersMax.add(Box.createHorizontalStrut(2));
>         filtersMax.add(this.filterMax);
>         final JPanel boxPanel2 = new JPanel();
>         boxPanel2.setLayout(new BoxLayout(boxPanel2, 1));
>         final IntervalMarker intervalMarker = new IntervalMarker(0.0, 0.0, (Paint)new Color(229, 255, 204), (Stroke)new BasicStroke(), (Paint)new Color(0, 102, 0), (Stroke)new BasicStroke(1.5f), 0.5f);
>         this.histogram = this.hs2.createChartPanel("", new double[] { 0.0, 0.0, 0.0 }, 100, intervalMarker);
>         final JPanel chartPanel2 = new JPanel(new BorderLayout());
>         chartPanel2.setPreferredSize(new Dimension(390, 180));
>         chartPanel2.add((Component)this.histogram);
>         boxPanel2.add(chartPanel2);
>         final JPanel controlPanel2 = this.hs2.createControlPanel();
>         boxPanel2.add(controlPanel2);
>         final JPanel filtersMain2 = new JPanel();
>         filtersMain2.setLayout(new BoxLayout(filtersMain2, 1));
>         filtersMain2.add(boxPanel2);
>         filtersMain2.add(filtersMin);
>         filtersMain2.add(filtersMax);
>         final JLabel featureSpot = new JLabel("  Spot-Features :  ");
>         featureSpot.setFont(new Font("Dialog", 1, 13));
>         FirstWizardPanel.comboFilters = new JComboBox<String>();
>         for (int l = 0; l < FirstWizardPanel.columnNamesSpot.length; ++l) {
>             FirstWizardPanel.comboFilters.addItem((String)FirstWizardPanel.columnNamesSpot[l]);
>         }
>         FirstWizardPanel.comboFilters.setPreferredSize(new Dimension(130, 25));
>         FirstWizardPanel.comboFilters.setSelectedIndex(0);
>         FirstWizardPanel.comboFilters.setOpaque(true);
>         final JPanel panelFilters = new JPanel(new FlowLayout(0));
>         final JSeparator separator3 = new JSeparator(1);
>         final Dimension dime2 = separator3.getPreferredSize();
>         dime2.height = filtersMain2.getPreferredSize().height;
>         separator3.setPreferredSize(dime2);
>         panelFilters.add(filtersMain2);
>         panelFilters.add(separator3);
>         FirstWizardPanel.modelListClass = new DefaultListModel<String>();
>         FirstWizardPanel.classList = new JList<String>(FirstWizardPanel.modelListClass);
>         FirstWizardPanel.modelListFeature = new DefaultListModel<String>();
>         FirstWizardPanel.featureList = new JList<String>(FirstWizardPanel.modelListFeature);
>         final ColorEditorSpot colorEditor = new ColorEditorSpot(FirstWizardPanel.featureList);
>         final JScrollPane scrollListFilter = new JScrollPane(FirstWizardPanel.featureList);
>         final JScrollPane scrollListClass = new JScrollPane(FirstWizardPanel.classList);
>         final Dimension d = FirstWizardPanel.featureList.getPreferredSize();
>         d.width = 150;
>         d.height = 90;
>         scrollListFilter.setPreferredSize(d);
>         scrollListClass.setPreferredSize(d);
>         final JPanel filterPanelButtons = new JPanel(new FlowLayout(0));
>         final JPanel classPanelButtons = new JPanel();
>         classPanelButtons.setLayout(new BoxLayout(classPanelButtons, 1));
>         filterPanelButtons.add(scrollListFilter);
>         final JPanel fButtonsPanel = new JPanel();
>         fButtonsPanel.setLayout(new BoxLayout(fButtonsPanel, 1));
>         final JButton addButton = new JButton();
>         final ImageIcon iconAdd = createImageIcon("images/add.png");
>         final Icon addCell = new ImageIcon(iconAdd.getImage().getScaledInstance(14, 16, 4));
>         addButton.setIcon(addCell);
>         addButton.setToolTipText("Click this button to add features");
>         final JButton remButton = new JButton();
>         final ImageIcon iconRem = createImageIcon("images/remove.png");
>         final Icon remCell = new ImageIcon(iconRem.getImage().getScaledInstance(14, 16, 4));
>         remButton.setIcon(remCell);
>         remButton.setToolTipText("Click this button to remove features");
>         final JButton classButton = new JButton();
>         final ImageIcon iconClass = createImageIcon("images/classes.png");
>         final Icon classCell = new ImageIcon(iconClass.getImage().getScaledInstance(14, 16, 4));
>         classButton.setIcon(classCell);
>         classButton.setToolTipText("Click this button to create a class.");
>         final JButton remClassButton = new JButton();
>         remClassButton.setIcon(remCell);
>         remClassButton.setToolTipText("Click this button to remove a class.");
>         fButtonsPanel.add(addButton);
>         fButtonsPanel.add(remButton);
>         filterPanelButtons.add(fButtonsPanel);
>         classPanelButtons.add(classButton);
>         classPanelButtons.add(remClassButton);
>         final JPanel classPanel = new JPanel(new FlowLayout(0));
>         classPanel.add(scrollListClass);
>         classPanel.add(classPanelButtons);
>         final JPanel boxPanel3 = new JPanel();
>         boxPanel3.setLayout(new BoxLayout(boxPanel3, 1));
>         boxPanel3.add(FirstWizardPanel.comboFilters);
>         boxPanel3.add(Box.createHorizontalStrut(5));
>         boxPanel3.add(filterPanelButtons);
>         boxPanel3.add(Box.createHorizontalStrut(5));
>         boxPanel3.add(classPanel);
>         boxPanel3.add(panelPngCsv);
>         panelFilters.add(boxPanel3);
>         mainPanel.add(panelFilters);
>         this.add((Component)tabbedPaneSpot);
>         this.createMovieTable();
>         refreshButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (FirstWizardPanel.this.refreshThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         FirstWizardPanel.spotEnable = "spotEnable";
>                         ProcessTrackMateXml.tracksVisible = false;
>                         ProcessTrackMateXml.spotsVisible = true;
>                         final ProcessTrackMateXml ptx = new ProcessTrackMateXml();
>                         ptx.processTrackMateXml();
>                     }
>                 })).start();
>             }
>         });
>         csvButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (FirstWizardPanel.this.csvThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         final List<String> columnSpotHead = new ArrayList<String>();
>                         for (int j = 0; j < FirstWizardPanel.modelSpot.getColumnCount(); ++j) {
>                             columnSpotHead.add(FirstWizardPanel.modelSpot.getColumnName(j));
422,465c418,420
<                      }
<                   }
< 
<                   JFrame pngFrame = new JFrame();
<                   JFileChooser fileChooser = new JFileChooser();
<                   fileChooser.setFileSelectionMode(1);
<                   fileChooser.setDialogTitle("Specify a directory to save csv file");
<                   int userSelection = fileChooser.showSaveDialog(pngFrame);
<                   if (userSelection == 0) {
<                      File fileToSave = fileChooser.getSelectedFile();
< 
<                      try {
<                         rt.saveAs(fileToSave.getAbsolutePath() + File.separator + "SpotStatistics for-" + IJ.getImage().getShortTitle() + ".csv");
<                      } catch (IOException var8) {
<                         var8.printStackTrace();
<                      }
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.csvThread.start();
<          }
<       });
<       pngButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.pngThread = new Thread(new Runnable() {
<                public void run() {
<                   if (IJ.getImage() == null) {
<                      IJ.error("You must have an image window active.");
<                   }
< 
<                   if (IJ.getImage() != null) {
<                      JFrame pngFrame = new JFrame();
<                      JFileChooser fileChooser = new JFileChooser();
<                      fileChooser.setFileSelectionMode(1);
<                      fileChooser.setDialogTitle("Specify a directory to save");
<                      int userSelection = fileChooser.showSaveDialog(pngFrame);
<                      if (userSelection == 0) {
<                         File fileToSave = fileChooser.getSelectedFile();
<                         int firstFrame = 0;
<                         int lastFrame = 0;
<                         if (ProcessTrackMateXml.displayer.getImp().getNFrames() > 1) {
<                            firstFrame = Math.max(1, Math.min(IJ.getImage().getNFrames(), 1));
<                            lastFrame = Math.min(IJ.getImage().getNFrames(), Math.max(IJ.getImage().getNFrames(), 1));
---
>                         final ResultsTable rt = new ResultsTable(Integer.valueOf(FirstWizardPanel.modelSpot.getRowCount()));
>                         if (rt != null) {
>                             rt.reset();
467,470c422,432
< 
<                         if (ProcessTrackMateXml.displayer.getImp().getNSlices() > 1) {
<                            firstFrame = Math.max(1, Math.min(IJ.getImage().getNSlices(), 1));
<                            lastFrame = Math.min(IJ.getImage().getNSlices(), Math.max(IJ.getImage().getNSlices(), 1));
---
>                         for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
>                             for (int k = 0; k < FirstWizardPanel.modelSpot.getColumnCount(); ++k) {
>                                 if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE) {
>                                     if (columnSpotHead.get(k).equals(columnSpotHead.get(0)) == Boolean.TRUE) {
>                                         rt.setValue((String)columnSpotHead.get(k), i, ((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, k)).getText());
>                                     }
>                                     else {
>                                         rt.setValue((String)columnSpotHead.get(k), i, FirstWizardPanel.modelSpot.getValueAt(i, k).toString());
>                                     }
>                                 }
>                             }
472,488c434,446
< 
<                         Rectangle bounds = ProcessTrackMateXml.displayer.getImp().getCanvas().getBounds();
<                         int width = bounds.width;
<                         int height = bounds.height;
<                         int nCaptures = lastFrame - firstFrame + 1;
<                         ImageStack stack = new ImageStack(width, height);
<                         int channel = ProcessTrackMateXml.displayer.getImp().getChannel();
<                         int slice = ProcessTrackMateXml.displayer.getImp().getSlice();
<                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(true);
< 
<                         for(int frame = firstFrame; frame <= lastFrame; ++frame) {
<                            ProcessTrackMateXml.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
<                            BufferedImage bi = new BufferedImage(width, height, 2);
<                            ProcessTrackMateXml.displayer.getImp().getCanvas().paint(bi.getGraphics());
<                            ColorProcessor cp = new ColorProcessor(bi);
<                            int index = ProcessTrackMateXml.displayer.getImp().getStackIndex(channel, slice, frame);
<                            stack.addSlice(ProcessTrackMateXml.displayer.getImp().getImageStack().getSliceLabel(index), cp);
---
>                         final JFrame pngFrame = new JFrame();
>                         final JFileChooser fileChooser = new JFileChooser();
>                         fileChooser.setFileSelectionMode(1);
>                         fileChooser.setDialogTitle("Specify a directory to save csv file");
>                         final int userSelection = fileChooser.showSaveDialog(pngFrame);
>                         if (userSelection == 0) {
>                             final File fileToSave = fileChooser.getSelectedFile();
>                             try {
>                                 rt.saveAs(String.valueOf(fileToSave.getAbsolutePath()) + File.separator + "SpotStatistics for-" + IJ.getImage().getShortTitle() + ".csv");
>                             }
>                             catch (IOException e1) {
>                                 e1.printStackTrace();
>                             }
490,760c448,774
< 
<                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(false);
<                         ImagePlus capture = new ImagePlus("TrackMate capture of " + ProcessTrackMateXml.displayer.getImp().getShortTitle(), stack);
<                         FirstWizardPanel.transferCalibration(ProcessTrackMateXml.displayer.getImp(), capture);
<                         IJ.saveAs(capture, "Tiff", fileToSave.getAbsolutePath() + File.separator + "Capture Overlay for " + IJ.getImage().getShortTitle());
<                      }
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.pngThread.start();
<          }
<       });
<       paintButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             FirstWizardPanel.this.paintThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      FirstWizardPanel.this.paintAndDisableAction();
<                   } else if (ev.getStateChange() == 2) {
<                      FirstWizardPanel.this.resetAndEnableAction();
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.paintThread.start();
<          }
<       });
<       tInsideButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             FirstWizardPanel.this.tInsideThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      FirstWizardPanel.this.toggleInsideAction();
<                   } else if (ev.getStateChange() == 2) {
<                      FirstWizardPanel.this.resetToggleInsideAction();
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.tInsideThread.start();
<          }
<       });
<       tOutsideButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             FirstWizardPanel.this.tOutsideThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      FirstWizardPanel.this.toggleOutsideAction();
<                   } else if (ev.getStateChange() == 2) {
<                      FirstWizardPanel.this.resetToggleOutsideAction();
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.tOutsideThread.start();
<          }
<       });
<       enableButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.enableThread = new Thread(new Runnable() {
<                public void run() {
<                   FirstWizardPanel.this.enableSpots();
<                }
<             });
<             FirstWizardPanel.this.enableThread.start();
<          }
<       });
<       disableButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.disableThread = new Thread(new Runnable() {
<                public void run() {
<                   FirstWizardPanel.this.disableSpots();
<                }
<             });
<             FirstWizardPanel.this.disableThread.start();
<          }
<       });
<       sliderMin.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             FirstWizardPanel.this.slMinThread = new Thread(new Runnable() {
<                public void run() {
<                   FirstWizardPanel.this.filterMin.setValue(sliderMin.getValue());
<                   intervalMarker.setStartValue((double)sliderMin.getValue());
<                }
<             });
<             FirstWizardPanel.this.slMinThread.start();
<          }
<       });
<       this.filterMin.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             FirstWizardPanel.this.filterMinThread = new Thread(new Runnable() {
<                public void run() {
<                   sliderMin.setValue((Integer)FirstWizardPanel.this.filterMin.getValue());
<                   intervalMarker.setStartValue((double)(Integer)FirstWizardPanel.this.filterMin.getValue());
<                }
<             });
<             FirstWizardPanel.this.filterMinThread.start();
<          }
<       });
<       sliderMax.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             FirstWizardPanel.this.slMaxThread = new Thread(new Runnable() {
<                public void run() {
<                   FirstWizardPanel.this.filterMax.setValue(sliderMax.getValue());
<                   intervalMarker.setEndValue((double)sliderMax.getValue());
<                }
<             });
<             FirstWizardPanel.this.slMaxThread.start();
<          }
<       });
<       this.filterMax.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             FirstWizardPanel.this.filterMaxThread = new Thread(new Runnable() {
<                public void run() {
<                   sliderMax.setValue((Integer)FirstWizardPanel.this.filterMax.getValue());
<                   intervalMarker.setEndValue((double)(Integer)FirstWizardPanel.this.filterMax.getValue());
<                }
<             });
<             FirstWizardPanel.this.filterMaxThread.start();
<          }
<       });
<       comboFilters.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.filtersThread = new Thread(new Runnable() {
<                public void run() {
<                   String selectedName = (String)FirstWizardPanel.comboFilters.getSelectedItem();
<                   int selectedIndex = FirstWizardPanel.comboFilters.getSelectedIndex();
<                   double[] valuesx = null;
<                   double[] values = new double[FirstWizardPanel.tableSpot.getRowCount()];
< 
<                   int i;
<                   for(i = 0; i < FirstWizardPanel.tableSpot.getRowCount(); ++i) {
<                      for(int c = 0; c < FirstWizardPanel.tableSpot.getColumnCount(); ++c) {
<                         values[i] = Double.parseDouble((String)FirstWizardPanel.tableSpot.getValueAt(i, selectedIndex + 2));
<                      }
<                   }
< 
<                   double max = values[0];
< 
<                   for(i = 1; i < values.length; ++i) {
<                      if (values[i] > max) {
<                         max = values[i];
<                      }
<                   }
< 
<                   sliderMin.setMinimum(0);
<                   sliderMin.setMaximum((int)max);
<                   sliderMax.setMinimum(0);
<                   sliderMax.setMaximum((int)max);
<                   FirstWizardPanel.this.hs2.addHistogramSeries(selectedName, values, (int)max, intervalMarker);
<                }
<             });
<             FirstWizardPanel.this.filtersThread.start();
<          }
<       });
<       this.checkRPicker.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent e) {
<             FirstWizardPanel.this.pickerThread = new Thread(new Runnable() {
<                public void run() {
<                   if (e.getStateChange() == 1) {
<                      FirstWizardPanel.command = "enable";
<                   }
< 
<                   if (e.getStateChange() == 2) {
<                      FirstWizardPanel.command = null;
<                      ProcessTrackMateXml.selectionModel.clearSpotSelection();
<                      ProcessTrackMateXml.selectionModel.clearSelection();
<                   }
<                }
<             });
<             FirstWizardPanel.this.pickerThread.start();
<          }
<       });
<       classButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.classThread = new Thread(new Runnable() {
<                public void run() {
<                   ColorEditorSpot.myFrame.setVisible(true);
<                   colorEditor.setClassAction();
<                }
<             });
<             FirstWizardPanel.this.classThread.start();
<          }
<       });
<       remClassButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.remClassThread = new Thread(new Runnable() {
<                public void run() {
<                   String classSelectedValue = (String)FirstWizardPanel.classList.getSelectedValue();
<                   int[] classSelectedIndex = FirstWizardPanel.classList.getSelectedIndices();
< 
<                   int i;
<                   for(i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<                      if (((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1))).getText().equals(classSelectedValue)) {
<                         FirstWizardPanel.modelSpot.setValueAt(FirstWizardPanel.labelReset, i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
<                      }
<                   }
< 
<                   for(i = 0; i < classSelectedIndex.length; ++i) {
<                      FirstWizardPanel.modelListClass.removeElementAt(classSelectedIndex[i]);
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.remClassThread.start();
<          }
<       });
<       addButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.addThread = new Thread(new Runnable() {
<                public void run() {
<                   List<String> listFilters = new ArrayList();
<                   if (FirstWizardPanel.featureList.getModel().getSize() < 1) {
<                      FirstWizardPanel.modelListFeature.addElement((String)FirstWizardPanel.comboFilters.getSelectedItem() + ":  [" + FirstWizardPanel.this.filterMin.getValue() + "," + FirstWizardPanel.this.filterMax.getValue() + "]");
<                   }
< 
<                   if (FirstWizardPanel.featureList.getModel().getSize() >= 1) {
<                      for(int i = 0; i < FirstWizardPanel.featureList.getModel().getSize(); ++i) {
<                         listFilters.add(String.valueOf(((String)FirstWizardPanel.featureList.getModel().getElementAt(i)).substring(0, ((String)FirstWizardPanel.featureList.getModel().getElementAt(i)).lastIndexOf(":"))));
<                      }
< 
<                      if (!listFilters.contains(FirstWizardPanel.comboFilters.getSelectedItem().toString())) {
<                         FirstWizardPanel.modelListFeature.addElement((String)FirstWizardPanel.comboFilters.getSelectedItem() + ":  [" + FirstWizardPanel.this.filterMin.getValue() + "," + FirstWizardPanel.this.filterMax.getValue() + "]");
<                      }
< 
<                      if (listFilters.contains(FirstWizardPanel.comboFilters.getSelectedItem().toString())) {
<                         return;
<                      }
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.addThread.start();
<          }
<       });
<       remButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.remThread = new Thread(new Runnable() {
<                public void run() {
<                   try {
<                      int[] indexes = FirstWizardPanel.featureList.getSelectedIndices();
< 
<                      for(int i = 0; i < indexes.length; ++i) {
<                         FirstWizardPanel.modelListFeature.remove(indexes[i]);
<                      }
<                   } catch (Exception var3) {
<                      var3.printStackTrace();
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.remThread.start();
<          }
<       });
<    }
< 
<    public void toggleOutsideAction() {
<       Roi mainRoi = null;
<       if (IJ.getImage().getRoi().getType() == 0) {
<          mainRoi = IJ.getImage().getRoi();
<       }
< 
<       this.indexesTO = new ArrayList();
< 
<       for(int i = 0; i < modelSpot.getRowCount(); ++i) {
<          if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(5)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(6)).toString()))) == Boolean.FALSE) {
<             this.indexesTO.add(i);
<             modelSpot.setValueAt(false, i, tableSpot.convertColumnIndexToModel(0));
<             int spotID = Integer.parseInt((String)tableSpot.getValueAt(i, 2));
<             Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
---
>                     }
>                 })).start();
>             }
>         });
>         pngButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (FirstWizardPanel.this.pngThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (IJ.getImage() == null) {
>                             IJ.error("You must have an image window active.");
>                         }
>                         if (IJ.getImage() != null) {
>                             final JFrame pngFrame = new JFrame();
>                             final JFileChooser fileChooser = new JFileChooser();
>                             fileChooser.setFileSelectionMode(1);
>                             fileChooser.setDialogTitle("Specify a directory to save");
>                             final int userSelection = fileChooser.showSaveDialog(pngFrame);
>                             if (userSelection == 0) {
>                                 final File fileToSave = fileChooser.getSelectedFile();
>                                 int firstFrame = 0;
>                                 int lastFrame = 0;
>                                 if (ProcessTrackMateXml.displayer.getImp().getNFrames() > 1) {
>                                     firstFrame = Math.max(1, Math.min(IJ.getImage().getNFrames(), 1));
>                                     lastFrame = Math.min(IJ.getImage().getNFrames(), Math.max(IJ.getImage().getNFrames(), 1));
>                                 }
>                                 if (ProcessTrackMateXml.displayer.getImp().getNSlices() > 1) {
>                                     firstFrame = Math.max(1, Math.min(IJ.getImage().getNSlices(), 1));
>                                     lastFrame = Math.min(IJ.getImage().getNSlices(), Math.max(IJ.getImage().getNSlices(), 1));
>                                 }
>                                 final Rectangle bounds = ProcessTrackMateXml.displayer.getImp().getCanvas().getBounds();
>                                 final int width = bounds.width;
>                                 final int height = bounds.height;
>                                 final int nCaptures = lastFrame - firstFrame + 1;
>                                 final ImageStack stack = new ImageStack(width, height);
>                                 final int channel = ProcessTrackMateXml.displayer.getImp().getChannel();
>                                 final int slice = ProcessTrackMateXml.displayer.getImp().getSlice();
>                                 ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(true);
>                                 for (int frame = firstFrame; frame <= lastFrame; ++frame) {
>                                     ProcessTrackMateXml.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
>                                     final BufferedImage bi = new BufferedImage(width, height, 2);
>                                     ProcessTrackMateXml.displayer.getImp().getCanvas().paint(bi.getGraphics());
>                                     final ColorProcessor cp = new ColorProcessor((Image)bi);
>                                     final int index = ProcessTrackMateXml.displayer.getImp().getStackIndex(channel, slice, frame);
>                                     stack.addSlice(ProcessTrackMateXml.displayer.getImp().getImageStack().getSliceLabel(index), (ImageProcessor)cp);
>                                 }
>                                 ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(false);
>                                 final ImagePlus capture = new ImagePlus("TrackMate capture of " + ProcessTrackMateXml.displayer.getImp().getShortTitle(), stack);
>                                 transferCalibration(ProcessTrackMateXml.displayer.getImp(), capture);
>                                 IJ.saveAs(capture, "Tiff", String.valueOf(fileToSave.getAbsolutePath()) + File.separator + "Capture Overlay for " + IJ.getImage().getShortTitle());
>                             }
>                         }
>                     }
>                 })).start();
>             }
>         });
>         paintButton.addItemListener(new ItemListener() {
>             @Override
>             public void itemStateChanged(final ItemEvent ev) {
>                 (FirstWizardPanel.this.paintThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (ev.getStateChange() == 1) {
>                             FirstWizardPanel.this.paintAndDisableAction();
>                         }
>                         else if (ev.getStateChange() == 2) {
>                             FirstWizardPanel.this.resetAndEnableAction();
>                         }
>                     }
>                 })).start();
>             }
>         });
>         tInsideButton.addItemListener(new ItemListener() {
>             @Override
>             public void itemStateChanged(final ItemEvent ev) {
>                 (FirstWizardPanel.this.tInsideThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (ev.getStateChange() == 1) {
>                             FirstWizardPanel.this.toggleInsideAction();
>                         }
>                         else if (ev.getStateChange() == 2) {
>                             FirstWizardPanel.this.resetToggleInsideAction();
>                         }
>                     }
>                 })).start();
>             }
>         });
>         tOutsideButton.addItemListener(new ItemListener() {
>             @Override
>             public void itemStateChanged(final ItemEvent ev) {
>                 (FirstWizardPanel.this.tOutsideThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (ev.getStateChange() == 1) {
>                             FirstWizardPanel.this.toggleOutsideAction();
>                         }
>                         else if (ev.getStateChange() == 2) {
>                             FirstWizardPanel.this.resetToggleOutsideAction();
>                         }
>                     }
>                 })).start();
>             }
>         });
>         enableButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (FirstWizardPanel.this.enableThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         FirstWizardPanel.this.enableSpots();
>                     }
>                 })).start();
>             }
>         });
>         disableButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (FirstWizardPanel.this.disableThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         FirstWizardPanel.this.disableSpots();
>                     }
>                 })).start();
>             }
>         });
>         sliderMin.addChangeListener(new ChangeListener() {
>             @Override
>             public void stateChanged(final ChangeEvent e) {
>                 (FirstWizardPanel.this.slMinThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         FirstWizardPanel.this.filterMin.setValue(sliderMin.getValue());
>                         intervalMarker.setStartValue((double)sliderMin.getValue());
>                     }
>                 })).start();
>             }
>         });
>         this.filterMin.addChangeListener(new ChangeListener() {
>             @Override
>             public void stateChanged(final ChangeEvent e) {
>                 (FirstWizardPanel.this.filterMinThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         sliderMin.setValue((int)FirstWizardPanel.this.filterMin.getValue());
>                         intervalMarker.setStartValue((double)(int)FirstWizardPanel.this.filterMin.getValue());
>                     }
>                 })).start();
>             }
>         });
>         sliderMax.addChangeListener(new ChangeListener() {
>             @Override
>             public void stateChanged(final ChangeEvent e) {
>                 (FirstWizardPanel.this.slMaxThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         FirstWizardPanel.this.filterMax.setValue(sliderMax.getValue());
>                         intervalMarker.setEndValue((double)sliderMax.getValue());
>                     }
>                 })).start();
>             }
>         });
>         this.filterMax.addChangeListener(new ChangeListener() {
>             @Override
>             public void stateChanged(final ChangeEvent e) {
>                 (FirstWizardPanel.this.filterMaxThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         sliderMax.setValue((int)FirstWizardPanel.this.filterMax.getValue());
>                         intervalMarker.setEndValue((double)(int)FirstWizardPanel.this.filterMax.getValue());
>                     }
>                 })).start();
>             }
>         });
>         FirstWizardPanel.comboFilters.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (FirstWizardPanel.this.filtersThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         final String selectedName = (String)FirstWizardPanel.comboFilters.getSelectedItem();
>                         final int selectedIndex = FirstWizardPanel.comboFilters.getSelectedIndex();
>                         double[] values = null;
>                         values = new double[FirstWizardPanel.tableSpot.getRowCount()];
>                         for (int r = 0; r < FirstWizardPanel.tableSpot.getRowCount(); ++r) {
>                             for (int c = 0; c < FirstWizardPanel.tableSpot.getColumnCount(); ++c) {
>                                 values[r] = Double.parseDouble((String)FirstWizardPanel.tableSpot.getValueAt(r, selectedIndex + 2));
>                             }
>                         }
>                         double max = values[0];
>                         for (int i = 1; i < values.length; ++i) {
>                             if (values[i] > max) {
>                                 max = values[i];
>                             }
>                         }
>                         sliderMin.setMinimum(0);
>                         sliderMin.setMaximum((int)max);
>                         sliderMax.setMinimum(0);
>                         sliderMax.setMaximum((int)max);
>                         FirstWizardPanel.this.hs2.addHistogramSeries(selectedName, values, (int)max, intervalMarker);
>                     }
>                 })).start();
>             }
>         });
>         this.checkRPicker.addItemListener(new ItemListener() {
>             @Override
>             public void itemStateChanged(final ItemEvent e) {
>                 (FirstWizardPanel.this.pickerThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (e.getStateChange() == 1) {
>                             FirstWizardPanel.command = "enable";
>                         }
>                         if (e.getStateChange() == 2) {
>                             FirstWizardPanel.command = null;
>                             ProcessTrackMateXml.selectionModel.clearSpotSelection();
>                             ProcessTrackMateXml.selectionModel.clearSelection();
>                         }
>                     }
>                 })).start();
>             }
>         });
>         classButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (FirstWizardPanel.this.classThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         ColorEditorSpot.myFrame.setVisible(true);
>                         colorEditor.setClassAction();
>                     }
>                 })).start();
>             }
>         });
>         remClassButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (FirstWizardPanel.this.remClassThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         final String classSelectedValue = FirstWizardPanel.classList.getSelectedValue();
>                         final int[] classSelectedIndex = FirstWizardPanel.classList.getSelectedIndices();
>                         for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
>                             if (((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1))).getText().equals(classSelectedValue)) {
>                                 FirstWizardPanel.modelSpot.setValueAt(FirstWizardPanel.labelReset, i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
>                             }
>                         }
>                         for (int i = 0; i < classSelectedIndex.length; ++i) {
>                             FirstWizardPanel.modelListClass.removeElementAt(classSelectedIndex[i]);
>                         }
>                     }
>                 })).start();
>             }
>         });
>         addButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (FirstWizardPanel.this.addThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         final List<String> listFilters = new ArrayList<String>();
>                         if (FirstWizardPanel.featureList.getModel().getSize() < 1) {
>                             FirstWizardPanel.modelListFeature.addElement(String.valueOf(FirstWizardPanel.comboFilters.getSelectedItem()) + ":  [" + FirstWizardPanel.this.filterMin.getValue() + "," + FirstWizardPanel.this.filterMax.getValue() + "]");
>                         }
>                         if (FirstWizardPanel.featureList.getModel().getSize() >= 1) {
>                             for (int i = 0; i < FirstWizardPanel.featureList.getModel().getSize(); ++i) {
>                                 listFilters.add(String.valueOf(FirstWizardPanel.featureList.getModel().getElementAt(i).substring(0, FirstWizardPanel.featureList.getModel().getElementAt(i).lastIndexOf(":"))));
>                             }
>                             if (!listFilters.contains(FirstWizardPanel.comboFilters.getSelectedItem().toString())) {
>                                 FirstWizardPanel.modelListFeature.addElement(String.valueOf(FirstWizardPanel.comboFilters.getSelectedItem()) + ":  [" + FirstWizardPanel.this.filterMin.getValue() + "," + FirstWizardPanel.this.filterMax.getValue() + "]");
>                             }
>                             if (listFilters.contains(FirstWizardPanel.comboFilters.getSelectedItem().toString())) {
>                                 return;
>                             }
>                         }
>                     }
>                 })).start();
>             }
>         });
>         remButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (FirstWizardPanel.this.remThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         try {
>                             final int[] indexes = FirstWizardPanel.featureList.getSelectedIndices();
>                             for (int i = 0; i < indexes.length; ++i) {
>                                 FirstWizardPanel.modelListFeature.remove(indexes[i]);
>                             }
>                         }
>                         catch (Exception e1) {
>                             e1.printStackTrace();
>                         }
>                     }
>                 })).start();
>             }
>         });
>     }
>     
>     public void toggleOutsideAction() {
>         Roi mainRoi = null;
>         if (IJ.getImage().getRoi().getType() == 0) {
>             mainRoi = IJ.getImage().getRoi();
>         }
>         this.indexesTO = new ArrayList<Integer>();
>         for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
>             if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(5)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(6)).toString()))) == Boolean.FALSE) {
>                 this.indexesTO.add(i);
>                 FirstWizardPanel.modelSpot.setValueAt(false, i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(0));
>                 final int spotID = Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(i, 2));
>                 final Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
>                 if (spot != null) {
>                     spot.putFeature("VISIBILITY", SpotCollection.ZERO);
>                     ProcessTrackMateXml.model.endUpdate();
>                     ProcessTrackMateXml.displayer.refresh();
>                 }
>             }
>         }
>     }
>     
>     public void resetToggleOutsideAction() {
>         for (int row = 0; row < FirstWizardPanel.modelSpot.getRowCount(); ++row) {
>             FirstWizardPanel.modelSpot.setValueAt(true, FirstWizardPanel.tableSpot.convertRowIndexToModel(row), FirstWizardPanel.tableSpot.convertColumnIndexToModel(0));
>             final int spotID = Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(row, 2));
>             final Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
762,764c776,778
<                spot.putFeature("VISIBILITY", SpotCollection.ZERO);
<                ProcessTrackMateXml.model.endUpdate();
<                ProcessTrackMateXml.displayer.refresh();
---
>                 spot.putFeature("VISIBILITY", SpotCollection.ONE);
>                 ProcessTrackMateXml.model.endUpdate();
>                 ProcessTrackMateXml.displayer.refresh();
766,798c780,808
<          }
<       }
< 
<    }
< 
<    public void resetToggleOutsideAction() {
<       for(int row = 0; row < modelSpot.getRowCount(); ++row) {
<          modelSpot.setValueAt(true, tableSpot.convertRowIndexToModel(row), tableSpot.convertColumnIndexToModel(0));
<          int spotID = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
<          Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
<          if (spot != null) {
<             spot.putFeature("VISIBILITY", SpotCollection.ONE);
<             ProcessTrackMateXml.model.endUpdate();
<             ProcessTrackMateXml.displayer.refresh();
<          }
<       }
< 
<    }
< 
<    public void toggleInsideAction() {
<       Roi mainRoi = null;
<       if (IJ.getImage().getRoi().getType() == 0) {
<          mainRoi = IJ.getImage().getRoi();
<       }
< 
<       this.indexesTI = new ArrayList();
< 
<       for(int i = 0; i < modelSpot.getRowCount(); ++i) {
<          if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(5)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(6)).toString()))) == Boolean.TRUE) {
<             this.indexesTI.add(i);
<             modelSpot.setValueAt(false, i, tableSpot.convertColumnIndexToModel(0));
<             int spotID = Integer.parseInt((String)tableSpot.getValueAt(i, 2));
<             Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
---
>         }
>     }
>     
>     public void toggleInsideAction() {
>         Roi mainRoi = null;
>         if (IJ.getImage().getRoi().getType() == 0) {
>             mainRoi = IJ.getImage().getRoi();
>         }
>         this.indexesTI = new ArrayList<Integer>();
>         for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
>             if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(5)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(6)).toString()))) == Boolean.TRUE) {
>                 this.indexesTI.add(i);
>                 FirstWizardPanel.modelSpot.setValueAt(false, i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(0));
>                 final int spotID = Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(i, 2));
>                 final Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
>                 if (spot != null) {
>                     spot.putFeature("VISIBILITY", SpotCollection.ZERO);
>                     ProcessTrackMateXml.model.endUpdate();
>                     ProcessTrackMateXml.displayer.refresh();
>                 }
>             }
>         }
>     }
>     
>     public void resetToggleInsideAction() {
>         for (int row = 0; row < FirstWizardPanel.modelSpot.getRowCount(); ++row) {
>             FirstWizardPanel.modelSpot.setValueAt(true, FirstWizardPanel.tableSpot.convertRowIndexToModel(row), FirstWizardPanel.tableSpot.convertColumnIndexToModel(0));
>             final int spotID = Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(row, 2));
>             final Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
800,802c810,812
<                spot.putFeature("VISIBILITY", SpotCollection.ZERO);
<                ProcessTrackMateXml.model.endUpdate();
<                ProcessTrackMateXml.displayer.refresh();
---
>                 spot.putFeature("VISIBILITY", SpotCollection.ONE);
>                 ProcessTrackMateXml.model.endUpdate();
>                 ProcessTrackMateXml.displayer.refresh();
804,884c814,868
<          }
<       }
< 
<    }
< 
<    public void resetToggleInsideAction() {
<       for(int row = 0; row < modelSpot.getRowCount(); ++row) {
<          modelSpot.setValueAt(true, tableSpot.convertRowIndexToModel(row), tableSpot.convertColumnIndexToModel(0));
<          int spotID = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
<          Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
<          if (spot != null) {
<             spot.putFeature("VISIBILITY", SpotCollection.ONE);
<             ProcessTrackMateXml.model.endUpdate();
<             ProcessTrackMateXml.displayer.refresh();
<          }
<       }
< 
<    }
< 
<    public void paintAndDisableAction() {
<       this.indexesToReset = new ArrayList();
<       this.spotID = new ArrayList();
<       this.spots = new ArrayList();
< 
<       int row;
<       for(row = 0; row < modelSpot.getRowCount(); ++row) {
<          if (((JLabel)modelSpot.getValueAt(row, tableSpot.convertColumnIndexToModel(1))).getBackground().equals(new Color(214, 217, 223)) == Boolean.TRUE) {
<             this.indexesToReset.add(row);
<             modelSpot.setValueAt(false, row, tableSpot.convertColumnIndexToModel(0));
<             this.spotID.add(Integer.parseInt((String)tableSpot.getValueAt(row, 2)));
<          }
<       }
< 
<       for(row = 0; row < this.indexesToReset.size(); ++row) {
<          int spotID = Integer.parseInt((String)tableSpot.getValueAt((Integer)this.indexesToReset.get(row), 2));
<          Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
<          if (spot != null) {
<             spot.putFeature("VISIBILITY", SpotCollection.ZERO);
<             ProcessTrackMateXml.model.endUpdate();
<             ProcessTrackMateXml.displayer.refresh();
<          }
<       }
< 
<    }
< 
<    public void resetAndEnableAction() {
<       int row;
<       for(row = 0; row < this.indexesToReset.size(); ++row) {
<          modelSpot.setValueAt(true, tableSpot.convertRowIndexToModel((Integer)this.indexesToReset.get(row)), tableSpot.convertColumnIndexToModel(0));
<       }
< 
<       for(row = 0; row < this.indexesToReset.size(); ++row) {
<          int spotID = Integer.parseInt((String)tableSpot.getValueAt((Integer)this.indexesToReset.get(row), 2));
<          Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
<          if (spot != null) {
<             spot.putFeature("VISIBILITY", SpotCollection.ONE);
<             ProcessTrackMateXml.model.endUpdate();
<             ProcessTrackMateXml.displayer.refresh();
<          }
<       }
< 
<    }
< 
<    public void enableSpots() {
<       ListSelectionModel lsm = tableSpot.getSelectionModel();
<       int[] selectedIndices = tableSpot.getSelectedRows();
< 
<       int selStart;
<       for(selStart = 0; selStart < selectedIndices.length; ++selStart) {
<          tableSpot.setValueAt(true, selectedIndices[selStart], 0);
<       }
< 
<       selStart = lsm.getMinSelectionIndex();
<       int selEnd = lsm.getMaxSelectionIndex();
<       if (selStart >= 0 && selEnd >= 0) {
<          int minLine = Math.min(selStart, selEnd);
<          int maxLine = Math.max(selStart, selEnd);
< 
<          for(int row = minLine; row <= maxLine; ++row) {
<             int spotIDEnable = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
<             Spot spotEnable = ProcessTrackMateXml.model.getSpots().search(spotIDEnable);
---
>         }
>     }
>     
>     public void paintAndDisableAction() {
>         this.indexesToReset = new ArrayList<Integer>();
>         this.spotID = new ArrayList<Integer>();
>         this.spots = new ArrayList<Spot>();
>         for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
>             if (((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1))).getBackground().equals(new Color(214, 217, 223)) == Boolean.TRUE) {
>                 this.indexesToReset.add(i);
>                 FirstWizardPanel.modelSpot.setValueAt(false, i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(0));
>                 this.spotID.add(Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(i, 2)));
>             }
>         }
>         for (int row = 0; row < this.indexesToReset.size(); ++row) {
>             final int spotID = Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(this.indexesToReset.get(row), 2));
>             final Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
>             if (spot != null) {
>                 spot.putFeature("VISIBILITY", SpotCollection.ZERO);
>                 ProcessTrackMateXml.model.endUpdate();
>                 ProcessTrackMateXml.displayer.refresh();
>             }
>         }
>     }
>     
>     public void resetAndEnableAction() {
>         for (int i = 0; i < this.indexesToReset.size(); ++i) {
>             FirstWizardPanel.modelSpot.setValueAt(true, FirstWizardPanel.tableSpot.convertRowIndexToModel(this.indexesToReset.get(i)), FirstWizardPanel.tableSpot.convertColumnIndexToModel(0));
>         }
>         for (int row = 0; row < this.indexesToReset.size(); ++row) {
>             final int spotID = Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(this.indexesToReset.get(row), 2));
>             final Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
>             if (spot != null) {
>                 spot.putFeature("VISIBILITY", SpotCollection.ONE);
>                 ProcessTrackMateXml.model.endUpdate();
>                 ProcessTrackMateXml.displayer.refresh();
>             }
>         }
>     }
>     
>     public void enableSpots() {
>         final ListSelectionModel lsm = FirstWizardPanel.tableSpot.getSelectionModel();
>         final int[] selectedIndices = FirstWizardPanel.tableSpot.getSelectedRows();
>         for (int i = 0; i < selectedIndices.length; ++i) {
>             FirstWizardPanel.tableSpot.setValueAt(true, selectedIndices[i], 0);
>         }
>         final int selStart = lsm.getMinSelectionIndex();
>         final int selEnd = lsm.getMaxSelectionIndex();
>         if (selStart < 0 || selEnd < 0) {
>             return;
>         }
>         final int minLine = Math.min(selStart, selEnd);
>         for (int maxLine = Math.max(selStart, selEnd), row = minLine; row <= maxLine; ++row) {
>             final int spotIDEnable = Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(row, 2));
>             final Spot spotEnable = ProcessTrackMateXml.model.getSpots().search(spotIDEnable);
886,888c870,872
<                spotEnable.putFeature("VISIBILITY", SpotCollection.ONE);
<                ProcessTrackMateXml.model.endUpdate();
<                ProcessTrackMateXml.displayer.refresh();
---
>                 spotEnable.putFeature("VISIBILITY", SpotCollection.ONE);
>                 ProcessTrackMateXml.model.endUpdate();
>                 ProcessTrackMateXml.displayer.refresh();
890,906c874,887
<          }
< 
<       }
<    }
< 
<    public void disableSpots() {
<       ListSelectionModel lsm = tableSpot.getSelectionModel();
<       int selStart = lsm.getMinSelectionIndex();
<       int selEnd = lsm.getMaxSelectionIndex();
<       if (selStart >= 0 && selEnd >= 0) {
<          int minLine = Math.min(selStart, selEnd);
<          int maxLine = Math.max(selStart, selEnd);
< 
<          int i;
<          for(int row = minLine; row <= maxLine; ++row) {
<             i = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
<             Spot spot = ProcessTrackMateXml.model.getSpots().search(i);
---
>         }
>     }
>     
>     public void disableSpots() {
>         final ListSelectionModel lsm = FirstWizardPanel.tableSpot.getSelectionModel();
>         final int selStart = lsm.getMinSelectionIndex();
>         final int selEnd = lsm.getMaxSelectionIndex();
>         if (selStart < 0 || selEnd < 0) {
>             return;
>         }
>         final int minLine = Math.min(selStart, selEnd);
>         for (int maxLine = Math.max(selStart, selEnd), row = minLine; row <= maxLine; ++row) {
>             final int spotID = Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(row, 2));
>             final Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
908,910c889,891
<                spot.putFeature("VISIBILITY", SpotCollection.ZERO);
<                ProcessTrackMateXml.model.endUpdate();
<                ProcessTrackMateXml.displayer.refresh();
---
>                 spot.putFeature("VISIBILITY", SpotCollection.ZERO);
>                 ProcessTrackMateXml.model.endUpdate();
>                 ProcessTrackMateXml.displayer.refresh();
912,930c893,910
<          }
< 
<          int[] selectedIndices = tableSpot.getSelectedRows();
< 
<          for(i = 0; i < selectedIndices.length; ++i) {
<             tableSpot.setValueAt(false, selectedIndices[i], 0);
<          }
< 
<       }
<    }
< 
<    public static void createSpotTable() {
<       modelSpot = new DefaultTableModel(ProcessTrackMateXml.dataSpot, ProcessTrackMateXml.columnHeadersSpot) {
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
---
>         }
>         final int[] selectedIndices = FirstWizardPanel.tableSpot.getSelectedRows();
>         for (int i = 0; i < selectedIndices.length; ++i) {
>             FirstWizardPanel.tableSpot.setValueAt(false, selectedIndices[i], 0);
>         }
>     }
>     
>     public static void createSpotTable() {
>         (FirstWizardPanel.modelSpot = new DefaultTableModel(ProcessTrackMateXml.dataSpot, ProcessTrackMateXml.columnHeadersSpot) {
>             @Override
>             public Class<?> getColumnClass(final int column) {
>                 if (this.getRowCount() > 0) {
>                     final Object value = this.getValueAt(0, column);
>                     if (value != null) {
>                         return this.getValueAt(0, column).getClass();
>                     }
>                 }
>                 return super.getColumnClass(column);
932,1049c912,1011
< 
<             return super.getColumnClass(column);
<          }
<       };
<       modelSpot.addColumn("Enable");
<       tableSpot.setModel(modelSpot);
<       tableSpot.moveColumn(tableSpot.getColumnCount() - 1, 0);
<       tableSpot.setSelectionBackground(new Color(229, 255, 204));
<       tableSpot.setSelectionForeground(new Color(0, 102, 0));
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableSpot.setDefaultRenderer(String.class, centerRenderer);
<       tableSpot.setAutoResizeMode(0);
<       tableSpot.setRowHeight(45);
<       tableSpot.setAutoCreateRowSorter(true);
<       tableSpot.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
< 
<       int i;
<       for(i = 0; i < tableSpot.getColumnCount(); ++i) {
<          tableSpot.getColumnModel().getColumn(i).setPreferredWidth(90);
<       }
< 
<       for(i = 16; i < tableSpot.getColumnCount(); ++i) {
<          tableSpot.getColumnModel().getColumn(i).setPreferredWidth(150);
<       }
< 
<       for(i = 0; i < tableSpot.getRowCount(); ++i) {
<          tableSpot.setValueAt(true, i, 0);
<       }
< 
<       tableSpot.getColumnModel().getColumn(1).setCellRenderer(new Renderer());
<       labelReset = new JLabel();
<       labelReset.setText("");
<       labelReset.setOpaque(true);
<       labelReset.setBackground(new Color(214, 217, 223));
< 
<       for(i = 0; i < modelSpot.getRowCount(); ++i) {
<          modelSpot.setValueAt(labelReset, i, tableSpot.convertColumnIndexToModel(1));
<       }
< 
<    }
< 
<    public void createMovieTable() {
<       tableImages.setSelectionBackground(new Color(229, 255, 204));
<       tableImages.setSelectionForeground(new Color(0, 102, 0));
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableImages.setDefaultRenderer(String.class, centerRenderer);
<       tableImages.setAutoResizeMode(0);
<       tableImages.setRowHeight(95);
<       tableImages.setAutoCreateRowSorter(true);
<       tableImages.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
< 
<       for(int i = 0; i < modelImages.getRowCount(); ++i) {
<          modelImages.setValueAt(this.icons[i], i, tableImages.convertColumnIndexToModel(0));
<          modelImages.setValueAt(imps[i].getShortTitle(), i, tableImages.convertColumnIndexToModel(1));
<          modelImages.setValueAt(imps[i].getTitle().substring(imps[i].getTitle().lastIndexOf(".")), i, tableImages.convertColumnIndexToModel(2));
<       }
< 
<    }
< 
<    public static Image getScaledImage(Image srcImg, int w, int h) {
<       BufferedImage resizedImg = new BufferedImage(w, h, 1);
<       Graphics2D g2 = resizedImg.createGraphics();
<       g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
<       g2.drawImage(srcImg, 0, 0, w, h, (ImageObserver)null);
<       g2.dispose();
<       return resizedImg;
<    }
< 
<    public static ImageIcon createImageIcon(String path) {
<       URL imgURL = FirstWizardPanel.class.getResource(path);
<       if (imgURL != null) {
<          return new ImageIcon(imgURL);
<       } else {
<          System.err.println("Couldn't find file: " + path);
<          return null;
<       }
<    }
< 
<    public ImagePlus extractTFrame(ImagePlus imp, int frame) {
<       int width = imp.getWidth();
<       int height = imp.getHeight();
<       int channels = imp.getNChannels();
<       int zslices = imp.getNSlices();
<       FileInfo fileInfo = imp.getOriginalFileInfo();
<       ImageStack stack2 = new ImageStack(width, height);
<       ImagePlus imp2 = new ImagePlus();
<       imp2.setTitle("T" + frame + "-" + imp.getTitle());
< 
<       for(int z = 1; z <= zslices; ++z) {
<          for(int c = 1; c <= channels; ++c) {
<             int sliceSix = imp.getStackIndex(c, z, frame);
<             stack2.addSlice("", imp.getStack().getProcessor(sliceSix));
<          }
<       }
< 
<       imp2.setStack(stack2);
<       imp2.setDimensions(channels, zslices, 1);
<       if (channels * zslices > 1) {
<          imp2.setOpenAsHyperStack(true);
<       }
< 
<       imp2.setFileInfo(fileInfo);
<       return imp2;
<    }
< 
<    private static final void transferCalibration(ImagePlus from, ImagePlus to) {
<       Calibration fc = from.getCalibration();
<       Calibration tc = to.getCalibration();
<       tc.setUnit(fc.getUnit());
<       tc.setTimeUnit(fc.getTimeUnit());
<       tc.frameInterval = fc.frameInterval;
<       double mag = from.getCanvas().getMagnification();
<       tc.pixelWidth = fc.pixelWidth / mag;
<       tc.pixelHeight = fc.pixelHeight / mag;
<       tc.pixelDepth = fc.pixelDepth;
<    }
---
>         }).addColumn("Enable");
>         FirstWizardPanel.tableSpot.setModel(FirstWizardPanel.modelSpot);
>         FirstWizardPanel.tableSpot.moveColumn(FirstWizardPanel.tableSpot.getColumnCount() - 1, 0);
>         FirstWizardPanel.tableSpot.setSelectionBackground(new Color(229, 255, 204));
>         FirstWizardPanel.tableSpot.setSelectionForeground(new Color(0, 102, 0));
>         final DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
>         centerRenderer.setHorizontalAlignment(0);
>         FirstWizardPanel.tableSpot.setDefaultRenderer(String.class, centerRenderer);
>         FirstWizardPanel.tableSpot.setAutoResizeMode(0);
>         FirstWizardPanel.tableSpot.setRowHeight(45);
>         FirstWizardPanel.tableSpot.setAutoCreateRowSorter(true);
>         FirstWizardPanel.tableSpot.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
>         for (int u = 0; u < FirstWizardPanel.tableSpot.getColumnCount(); ++u) {
>             FirstWizardPanel.tableSpot.getColumnModel().getColumn(u).setPreferredWidth(90);
>         }
>         for (int u = 16; u < FirstWizardPanel.tableSpot.getColumnCount(); ++u) {
>             FirstWizardPanel.tableSpot.getColumnModel().getColumn(u).setPreferredWidth(150);
>         }
>         for (int i = 0; i < FirstWizardPanel.tableSpot.getRowCount(); ++i) {
>             FirstWizardPanel.tableSpot.setValueAt(true, i, 0);
>         }
>         FirstWizardPanel.tableSpot.getColumnModel().getColumn(1).setCellRenderer(new Renderer());
>         (FirstWizardPanel.labelReset = new JLabel()).setText("");
>         FirstWizardPanel.labelReset.setOpaque(true);
>         FirstWizardPanel.labelReset.setBackground(new Color(214, 217, 223));
>         for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
>             FirstWizardPanel.modelSpot.setValueAt(FirstWizardPanel.labelReset, i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
>         }
>     }
>     
>     public void createMovieTable() {
>         FirstWizardPanel.tableImages.setSelectionBackground(new Color(229, 255, 204));
>         FirstWizardPanel.tableImages.setSelectionForeground(new Color(0, 102, 0));
>         final DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
>         centerRenderer.setHorizontalAlignment(0);
>         FirstWizardPanel.tableImages.setDefaultRenderer(String.class, centerRenderer);
>         FirstWizardPanel.tableImages.setAutoResizeMode(0);
>         FirstWizardPanel.tableImages.setRowHeight(95);
>         FirstWizardPanel.tableImages.setAutoCreateRowSorter(true);
>         FirstWizardPanel.tableImages.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
>         for (int i = 0; i < FirstWizardPanel.modelImages.getRowCount(); ++i) {
>             FirstWizardPanel.modelImages.setValueAt(this.icons[i], i, FirstWizardPanel.tableImages.convertColumnIndexToModel(0));
>             FirstWizardPanel.modelImages.setValueAt(FirstWizardPanel.imps[i].getShortTitle(), i, FirstWizardPanel.tableImages.convertColumnIndexToModel(1));
>             FirstWizardPanel.modelImages.setValueAt(FirstWizardPanel.imps[i].getTitle().substring(FirstWizardPanel.imps[i].getTitle().lastIndexOf(".")), i, FirstWizardPanel.tableImages.convertColumnIndexToModel(2));
>         }
>     }
>     
>     public static Image getScaledImage(final Image srcImg, final int w, final int h) {
>         final BufferedImage resizedImg = new BufferedImage(w, h, 1);
>         final Graphics2D g2 = resizedImg.createGraphics();
>         g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
>         g2.drawImage(srcImg, 0, 0, w, h, null);
>         g2.dispose();
>         return resizedImg;
>     }
>     
>     public static ImageIcon createImageIcon(final String path) {
>         final URL imgURL = FirstWizardPanel.class.getResource(path);
>         if (imgURL != null) {
>             return new ImageIcon(imgURL);
>         }
>         System.err.println("Couldn't find file: " + path);
>         return null;
>     }
>     
>     public ImagePlus extractTFrame(final ImagePlus imp, final int frame) {
>         final int width = imp.getWidth();
>         final int height = imp.getHeight();
>         final int channels = imp.getNChannels();
>         final int zslices = imp.getNSlices();
>         final FileInfo fileInfo = imp.getOriginalFileInfo();
>         final ImageStack stack2 = new ImageStack(width, height);
>         final ImagePlus imp2 = new ImagePlus();
>         imp2.setTitle("T" + frame + "-" + imp.getTitle());
>         for (int z = 1; z <= zslices; ++z) {
>             for (int c = 1; c <= channels; ++c) {
>                 final int sliceSix = imp.getStackIndex(c, z, frame);
>                 stack2.addSlice("", imp.getStack().getProcessor(sliceSix));
>             }
>         }
>         imp2.setStack(stack2);
>         imp2.setDimensions(channels, zslices, 1);
>         if (channels * zslices > 1) {
>             imp2.setOpenAsHyperStack(true);
>         }
>         imp2.setFileInfo(fileInfo);
>         return imp2;
>     }
>     
>     private static final void transferCalibration(final ImagePlus from, final ImagePlus to) {
>         final Calibration fc = from.getCalibration();
>         final Calibration tc = to.getCalibration();
>         tc.setUnit(fc.getUnit());
>         tc.setTimeUnit(fc.getTimeUnit());
>         tc.frameInterval = fc.frameInterval;
>         final double mag = from.getCanvas().getMagnification();
>         tc.pixelWidth = fc.pixelWidth / mag;
>         tc.pixelHeight = fc.pixelHeight / mag;
>         tc.pixelDepth = fc.pixelDepth;
>     }
diff -r TrackAnalyzer_/HistogramFilterVersion.java procyon/HistogramFilterVersion.java
1,5d0
< import java.awt.Color;
< import java.awt.Component;
< import java.awt.Dimension;
< import java.awt.Font;
< import java.awt.Paint;
7a3
> import java.awt.Component;
10,11d5
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartPanel;
12a7,10
> import org.jfree.chart.plot.Marker;
> import java.awt.Font;
> import java.awt.Dimension;
> import org.jfree.chart.plot.DrawingSupplier;
14c12,17
< import org.jfree.chart.plot.IntervalMarker;
---
> import java.awt.Color;
> import java.awt.Paint;
> import org.jfree.chart.renderer.xy.XYBarPainter;
> import org.jfree.chart.renderer.xy.StandardXYBarPainter;
> import org.jfree.data.xy.IntervalXYDataset;
> import org.jfree.chart.ChartFactory;
15a19,20
> import org.jfree.chart.plot.IntervalMarker;
> import org.jfree.chart.ChartPanel;
17d21
< import org.jfree.chart.renderer.xy.StandardXYBarPainter;
21,125c25,131
< public class HistogramFilterVersion {
<    private int BINS;
<    private HistogramDataset dataset;
<    private XYBarRenderer renderer;
<    private XYPlot plot;
<    private double[] values;
<    private String feature;
<    private ChartPanel panel;
<    public IntervalMarker intervalMarker;
< 
<    public ChartPanel createChartPanel(String feature, double[] values, int BINS, IntervalMarker intervalMarker) {
<       this.feature = feature;
<       this.values = values;
<       this.BINS = BINS;
<       this.intervalMarker = intervalMarker;
<       this.dataset = new HistogramDataset();
<       if (BINS != 0) {
<          this.dataset.addSeries(feature, values, BINS);
<       }
< 
<       JFreeChart chart = ChartFactory.createHistogram("", feature, "", this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       this.plot = (XYPlot)chart.getPlot();
<       this.renderer = (XYBarRenderer)this.plot.getRenderer();
<       this.renderer.setBarPainter(new StandardXYBarPainter());
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       this.plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       this.panel = new ChartPanel(chart);
<       this.panel.setPreferredSize(new Dimension(390, 180));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       Font font3 = new Font("Dialog", 2, 9);
<       this.plot.getDomainAxis().setLabelFont(font3);
<       this.plot.getRangeAxis().setLabelFont(font3);
<       this.plot.getRangeAxis().setTickLabelFont(font3);
<       this.plot.getDomainAxis().setTickLabelFont(font3);
<       chart.getLegend().setVisible(false);
<       this.plot.addDomainMarker(intervalMarker);
<       double x = (double)((float)(0.05D * this.plot.getDomainAxis().getRange().getLength()));
<       double y = (double)((float)(0.85D * this.plot.getRangeAxis().getUpperBound()));
<       return this.panel;
<    }
< 
<    public JPanel createControlPanel() {
<       JPanel panel = new JPanel();
<       return panel;
<    }
< 
<    public void addHistogramSeries(String feature, double[] values, int BINS, IntervalMarker intervalMarker) {
<       this.feature = feature;
<       this.values = values;
<       this.BINS = BINS;
<       this.intervalMarker = intervalMarker;
<       this.panel.removeAll();
<       this.dataset = new HistogramDataset();
<       if (BINS != 0) {
<          this.dataset.addSeries(feature, values, BINS);
<       }
< 
<       JFreeChart chart = ChartFactory.createHistogram("", feature, "COUNTING", this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       this.plot = (XYPlot)chart.getPlot();
<       this.renderer = (XYBarRenderer)this.plot.getRenderer();
<       this.renderer.setBarPainter(new StandardXYBarPainter());
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       this.plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       this.panel.setChart(chart);
<       this.panel.setPreferredSize(new Dimension(390, 180));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(false);
<       Font font3 = new Font("Dialog", 2, 10);
<       this.plot.getDomainAxis().setLabelFont(font3);
<       this.plot.getRangeAxis().setLabelFont(font3);
<       this.plot.getRangeAxis().setTickLabelFont(font3);
<       this.plot.getDomainAxis().setTickLabelFont(font3);
<       this.plot.addDomainMarker(intervalMarker);
<    }
< 
<    public void display() {
<       JFrame f = new JFrame("Histogram");
<       f.setDefaultCloseOperation(3);
<       f.add(this.createControlPanel(), "South");
<       f.pack();
<       f.setLocationRelativeTo((Component)null);
<       f.setVisible(true);
<    }
< 
<    public class VisibleAction extends AbstractAction {
<       private static final long serialVersionUID = 1L;
<       private final int i;
< 
<       public VisibleAction(int i) {
<          this.i = i;
<          this.putValue("Name", (String)HistogramFilterVersion.this.dataset.getSeriesKey(i));
<          this.putValue("SwingSelectedKey", true);
<          HistogramFilterVersion.this.renderer.setSeriesVisible(i, true);
<       }
< 
<       public void actionPerformed(ActionEvent e) {
<          HistogramFilterVersion.this.renderer.setSeriesVisible(this.i, !HistogramFilterVersion.this.renderer.getSeriesVisible(this.i));
<       }
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class HistogramFilterVersion
> {
>     private int BINS;
>     private HistogramDataset dataset;
>     private XYBarRenderer renderer;
>     private XYPlot plot;
>     private double[] values;
>     private String feature;
>     private ChartPanel panel;
>     public IntervalMarker intervalMarker;
>     
>     public ChartPanel createChartPanel(final String feature, final double[] values, final int BINS, final IntervalMarker intervalMarker) {
>         this.feature = feature;
>         this.values = values;
>         this.BINS = BINS;
>         this.intervalMarker = intervalMarker;
>         this.dataset = new HistogramDataset();
>         if (BINS != 0) {
>             this.dataset.addSeries((Comparable)feature, values, BINS);
>         }
>         final JFreeChart chart = ChartFactory.createHistogram("", feature, "", (IntervalXYDataset)this.dataset, PlotOrientation.VERTICAL, true, true, false);
>         this.plot = (XYPlot)chart.getPlot();
>         (this.renderer = (XYBarRenderer)this.plot.getRenderer()).setBarPainter((XYBarPainter)new StandardXYBarPainter());
>         final Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
>         this.plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
>         (this.panel = new ChartPanel(chart)).setPreferredSize(new Dimension(390, 180));
>         chart.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         this.plot.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         chart.getLegend().setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         this.panel.setMouseWheelEnabled(true);
>         final Font font3 = new Font("Dialog", 2, 9);
>         this.plot.getDomainAxis().setLabelFont(font3);
>         this.plot.getRangeAxis().setLabelFont(font3);
>         this.plot.getRangeAxis().setTickLabelFont(font3);
>         this.plot.getDomainAxis().setTickLabelFont(font3);
>         chart.getLegend().setVisible(false);
>         this.plot.addDomainMarker((Marker)intervalMarker);
>         final double x = (float)(0.05 * this.plot.getDomainAxis().getRange().getLength());
>         final double y = (float)(0.85 * this.plot.getRangeAxis().getUpperBound());
>         return this.panel;
>     }
>     
>     public JPanel createControlPanel() {
>         final JPanel panel = new JPanel();
>         return panel;
>     }
>     
>     public void addHistogramSeries(final String feature, final double[] values, final int BINS, final IntervalMarker intervalMarker) {
>         this.feature = feature;
>         this.values = values;
>         this.BINS = BINS;
>         this.intervalMarker = intervalMarker;
>         this.panel.removeAll();
>         this.dataset = new HistogramDataset();
>         if (BINS != 0) {
>             this.dataset.addSeries((Comparable)feature, values, BINS);
>         }
>         final JFreeChart chart = ChartFactory.createHistogram("", feature, "COUNTING", (IntervalXYDataset)this.dataset, PlotOrientation.VERTICAL, true, true, false);
>         this.plot = (XYPlot)chart.getPlot();
>         (this.renderer = (XYBarRenderer)this.plot.getRenderer()).setBarPainter((XYBarPainter)new StandardXYBarPainter());
>         final Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
>         this.plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
>         this.panel.setChart(chart);
>         this.panel.setPreferredSize(new Dimension(390, 180));
>         chart.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         this.plot.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         chart.getLegend().setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         this.panel.setMouseWheelEnabled(true);
>         chart.getLegend().setVisible(false);
>         final Font font3 = new Font("Dialog", 2, 10);
>         this.plot.getDomainAxis().setLabelFont(font3);
>         this.plot.getRangeAxis().setLabelFont(font3);
>         this.plot.getRangeAxis().setTickLabelFont(font3);
>         this.plot.getDomainAxis().setTickLabelFont(font3);
>         this.plot.addDomainMarker((Marker)intervalMarker);
>     }
>     
>     public void display() {
>         final JFrame f = new JFrame("Histogram");
>         f.setDefaultCloseOperation(3);
>         f.add(this.createControlPanel(), "South");
>         f.pack();
>         f.setLocationRelativeTo(null);
>         f.setVisible(true);
>     }
>     
>     public class VisibleAction extends AbstractAction
>     {
>         private static final long serialVersionUID = 1L;
>         private final int i;
>         
>         public VisibleAction(final int i) {
>             this.i = i;
>             this.putValue("Name", HistogramFilterVersion.this.dataset.getSeriesKey(i));
>             this.putValue("SwingSelectedKey", true);
>             HistogramFilterVersion.this.renderer.setSeriesVisible(i, Boolean.valueOf(true));
>         }
>         
>         @Override
>         public void actionPerformed(final ActionEvent e) {
>             HistogramFilterVersion.this.renderer.setSeriesVisible(this.i, Boolean.valueOf(!HistogramFilterVersion.this.renderer.getSeriesVisible(this.i)));
>         }
>     }
diff -r TrackAnalyzer_/ImagePlusReaderModified.java procyon/ImagePlusReaderModified.java
1,12c1
< import ij.ImagePlus;
< import ij.ImageStack;
< import ij.io.FileInfo;
< import ij.process.ImageProcessor;
< import ij.process.LUT;
< import java.awt.image.ColorModel;
< import java.io.File;
< import java.io.IOException;
< import java.util.ArrayList;
< import java.util.Iterator;
< import java.util.List;
< import java.util.Vector;
---
> import loci.formats.FilePattern;
14,18d2
< import loci.common.Region;
< import loci.common.StatusEvent;
< import loci.common.StatusListener;
< import loci.common.StatusReporter;
< import loci.common.services.DependencyException;
20,25c4,5
< import loci.common.services.ServiceFactory;
< import loci.formats.FilePattern;
< import loci.formats.FormatException;
< import loci.formats.IFormatReader;
< import loci.formats.cache.CacheException;
< import loci.formats.meta.IMetadata;
---
> import loci.common.services.DependencyException;
> import loci.formats.meta.MetadataRetrieve;
26a7,8
> import loci.common.services.ServiceFactory;
> import java.io.File;
28d9
< import loci.plugins.in.Calibrator;
31,34d11
< import loci.plugins.in.ImportProcess;
< import loci.plugins.in.ImporterOptions;
< import loci.plugins.util.BFVirtualStack;
< import loci.plugins.util.ImageProcessorReader;
35a13,21
> import loci.common.Region;
> import loci.formats.meta.IMetadata;
> import java.io.IOException;
> import loci.formats.FormatException;
> import loci.formats.cache.CacheException;
> import loci.plugins.util.BFVirtualStack;
> import ij.io.FileInfo;
> import loci.formats.IFormatReader;
> import loci.plugins.in.Calibrator;
36a23,37
> import loci.plugins.util.ImageProcessorReader;
> import loci.plugins.in.ImporterOptions;
> import java.awt.image.ColorModel;
> import ij.ImageStack;
> import ij.process.LUT;
> import java.util.ArrayList;
> import ij.process.ImageProcessor;
> import java.util.Iterator;
> import loci.common.StatusEvent;
> import ij.ImagePlus;
> import java.util.Vector;
> import loci.common.StatusListener;
> import java.util.List;
> import loci.plugins.in.ImportProcess;
> import loci.common.StatusReporter;
38,97c39,101
< public class ImagePlusReaderModified implements StatusReporter {
<    public static final String PROP_SERIES = "Series";
<    public static final String PROP_LUT = "LUT-";
<    public ImportProcess process;
<    public List<StatusListener> listeners = new Vector();
<    public long startTime;
<    public long time;
< 
<    public ImagePlusReaderModified(ImportProcess process) {
<       this.process = process;
<    }
< 
<    public ImagePlus[] openImagePlus() {
<       List<ImagePlus> imps = this.readImages();
<       return (ImagePlus[])imps.toArray(new ImagePlus[0]);
<    }
< 
<    public ImagePlus[] openThumbImagePlus() {
<       List<ImagePlus> imps = this.readThumbImages();
<       return (ImagePlus[])imps.toArray(new ImagePlus[imps.size()]);
<    }
< 
<    public void addStatusListener(StatusListener l) {
<       this.listeners.add(l);
<    }
< 
<    public void removeStatusListener(StatusListener l) {
<       this.listeners.remove(l);
<    }
< 
<    public void notifyListeners(StatusEvent e) {
<       Iterator var3 = this.listeners.iterator();
< 
<       while(var3.hasNext()) {
<          StatusListener l = (StatusListener)var3.next();
<          l.statusUpdated(e);
<       }
< 
<    }
< 
<    public static ImagePlus createImage(String title, List<ImageProcessor> procs) {
<       List<LUT> luts = new ArrayList();
<       ImageStack stack = createStack(procs, (List)null, luts);
<       return createImage(title, stack, luts);
<    }
< 
<    public static ImagePlus createImage(String title, ImageStack stack, List<LUT> luts) {
<       ImagePlus imp = new ImagePlus(title, stack);
<       saveLUTs(imp, luts);
<       return imp;
<    }
< 
<    public static ImageStack createStack(List<ImageProcessor> procs, List<String> labels, List<LUT> luts) {
<       if (procs != null && procs.size() != 0) {
<          ImageProcessor ip0 = (ImageProcessor)procs.get(0);
<          ImageStack stack = new ImageStack(ip0.getWidth(), ip0.getHeight());
< 
<          for(int i = 0; i < procs.size(); ++i) {
<             ImageProcessor ip = (ImageProcessor)procs.get(i);
<             String label = labels == null ? null : (String)labels.get(i);
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class ImagePlusReaderModified implements StatusReporter
> {
>     public static final String PROP_SERIES = "Series";
>     public static final String PROP_LUT = "LUT-";
>     public ImportProcess process;
>     public List<StatusListener> listeners;
>     public long startTime;
>     public long time;
>     
>     public ImagePlusReaderModified(final ImportProcess process) {
>         this.listeners = new Vector<StatusListener>();
>         this.process = process;
>     }
>     
>     public ImagePlus[] openImagePlus() {
>         final List<ImagePlus> imps = this.readImages();
>         return imps.<ImagePlus>toArray(new ImagePlus[0]);
>     }
>     
>     public ImagePlus[] openThumbImagePlus() {
>         final List<ImagePlus> imps = this.readThumbImages();
>         return imps.<ImagePlus>toArray(new ImagePlus[imps.size()]);
>     }
>     
>     public void addStatusListener(final StatusListener l) {
>         this.listeners.add(l);
>     }
>     
>     public void removeStatusListener(final StatusListener l) {
>         this.listeners.remove(l);
>     }
>     
>     public void notifyListeners(final StatusEvent e) {
>         for (final StatusListener l : this.listeners) {
>             l.statusUpdated(e);
>         }
>     }
>     
>     public static ImagePlus createImage(final String title, final List<ImageProcessor> procs) {
>         final List<LUT> luts = new ArrayList<LUT>();
>         final ImageStack stack = createStack(procs, null, luts);
>         return createImage(title, stack, luts);
>     }
>     
>     public static ImagePlus createImage(final String title, final ImageStack stack, final List<LUT> luts) {
>         final ImagePlus imp = new ImagePlus(title, stack);
>         saveLUTs(imp, luts);
>         return imp;
>     }
>     
>     public static ImageStack createStack(final List<ImageProcessor> procs, final List<String> labels, final List<LUT> luts) {
>         if (procs == null || procs.size() == 0) {
>             return null;
>         }
>         final ImageProcessor ip0 = procs.get(0);
>         final ImageStack stack = new ImageStack(ip0.getWidth(), ip0.getHeight());
>         for (int i = 0; i < procs.size(); ++i) {
>             final ImageProcessor ip2 = procs.get(i);
>             final String label = (labels == null) ? null : labels.get(i);
99,106c103,111
<                ColorModel cm = ip.getColorModel();
<                if (cm instanceof LUT) {
<                   LUT lut = (LUT)cm;
<                   luts.add(lut);
<                   ip.setColorModel(ip.getDefaultColorModel());
<                } else {
<                   luts.add((Object)null);
<                }
---
>                 final ColorModel cm = ip2.getColorModel();
>                 if (cm instanceof LUT) {
>                     final LUT lut = (LUT)cm;
>                     luts.add(lut);
>                     ip2.setColorModel((ColorModel)ip2.getDefaultColorModel());
>                 }
>                 else {
>                     luts.add(null);
>                 }
108,225c113,134
< 
<             stack.addSlice(label, ip);
<          }
< 
<          return stack;
<       } else {
<          return null;
<       }
<    }
< 
<    public List<ImagePlus> readImages() {
<       return this.readImages(false);
<    }
< 
<    public List<ImagePlus> readThumbImages() {
<       return this.readImages(true);
<    }
< 
<    public List<ImagePlus> readImages(boolean thumbnail) {
<       ImporterOptions options = this.process.getOptions();
<       ImageProcessorReader reader = this.process.getReader();
<       List<ImagePlus> imps = new ArrayList();
<       this.startTiming();
< 
<       for(int s = 0; s < reader.getSeriesCount(); ++s) {
<          if (options.isSeriesOn(s)) {
<             ImagePlus imp = this.readImage(s, thumbnail);
<             imps.add(imp);
<          }
<       }
< 
<       List<ImagePlus> imps = this.concatenate(imps);
<       imps = this.applyColors(imps);
<       imps = this.splitDims(imps);
<       if (options.isVirtual()) {
<          this.process.getVirtualReader().setRefCount(imps.size());
<       }
< 
<       this.finishTiming();
<       return imps;
<    }
< 
<    public ImagePlus readImage(int s, boolean thumbnail) {
<       ImporterOptions options = this.process.getOptions();
<       int zCount = this.process.getZCount(s);
<       int cCount = this.process.getCCount(s);
<       int tCount = this.process.getTCount(s);
<       List<LUT> luts = new ArrayList();
<       ImageStack stack;
<       if (options.isVirtual()) {
<          stack = this.createVirtualStack(this.process, s, luts);
<       } else {
<          stack = this.readPlanes(this.process, s, luts, thumbnail);
<       }
< 
<       this.notifyListeners(new StatusEvent(1, 1, "Creating image"));
<       String seriesName = this.process.getOMEMetadata().getImageName(s);
<       String file = this.process.getCurrentFile();
<       IFormatReader reader = this.process.getReader();
<       String title = this.constructImageTitle(reader, file, seriesName, options.isGroupFiles());
<       Object imp;
<       if (stack.isVirtual()) {
<          VirtualImagePlus vip = new VirtualImagePlus(title, stack);
<          vip.setReader(reader);
<          imp = vip;
<          saveLUTs(vip, luts);
<       } else {
<          imp = createImage(title, stack, luts);
<       }
< 
<       String metadata = this.process.getOriginalMetadata().toString();
<       ((ImagePlus)imp).setProperty("Info", metadata);
<       ((ImagePlus)imp).setProperty("Series", s);
<       FileInfo fi = this.createFileInfo();
<       (new Calibrator(this.process)).applyCalibration((ImagePlus)imp);
<       ((ImagePlus)imp).setFileInfo(fi);
<       ((ImagePlus)imp).setDimensions(cCount, zCount, tCount);
<       boolean hyper = !options.isViewStandard();
<       ((ImagePlus)imp).setOpenAsHyperStack(hyper);
<       return (ImagePlus)imp;
<    }
< 
<    public ImageStack createVirtualStack(ImportProcess process, int s, List<LUT> luts) {
<       ImporterOptions options = process.getOptions();
<       ImageProcessorReader reader = process.getReader();
<       reader.setSeries(s);
<       int zCount = process.getZCount(s);
<       int cCount = process.getCCount(s);
<       int tCount = process.getTCount(s);
<       IMetadata meta = process.getOMEMetadata();
<       int imageCount = reader.getImageCount();
<       BFVirtualStack virtualStack = null;
< 
<       try {
<          virtualStack = new BFVirtualStack(options.getId(), reader, false, false, false);
<       } catch (CacheException var18) {
<          var18.printStackTrace();
<       } catch (FormatException var19) {
<          var19.printStackTrace();
<       } catch (IOException var20) {
<          var20.printStackTrace();
<       }
< 
<       int c;
<       for(c = 0; c < imageCount; ++c) {
<          String label = this.constructSliceLabel(c, reader, meta, s, zCount, cCount, tCount);
<          virtualStack.addSlice(label);
<       }
< 
<       if (luts != null) {
<          for(c = 0; c < cCount; ++c) {
<             int index = reader.getIndex(0, c, 0);
<             ImageProcessor ip = null;
< 
<             try {
<                ip = reader.openProcessors(index)[0];
<             } catch (IOException | FormatException var17) {
<                var17.printStackTrace();
---
>             stack.addSlice(label, ip2);
>         }
>         return stack;
>     }
>     
>     public List<ImagePlus> readImages() {
>         return this.readImages(false);
>     }
>     
>     public List<ImagePlus> readThumbImages() {
>         return this.readImages(true);
>     }
>     
>     public List<ImagePlus> readImages(final boolean thumbnail) {
>         final ImporterOptions options = this.process.getOptions();
>         final ImageProcessorReader reader = this.process.getReader();
>         List<ImagePlus> imps = new ArrayList<ImagePlus>();
>         this.startTiming();
>         for (int s = 0; s < reader.getSeriesCount(); ++s) {
>             if (options.isSeriesOn(s)) {
>                 final ImagePlus imp = this.readImage(s, thumbnail);
>                 imps.add(imp);
227,269c136,227
< 
<             ColorModel cm = ip.getColorModel();
<             LUT lut = cm instanceof LUT ? (LUT)cm : null;
<             luts.add(lut);
<          }
<       }
< 
<       return virtualStack;
<    }
< 
<    public ImageStack readPlanes(ImportProcess process, int s, List<LUT> luts, boolean thumbnail) {
<       ImageProcessorReader reader = process.getReader();
<       reader.setSeries(s);
<       int zCount = process.getZCount(s);
<       int cCount = process.getCCount(s);
<       int tCount = process.getTCount(s);
<       IMetadata meta = process.getOMEMetadata();
<       boolean[] load = this.getPlanesToLoad(s);
<       int current = 0;
<       int total = 0;
< 
<       for(int j = 0; j < load.length; ++j) {
<          if (load[j]) {
<             ++total;
<          }
<       }
< 
<       List<ImageProcessor> procs = new ArrayList();
<       List<String> labels = new ArrayList();
<       Region region = process.getCropRegion(s);
< 
<       for(int i = 0; i < load.length; ++i) {
<          if (load[i]) {
<             this.updateTiming(s, current, current++, total);
<             ImageProcessor[] p = this.readProcessors(process, i, region, thumbnail);
<             String label = this.constructSliceLabel(i, reader, meta, s, zCount, cCount, tCount);
<             ImageProcessor[] var22 = p;
<             int var21 = p.length;
< 
<             for(int var20 = 0; var20 < var21; ++var20) {
<                ImageProcessor ip = var22[var20];
<                procs.add(ip);
<                labels.add(label);
---
>         }
>         imps = this.concatenate(imps);
>         imps = this.applyColors(imps);
>         imps = this.splitDims(imps);
>         if (options.isVirtual()) {
>             this.process.getVirtualReader().setRefCount(imps.size());
>         }
>         this.finishTiming();
>         return imps;
>     }
>     
>     public ImagePlus readImage(final int s, final boolean thumbnail) {
>         final ImporterOptions options = this.process.getOptions();
>         final int zCount = this.process.getZCount(s);
>         final int cCount = this.process.getCCount(s);
>         final int tCount = this.process.getTCount(s);
>         final List<LUT> luts = new ArrayList<LUT>();
>         ImageStack stack;
>         if (options.isVirtual()) {
>             stack = this.createVirtualStack(this.process, s, luts);
>         }
>         else {
>             stack = this.readPlanes(this.process, s, luts, thumbnail);
>         }
>         this.notifyListeners(new StatusEvent(1, 1, "Creating image"));
>         final String seriesName = this.process.getOMEMetadata().getImageName(s);
>         final String file = this.process.getCurrentFile();
>         final IFormatReader reader = (IFormatReader)this.process.getReader();
>         final String title = this.constructImageTitle(reader, file, seriesName, options.isGroupFiles());
>         ImagePlus imp;
>         if (stack.isVirtual()) {
>             final VirtualImagePlus vip = new VirtualImagePlus(title, stack);
>             vip.setReader(reader);
>             imp = (ImagePlus)vip;
>             saveLUTs(imp, luts);
>         }
>         else {
>             imp = createImage(title, stack, luts);
>         }
>         final String metadata = this.process.getOriginalMetadata().toString();
>         imp.setProperty("Info", (Object)metadata);
>         imp.setProperty("Series", (Object)s);
>         final FileInfo fi = this.createFileInfo();
>         new Calibrator(this.process).applyCalibration(imp);
>         imp.setFileInfo(fi);
>         imp.setDimensions(cCount, zCount, tCount);
>         final boolean hyper = !options.isViewStandard();
>         imp.setOpenAsHyperStack(hyper);
>         return imp;
>     }
>     
>     public ImageStack createVirtualStack(final ImportProcess process, final int s, final List<LUT> luts) {
>         final ImporterOptions options = process.getOptions();
>         final ImageProcessorReader reader = process.getReader();
>         reader.setSeries(s);
>         final int zCount = process.getZCount(s);
>         final int cCount = process.getCCount(s);
>         final int tCount = process.getTCount(s);
>         final IMetadata meta = process.getOMEMetadata();
>         final int imageCount = reader.getImageCount();
>         BFVirtualStack virtualStack = null;
>         try {
>             virtualStack = new BFVirtualStack(options.getId(), (IFormatReader)reader, false, false, false);
>         }
>         catch (CacheException e) {
>             e.printStackTrace();
>         }
>         catch (FormatException e2) {
>             e2.printStackTrace();
>         }
>         catch (IOException e3) {
>             e3.printStackTrace();
>         }
>         for (int i = 0; i < imageCount; ++i) {
>             final String label = this.constructSliceLabel(i, reader, meta, s, zCount, cCount, tCount);
>             virtualStack.addSlice(label);
>         }
>         if (luts != null) {
>             for (int c = 0; c < cCount; ++c) {
>                 final int index = reader.getIndex(0, c, 0);
>                 ImageProcessor ip = null;
>                 try {
>                     ip = reader.openProcessors(index)[0];
>                 }
>                 catch (FormatException | IOException ex2) {
>                     final Exception ex;
>                     final Exception e4 = ex;
>                     e4.printStackTrace();
>                 }
>                 final ColorModel cm = ip.getColorModel();
>                 final LUT lut = (cm instanceof LUT) ? cm : null;
>                 luts.add(lut);
271,291c229,245
<          }
<       }
< 
<       return createStack(procs, labels, luts);
<    }
< 
<    public ImageProcessor[] readProcessors(ImportProcess process, int no, Region r, boolean thumbnail) {
<       ImageProcessorReader reader = process.getReader();
<       ImporterOptions options = process.getOptions();
<       boolean first = true;
< 
<       for(int i = 0; i < 5; ++i) {
<          String code = LuraWave.initLicenseCode();
< 
<          try {
<             if (thumbnail) {
<                try {
<                   return reader.openThumbProcessors(no);
<                } catch (IOException var12) {
<                   var12.printStackTrace();
<                }
---
>         }
>         return (ImageStack)virtualStack;
>     }
>     
>     public ImageStack readPlanes(final ImportProcess process, final int s, final List<LUT> luts, final boolean thumbnail) {
>         final ImageProcessorReader reader = process.getReader();
>         reader.setSeries(s);
>         final int zCount = process.getZCount(s);
>         final int cCount = process.getCCount(s);
>         final int tCount = process.getTCount(s);
>         final IMetadata meta = process.getOMEMetadata();
>         final boolean[] load = this.getPlanesToLoad(s);
>         int current = 0;
>         int total = 0;
>         for (int j = 0; j < load.length; ++j) {
>             if (load[j]) {
>                 ++total;
293c247,272
< 
---
>         }
>         final List<ImageProcessor> procs = new ArrayList<ImageProcessor>();
>         final List<String> labels = new ArrayList<String>();
>         final Region region = process.getCropRegion(s);
>         for (int i = 0; i < load.length; ++i) {
>             if (load[i]) {
>                 this.updateTiming(s, current, current++, total);
>                 final ImageProcessor[] p = this.readProcessors(process, i, region, thumbnail);
>                 final String label = this.constructSliceLabel(i, reader, meta, s, zCount, cCount, tCount);
>                 ImageProcessor[] array;
>                 for (int length = (array = p).length, k = 0; k < length; ++k) {
>                     final ImageProcessor ip = array[k];
>                     procs.add(ip);
>                     labels.add(label);
>                 }
>             }
>         }
>         return createStack(procs, labels, luts);
>     }
>     
>     public ImageProcessor[] readProcessors(final ImportProcess process, final int no, final Region r, final boolean thumbnail) {
>         final ImageProcessorReader reader = process.getReader();
>         final ImporterOptions options = process.getOptions();
>         boolean first = true;
>         for (int i = 0; i < 5; ++i) {
>             String code = LuraWave.initLicenseCode();
295,297c274,326
<                return reader.openProcessors(no, r.x, r.y, r.width, r.height);
<             } catch (IOException var11) {
<                var11.printStackTrace();
---
>                 if (thumbnail) {
>                     try {
>                         return reader.openThumbProcessors(no);
>                     }
>                     catch (IOException e) {
>                         e.printStackTrace();
>                     }
>                 }
>                 try {
>                     return reader.openProcessors(no, r.x, r.y, r.width, r.height);
>                 }
>                 catch (IOException e) {
>                     e.printStackTrace();
>                 }
>             }
>             catch (FormatException exc) {
>                 code = LuraWave.promptLicenseCode(code, first);
>                 if (first) {
>                     first = false;
>                 }
>             }
>         }
>         return null;
>     }
>     
>     public List<ImagePlus> concatenate(List<ImagePlus> imps) {
>         final ImporterOptions options = this.process.getOptions();
>         if (options.isConcatenate()) {
>             imps = (List<ImagePlus>)new Concatenator().concatenate((List)imps);
>         }
>         return imps;
>     }
>     
>     public List<ImagePlus> applyColors(final List<ImagePlus> imps) {
>         return (List<ImagePlus>)new Colorizer(this.process).applyColors((List)imps);
>     }
>     
>     public List<ImagePlus> splitDims(List<ImagePlus> imps) {
>         final ImporterOptions options = this.process.getOptions();
>         final boolean sliceC = options.isSplitChannels();
>         final boolean sliceZ = options.isSplitFocalPlanes();
>         final boolean sliceT = options.isSplitTimepoints();
>         if (sliceC || sliceZ || sliceT) {
>             final String stackOrder = this.process.getStackOrder();
>             final List<ImagePlus> slicedImps = new ArrayList<ImagePlus>();
>             final Slicer slicer = new Slicer();
>             for (final ImagePlus imp : imps) {
>                 final ImagePlus[] results = slicer.reslice(imp, sliceC, sliceZ, sliceT, stackOrder);
>                 ImagePlus[] array;
>                 for (int length = (array = results).length, i = 0; i < length; ++i) {
>                     final ImagePlus result = array[i];
>                     slicedImps.add(result);
>                 }
299,300c328,435
<          } catch (FormatException var13) {
<             LuraWave.promptLicenseCode(code, first);
---
>             imps = slicedImps;
>         }
>         return imps;
>     }
>     
>     public void startTiming() {
>         final long currentTimeMillis = System.currentTimeMillis();
>         this.time = currentTimeMillis;
>         this.startTime = currentTimeMillis;
>     }
>     
>     public void updateTiming(final int s, final int i, final int current, final int total) {
>         final ImageProcessorReader reader = this.process.getReader();
>         final long clock = System.currentTimeMillis();
>         if (clock - this.time >= 100L) {
>             final String sLabel = (reader.getSeriesCount() > 1) ? ("series " + (s + 1) + ", ") : "";
>             final String pLabel = "plane " + (i + 1) + "/" + total;
>             this.notifyListeners(new StatusEvent("Reading " + sLabel + pLabel));
>             this.time = clock;
>         }
>         this.notifyListeners(new StatusEvent(current, total, (String)null));
>     }
>     
>     public void finishTiming() {
>         final ImageProcessorReader reader = this.process.getReader();
>         final long endTime = System.currentTimeMillis();
>         final double elapsed = (endTime - this.startTime) / 1000.0;
>         if (reader.getImageCount() == 1) {
>             this.notifyListeners(new StatusEvent("Bio-Formats: " + elapsed + " seconds"));
>         }
>         else {
>             final long average = (endTime - this.startTime) / reader.getImageCount();
>             this.notifyListeners(new StatusEvent("Bio-Formats: " + elapsed + " seconds (" + average + " ms per plane)"));
>         }
>     }
>     
>     public FileInfo createFileInfo() {
>         final FileInfo fi = new FileInfo();
>         String idDir = (this.process.getIdLocation() == null) ? null : this.process.getIdLocation().getParent();
>         if (idDir != null && !idDir.endsWith(File.separator)) {
>             idDir = String.valueOf(idDir) + File.separator;
>         }
>         fi.fileName = this.process.getIdName();
>         fi.directory = idDir;
>         try {
>             final ServiceFactory factory = new ServiceFactory();
>             final OMEXMLService service = (OMEXMLService)factory.getInstance((Class)OMEXMLService.class);
>             fi.description = service.getOMEXML((MetadataRetrieve)this.process.getOMEMetadata());
>         }
>         catch (DependencyException ex) {}
>         catch (ServiceException ex2) {}
>         return fi;
>     }
>     
>     public boolean[] getPlanesToLoad(final int s) {
>         final ImageProcessorReader reader = this.process.getReader();
>         final boolean[] load = new boolean[reader.getImageCount()];
>         final int cBegin = this.process.getCBegin(s);
>         final int cEnd = this.process.getCEnd(s);
>         final int cStep = this.process.getCStep(s);
>         final int zBegin = this.process.getZBegin(s);
>         final int zEnd = this.process.getZEnd(s);
>         final int zStep = this.process.getZStep(s);
>         final int tBegin = this.process.getTBegin(s);
>         final int tEnd = this.process.getTEnd(s);
>         final int tStep = this.process.getTStep(s);
>         for (int c = cBegin; c <= cEnd; c += cStep) {
>             for (int z = zBegin; z <= zEnd; z += zStep) {
>                 for (int t = tBegin; t <= tEnd; t += tStep) {
>                     final int index = reader.getIndex(z, c, t);
>                     load[index] = true;
>                 }
>             }
>         }
>         return load;
>     }
>     
>     public String constructImageTitle(final IFormatReader r, final String file, final String seriesName, final boolean groupFiles) {
>         final String[] used = r.getUsedFiles();
>         String title = file.substring(file.lastIndexOf(File.separator) + 1);
>         if (used.length > 1 && groupFiles) {
>             final FilePattern fp = new FilePattern(new Location(file));
>             title = fp.getPattern();
>             if (title == null) {
>                 title = file;
>                 if (title.indexOf(".") != -1) {
>                     title = title.substring(0, title.lastIndexOf("."));
>                 }
>             }
>             title = title.substring(title.lastIndexOf(File.separator) + 1);
>         }
>         if (seriesName != null && !file.endsWith(seriesName) && r.getSeriesCount() > 1) {
>             title = String.valueOf(title) + " - " + seriesName;
>         }
>         if (title.length() > 128) {
>             final String a = title.substring(0, 62);
>             final String b = title.substring(title.length() - 62);
>             title = String.valueOf(a) + "..." + b;
>         }
>         return title;
>     }
>     
>     public String constructSliceLabel(final int ndx, final ImageProcessorReader r, final IMetadata meta, final int series, final int zCount, final int cCount, final int tCount) {
>         r.setSeries(series);
>         final int[] zct = r.getZCTCoords(ndx);
>         final StringBuffer sb = new StringBuffer();
>         boolean first = true;
>         if (zCount > 1) {
302c437
<                first = false;
---
>                 first = false;
304,342c439,440
<          }
<       }
< 
<       return null;
<    }
< 
<    public List<ImagePlus> concatenate(List<ImagePlus> imps) {
<       ImporterOptions options = this.process.getOptions();
<       if (options.isConcatenate()) {
<          imps = (new Concatenator()).concatenate(imps);
<       }
< 
<       return imps;
<    }
< 
<    public List<ImagePlus> applyColors(List<ImagePlus> imps) {
<       return (new Colorizer(this.process)).applyColors(imps);
<    }
< 
<    public List<ImagePlus> splitDims(List<ImagePlus> imps) {
<       ImporterOptions options = this.process.getOptions();
<       boolean sliceC = options.isSplitChannels();
<       boolean sliceZ = options.isSplitFocalPlanes();
<       boolean sliceT = options.isSplitTimepoints();
<       if (sliceC || sliceZ || sliceT) {
<          String stackOrder = this.process.getStackOrder();
<          List<ImagePlus> slicedImps = new ArrayList();
<          Slicer slicer = new Slicer();
<          Iterator var10 = ((List)imps).iterator();
< 
<          while(var10.hasNext()) {
<             ImagePlus imp = (ImagePlus)var10.next();
<             ImagePlus[] results = slicer.reslice(imp, sliceC, sliceZ, sliceT, stackOrder);
<             ImagePlus[] var15 = results;
<             int var14 = results.length;
< 
<             for(int var13 = 0; var13 < var14; ++var13) {
<                ImagePlus result = var15[var13];
<                slicedImps.add(result);
---
>             else {
>                 sb.append("; ");
344,420c442,449
<          }
< 
<          imps = slicedImps;
<       }
< 
<       return (List)imps;
<    }
< 
<    public void startTiming() {
<       this.startTime = this.time = System.currentTimeMillis();
<    }
< 
<    public void updateTiming(int s, int i, int current, int total) {
<       ImageProcessorReader reader = this.process.getReader();
<       long clock = System.currentTimeMillis();
<       if (clock - this.time >= 100L) {
<          String sLabel = reader.getSeriesCount() > 1 ? "series " + (s + 1) + ", " : "";
<          String pLabel = "plane " + (i + 1) + "/" + total;
<          this.notifyListeners(new StatusEvent("Reading " + sLabel + pLabel));
<          this.time = clock;
<       }
< 
<       this.notifyListeners(new StatusEvent(current, total, (String)null));
<    }
< 
<    public void finishTiming() {
<       ImageProcessorReader reader = this.process.getReader();
<       long endTime = System.currentTimeMillis();
<       double elapsed = (double)(endTime - this.startTime) / 1000.0D;
<       if (reader.getImageCount() == 1) {
<          this.notifyListeners(new StatusEvent("Bio-Formats: " + elapsed + " seconds"));
<       } else {
<          long average = (endTime - this.startTime) / (long)reader.getImageCount();
<          this.notifyListeners(new StatusEvent("Bio-Formats: " + elapsed + " seconds (" + average + " ms per plane)"));
<       }
< 
<    }
< 
<    public FileInfo createFileInfo() {
<       FileInfo fi = new FileInfo();
<       String idDir = this.process.getIdLocation() == null ? null : this.process.getIdLocation().getParent();
<       if (idDir != null && !idDir.endsWith(File.separator)) {
<          idDir = idDir + File.separator;
<       }
< 
<       fi.fileName = this.process.getIdName();
<       fi.directory = idDir;
< 
<       try {
<          ServiceFactory factory = new ServiceFactory();
<          OMEXMLService service = (OMEXMLService)factory.getInstance(OMEXMLService.class);
<          fi.description = service.getOMEXML(this.process.getOMEMetadata());
<       } catch (DependencyException var5) {
<       } catch (ServiceException var6) {
<       }
< 
<       return fi;
<    }
< 
<    public boolean[] getPlanesToLoad(int s) {
<       ImageProcessorReader reader = this.process.getReader();
<       boolean[] load = new boolean[reader.getImageCount()];
<       int cBegin = this.process.getCBegin(s);
<       int cEnd = this.process.getCEnd(s);
<       int cStep = this.process.getCStep(s);
<       int zBegin = this.process.getZBegin(s);
<       int zEnd = this.process.getZEnd(s);
<       int zStep = this.process.getZStep(s);
<       int tBegin = this.process.getTBegin(s);
<       int tEnd = this.process.getTEnd(s);
<       int tStep = this.process.getTStep(s);
< 
<       for(int c = cBegin; c <= cEnd; c += cStep) {
<          for(int z = zBegin; z <= zEnd; z += zStep) {
<             for(int t = tBegin; t <= tEnd; t += tStep) {
<                int index = reader.getIndex(z, c, t);
<                load[index] = true;
---
>             sb.append("z:");
>             sb.append(zct[0] + 1);
>             sb.append("/");
>             sb.append(r.getSizeZ());
>         }
>         if (tCount > 1) {
>             if (first) {
>                 first = false;
422,437c451,452
<          }
<       }
< 
<       return load;
<    }
< 
<    public String constructImageTitle(IFormatReader r, String file, String seriesName, boolean groupFiles) {
<       String[] used = r.getUsedFiles();
<       String title = file.substring(file.lastIndexOf(File.separator) + 1);
<       if (used.length > 1 && groupFiles) {
<          FilePattern fp = new FilePattern(new Location(file));
<          title = fp.getPattern();
<          if (title == null) {
<             title = file;
<             if (file.indexOf(".") != -1) {
<                title = file.substring(0, file.lastIndexOf("."));
---
>             else {
>                 sb.append("; ");
439,505c454,474
<          }
< 
<          title = title.substring(title.lastIndexOf(File.separator) + 1);
<       }
< 
<       if (seriesName != null && !file.endsWith(seriesName) && r.getSeriesCount() > 1) {
<          title = title + " - " + seriesName;
<       }
< 
<       if (title.length() > 128) {
<          String a = title.substring(0, 62);
<          String b = title.substring(title.length() - 62);
<          title = a + "..." + b;
<       }
< 
<       return title;
<    }
< 
<    public String constructSliceLabel(int ndx, ImageProcessorReader r, IMetadata meta, int series, int zCount, int cCount, int tCount) {
<       r.setSeries(series);
<       int[] zct = r.getZCTCoords(ndx);
<       StringBuffer sb = new StringBuffer();
<       boolean first = true;
<       if (zCount > 1) {
<          if (first) {
<             first = false;
<          } else {
<             sb.append("; ");
<          }
< 
<          sb.append("z:");
<          sb.append(zct[0] + 1);
<          sb.append("/");
<          sb.append(r.getSizeZ());
<       }
< 
<       if (tCount > 1) {
<          if (first) {
<             first = false;
<          } else {
<             sb.append("; ");
<          }
< 
<          sb.append("t:");
<          sb.append(zct[2] + 1);
<          sb.append("/");
<          sb.append(r.getSizeT());
<       }
< 
<       String imageName = meta.getImageName(series);
<       if (imageName != null && !imageName.trim().equals("")) {
<          sb.append(" - ");
<          sb.append(imageName);
<       }
< 
<       return sb.toString();
<    }
< 
<    public static void saveLUTs(ImagePlus imp, List<LUT> luts) {
<       for(int i = 0; i < luts.size(); ++i) {
<          LUT lut = (LUT)luts.get(i);
<          if (lut != null) {
<             imp.setProperty("LUT-" + i, lut);
<          }
<       }
< 
<    }
---
>             sb.append("t:");
>             sb.append(zct[2] + 1);
>             sb.append("/");
>             sb.append(r.getSizeT());
>         }
>         final String imageName = meta.getImageName(series);
>         if (imageName != null && !imageName.trim().equals("")) {
>             sb.append(" - ");
>             sb.append(imageName);
>         }
>         return sb.toString();
>     }
>     
>     public static void saveLUTs(final ImagePlus imp, final List<LUT> luts) {
>         for (int i = 0; i < luts.size(); ++i) {
>             final LUT lut = luts.get(i);
>             if (lut != null) {
>                 imp.setProperty("LUT-" + i, (Object)lut);
>             }
>         }
>     }
Only in TrackAnalyzer_: images
diff -r TrackAnalyzer_/ISBIChallengeExporterModified.java procyon/ISBIChallengeExporterModified.java
1,15d0
< import fiji.plugin.trackmate.Logger;
< import fiji.plugin.trackmate.Model;
< import fiji.plugin.trackmate.SelectionModel;
< import fiji.plugin.trackmate.Settings;
< import fiji.plugin.trackmate.Spot;
< import fiji.plugin.trackmate.TrackMate;
< import fiji.plugin.trackmate.action.AbstractTMAction;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings;
< import fiji.plugin.trackmate.io.IOUtils;
< import java.awt.Frame;
< import java.io.File;
< import java.io.FileNotFoundException;
< import java.io.FileOutputStream;
< import java.io.IOException;
< import java.util.Date;
18d2
< import java.util.TreeSet;
19a4,9
> import org.jdom2.Content;
> import java.util.Collection;
> import java.util.Comparator;
> import java.util.TreeSet;
> import fiji.plugin.trackmate.Spot;
> import java.util.Date;
21d10
< import org.jdom2.Document;
23c12,15
< import org.jdom2.output.Format;
---
> import java.io.IOException;
> import java.io.FileNotFoundException;
> import java.io.OutputStream;
> import java.io.FileOutputStream;
24a17,28
> import org.jdom2.output.Format;
> import org.jdom2.Document;
> import fiji.plugin.trackmate.Logger;
> import fiji.plugin.trackmate.Settings;
> import fiji.plugin.trackmate.Model;
> import fiji.plugin.trackmate.io.IOUtils;
> import java.io.File;
> import java.awt.Frame;
> import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings;
> import fiji.plugin.trackmate.SelectionModel;
> import fiji.plugin.trackmate.TrackMate;
> import fiji.plugin.trackmate.action.AbstractTMAction;
26,143c30,145
< public class ISBIChallengeExporterModified extends AbstractTMAction {
<    public static final String NAME = "Export to ISBI challenge format";
<    public static final String KEY = "EXPORT_TO_ISBI_CHALLENGE_FORMAT";
<    public static final String INFO_TEXT = "<html>Export the current model content to a XML file following the ISBI 2012 particle tracking challenge format, as specified on <a href='http://bioimageanalysis.org/track/'></a>. <p> Only tracks are exported. If there is no track, this action does nothing. </html>";
<    private static final String CONTENT_KEY = "TrackContestISBI2012";
<    private static final String DATE_ATT = "generationDateTime";
<    private static final String SNR_ATT = "snr";
<    private static final String DENSITY_ATT = "density";
<    private static final String SCENARIO_ATT = "scenario";
<    private static final String TRACK_KEY = "particle";
<    private static final String SPOT_KEY = "detection";
<    private static final String X_ATT = "x";
<    private static final String Y_ATT = "y";
<    private static final String Z_ATT = "z";
<    private static final String T_ATT = "t";
< 
<    public void execute(TrackMate trackmate, SelectionModel selectionModel, DisplaySettings displaySettings, Frame parent) {
<       Model model = trackmate.getModel();
<       File folder = (new File(System.getProperty("user.dir"))).getParentFile().getParentFile();
< 
<       File file;
<       try {
<          String filename = trackmate.getSettings().imageFileName;
<          filename = filename.substring(0, filename.indexOf("."));
<          file = new File(folder.getPath() + File.separator + filename + "_ISBI.xml");
<       } catch (NullPointerException var9) {
<          file = new File(folder.getPath() + File.separator + "ISBIChallenge2012Result.xml");
<       }
< 
<       file = IOUtils.askForFileForSaving(file, parent, this.logger);
<       exportToFile(model, trackmate.getSettings(), file, this.logger);
<    }
< 
<    public static void exportToFile(Model model, Settings settings, File file) {
<       exportToFile(model, settings, file, model.getLogger());
<    }
< 
<    public static void exportToFile(Model model, Settings settings, File file, Logger logger) {
<       SPTBatch_.taskOutput.append("Exporting to ISBI 2012 particle tracking challenge format.\n");
<       int ntracks = model.getTrackModel().nTracks(true);
<       if (ntracks == 0) {
<          SPTBatch_.taskOutput.append("No visible track found. Aborting.\n");
<       } else {
<          SPTBatch_.taskOutput.append("  Preparing XML data.\n");
<          Element root = marshall(model, settings);
<          SPTBatch_.taskOutput.append("  Writing to file.\n");
<          Document document = new Document(root);
<          XMLOutputter outputter = new XMLOutputter(Format.getPrettyFormat());
< 
<          try {
<             outputter.output(document, new FileOutputStream(file));
<          } catch (FileNotFoundException var9) {
<             SPTBatch_.taskOutput.append("Trouble writing to " + file + ":\n" + var9.getMessage());
<          } catch (IOException var10) {
<             SPTBatch_.taskOutput.append("Trouble writing to " + file + ":\n" + var10.getMessage());
<          }
< 
<          SPTBatch_.taskOutput.append("Done.\n");
<       }
<    }
< 
<    private static final Element marshall(Model model, Settings settings) {
<       Logger logger = model.getLogger();
<       Element root = new Element("root");
<       Element content = new Element("TrackContestISBI2012");
<       String filename = settings.imageFileName;
<       String pattern = "^(\\w+) snr (\\d+) density (\\w+)\\.";
<       Pattern r = Pattern.compile("^(\\w+) snr (\\d+) density (\\w+)\\.");
<       Matcher m = r.matcher(filename);
<       String snr_val;
<       String density_val;
<       String scenario_val;
<       if (m.find()) {
<          scenario_val = m.group(1);
<          snr_val = m.group(2);
<          density_val = m.group(3);
<       } else {
<          scenario_val = filename;
<          snr_val = "?";
<          density_val = "?";
<       }
< 
<       content.setAttribute("snr", snr_val);
<       content.setAttribute("density", density_val);
<       content.setAttribute("scenario", scenario_val);
<       content.setAttribute("generationDateTime", (new Date()).toString());
<       SPTBatch_.taskOutput.append("Marshalling...");
<       Integer[] visibleTracks = (Integer[])model.getTrackModel().trackIDs(true).toArray(new Integer[0]);
< 
<       for(int i = 0; i < model.getTrackModel().nTracks(true); ++i) {
<          Element trackElement = new Element("particle");
<          int trackindex = visibleTracks[i];
<          Set<Spot> track = model.getTrackModel().trackSpots(trackindex);
<          TreeSet<Spot> sortedTrack = new TreeSet(Spot.timeComparator);
<          sortedTrack.addAll(track);
<          Iterator var19 = sortedTrack.iterator();
< 
<          while(var19.hasNext()) {
<             Spot spot = (Spot)var19.next();
<             int t = spot.getFeature("FRAME").intValue();
<             double x = spot.getFeature("POSITION_X");
<             double y = spot.getFeature("POSITION_Y");
<             double z = spot.getFeature("POSITION_Z");
<             Element spotElement = new Element("detection");
<             spotElement.setAttribute("t", "" + t);
<             spotElement.setAttribute("x", "" + x);
<             spotElement.setAttribute("y", "" + y);
<             spotElement.setAttribute("z", "" + z);
<             trackElement.addContent(spotElement);
<          }
< 
<          content.addContent(trackElement);
<          SPTBatch_.taskOutput.append(String.valueOf((double)i / (0.0D + (double)model.getTrackModel().nTracks(true))));
<       }
< 
<       root.addContent(content);
<       return root;
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class ISBIChallengeExporterModified extends AbstractTMAction
> {
>     public static final String NAME = "Export to ISBI challenge format";
>     public static final String KEY = "EXPORT_TO_ISBI_CHALLENGE_FORMAT";
>     public static final String INFO_TEXT = "<html>Export the current model content to a XML file following the ISBI 2012 particle tracking challenge format, as specified on <a href='http://bioimageanalysis.org/track/'></a>. <p> Only tracks are exported. If there is no track, this action does nothing. </html>";
>     private static final String CONTENT_KEY = "TrackContestISBI2012";
>     private static final String DATE_ATT = "generationDateTime";
>     private static final String SNR_ATT = "snr";
>     private static final String DENSITY_ATT = "density";
>     private static final String SCENARIO_ATT = "scenario";
>     private static final String TRACK_KEY = "particle";
>     private static final String SPOT_KEY = "detection";
>     private static final String X_ATT = "x";
>     private static final String Y_ATT = "y";
>     private static final String Z_ATT = "z";
>     private static final String T_ATT = "t";
>     
>     public void execute(final TrackMate trackmate, final SelectionModel selectionModel, final DisplaySettings displaySettings, final Frame parent) {
>         final Model model = trackmate.getModel();
>         final File folder = new File(System.getProperty("user.dir")).getParentFile().getParentFile();
>         File file;
>         try {
>             String filename = trackmate.getSettings().imageFileName;
>             filename = filename.substring(0, filename.indexOf("."));
>             file = new File(String.valueOf(folder.getPath()) + File.separator + filename + "_ISBI.xml");
>         }
>         catch (NullPointerException npe) {
>             file = new File(String.valueOf(folder.getPath()) + File.separator + "ISBIChallenge2012Result.xml");
>         }
>         file = IOUtils.askForFileForSaving(file, parent, this.logger);
>         exportToFile(model, trackmate.getSettings(), file, this.logger);
>     }
>     
>     public static void exportToFile(final Model model, final Settings settings, final File file) {
>         exportToFile(model, settings, file, model.getLogger());
>     }
>     
>     public static void exportToFile(final Model model, final Settings settings, final File file, final Logger logger) {
>         SPTBatch_.taskOutput.append("Exporting to ISBI 2012 particle tracking challenge format.\n");
>         final int ntracks = model.getTrackModel().nTracks(true);
>         if (ntracks == 0) {
>             SPTBatch_.taskOutput.append("No visible track found. Aborting.\n");
>             return;
>         }
>         SPTBatch_.taskOutput.append("  Preparing XML data.\n");
>         final Element root = marshall(model, settings);
>         SPTBatch_.taskOutput.append("  Writing to file.\n");
>         final Document document = new Document(root);
>         final XMLOutputter outputter = new XMLOutputter(Format.getPrettyFormat());
>         try {
>             outputter.output(document, (OutputStream)new FileOutputStream(file));
>         }
>         catch (FileNotFoundException e) {
>             SPTBatch_.taskOutput.append("Trouble writing to " + file + ":\n" + e.getMessage());
>         }
>         catch (IOException e2) {
>             SPTBatch_.taskOutput.append("Trouble writing to " + file + ":\n" + e2.getMessage());
>         }
>         SPTBatch_.taskOutput.append("Done.\n");
>     }
>     
>     private static final Element marshall(final Model model, final Settings settings) {
>         final Logger logger = model.getLogger();
>         final Element root = new Element("root");
>         final Element content = new Element("TrackContestISBI2012");
>         final String filename = settings.imageFileName;
>         final String pattern = "^(\\w+) snr (\\d+) density (\\w+)\\.";
>         final Pattern r = Pattern.compile("^(\\w+) snr (\\d+) density (\\w+)\\.");
>         final Matcher m = r.matcher(filename);
>         String scenario_val;
>         String snr_val;
>         String density_val;
>         if (m.find()) {
>             scenario_val = m.group(1);
>             snr_val = m.group(2);
>             density_val = m.group(3);
>         }
>         else {
>             scenario_val = filename;
>             snr_val = "?";
>             density_val = "?";
>         }
>         content.setAttribute("snr", snr_val);
>         content.setAttribute("density", density_val);
>         content.setAttribute("scenario", scenario_val);
>         content.setAttribute("generationDateTime", new Date().toString());
>         SPTBatch_.taskOutput.append("Marshalling...");
>         final Integer[] visibleTracks = model.getTrackModel().trackIDs(true).<Integer>toArray(new Integer[0]);
>         for (int i = 0; i < model.getTrackModel().nTracks(true); ++i) {
>             final Element trackElement = new Element("particle");
>             final int trackindex = visibleTracks[i];
>             final Set<Spot> track = (Set<Spot>)model.getTrackModel().trackSpots(Integer.valueOf(trackindex));
>             final TreeSet<Spot> sortedTrack = new TreeSet<Spot>(Spot.timeComparator);
>             sortedTrack.addAll(track);
>             for (final Spot spot : sortedTrack) {
>                 final int t = spot.getFeature("FRAME").intValue();
>                 final double x = spot.getFeature("POSITION_X");
>                 final double y = spot.getFeature("POSITION_Y");
>                 final double z = spot.getFeature("POSITION_Z");
>                 final Element spotElement = new Element("detection");
>                 spotElement.setAttribute("t", new StringBuilder().append(t).toString());
>                 spotElement.setAttribute("x", new StringBuilder().append(x).toString());
>                 spotElement.setAttribute("y", new StringBuilder().append(y).toString());
>                 spotElement.setAttribute("z", new StringBuilder().append(z).toString());
>                 trackElement.addContent((Content)spotElement);
>             }
>             content.addContent((Content)trackElement);
>             SPTBatch_.taskOutput.append(new StringBuilder(String.valueOf(i / (0.0 + model.getTrackModel().nTracks(true)))).toString());
>         }
>         root.addContent((Content)content);
>         return root;
>     }
diff -r TrackAnalyzer_/LabelWizardPanel.java procyon/LabelWizardPanel.java
5,10c5,15
< public class LabelWizardPanel extends JWizardPanel {
<    public LabelWizardPanel(JWizardComponents wizardComponents, String label) {
<       super(wizardComponents);
<       JButton backButton = wizardComponents.getBackButton();
<       backButton.setText("");
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class LabelWizardPanel extends JWizardPanel
> {
>     public LabelWizardPanel(final JWizardComponents wizardComponents, final String label) {
>         super(wizardComponents);
>         final JButton backButton = wizardComponents.getBackButton();
>         backButton.setText("");
>     }
diff -r TrackAnalyzer_/LastWizardPanel.java procyon/LastWizardPanel.java
4,11c4,6
< public class LastWizardPanel extends LabelWizardPanel {
<    public LastWizardPanel(JWizardComponents wizardComponents) {
<       super(wizardComponents, "");
<       this.setPanelTitle("  PLOT-OPTIONS:  Spots,Links or Tracks");
<       this.update();
<       this.removeAll();
<       new JTabbedPane();
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
13,28c8,33
<    public void update() {
<       this.setNextButtonEnabled(false);
<       this.setFinishButtonEnabled(true);
<       this.setBackButtonEnabled(true);
<    }
< 
<    public void next() {
<    }
< 
<    public void back() {
<       this.switchPanel(1);
<    }
< 
<    public void finish() {
<       this.switchPanel(2);
<    }
---
> public class LastWizardPanel extends LabelWizardPanel
> {
>     public LastWizardPanel(final JWizardComponents wizardComponents) {
>         super(wizardComponents, "");
>         this.setPanelTitle("  PLOT-OPTIONS:  Spots,Links or Tracks");
>         this.update();
>         this.removeAll();
>         final JTabbedPane tabbedPane = new JTabbedPane();
>     }
>     
>     public void update() {
>         this.setNextButtonEnabled(false);
>         this.setFinishButtonEnabled(true);
>         this.setBackButtonEnabled(true);
>     }
>     
>     public void next() {
>     }
>     
>     public void back() {
>         this.switchPanel(1);
>     }
>     
>     public void finish() {
>         this.switchPanel(2);
>     }
diff -r TrackAnalyzer_/math/ActiveTransportMSDLineFitModified.java procyon/math/ActiveTransportMSDLineFitModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,29c9,34
< public class ActiveTransportMSDLineFitModified {
<    double a;
<    double b;
<    double goodness;
< 
<    public void doFit(double[] xdata, double[] ydata) {
<       new CurveFitter(xdata, ydata);
<       CurveFitter fitter = new CurveFitter(xdata, ydata);
<       fitter.doCustomFit("y=a*a*x*x + 4*sqrt(b*b)*x", new double[]{0.0D, 0.0D}, false);
<       this.a = Math.abs(fitter.getParams()[0]);
<       this.b = Math.abs(fitter.getParams()[1]);
<       this.goodness = fitter.getFitGoodness();
<    }
< 
<    public double getVelocity() {
<       return this.a;
<    }
< 
<    public double getDiffusionCoefficient() {
<       return this.b;
<    }
< 
<    public double getFitGoodness() {
<       return this.goodness;
<    }
---
> public class ActiveTransportMSDLineFitModified
> {
>     double a;
>     double b;
>     double goodness;
>     
>     public void doFit(final double[] xdata, final double[] ydata) {
>         CurveFitter fitter = new CurveFitter(xdata, ydata);
>         fitter = new CurveFitter(xdata, ydata);
>         fitter.doCustomFit("y=a*a*x*x + 4*sqrt(b*b)*x", new double[] { 0.0, 0.0 }, false);
>         this.a = Math.abs(fitter.getParams()[0]);
>         this.b = Math.abs(fitter.getParams()[1]);
>         this.goodness = fitter.getFitGoodness();
>     }
>     
>     public double getVelocity() {
>         return this.a;
>     }
>     
>     public double getDiffusionCoefficient() {
>         return this.b;
>     }
>     
>     public double getFitGoodness() {
>         return this.goodness;
>     }
diff -r TrackAnalyzer_/math/ConfinedDiffusionMSDCurveFitModified.java procyon/math/ConfinedDiffusionMSDCurveFitModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,73c9,83
< public class ConfinedDiffusionMSDCurveFitModified {
<    private double a;
<    private double b;
<    private double c;
<    private double D;
<    private double goodness;
<    private double initA = Double.NaN;
<    private double initB = Double.NaN;
<    private double initC = Double.NaN;
<    private double initD = Double.NaN;
< 
<    public void doFit(double[] xdata, double[] ydata, boolean reduced) {
<       CurveFitter fitter = new CurveFitter(xdata, ydata);
<       double ia;
<       double ib;
<       if (!reduced) {
<          ia = Double.isNaN(this.initA) ? 0.0D : this.initA;
<          ib = Double.isNaN(this.initB) ? 0.0D : this.initB;
<          double ic = Double.isNaN(this.initC) ? 0.0D : this.initC;
<          double id = Double.isNaN(this.initD) ? 0.0D : this.initD;
<          double[] initialParams = new double[]{ia, ib, ic, id};
<          fitter.setInitialParameters(initialParams);
<          fitter.doCustomFit("y=sqrt(a*a)*(1-sqrt(b*b)*exp(-4*sqrt(c*c)*sqrt(d*d)*x/sqrt(a*a)))", initialParams, false);
<          double[] params = fitter.getParams();
<          this.a = Math.abs(params[0]);
<          this.b = Math.abs(params[1]);
<          this.c = Math.abs(params[2]);
<          this.D = Math.abs(params[3]);
<          this.goodness = fitter.getFitGoodness();
<       } else {
<          ia = Double.isNaN(this.initA) ? 0.0D : this.initA;
<          ib = Double.isNaN(this.initD) ? 0.0D : this.initD;
<          double[] initialParams = new double[]{ia, ib};
<          fitter.setInitialParameters(initialParams);
<          fitter.doCustomFit("y=sqrt(a*a)*(1-exp(-4*sqrt(b*b)*x/sqrt(a*a)))", initialParams, false);
<          double[] params = fitter.getParams();
<          this.a = Math.abs(params[0]);
<          this.D = Math.abs(params[1]);
<          this.goodness = fitter.getFitGoodness();
<       }
< 
<    }
< 
<    public void setInitParameters(double[] p) {
<       this.initA = p[0];
<       this.initB = p[1];
<       this.initC = p[2];
<       this.initD = p[3];
<    }
< 
<    public double getA() {
<       return this.a;
<    }
< 
<    public double getB() {
<       return this.b;
<    }
< 
<    public double getC() {
<       return this.c;
<    }
< 
<    public double getD() {
<       return this.D;
<    }
< 
<    public double getGoodness() {
<       return this.goodness;
<    }
---
> public class ConfinedDiffusionMSDCurveFitModified
> {
>     private double a;
>     private double b;
>     private double c;
>     private double D;
>     private double goodness;
>     private double initA;
>     private double initB;
>     private double initC;
>     private double initD;
>     
>     public ConfinedDiffusionMSDCurveFitModified() {
>         this.initA = Double.NaN;
>         this.initB = Double.NaN;
>         this.initC = Double.NaN;
>         this.initD = Double.NaN;
>     }
>     
>     public void doFit(final double[] xdata, final double[] ydata, final boolean reduced) {
>         final CurveFitter fitter = new CurveFitter(xdata, ydata);
>         if (!reduced) {
>             final double ia = Double.isNaN(this.initA) ? 0.0 : this.initA;
>             final double ib = Double.isNaN(this.initB) ? 0.0 : this.initB;
>             final double ic = Double.isNaN(this.initC) ? 0.0 : this.initC;
>             final double id = Double.isNaN(this.initD) ? 0.0 : this.initD;
>             final double[] initialParams = { ia, ib, ic, id };
>             fitter.setInitialParameters(initialParams);
>             fitter.doCustomFit("y=sqrt(a*a)*(1-sqrt(b*b)*exp(-4*sqrt(c*c)*sqrt(d*d)*x/sqrt(a*a)))", initialParams, false);
>             final double[] params = fitter.getParams();
>             this.a = Math.abs(params[0]);
>             this.b = Math.abs(params[1]);
>             this.c = Math.abs(params[2]);
>             this.D = Math.abs(params[3]);
>             this.goodness = fitter.getFitGoodness();
>         }
>         else {
>             final double ia = Double.isNaN(this.initA) ? 0.0 : this.initA;
>             final double id2 = Double.isNaN(this.initD) ? 0.0 : this.initD;
>             final double[] initialParams2 = { ia, id2 };
>             fitter.setInitialParameters(initialParams2);
>             fitter.doCustomFit("y=sqrt(a*a)*(1-exp(-4*sqrt(b*b)*x/sqrt(a*a)))", initialParams2, false);
>             final double[] params2 = fitter.getParams();
>             this.a = Math.abs(params2[0]);
>             this.D = Math.abs(params2[1]);
>             this.goodness = fitter.getFitGoodness();
>         }
>     }
>     
>     public void setInitParameters(final double[] p) {
>         this.initA = p[0];
>         this.initB = p[1];
>         this.initC = p[2];
>         this.initD = p[3];
>     }
>     
>     public double getA() {
>         return this.a;
>     }
>     
>     public double getB() {
>         return this.b;
>     }
>     
>     public double getC() {
>         return this.c;
>     }
>     
>     public double getD() {
>         return this.D;
>     }
>     
>     public double getGoodness() {
>         return this.goodness;
>     }
diff -r TrackAnalyzer_/math/MomentsCalculatorModified.java procyon/math/MomentsCalculatorModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
4,5d7
< import org.apache.commons.math3.linear.EigenDecomposition;
< import org.apache.commons.math3.stat.descriptive.moment.Mean;
7c9
< import traJ.TrajectoryModified;
---
> import org.apache.commons.math3.stat.descriptive.moment.Mean;
9a12,14
> import org.apache.commons.math3.linear.RealMatrix;
> import org.apache.commons.math3.linear.EigenDecomposition;
> import traJ.TrajectoryModified;
11,43c16,44
< public class MomentsCalculatorModified {
<    private TrajectoryModified t;
< 
<    public MomentsCalculatorModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double calculateNthMoment(int n) {
<       Array2DRowRealMatrix gyr = RadiusGyrationTensor2DModified.getRadiusOfGyrationTensor(this.t);
<       EigenDecomposition eigdec = new EigenDecomposition(gyr);
<       Vector2d eigv = new Vector2d(eigdec.getEigenvector(0).getEntry(0), eigdec.getEigenvector(0).getEntry(1));
<       double[] projected = new double[this.t.size()];
< 
<       double mean;
<       for(int i = 0; i < this.t.size(); ++i) {
<          Vector2d pos = new Vector2d(((Point3dModified)this.t.get(i)).x, ((Point3dModified)this.t.get(i)).y);
<          mean = eigv.dot(pos);
<          projected[i] = mean;
<       }
< 
<       Mean m = new Mean();
<       StandardDeviation s = new StandardDeviation();
<       mean = m.evaluate(projected);
<       double sd = s.evaluate(projected);
<       double sumPowN = 0.0D;
< 
<       for(int i = 0; i < projected.length; ++i) {
<          sumPowN += Math.pow((projected[i] - mean) / sd, (double)n);
<       }
< 
<       double nThMoment = sumPowN / (double)projected.length;
<       return nThMoment;
<    }
---
> public class MomentsCalculatorModified
> {
>     private TrajectoryModified t;
>     
>     public MomentsCalculatorModified(final TrajectoryModified t) {
>         this.t = t;
>     }
>     
>     public double calculateNthMoment(final int n) {
>         final Array2DRowRealMatrix gyr = RadiusGyrationTensor2DModified.getRadiusOfGyrationTensor(this.t);
>         final EigenDecomposition eigdec = new EigenDecomposition((RealMatrix)gyr);
>         final Vector2d eigv = new Vector2d(eigdec.getEigenvector(0).getEntry(0), eigdec.getEigenvector(0).getEntry(1));
>         final double[] projected = new double[this.t.size()];
>         for (int i = 0; i < this.t.size(); ++i) {
>             final Vector2d pos = new Vector2d(this.t.get(i).x, this.t.get(i).y);
>             final double v = eigv.dot(pos);
>             projected[i] = v;
>         }
>         final Mean m = new Mean();
>         final StandardDeviation s = new StandardDeviation();
>         final double mean = m.evaluate(projected);
>         final double sd = s.evaluate(projected);
>         double sumPowN = 0.0;
>         for (int j = 0; j < projected.length; ++j) {
>             sumPowN += Math.pow((projected[j] - mean) / sd, n);
>         }
>         final double nThMoment = sumPowN / projected.length;
>         return nThMoment;
>     }
diff -r TrackAnalyzer_/math/PowerLawCurveFitModified.java procyon/math/PowerLawCurveFitModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,68c9,68
< public class PowerLawCurveFitModified {
<    private double alpha;
<    private double dc;
<    private double goodness;
< 
<    public void doFit(double[] xdata, double[] ydata) {
<       this.doFit(xdata, ydata, false, 0.0D, 0.0D);
<    }
< 
<    public void doFit(double[] xdata, double[] ydata, double initalAlpha, double initalDiffCoeff) {
<       this.doFit(xdata, ydata, true, initalAlpha, initalDiffCoeff);
<    }
< 
<    private void doFit(double[] xdata, double[] ydata, boolean useInitialGuess, double initalAlpha, double initalDiffCoeff) {
<       CurveFitter fitter = new CurveFitter(xdata, ydata);
<       if (useInitialGuess) {
<          fitter.setInitialParameters(new double[]{initalDiffCoeff, this.alpha});
<       }
< 
<       double[] init = null;
<       if (useInitialGuess) {
<          init = new double[]{initalAlpha, initalDiffCoeff};
<       }
< 
<       fitter.doFit(16);
<       double[] params = fitter.getParams();
<       boolean failed = fitter.getStatus() != 0;
<       if (failed) {
<          this.alpha = -1.0D;
<          this.dc = -1.0D;
<          this.goodness = 0.0D;
<       } else {
<          this.alpha = params[1];
<          this.dc = params[0] / 4.0D;
<          this.goodness = fitter.getFitGoodness();
<       }
< 
<       if (failed || this.alpha < 0.0D || this.dc < 0.0D) {
<          fitter = new CurveFitter(xdata, ydata);
< 
<          for(int i = 0; i < ydata.length; ++i) {
<             ydata[i] = Math.log(ydata[i]);
<          }
< 
<          fitter.doCustomFit("y=sqrt(a*a)*log(x)+log(4*sqrt(b*b))", init, false);
<          params = fitter.getParams();
<          this.alpha = Math.abs(params[0]);
<          this.dc = Math.abs(params[1]);
<          this.goodness = fitter.getFitGoodness();
<       }
< 
<    }
< 
<    public double getAlpha() {
<       return this.alpha;
<    }
< 
<    public double getDiffusionCoefficient() {
<       return this.dc;
<    }
< 
<    public double getGoodness() {
<       return this.goodness;
<    }
---
> public class PowerLawCurveFitModified
> {
>     private double alpha;
>     private double dc;
>     private double goodness;
>     
>     public void doFit(final double[] xdata, final double[] ydata) {
>         this.doFit(xdata, ydata, false, 0.0, 0.0);
>     }
>     
>     public void doFit(final double[] xdata, final double[] ydata, final double initalAlpha, final double initalDiffCoeff) {
>         this.doFit(xdata, ydata, true, initalAlpha, initalDiffCoeff);
>     }
>     
>     private void doFit(final double[] xdata, final double[] ydata, final boolean useInitialGuess, final double initalAlpha, final double initalDiffCoeff) {
>         CurveFitter fitter = new CurveFitter(xdata, ydata);
>         if (useInitialGuess) {
>             fitter.setInitialParameters(new double[] { initalDiffCoeff, this.alpha });
>         }
>         double[] init = null;
>         if (useInitialGuess) {
>             init = new double[] { initalAlpha, initalDiffCoeff };
>         }
>         fitter.doFit(16);
>         double[] params = fitter.getParams();
>         final boolean failed = fitter.getStatus() != 0;
>         if (failed) {
>             this.alpha = -1.0;
>             this.dc = -1.0;
>             this.goodness = 0.0;
>         }
>         else {
>             this.alpha = params[1];
>             this.dc = params[0] / 4.0;
>             this.goodness = fitter.getFitGoodness();
>         }
>         if (failed || this.alpha < 0.0 || this.dc < 0.0) {
>             fitter = new CurveFitter(xdata, ydata);
>             for (int i = 0; i < ydata.length; ++i) {
>                 ydata[i] = Math.log(ydata[i]);
>             }
>             fitter.doCustomFit("y=sqrt(a*a)*log(x)+log(4*sqrt(b*b))", init, false);
>             params = fitter.getParams();
>             this.alpha = Math.abs(params[0]);
>             this.dc = Math.abs(params[1]);
>             this.goodness = fitter.getFitGoodness();
>         }
>     }
>     
>     public double getAlpha() {
>         return this.alpha;
>     }
>     
>     public double getDiffusionCoefficient() {
>         return this.dc;
>     }
>     
>     public double getGoodness() {
>         return this.goodness;
>     }
diff -r TrackAnalyzer_/math/RadiusGyrationTensor2DModified.java procyon/math/RadiusGyrationTensor2DModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
2a7
> import vecmath.Point3dModified;
5,38d9
< import vecmath.Point3dModified;
< 
< public class RadiusGyrationTensor2DModified {
<    private TrajectoryModified t;
< 
<    public RadiusGyrationTensor2DModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public Array2DRowRealMatrix getRadiusOfGyrationTensor() {
<       return getRadiusOfGyrationTensor(this.t);
<    }
< 
<    public static Array2DRowRealMatrix getRadiusOfGyrationTensor(TrajectoryModified t) {
<       double meanx = 0.0D;
<       double meany = 0.0D;
< 
<       for(int i = 0; i < t.size(); ++i) {
<          meanx += ((Point3dModified)t.get(i)).x;
<          meany += ((Point3dModified)t.get(i)).y;
<       }
< 
<       meanx /= (double)t.size();
<       meany /= (double)t.size();
<       double e11 = 0.0D;
<       double e12 = 0.0D;
<       double e21 = 0.0D;
<       double e22 = 0.0D;
< 
<       for(int i = 0; i < t.size(); ++i) {
<          e11 += Math.pow(((Point3dModified)t.get(i)).x - meanx, 2.0D);
<          e12 += (((Point3dModified)t.get(i)).x - meanx) * (((Point3dModified)t.get(i)).y - meany);
<          e22 += Math.pow(((Point3dModified)t.get(i)).y - meany, 2.0D);
<       }
40,51c11,52
<       e11 /= (double)t.size();
<       e12 /= (double)t.size();
<       e22 /= (double)t.size();
<       int rows = 2;
<       int columns = 2;
<       Array2DRowRealMatrix gyr = new Array2DRowRealMatrix(rows, columns);
<       gyr.addToEntry(0, 0, e11);
<       gyr.addToEntry(0, 1, e12);
<       gyr.addToEntry(1, 0, e12);
<       gyr.addToEntry(1, 1, e22);
<       return gyr;
<    }
---
> public class RadiusGyrationTensor2DModified
> {
>     private TrajectoryModified t;
>     
>     public RadiusGyrationTensor2DModified(final TrajectoryModified t) {
>         this.t = t;
>     }
>     
>     public Array2DRowRealMatrix getRadiusOfGyrationTensor() {
>         return getRadiusOfGyrationTensor(this.t);
>     }
>     
>     public static Array2DRowRealMatrix getRadiusOfGyrationTensor(final TrajectoryModified t) {
>         double meanx = 0.0;
>         double meany = 0.0;
>         for (int i = 0; i < t.size(); ++i) {
>             meanx += t.get(i).x;
>             meany += t.get(i).y;
>         }
>         meanx /= t.size();
>         meany /= t.size();
>         double e11 = 0.0;
>         double e12 = 0.0;
>         double e13 = 0.0;
>         double e14 = 0.0;
>         for (int j = 0; j < t.size(); ++j) {
>             e11 += Math.pow(t.get(j).x - meanx, 2.0);
>             e12 += (t.get(j).x - meanx) * (t.get(j).y - meany);
>             e14 += Math.pow(t.get(j).y - meany, 2.0);
>         }
>         e11 /= t.size();
>         e12 = (e13 = e12 / t.size());
>         e14 /= t.size();
>         final int rows = 2;
>         final int columns = 2;
>         final Array2DRowRealMatrix gyr = new Array2DRowRealMatrix(rows, columns);
>         gyr.addToEntry(0, 0, e11);
>         gyr.addToEntry(0, 1, e12);
>         gyr.addToEntry(1, 0, e13);
>         gyr.addToEntry(1, 1, e14);
>         return gyr;
>     }
diff -r TrackAnalyzer_/math/StraightLineFitModified.java procyon/math/StraightLineFitModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import ij.measure.CurveFitter;
4a8
> import ij.measure.CurveFitter;
6,39c10,43
< public class StraightLineFitModified {
<    double a;
<    double b;
<    double goodness;
< 
<    public void doFit(double[] xdata, double[] ydata) {
<       CurveFitter fitter = new CurveFitter(xdata, ydata);
<       fitter.doFit(0);
<       this.goodness = fitter.getFitGoodness();
<       this.a = fitter.getParams()[0];
<       this.a = TrajectoryUtilModified.isZero(this.a) ? 0.0D : this.a;
<       this.b = fitter.getParams()[1];
<       this.b = TrajectoryUtilModified.isZero(this.b) ? 0.0D : this.b;
<       if (this.b < 0.0D) {
<          fitter = new CurveFitter(xdata, ydata);
<          fitter.doCustomFit("y=sqrt(a*a)+sqrt(b*b)*x", new double[]{0.0D, 0.0D}, false);
<          this.a = Math.abs(fitter.getParams()[0]);
<          this.b = Math.abs(fitter.getParams()[1]);
<          this.goodness = fitter.getFitGoodness();
<       }
< 
<    }
< 
<    public double getA() {
<       return this.a;
<    }
< 
<    public double getB() {
<       return this.b;
<    }
< 
<    public double getGoodness() {
<       return this.goodness;
<    }
---
> public class StraightLineFitModified
> {
>     double a;
>     double b;
>     double goodness;
>     
>     public void doFit(final double[] xdata, final double[] ydata) {
>         CurveFitter fitter = new CurveFitter(xdata, ydata);
>         fitter.doFit(0);
>         this.goodness = fitter.getFitGoodness();
>         this.a = fitter.getParams()[0];
>         this.a = (TrajectoryUtilModified.isZero(this.a) ? 0.0 : this.a);
>         this.b = fitter.getParams()[1];
>         this.b = (TrajectoryUtilModified.isZero(this.b) ? 0.0 : this.b);
>         if (this.b < 0.0) {
>             fitter = new CurveFitter(xdata, ydata);
>             fitter.doCustomFit("y=sqrt(a*a)+sqrt(b*b)*x", new double[] { 0.0, 0.0 }, false);
>             this.a = Math.abs(fitter.getParams()[0]);
>             this.b = Math.abs(fitter.getParams()[1]);
>             this.goodness = fitter.getFitGoodness();
>         }
>     }
>     
>     public double getA() {
>         return this.a;
>     }
>     
>     public double getB() {
>         return this.b;
>     }
>     
>     public double getGoodness() {
>         return this.goodness;
>     }
Only in TrackAnalyzer_: META-INF
diff -r TrackAnalyzer_/NormalDistributionMine.java procyon/NormalDistributionMine.java
1c1,8
< import ij.measure.ResultsTable;
---
> import org.jfree.chart.axis.ValueAxis;
> import org.jfree.chart.JFreeChart;
> import org.jfree.data.xy.XYSeries;
> import org.jfree.data.function.Function2D;
> import org.jfree.chart.ChartUtils;
> import java.io.IOException;
> import java.io.File;
> import java.awt.Stroke;
2a10,11
> import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
> import java.awt.Paint;
4,5c13,14
< import java.io.File;
< import java.io.IOException;
---
> import org.jfree.chart.plot.XYPlot;
> import org.jfree.data.xy.XYDataset;
7,9d15
< import org.jfree.chart.ChartUtils;
< import org.jfree.chart.JFreeChart;
< import org.jfree.chart.axis.ValueAxis;
11,14d16
< import org.jfree.chart.plot.XYPlot;
< import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
< import org.jfree.data.function.Function2D;
< import org.jfree.data.function.NormalDistributionFunction2D;
16c18,19
< import org.jfree.data.xy.XYSeries;
---
> import org.jfree.data.function.NormalDistributionFunction2D;
> import ij.measure.ResultsTable;
20,111c23,112
< public class NormalDistributionMine {
<    Integer nOfTrack;
<    MixtureModified.Component[] components;
<    int samples;
<    double meanValue;
< 
<    public NormalDistributionMine(Integer nOfTrack, MixtureModified.Component[] components, int samples, double meanValue) {
<       this.nOfTrack = nOfTrack;
<       this.components = components;
<       this.samples = samples;
<       this.meanValue = meanValue;
<    }
< 
<    public void runNormalDistribution() {
<       XYSeriesCollection dataset = new XYSeriesCollection();
<       ResultsTable rtMonomer = new ResultsTable();
<       String[] var10000 = new String[]{"Subpopulation", "", "", "Entropy", "N of Parameters", "Variance", "N Receptor/Particle", "Monomer Intensity", "Track Mean Intensity"};
<       double monomerValue = 0.0D;
< 
<       for(int i = 0; i < this.components.length; ++i) {
<          Function2D n1 = new NormalDistributionFunction2D(this.components[i].distribution.mean(), this.components[i].distribution.sd());
<          XYSeries s1 = DatasetUtils.sampleFunction2DToSeries(n1, this.components[i].distribution.mean() - 3.0D * this.components[i].distribution.sd(), this.components[i].distribution.mean() + 3.0D * this.components[i].distribution.sd(), this.samples, "subpop-" + i + " : " + " = " + String.format("%.3f", this.components[i].distribution.mean()) + "," + " = " + String.format("%.3f", this.components[i].distribution.sd()));
<          dataset.addSeries(s1);
<          rtMonomer.setValue("Subpopulation", i, String.valueOf(i + 1));
<          rtMonomer.setValue("", i, String.format("%.3f", this.components[i].distribution.mean()));
<          rtMonomer.setValue("", i, String.format("%.3f", this.components[i].distribution.sd()));
<          rtMonomer.setValue("Entropy", i, String.format("%.3f", this.components[i].distribution.entropy()));
<          rtMonomer.setValue("N of Parameters", i, (double)this.components[i].distribution.length());
<          rtMonomer.setValue("Variance", i, String.format("%.3f", this.components[i].distribution.variance()));
<          if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE && this.components.length == 2) {
<             monomerValue = Math.abs(this.components[0].distribution.mean() - this.components[1].distribution.mean());
<          }
<       }
< 
<       if (SPTBatch_.checkMonomer.isSelected() == Boolean.TRUE) {
<          rtMonomer.setValue("N Receptor/Particle", 0, String.valueOf(this.meanValue / Double.valueOf(SPTBatch_.monomerField.getText())));
<       }
< 
<       if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE) {
<          if (monomerValue == 0.0D) {
<             rtMonomer.setValue("N Receptor/Particle", 0, "1");
<             monomerValue = this.components[0].distribution.mean();
<          } else {
<             rtMonomer.setValue("N Receptor/Particle", 0, String.valueOf(this.meanValue / monomerValue));
<          }
<       }
< 
<       if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE) {
<          rtMonomer.setValue("Monomer Intensity", 0, monomerValue);
<       }
< 
<       if (SPTBatch_.checkMonomer.isSelected() == Boolean.TRUE) {
<          rtMonomer.setValue("Monomer Intensity", 0, SPTBatch_.monomerField.getText());
<       }
< 
<       rtMonomer.setValue("Track Mean Intensity", 0, String.valueOf(this.meanValue));
<       JFreeChart chart = ChartFactory.createXYLineChart("Distribution of Single Integrated Intensities for Track-" + this.nOfTrack.toString(), "Integrated Intensity", "Probability Density [nmolecule-1]", dataset, PlotOrientation.VERTICAL, true, true, false);
<       XYPlot plot = (XYPlot)chart.getPlot();
<       plot.setDomainZeroBaselineVisible(true);
<       plot.setRangeZeroBaselineVisible(true);
<       plot.setDomainPannable(true);
<       plot.setRangePannable(true);
<       plot.setBackgroundPaint(Color.white);
<       plot.setDomainGridlinesVisible(true);
<       plot.setRangeGridlinesVisible(true);
<       plot.setDomainMinorGridlinePaint(Color.GRAY);
<       plot.setDomainGridlinePaint(Color.DARK_GRAY);
<       plot.setRangeMinorGridlinePaint(Color.GRAY);
<       plot.setRangeGridlinePaint(Color.DARK_GRAY);
<       ValueAxis xAxis = plot.getDomainAxis();
<       xAxis.setLowerMargin(0.0D);
<       xAxis.setUpperMargin(0.0D);
<       XYLineAndShapeRenderer r = (XYLineAndShapeRenderer)plot.getRenderer();
<       r.setDrawSeriesLineAsPath(true);
< 
<       for(int i = 0; i < dataset.getSeriesCount(); ++i) {
<          r.setSeriesStroke(i, new BasicStroke(2.0F, 1, 1, 1.0F));
<       }
< 
<       try {
<          rtMonomer.saveAs(SPTBatch_.directCluster.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_Cluster_Analysis_" + this.nOfTrack.toString() + ".csv");
<       } catch (IOException var12) {
<          var12.printStackTrace();
<       }
< 
<       try {
<          ChartUtils.saveChartAsPNG(new File(SPTBatch_.directCluster.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_DistributionDensityFunction_" + this.nOfTrack.toString() + ".png"), chart, 500, 400);
<       } catch (IOException var11) {
<          var11.printStackTrace();
<       }
< 
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class NormalDistributionMine
> {
>     Integer nOfTrack;
>     MixtureModified.Component[] components;
>     int samples;
>     double meanValue;
>     
>     public NormalDistributionMine(final Integer nOfTrack, final MixtureModified.Component[] components, final int samples, final double meanValue) {
>         this.nOfTrack = nOfTrack;
>         this.components = components;
>         this.samples = samples;
>         this.meanValue = meanValue;
>     }
>     
>     public void runNormalDistribution() {
>         final XYSeriesCollection dataset = new XYSeriesCollection();
>         final ResultsTable rtMonomer = new ResultsTable();
>         final String[] columnNames = { "Subpopulation", "", "", "Entropy", "N of Parameters", "Variance", "N Receptor/Particle", "Monomer Intensity", "Track Mean Intensity" };
>         double monomerValue = 0.0;
>         for (int i = 0; i < this.components.length; ++i) {
>             final Function2D n1 = (Function2D)new NormalDistributionFunction2D(this.components[i].distribution.mean(), this.components[i].distribution.sd());
>             final XYSeries s1 = DatasetUtils.sampleFunction2DToSeries(n1, this.components[i].distribution.mean() - 3.0 * this.components[i].distribution.sd(), this.components[i].distribution.mean() + 3.0 * this.components[i].distribution.sd(), this.samples, (Comparable)("subpop-" + i + " : " + " = " + String.format("%.3f", this.components[i].distribution.mean()) + "," + " = " + String.format("%.3f", this.components[i].distribution.sd())));
>             dataset.addSeries(s1);
>             rtMonomer.setValue("Subpopulation", i, String.valueOf(i + 1));
>             rtMonomer.setValue("", i, String.format("%.3f", this.components[i].distribution.mean()));
>             rtMonomer.setValue("", i, String.format("%.3f", this.components[i].distribution.sd()));
>             rtMonomer.setValue("Entropy", i, String.format("%.3f", this.components[i].distribution.entropy()));
>             rtMonomer.setValue("N of Parameters", i, (double)this.components[i].distribution.length());
>             rtMonomer.setValue("Variance", i, String.format("%.3f", this.components[i].distribution.variance()));
>             if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE && this.components.length == 2) {
>                 monomerValue = Math.abs(this.components[0].distribution.mean() - this.components[1].distribution.mean());
>             }
>         }
>         if (SPTBatch_.checkMonomer.isSelected() == Boolean.TRUE) {
>             rtMonomer.setValue("N Receptor/Particle", 0, String.valueOf(this.meanValue / Double.valueOf(SPTBatch_.monomerField.getText())));
>         }
>         if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE) {
>             if (monomerValue == 0.0) {
>                 rtMonomer.setValue("N Receptor/Particle", 0, "1");
>                 monomerValue = this.components[0].distribution.mean();
>             }
>             else {
>                 rtMonomer.setValue("N Receptor/Particle", 0, String.valueOf(this.meanValue / monomerValue));
>             }
>         }
>         if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE) {
>             rtMonomer.setValue("Monomer Intensity", 0, monomerValue);
>         }
>         if (SPTBatch_.checkMonomer.isSelected() == Boolean.TRUE) {
>             rtMonomer.setValue("Monomer Intensity", 0, SPTBatch_.monomerField.getText());
>         }
>         rtMonomer.setValue("Track Mean Intensity", 0, String.valueOf(this.meanValue));
>         final JFreeChart chart = ChartFactory.createXYLineChart("Distribution of Single Integrated Intensities for Track-" + this.nOfTrack.toString(), "Integrated Intensity", "Probability Density [nmolecule-1]", (XYDataset)dataset, PlotOrientation.VERTICAL, true, true, false);
>         final XYPlot plot = (XYPlot)chart.getPlot();
>         plot.setDomainZeroBaselineVisible(true);
>         plot.setRangeZeroBaselineVisible(true);
>         plot.setDomainPannable(true);
>         plot.setRangePannable(true);
>         plot.setBackgroundPaint((Paint)Color.white);
>         plot.setDomainGridlinesVisible(true);
>         plot.setRangeGridlinesVisible(true);
>         plot.setDomainMinorGridlinePaint((Paint)Color.GRAY);
>         plot.setDomainGridlinePaint((Paint)Color.DARK_GRAY);
>         plot.setRangeMinorGridlinePaint((Paint)Color.GRAY);
>         plot.setRangeGridlinePaint((Paint)Color.DARK_GRAY);
>         final ValueAxis xAxis = plot.getDomainAxis();
>         xAxis.setLowerMargin(0.0);
>         xAxis.setUpperMargin(0.0);
>         final XYLineAndShapeRenderer r = (XYLineAndShapeRenderer)plot.getRenderer();
>         r.setDrawSeriesLineAsPath(true);
>         for (int j = 0; j < dataset.getSeriesCount(); ++j) {
>             r.setSeriesStroke(j, (Stroke)new BasicStroke(2.0f, 1, 1, 1.0f));
>         }
>         try {
>             rtMonomer.saveAs(String.valueOf(SPTBatch_.directCluster.getAbsolutePath()) + File.separator + SPTBatch_.imps.getShortTitle() + "_Cluster_Analysis_" + this.nOfTrack.toString() + ".csv");
>         }
>         catch (IOException e) {
>             e.printStackTrace();
>         }
>         try {
>             ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directCluster.getAbsolutePath()) + File.separator + SPTBatch_.imps.getShortTitle() + "_DistributionDensityFunction_" + this.nOfTrack.toString() + ".png"), chart, 500, 400);
>         }
>         catch (IOException e) {
>             e.printStackTrace();
>         }
>     }
diff -r TrackAnalyzer_/OptionWizardPanel.java procyon/OptionWizardPanel.java
1c1,3
< import ij.IJ;
---
> import java.util.Collections;
> import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
> import javax.swing.Icon;
3,9d4
< import java.awt.BasicStroke;
< import java.awt.Color;
< import java.awt.Dimension;
< import java.awt.FlowLayout;
< import java.awt.Font;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
11d5
< import java.io.File;
13,16c7
< import java.util.ArrayList;
< import java.util.Arrays;
< import java.util.Collections;
< import java.util.List;
---
> import java.awt.image.RenderedImage;
17a9,21
> import ij.IJ;
> import java.io.File;
> import javax.swing.JFrame;
> import javax.swing.JFileChooser;
> import java.awt.event.ActionEvent;
> import java.awt.event.ActionListener;
> import javax.swing.JTabbedPane;
> import javax.swing.JScrollPane;
> import javax.swing.table.TableModel;
> import javax.swing.JTable;
> import javax.swing.JSeparator;
> import java.awt.Font;
> import javax.swing.border.Border;
20,21c24,28
< import javax.swing.BoxLayout;
< import javax.swing.Icon;
---
> import java.awt.FlowLayout;
> import javax.swing.SpinnerModel;
> import javax.swing.SpinnerNumberModel;
> import java.awt.Component;
> import java.awt.Dimension;
22a30,43
> import java.util.Collection;
> import java.util.ArrayList;
> import java.util.Arrays;
> import java.awt.Stroke;
> import java.awt.Paint;
> import java.awt.BasicStroke;
> import java.awt.Color;
> import java.awt.LayoutManager;
> import java.awt.Container;
> import javax.swing.BoxLayout;
> import jwizardcomponent.JWizardComponents;
> import javax.swing.table.DefaultTableModel;
> import javax.swing.JPanel;
> import org.jfree.chart.ChartPanel;
23a45
> import java.util.List;
25,26d46
< import javax.swing.JFileChooser;
< import javax.swing.JFrame;
28,30d47
< import javax.swing.JPanel;
< import javax.swing.JScrollPane;
< import javax.swing.JSeparator;
32,38d48
< import javax.swing.JTabbedPane;
< import javax.swing.JTable;
< import javax.swing.SpinnerNumberModel;
< import javax.swing.table.DefaultTableModel;
< import jwizardcomponent.JWizardComponents;
< import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
< import org.jfree.chart.ChartPanel;
41,264c51,260
< public class OptionWizardPanel extends LabelWizardPanel {
<    public double maxDomainSpot;
<    public double maxRangeSpot;
<    public double maxDomainTrack;
<    public double maxRangeTrack;
<    public IntervalMarker markerRangeSpot;
<    public IntervalMarker markerDomainSpot;
<    public IntervalMarker markerRangeTrack;
<    public IntervalMarker markerDomainTrack;
<    private JSpinner filterOrderSpot;
<    private JSpinner filterOrderTrack;
<    static int selectedIndexCh2;
<    static int selectedIndexCh3;
<    static int numCh2Positive;
<    static int numCh3Positive;
<    static int countSenescentNumber;
<    static int lhCountAll;
<    static int hhCountAll;
<    static int llCountAll;
<    static int hlCountAll;
<    static int lhCountNID;
<    static int hhCountNID;
<    static int llCountNID;
<    static int hlCountNID;
<    static int lhCountClass;
<    static int hhCountClass;
<    static int llCountClass;
<    static int hlCountClass;
<    static int selectedIndexDomainSpot;
<    static int selectedIndexRangeSpot;
<    static int selectedIndexDomainTrack;
<    static int selectedIndexRangeTrack;
<    static JLabel scatLabel;
<    static JLabel sumLabel;
<    static JLabel labelScoresSpot;
<    static JLabel labelScoresTrack;
<    JComboBox<String> comboFeatureDomainSpot;
<    JComboBox<String> comboFeatureRangeSpot;
<    JComboBox<String> comboFeatureDomainTrack;
<    JComboBox<String> comboFeatureRangeTrack;
<    JComboBox<String> comboClassSpot;
<    JComboBox<String> comboParamSpot;
<    JComboBox<String> comboClassTrack;
<    JComboBox<String> comboParamTrack;
<    JComboBox<String> comboRegressionSpot;
<    JComboBox<String> comboRegressionTrack;
<    List<String> itemFiltersSpot;
<    List<String> itemFiltersTrack;
<    STScatterPlot scatterPlot;
<    JButton refreshButtonSpot;
<    JButton zoomInSpot;
<    JButton zoomOutSpot;
<    JButton refreshButtonTrack;
<    JButton zoomInTrack;
<    JButton zoomOutTrack;
<    STScatterPlot sp2Spot;
<    STScatterPlot sp2Track;
<    ChartPanel scatterPlotSpot;
<    ChartPanel scatterPlotTrack;
<    static JPanel regressionPanelSpot;
<    static JPanel regressionPanelTrack;
<    List<Double> dataToStatisticsSpot;
<    List<Double> dataToStatisticsTrack;
<    DefaultTableModel modelSpot;
<    DefaultTableModel modelTrack;
<    Thread refreshSpotThread;
<    Thread refreshTrackThread;
<    Thread zoomInSpotThread;
<    Thread zoomInTrackThread;
<    Thread zoomOutSpotThread;
<    Thread zoomOutTrackThread;
<    Thread comboRegSpotThread;
<    Thread comboRegTrackThread;
<    Thread comboClassSpotThread;
<    Thread comboClassTrackThread;
< 
<    public OptionWizardPanel(JWizardComponents wizardComponents, String option) {
<       super(wizardComponents, "");
<       this.setPanelTitle("");
<       this.setLayout(new BoxLayout(this, 1));
<       JPanel chartPanel2Spot = new JPanel();
<       this.markerRangeSpot = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.6F);
<       this.markerDomainSpot = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.5F);
<       this.markerRangeTrack = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.6F);
<       this.markerDomainTrack = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.5F);
<       this.sp2Spot = new STScatterPlot("");
<       this.scatterPlotSpot = this.sp2Spot.createScatterChartPanelInitial("", "", new ArrayList(Arrays.asList(0.0D, 0.0D, 0.0D)), new ArrayList(Arrays.asList(0.0D, 0.0D, 0.0D)), this.markerRangeSpot, this.markerDomainSpot, new Double[][]{{0.0D}, {0.0D}}, new Double[][]{{0.0D}, {0.0D}});
<       this.refreshButtonSpot = new JButton("");
<       this.refreshButtonSpot.setIcon(FirstWizardPanel.refreshCell);
<       this.refreshButtonSpot.setToolTipText("Click this button to refresh scatter-plot.");
<       this.zoomInSpot = new JButton("");
<       ImageIcon iconZoomIn = FirstWizardPanel.createImageIcon("images/zoomin.png");
<       Icon zoomInCell = new ImageIcon(iconZoomIn.getImage().getScaledInstance(18, 20, 4));
<       this.zoomInSpot.setIcon(zoomInCell);
<       this.zoomInSpot.setToolTipText("Click this button to zoom in Chart");
<       this.zoomOutSpot = new JButton("");
<       ImageIcon iconZoomOut = FirstWizardPanel.createImageIcon("images/zoomout.png");
<       Icon zoomOutCell = new ImageIcon(iconZoomOut.getImage().getScaledInstance(18, 20, 4));
<       this.zoomOutSpot.setIcon(zoomOutCell);
<       this.zoomOutSpot.setToolTipText("Click this button to zoom out Chart");
<       this.itemFiltersSpot = new ArrayList();
<       this.itemFiltersTrack = new ArrayList();
< 
<       int i;
<       for(i = 2; i < FirstWizardPanel.columnNamesSpot.length; ++i) {
<          this.itemFiltersSpot.add(FirstWizardPanel.columnNamesSpot[i].toString());
<       }
< 
<       for(i = 0; i < ChooserWizardPanel.columnNamesTrack.length; ++i) {
<          this.itemFiltersTrack.add(ChooserWizardPanel.columnNamesTrack[i].toString());
<       }
< 
<       this.comboFeatureDomainSpot = new JComboBox();
<       this.comboFeatureDomainSpot.setPreferredSize(new Dimension(110, 20));
< 
<       for(i = 0; i < this.itemFiltersSpot.size(); ++i) {
<          this.comboFeatureDomainSpot.addItem((String)this.itemFiltersSpot.get(i));
<       }
< 
<       this.comboFeatureDomainSpot.setOpaque(true);
<       this.scatterPlot = new STScatterPlot("holaa");
<       chartPanel2Spot.add(this.scatterPlotSpot);
<       this.filterOrderSpot = new JSpinner(new SpinnerNumberModel(1, 0, 1000, 1));
<       this.filterOrderSpot.setPreferredSize(new Dimension(60, 20));
<       this.filterOrderSpot.setEnabled(false);
<       JPanel filtersMaxSpot = new JPanel(new FlowLayout(1));
<       filtersMaxSpot.add(Box.createHorizontalStrut(2));
<       this.comboFeatureRangeSpot = new JComboBox();
<       this.comboFeatureRangeSpot.setPreferredSize(new Dimension(110, 20));
< 
<       for(int i = 0; i < this.itemFiltersSpot.size(); ++i) {
<          this.comboFeatureRangeSpot.addItem((String)this.itemFiltersSpot.get(i));
<       }
< 
<       this.comboFeatureRangeSpot.setOpaque(true);
<       filtersMaxSpot.add(new JLabel("X :  "));
<       filtersMaxSpot.add(this.comboFeatureDomainSpot);
<       filtersMaxSpot.add(new JLabel("   Y :  "));
<       filtersMaxSpot.add(this.comboFeatureRangeSpot);
<       JPanel rangePanelFSpot = new JPanel(new FlowLayout(0));
<       JPanel chartDomainPanelBoxSpot = new JPanel();
<       chartDomainPanelBoxSpot.setLayout(new BoxLayout(chartDomainPanelBoxSpot, 1));
<       chartDomainPanelBoxSpot.add(Box.createVerticalStrut(10));
<       chartDomainPanelBoxSpot.add(chartPanel2Spot);
<       chartDomainPanelBoxSpot.add(filtersMaxSpot);
<       rangePanelFSpot.add(chartDomainPanelBoxSpot);
<       JPanel buttonBox = new JPanel();
<       buttonBox.setLayout(new BoxLayout(buttonBox, 1));
<       JPanel refreshButtonPanelSpot = new JPanel(new FlowLayout(0));
<       refreshButtonPanelSpot.add(this.refreshButtonSpot);
<       JPanel zoomOutButtonPanelSpot = new JPanel(new FlowLayout(0));
<       zoomOutButtonPanelSpot.add(this.zoomOutSpot);
<       JPanel zoomInButtonPanelSpot = new JPanel(new FlowLayout(0));
<       zoomInButtonPanelSpot.add(this.zoomInSpot);
<       buttonBox.add(zoomInButtonPanelSpot);
<       buttonBox.add(zoomOutButtonPanelSpot);
<       buttonBox.add(refreshButtonPanelSpot);
<       this.comboRegressionSpot = new JComboBox();
<       this.comboRegressionSpot.setPreferredSize(new Dimension(90, 20));
<       this.comboRegressionSpot.addItem("Linear");
<       this.comboRegressionSpot.addItem("Polynomial");
<       this.comboRegressionSpot.addItem("Power");
<       this.comboRegressionSpot.addItem("Logarithmic");
<       this.comboRegressionSpot.addItem("Exponential");
<       this.comboRegressionSpot.setSelectedIndex(0);
<       this.comboRegressionSpot.setOpaque(true);
<       JPanel regreOrderPanel = new JPanel(new FlowLayout(0));
<       regreOrderPanel.add(this.comboRegressionSpot);
<       JPanel filterOrderPanel = new JPanel(new FlowLayout(0));
<       filterOrderPanel.add(this.filterOrderSpot);
<       buttonBox.add(regreOrderPanel);
<       buttonBox.add(filterOrderPanel);
<       regressionPanelSpot = new JPanel();
<       regressionPanelSpot.setBorder(BorderFactory.createTitledBorder("Reg.Params"));
<       regressionPanelSpot.setPreferredSize(new Dimension(this.comboRegressionSpot.getWidth() + 10, 35));
<       rangePanelFSpot.add(buttonBox);
<       JPanel spotPanel = new JPanel();
<       spotPanel.add(rangePanelFSpot);
<       spotPanel.setBorder(BorderFactory.createTitledBorder(""));
<       JPanel spotStatistics = new JPanel();
<       spotStatistics.setLayout(new BoxLayout(spotStatistics, 1));
<       JPanel spotStatisticsFlow = new JPanel(new FlowLayout(0));
<       JPanel classParamSpot = new JPanel(new FlowLayout(0));
<       this.comboClassSpot = new JComboBox();
<       this.comboClassSpot.setPreferredSize(new Dimension(120, 20));
< 
<       int i;
<       for(i = 2; i < FirstWizardPanel.columnNamesSpot.length; ++i) {
<          this.comboClassSpot.addItem((String)FirstWizardPanel.columnNamesSpot[i]);
<       }
< 
<       this.comboClassSpot.setOpaque(true);
<       this.comboClassSpot.setToolTipText("Choose selected items for descriptive statistics.");
<       this.comboParamSpot = new JComboBox();
<       this.comboParamSpot.setPreferredSize(new Dimension(120, 20));
< 
<       for(i = 2; i < FirstWizardPanel.columnNamesSpot.length; ++i) {
<          this.comboParamSpot.addItem((String)FirstWizardPanel.columnNamesSpot[i]);
<       }
< 
<       this.comboParamSpot.setOpaque(true);
<       this.comboParamSpot.setToolTipText("Choose a spot parameter for descriptive statistics.");
<       classParamSpot.add(this.comboClassSpot);
<       classParamSpot.add(this.comboParamSpot);
<       labelScoresSpot = new JLabel("SCORES");
<       labelScoresSpot.setFont(new Font("Verdana", 1, 20));
<       spotStatisticsFlow.add(labelScoresSpot);
<       spotStatistics.add(Box.createVerticalStrut(60));
<       spotStatistics.add(spotStatisticsFlow);
<       spotStatistics.add(new JSeparator(0));
<       spotStatistics.add(Box.createVerticalStrut(20));
<       spotStatistics.add(classParamSpot);
<       spotStatistics.add(Box.createVerticalStrut(20));
<       spotStatistics.add(new JSeparator(0));
<       String[][] data = new String[][]{{"", "", "", "", "", "", "", "", "", "", ""}};
<       String[] column = new String[]{"Mean ", "Std.Error ", "Median ", "Std.Dev ", "Variance ", "Kurtosis ", "Skewness ", "Min ", "Max ", "Sum ", "Count "};
<       JTable table = new JTable();
<       this.modelSpot = new DefaultTableModel(data, column) {
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class OptionWizardPanel extends LabelWizardPanel
> {
>     public double maxDomainSpot;
>     public double maxRangeSpot;
>     public double maxDomainTrack;
>     public double maxRangeTrack;
>     public IntervalMarker markerRangeSpot;
>     public IntervalMarker markerDomainSpot;
>     public IntervalMarker markerRangeTrack;
>     public IntervalMarker markerDomainTrack;
>     private JSpinner filterOrderSpot;
>     private JSpinner filterOrderTrack;
>     static int selectedIndexCh2;
>     static int selectedIndexCh3;
>     static int numCh2Positive;
>     static int numCh3Positive;
>     static int countSenescentNumber;
>     static int lhCountAll;
>     static int hhCountAll;
>     static int llCountAll;
>     static int hlCountAll;
>     static int lhCountNID;
>     static int hhCountNID;
>     static int llCountNID;
>     static int hlCountNID;
>     static int lhCountClass;
>     static int hhCountClass;
>     static int llCountClass;
>     static int hlCountClass;
>     static int selectedIndexDomainSpot;
>     static int selectedIndexRangeSpot;
>     static int selectedIndexDomainTrack;
>     static int selectedIndexRangeTrack;
>     static JLabel scatLabel;
>     static JLabel sumLabel;
>     static JLabel labelScoresSpot;
>     static JLabel labelScoresTrack;
>     JComboBox<String> comboFeatureDomainSpot;
>     JComboBox<String> comboFeatureRangeSpot;
>     JComboBox<String> comboFeatureDomainTrack;
>     JComboBox<String> comboFeatureRangeTrack;
>     JComboBox<String> comboClassSpot;
>     JComboBox<String> comboParamSpot;
>     JComboBox<String> comboClassTrack;
>     JComboBox<String> comboParamTrack;
>     JComboBox<String> comboRegressionSpot;
>     JComboBox<String> comboRegressionTrack;
>     List<String> itemFiltersSpot;
>     List<String> itemFiltersTrack;
>     STScatterPlot scatterPlot;
>     JButton refreshButtonSpot;
>     JButton zoomInSpot;
>     JButton zoomOutSpot;
>     JButton refreshButtonTrack;
>     JButton zoomInTrack;
>     JButton zoomOutTrack;
>     STScatterPlot sp2Spot;
>     STScatterPlot sp2Track;
>     ChartPanel scatterPlotSpot;
>     ChartPanel scatterPlotTrack;
>     static JPanel regressionPanelSpot;
>     static JPanel regressionPanelTrack;
>     List<Double> dataToStatisticsSpot;
>     List<Double> dataToStatisticsTrack;
>     DefaultTableModel modelSpot;
>     DefaultTableModel modelTrack;
>     Thread refreshSpotThread;
>     Thread refreshTrackThread;
>     Thread zoomInSpotThread;
>     Thread zoomInTrackThread;
>     Thread zoomOutSpotThread;
>     Thread zoomOutTrackThread;
>     Thread comboRegSpotThread;
>     Thread comboRegTrackThread;
>     Thread comboClassSpotThread;
>     Thread comboClassTrackThread;
>     
>     public OptionWizardPanel(final JWizardComponents wizardComponents, final String option) {
>         super(wizardComponents, "");
>         this.setPanelTitle("");
>         this.setLayout((LayoutManager)new BoxLayout((Container)this, 1));
>         final JPanel chartPanel2Spot = new JPanel();
>         this.markerRangeSpot = new IntervalMarker(0.0, 0.0, (Paint)new Color(229, 255, 204), (Stroke)new BasicStroke(), (Paint)new Color(0, 102, 0), (Stroke)new BasicStroke(1.5f), 0.6f);
>         this.markerDomainSpot = new IntervalMarker(0.0, 0.0, (Paint)new Color(229, 255, 204), (Stroke)new BasicStroke(), (Paint)new Color(0, 102, 0), (Stroke)new BasicStroke(1.5f), 0.5f);
>         this.markerRangeTrack = new IntervalMarker(0.0, 0.0, (Paint)new Color(229, 255, 204), (Stroke)new BasicStroke(), (Paint)new Color(0, 102, 0), (Stroke)new BasicStroke(1.5f), 0.6f);
>         this.markerDomainTrack = new IntervalMarker(0.0, 0.0, (Paint)new Color(229, 255, 204), (Stroke)new BasicStroke(), (Paint)new Color(0, 102, 0), (Stroke)new BasicStroke(1.5f), 0.5f);
>         this.sp2Spot = new STScatterPlot("");
>         this.scatterPlotSpot = this.sp2Spot.createScatterChartPanelInitial("", "", new ArrayList<Double>(Arrays.<Double>asList(0.0, 0.0, 0.0)), new ArrayList<Double>(Arrays.<Double>asList(0.0, 0.0, 0.0)), this.markerRangeSpot, this.markerDomainSpot, new Double[][] { { 0.0 }, { 0.0 } }, new Double[][] { { 0.0 }, { 0.0 } });
>         (this.refreshButtonSpot = new JButton("")).setIcon(FirstWizardPanel.refreshCell);
>         this.refreshButtonSpot.setToolTipText("Click this button to refresh scatter-plot.");
>         this.zoomInSpot = new JButton("");
>         final ImageIcon iconZoomIn = FirstWizardPanel.createImageIcon("images/zoomin.png");
>         final Icon zoomInCell = new ImageIcon(iconZoomIn.getImage().getScaledInstance(18, 20, 4));
>         this.zoomInSpot.setIcon(zoomInCell);
>         this.zoomInSpot.setToolTipText("Click this button to zoom in Chart");
>         this.zoomOutSpot = new JButton("");
>         final ImageIcon iconZoomOut = FirstWizardPanel.createImageIcon("images/zoomout.png");
>         final Icon zoomOutCell = new ImageIcon(iconZoomOut.getImage().getScaledInstance(18, 20, 4));
>         this.zoomOutSpot.setIcon(zoomOutCell);
>         this.zoomOutSpot.setToolTipText("Click this button to zoom out Chart");
>         this.itemFiltersSpot = new ArrayList<String>();
>         this.itemFiltersTrack = new ArrayList<String>();
>         for (int i = 2; i < FirstWizardPanel.columnNamesSpot.length; ++i) {
>             this.itemFiltersSpot.add(FirstWizardPanel.columnNamesSpot[i].toString());
>         }
>         for (int i = 0; i < ChooserWizardPanel.columnNamesTrack.length; ++i) {
>             this.itemFiltersTrack.add(ChooserWizardPanel.columnNamesTrack[i].toString());
>         }
>         (this.comboFeatureDomainSpot = new JComboBox<String>()).setPreferredSize(new Dimension(110, 20));
>         for (int i = 0; i < this.itemFiltersSpot.size(); ++i) {
>             this.comboFeatureDomainSpot.addItem(this.itemFiltersSpot.get(i));
>         }
>         this.comboFeatureDomainSpot.setOpaque(true);
>         this.scatterPlot = new STScatterPlot("holaa");
>         chartPanel2Spot.add((Component)this.scatterPlotSpot);
>         (this.filterOrderSpot = new JSpinner(new SpinnerNumberModel(1, 0, 1000, 1))).setPreferredSize(new Dimension(60, 20));
>         this.filterOrderSpot.setEnabled(false);
>         final JPanel filtersMaxSpot = new JPanel(new FlowLayout(1));
>         filtersMaxSpot.add(Box.createHorizontalStrut(2));
>         (this.comboFeatureRangeSpot = new JComboBox<String>()).setPreferredSize(new Dimension(110, 20));
>         for (int j = 0; j < this.itemFiltersSpot.size(); ++j) {
>             this.comboFeatureRangeSpot.addItem(this.itemFiltersSpot.get(j));
>         }
>         this.comboFeatureRangeSpot.setOpaque(true);
>         filtersMaxSpot.add(new JLabel("X :  "));
>         filtersMaxSpot.add(this.comboFeatureDomainSpot);
>         filtersMaxSpot.add(new JLabel("   Y :  "));
>         filtersMaxSpot.add(this.comboFeatureRangeSpot);
>         final JPanel rangePanelFSpot = new JPanel(new FlowLayout(0));
>         final JPanel chartDomainPanelBoxSpot = new JPanel();
>         chartDomainPanelBoxSpot.setLayout(new BoxLayout(chartDomainPanelBoxSpot, 1));
>         chartDomainPanelBoxSpot.add(Box.createVerticalStrut(10));
>         chartDomainPanelBoxSpot.add(chartPanel2Spot);
>         chartDomainPanelBoxSpot.add(filtersMaxSpot);
>         rangePanelFSpot.add(chartDomainPanelBoxSpot);
>         final JPanel buttonBox = new JPanel();
>         buttonBox.setLayout(new BoxLayout(buttonBox, 1));
>         final JPanel refreshButtonPanelSpot = new JPanel(new FlowLayout(0));
>         refreshButtonPanelSpot.add(this.refreshButtonSpot);
>         final JPanel zoomOutButtonPanelSpot = new JPanel(new FlowLayout(0));
>         zoomOutButtonPanelSpot.add(this.zoomOutSpot);
>         final JPanel zoomInButtonPanelSpot = new JPanel(new FlowLayout(0));
>         zoomInButtonPanelSpot.add(this.zoomInSpot);
>         buttonBox.add(zoomInButtonPanelSpot);
>         buttonBox.add(zoomOutButtonPanelSpot);
>         buttonBox.add(refreshButtonPanelSpot);
>         (this.comboRegressionSpot = new JComboBox<String>()).setPreferredSize(new Dimension(90, 20));
>         this.comboRegressionSpot.addItem("Linear");
>         this.comboRegressionSpot.addItem("Polynomial");
>         this.comboRegressionSpot.addItem("Power");
>         this.comboRegressionSpot.addItem("Logarithmic");
>         this.comboRegressionSpot.addItem("Exponential");
>         this.comboRegressionSpot.setSelectedIndex(0);
>         this.comboRegressionSpot.setOpaque(true);
>         final JPanel regreOrderPanel = new JPanel(new FlowLayout(0));
>         regreOrderPanel.add(this.comboRegressionSpot);
>         final JPanel filterOrderPanel = new JPanel(new FlowLayout(0));
>         filterOrderPanel.add(this.filterOrderSpot);
>         buttonBox.add(regreOrderPanel);
>         buttonBox.add(filterOrderPanel);
>         (OptionWizardPanel.regressionPanelSpot = new JPanel()).setBorder(BorderFactory.createTitledBorder("Reg.Params"));
>         OptionWizardPanel.regressionPanelSpot.setPreferredSize(new Dimension(this.comboRegressionSpot.getWidth() + 10, 35));
>         rangePanelFSpot.add(buttonBox);
>         final JPanel spotPanel = new JPanel();
>         spotPanel.add(rangePanelFSpot);
>         spotPanel.setBorder(BorderFactory.createTitledBorder(""));
>         final JPanel spotStatistics = new JPanel();
>         spotStatistics.setLayout(new BoxLayout(spotStatistics, 1));
>         final JPanel spotStatisticsFlow = new JPanel(new FlowLayout(0));
>         final JPanel classParamSpot = new JPanel(new FlowLayout(0));
>         (this.comboClassSpot = new JComboBox<String>()).setPreferredSize(new Dimension(120, 20));
>         for (int k = 2; k < FirstWizardPanel.columnNamesSpot.length; ++k) {
>             this.comboClassSpot.addItem((String)FirstWizardPanel.columnNamesSpot[k]);
>         }
>         this.comboClassSpot.setOpaque(true);
>         this.comboClassSpot.setToolTipText("Choose selected items for descriptive statistics.");
>         (this.comboParamSpot = new JComboBox<String>()).setPreferredSize(new Dimension(120, 20));
>         for (int k = 2; k < FirstWizardPanel.columnNamesSpot.length; ++k) {
>             this.comboParamSpot.addItem((String)FirstWizardPanel.columnNamesSpot[k]);
>         }
>         this.comboParamSpot.setOpaque(true);
>         this.comboParamSpot.setToolTipText("Choose a spot parameter for descriptive statistics.");
>         classParamSpot.add(this.comboClassSpot);
>         classParamSpot.add(this.comboParamSpot);
>         (OptionWizardPanel.labelScoresSpot = new JLabel("SCORES")).setFont(new Font("Verdana", 1, 20));
>         spotStatisticsFlow.add(OptionWizardPanel.labelScoresSpot);
>         spotStatistics.add(Box.createVerticalStrut(60));
>         spotStatistics.add(spotStatisticsFlow);
>         spotStatistics.add(new JSeparator(0));
>         spotStatistics.add(Box.createVerticalStrut(20));
>         spotStatistics.add(classParamSpot);
>         spotStatistics.add(Box.createVerticalStrut(20));
>         spotStatistics.add(new JSeparator(0));
>         final String[][] data = { { "", "", "", "", "", "", "", "", "", "", "" } };
>         final String[] column = { "Mean ", "Std.Error ", "Median ", "Std.Dev ", "Variance ", "Kurtosis ", "Skewness ", "Min ", "Max ", "Sum ", "Count " };
>         final JTable table = new JTable();
>         this.modelSpot = new DefaultTableModel(data, column) {
>             @Override
>             public Class<?> getColumnClass(final int column) {
>                 if (this.getRowCount() > 0) {
>                     final Object value = this.getValueAt(0, column);
>                     if (value != null) {
>                         return this.getValueAt(0, column).getClass();
>                     }
>                 }
>                 return super.getColumnClass(column);
266,439c262,265
< 
<             return super.getColumnClass(column);
<          }
< 
<          public boolean isCellEditable(int row, int col) {
<             return false;
<          }
<       };
<       table.setAutoResizeMode(0);
<       table.setModel(this.modelSpot);
<       table.setRowHeight(60);
<       JScrollPane sp = new JScrollPane(table);
<       sp.setPreferredSize(new Dimension(500, 100));
<       sp.setVerticalScrollBarPolicy(22);
<       sp.setHorizontalScrollBarPolicy(32);
< 
<       for(int u = 0; u < table.getColumnCount(); ++u) {
<          table.getColumnModel().getColumn(u).setMinWidth(100);
<          table.getColumnModel().getColumn(u).setMaxWidth(100);
<          table.getColumnModel().getColumn(u).setPreferredWidth(100);
<       }
< 
<       spotStatistics.add(Box.createVerticalStrut(20));
<       spotStatistics.add(sp);
<       spotStatistics.add(Box.createVerticalStrut(20));
<       spotStatistics.add(new JSeparator(0));
<       JButton plotButton = new JButton();
<       ImageIcon iconPlot = FirstWizardPanel.createImageIcon("images/plot.jpg");
<       Icon plotCell = new ImageIcon(iconPlot.getImage().getScaledInstance(18, 20, 4));
<       plotButton.setIcon(plotCell);
<       plotButton.setToolTipText("Click to export scatter plot.");
<       JPanel panelPlot = new JPanel(new FlowLayout(0));
<       panelPlot.add(plotButton);
<       JButton csvButton = new JButton();
<       ImageIcon iconCsv = FirstWizardPanel.createImageIcon("images/csv.png");
<       Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
<       csvButton.setIcon(csvCell);
<       csvButton.setToolTipText("Click to export your spots statistics table.");
<       JPanel panelCsv = new JPanel(new FlowLayout(0));
<       panelCsv.add(csvButton);
<       JPanel panelPngCsv = new JPanel(new FlowLayout(0));
<       panelPngCsv.add(panelPlot);
<       panelPngCsv.add(panelCsv);
<       spotStatistics.add(panelPngCsv);
<       spotPanel.add(spotStatistics);
<       JPanel chartPanel2Track = new JPanel();
<       this.sp2Track = new STScatterPlot("");
<       this.scatterPlotTrack = this.sp2Track.createScatterChartPanelInitial("", "", new ArrayList(Arrays.asList(0.0D, 0.0D, 0.0D)), new ArrayList(Arrays.asList(0.0D, 0.0D, 0.0D)), this.markerRangeTrack, this.markerDomainTrack, new Double[][]{{0.0D}, {0.0D}}, new Double[][]{{0.0D}, {0.0D}});
<       this.refreshButtonTrack = new JButton("");
<       this.refreshButtonTrack.setIcon(FirstWizardPanel.refreshCell);
<       this.refreshButtonTrack.setToolTipText("Click this button to refresh scatter-plot.");
<       this.zoomInTrack = new JButton("");
<       this.zoomInTrack.setIcon(zoomInCell);
<       this.zoomInTrack.setToolTipText("Click this button to zoom in Chart");
<       this.zoomOutTrack = new JButton("");
<       this.zoomOutTrack.setIcon(zoomOutCell);
<       this.zoomOutTrack.setToolTipText("Click this button to zoom out Chart");
< 
<       int i;
<       for(i = 0; i < ChooserWizardPanel.columnNamesTrack.length; ++i) {
<          this.itemFiltersTrack.add(ChooserWizardPanel.columnNamesTrack[i].toString());
<       }
< 
<       this.comboFeatureDomainTrack = new JComboBox();
<       this.comboFeatureDomainTrack.setPreferredSize(new Dimension(110, 20));
< 
<       for(i = 3; i < this.itemFiltersTrack.size(); ++i) {
<          this.comboFeatureDomainTrack.addItem((String)this.itemFiltersTrack.get(i));
<       }
< 
<       this.comboFeatureDomainTrack.setOpaque(true);
<       chartPanel2Track.add(this.scatterPlotTrack);
<       this.filterOrderTrack = new JSpinner(new SpinnerNumberModel(1, 0, 1000, 1));
<       this.filterOrderTrack.setPreferredSize(new Dimension(60, 20));
<       this.filterOrderTrack.setEnabled(false);
<       JPanel filtersMaxTrack = new JPanel(new FlowLayout(1));
<       filtersMaxTrack.add(Box.createHorizontalStrut(2));
<       this.comboFeatureRangeTrack = new JComboBox();
<       this.comboFeatureRangeTrack.setPreferredSize(new Dimension(110, 20));
< 
<       for(int i = 3; i < this.itemFiltersTrack.size(); ++i) {
<          this.comboFeatureRangeTrack.addItem((String)this.itemFiltersTrack.get(i));
<       }
< 
<       this.comboFeatureRangeTrack.setOpaque(true);
<       filtersMaxTrack.add(new JLabel("X :  "));
<       filtersMaxTrack.add(this.comboFeatureDomainTrack);
<       filtersMaxTrack.add(new JLabel("   Y :  "));
<       filtersMaxTrack.add(this.comboFeatureRangeTrack);
<       JPanel rangePanelFTrack = new JPanel(new FlowLayout(0));
<       JPanel chartDomainPanelBoxTrack = new JPanel();
<       chartDomainPanelBoxTrack.setLayout(new BoxLayout(chartDomainPanelBoxTrack, 1));
<       chartDomainPanelBoxTrack.add(Box.createVerticalStrut(10));
<       chartDomainPanelBoxTrack.add(chartPanel2Track);
<       chartDomainPanelBoxTrack.add(filtersMaxTrack);
<       rangePanelFTrack.add(chartDomainPanelBoxTrack);
<       JPanel buttonBoxTrack = new JPanel();
<       buttonBoxTrack.setLayout(new BoxLayout(buttonBoxTrack, 1));
<       JPanel refreshButtonPanelTrack = new JPanel(new FlowLayout(0));
<       refreshButtonPanelTrack.add(this.refreshButtonTrack);
<       JPanel zoomOutButtonPanelTrack = new JPanel(new FlowLayout(0));
<       zoomOutButtonPanelTrack.add(this.zoomOutTrack);
<       JPanel zoomInButtonPanelTrack = new JPanel(new FlowLayout(0));
<       zoomInButtonPanelTrack.add(this.zoomInTrack);
<       buttonBoxTrack.add(zoomInButtonPanelTrack);
<       buttonBoxTrack.add(zoomOutButtonPanelTrack);
<       buttonBoxTrack.add(refreshButtonPanelTrack);
<       this.comboRegressionTrack = new JComboBox();
<       this.comboRegressionTrack.setPreferredSize(new Dimension(90, 20));
<       this.comboRegressionTrack.addItem("Linear");
<       this.comboRegressionTrack.addItem("Polynomial");
<       this.comboRegressionTrack.addItem("Power");
<       this.comboRegressionTrack.addItem("Logarithmic");
<       this.comboRegressionTrack.addItem("Exponential");
<       this.comboRegressionTrack.setSelectedIndex(0);
<       this.comboRegressionTrack.setOpaque(true);
<       JPanel regreOrderPanelTrack = new JPanel(new FlowLayout(0));
<       regreOrderPanelTrack.add(this.comboRegressionTrack);
<       JPanel filterOrderPanelTrack = new JPanel(new FlowLayout(0));
<       filterOrderPanelTrack.add(this.filterOrderTrack);
<       buttonBoxTrack.add(regreOrderPanelTrack);
<       buttonBoxTrack.add(filterOrderPanelTrack);
<       regressionPanelTrack = new JPanel();
<       regressionPanelTrack.setBorder(BorderFactory.createTitledBorder("Reg.Params"));
<       regressionPanelTrack.setPreferredSize(new Dimension(this.comboRegressionTrack.getWidth() + 10, 35));
<       rangePanelFTrack.add(buttonBoxTrack);
<       JPanel trackPanel = new JPanel();
<       trackPanel.add(rangePanelFTrack);
<       trackPanel.setBorder(BorderFactory.createTitledBorder(""));
<       JPanel trackStatistics = new JPanel();
<       trackStatistics.setLayout(new BoxLayout(trackStatistics, 1));
<       JPanel trackStatisticsFlow = new JPanel(new FlowLayout(0));
<       JPanel classParamTrack = new JPanel(new FlowLayout(0));
<       this.comboClassTrack = new JComboBox();
<       this.comboClassTrack.setPreferredSize(new Dimension(120, 20));
< 
<       int i;
<       for(i = 3; i < ChooserWizardPanel.columnNamesTrack.length; ++i) {
<          this.comboClassTrack.addItem((String)ChooserWizardPanel.columnNamesTrack[i]);
<       }
< 
<       this.comboClassTrack.setOpaque(true);
<       this.comboClassTrack.setToolTipText("Choose selected items for descriptive statistics.");
<       this.comboParamTrack = new JComboBox();
<       this.comboParamTrack.setPreferredSize(new Dimension(120, 20));
< 
<       for(i = 3; i < ChooserWizardPanel.columnNamesTrack.length; ++i) {
<          this.comboParamTrack.addItem((String)ChooserWizardPanel.columnNamesTrack[i]);
<       }
< 
<       this.comboParamTrack.setOpaque(true);
<       this.comboParamTrack.setToolTipText("Choose a track parameter for descriptive statistics.");
<       classParamTrack.add(this.comboClassTrack);
<       classParamTrack.add(this.comboParamTrack);
<       labelScoresTrack = new JLabel("SCORES");
<       labelScoresTrack.setFont(new Font("Verdana", 1, 20));
<       trackStatisticsFlow.add(labelScoresTrack);
<       trackStatistics.add(Box.createVerticalStrut(60));
<       trackStatistics.add(trackStatisticsFlow);
<       trackStatistics.add(new JSeparator(0));
<       trackStatistics.add(Box.createVerticalStrut(20));
<       trackStatistics.add(classParamTrack);
<       trackStatistics.add(Box.createVerticalStrut(20));
<       trackStatistics.add(new JSeparator(0));
<       String[][] dataTrack = new String[][]{{"", "", "", "", "", "", "", "", "", "", ""}};
<       String[] columnTrack = new String[]{"Mean ", "Std.Error ", "Median ", "Std.Dev ", "Variance ", "Kurtosis ", "Skewness ", "Min ", "Max ", "Sum ", "Count "};
<       JTable tableTrack = new JTable();
<       this.modelTrack = new DefaultTableModel(dataTrack, columnTrack) {
<          public Class<?> getColumnClass(int columnTrack) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, columnTrack);
<                if (value != null) {
<                   return this.getValueAt(0, columnTrack).getClass();
<                }
---
>             
>             @Override
>             public boolean isCellEditable(final int row, final int col) {
>                 return false;
441,501c267,411
< 
<             return super.getColumnClass(columnTrack);
<          }
< 
<          public boolean isCellEditable(int row, int col) {
<             return false;
<          }
<       };
<       tableTrack.setAutoResizeMode(0);
<       tableTrack.setModel(this.modelTrack);
<       tableTrack.setRowHeight(60);
<       JScrollPane spTrack = new JScrollPane(tableTrack);
<       spTrack.setPreferredSize(new Dimension(500, 100));
<       spTrack.setVerticalScrollBarPolicy(22);
<       spTrack.setHorizontalScrollBarPolicy(32);
< 
<       for(int u = 0; u < tableTrack.getColumnCount(); ++u) {
<          tableTrack.getColumnModel().getColumn(u).setMinWidth(100);
<          tableTrack.getColumnModel().getColumn(u).setMaxWidth(100);
<          tableTrack.getColumnModel().getColumn(u).setPreferredWidth(100);
<       }
< 
<       trackStatistics.add(Box.createVerticalStrut(20));
<       trackStatistics.add(spTrack);
<       trackStatistics.add(Box.createVerticalStrut(20));
<       trackStatistics.add(new JSeparator(0));
<       JButton plotButtonTrack = new JButton();
<       plotButtonTrack.setIcon(plotCell);
<       plotButtonTrack.setToolTipText("Click to export scatter plot.");
<       JPanel panelPlotTrack = new JPanel(new FlowLayout(0));
<       panelPlotTrack.add(plotButtonTrack);
<       JButton csvButtonTrack = new JButton();
<       csvButtonTrack.setIcon(csvCell);
<       csvButtonTrack.setToolTipText("Click to export your tracks statistics table.");
<       JPanel panelCsvTrack = new JPanel(new FlowLayout(0));
<       panelCsvTrack.add(csvButtonTrack);
<       JPanel panelPngCsvTrack = new JPanel(new FlowLayout(0));
<       panelPngCsvTrack.add(panelPlotTrack);
<       panelPngCsvTrack.add(panelCsvTrack);
<       trackStatistics.add(panelPngCsvTrack);
<       trackPanel.add(trackStatistics);
<       JTabbedPane maintabbedPane = new JTabbedPane(1);
<       maintabbedPane.addTab("SPOTS ", FirstWizardPanel.iconSpotCell, spotPanel, "Scatter-Plot for spots");
<       maintabbedPane.addTab("TRACKS ", ChooserWizardPanel.iconTrackCell, trackPanel, "Scatter-Plot for tracks");
<       maintabbedPane.setTabLayoutPolicy(1);
<       this.add(maintabbedPane, "Center");
<       plotButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             JFileChooser fileChooser = new JFileChooser();
<             fileChooser.setFileSelectionMode(1);
<             fileChooser.setDialogTitle("Specify a directory to save plot as .png file");
<             int userSelection = fileChooser.showSaveDialog(new JFrame());
<             if (userSelection == 0) {
<                File fileToSave = fileChooser.getSelectedFile();
<                BufferedImage chartImage = STScatterPlot.plot.getChart().createBufferedImage(1024, 768);
< 
<                try {
<                   ImageIO.write(chartImage, "png", new File(fileToSave.getAbsolutePath() + File.separator + "SpotPlot for " + IJ.getImage().getShortTitle() + ".png"));
<                } catch (IOException var7) {
<                   var7.printStackTrace();
<                }
---
>         };
>         table.setAutoResizeMode(0);
>         table.setModel(this.modelSpot);
>         table.setRowHeight(60);
>         final JScrollPane sp = new JScrollPane(table);
>         sp.setPreferredSize(new Dimension(500, 100));
>         sp.setVerticalScrollBarPolicy(22);
>         sp.setHorizontalScrollBarPolicy(32);
>         for (int u = 0; u < table.getColumnCount(); ++u) {
>             table.getColumnModel().getColumn(u).setMinWidth(100);
>             table.getColumnModel().getColumn(u).setMaxWidth(100);
>             table.getColumnModel().getColumn(u).setPreferredWidth(100);
>         }
>         spotStatistics.add(Box.createVerticalStrut(20));
>         spotStatistics.add(sp);
>         spotStatistics.add(Box.createVerticalStrut(20));
>         spotStatistics.add(new JSeparator(0));
>         final JButton plotButton = new JButton();
>         final ImageIcon iconPlot = FirstWizardPanel.createImageIcon("images/plot.jpg");
>         final Icon plotCell = new ImageIcon(iconPlot.getImage().getScaledInstance(18, 20, 4));
>         plotButton.setIcon(plotCell);
>         plotButton.setToolTipText("Click to export scatter plot.");
>         final JPanel panelPlot = new JPanel(new FlowLayout(0));
>         panelPlot.add(plotButton);
>         final JButton csvButton = new JButton();
>         final ImageIcon iconCsv = FirstWizardPanel.createImageIcon("images/csv.png");
>         final Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
>         csvButton.setIcon(csvCell);
>         csvButton.setToolTipText("Click to export your spots statistics table.");
>         final JPanel panelCsv = new JPanel(new FlowLayout(0));
>         panelCsv.add(csvButton);
>         final JPanel panelPngCsv = new JPanel(new FlowLayout(0));
>         panelPngCsv.add(panelPlot);
>         panelPngCsv.add(panelCsv);
>         spotStatistics.add(panelPngCsv);
>         spotPanel.add(spotStatistics);
>         final JPanel chartPanel2Track = new JPanel();
>         this.sp2Track = new STScatterPlot("");
>         this.scatterPlotTrack = this.sp2Track.createScatterChartPanelInitial("", "", new ArrayList<Double>(Arrays.<Double>asList(0.0, 0.0, 0.0)), new ArrayList<Double>(Arrays.<Double>asList(0.0, 0.0, 0.0)), this.markerRangeTrack, this.markerDomainTrack, new Double[][] { { 0.0 }, { 0.0 } }, new Double[][] { { 0.0 }, { 0.0 } });
>         (this.refreshButtonTrack = new JButton("")).setIcon(FirstWizardPanel.refreshCell);
>         this.refreshButtonTrack.setToolTipText("Click this button to refresh scatter-plot.");
>         (this.zoomInTrack = new JButton("")).setIcon(zoomInCell);
>         this.zoomInTrack.setToolTipText("Click this button to zoom in Chart");
>         (this.zoomOutTrack = new JButton("")).setIcon(zoomOutCell);
>         this.zoomOutTrack.setToolTipText("Click this button to zoom out Chart");
>         for (int l = 0; l < ChooserWizardPanel.columnNamesTrack.length; ++l) {
>             this.itemFiltersTrack.add(ChooserWizardPanel.columnNamesTrack[l].toString());
>         }
>         (this.comboFeatureDomainTrack = new JComboBox<String>()).setPreferredSize(new Dimension(110, 20));
>         for (int l = 3; l < this.itemFiltersTrack.size(); ++l) {
>             this.comboFeatureDomainTrack.addItem(this.itemFiltersTrack.get(l));
>         }
>         this.comboFeatureDomainTrack.setOpaque(true);
>         chartPanel2Track.add((Component)this.scatterPlotTrack);
>         (this.filterOrderTrack = new JSpinner(new SpinnerNumberModel(1, 0, 1000, 1))).setPreferredSize(new Dimension(60, 20));
>         this.filterOrderTrack.setEnabled(false);
>         final JPanel filtersMaxTrack = new JPanel(new FlowLayout(1));
>         filtersMaxTrack.add(Box.createHorizontalStrut(2));
>         (this.comboFeatureRangeTrack = new JComboBox<String>()).setPreferredSize(new Dimension(110, 20));
>         for (int m = 3; m < this.itemFiltersTrack.size(); ++m) {
>             this.comboFeatureRangeTrack.addItem(this.itemFiltersTrack.get(m));
>         }
>         this.comboFeatureRangeTrack.setOpaque(true);
>         filtersMaxTrack.add(new JLabel("X :  "));
>         filtersMaxTrack.add(this.comboFeatureDomainTrack);
>         filtersMaxTrack.add(new JLabel("   Y :  "));
>         filtersMaxTrack.add(this.comboFeatureRangeTrack);
>         final JPanel rangePanelFTrack = new JPanel(new FlowLayout(0));
>         final JPanel chartDomainPanelBoxTrack = new JPanel();
>         chartDomainPanelBoxTrack.setLayout(new BoxLayout(chartDomainPanelBoxTrack, 1));
>         chartDomainPanelBoxTrack.add(Box.createVerticalStrut(10));
>         chartDomainPanelBoxTrack.add(chartPanel2Track);
>         chartDomainPanelBoxTrack.add(filtersMaxTrack);
>         rangePanelFTrack.add(chartDomainPanelBoxTrack);
>         final JPanel buttonBoxTrack = new JPanel();
>         buttonBoxTrack.setLayout(new BoxLayout(buttonBoxTrack, 1));
>         final JPanel refreshButtonPanelTrack = new JPanel(new FlowLayout(0));
>         refreshButtonPanelTrack.add(this.refreshButtonTrack);
>         final JPanel zoomOutButtonPanelTrack = new JPanel(new FlowLayout(0));
>         zoomOutButtonPanelTrack.add(this.zoomOutTrack);
>         final JPanel zoomInButtonPanelTrack = new JPanel(new FlowLayout(0));
>         zoomInButtonPanelTrack.add(this.zoomInTrack);
>         buttonBoxTrack.add(zoomInButtonPanelTrack);
>         buttonBoxTrack.add(zoomOutButtonPanelTrack);
>         buttonBoxTrack.add(refreshButtonPanelTrack);
>         (this.comboRegressionTrack = new JComboBox<String>()).setPreferredSize(new Dimension(90, 20));
>         this.comboRegressionTrack.addItem("Linear");
>         this.comboRegressionTrack.addItem("Polynomial");
>         this.comboRegressionTrack.addItem("Power");
>         this.comboRegressionTrack.addItem("Logarithmic");
>         this.comboRegressionTrack.addItem("Exponential");
>         this.comboRegressionTrack.setSelectedIndex(0);
>         this.comboRegressionTrack.setOpaque(true);
>         final JPanel regreOrderPanelTrack = new JPanel(new FlowLayout(0));
>         regreOrderPanelTrack.add(this.comboRegressionTrack);
>         final JPanel filterOrderPanelTrack = new JPanel(new FlowLayout(0));
>         filterOrderPanelTrack.add(this.filterOrderTrack);
>         buttonBoxTrack.add(regreOrderPanelTrack);
>         buttonBoxTrack.add(filterOrderPanelTrack);
>         (OptionWizardPanel.regressionPanelTrack = new JPanel()).setBorder(BorderFactory.createTitledBorder("Reg.Params"));
>         OptionWizardPanel.regressionPanelTrack.setPreferredSize(new Dimension(this.comboRegressionTrack.getWidth() + 10, 35));
>         rangePanelFTrack.add(buttonBoxTrack);
>         final JPanel trackPanel = new JPanel();
>         trackPanel.add(rangePanelFTrack);
>         trackPanel.setBorder(BorderFactory.createTitledBorder(""));
>         final JPanel trackStatistics = new JPanel();
>         trackStatistics.setLayout(new BoxLayout(trackStatistics, 1));
>         final JPanel trackStatisticsFlow = new JPanel(new FlowLayout(0));
>         final JPanel classParamTrack = new JPanel(new FlowLayout(0));
>         (this.comboClassTrack = new JComboBox<String>()).setPreferredSize(new Dimension(120, 20));
>         for (int i2 = 3; i2 < ChooserWizardPanel.columnNamesTrack.length; ++i2) {
>             this.comboClassTrack.addItem((String)ChooserWizardPanel.columnNamesTrack[i2]);
>         }
>         this.comboClassTrack.setOpaque(true);
>         this.comboClassTrack.setToolTipText("Choose selected items for descriptive statistics.");
>         (this.comboParamTrack = new JComboBox<String>()).setPreferredSize(new Dimension(120, 20));
>         for (int i2 = 3; i2 < ChooserWizardPanel.columnNamesTrack.length; ++i2) {
>             this.comboParamTrack.addItem((String)ChooserWizardPanel.columnNamesTrack[i2]);
>         }
>         this.comboParamTrack.setOpaque(true);
>         this.comboParamTrack.setToolTipText("Choose a track parameter for descriptive statistics.");
>         classParamTrack.add(this.comboClassTrack);
>         classParamTrack.add(this.comboParamTrack);
>         (OptionWizardPanel.labelScoresTrack = new JLabel("SCORES")).setFont(new Font("Verdana", 1, 20));
>         trackStatisticsFlow.add(OptionWizardPanel.labelScoresTrack);
>         trackStatistics.add(Box.createVerticalStrut(60));
>         trackStatistics.add(trackStatisticsFlow);
>         trackStatistics.add(new JSeparator(0));
>         trackStatistics.add(Box.createVerticalStrut(20));
>         trackStatistics.add(classParamTrack);
>         trackStatistics.add(Box.createVerticalStrut(20));
>         trackStatistics.add(new JSeparator(0));
>         final String[][] dataTrack = { { "", "", "", "", "", "", "", "", "", "", "" } };
>         final String[] columnTrack = { "Mean ", "Std.Error ", "Median ", "Std.Dev ", "Variance ", "Kurtosis ", "Skewness ", "Min ", "Max ", "Sum ", "Count " };
>         final JTable tableTrack = new JTable();
>         this.modelTrack = new DefaultTableModel(dataTrack, columnTrack) {
>             @Override
>             public Class<?> getColumnClass(final int columnTrack) {
>                 if (this.getRowCount() > 0) {
>                     final Object value = this.getValueAt(0, columnTrack);
>                     if (value != null) {
>                         return this.getValueAt(0, columnTrack).getClass();
>                     }
>                 }
>                 return super.getColumnClass(columnTrack);
503,511c413,416
< 
<          }
<       });
<       csvButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             List<String> columnSpotHead = new ArrayList();
< 
<             for(int j = 0; j < OptionWizardPanel.this.modelSpot.getColumnCount(); ++j) {
<                columnSpotHead.add(OptionWizardPanel.this.modelSpot.getColumnName(j));
---
>             
>             @Override
>             public boolean isCellEditable(final int row, final int col) {
>                 return false;
513,516c418,471
< 
<             ResultsTable rt = new ResultsTable(OptionWizardPanel.this.modelSpot.getRowCount());
<             if (rt != null) {
<                rt.reset();
---
>         };
>         tableTrack.setAutoResizeMode(0);
>         tableTrack.setModel(this.modelTrack);
>         tableTrack.setRowHeight(60);
>         final JScrollPane spTrack = new JScrollPane(tableTrack);
>         spTrack.setPreferredSize(new Dimension(500, 100));
>         spTrack.setVerticalScrollBarPolicy(22);
>         spTrack.setHorizontalScrollBarPolicy(32);
>         for (int u2 = 0; u2 < tableTrack.getColumnCount(); ++u2) {
>             tableTrack.getColumnModel().getColumn(u2).setMinWidth(100);
>             tableTrack.getColumnModel().getColumn(u2).setMaxWidth(100);
>             tableTrack.getColumnModel().getColumn(u2).setPreferredWidth(100);
>         }
>         trackStatistics.add(Box.createVerticalStrut(20));
>         trackStatistics.add(spTrack);
>         trackStatistics.add(Box.createVerticalStrut(20));
>         trackStatistics.add(new JSeparator(0));
>         final JButton plotButtonTrack = new JButton();
>         plotButtonTrack.setIcon(plotCell);
>         plotButtonTrack.setToolTipText("Click to export scatter plot.");
>         final JPanel panelPlotTrack = new JPanel(new FlowLayout(0));
>         panelPlotTrack.add(plotButtonTrack);
>         final JButton csvButtonTrack = new JButton();
>         csvButtonTrack.setIcon(csvCell);
>         csvButtonTrack.setToolTipText("Click to export your tracks statistics table.");
>         final JPanel panelCsvTrack = new JPanel(new FlowLayout(0));
>         panelCsvTrack.add(csvButtonTrack);
>         final JPanel panelPngCsvTrack = new JPanel(new FlowLayout(0));
>         panelPngCsvTrack.add(panelPlotTrack);
>         panelPngCsvTrack.add(panelCsvTrack);
>         trackStatistics.add(panelPngCsvTrack);
>         trackPanel.add(trackStatistics);
>         final JTabbedPane maintabbedPane = new JTabbedPane(1);
>         maintabbedPane.addTab("SPOTS ", FirstWizardPanel.iconSpotCell, spotPanel, "Scatter-Plot for spots");
>         maintabbedPane.addTab("TRACKS ", ChooserWizardPanel.iconTrackCell, trackPanel, "Scatter-Plot for tracks");
>         maintabbedPane.setTabLayoutPolicy(1);
>         this.add((Component)maintabbedPane, (Object)"Center");
>         plotButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 final JFileChooser fileChooser = new JFileChooser();
>                 fileChooser.setFileSelectionMode(1);
>                 fileChooser.setDialogTitle("Specify a directory to save plot as .png file");
>                 final int userSelection = fileChooser.showSaveDialog(new JFrame());
>                 if (userSelection == 0) {
>                     final File fileToSave = fileChooser.getSelectedFile();
>                     final BufferedImage chartImage = STScatterPlot.plot.getChart().createBufferedImage(1024, 768);
>                     try {
>                         ImageIO.write(chartImage, "png", new File(String.valueOf(fileToSave.getAbsolutePath()) + File.separator + "SpotPlot for " + IJ.getImage().getShortTitle() + ".png"));
>                     }
>                     catch (IOException e2) {
>                         e2.printStackTrace();
>                     }
>                 }
518,522c473,503
< 
<             for(int i = 0; i < OptionWizardPanel.this.modelSpot.getRowCount(); ++i) {
<                for(int jx = 0; jx < OptionWizardPanel.this.modelSpot.getColumnCount(); ++jx) {
<                   rt.setValue((String)columnSpotHead.get(jx), i, OptionWizardPanel.this.modelSpot.getValueAt(i, jx).toString());
<                }
---
>         });
>         csvButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 final List<String> columnSpotHead = new ArrayList<String>();
>                 for (int j = 0; j < OptionWizardPanel.this.modelSpot.getColumnCount(); ++j) {
>                     columnSpotHead.add(OptionWizardPanel.this.modelSpot.getColumnName(j));
>                 }
>                 final ResultsTable rt = new ResultsTable(Integer.valueOf(OptionWizardPanel.this.modelSpot.getRowCount()));
>                 if (rt != null) {
>                     rt.reset();
>                 }
>                 for (int i = 0; i < OptionWizardPanel.this.modelSpot.getRowCount(); ++i) {
>                     for (int k = 0; k < OptionWizardPanel.this.modelSpot.getColumnCount(); ++k) {
>                         rt.setValue((String)columnSpotHead.get(k), i, OptionWizardPanel.this.modelSpot.getValueAt(i, k).toString());
>                     }
>                 }
>                 final JFrame pngFrame = new JFrame();
>                 final JFileChooser fileChooser = new JFileChooser();
>                 fileChooser.setFileSelectionMode(1);
>                 fileChooser.setDialogTitle("Specify a directory to save csv file");
>                 final int userSelection = fileChooser.showSaveDialog(pngFrame);
>                 if (userSelection == 0) {
>                     final File fileToSave = fileChooser.getSelectedFile();
>                     try {
>                         rt.saveAs(String.valueOf(fileToSave.getAbsolutePath()) + File.separator + "SpotStatistics for-" + IJ.getImage().getShortTitle() + ".csv");
>                     }
>                     catch (IOException e2) {
>                         e2.printStackTrace();
>                     }
>                 }
524,537c505,514
< 
<             JFrame pngFrame = new JFrame();
<             JFileChooser fileChooser = new JFileChooser();
<             fileChooser.setFileSelectionMode(1);
<             fileChooser.setDialogTitle("Specify a directory to save csv file");
<             int userSelection = fileChooser.showSaveDialog(pngFrame);
<             if (userSelection == 0) {
<                File fileToSave = fileChooser.getSelectedFile();
< 
<                try {
<                   rt.saveAs(fileToSave.getAbsolutePath() + File.separator + "SpotStatistics for-" + IJ.getImage().getShortTitle() + ".csv");
<                } catch (IOException var9) {
<                   var9.printStackTrace();
<                }
---
>         });
>         this.refreshButtonSpot.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (OptionWizardPanel.this.refreshSpotThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         OptionWizardPanel.this.refreshActionSpot();
>                     }
>                 })).start();
539,650c516,583
< 
<          }
<       });
<       this.refreshButtonSpot.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.refreshSpotThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.refreshActionSpot();
<                }
<             });
<             OptionWizardPanel.this.refreshSpotThread.start();
<          }
<       });
<       this.refreshButtonTrack.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.refreshTrackThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.refreshActionTrack();
<                }
<             });
<             OptionWizardPanel.this.refreshTrackThread.start();
<          }
<       });
<       this.zoomInSpot.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.zoomInSpotThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.zoomInSpot.setActionCommand("ZOOM_IN_BOTH");
<                   OptionWizardPanel.this.zoomInSpot.addActionListener(OptionWizardPanel.this.scatterPlotSpot);
<                }
<             });
<             OptionWizardPanel.this.zoomInSpotThread.start();
<          }
<       });
<       this.zoomOutSpot.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.zoomOutSpotThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.zoomOutSpot.setActionCommand("ZOOM_OUT_BOTH");
<                   OptionWizardPanel.this.zoomOutSpot.addActionListener(OptionWizardPanel.this.scatterPlotSpot);
<                }
<             });
<             OptionWizardPanel.this.zoomOutSpotThread.start();
<          }
<       });
<       this.zoomInTrack.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.zoomInTrackThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.zoomInSpot.setActionCommand("ZOOM_IN_BOTH");
<                   OptionWizardPanel.this.zoomInSpot.addActionListener(OptionWizardPanel.this.scatterPlotTrack);
<                }
<             });
<             OptionWizardPanel.this.zoomInTrackThread.start();
<          }
<       });
<       this.zoomOutTrack.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.zoomOutTrackThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.zoomOutTrack.setActionCommand("ZOOM_OUT_BOTH");
<                   OptionWizardPanel.this.zoomOutTrack.addActionListener(OptionWizardPanel.this.scatterPlotTrack);
<                }
<             });
<             OptionWizardPanel.this.zoomOutTrackThread.start();
<          }
<       });
<       this.comboRegressionSpot.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.comboRegSpotThread = new Thread(new Runnable() {
<                public void run() {
<                   if (OptionWizardPanel.this.comboRegressionSpot.getSelectedIndex() == 1) {
<                      OptionWizardPanel.this.filterOrderSpot.setEnabled(true);
<                   }
< 
<                   if (OptionWizardPanel.this.comboRegressionSpot.getSelectedIndex() != 1) {
<                      OptionWizardPanel.this.filterOrderSpot.setEnabled(false);
<                   }
< 
<                }
<             });
<             OptionWizardPanel.this.comboRegSpotThread.start();
<          }
<       });
<       this.comboRegressionTrack.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.comboRegTrackThread = new Thread(new Runnable() {
<                public void run() {
<                   if (OptionWizardPanel.this.comboRegressionTrack.getSelectedIndex() == 1) {
<                      OptionWizardPanel.this.filterOrderTrack.setEnabled(true);
<                   }
< 
<                   if (OptionWizardPanel.this.comboRegressionTrack.getSelectedIndex() != 1) {
<                      OptionWizardPanel.this.filterOrderTrack.setEnabled(false);
<                   }
< 
<                }
<             });
<             OptionWizardPanel.this.comboRegTrackThread.start();
<          }
<       });
<       this.comboClassSpot.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.comboClassSpotThread = new Thread(new Runnable() {
<                public void run() {
<                   int i;
<                   if (OptionWizardPanel.this.comboClassSpot.getSelectedIndex() == 0) {
<                      OptionWizardPanel.this.dataToStatisticsSpot = new ArrayList();
< 
<                      for(i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<                         if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE) {
<                            OptionWizardPanel.this.dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot.getValueAt(i, OptionWizardPanel.this.comboParamSpot.getSelectedIndex() + 3).toString()));
---
>         });
>         this.refreshButtonTrack.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (OptionWizardPanel.this.refreshTrackThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         OptionWizardPanel.this.refreshActionTrack();
>                     }
>                 })).start();
>             }
>         });
>         this.zoomInSpot.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (OptionWizardPanel.this.zoomInSpotThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         OptionWizardPanel.this.zoomInSpot.setActionCommand("ZOOM_IN_BOTH");
>                         OptionWizardPanel.this.zoomInSpot.addActionListener((ActionListener)OptionWizardPanel.this.scatterPlotSpot);
>                     }
>                 })).start();
>             }
>         });
>         this.zoomOutSpot.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (OptionWizardPanel.this.zoomOutSpotThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         OptionWizardPanel.this.zoomOutSpot.setActionCommand("ZOOM_OUT_BOTH");
>                         OptionWizardPanel.this.zoomOutSpot.addActionListener((ActionListener)OptionWizardPanel.this.scatterPlotSpot);
>                     }
>                 })).start();
>             }
>         });
>         this.zoomInTrack.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (OptionWizardPanel.this.zoomInTrackThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         OptionWizardPanel.this.zoomInSpot.setActionCommand("ZOOM_IN_BOTH");
>                         OptionWizardPanel.this.zoomInSpot.addActionListener((ActionListener)OptionWizardPanel.this.scatterPlotTrack);
>                     }
>                 })).start();
>             }
>         });
>         this.zoomOutTrack.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (OptionWizardPanel.this.zoomOutTrackThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         OptionWizardPanel.this.zoomOutTrack.setActionCommand("ZOOM_OUT_BOTH");
>                         OptionWizardPanel.this.zoomOutTrack.addActionListener((ActionListener)OptionWizardPanel.this.scatterPlotTrack);
>                     }
>                 })).start();
>             }
>         });
>         this.comboRegressionSpot.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (OptionWizardPanel.this.comboRegSpotThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (OptionWizardPanel.this.comboRegressionSpot.getSelectedIndex() == 1) {
>                             OptionWizardPanel.this.filterOrderSpot.setEnabled(true);
652,662c585,586
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionSpot();
<                   }
< 
<                   if (OptionWizardPanel.this.comboClassSpot.getSelectedIndex() == 1) {
<                      OptionWizardPanel.this.dataToStatisticsSpot = new ArrayList();
< 
<                      for(i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<                         if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, 0)).getText() == "") {
<                            OptionWizardPanel.this.dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot.getValueAt(i, OptionWizardPanel.this.comboParamSpot.getSelectedIndex() + 3).toString()));
---
>                         if (OptionWizardPanel.this.comboRegressionSpot.getSelectedIndex() != 1) {
>                             OptionWizardPanel.this.filterOrderSpot.setEnabled(false);
664,674c588,599
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionSpot();
<                   }
< 
<                   if (OptionWizardPanel.this.comboClassSpot.getSelectedIndex() == 2) {
<                      OptionWizardPanel.this.dataToStatisticsSpot = new ArrayList();
< 
<                      for(i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<                         if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, 0)).getText() == OptionWizardPanel.this.comboClassSpot.getSelectedItem().toString()) {
<                            OptionWizardPanel.this.dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot.getValueAt(i, OptionWizardPanel.this.comboParamSpot.getSelectedIndex() + 3).toString()));
---
>                     }
>                 })).start();
>             }
>         });
>         this.comboRegressionTrack.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (OptionWizardPanel.this.comboRegTrackThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (OptionWizardPanel.this.comboRegressionTrack.getSelectedIndex() == 1) {
>                             OptionWizardPanel.this.filterOrderTrack.setEnabled(true);
676,696c601,602
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionSpot();
<                   }
< 
<                }
<             });
<             OptionWizardPanel.this.comboClassSpotThread.start();
<          }
<       });
<       this.comboClassTrack.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.comboClassTrackThread = new Thread(new Runnable() {
<                public void run() {
<                   int i;
<                   if (OptionWizardPanel.this.comboClassTrack.getSelectedIndex() == 0) {
<                      OptionWizardPanel.this.dataToStatisticsTrack = new ArrayList();
< 
<                      for(i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<                         if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE) {
<                            OptionWizardPanel.this.dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack.getValueAt(i, OptionWizardPanel.this.comboParamTrack.getSelectedIndex() + 3).toString()));
---
>                         if (OptionWizardPanel.this.comboRegressionTrack.getSelectedIndex() != 1) {
>                             OptionWizardPanel.this.filterOrderTrack.setEnabled(false);
698,708c604,621
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionTrack();
<                   }
< 
<                   if (OptionWizardPanel.this.comboClassTrack.getSelectedIndex() == 1) {
<                      OptionWizardPanel.this.dataToStatisticsTrack = new ArrayList();
< 
<                      for(i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<                         if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, 0)).getText() == "") {
<                            OptionWizardPanel.this.dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack.getValueAt(i, OptionWizardPanel.this.comboParamTrack.getSelectedIndex() + 3).toString()));
---
>                     }
>                 })).start();
>             }
>         });
>         this.comboClassSpot.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (OptionWizardPanel.this.comboClassSpotThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (OptionWizardPanel.this.comboClassSpot.getSelectedIndex() == 0) {
>                             OptionWizardPanel.this.dataToStatisticsSpot = new ArrayList<Double>();
>                             for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
>                                 if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE) {
>                                     OptionWizardPanel.this.dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot.getValueAt(i, OptionWizardPanel.this.comboParamSpot.getSelectedIndex() + 3).toString()));
>                                 }
>                             }
>                             OptionWizardPanel.this.descriptiveStatisticsActionSpot();
710,720c623,630
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionTrack();
<                   }
< 
<                   if (OptionWizardPanel.this.comboClassTrack.getSelectedIndex() == 2) {
<                      OptionWizardPanel.this.dataToStatisticsTrack = new ArrayList();
< 
<                      for(i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<                         if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, 0)).getText() == OptionWizardPanel.this.comboClassTrack.getSelectedItem().toString()) {
<                            OptionWizardPanel.this.dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack.getValueAt(i, OptionWizardPanel.this.comboParamTrack.getSelectedIndex() + 3).toString()));
---
>                         if (OptionWizardPanel.this.comboClassSpot.getSelectedIndex() == 1) {
>                             OptionWizardPanel.this.dataToStatisticsSpot = new ArrayList<Double>();
>                             for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
>                                 if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, 0)).getText() == "") {
>                                     OptionWizardPanel.this.dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot.getValueAt(i, OptionWizardPanel.this.comboParamSpot.getSelectedIndex() + 3).toString()));
>                                 }
>                             }
>                             OptionWizardPanel.this.descriptiveStatisticsActionSpot();
722,908c632,834
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionTrack();
<                   }
< 
<                }
<             });
<             OptionWizardPanel.this.comboClassTrackThread.start();
<          }
<       });
<    }
< 
<    public void descriptiveStatisticsActionSpot() {
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getMean() * 1000.0D) / 1000.0D), 0, 0);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getStandardDeviation() / (double)(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getN() * 1000.0D) / 1000.0D), 0, 1);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getPercentile(50.0D) * 1000.0D) / 1000.0D), 0, 2);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getStandardDeviation() * 1000.0D) / 1000.0D), 0, 3);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getVariance() * 1000.0D) / 1000.0D), 0, 4);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getKurtosis() * 1000.0D) / 1000.0D), 0, 5);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getSkewness() * 1000.0D) / 1000.0D), 0, 6);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getMin() * 1000.0D) / 1000.0D), 0, 7);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getMax() * 1000.0D) / 1000.0D), 0, 8);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getSum() * 1000.0D) / 1000.0D), 0, 9);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((double)(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getN() * 1000.0D) / 1000.0D), 0, 10);
<    }
< 
<    public void descriptiveStatisticsActionTrack() {
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getMean() * 1000.0D) / 1000.0D), 0, 0);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getStandardDeviation() / (double)(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getN() * 1000.0D) / 1000.0D), 0, 1);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getPercentile(50.0D) * 1000.0D) / 1000.0D), 0, 2);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getStandardDeviation() * 1000.0D) / 1000.0D), 0, 3);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getVariance() * 1000.0D) / 1000.0D), 0, 4);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getKurtosis() * 1000.0D) / 1000.0D), 0, 5);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getSkewness() * 1000.0D) / 1000.0D), 0, 6);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getMin() * 1000.0D) / 1000.0D), 0, 7);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getMax() * 1000.0D) / 1000.0D), 0, 8);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getSum() * 1000.0D) / 1000.0D), 0, 9);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((double)(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getN() * 1000.0D) / 1000.0D), 0, 10);
<    }
< 
<    public void refreshActionSpot() {
<       this.comboClassSpot.removeAllItems();
<       this.comboClassSpot.addItem("All items");
<       this.comboClassSpot.addItem("No Identified");
<       int rowCount;
<       if (ColorEditorSpot.modelC.getRowCount() > 0) {
<          for(rowCount = 0; rowCount < ColorEditorSpot.modelC.getRowCount(); ++rowCount) {
<             this.comboClassSpot.addItem(((JLabel)ColorEditorSpot.modelC.getValueAt(rowCount, 0)).getText());
<          }
<       }
< 
<       rowCount = FirstWizardPanel.tableSpot.getRowCount();
<       int columnCount = FirstWizardPanel.tableSpot.getColumnCount();
<       selectedIndexDomainSpot = this.comboFeatureDomainSpot.getSelectedIndex();
<       selectedIndexRangeSpot = this.comboFeatureRangeSpot.getSelectedIndex();
<       List<Double> valuesDomainSpot = new ArrayList();
<       List<Double> valuesRangeSpot = new ArrayList();
<       Object[][] dataSpot = new Object[rowCount][columnCount];
< 
<       int i;
<       for(int i = 0; i < rowCount; ++i) {
<          for(i = 0; i < columnCount; ++i) {
<             dataSpot[i][i] = FirstWizardPanel.tableSpot.getValueAt(i, i);
<          }
< 
<          valuesDomainSpot.add(Double.parseDouble(dataSpot[i][selectedIndexDomainSpot + 4].toString()));
<          valuesRangeSpot.add(Double.parseDouble(dataSpot[i][selectedIndexRangeSpot + 4].toString()));
<       }
< 
<       if (valuesDomainSpot.isEmpty() == Boolean.TRUE) {
<          IJ.error("You should have your spot analysis done. Please go backwards.");
<       } else {
<          this.maxDomainSpot = (Double)Collections.max(valuesDomainSpot);
<          this.maxRangeSpot = (Double)Collections.max(valuesRangeSpot);
<          List<Color> listColorSpot = new ArrayList();
< 
<          for(i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<             listColorSpot.add(((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1))).getBackground());
<          }
< 
<          Color[] classColorSpot = new Color[listColorSpot.size()];
<          listColorSpot.toArray(classColorSpot);
<          if (this.comboRegressionSpot.getSelectedIndex() == 0) {
<             this.sp2Spot.addScatterPlotSeriesLinear(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
<          }
< 
<          if (this.comboRegressionSpot.getSelectedIndex() == 1) {
<             this.sp2Spot.addScatterPlotSeriesPolynomial(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot, (Integer)this.filterOrderSpot.getValue());
<          }
< 
<          if (this.comboRegressionSpot.getSelectedIndex() == 2) {
<             this.sp2Spot.addScatterPlotSeriesPower(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
<          }
< 
<          if (this.comboRegressionSpot.getSelectedIndex() == 3) {
<             this.sp2Spot.addScatterPlotSeriesLogarithmic(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
<          }
< 
<          if (this.comboRegressionSpot.getSelectedIndex() == 4) {
<             this.sp2Spot.addScatterPlotSeriesExponential(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
<          }
<       }
< 
<    }
< 
<    public void refreshActionTrack() {
<       this.comboClassTrack.removeAllItems();
<       this.comboClassTrack.addItem("All items");
<       this.comboClassTrack.addItem("No Identified");
<       int rowCount;
<       if (ColorEditorTrack.modelC.getRowCount() > 0) {
<          for(rowCount = 0; rowCount < ColorEditorTrack.modelC.getRowCount(); ++rowCount) {
<             this.comboClassTrack.addItem(((JLabel)ColorEditorTrack.modelC.getValueAt(rowCount, 0)).getText());
<          }
<       }
< 
<       rowCount = ChooserWizardPanel.tableTrack.getRowCount();
<       int columnCount = ChooserWizardPanel.tableTrack.getColumnCount();
<       selectedIndexDomainTrack = this.comboFeatureDomainTrack.getSelectedIndex();
<       selectedIndexRangeTrack = this.comboFeatureRangeTrack.getSelectedIndex();
<       List<Double> valuesDomainTrack = new ArrayList();
<       List<Double> valuesRangeTrack = new ArrayList();
<       Object[][] dataTrack = new Object[rowCount][columnCount];
< 
<       int i;
<       for(int i = 0; i < rowCount; ++i) {
<          for(i = 0; i < columnCount; ++i) {
<             dataTrack[i][i] = ChooserWizardPanel.tableTrack.getValueAt(i, i);
<          }
< 
<          valuesDomainTrack.add(Double.parseDouble(dataTrack[i][selectedIndexDomainTrack + 4].toString()));
<          valuesRangeTrack.add(Double.parseDouble(dataTrack[i][selectedIndexRangeTrack + 4].toString()));
<       }
< 
<       if (valuesDomainTrack.isEmpty() == Boolean.TRUE) {
<          IJ.error("You should have your track analysis done. Please go backwards.");
<       } else {
<          this.maxDomainTrack = (Double)Collections.max(valuesDomainTrack);
<          this.maxRangeTrack = (Double)Collections.max(valuesRangeTrack);
<          List<Color> listColorTrack = new ArrayList();
< 
<          for(i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<             listColorTrack.add(((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1))).getBackground());
<          }
< 
<          Color[] classColorTrack = new Color[listColorTrack.size()];
<          listColorTrack.toArray(classColorTrack);
<          if (this.comboRegressionTrack.getSelectedIndex() == 0) {
<             this.sp2Track.addScatterPlotSeriesLinear(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
<          }
< 
<          if (this.comboRegressionTrack.getSelectedIndex() == 1) {
<             this.sp2Track.addScatterPlotSeriesPolynomial(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack, (Integer)this.filterOrderTrack.getValue());
<          }
< 
<          if (this.comboRegressionTrack.getSelectedIndex() == 2) {
<             this.sp2Track.addScatterPlotSeriesPower(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
<          }
< 
<          if (this.comboRegressionTrack.getSelectedIndex() == 3) {
<             this.sp2Track.addScatterPlotSeriesLogarithmic(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
<          }
< 
<          if (this.comboRegressionTrack.getSelectedIndex() == 4) {
<             this.sp2Track.addScatterPlotSeriesExponential(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
<          }
<       }
< 
<    }
< 
<    public void update1() {
<       this.setNextButtonEnabled(true);
<       this.setFinishButtonEnabled(true);
<       this.setBackButtonEnabled(true);
<    }
< 
<    public void next() {
<       this.setNextButtonEnabled(false);
<    }
< 
<    public void back() {
<       this.switchPanel(1);
<    }
< 
<    public void finish() {
<       this.switchPanel(2);
<    }
---
>                         if (OptionWizardPanel.this.comboClassSpot.getSelectedIndex() == 2) {
>                             OptionWizardPanel.this.dataToStatisticsSpot = new ArrayList<Double>();
>                             for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
>                                 if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, 0)).getText() == OptionWizardPanel.this.comboClassSpot.getSelectedItem().toString()) {
>                                     OptionWizardPanel.this.dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot.getValueAt(i, OptionWizardPanel.this.comboParamSpot.getSelectedIndex() + 3).toString()));
>                                 }
>                             }
>                             OptionWizardPanel.this.descriptiveStatisticsActionSpot();
>                         }
>                     }
>                 })).start();
>             }
>         });
>         this.comboClassTrack.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 (OptionWizardPanel.this.comboClassTrackThread = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         if (OptionWizardPanel.this.comboClassTrack.getSelectedIndex() == 0) {
>                             OptionWizardPanel.this.dataToStatisticsTrack = new ArrayList<Double>();
>                             for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
>                                 if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE) {
>                                     OptionWizardPanel.this.dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack.getValueAt(i, OptionWizardPanel.this.comboParamTrack.getSelectedIndex() + 3).toString()));
>                                 }
>                             }
>                             OptionWizardPanel.this.descriptiveStatisticsActionTrack();
>                         }
>                         if (OptionWizardPanel.this.comboClassTrack.getSelectedIndex() == 1) {
>                             OptionWizardPanel.this.dataToStatisticsTrack = new ArrayList<Double>();
>                             for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
>                                 if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, 0)).getText() == "") {
>                                     OptionWizardPanel.this.dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack.getValueAt(i, OptionWizardPanel.this.comboParamTrack.getSelectedIndex() + 3).toString()));
>                                 }
>                             }
>                             OptionWizardPanel.this.descriptiveStatisticsActionTrack();
>                         }
>                         if (OptionWizardPanel.this.comboClassTrack.getSelectedIndex() == 2) {
>                             OptionWizardPanel.this.dataToStatisticsTrack = new ArrayList<Double>();
>                             for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
>                                 if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, 0)).getText() == OptionWizardPanel.this.comboClassTrack.getSelectedItem().toString()) {
>                                     OptionWizardPanel.this.dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack.getValueAt(i, OptionWizardPanel.this.comboParamTrack.getSelectedIndex() + 3).toString()));
>                                 }
>                             }
>                             OptionWizardPanel.this.descriptiveStatisticsActionTrack();
>                         }
>                     }
>                 })).start();
>             }
>         });
>     }
>     
>     public void descriptiveStatisticsActionSpot() {
>         this.modelSpot.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getMean() * 1000.0) / 1000.0), 0, 0);
>         this.modelSpot.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getStandardDeviation() / new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getN() * 1000.0) / 1000.0), 0, 1);
>         this.modelSpot.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getPercentile(50.0) * 1000.0) / 1000.0), 0, 2);
>         this.modelSpot.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getStandardDeviation() * 1000.0) / 1000.0), 0, 3);
>         this.modelSpot.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getVariance() * 1000.0) / 1000.0), 0, 4);
>         this.modelSpot.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getKurtosis() * 1000.0) / 1000.0), 0, 5);
>         this.modelSpot.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getSkewness() * 1000.0) / 1000.0), 0, 6);
>         this.modelSpot.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getMin() * 1000.0) / 1000.0), 0, 7);
>         this.modelSpot.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getMax() * 1000.0) / 1000.0), 0, 8);
>         this.modelSpot.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getSum() * 1000.0) / 1000.0), 0, 9);
>         this.modelSpot.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()).getN() * 1000.0) / 1000.0), 0, 10);
>     }
>     
>     public void descriptiveStatisticsActionTrack() {
>         this.modelTrack.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getMean() * 1000.0) / 1000.0), 0, 0);
>         this.modelTrack.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getStandardDeviation() / new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getN() * 1000.0) / 1000.0), 0, 1);
>         this.modelTrack.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getPercentile(50.0) * 1000.0) / 1000.0), 0, 2);
>         this.modelTrack.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getStandardDeviation() * 1000.0) / 1000.0), 0, 3);
>         this.modelTrack.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getVariance() * 1000.0) / 1000.0), 0, 4);
>         this.modelTrack.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getKurtosis() * 1000.0) / 1000.0), 0, 5);
>         this.modelTrack.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getSkewness() * 1000.0) / 1000.0), 0, 6);
>         this.modelTrack.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getMin() * 1000.0) / 1000.0), 0, 7);
>         this.modelTrack.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getMax() * 1000.0) / 1000.0), 0, 8);
>         this.modelTrack.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getSum() * 1000.0) / 1000.0), 0, 9);
>         this.modelTrack.setValueAt(String.valueOf(Math.round(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()).getN() * 1000.0) / 1000.0), 0, 10);
>     }
>     
>     public void refreshActionSpot() {
>         this.comboClassSpot.removeAllItems();
>         this.comboClassSpot.addItem("All items");
>         this.comboClassSpot.addItem("No Identified");
>         if (ColorEditorSpot.modelC.getRowCount() > 0) {
>             for (int i = 0; i < ColorEditorSpot.modelC.getRowCount(); ++i) {
>                 this.comboClassSpot.addItem(((JLabel)ColorEditorSpot.modelC.getValueAt(i, 0)).getText());
>             }
>         }
>         final int rowCount = FirstWizardPanel.tableSpot.getRowCount();
>         final int columnCount = FirstWizardPanel.tableSpot.getColumnCount();
>         OptionWizardPanel.selectedIndexDomainSpot = this.comboFeatureDomainSpot.getSelectedIndex();
>         OptionWizardPanel.selectedIndexRangeSpot = this.comboFeatureRangeSpot.getSelectedIndex();
>         final List<Double> valuesDomainSpot = new ArrayList<Double>();
>         final List<Double> valuesRangeSpot = new ArrayList<Double>();
>         final Object[][] dataSpot = new Object[rowCount][columnCount];
>         for (int j = 0; j < rowCount; ++j) {
>             for (int k = 0; k < columnCount; ++k) {
>                 dataSpot[j][k] = FirstWizardPanel.tableSpot.getValueAt(j, k);
>             }
>             valuesDomainSpot.add(Double.parseDouble(dataSpot[j][OptionWizardPanel.selectedIndexDomainSpot + 4].toString()));
>             valuesRangeSpot.add(Double.parseDouble(dataSpot[j][OptionWizardPanel.selectedIndexRangeSpot + 4].toString()));
>         }
>         if (valuesDomainSpot.isEmpty() == Boolean.TRUE) {
>             IJ.error("You should have your spot analysis done. Please go backwards.");
>         }
>         else {
>             this.maxDomainSpot = Collections.<Double>max((Collection<? extends Double>)valuesDomainSpot);
>             this.maxRangeSpot = Collections.<Double>max((Collection<? extends Double>)valuesRangeSpot);
>             final List<Color> listColorSpot = new ArrayList<Color>();
>             for (int l = 0; l < FirstWizardPanel.modelSpot.getRowCount(); ++l) {
>                 listColorSpot.add(((JLabel)FirstWizardPanel.modelSpot.getValueAt(l, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1))).getBackground());
>             }
>             final Color[] classColorSpot = new Color[listColorSpot.size()];
>             listColorSpot.<Color>toArray(classColorSpot);
>             if (this.comboRegressionSpot.getSelectedIndex() == 0) {
>                 this.sp2Spot.addScatterPlotSeriesLinear(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
>             }
>             if (this.comboRegressionSpot.getSelectedIndex() == 1) {
>                 this.sp2Spot.addScatterPlotSeriesPolynomial(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot, (int)this.filterOrderSpot.getValue());
>             }
>             if (this.comboRegressionSpot.getSelectedIndex() == 2) {
>                 this.sp2Spot.addScatterPlotSeriesPower(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
>             }
>             if (this.comboRegressionSpot.getSelectedIndex() == 3) {
>                 this.sp2Spot.addScatterPlotSeriesLogarithmic(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
>             }
>             if (this.comboRegressionSpot.getSelectedIndex() == 4) {
>                 this.sp2Spot.addScatterPlotSeriesExponential(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
>             }
>         }
>     }
>     
>     public void refreshActionTrack() {
>         this.comboClassTrack.removeAllItems();
>         this.comboClassTrack.addItem("All items");
>         this.comboClassTrack.addItem("No Identified");
>         if (ColorEditorTrack.modelC.getRowCount() > 0) {
>             for (int i = 0; i < ColorEditorTrack.modelC.getRowCount(); ++i) {
>                 this.comboClassTrack.addItem(((JLabel)ColorEditorTrack.modelC.getValueAt(i, 0)).getText());
>             }
>         }
>         final int rowCount = ChooserWizardPanel.tableTrack.getRowCount();
>         final int columnCount = ChooserWizardPanel.tableTrack.getColumnCount();
>         OptionWizardPanel.selectedIndexDomainTrack = this.comboFeatureDomainTrack.getSelectedIndex();
>         OptionWizardPanel.selectedIndexRangeTrack = this.comboFeatureRangeTrack.getSelectedIndex();
>         final List<Double> valuesDomainTrack = new ArrayList<Double>();
>         final List<Double> valuesRangeTrack = new ArrayList<Double>();
>         final Object[][] dataTrack = new Object[rowCount][columnCount];
>         for (int j = 0; j < rowCount; ++j) {
>             for (int k = 0; k < columnCount; ++k) {
>                 dataTrack[j][k] = ChooserWizardPanel.tableTrack.getValueAt(j, k);
>             }
>             valuesDomainTrack.add(Double.parseDouble(dataTrack[j][OptionWizardPanel.selectedIndexDomainTrack + 4].toString()));
>             valuesRangeTrack.add(Double.parseDouble(dataTrack[j][OptionWizardPanel.selectedIndexRangeTrack + 4].toString()));
>         }
>         if (valuesDomainTrack.isEmpty() == Boolean.TRUE) {
>             IJ.error("You should have your track analysis done. Please go backwards.");
>         }
>         else {
>             this.maxDomainTrack = Collections.<Double>max((Collection<? extends Double>)valuesDomainTrack);
>             this.maxRangeTrack = Collections.<Double>max((Collection<? extends Double>)valuesRangeTrack);
>             final List<Color> listColorTrack = new ArrayList<Color>();
>             for (int l = 0; l < ChooserWizardPanel.modelTrack.getRowCount(); ++l) {
>                 listColorTrack.add(((JLabel)ChooserWizardPanel.modelTrack.getValueAt(l, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1))).getBackground());
>             }
>             final Color[] classColorTrack = new Color[listColorTrack.size()];
>             listColorTrack.<Color>toArray(classColorTrack);
>             if (this.comboRegressionTrack.getSelectedIndex() == 0) {
>                 this.sp2Track.addScatterPlotSeriesLinear(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
>             }
>             if (this.comboRegressionTrack.getSelectedIndex() == 1) {
>                 this.sp2Track.addScatterPlotSeriesPolynomial(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack, (int)this.filterOrderTrack.getValue());
>             }
>             if (this.comboRegressionTrack.getSelectedIndex() == 2) {
>                 this.sp2Track.addScatterPlotSeriesPower(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
>             }
>             if (this.comboRegressionTrack.getSelectedIndex() == 3) {
>                 this.sp2Track.addScatterPlotSeriesLogarithmic(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
>             }
>             if (this.comboRegressionTrack.getSelectedIndex() == 4) {
>                 this.sp2Track.addScatterPlotSeriesExponential(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
>             }
>         }
>     }
>     
>     public void update1() {
>         this.setNextButtonEnabled(true);
>         this.setFinishButtonEnabled(true);
>         this.setBackButtonEnabled(true);
>     }
>     
>     public void next() {
>         this.setNextButtonEnabled(false);
>     }
>     
>     public void back() {
>         this.switchPanel(1);
>     }
>     
>     public void finish() {
>         this.switchPanel(2);
>     }
diff -r TrackAnalyzer_/PhotobleachingSpotPlot.java procyon/PhotobleachingSpotPlot.java
1,8d0
< import fiji.plugin.trackmate.gui.displaysettings.Colormap;
< import fiji.plugin.trackmate.visualization.PerTrackFeatureColorGenerator;
< import ij.ImagePlus;
< import ij.gui.OvalRoi;
< import ij.measure.ResultsTable;
< import java.awt.Color;
< import java.awt.Point;
< import java.awt.event.KeyEvent;
10,14c2,5
< import java.awt.geom.Rectangle2D;
< import java.awt.geom.Rectangle2D.Float;
< import java.io.File;
< import java.io.IOException;
< import java.util.ArrayList;
---
> import java.awt.event.KeyEvent;
> import java.awt.Point;
> import org.jfree.chart.renderer.xy.XYItemRenderer;
> import ij.ImagePlus;
17,20c8
< import javax.swing.JLabel;
< import javax.swing.JPanel;
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartPanel;
---
> import java.io.IOException;
22,23c10,14
< import org.jfree.chart.JFreeChart;
< import org.jfree.chart.plot.PlotOrientation;
---
> import java.io.File;
> import java.awt.Paint;
> import java.awt.Color;
> import fiji.plugin.trackmate.visualization.PerTrackFeatureColorGenerator;
> import fiji.plugin.trackmate.gui.displaysettings.Colormap;
25c16,20
< import org.jfree.chart.renderer.xy.XYItemRenderer;
---
> import org.jfree.data.xy.XYDataset;
> import org.jfree.chart.ChartFactory;
> import org.jfree.chart.plot.PlotOrientation;
> import ij.gui.Roi;
> import ij.gui.OvalRoi;
27a23,30
> import java.util.ArrayList;
> import java.awt.Component;
> import org.jfree.chart.ChartPanel;
> import javax.swing.JLabel;
> import java.awt.geom.Rectangle2D;
> import ij.measure.ResultsTable;
> import javax.swing.JPanel;
> import org.jfree.chart.JFreeChart;
29,147c32,146
< public class PhotobleachingSpotPlot {
<    JFreeChart chart;
<    JPanel chartpanel = new JPanel();
<    ResultsTable rt;
<    Rectangle2D chartRectangleInSequence = new Float(250.0F, 20.0F, 490.0F, 240.0F);
<    JLabel outLabel = new JLabel();
< 
<    public PhotobleachingSpotPlot() {
<       this.chartpanel.add(new ChartPanel(this.chart, 500, 300, 500, 300, 500, 300, false, false, true, true, true, true));
<    }
< 
<    public void Compute() {
<       Set<Integer> trackIDs = SPTBatch_.model.getTrackModel().trackIDs(true);
<       List<Integer> nOfTracks = new ArrayList();
<       if (SPTBatch_.checkboxSubBg.isSelected()) {
<          int r;
<          for(r = 0; r < SPTBatch_.trackJTable.getRowCount(); ++r) {
<             nOfTracks.add(Integer.valueOf(SPTBatch_.trackJTable.getValueAt(r, 2).toString()));
<          }
< 
<          for(r = 0; r < nOfTracks.size(); ++r) {
<             XYSeriesCollection xyDataset = new XYSeriesCollection();
<             XYSeries seriesTrack = null;
<             XYSeries seriesBg = null;
<             List<Double> perTrack = new ArrayList();
<             List<Double> perFrame = new ArrayList();
<             List<Double> perTrackDef = new ArrayList();
<             List<Double> perXPositionDef = new ArrayList();
<             List<Double> perYPositionDef = new ArrayList();
<             List<Double> perFrameDef = new ArrayList();
< 
<             int i;
<             for(i = 0; i < SPTBatch_.tableSpot.getRowCount(); ++i) {
<                if (Integer.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 2).toString()).equals(nOfTracks.get(r)) == Boolean.TRUE) {
<                   perTrack.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 12).toString()));
<                   perFrame.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 8).toString()));
<                   perTrackDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 12).toString()));
<                   perFrameDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 8).toString()));
<                   perXPositionDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 4).toString()));
<                   perYPositionDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 5).toString()));
<                }
<             }
< 
<             this.rt = new ResultsTable();
<             seriesTrack = new XYSeries("Spot Mean Raw Intensity Track ");
<             seriesBg = new XYSeries("Bg Intensity");
< 
<             for(i = 0; i < perTrackDef.size(); ++i) {
<                seriesTrack.add((Number)perFrameDef.get(i), (Number)perTrackDef.get(i));
<                this.rt.setValue("Spot Mean Raw Intensity Track ", i, (Double)perTrackDef.get(i));
<             }
< 
<             for(i = 0; i < SPTBatch_.imps.getStack().getSize(); ++i) {
<                seriesBg.add((double)i, SPTBatch_.slicesIntensitySpot[i]);
<                this.rt.setValue("Bg Intensity", i, Double.valueOf(SPTBatch_.slicesIntensitySpot[i]));
<             }
< 
<             if (((Double)perFrameDef.get(perFrameDef.size() - 1)).intValue() != SPTBatch_.imps.getStack().getSize() - 1) {
<                ImagePlus[] slices = SPTBatch_.stack2images(SPTBatch_.imps.duplicate());
<                OvalRoi ovalRoi = new OvalRoi((Double)perXPositionDef.get(perXPositionDef.size() - 1), (Double)perXPositionDef.get(perXPositionDef.size() - 1), Double.valueOf(SPTBatch_.RADIUS) / SPTBatch_.imps.getCalibration().pixelWidth, Double.valueOf(SPTBatch_.RADIUS) / SPTBatch_.imps.getCalibration().pixelWidth);
< 
<                for(int i = ((Double)perFrameDef.get(perFrameDef.size() - 1)).intValue(); i < SPTBatch_.imps.getStack().getSize(); ++i) {
<                   slices[i].setRoi(ovalRoi);
<                   seriesTrack.add((double)i, slices[i].getStatistics().mean);
<                   this.rt.setValue("Spot Mean Raw Intensity Track ", i, slices[i].getStatistics().mean);
<                }
<             }
< 
<             xyDataset.addSeries(seriesTrack);
<             xyDataset.addSeries(seriesBg);
<             this.chart = ChartFactory.createXYLineChart("PhotoBleaching step for Track " + nOfTracks.get(r), "Frame", "Intensity", xyDataset, PlotOrientation.VERTICAL, true, true, false);
<             this.chartpanel.removeAll();
<             if (this.chart != null) {
<                XYItemRenderer renderer = ((XYPlot)this.chart.getPlot()).getRenderer();
<                PerTrackFeatureColorGenerator tcg = new PerTrackFeatureColorGenerator(SPTBatch_.model, "TRACK_INDEX", (Color)null, (Color)null, Colormap.Turbo, 0.0D, 1.0D);
<                XYPlot plot = this.chart.getXYPlot();
<                plot.setDataset(0, xyDataset);
<                plot.setRenderer(0, renderer);
<                plot.getRendererForDataset(plot.getDataset(0)).setSeriesPaint(0, tcg.colorOf((Integer)nOfTracks.get(r)));
<             }
< 
<             XYPlot plot = (XYPlot)this.chart.getPlot();
<             plot.setBackgroundPaint(Color.white);
<             plot.setDomainGridlinesVisible(true);
<             plot.setRangeGridlinesVisible(true);
<             plot.setDomainMinorGridlinePaint(Color.GRAY);
<             plot.setDomainGridlinePaint(Color.DARK_GRAY);
<             plot.setRangeMinorGridlinePaint(Color.GRAY);
<             plot.setRangeGridlinePaint(Color.DARK_GRAY);
<             this.chartpanel.add(new ChartPanel(this.chart));
<             this.chartpanel.updateUI();
< 
<             try {
<                ChartUtils.saveChartAsPNG(new File(SPTBatch_.directPBS.getAbsolutePath() + File.separator + SPTBatch_.imgTitle + "_" + ((Integer)nOfTracks.get(r)).toString() + ".png"), this.chart, 2000, 400);
<             } catch (IOException var17) {
<                var17.printStackTrace();
<             }
< 
<             try {
<                this.rt.saveAs(SPTBatch_.directPBS.getAbsolutePath() + File.separator + SPTBatch_.imgTitle + "_" + ((Integer)SPTBatch_.nOfTracks.get(r)).toString() + ".csv");
<             } catch (IOException var16) {
<                var16.printStackTrace();
<             }
<          }
<       }
< 
<    }
< 
<    public void keyPressed(Point p, KeyEvent e) {
<    }
< 
<    public void mouseClick(Point p, MouseEvent e) {
<    }
< 
<    public void mouseDrag(Point p, MouseEvent e) {
<    }
< 
<    public void mouseMove(Point p, MouseEvent e) {
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class PhotobleachingSpotPlot
> {
>     JFreeChart chart;
>     JPanel chartpanel;
>     ResultsTable rt;
>     Rectangle2D chartRectangleInSequence;
>     JLabel outLabel;
>     
>     public PhotobleachingSpotPlot() {
>         this.chartpanel = new JPanel();
>         this.chartRectangleInSequence = new Rectangle2D.Float(250.0f, 20.0f, 490.0f, 240.0f);
>         this.outLabel = new JLabel();
>         this.chartpanel.add((Component)new ChartPanel(this.chart, 500, 300, 500, 300, 500, 300, false, false, true, true, true, true));
>     }
>     
>     public void Compute() {
>         final Set<Integer> trackIDs = (Set<Integer>)SPTBatch_.model.getTrackModel().trackIDs(true);
>         final List<Integer> nOfTracks = new ArrayList<Integer>();
>         if (SPTBatch_.checkboxSubBg.isSelected()) {
>             for (int t = 0; t < SPTBatch_.trackJTable.getRowCount(); ++t) {
>                 nOfTracks.add(Integer.valueOf(SPTBatch_.trackJTable.getValueAt(t, 2).toString()));
>             }
>             for (int r = 0; r < nOfTracks.size(); ++r) {
>                 final XYSeriesCollection xyDataset = new XYSeriesCollection();
>                 XYSeries seriesTrack = null;
>                 XYSeries seriesBg = null;
>                 final List<Double> perTrack = new ArrayList<Double>();
>                 final List<Double> perFrame = new ArrayList<Double>();
>                 final List<Double> perTrackDef = new ArrayList<Double>();
>                 final List<Double> perXPositionDef = new ArrayList<Double>();
>                 final List<Double> perYPositionDef = new ArrayList<Double>();
>                 final List<Double> perFrameDef = new ArrayList<Double>();
>                 for (int t2 = 0; t2 < SPTBatch_.tableSpot.getRowCount(); ++t2) {
>                     if (Integer.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t2, 2).toString()).equals(nOfTracks.get(r)) == Boolean.TRUE) {
>                         perTrack.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t2, 12).toString()));
>                         perFrame.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t2, 8).toString()));
>                         perTrackDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t2, 12).toString()));
>                         perFrameDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t2, 8).toString()));
>                         perXPositionDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t2, 4).toString()));
>                         perYPositionDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t2, 5).toString()));
>                     }
>                 }
>                 this.rt = new ResultsTable();
>                 seriesTrack = new XYSeries((Comparable)"Spot Mean Raw Intensity Track ");
>                 seriesBg = new XYSeries((Comparable)"Bg Intensity");
>                 for (int i = 0; i < perTrackDef.size(); ++i) {
>                     seriesTrack.add((Number)perFrameDef.get(i), (Number)perTrackDef.get(i));
>                     this.rt.setValue("Spot Mean Raw Intensity Track ", i, (double)perTrackDef.get(i));
>                 }
>                 for (int i = 0; i < SPTBatch_.imps.getStack().getSize(); ++i) {
>                     seriesBg.add((double)i, (Number)SPTBatch_.slicesIntensitySpot[i]);
>                     this.rt.setValue("Bg Intensity", i, (double)SPTBatch_.slicesIntensitySpot[i]);
>                 }
>                 if (perFrameDef.get(perFrameDef.size() - 1).intValue() != SPTBatch_.imps.getStack().getSize() - 1) {
>                     final ImagePlus[] slices = SPTBatch_.stack2images(SPTBatch_.imps.duplicate());
>                     final OvalRoi ovalRoi = new OvalRoi((double)perXPositionDef.get(perXPositionDef.size() - 1), (double)perXPositionDef.get(perXPositionDef.size() - 1), Double.valueOf(SPTBatch_.RADIUS) / SPTBatch_.imps.getCalibration().pixelWidth, Double.valueOf(SPTBatch_.RADIUS) / SPTBatch_.imps.getCalibration().pixelWidth);
>                     for (int j = perFrameDef.get(perFrameDef.size() - 1).intValue(); j < SPTBatch_.imps.getStack().getSize(); ++j) {
>                         slices[j].setRoi((Roi)ovalRoi);
>                         seriesTrack.add((double)j, slices[j].getStatistics().mean);
>                         this.rt.setValue("Spot Mean Raw Intensity Track ", j, slices[j].getStatistics().mean);
>                     }
>                 }
>                 xyDataset.addSeries(seriesTrack);
>                 xyDataset.addSeries(seriesBg);
>                 this.chart = ChartFactory.createXYLineChart("PhotoBleaching step for Track " + nOfTracks.get(r), "Frame", "Intensity", (XYDataset)xyDataset, PlotOrientation.VERTICAL, true, true, false);
>                 this.chartpanel.removeAll();
>                 if (this.chart != null) {
>                     final XYItemRenderer renderer = ((XYPlot)this.chart.getPlot()).getRenderer();
>                     final PerTrackFeatureColorGenerator tcg = new PerTrackFeatureColorGenerator(SPTBatch_.model, "TRACK_INDEX", (Color)null, (Color)null, Colormap.Turbo, 0.0, 1.0);
>                     final XYPlot plot = this.chart.getXYPlot();
>                     plot.setDataset(0, (XYDataset)xyDataset);
>                     plot.setRenderer(0, renderer);
>                     plot.getRendererForDataset(plot.getDataset(0)).setSeriesPaint(0, (Paint)tcg.colorOf(Integer.valueOf(nOfTracks.get(r))));
>                 }
>                 final XYPlot plot2 = (XYPlot)this.chart.getPlot();
>                 plot2.setBackgroundPaint((Paint)Color.white);
>                 plot2.setDomainGridlinesVisible(true);
>                 plot2.setRangeGridlinesVisible(true);
>                 plot2.setDomainMinorGridlinePaint((Paint)Color.GRAY);
>                 plot2.setDomainGridlinePaint((Paint)Color.DARK_GRAY);
>                 plot2.setRangeMinorGridlinePaint((Paint)Color.GRAY);
>                 plot2.setRangeGridlinePaint((Paint)Color.DARK_GRAY);
>                 this.chartpanel.add((Component)new ChartPanel(this.chart));
>                 this.chartpanel.updateUI();
>                 try {
>                     ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directPBS.getAbsolutePath()) + File.separator + SPTBatch_.imgTitle + "_" + nOfTracks.get(r).toString() + ".png"), this.chart, 2000, 400);
>                 }
>                 catch (IOException e) {
>                     e.printStackTrace();
>                 }
>                 try {
>                     this.rt.saveAs(String.valueOf(SPTBatch_.directPBS.getAbsolutePath()) + File.separator + SPTBatch_.imgTitle + "_" + SPTBatch_.nOfTracks.get(r).toString() + ".csv");
>                 }
>                 catch (IOException e) {
>                     e.printStackTrace();
>                 }
>             }
>         }
>     }
>     
>     public void keyPressed(final Point p, final KeyEvent e) {
>     }
>     
>     public void mouseClick(final Point p, final MouseEvent e) {
>     }
>     
>     public void mouseDrag(final Point p, final MouseEvent e) {
>     }
>     
>     public void mouseMove(final Point p, final MouseEvent e) {
>     }
Only in TrackAnalyzer_: plugins
diff -r TrackAnalyzer_/ProcessTrackMateXml.java procyon/ProcessTrackMateXml.java
1,991d0
< import fiji.plugin.trackmate.Dimension;
< import fiji.plugin.trackmate.FeatureModel;
< import fiji.plugin.trackmate.Model;
< import fiji.plugin.trackmate.SelectionModel;
< import fiji.plugin.trackmate.Settings;
< import fiji.plugin.trackmate.Spot;
< import fiji.plugin.trackmate.SpotCollection;
< import fiji.plugin.trackmate.TrackMate;
< import fiji.plugin.trackmate.detection.DogDetectorFactory;
< import fiji.plugin.trackmate.detection.LogDetectorFactory;
< import fiji.plugin.trackmate.detection.ManualDetectorFactory;
< import fiji.plugin.trackmate.features.FeatureFilter;
< import fiji.plugin.trackmate.features.FeatureUtils;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettingsIO;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings.TrackDisplayMode;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings.TrackMateObject;
< import fiji.plugin.trackmate.io.TmXmlReader;
< import fiji.plugin.trackmate.tracking.LAPUtils;
< import fiji.plugin.trackmate.tracking.ManualTrackerFactory;
< import fiji.plugin.trackmate.tracking.kalman.KalmanTrackerFactory;
< import fiji.plugin.trackmate.tracking.sparselap.SimpleSparseLAPTrackerFactory;
< import fiji.plugin.trackmate.tracking.sparselap.SparseLAPTrackerFactory;
< import fiji.plugin.trackmate.util.TMUtils;
< import fiji.plugin.trackmate.visualization.FeatureColorGenerator;
< import fiji.plugin.trackmate.visualization.hyperstack.HyperStackDisplayer;
< import fiji.plugin.trackmate.visualization.table.TablePanel;
< import ij.ImagePlus;
< import ij.ImageStack;
< import ij.WindowManager;
< import ij.measure.Calibration;
< import ij.measure.ResultsTable;
< import ij.process.ColorProcessor;
< import java.awt.Color;
< import java.awt.Rectangle;
< import java.awt.event.MouseAdapter;
< import java.awt.event.MouseEvent;
< import java.awt.image.BufferedImage;
< import java.io.File;
< import java.io.IOException;
< import java.util.ArrayList;
< import java.util.Collection;
< import java.util.Collections;
< import java.util.HashMap;
< import java.util.HashSet;
< import java.util.Iterator;
< import java.util.List;
< import java.util.Map;
< import java.util.Set;
< import java.util.function.BiConsumer;
< import java.util.function.BiFunction;
< import java.util.function.Function;
< import java.util.function.Supplier;
< import java.util.stream.Collectors;
< import java.util.stream.Stream;
< import javax.swing.ListSelectionModel;
< import javax.xml.parsers.DocumentBuilder;
< import javax.xml.parsers.DocumentBuilderFactory;
< import javax.xml.parsers.ParserConfigurationException;
< import javax.xml.xpath.XPath;
< import javax.xml.xpath.XPathConstants;
< import javax.xml.xpath.XPathExpression;
< import javax.xml.xpath.XPathExpressionException;
< import javax.xml.xpath.XPathFactory;
< import org.jgrapht.graph.DefaultWeightedEdge;
< import org.w3c.dom.Document;
< import org.w3c.dom.Node;
< import org.w3c.dom.NodeList;
< import org.xml.sax.SAXException;
< 
< public class ProcessTrackMateXml {
<    Thread mainProcess;
<    String zstart;
<    String zend;
<    String ystart;
<    String yend;
<    String xstart;
<    String xend;
<    String tstart;
<    String tend;
<    String RADIUS;
<    String THRESHOLD;
<    String TARGET_CHANNEL;
<    String DO_SUBPIXEL_LOCALIZATION;
<    String DO_MEDIAN_FILTERING;
<    String DETECTOR_NAME;
<    String NSPLIT;
<    String DOWNSAMPLE_FACTOR;
<    String initialSpotFilter;
<    String TRACKER_NAME;
<    String CUTOFF_PERCENTILE;
<    String ALTERNATIVE_LINKING_COST_FACTOR;
<    String LINKING_MAX_DISTANCE;
<    String MAX_FRAME_GAP;
<    String MAX_DISTANCE;
<    String ALLOW_GAP_CLOSING;
<    String SPLITTING_MAX_DISTANCE;
<    String ALLOW_TRACK_SPLITTING;
<    String MERGING_MAX_DISTANCE;
<    String ALLOW_TRACK_MERGING;
<    String BLOCKING_VALUE;
<    static Model model;
<    static Settings settings;
<    static SelectionModel selectionModel;
<    static TrackMate trackmate;
<    SpotCollection totalSpots;
<    static HyperStackDisplayer displayer;
<    ImagePlus impAnal;
<    ImagePlus[] imps;
<    static boolean tracksVisible;
<    static boolean spotsVisible;
<    static String[][] dataSpot;
<    static String[][] dataTrack;
<    static String[] columnHeadersSpot;
<    static String[] columnHeadersTrack;
<    static DisplaySettings ds;
<    public static final String NAME = "Export statistics to tables";
<    public static final String KEY = "EXPORT_STATS_TO_IJ";
<    public static final String INFO_TEXT = "<html>Compute and export all statistics to 3 ImageJ results table. Statistisc are separated in features computed for: <ol> \t<li> spots in filtered tracks; \t<li> links between those spots; \t<li> filtered tracks. </ol> For tracks and links, they are recalculated prior to exporting. Note that spots and links that are not in a filtered tracks are not part of this export.</html>";
<    private static final String SPOT_TABLE_NAME = "Spots in tracks statistics";
<    private static final String EDGE_TABLE_NAME = "Links in tracks statistics";
<    private static final String TRACK_TABLE_NAME = "Track statistics";
<    private static final String ID_COLUMN = "ID";
<    private static final String TRACK_ID_COLUMN = "TRACK_ID";
<    private ResultsTable spotTable;
<    private ResultsTable edgeTable;
<    private ResultsTable trackTable;
<    public static final String KEYLINEAR = "Linear track analysis";
<    public static final String TRACK_TOTAL_DISTANCE_TRAVELED = "TOTAL_DISTANCE_TRAVELED";
<    public static final String TRACK_MAX_DISTANCE_TRAVELED = "MAX_DISTANCE_TRAVELED";
<    public static final String TRACK_CONFINMENT_RATIO = "CONFINMENT_RATIO";
<    public static final String TRACK_MEAN_STRAIGHT_LINE_SPEED = "MEAN_STRAIGHT_LINE_SPEED";
<    public static final String TRACK_LINEARITY_OF_FORWARD_PROGRESSION = "LINEARITY_OF_FORWARD_PROGRESSION";
<    public static final String TOTAL_ABSOLUTE_ANGLE_XY = "TOTAL_ABSOLUTE_ANGLE_XY";
<    public static final String TOTAL_ABSOLUTE_ANGLE_YZ = "TOTAL_ABSOLUTE_ANGLE_YZ";
<    public static final String TOTAL_ABSOLUTE_ANGLE_ZX = "TOTAL_ABSOLUTE_ANGLE_ZX";
<    public static final List<String> FEATURES = new ArrayList(9);
<    public static final Map<String, String> FEATURE_NAMES = new HashMap(9);
<    public static final Map<String, String> FEATURE_SHORT_NAMES = new HashMap(9);
<    public static final Map<String, Dimension> FEATURE_DIMENSIONS = new HashMap(9);
<    public static final Map<String, Boolean> IS_INT = new HashMap(9);
< 
<    public ProcessTrackMateXml() {
<       this.imps = FirstWizardPanel.imps;
<    }
< 
<    public void processTrackMateXml() {
<       this.mainProcess = new Thread(new Runnable() {
<          public void run() {
<             File fileXML = new File(TrackAnalyzer_.xmlPath);
<             List<ImagePlus> impAnalClose = new ArrayList();
<             int[] IDs = WindowManager.getIDList();
<             int i;
<             if (IDs != null) {
<                for(i = 0; i < IDs.length; ++i) {
<                   impAnalClose.add(WindowManager.getImage(IDs[i]));
<                }
<             }
< 
<             if (FirstWizardPanel.spotEnable.equals("spotEnable") == Boolean.TRUE && FirstWizardPanel.tableImages.getSelectedRow() != -1) {
<                if (IDs != null) {
<                   for(i = 0; i < IDs.length; ++i) {
<                      ((ImagePlus)impAnalClose.get(i)).hide();
<                   }
<                }
< 
<                ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[FirstWizardPanel.tableImages.getSelectedRow()];
<             }
< 
<             if (FirstWizardPanel.spotEnable.equals("spotEnable") == Boolean.TRUE && FirstWizardPanel.tableImages.getSelectedRow() == -1) {
<                ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[ChooserWizardPanel.tableImages.getSelectedRow()];
<             }
< 
<             if (ChooserWizardPanel.trackEnable.equals("trackEnable") == Boolean.TRUE && ChooserWizardPanel.tableImages.getSelectedRow() != -1) {
<                if (IDs != null) {
<                   for(i = 0; i < IDs.length; ++i) {
<                      ((ImagePlus)impAnalClose.get(i)).hide();
<                   }
<                }
< 
<                ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[ChooserWizardPanel.tableImages.getSelectedRow()];
<             }
< 
<             if (ChooserWizardPanel.trackEnable.equals("trackEnable") == Boolean.TRUE && ChooserWizardPanel.tableImages.getSelectedRow() == -1) {
<                ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[FirstWizardPanel.tableImages.getSelectedRow()];
<             }
< 
<             ProcessTrackMateXml.this.impAnal.show();
<             int[] dims = ProcessTrackMateXml.this.impAnal.getDimensions();
<             if (dims[4] == 1 && dims[3] > 1) {
<                ProcessTrackMateXml.this.impAnal.setDimensions(dims[2], dims[4], dims[3]);
<                Calibration calibration = ProcessTrackMateXml.this.impAnal.getCalibration();
<                calibration.frameInterval = 1.0D;
<             }
< 
<             new TmXmlReader(fileXML);
<             DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
<             DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
<             DocumentBuilder builder = null;
< 
<             try {
<                builder = factory.newDocumentBuilder();
<             } catch (ParserConfigurationException var116) {
<                var116.printStackTrace();
<             }
< 
<             Document doc = null;
< 
<             try {
<                doc = builder.parse(TrackAnalyzer_.xmlPath);
<             } catch (SAXException var114) {
<                var114.printStackTrace();
<             } catch (IOException var115) {
<                var115.printStackTrace();
<             }
< 
<             XPathFactory xPathfactory = XPathFactory.newInstance();
<             XPath xpath = xPathfactory.newXPath();
<             XPathExpression exprBasicSettings = null;
<             XPathExpression exprDetectorSettings = null;
<             XPathExpression exprInitialSpotFilter = null;
<             XPathExpression exprFilter = null;
<             XPathExpression exprTrackerSettings = null;
<             XPathExpression exprLinking = null;
<             XPathExpression exprGapClosing = null;
<             XPathExpression exprSplitting = null;
<             XPathExpression exprMerging = null;
<             XPathExpression exprTrackFilter = null;
<             XPathExpression exprLinkingP = null;
< 
<             try {
<                exprBasicSettings = xpath.compile("//Settings/BasicSettings[@zstart]");
<             } catch (XPathExpressionException var113) {
<                var113.printStackTrace();
<             }
< 
<             try {
<                exprLinkingP = xpath.compile("//Linking/FeaturePenalties[@MEAN_INTENSITY]");
<             } catch (XPathExpressionException var112) {
<                var112.printStackTrace();
<             }
< 
<             try {
<                exprDetectorSettings = xpath.compile("//Settings/DetectorSettings[@RADIUS]");
<             } catch (XPathExpressionException var111) {
<                var111.printStackTrace();
<             }
< 
<             try {
<                exprInitialSpotFilter = xpath.compile("//Settings/InitialSpotFilter[@feature]");
<             } catch (XPathExpressionException var110) {
<                var110.printStackTrace();
<             }
< 
<             try {
<                exprFilter = xpath.compile("//SpotFilterCollection/Filter[@feature]");
<             } catch (XPathExpressionException var109) {
<                var109.printStackTrace();
<             }
< 
<             try {
<                exprTrackerSettings = xpath.compile("//Settings/TrackerSettings[@TRACKER_NAME]");
<             } catch (XPathExpressionException var108) {
<                var108.printStackTrace();
<             }
< 
<             try {
<                exprLinking = xpath.compile("//TrackerSettings/Linking[@LINKING_MAX_DISTANCE]");
<             } catch (XPathExpressionException var107) {
<                var107.printStackTrace();
<             }
< 
<             try {
<                exprGapClosing = xpath.compile("//TrackerSettings/GapClosing[@MAX_FRAME_GAP]");
<             } catch (XPathExpressionException var106) {
<                var106.printStackTrace();
<             }
< 
<             try {
<                exprSplitting = xpath.compile("//TrackerSettings/TrackSplitting[@SPLITTING_MAX_DISTANCE]");
<             } catch (XPathExpressionException var105) {
<                var105.printStackTrace();
<             }
< 
<             try {
<                exprMerging = xpath.compile("//TrackerSettings/TrackMerging[@MERGING_MAX_DISTANCE]");
<             } catch (XPathExpressionException var104) {
<                var104.printStackTrace();
<             }
< 
<             try {
<                exprTrackFilter = xpath.compile("//TrackFilterCollection/Filter[@feature]");
<             } catch (XPathExpressionException var103) {
<                var103.printStackTrace();
<             }
< 
<             NodeList nlBasicSettings = null;
<             NodeList nlDetectorSettings = null;
<             NodeList nlInitialSpotFilter = null;
<             NodeList nlFilter = null;
<             NodeList nlTrackerSettings = null;
<             NodeList nlLinking = null;
<             NodeList nlGapClosing = null;
<             NodeList nlSplitting = null;
<             NodeList nlMerging = null;
<             NodeList nlTrackFilter = null;
<             NodeList nlLinkingP = null;
< 
<             try {
<                nlBasicSettings = (NodeList)exprBasicSettings.evaluate(doc, XPathConstants.NODESET);
<                nlDetectorSettings = (NodeList)exprDetectorSettings.evaluate(doc, XPathConstants.NODESET);
<                nlInitialSpotFilter = (NodeList)exprInitialSpotFilter.evaluate(doc, XPathConstants.NODESET);
<                nlFilter = (NodeList)exprFilter.evaluate(doc, XPathConstants.NODESET);
<                nlTrackerSettings = (NodeList)exprTrackerSettings.evaluate(doc, XPathConstants.NODESET);
<                nlLinking = (NodeList)exprLinking.evaluate(doc, XPathConstants.NODESET);
<                nlGapClosing = (NodeList)exprGapClosing.evaluate(doc, XPathConstants.NODESET);
<                nlSplitting = (NodeList)exprSplitting.evaluate(doc, XPathConstants.NODESET);
<                nlMerging = (NodeList)exprMerging.evaluate(doc, XPathConstants.NODESET);
<                nlTrackFilter = (NodeList)exprTrackFilter.evaluate(doc, XPathConstants.NODESET);
<                nlLinkingP = (NodeList)exprLinkingP.evaluate(doc, XPathConstants.NODESET);
<             } catch (XPathExpressionException var102) {
<                var102.printStackTrace();
<             }
< 
<             Node linkingNames;
<             for(int ixx = 0; ixx < nlBasicSettings.getLength(); ++ixx) {
<                linkingNames = nlBasicSettings.item(ixx);
<                ProcessTrackMateXml.this.zstart = linkingNames.getAttributes().getNamedItem("zstart").getNodeValue();
<                ProcessTrackMateXml.this.zend = linkingNames.getAttributes().getNamedItem("zend").getNodeValue();
<                ProcessTrackMateXml.this.ystart = linkingNames.getAttributes().getNamedItem("ystart").getNodeValue();
<                ProcessTrackMateXml.this.yend = linkingNames.getAttributes().getNamedItem("yend").getNodeValue();
<                ProcessTrackMateXml.this.xstart = linkingNames.getAttributes().getNamedItem("xstart").getNodeValue();
<                ProcessTrackMateXml.this.xend = linkingNames.getAttributes().getNamedItem("xend").getNodeValue();
<                ProcessTrackMateXml.this.tstart = linkingNames.getAttributes().getNamedItem("tstart").getNodeValue();
<                ProcessTrackMateXml.this.tend = linkingNames.getAttributes().getNamedItem("tend").getNodeValue();
<             }
< 
<             Node currentItem = null;
< 
<             for(int ix = 0; ix < nlDetectorSettings.getLength(); ++ix) {
<                currentItem = nlDetectorSettings.item(ix);
<                ProcessTrackMateXml.this.RADIUS = currentItem.getAttributes().getNamedItem("RADIUS").getNodeValue();
<                ProcessTrackMateXml.this.THRESHOLD = currentItem.getAttributes().getNamedItem("THRESHOLD").getNodeValue();
<                ProcessTrackMateXml.this.TARGET_CHANNEL = currentItem.getAttributes().getNamedItem("TARGET_CHANNEL").getNodeValue();
<                ProcessTrackMateXml.this.DO_SUBPIXEL_LOCALIZATION = currentItem.getAttributes().getNamedItem("DO_SUBPIXEL_LOCALIZATION").getNodeValue();
<                ProcessTrackMateXml.this.DO_MEDIAN_FILTERING = currentItem.getAttributes().getNamedItem("DO_MEDIAN_FILTERING").getNodeValue();
<                ProcessTrackMateXml.this.DETECTOR_NAME = currentItem.getAttributes().getNamedItem("DETECTOR_NAME").getNodeValue();
<                if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("BLOCK_LOG_DETECTOR")) {
<                   ProcessTrackMateXml.this.NSPLIT = currentItem.getAttributes().getNamedItem("NSPLIT").getNodeValue();
<                }
< 
<                if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("DOWNSAMLE_LOG_DETECTOR")) {
<                   ProcessTrackMateXml.this.DOWNSAMPLE_FACTOR = currentItem.getAttributes().getNamedItem("DOWNSAMPLE_FACTOR").getNodeValue();
<                }
<             }
< 
<             linkingNames = null;
<             String linkingValues = null;
< 
<             int ixxx;
<             for(ixxx = 0; ixxx < nlLinkingP.getLength(); ++ixxx) {
<                nlLinkingP.item(ixxx).getAttributes().item(ixxx).getNodeName();
<                nlLinkingP.item(ixxx).getAttributes().item(ixxx).getNodeValue();
<             }
< 
<             for(ixxx = 0; ixxx < nlInitialSpotFilter.getLength(); ++ixxx) {
<                currentItem = nlInitialSpotFilter.item(ixxx);
<                ProcessTrackMateXml.this.initialSpotFilter = currentItem.getAttributes().getNamedItem("value").getNodeValue();
<             }
< 
<             String initialFilterFeature = null;
<             String initialFilterValue = null;
<             String initialFilterAbove = null;
< 
<             for(int ixxxx = 0; ixxxx < nlFilter.getLength(); ++ixxxx) {
<                currentItem = nlFilter.item(ixxxx);
<                initialFilterFeature = currentItem.getAttributes().getNamedItem("feature").getNodeValue();
<                initialFilterValue = currentItem.getAttributes().getNamedItem("value").getNodeValue();
<                initialFilterAbove = currentItem.getAttributes().getNamedItem("isabove").getNodeValue();
<             }
< 
<             String initialTrackFilterFeature = null;
<             String initialTrackFilterValue = null;
<             String initialTrackFilterAbove = null;
< 
<             int ixxxxx;
<             for(ixxxxx = 0; ixxxxx < nlTrackerSettings.getLength(); ++ixxxxx) {
<                currentItem = nlTrackerSettings.item(ixxxxx);
<                ProcessTrackMateXml.this.TRACKER_NAME = currentItem.getAttributes().getNamedItem("TRACKER_NAME").getNodeValue();
<                ProcessTrackMateXml.this.CUTOFF_PERCENTILE = currentItem.getAttributes().getNamedItem("CUTOFF_PERCENTILE").getNodeValue();
<                ProcessTrackMateXml.this.BLOCKING_VALUE = currentItem.getAttributes().getNamedItem("BLOCKING_VALUE").getNodeValue();
<                ProcessTrackMateXml.this.ALTERNATIVE_LINKING_COST_FACTOR = currentItem.getAttributes().getNamedItem("ALTERNATIVE_LINKING_COST_FACTOR").getNodeValue();
<             }
< 
<             for(ixxxxx = 0; ixxxxx < nlLinking.getLength(); ++ixxxxx) {
<                currentItem = nlLinking.item(ixxxxx);
<                ProcessTrackMateXml.this.LINKING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("LINKING_MAX_DISTANCE").getNodeValue();
<             }
< 
<             for(ixxxxx = 0; ixxxxx < nlGapClosing.getLength(); ++ixxxxx) {
<                currentItem = nlGapClosing.item(ixxxxx);
<                ProcessTrackMateXml.this.MAX_FRAME_GAP = currentItem.getAttributes().getNamedItem("MAX_FRAME_GAP").getNodeValue();
<                ProcessTrackMateXml.this.MAX_DISTANCE = currentItem.getAttributes().getNamedItem("GAP_CLOSING_MAX_DISTANCE").getNodeValue();
<                ProcessTrackMateXml.this.ALLOW_GAP_CLOSING = currentItem.getAttributes().getNamedItem("ALLOW_GAP_CLOSING").getNodeValue();
<             }
< 
<             for(ixxxxx = 0; ixxxxx < nlSplitting.getLength(); ++ixxxxx) {
<                currentItem = nlSplitting.item(ixxxxx);
<                ProcessTrackMateXml.this.SPLITTING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("SPLITTING_MAX_DISTANCE").getNodeValue();
<                ProcessTrackMateXml.this.ALLOW_TRACK_SPLITTING = currentItem.getAttributes().getNamedItem("ALLOW_TRACK_SPLITTING").getNodeValue();
<             }
< 
<             for(ixxxxx = 0; ixxxxx < nlMerging.getLength(); ++ixxxxx) {
<                currentItem = nlMerging.item(ixxxxx);
<                ProcessTrackMateXml.this.MERGING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("MERGING_MAX_DISTANCE").getNodeValue();
<                ProcessTrackMateXml.this.ALLOW_TRACK_MERGING = currentItem.getAttributes().getNamedItem("ALLOW_TRACK_MERGING").getNodeValue();
<             }
< 
<             ProcessTrackMateXml.settings = new Settings(ProcessTrackMateXml.this.impAnal);
<             ProcessTrackMateXml.settings.dt = 0.05D;
<             FeatureFilter ok;
<             if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("LOG_DETECTOR")) {
<                ProcessTrackMateXml.settings.detectorFactory = new LogDetectorFactory();
<                ProcessTrackMateXml.settings.detectorSettings = ProcessTrackMateXml.settings.detectorFactory.getDefaultSettings();
<                ProcessTrackMateXml.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", Boolean.parseBoolean(ProcessTrackMateXml.this.DO_SUBPIXEL_LOCALIZATION));
<                ProcessTrackMateXml.settings.detectorSettings.put("RADIUS", Double.parseDouble(ProcessTrackMateXml.this.RADIUS));
<                ProcessTrackMateXml.settings.detectorSettings.put("TARGET_CHANNEL", Integer.parseInt(ProcessTrackMateXml.this.TARGET_CHANNEL));
<                ProcessTrackMateXml.settings.detectorSettings.put("THRESHOLD", Double.parseDouble(ProcessTrackMateXml.this.THRESHOLD));
<                ProcessTrackMateXml.settings.detectorSettings.put("DO_MEDIAN_FILTERING", Boolean.parseBoolean(ProcessTrackMateXml.this.DO_MEDIAN_FILTERING));
<                if (ProcessTrackMateXml.this.initialSpotFilter != null) {
<                   ProcessTrackMateXml.settings.initialSpotFilterValue = Double.parseDouble(ProcessTrackMateXml.this.initialSpotFilter);
<                }
< 
<                if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("MANUAL_DETECTOR")) {
<                   ProcessTrackMateXml.settings.detectorFactory = new ManualDetectorFactory();
<                   ProcessTrackMateXml.settings.detectorSettings.put("RADIUS", Double.parseDouble(ProcessTrackMateXml.this.RADIUS));
<                   if (ProcessTrackMateXml.this.initialSpotFilter != null) {
<                      ProcessTrackMateXml.settings.initialSpotFilterValue = Double.parseDouble(ProcessTrackMateXml.this.initialSpotFilter);
<                   }
<                }
< 
<                if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("DOG_DETECTOR")) {
<                   ProcessTrackMateXml.settings.detectorFactory = new DogDetectorFactory();
<                   ProcessTrackMateXml.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", Boolean.parseBoolean(ProcessTrackMateXml.this.DO_SUBPIXEL_LOCALIZATION));
<                   ProcessTrackMateXml.settings.detectorSettings.put("RADIUS", Double.parseDouble(ProcessTrackMateXml.this.RADIUS));
<                   ProcessTrackMateXml.settings.detectorSettings.put("TARGET_CHANNEL", Integer.parseInt(ProcessTrackMateXml.this.TARGET_CHANNEL));
<                   ProcessTrackMateXml.settings.detectorSettings.put("THRESHOLD", Double.parseDouble(ProcessTrackMateXml.this.THRESHOLD));
<                   ProcessTrackMateXml.settings.detectorSettings.put("DO_MEDIAN_FILTERING", Double.parseDouble(ProcessTrackMateXml.this.DO_MEDIAN_FILTERING));
<                   if (ProcessTrackMateXml.this.initialSpotFilter != null) {
<                      ProcessTrackMateXml.settings.initialSpotFilterValue = Double.parseDouble(ProcessTrackMateXml.this.initialSpotFilter);
<                   }
<                }
< 
<                if (initialFilterFeature != null) {
<                   ok = new FeatureFilter(initialFilterFeature, Double.parseDouble(initialFilterValue), Boolean.parseBoolean(initialFilterAbove));
<                   ProcessTrackMateXml.settings.addSpotFilter(ok);
<                }
<             }
< 
<             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
<                ProcessTrackMateXml.settings.trackerFactory = new ManualTrackerFactory();
<                ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<             }
< 
<             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
<                ProcessTrackMateXml.settings.trackerFactory = new ManualTrackerFactory();
<                ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<             }
< 
<             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("KALMAN_TRACKER")) {
<                ProcessTrackMateXml.settings.trackerFactory = new KalmanTrackerFactory();
<                ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                ProcessTrackMateXml.settings.trackerSettings.put("KALMAN_SEARCH_RADIUS", Double.parseDouble(ProcessTrackMateXml.this.RADIUS));
<             }
< 
<             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("SIMPLE_SPARSE_LAP_TRACKER")) {
<                ProcessTrackMateXml.settings.trackerFactory = new SimpleSparseLAPTrackerFactory();
<                ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                ProcessTrackMateXml.settings.trackerSettings.put("LINKING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.LINKING_MAX_DISTANCE));
<                ProcessTrackMateXml.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.MAX_DISTANCE));
<                ProcessTrackMateXml.settings.trackerSettings.put("MAX_FRAME_GAP", Double.parseDouble(ProcessTrackMateXml.this.MAX_FRAME_GAP));
<             }
< 
<             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("SPARSE_LAP_TRACKER")) {
<                ProcessTrackMateXml.settings.trackerFactory = new SparseLAPTrackerFactory();
<                ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                ProcessTrackMateXml.settings.trackerSettings.put("LINKING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.LINKING_MAX_DISTANCE));
<                Map<String, Double> linkingPenalty = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((data) -> {
<                   return (String)data[0];
<                }, (data) -> {
<                   return (Double)data[1];
<                }));
<                ProcessTrackMateXml.settings.trackerSettings.put("ALLOW_GAP_CLOSING", Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_GAP_CLOSING));
<                Map var44;
<                if (Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_GAP_CLOSING)) {
<                   ProcessTrackMateXml.settings.trackerSettings.put("MAX_FRAME_GAP", Integer.parseInt(ProcessTrackMateXml.this.MAX_FRAME_GAP));
<                   ProcessTrackMateXml.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.MAX_DISTANCE));
<                   var44 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((data) -> {
<                      return (String)data[0];
<                   }, (data) -> {
<                      return (Double)data[1];
<                   }));
<                }
< 
<                ProcessTrackMateXml.settings.trackerSettings.put("ALLOW_TRACK_SPLITTING", Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_SPLITTING));
<                if (Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_SPLITTING)) {
<                   ProcessTrackMateXml.settings.trackerSettings.put("SPLITTING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.SPLITTING_MAX_DISTANCE));
<                   var44 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((data) -> {
<                      return (String)data[0];
<                   }, (data) -> {
<                      return (Double)data[1];
<                   }));
<                }
< 
<                ProcessTrackMateXml.settings.trackerSettings.put("ALLOW_TRACK_MERGING", Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_MERGING));
<                if (Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_MERGING)) {
<                   ProcessTrackMateXml.settings.trackerSettings.put("MERGING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.MERGING_MAX_DISTANCE));
<                   var44 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((data) -> {
<                      return (String)data[0];
<                   }, (data) -> {
<                      return (Double)data[1];
<                   }));
<                }
<             }
< 
<             ProcessTrackMateXml.settings.addAllAnalyzers();
<             ProcessTrackMateXml.model = new Model();
<             ProcessTrackMateXml.trackmate = new TrackMate(ProcessTrackMateXml.model, ProcessTrackMateXml.settings);
<             ok = null;
<             Boolean okx = ProcessTrackMateXml.trackmate.checkInput();
<             okx = ProcessTrackMateXml.trackmate.process();
<             FeatureModel fm = ProcessTrackMateXml.model.getFeatureModel();
<             Set<Integer> trackIDs = ProcessTrackMateXml.model.getTrackModel().trackIDs(true);
<             Set<Spot> track = null;
< 
<             for(int id = 0; id < trackIDs.size(); ++id) {
<                fm.getTrackFeature(id, "TRACK_MEAN_SPEED");
<                track = ProcessTrackMateXml.model.getTrackModel().trackSpots(id);
<             }
< 
<             Double widthx;
<             Double heightx;
<             Double nCapturesx;
<             Double stackx;
<             Double channelx;
<             Double slicex;
<             Spot spot;
<             for(Iterator var48 = track.iterator(); var48.hasNext(); slicex = spot.getFeature("MEAN_INTENSITY")) {
<                spot = (Spot)var48.next();
<                int sid = spot.ID();
<                widthx = spot.getFeature("POSITION_X");
<                heightx = spot.getFeature("POSITION_Y");
<                nCapturesx = spot.getFeature("FRAME");
<                stackx = spot.getFeature("QUALITY");
<                channelx = spot.getFeature("SNR");
<             }
< 
<             ProcessTrackMateXml.this.totalSpots = ProcessTrackMateXml.model.getSpots();
<             ProcessTrackMateXml.displayer = null;
<             ProcessTrackMateXml.selectionModel = new SelectionModel(ProcessTrackMateXml.model);
<             ProcessTrackMateXml.ds = DisplaySettingsIO.readUserDefault();
<             ProcessTrackMateXml.ds.setSpotShowName(true);
<             ProcessTrackMateXml.ds.setSpotVisible(ProcessTrackMateXml.spotsVisible);
<             ProcessTrackMateXml.ds.setSpotColorBy(TrackMateObject.TRACKS, "TRACK_INDEX");
<             ProcessTrackMateXml.ds.setTrackVisible(ProcessTrackMateXml.tracksVisible);
<             ProcessTrackMateXml.ds.setTrackColorBy(TrackMateObject.TRACKS, "TRACK_INDEX");
<             ProcessTrackMateXml.ds.setTrackDisplayMode(TrackDisplayMode.FULL);
<             ProcessTrackMateXml.displayer = new HyperStackDisplayer(ProcessTrackMateXml.model, ProcessTrackMateXml.selectionModel, ProcessTrackMateXml.this.impAnal, ProcessTrackMateXml.ds);
<             ProcessTrackMateXml.displayer.render();
<             ProcessTrackMateXml.displayer.refresh();
<             spot = null;
<             Integer firstFrame = null;
<             Integer lastFrame = null;
<             widthx = null;
<             heightx = null;
<             nCapturesx = null;
<             stackx = null;
<             channelx = null;
<             slicex = null;
<             BufferedImage bi = null;
<             ColorProcessor cp = null;
<             Integer index = null;
<             ImagePlus capture = null;
<             if (ProcessTrackMateXml.this.impAnal.getNFrames() > 1) {
<                firstFrame = Math.max(1, Math.min(ProcessTrackMateXml.this.impAnal.getNFrames(), 1));
<                lastFrame = Math.min(ProcessTrackMateXml.this.impAnal.getNFrames(), Math.max(ProcessTrackMateXml.this.impAnal.getNFrames(), 1));
<             }
< 
<             if (ProcessTrackMateXml.this.impAnal.getNSlices() > 1) {
<                firstFrame = Math.max(1, Math.min(ProcessTrackMateXml.this.impAnal.getNSlices(), 1));
<                lastFrame = Math.min(ProcessTrackMateXml.this.impAnal.getNSlices(), Math.max(ProcessTrackMateXml.this.impAnal.getNSlices(), 1));
<             }
< 
<             Rectangle bounds = ProcessTrackMateXml.displayer.getImp().getCanvas().getBounds();
<             Integer width = bounds.width;
<             Integer height = bounds.height;
<             Integer nCaptures = lastFrame - firstFrame + 1;
<             ImageStack stack = new ImageStack(width, height);
<             Integer channel = ProcessTrackMateXml.displayer.getImp().getChannel();
<             Integer slice = ProcessTrackMateXml.displayer.getImp().getSlice();
<             ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(true);
< 
<             for(int frame = firstFrame; frame <= lastFrame; ++frame) {
<                ProcessTrackMateXml.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
<                bi = new BufferedImage(width, height, 2);
<                ProcessTrackMateXml.displayer.getImp().getCanvas().paint(bi.getGraphics());
<                cp = new ColorProcessor(bi);
<                index = ProcessTrackMateXml.displayer.getImp().getStackIndex(channel, slice, frame);
<                stack.addSlice(ProcessTrackMateXml.displayer.getImp().getImageStack().getSliceLabel(index), cp);
<             }
< 
<             ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(false);
<             capture = new ImagePlus("TrackMate capture of " + ProcessTrackMateXml.displayer.getImp().getShortTitle(), stack);
<             ProcessTrackMateXml.transferCalibration(ProcessTrackMateXml.displayer.getImp(), capture);
<             FeatureModel fm1;
<             Set trackIDs1;
<             Set edges;
<             final Model model;
<             int j;
<             ArrayList dataListSpot;
<             int jx;
<             if (FirstWizardPanel.spotEnable.equals("spotEnable") == Boolean.TRUE) {
<                model = ProcessTrackMateXml.trackmate.getModel();
<                fm1 = model.getFeatureModel();
<                trackIDs1 = model.getTrackModel().trackIDs(true);
<                Collection<String> spotFeatures = ProcessTrackMateXml.trackmate.getModel().getFeatureModel().getSpotFeatures();
<                ResultsTable spotTable = new ResultsTable();
<                Iterator var66 = trackIDs1.iterator();
< 
<                ArrayList stringsSpot;
<                while(var66.hasNext()) {
<                   Integer trackIDx = (Integer)var66.next();
<                   edges = model.getTrackModel().trackSpots(trackIDx);
<                   stringsSpot = new ArrayList(edges);
<                   Collections.sort(stringsSpot, Spot.frameComparator);
<                   Iterator var70 = stringsSpot.iterator();
< 
<                   while(var70.hasNext()) {
<                      Spot spotx = (Spot)var70.next();
<                      spotTable.incrementCounter();
<                      spotTable.addLabel(spotx.getName());
<                      spotTable.addValue("ID", "" + spotx.ID());
<                      spotTable.addValue("TRACK_ID", "" + trackIDx);
<                      Iterator var72 = spotFeatures.iterator();
< 
<                      while(var72.hasNext()) {
<                         String featurex = (String)var72.next();
<                         Double valx = spotx.getFeature(featurex);
<                         if (valx == null) {
<                            spotTable.addValue(featurex, "None");
<                         } else if ((Boolean)fm1.getSpotFeatureIsInt().get(featurex)) {
<                            spotTable.addValue(featurex, "" + valx.intValue());
<                         } else {
<                            spotTable.addValue(featurex, valx);
<                         }
<                      }
<                   }
<                }
< 
<                ProcessTrackMateXml.columnHeadersSpot = spotTable.getHeadings();
<                j = spotTable.size();
<                dataListSpot = new ArrayList();
< 
<                for(jx = 0; jx < j; ++jx) {
<                   stringsSpot = new ArrayList();
< 
<                   for(int c = 0; c < ProcessTrackMateXml.columnHeadersSpot.length; ++c) {
<                      String valuesSpot = spotTable.getStringValue(ProcessTrackMateXml.columnHeadersSpot[c], jx);
<                      stringsSpot.add(valuesSpot);
<                   }
< 
<                   dataListSpot.add(stringsSpot);
<                }
< 
<                ProcessTrackMateXml.dataSpot = new String[dataListSpot.size()][];
< 
<                for(jx = 0; jx < ProcessTrackMateXml.dataSpot.length; ++jx) {
<                   ProcessTrackMateXml.dataSpot[jx] = new String[((List)dataListSpot.get(jx)).size()];
<                }
< 
<                for(jx = 0; jx < dataListSpot.size(); ++jx) {
<                   for(int ux = 1; ux < ((List)dataListSpot.get(jx)).size(); ++ux) {
<                      ProcessTrackMateXml.dataSpot[jx][ux] = (String)((List)dataListSpot.get(jx)).get(ux);
<                   }
<                }
< 
<                FirstWizardPanel.createSpotTable();
<                FirstWizardPanel.tableSpot.addMouseListener(new MouseAdapter() {
<                   public void mouseReleased(MouseEvent e) {
<                      if (ProcessTrackMateXml.selectionModel != null && FirstWizardPanel.command == "enable" && FirstWizardPanel.command != null) {
<                         ListSelectionModel lsm = FirstWizardPanel.tableSpot.getSelectionModel();
<                         int selStart = lsm.getMinSelectionIndex();
<                         int selEnd = lsm.getMaxSelectionIndex();
<                         if (selStart < 0 || selEnd < 0) {
<                            return;
<                         }
< 
<                         int minLine = Math.min(selStart, selEnd);
<                         int maxLine = Math.max(selStart, selEnd);
<                         Set<Spot> spots = new HashSet();
< 
<                         for(int row = minLine; row <= maxLine; ++row) {
<                            int spotID = Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(row, 2));
<                            Spot spot = ProcessTrackMateXml.this.totalSpots.search(spotID);
<                            if (spot != null) {
<                               spots.add(spot);
<                            }
<                         }
< 
<                         ProcessTrackMateXml.selectionModel.clearSelection();
<                         ProcessTrackMateXml.selectionModel.addSpotToSelection(spots);
<                      }
< 
<                   }
<                });
<             }
< 
<             if (ChooserWizardPanel.trackEnable.equals("trackEnable") == Boolean.TRUE) {
<                ProcessTrackMateXml.FEATURES.add("TOTAL_DISTANCE_TRAVELED");
<                ProcessTrackMateXml.FEATURES.add("MAX_DISTANCE_TRAVELED");
<                ProcessTrackMateXml.FEATURES.add("CONFINMENT_RATIO");
<                ProcessTrackMateXml.FEATURES.add("MEAN_STRAIGHT_LINE_SPEED");
<                ProcessTrackMateXml.FEATURES.add("LINEARITY_OF_FORWARD_PROGRESSION");
<                ProcessTrackMateXml.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_XY");
<                ProcessTrackMateXml.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_YZ");
<                ProcessTrackMateXml.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_ZX");
<                ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total distance traveled");
<                ProcessTrackMateXml.FEATURE_NAMES.put("MAX_DISTANCE_TRAVELED", "Max distance traveled");
<                ProcessTrackMateXml.FEATURE_NAMES.put("CONFINMENT_RATIO", "Confinment ratio");
<                ProcessTrackMateXml.FEATURE_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean straight line speed");
<                ProcessTrackMateXml.FEATURE_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Linearity of forward progression");
<                ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Absolute angle in xy plane");
<                ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Absolute angle in yz plane");
<                ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Absolute angle in zx plane");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total dist.");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("MAX_DISTANCE_TRAVELED", "Max dist.");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("CONFINMENT_RATIO", "Cnfnmnt ratio");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean v. line");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Lin. fwd. progr.");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Abs. angle xy");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Abs. angle yz");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Abs. angle zx");
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_DISTANCE_TRAVELED", Dimension.LENGTH);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("MAX_DISTANCE_TRAVELED", Dimension.LENGTH);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("CONFINMENT_RATIO", Dimension.NONE);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("MEAN_STRAIGHT_LINE_SPEED", Dimension.VELOCITY);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("LINEARITY_OF_FORWARD_PROGRESSION", Dimension.NONE);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_XY", Dimension.ANGLE);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_YZ", Dimension.ANGLE);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_ZX", Dimension.ANGLE);
<                ProcessTrackMateXml.IS_INT.put("TOTAL_DISTANCE_TRAVELED", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("MAX_DISTANCE_TRAVELED", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("CONFINMENT_RATIO", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("MEAN_STRAIGHT_LINE_SPEED", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("LINEARITY_OF_FORWARD_PROGRESSION", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_XY", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_YZ", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_ZX", Boolean.FALSE);
<                model = ProcessTrackMateXml.trackmate.getModel();
<                fm1 = model.getFeatureModel();
<                trackIDs1 = model.getTrackModel().trackIDs(true);
<                ProcessTrackMateXml.this.trackTable = new ResultsTable();
<                Iterator var139 = trackIDs1.iterator();
< 
<                while(var139.hasNext()) {
<                   Integer trackID = (Integer)var139.next();
<                   List<Spot> spots = new ArrayList(model.getTrackModel().trackSpots(trackID));
<                   Collections.sort(spots, Spot.frameComparator);
<                   Spot first = (Spot)spots.get(0);
<                   edges = model.getTrackModel().trackEdges(trackID);
<                   double totalDistance = 0.0D;
<                   double maxDistanceSq = Double.NEGATIVE_INFINITY;
<                   double maxDistance = 0.0D;
<                   double dx = 0.0D;
<                   double dy = 0.0D;
<                   double dz = 0.0D;
< 
<                   Spot source;
<                   Spot target;
<                   double vMean;
<                   double confinmentRatio;
<                   for(Iterator var81 = edges.iterator(); var81.hasNext(); dz += target.getDoublePosition(2) - source.getDoublePosition(2)) {
<                      DefaultWeightedEdge edge = (DefaultWeightedEdge)var81.next();
<                      source = model.getTrackModel().getEdgeSource(edge);
<                      target = model.getTrackModel().getEdgeTarget(edge);
<                      vMean = Math.sqrt(source.squareDistanceTo(target));
<                      totalDistance += vMean;
<                      confinmentRatio = first.squareDistanceTo(target);
<                      if (confinmentRatio > maxDistanceSq) {
<                         maxDistanceSq = confinmentRatio;
<                         maxDistance = Math.sqrt(confinmentRatio);
<                      }
< 
<                      dx += target.getDoublePosition(0) - source.getDoublePosition(0);
<                      dy += target.getDoublePosition(1) - source.getDoublePosition(1);
<                   }
< 
<                   double netDistance = fm1.getTrackFeature(trackID, "TRACK_DISPLACEMENT");
<                   double tTotal = fm1.getTrackFeature(trackID, "TRACK_DURATION");
<                   vMean = fm1.getTrackFeature(trackID, "TRACK_MEAN_SPEED");
<                   confinmentRatio = netDistance / totalDistance;
<                   double meanStraightLineSpeed = netDistance / tTotal;
<                   double linearityForwardProgression = meanStraightLineSpeed / vMean;
<                   double angleXY = Math.atan2(dy, dx);
<                   double angleYZ = Math.atan2(dz, dy);
<                   double angleZX = Math.atan2(dx, dz);
<                   Collection<String> trackFeatures = fm1.getTrackFeatures();
<                   ProcessTrackMateXml.this.trackTable.incrementCounter();
<                   ProcessTrackMateXml.this.trackTable.addLabel(model.getTrackModel().name(trackID));
<                   ProcessTrackMateXml.this.trackTable.addValue("TRACK_ID", "" + trackID);
<                   Iterator var100 = trackFeatures.iterator();
< 
<                   while(var100.hasNext()) {
<                      String feature = (String)var100.next();
<                      Double val = fm1.getTrackFeature(trackID, feature);
<                      if (val == null) {
<                         ProcessTrackMateXml.this.trackTable.addValue(feature, "None");
<                      } else if ((Boolean)fm1.getTrackFeatureIsInt().get(feature)) {
<                         ProcessTrackMateXml.this.trackTable.addValue(feature, "" + val.intValue());
<                      } else {
<                         ProcessTrackMateXml.this.trackTable.addValue(feature, val);
<                      }
<                   }
< 
<                   ProcessTrackMateXml.this.trackTable.addValue("TOTAL_DISTANCE_TRAVELED", "" + (double)Math.round(totalDistance * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("MAX_DISTANCE_TRAVELED", "" + (double)Math.round(maxDistance * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("MEAN_STRAIGHT_LINE_SPEED", "" + (double)Math.round(meanStraightLineSpeed * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("LINEARITY_OF_FORWARD_PROGRESSION", "" + (double)Math.round(linearityForwardProgression * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_XY", "" + (double)Math.round(angleXY * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_YZ", "" + (double)Math.round(angleYZ * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_ZX", "" + (double)Math.round(angleZX * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("CONFINMENT_RATIO", "" + (double)Math.round(confinmentRatio * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "");
<                   if (confinmentRatio == 0.0D) {
<                      ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Total-Confined Track");
<                   }
< 
<                   if (confinmentRatio == 1.0D) {
<                      ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Perfectly Straight Track");
<                   }
< 
<                   if (confinmentRatio > 0.0D && confinmentRatio <= 0.5D) {
<                      ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Strongly Confined Track");
<                   }
< 
<                   if (confinmentRatio > 0.05D && confinmentRatio <= 0.25D) {
<                      ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Purely Random Track");
<                   }
< 
<                   if (confinmentRatio > 0.25D && confinmentRatio < 1.0D) {
<                      ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Fairly Straight Track");
<                   }
<                }
< 
<                ProcessTrackMateXml.columnHeadersTrack = ProcessTrackMateXml.this.trackTable.getHeadings();
<                int rowsTrack = ProcessTrackMateXml.this.trackTable.size();
<                List<List<String>> dataListTrack = new ArrayList();
< 
<                for(j = 0; j < rowsTrack; ++j) {
<                   dataListSpot = new ArrayList();
< 
<                   for(jx = 0; jx < ProcessTrackMateXml.columnHeadersTrack.length; ++jx) {
<                      String valuesTrack = ProcessTrackMateXml.this.trackTable.getStringValue(ProcessTrackMateXml.columnHeadersTrack[jx], j);
<                      dataListSpot.add(valuesTrack);
<                   }
< 
<                   dataListTrack.add(dataListSpot);
<                }
< 
<                ProcessTrackMateXml.dataTrack = new String[dataListTrack.size()][];
< 
<                for(j = 0; j < ProcessTrackMateXml.dataTrack.length; ++j) {
<                   ProcessTrackMateXml.dataTrack[j] = new String[((List)dataListTrack.get(j)).size()];
<                }
< 
<                for(j = 0; j < dataListTrack.size(); ++j) {
<                   for(int u = 1; u < ((List)dataListTrack.get(j)).size(); ++u) {
<                      ProcessTrackMateXml.dataTrack[j][u] = (String)((List)dataListTrack.get(j)).get(u);
<                   }
<                }
< 
<                ChooserWizardPanel.createTrackTable();
<                ChooserWizardPanel.tableTrack.addMouseListener(new MouseAdapter() {
<                   public void mouseReleased(MouseEvent e) {
<                      if (ProcessTrackMateXml.selectionModel != null && ChooserWizardPanel.command == "enable" && ChooserWizardPanel.command != null) {
<                         ListSelectionModel lsm = ChooserWizardPanel.tableTrack.getSelectionModel();
<                         int selStart = lsm.getMinSelectionIndex();
<                         int selEnd = lsm.getMaxSelectionIndex();
<                         if (selStart < 0 || selEnd < 0) {
<                            return;
<                         }
< 
<                         int minLine = Math.min(selStart, selEnd);
<                         int maxLine = Math.max(selStart, selEnd);
<                         Set<DefaultWeightedEdge> edges = new HashSet();
<                         Set<Spot> spots = new HashSet();
< 
<                         for(int row = minLine; row <= maxLine; ++row) {
<                            int trackID = Integer.parseInt((String)ChooserWizardPanel.tableTrack.getValueAt(row, 2));
<                            spots.addAll(model.getTrackModel().trackSpots(trackID));
<                            edges.addAll(model.getTrackModel().trackEdges(trackID));
<                         }
< 
<                         ProcessTrackMateXml.selectionModel.clearSelection();
<                         ProcessTrackMateXml.selectionModel.addSpotToSelection(spots);
<                         ProcessTrackMateXml.selectionModel.addEdgeToSelection(edges);
<                      }
< 
<                   }
<                });
<             }
< 
<          }
<       });
<       this.mainProcess.start();
<    }
< 
<    private static void transferCalibration(ImagePlus from, ImagePlus to) {
<       Calibration fc = from.getCalibration();
<       Calibration tc = to.getCalibration();
<       tc.setUnit(fc.getUnit());
<       tc.setTimeUnit(fc.getTimeUnit());
<       tc.frameInterval = fc.frameInterval;
<       double mag = from.getCanvas().getMagnification();
<       tc.pixelWidth = fc.pixelWidth / mag;
<       tc.pixelHeight = fc.pixelHeight / mag;
<       tc.pixelDepth = fc.pixelDepth;
<    }
< 
<    private final TablePanel<Spot> createSpotTableRT(Model model, DisplaySettings ds) {
<       List<Spot> objects = new ArrayList();
<       Iterator var5 = model.getTrackModel().unsortedTrackIDs(true).iterator();
< 
<       while(var5.hasNext()) {
<          Integer trackID = (Integer)var5.next();
<          objects.addAll(model.getTrackModel().trackSpots(trackID));
<       }
< 
<       List<String> features = new ArrayList(model.getFeatureModel().getSpotFeatures());
<       Map<String, String> featureNames = model.getFeatureModel().getSpotFeatureNames();
<       Map<String, String> featureShortNames = model.getFeatureModel().getSpotFeatureShortNames();
<       Map<String, String> featureUnits = new HashMap();
<       Iterator var9 = features.iterator();
< 
<       while(var9.hasNext()) {
<          String feature = (String)var9.next();
<          Dimension dimension = (Dimension)model.getFeatureModel().getSpotFeatureDimensions().get(feature);
<          String units = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
<          featureUnits.put(feature, units);
<       }
< 
<       Map<String, Boolean> isInts = model.getFeatureModel().getSpotFeatureIsInt();
<       Map<String, String> infoTexts = new HashMap();
<       Function<Spot, String> labelGenerator = (spot) -> {
<          return spot.getName();
<       };
<       BiConsumer<Spot, String> labelSetter = (spot, label) -> {
<          spot.setName(label);
<       };
<       String SPOT_ID = "ID";
<       features.add(0, "ID");
<       featureNames.put("ID", "Spot ID");
<       featureShortNames.put("ID", "Spot ID");
<       featureUnits.put("ID", "");
<       isInts.put("ID", Boolean.TRUE);
<       infoTexts.put("ID", "The id of the spot.");
<       String TRACK_ID = "TRACK_ID";
<       features.add(1, "TRACK_ID");
<       featureNames.put("TRACK_ID", "Track ID");
<       featureShortNames.put("TRACK_ID", "Track ID");
<       featureUnits.put("TRACK_ID", "");
<       isInts.put("TRACK_ID", Boolean.TRUE);
<       infoTexts.put("TRACK_ID", "The id of the track this spot belongs to.");
<       BiFunction<Spot, String, Double> featureFun = (spot, featurex) -> {
<          if (featurex.equals("TRACK_ID")) {
<             Integer trackID = model.getTrackModel().trackIDOf(spot);
<             return trackID == null ? null : trackID.doubleValue();
<          } else {
<             return featurex.equals("ID") ? (double)spot.ID() : spot.getFeature(featurex);
<          }
<       };
<       BiConsumer<Spot, Color> colorSetter = (spot, color) -> {
<          spot.putFeature("MANUAL_SPOT_COLOR", (double)color.getRGB());
<       };
<       Supplier<FeatureColorGenerator<Spot>> coloring = () -> {
<          return FeatureUtils.createSpotColorGenerator(model, ds);
<       };
<       TablePanel<Spot> table = new TablePanel(objects, features, featureFun, featureNames, featureShortNames, featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter, "MANUAL_SPOT_COLOR", colorSetter);
<       return table;
<    }
< }
diff -r TrackAnalyzer_/RegressionLE_.java procyon/RegressionLE_.java
1,2d0
< import org.jfree.data.function.Function2D;
< import org.jfree.data.function.LineFunction2D;
3a2,3
> import org.jfree.data.function.LineFunction2D;
> import org.jfree.data.function.Function2D;
6,14c6,18
< public class RegressionLE_ {
<    private static double[][] getXYData(XYDataset data, int series) {
<       int n = data.getItemCount(series);
<       if (n < 1) {
<          throw new IllegalArgumentException("Not enough data.");
<       } else {
<          double[][] result = new double[n][2];
< 
<          for(int i = 0; i < n; ++i) {
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class RegressionLE_
> {
>     private static double[][] getXYData(final XYDataset data, final int series) {
>         final int n = data.getItemCount(series);
>         if (n < 1) {
>             throw new IllegalArgumentException("Not enough data.");
>         }
>         final double[][] result = new double[n][2];
>         for (int i = 0; i < n; ++i) {
17,36c21,37
<          }
< 
<          return result;
<       }
<    }
< 
<    public static double[] getOLSRegression(double[][] data) {
<       int n = data.length;
<       if (n < 2) {
<          throw new IllegalArgumentException("LinearRegression: Not enough data.");
<       } else {
<          double sumX = 0.0D;
<          double sumY = 0.0D;
<          double sumXX = 0.0D;
<          double sumYY = 0.0D;
<          double sumXY = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             double x = data[i][0];
<             double y = data[i][1];
---
>         }
>         return result;
>     }
>     
>     public static double[] getOLSRegression(final double[][] data) {
>         final int n = data.length;
>         if (n < 2) {
>             throw new IllegalArgumentException("LinearRegression: Not enough data.");
>         }
>         double sumX = 0.0;
>         double sumY = 0.0;
>         double sumXX = 0.0;
>         double sumYY = 0.0;
>         double sumXY = 0.0;
>         for (int i = 0; i < n; ++i) {
>             final double x = data[i][0];
>             final double y = data[i][1];
39c40
<             double xx = x * x;
---
>             final double xx = x * x;
41c42
<             double yy = y * y;
---
>             final double yy = y * y;
43c44
<             double xy = x * y;
---
>             final double xy = x * y;
45,69c46,53
<          }
< 
<          double sxx = sumXX - sumX * sumX / (double)n;
<          double sxy = sumXY - sumX * sumY / (double)n;
<          double xbar = sumX / (double)n;
<          double ybar = sumY / (double)n;
<          double tmp1 = (double)n * sumXX - sumX * sumX;
<          double tmp2 = (double)n * sumYY - sumY * sumY;
<          if (!(tmp1 < 0.0D) && !(tmp2 < 0.0D)) {
<             double numerator = (double)n * sumXY - sumX * sumY;
<             double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
<             if (denominator == 0.0D) {
<                throw new IllegalArgumentException("LinearRegression: Data would cause divide by zero error.");
<             } else {
<                double r = numerator / denominator;
<                double[] result = new double[]{0.0D, 0.0D, r * r};
<                if (sxx < 0.0D) {
<                   throw new IllegalArgumentException("LinearRegression: Data would cause divide by zero error.");
<                } else {
<                   result[1] = sxy / sxx;
<                   result[0] = ybar - result[1] * xbar;
<                   return result;
<                }
<             }
<          } else {
---
>         }
>         final double sxx = sumXX - sumX * sumX / n;
>         final double sxy = sumXY - sumX * sumY / n;
>         final double xbar = sumX / n;
>         final double ybar = sumY / n;
>         final double tmp1 = n * sumXX - sumX * sumX;
>         final double tmp2 = n * sumYY - sumY * sumY;
>         if (tmp1 < 0.0 || tmp2 < 0.0) {
71,92c55,87
<          }
<       }
<    }
< 
<    public static double[] getOLSRegression(XYDataset data, int series) {
<       return getOLSRegression(getXYData(data, series));
<    }
< 
<    public static double[] getPowerRegression(double[][] data) {
<       int n = data.length;
<       if (n < 2) {
<          throw new IllegalArgumentException("Not enough data.");
<       } else {
<          double sumX = 0.0D;
<          double sumY = 0.0D;
<          double sumXX = 0.0D;
<          double sumYY = 0.0D;
<          double sumXY = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             if (!(data[i][0] > 0.0D) || !(data[i][1] > 0.0D)) {
<                throw new IllegalArgumentException("PowerRegression: X & Y Data must be greater than zero.");
---
>         }
>         final double numerator = n * sumXY - sumX * sumY;
>         final double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
>         if (denominator == 0.0) {
>             throw new IllegalArgumentException("LinearRegression: Data would cause divide by zero error.");
>         }
>         final double r = numerator / denominator;
>         final double[] result = { 0.0, 0.0, r * r };
>         if (sxx < 0.0) {
>             throw new IllegalArgumentException("LinearRegression: Data would cause divide by zero error.");
>         }
>         result[1] = sxy / sxx;
>         result[0] = ybar - result[1] * xbar;
>         return result;
>     }
>     
>     public static double[] getOLSRegression(final XYDataset data, final int series) {
>         return getOLSRegression(getXYData(data, series));
>     }
>     
>     public static double[] getPowerRegression(final double[][] data) {
>         final int n = data.length;
>         if (n < 2) {
>             throw new IllegalArgumentException("Not enough data.");
>         }
>         double sumX = 0.0;
>         double sumY = 0.0;
>         double sumXX = 0.0;
>         double sumYY = 0.0;
>         double sumXY = 0.0;
>         for (int i = 0; i < n; ++i) {
>             if (data[i][0] <= 0.0 || data[i][1] <= 0.0) {
>                 throw new IllegalArgumentException("PowerRegression: X & Y Data must be greater than zero.");
94,96c89,90
< 
<             double x = Math.log(data[i][0]);
<             double y = Math.log(data[i][1]);
---
>             final double x = Math.log(data[i][0]);
>             final double y = Math.log(data[i][1]);
99c93
<             double xx = x * x;
---
>             final double xx = x * x;
101c95
<             double yy = y * y;
---
>             final double yy = y * y;
103c97
<             double xy = x * y;
---
>             final double xy = x * y;
105,129c99,106
<          }
< 
<          double sxx = sumXX - sumX * sumX / (double)n;
<          double sxy = sumXY - sumX * sumY / (double)n;
<          double xbar = sumX / (double)n;
<          double ybar = sumY / (double)n;
<          double tmp1 = (double)n * sumXX - sumX * sumX;
<          double tmp2 = (double)n * sumYY - sumY * sumY;
<          if (!(tmp1 < 0.0D) && !(tmp2 < 0.0D)) {
<             double numerator = (double)n * sumXY - sumX * sumY;
<             double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
<             if (denominator == 0.0D) {
<                throw new IllegalArgumentException("PowerRegression: Data would cause divide by zero error.");
<             } else {
<                double r = numerator / denominator;
<                double[] result = new double[]{0.0D, 0.0D, r * r};
<                if (sxx < 0.0D) {
<                   throw new IllegalArgumentException("PowerRegression: Data would cause divide by zero error.");
<                } else {
<                   result[1] = sxy / sxx;
<                   result[0] = Math.pow(Math.exp(1.0D), ybar - result[1] * xbar);
<                   return result;
<                }
<             }
<          } else {
---
>         }
>         final double sxx = sumXX - sumX * sumX / n;
>         final double sxy = sumXY - sumX * sumY / n;
>         final double xbar = sumX / n;
>         final double ybar = sumY / n;
>         final double tmp1 = n * sumXX - sumX * sumX;
>         final double tmp2 = n * sumYY - sumY * sumY;
>         if (tmp1 < 0.0 || tmp2 < 0.0) {
131,152c108,140
<          }
<       }
<    }
< 
<    public static double[] getPowerRegression(XYDataset data, int series) {
<       return getPowerRegression(getXYData(data, series));
<    }
< 
<    public static double[] getLogarithmicRegression(double[][] data) {
<       int n = data.length;
<       if (n < 2) {
<          throw new IllegalArgumentException("LogarithmicRegression: Not enough data.");
<       } else {
<          double sumX = 0.0D;
<          double sumY = 0.0D;
<          double sumXX = 0.0D;
<          double sumYY = 0.0D;
<          double sumXY = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             if (!(data[i][0] > 0.0D)) {
<                throw new IllegalArgumentException("LogarithmicRegression: X Data must be greater than zero.");
---
>         }
>         final double numerator = n * sumXY - sumX * sumY;
>         final double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
>         if (denominator == 0.0) {
>             throw new IllegalArgumentException("PowerRegression: Data would cause divide by zero error.");
>         }
>         final double r = numerator / denominator;
>         final double[] result = { 0.0, 0.0, r * r };
>         if (sxx < 0.0) {
>             throw new IllegalArgumentException("PowerRegression: Data would cause divide by zero error.");
>         }
>         result[1] = sxy / sxx;
>         result[0] = Math.pow(Math.exp(1.0), ybar - result[1] * xbar);
>         return result;
>     }
>     
>     public static double[] getPowerRegression(final XYDataset data, final int series) {
>         return getPowerRegression(getXYData(data, series));
>     }
>     
>     public static double[] getLogarithmicRegression(final double[][] data) {
>         final int n = data.length;
>         if (n < 2) {
>             throw new IllegalArgumentException("LogarithmicRegression: Not enough data.");
>         }
>         double sumX = 0.0;
>         double sumY = 0.0;
>         double sumXX = 0.0;
>         double sumYY = 0.0;
>         double sumXY = 0.0;
>         for (int i = 0; i < n; ++i) {
>             if (data[i][0] <= 0.0) {
>                 throw new IllegalArgumentException("LogarithmicRegression: X Data must be greater than zero.");
154,156c142,143
< 
<             double x = Math.log(data[i][0]);
<             double y = data[i][1];
---
>             final double x = Math.log(data[i][0]);
>             final double y = data[i][1];
159c146
<             double xx = x * x;
---
>             final double xx = x * x;
161c148
<             double yy = y * y;
---
>             final double yy = y * y;
163c150
<             double xy = x * y;
---
>             final double xy = x * y;
165,189c152,159
<          }
< 
<          double sxx = sumXX - sumX * sumX / (double)n;
<          double sxy = sumXY - sumX * sumY / (double)n;
<          double xbar = sumX / (double)n;
<          double ybar = sumY / (double)n;
<          double tmp1 = (double)n * sumXX - sumX * sumX;
<          double tmp2 = (double)n * sumYY - sumY * sumY;
<          if (!(tmp1 < 0.0D) && !(tmp2 < 0.0D)) {
<             double numerator = (double)n * sumXY - sumX * sumY;
<             double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
<             if (denominator == 0.0D) {
<                throw new IllegalArgumentException("LogarithmicRegression: Data would cause divide by zero error.");
<             } else {
<                double r = numerator / denominator;
<                double[] result = new double[]{0.0D, 0.0D, r * r};
<                if (sxx < 0.0D) {
<                   throw new IllegalArgumentException("LogarithmicRegression: Data would cause divide by zero error.");
<                } else {
<                   result[1] = sxy / sxx;
<                   result[0] = ybar - result[1] * xbar;
<                   return result;
<                }
<             }
<          } else {
---
>         }
>         final double sxx = sumXX - sumX * sumX / n;
>         final double sxy = sumXY - sumX * sumY / n;
>         final double xbar = sumX / n;
>         final double ybar = sumY / n;
>         final double tmp1 = n * sumXX - sumX * sumX;
>         final double tmp2 = n * sumYY - sumY * sumY;
>         if (tmp1 < 0.0 || tmp2 < 0.0) {
191,213c161,194
<          }
<       }
<    }
< 
<    public static double[] getLogarithmicRegression(XYDataset data, int series) {
<       return getLogarithmicRegression(getXYData(data, series));
<    }
< 
<    public static double[] getExponentialRegression(double[][] data) {
<       int n = data.length;
<       if (n < 2) {
<          throw new IllegalArgumentException("ExponentialRegression: Not enough data.");
<       } else {
<          double sumX = 0.0D;
<          double sumY = 0.0D;
<          double sumXX = 0.0D;
<          double sumYY = 0.0D;
<          double sumXY = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             double x = data[i][0];
<             if (!(data[i][1] > 0.0D)) {
<                throw new IllegalArgumentException("ExponentialRegression: Y Data must be greater than zero.");
---
>         }
>         final double numerator = n * sumXY - sumX * sumY;
>         final double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
>         if (denominator == 0.0) {
>             throw new IllegalArgumentException("LogarithmicRegression: Data would cause divide by zero error.");
>         }
>         final double r = numerator / denominator;
>         final double[] result = { 0.0, 0.0, r * r };
>         if (sxx < 0.0) {
>             throw new IllegalArgumentException("LogarithmicRegression: Data would cause divide by zero error.");
>         }
>         result[1] = sxy / sxx;
>         result[0] = ybar - result[1] * xbar;
>         return result;
>     }
>     
>     public static double[] getLogarithmicRegression(final XYDataset data, final int series) {
>         return getLogarithmicRegression(getXYData(data, series));
>     }
>     
>     public static double[] getExponentialRegression(final double[][] data) {
>         final int n = data.length;
>         if (n < 2) {
>             throw new IllegalArgumentException("ExponentialRegression: Not enough data.");
>         }
>         double sumX = 0.0;
>         double sumY = 0.0;
>         double sumXX = 0.0;
>         double sumYY = 0.0;
>         double sumXY = 0.0;
>         for (int i = 0; i < n; ++i) {
>             final double x = data[i][0];
>             if (data[i][1] <= 0.0) {
>                 throw new IllegalArgumentException("ExponentialRegression: Y Data must be greater than zero.");
215,216c196
< 
<             double y = Math.log(data[i][1]);
---
>             final double y = Math.log(data[i][1]);
219c199
<             double xx = x * x;
---
>             final double xx = x * x;
221c201
<             double yy = y * y;
---
>             final double yy = y * y;
223c203
<             double xy = x * y;
---
>             final double xy = x * y;
225,249c205,212
<          }
< 
<          double sxx = sumXX - sumX * sumX / (double)n;
<          double sxy = sumXY - sumX * sumY / (double)n;
<          double xbar = sumX / (double)n;
<          double ybar = sumY / (double)n;
<          double tmp1 = (double)n * sumXX - sumX * sumX;
<          double tmp2 = (double)n * sumYY - sumY * sumY;
<          if (!(tmp1 < 0.0D) && !(tmp2 < 0.0D)) {
<             double numerator = (double)n * sumXY - sumX * sumY;
<             double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
<             if (denominator == 0.0D) {
<                throw new IllegalArgumentException("ExponentialRegression: Data would cause divide by zero error.");
<             } else {
<                double r = numerator / denominator;
<                double[] result = new double[]{0.0D, 0.0D, r * r};
<                if (sxx < 0.0D) {
<                   throw new IllegalArgumentException("ExponentialRegression: Data would cause divide by zero error.");
<                } else {
<                   result[1] = sxy / sxx;
<                   result[0] = Math.exp(ybar - result[1] * xbar);
<                   return result;
<                }
<             }
<          } else {
---
>         }
>         final double sxx = sumXX - sumX * sumX / n;
>         final double sxy = sumXY - sumX * sumY / n;
>         final double xbar = sumX / n;
>         final double ybar = sumY / n;
>         final double tmp1 = n * sumXX - sumX * sumX;
>         final double tmp2 = n * sumYY - sumY * sumY;
>         if (tmp1 < 0.0 || tmp2 < 0.0) {
251,296c214,240
<          }
<       }
<    }
< 
<    public static double[] getExponentialRegression(XYDataset data, int series) {
<       return getExponentialRegression(getXYData(data, series));
<    }
< 
<    public static Function2D getBestRegressionFunction(double[][] data) {
<       Function2D retVal = null;
<       double r2 = 0.0D;
<       Object var4 = null;
< 
<       double[] coefficients;
<       try {
<          coefficients = getOLSRegression(data);
<          retVal = new LineFunction2D(coefficients[0], coefficients[1]);
<          r2 = coefficients[2];
<       } catch (Exception var9) {
<          System.err.println(var9.getMessage());
<       }
< 
<       try {
<          coefficients = getPowerRegression(data);
<          if (coefficients[2] > r2) {
<             retVal = new PowerFunction2D(coefficients[0], coefficients[1]);
<             r2 = coefficients[2];
<          }
<       } catch (Exception var8) {
<          System.err.println(var8.getMessage());
<       }
< 
<       try {
<          coefficients = getLogarithmicRegression(data);
<          if (coefficients[2] > r2) {
<             retVal = new LogarithmicFunction2D(coefficients[0], coefficients[1]);
<             r2 = coefficients[2];
<          }
<       } catch (Exception var7) {
<          System.err.println(var7.getMessage());
<       }
< 
<       try {
<          coefficients = getExponentialRegression(data);
<          if (coefficients[2] > r2) {
<             retVal = new ExponentialFunction2D(coefficients[0], coefficients[1]);
---
>         }
>         final double numerator = n * sumXY - sumX * sumY;
>         final double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
>         if (denominator == 0.0) {
>             throw new IllegalArgumentException("ExponentialRegression: Data would cause divide by zero error.");
>         }
>         final double r = numerator / denominator;
>         final double[] result = { 0.0, 0.0, r * r };
>         if (sxx < 0.0) {
>             throw new IllegalArgumentException("ExponentialRegression: Data would cause divide by zero error.");
>         }
>         result[1] = sxy / sxx;
>         result[0] = Math.exp(ybar - result[1] * xbar);
>         return result;
>     }
>     
>     public static double[] getExponentialRegression(final XYDataset data, final int series) {
>         return getExponentialRegression(getXYData(data, series));
>     }
>     
>     public static Function2D getBestRegressionFunction(final double[][] data) {
>         Function2D retVal = null;
>         double r2 = 0.0;
>         double[] coefficients = null;
>         try {
>             coefficients = getOLSRegression(data);
>             retVal = (Function2D)new LineFunction2D(coefficients[0], coefficients[1]);
298,312c242,284
<          }
<       } catch (Exception var6) {
<          System.err.println(var6.getMessage());
<       }
< 
<       if (retVal == null) {
<          throw new IllegalArgumentException("No regression functions were found with current dataset.");
<       } else {
<          return (Function2D)retVal;
<       }
<    }
< 
<    public static Function2D getBestRegressionFunction(XYDataset data, int series) {
<       return getBestRegressionFunction(getXYData(data, series));
<    }
---
>         }
>         catch (Exception e) {
>             System.err.println(e.getMessage());
>         }
>         try {
>             coefficients = getPowerRegression(data);
>             if (coefficients[2] > r2) {
>                 retVal = (Function2D)new PowerFunction2D(coefficients[0], coefficients[1]);
>                 r2 = coefficients[2];
>             }
>         }
>         catch (Exception e) {
>             System.err.println(e.getMessage());
>         }
>         try {
>             coefficients = getLogarithmicRegression(data);
>             if (coefficients[2] > r2) {
>                 retVal = (Function2D)new LogarithmicFunction2D(coefficients[0], coefficients[1]);
>                 r2 = coefficients[2];
>             }
>         }
>         catch (Exception e) {
>             System.err.println(e.getMessage());
>         }
>         try {
>             coefficients = getExponentialRegression(data);
>             if (coefficients[2] > r2) {
>                 retVal = (Function2D)new ExponentialFunction2D(coefficients[0], coefficients[1]);
>                 r2 = coefficients[2];
>             }
>         }
>         catch (Exception e) {
>             System.err.println(e.getMessage());
>         }
>         if (retVal == null) {
>             throw new IllegalArgumentException("No regression functions were found with current dataset.");
>         }
>         return retVal;
>     }
>     
>     public static Function2D getBestRegressionFunction(final XYDataset data, final int series) {
>         return getBestRegressionFunction(getXYData(data, series));
>     }
diff -r TrackAnalyzer_/Renderer.java procyon/Renderer.java
6,14c6,8
< public class Renderer extends DefaultTableCellRenderer {
<    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
<       Component comp = this.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
<       value = table.getModel().getValueAt(row, 0);
<       if (value.equals(true)) {
<          comp.setBackground(Color.LIGHT_GRAY);
<       } else {
<          comp.setForeground(Color.white);
<       }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
16,17c10,23
<       return comp;
<    }
---
> public class Renderer extends DefaultTableCellRenderer
> {
>     @Override
>     public Component getTableCellRendererComponent(final JTable table, Object value, final boolean isSelected, final boolean hasFocus, final int row, final int column) {
>         final Component comp = this.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
>         value = table.getModel().getValueAt(row, 0);
>         if (value.equals(true)) {
>             comp.setBackground(Color.LIGHT_GRAY);
>         }
>         else {
>             comp.setForeground(Color.white);
>         }
>         return comp;
>     }
diff -r TrackAnalyzer_/RollingBall.java procyon/RollingBall.java
1,49c1,54
< class RollingBall {
<    float[] data;
<    int width;
<    int shrinkFactor;
< 
<    RollingBall(double radius) {
<       byte arcTrimPer;
<       if (radius <= 10.0D) {
<          this.shrinkFactor = 1;
<          arcTrimPer = 24;
<       } else if (radius <= 30.0D) {
<          this.shrinkFactor = 2;
<          arcTrimPer = 24;
<       } else if (radius <= 100.0D) {
<          this.shrinkFactor = 4;
<          arcTrimPer = 32;
<       } else {
<          this.shrinkFactor = 8;
<          arcTrimPer = 40;
<       }
< 
<       this.buildRollingBall(radius, arcTrimPer);
<    }
< 
<    void buildRollingBall(double ballradius, int arcTrimPer) {
<       this.shrinkFactor = this.shrinkFactor;
<       double smallballradius = ballradius / (double)this.shrinkFactor;
<       if (smallballradius < 1.0D) {
<          smallballradius = 1.0D;
<       }
< 
<       double rsquare = smallballradius * smallballradius;
<       int xtrim = (int)((double)arcTrimPer * smallballradius) / 100;
<       int halfWidth = (int)Math.round(smallballradius - (double)xtrim);
<       this.width = 2 * halfWidth + 1;
<       this.data = new float[this.width * this.width];
<       int y = 0;
< 
<       for(int p = 0; y < this.width; ++y) {
<          for(int x = 0; x < this.width; ++p) {
<             int xval = x - halfWidth;
<             int yval = y - halfWidth;
<             double temp = rsquare - (double)(xval * xval) - (double)(yval * yval);
<             this.data[p] = temp > 0.0D ? (float)Math.sqrt(temp) : 0.0F;
<             ++x;
<          }
<       }
< 
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> class RollingBall
> {
>     float[] data;
>     int width;
>     int shrinkFactor;
>     
>     RollingBall(final double radius) {
>         int arcTrimPer;
>         if (radius <= 10.0) {
>             this.shrinkFactor = 1;
>             arcTrimPer = 24;
>         }
>         else if (radius <= 30.0) {
>             this.shrinkFactor = 2;
>             arcTrimPer = 24;
>         }
>         else if (radius <= 100.0) {
>             this.shrinkFactor = 4;
>             arcTrimPer = 32;
>         }
>         else {
>             this.shrinkFactor = 8;
>             arcTrimPer = 40;
>         }
>         this.buildRollingBall(radius, arcTrimPer);
>     }
>     
>     void buildRollingBall(final double ballradius, final int arcTrimPer) {
>         this.shrinkFactor = this.shrinkFactor;
>         double smallballradius = ballradius / this.shrinkFactor;
>         if (smallballradius < 1.0) {
>             smallballradius = 1.0;
>         }
>         final double rsquare = smallballradius * smallballradius;
>         final int xtrim = (int)(arcTrimPer * smallballradius) / 100;
>         final int halfWidth = (int)Math.round(smallballradius - xtrim);
>         this.width = 2 * halfWidth + 1;
>         this.data = new float[this.width * this.width];
>         int y = 0;
>         int p = 0;
>         while (y < this.width) {
>             for (int x = 0; x < this.width; ++x, ++p) {
>                 final int xval = x - halfWidth;
>                 final int yval = y - halfWidth;
>                 final double temp = rsquare - xval * xval - yval * yval;
>                 this.data[p] = ((temp > 0.0) ? ((float)Math.sqrt(temp)) : 0.0f);
>             }
>             ++y;
>         }
>     }
diff -r TrackAnalyzer_/SimpleHeaderRenderer.java procyon/SimpleHeaderRenderer.java
1d0
< import java.awt.Color;
3,5d1
< import java.awt.Font;
< import javax.swing.BorderFactory;
< import javax.swing.JLabel;
6a3,5
> import javax.swing.BorderFactory;
> import java.awt.Color;
> import java.awt.Font;
7a7
> import javax.swing.JLabel;
9,16c9,11
< public class SimpleHeaderRenderer extends JLabel implements TableCellRenderer {
<    public SimpleHeaderRenderer() {
<       this.setFont(new Font("SansSerif", 1, 12));
<       this.setForeground(Color.DARK_GRAY);
<       this.setBorder(BorderFactory.createEtchedBorder());
<       this.setBackground(new Color(230, 250, 240, 50));
<       this.setHorizontalAlignment(0);
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
18,21c13,27
<    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
<       this.setText(value.toString());
<       return this;
<    }
---
> public class SimpleHeaderRenderer extends JLabel implements TableCellRenderer
> {
>     public SimpleHeaderRenderer() {
>         this.setFont(new Font("SansSerif", 1, 12));
>         this.setForeground(Color.DARK_GRAY);
>         this.setBorder(BorderFactory.createEtchedBorder());
>         this.setBackground(new Color(230, 250, 240, 50));
>         this.setHorizontalAlignment(0);
>     }
>     
>     @Override
>     public Component getTableCellRendererComponent(final JTable table, final Object value, final boolean isSelected, final boolean hasFocus, final int row, final int column) {
>         this.setText(value.toString());
>         return this;
>     }
diff -r TrackAnalyzer_/SLTResultsTableVersion.java procyon/SLTResultsTableVersion.java
1c1,5
< import fiji.plugin.trackmate.Dimension;
---
> import net.imglib2.RealLocalizable;
> import org.jgrapht.graph.DefaultWeightedEdge;
> import fiji.plugin.trackmate.util.ModelTools;
> import java.util.Iterator;
> import java.util.Set;
4c8,10
< import fiji.plugin.trackmate.SelectionModel;
---
> import java.util.Comparator;
> import java.util.Collections;
> import java.util.Collection;
7,12d12
< import fiji.plugin.trackmate.util.ModelTools;
< import ij.measure.ResultsTable;
< import java.util.ArrayList;
< import java.util.Collection;
< import java.util.Collections;
< import java.util.Comparator;
14,15c14,15
< import java.util.Iterator;
< import java.util.List;
---
> import java.util.ArrayList;
> import fiji.plugin.trackmate.Dimension;
17,73c17,19
< import java.util.Set;
< import org.jgrapht.graph.DefaultWeightedEdge;
< 
< public class SLTResultsTableVersion {
<    public static final String NAME = "Export statistics to tables";
<    public static final String KEY = "EXPORT_STATS_TO_IJ";
<    public static final String INFO_TEXT = "<html>Compute and export all statistics to 3 ImageJ results table. Statistisc are separated in features computed for: <ol> \t<li> spots in filtered tracks; \t<li> links between those spots; \t<li> filtered tracks. </ol> For tracks and links, they are recalculated prior to exporting. Note that spots and links that are not in a filtered tracks are not part of this export.</html>";
<    private static final String SPOT_TABLE_NAME = "Spots in tracks statistics";
<    private static final String EDGE_TABLE_NAME = "Links in tracks statistics";
<    private static final String TRACK_TABLE_NAME = "Track statistics";
<    private static final String ID_COLUMN = "ID";
<    private static final String TRACK_ID_COLUMN = "TRACK_ID";
<    private ResultsTable spotTable;
<    private ResultsTable edgeTable;
<    private ResultsTable trackTable;
<    private final SelectionModel selectionModel;
<    public static final String KEYLINEAR = "Linear track analysis";
<    public static final String TRACK_TOTAL_DISTANCE_TRAVELED = "TOTAL_DISTANCE_TRAVELED";
<    public static final String TRACK_MAX_DISTANCE_TRAVELED = "MAX_DISTANCE_TRAVELED";
<    public static final String TRACK_CONFINMENT_RATIO = "CONFINMENT_RATIO";
<    public static final String TRACK_MEAN_STRAIGHT_LINE_SPEED = "MEAN_STRAIGHT_LINE_SPEED";
<    public static final String TRACK_LINEARITY_OF_FORWARD_PROGRESSION = "LINEARITY_OF_FORWARD_PROGRESSION";
<    public static final String TOTAL_ABSOLUTE_ANGLE_XY = "TOTAL_ABSOLUTE_ANGLE_XY";
<    public static final String TOTAL_ABSOLUTE_ANGLE_YZ = "TOTAL_ABSOLUTE_ANGLE_YZ";
<    public static final String TOTAL_ABSOLUTE_ANGLE_ZX = "TOTAL_ABSOLUTE_ANGLE_ZX";
<    public static final List<String> FEATURES = new ArrayList(9);
<    public static final Map<String, String> FEATURE_NAMES = new HashMap(9);
<    public static final Map<String, String> FEATURE_SHORT_NAMES = new HashMap(9);
<    public static final Map<String, Dimension> FEATURE_DIMENSIONS = new HashMap(9);
<    public static final Map<String, Boolean> IS_INT = new HashMap(9);
< 
<    public SLTResultsTableVersion(SelectionModel selectionModel) {
<       this.selectionModel = selectionModel;
<    }
< 
<    public ResultsTable executeSpot(TrackMate trackmate) {
<       Model model = trackmate.getModel();
<       FeatureModel fm = model.getFeatureModel();
<       Set<Integer> trackIDs = model.getTrackModel().trackIDs(true);
<       Collection<String> spotFeatures = trackmate.getModel().getFeatureModel().getSpotFeatures();
<       this.spotTable = new ResultsTable();
<       Iterator var7 = trackIDs.iterator();
< 
<       while(var7.hasNext()) {
<          Integer trackID = (Integer)var7.next();
<          Set<Spot> track = model.getTrackModel().trackSpots(trackID);
<          List<Spot> sortedTrack = new ArrayList(track);
<          Collections.sort(sortedTrack, Spot.frameComparator);
<          Iterator var11 = sortedTrack.iterator();
< 
<          while(var11.hasNext()) {
<             Spot spot = (Spot)var11.next();
<             this.spotTable.incrementCounter();
<             this.spotTable.addLabel(spot.getName());
<             this.spotTable.addValue("ID", "" + spot.ID());
<             this.spotTable.addValue("TRACK_ID", "" + trackID);
<             Iterator var13 = spotFeatures.iterator();
---
> import java.util.List;
> import fiji.plugin.trackmate.SelectionModel;
> import ij.measure.ResultsTable;
75,84c21,92
<             while(var13.hasNext()) {
<                String feature = (String)var13.next();
<                Double val = spot.getFeature(feature);
<                if (val == null) {
<                   this.spotTable.addValue(feature, "None");
<                } else if ((Boolean)fm.getSpotFeatureIsInt().get(feature)) {
<                   this.spotTable.addValue(feature, "" + val.intValue());
<                } else {
<                   this.spotTable.addValue(feature, val);
<                }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class SLTResultsTableVersion
> {
>     public static final String NAME = "Export statistics to tables";
>     public static final String KEY = "EXPORT_STATS_TO_IJ";
>     public static final String INFO_TEXT = "<html>Compute and export all statistics to 3 ImageJ results table. Statistisc are separated in features computed for: <ol> \t<li> spots in filtered tracks; \t<li> links between those spots; \t<li> filtered tracks. </ol> For tracks and links, they are recalculated prior to exporting. Note that spots and links that are not in a filtered tracks are not part of this export.</html>";
>     private static final String SPOT_TABLE_NAME = "Spots in tracks statistics";
>     private static final String EDGE_TABLE_NAME = "Links in tracks statistics";
>     private static final String TRACK_TABLE_NAME = "Track statistics";
>     private static final String ID_COLUMN = "ID";
>     private static final String TRACK_ID_COLUMN = "TRACK_ID";
>     private ResultsTable spotTable;
>     private ResultsTable edgeTable;
>     private ResultsTable trackTable;
>     private final SelectionModel selectionModel;
>     public static final String KEYLINEAR = "Linear track analysis";
>     public static final String TRACK_TOTAL_DISTANCE_TRAVELED = "TOTAL_DISTANCE_TRAVELED";
>     public static final String TRACK_MAX_DISTANCE_TRAVELED = "MAX_DISTANCE_TRAVELED";
>     public static final String TRACK_CONFINMENT_RATIO = "CONFINMENT_RATIO";
>     public static final String TRACK_MEAN_STRAIGHT_LINE_SPEED = "MEAN_STRAIGHT_LINE_SPEED";
>     public static final String TRACK_LINEARITY_OF_FORWARD_PROGRESSION = "LINEARITY_OF_FORWARD_PROGRESSION";
>     public static final String TOTAL_ABSOLUTE_ANGLE_XY = "TOTAL_ABSOLUTE_ANGLE_XY";
>     public static final String TOTAL_ABSOLUTE_ANGLE_YZ = "TOTAL_ABSOLUTE_ANGLE_YZ";
>     public static final String TOTAL_ABSOLUTE_ANGLE_ZX = "TOTAL_ABSOLUTE_ANGLE_ZX";
>     public static final List<String> FEATURES;
>     public static final Map<String, String> FEATURE_NAMES;
>     public static final Map<String, String> FEATURE_SHORT_NAMES;
>     public static final Map<String, Dimension> FEATURE_DIMENSIONS;
>     public static final Map<String, Boolean> IS_INT;
>     
>     static {
>         FEATURES = new ArrayList<String>(9);
>         FEATURE_NAMES = new HashMap<String, String>(9);
>         FEATURE_SHORT_NAMES = new HashMap<String, String>(9);
>         FEATURE_DIMENSIONS = new HashMap<String, Dimension>(9);
>         IS_INT = new HashMap<String, Boolean>(9);
>     }
>     
>     public SLTResultsTableVersion(final SelectionModel selectionModel) {
>         this.selectionModel = selectionModel;
>     }
>     
>     public ResultsTable executeSpot(final TrackMate trackmate) {
>         final Model model = trackmate.getModel();
>         final FeatureModel fm = model.getFeatureModel();
>         final Set<Integer> trackIDs = (Set<Integer>)model.getTrackModel().trackIDs(true);
>         final Collection<String> spotFeatures = (Collection<String>)trackmate.getModel().getFeatureModel().getSpotFeatures();
>         this.spotTable = new ResultsTable();
>         for (final Integer trackID : trackIDs) {
>             final Set<Spot> track = (Set<Spot>)model.getTrackModel().trackSpots(trackID);
>             final List<Spot> sortedTrack = new ArrayList<Spot>(track);
>             Collections.<Spot>sort(sortedTrack, Spot.frameComparator);
>             for (final Spot spot : sortedTrack) {
>                 this.spotTable.incrementCounter();
>                 this.spotTable.addLabel(spot.getName());
>                 this.spotTable.addValue("ID", new StringBuilder().append(spot.ID()).toString());
>                 this.spotTable.addValue("TRACK_ID", new StringBuilder().append((int)trackID).toString());
>                 for (final String feature : spotFeatures) {
>                     final Double val = spot.getFeature(feature);
>                     if (val == null) {
>                         this.spotTable.addValue(feature, "None");
>                     }
>                     else if (fm.getSpotFeatureIsInt().get(feature)) {
>                         this.spotTable.addValue(feature, new StringBuilder().append(val.intValue()).toString());
>                     }
>                     else {
>                         this.spotTable.addValue(feature, (double)val);
>                     }
>                 }
86,133c94,110
<          }
<       }
< 
<       return this.spotTable;
<    }
< 
<    public ResultsTable executeLink(TrackMate trackmate) {
<       Model model = trackmate.getModel();
<       FeatureModel fm = model.getFeatureModel();
<       Set<Integer> trackIDs = model.getTrackModel().trackIDs(true);
<       Collection<String> edgeFeatures = fm.getEdgeFeatures();
<       this.edgeTable = new ResultsTable();
<       Iterator var7 = trackIDs.iterator();
< 
<       while(var7.hasNext()) {
<          Integer trackID = (Integer)var7.next();
<          Comparator<DefaultWeightedEdge> edgeTimeComparator = ModelTools.featureEdgeComparator("EDGE_TIME", fm);
<          Comparator<DefaultWeightedEdge> edgeSourceSpotTimeComparator = new SLTResultsTableVersion.EdgeSourceSpotFrameComparator(model);
<          Set<DefaultWeightedEdge> track = model.getTrackModel().trackEdges(trackID);
<          List<DefaultWeightedEdge> sortedTrack = new ArrayList(track);
<          if (model.getFeatureModel().getEdgeFeatures().contains("Edge location")) {
<             Collections.sort(sortedTrack, edgeTimeComparator);
<          } else {
<             Collections.sort(sortedTrack, edgeSourceSpotTimeComparator);
<          }
< 
<          Iterator var13 = sortedTrack.iterator();
< 
<          while(var13.hasNext()) {
<             DefaultWeightedEdge edge = (DefaultWeightedEdge)var13.next();
<             this.edgeTable.incrementCounter();
<             this.edgeTable.addLabel(edge.toString());
<             this.edgeTable.addValue("TRACK_ID", "" + trackID);
<             Iterator var15 = edgeFeatures.iterator();
< 
<             while(var15.hasNext()) {
<                String feature = (String)var15.next();
<                Object o = fm.getEdgeFeature(edge, feature);
<                if (!(o instanceof String)) {
<                   Number d = (Number)o;
<                   if (d == null) {
<                      this.edgeTable.addValue(feature, "None");
<                   } else if ((Boolean)fm.getEdgeFeatureIsInt().get(feature)) {
<                      this.edgeTable.addValue(feature, "" + d.intValue());
<                   } else {
<                      this.edgeTable.addValue(feature, d.doubleValue());
<                   }
<                }
---
>         }
>         return this.spotTable;
>     }
>     
>     public ResultsTable executeLink(final TrackMate trackmate) {
>         final Model model = trackmate.getModel();
>         final FeatureModel fm = model.getFeatureModel();
>         final Set<Integer> trackIDs = (Set<Integer>)model.getTrackModel().trackIDs(true);
>         final Collection<String> edgeFeatures = (Collection<String>)fm.getEdgeFeatures();
>         this.edgeTable = new ResultsTable();
>         for (final Integer trackID : trackIDs) {
>             final Comparator<DefaultWeightedEdge> edgeTimeComparator = (Comparator<DefaultWeightedEdge>)ModelTools.featureEdgeComparator("EDGE_TIME", fm);
>             final Comparator<DefaultWeightedEdge> edgeSourceSpotTimeComparator = new EdgeSourceSpotFrameComparator(model);
>             final Set<DefaultWeightedEdge> track = (Set<DefaultWeightedEdge>)model.getTrackModel().trackEdges(trackID);
>             final List<DefaultWeightedEdge> sortedTrack = new ArrayList<DefaultWeightedEdge>(track);
>             if (model.getFeatureModel().getEdgeFeatures().contains("Edge location")) {
>                 Collections.<DefaultWeightedEdge>sort(sortedTrack, edgeTimeComparator);
135,214c112,113
<          }
<       }
< 
<       return this.edgeTable;
<    }
< 
<    public ResultsTable executeTrack(TrackMate trackmate) {
<       FEATURES.add("TOTAL_DISTANCE_TRAVELED");
<       FEATURES.add("MAX_DISTANCE_TRAVELED");
<       FEATURES.add("CONFINMENT_RATIO");
<       FEATURES.add("MEAN_STRAIGHT_LINE_SPEED");
<       FEATURES.add("LINEARITY_OF_FORWARD_PROGRESSION");
<       FEATURES.add("TOTAL_ABSOLUTE_ANGLE_XY");
<       FEATURES.add("TOTAL_ABSOLUTE_ANGLE_YZ");
<       FEATURES.add("TOTAL_ABSOLUTE_ANGLE_ZX");
<       FEATURE_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total distance traveled");
<       FEATURE_NAMES.put("MAX_DISTANCE_TRAVELED", "Max distance traveled");
<       FEATURE_NAMES.put("CONFINMENT_RATIO", "Confinment ratio");
<       FEATURE_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean straight line speed");
<       FEATURE_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Linearity of forward progression");
<       FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Absolute angle in xy plane");
<       FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Absolute angle in yz plane");
<       FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Absolute angle in zx plane");
<       FEATURE_SHORT_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total dist.");
<       FEATURE_SHORT_NAMES.put("MAX_DISTANCE_TRAVELED", "Max dist.");
<       FEATURE_SHORT_NAMES.put("CONFINMENT_RATIO", "Cnfnmnt ratio");
<       FEATURE_SHORT_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean v. line");
<       FEATURE_SHORT_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Lin. fwd. progr.");
<       FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Abs. angle xy");
<       FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Abs. angle yz");
<       FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Abs. angle zx");
<       FEATURE_DIMENSIONS.put("TOTAL_DISTANCE_TRAVELED", Dimension.LENGTH);
<       FEATURE_DIMENSIONS.put("MAX_DISTANCE_TRAVELED", Dimension.LENGTH);
<       FEATURE_DIMENSIONS.put("CONFINMENT_RATIO", Dimension.NONE);
<       FEATURE_DIMENSIONS.put("MEAN_STRAIGHT_LINE_SPEED", Dimension.VELOCITY);
<       FEATURE_DIMENSIONS.put("LINEARITY_OF_FORWARD_PROGRESSION", Dimension.NONE);
<       FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_XY", Dimension.ANGLE);
<       FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_YZ", Dimension.ANGLE);
<       FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_ZX", Dimension.ANGLE);
<       IS_INT.put("TOTAL_DISTANCE_TRAVELED", Boolean.FALSE);
<       IS_INT.put("MAX_DISTANCE_TRAVELED", Boolean.FALSE);
<       IS_INT.put("CONFINMENT_RATIO", Boolean.FALSE);
<       IS_INT.put("MEAN_STRAIGHT_LINE_SPEED", Boolean.FALSE);
<       IS_INT.put("LINEARITY_OF_FORWARD_PROGRESSION", Boolean.FALSE);
<       IS_INT.put("TOTAL_ABSOLUTE_ANGLE_XY", Boolean.FALSE);
<       IS_INT.put("TOTAL_ABSOLUTE_ANGLE_YZ", Boolean.FALSE);
<       IS_INT.put("TOTAL_ABSOLUTE_ANGLE_ZX", Boolean.FALSE);
<       Model model = trackmate.getModel();
<       FeatureModel fm = model.getFeatureModel();
<       Set<Integer> trackIDs = model.getTrackModel().trackIDs(true);
<       this.trackTable = new ResultsTable();
<       Iterator var6 = trackIDs.iterator();
< 
<       while(var6.hasNext()) {
<          Integer trackID = (Integer)var6.next();
<          List<Spot> spots = new ArrayList(model.getTrackModel().trackSpots(trackID));
<          Collections.sort(spots, Spot.frameComparator);
<          Spot first = (Spot)spots.get(0);
<          Set<DefaultWeightedEdge> edges = model.getTrackModel().trackEdges(trackID);
<          double totalDistance = 0.0D;
<          double maxDistanceSq = Double.NEGATIVE_INFINITY;
<          double maxDistance = 0.0D;
<          double dx = 0.0D;
<          double dy = 0.0D;
<          double dz = 0.0D;
< 
<          Spot source;
<          Spot target;
<          double vMean;
<          double confinmentRatio;
<          for(Iterator var23 = edges.iterator(); var23.hasNext(); dz += target.getDoublePosition(2) - source.getDoublePosition(2)) {
<             DefaultWeightedEdge edge = (DefaultWeightedEdge)var23.next();
<             source = model.getTrackModel().getEdgeSource(edge);
<             target = model.getTrackModel().getEdgeTarget(edge);
<             vMean = Math.sqrt(source.squareDistanceTo(target));
<             totalDistance += vMean;
<             confinmentRatio = first.squareDistanceTo(target);
<             if (confinmentRatio > maxDistanceSq) {
<                maxDistanceSq = confinmentRatio;
<                maxDistance = Math.sqrt(confinmentRatio);
---
>             else {
>                 Collections.<DefaultWeightedEdge>sort(sortedTrack, edgeSourceSpotTimeComparator);
216,244c115,134
< 
<             dx += target.getDoublePosition(0) - source.getDoublePosition(0);
<             dy += target.getDoublePosition(1) - source.getDoublePosition(1);
<          }
< 
<          double netDistance = fm.getTrackFeature(trackID, "TRACK_DISPLACEMENT");
<          double tTotal = fm.getTrackFeature(trackID, "TRACK_DURATION");
<          vMean = fm.getTrackFeature(trackID, "TRACK_MEAN_SPEED");
<          confinmentRatio = netDistance / totalDistance;
<          double meanStraightLineSpeed = netDistance / tTotal;
<          double linearityForwardProgression = meanStraightLineSpeed / vMean;
<          double angleXY = Math.atan2(dy, dx);
<          double angleYZ = Math.atan2(dz, dy);
<          double angleZX = Math.atan2(dx, dz);
<          Collection<String> trackFeatures = fm.getTrackFeatures();
<          this.trackTable.incrementCounter();
<          this.trackTable.addLabel(model.getTrackModel().name(trackID));
<          this.trackTable.addValue("TRACK_ID", "" + trackID);
<          Iterator var42 = trackFeatures.iterator();
< 
<          while(var42.hasNext()) {
<             String feature = (String)var42.next();
<             Double val = fm.getTrackFeature(trackID, feature);
<             if (val == null) {
<                this.trackTable.addValue(feature, "None");
<             } else if ((Boolean)fm.getTrackFeatureIsInt().get(feature)) {
<                this.trackTable.addValue(feature, "" + val.intValue());
<             } else {
<                this.trackTable.addValue(feature, val);
---
>             for (final DefaultWeightedEdge edge : sortedTrack) {
>                 this.edgeTable.incrementCounter();
>                 this.edgeTable.addLabel(edge.toString());
>                 this.edgeTable.addValue("TRACK_ID", new StringBuilder().append((int)trackID).toString());
>                 for (final String feature : edgeFeatures) {
>                     final Object o = fm.getEdgeFeature(edge, feature);
>                     if (o instanceof String) {
>                         continue;
>                     }
>                     final Number d = (Number)o;
>                     if (d == null) {
>                         this.edgeTable.addValue(feature, "None");
>                     }
>                     else if (fm.getEdgeFeatureIsInt().get(feature)) {
>                         this.edgeTable.addValue(feature, new StringBuilder().append(d.intValue()).toString());
>                     }
>                     else {
>                         this.edgeTable.addValue(feature, d.doubleValue());
>                     }
>                 }
246,305c136,291
<          }
< 
<          this.trackTable.addValue("TOTAL_DISTANCE_TRAVELED", "" + (double)Math.round(totalDistance * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("MAX_DISTANCE_TRAVELED", "" + (double)Math.round(maxDistance * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("MEAN_STRAIGHT_LINE_SPEED", "" + (double)Math.round(meanStraightLineSpeed * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("LINEARITY_OF_FORWARD_PROGRESSION", "" + (double)Math.round(linearityForwardProgression * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_XY", "" + (double)Math.round(angleXY * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_YZ", "" + (double)Math.round(angleYZ * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_ZX", "" + (double)Math.round(angleZX * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("CONFINMENT_RATIO", "" + (double)Math.round(confinmentRatio * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("TRACK_CLASSIFICATION", "");
<          if (confinmentRatio == 0.0D) {
<             this.trackTable.addValue("TRACK_CLASSIFICATION", "Total-Confined Track");
<          }
< 
<          if (confinmentRatio == 1.0D) {
<             this.trackTable.addValue("TRACK_CLASSIFICATION", "Perfectly Straight Track");
<          }
< 
<          if (confinmentRatio > 0.0D && confinmentRatio <= 0.5D) {
<             this.trackTable.addValue("TRACK_CLASSIFICATION", "Strongly Confined Track");
<          }
< 
<          if (confinmentRatio > 0.05D && confinmentRatio <= 0.25D) {
<             this.trackTable.addValue("TRACK_CLASSIFICATION", "Purely Random Track");
<          }
< 
<          if (confinmentRatio > 0.25D && confinmentRatio < 1.0D) {
<             this.trackTable.addValue("TRACK_CLASSIFICATION", "Fairly Straight Track");
<          }
<       }
< 
<       return this.trackTable;
<    }
< 
<    public ResultsTable getEdgeTable() {
<       return this.edgeTable;
<    }
< 
<    public ResultsTable getTrackTable() {
<       return this.trackTable;
<    }
< 
<    private static final class EdgeSourceSpotFrameComparator implements Comparator<DefaultWeightedEdge> {
<       private final Model model;
< 
<       public EdgeSourceSpotFrameComparator(Model model) {
<          this.model = model;
<       }
< 
<       public int compare(DefaultWeightedEdge e1, DefaultWeightedEdge e2) {
<          double t1 = this.model.getTrackModel().getEdgeSource(e1).getFeature("FRAME");
<          double t2 = this.model.getTrackModel().getEdgeSource(e2).getFeature("FRAME");
<          if (t1 < t2) {
<             return -1;
<          } else {
<             return t1 > t2 ? 1 : 0;
<          }
<       }
<    }
---
>         }
>         return this.edgeTable;
>     }
>     
>     public ResultsTable executeTrack(final TrackMate trackmate) {
>         SLTResultsTableVersion.FEATURES.add("TOTAL_DISTANCE_TRAVELED");
>         SLTResultsTableVersion.FEATURES.add("MAX_DISTANCE_TRAVELED");
>         SLTResultsTableVersion.FEATURES.add("CONFINMENT_RATIO");
>         SLTResultsTableVersion.FEATURES.add("MEAN_STRAIGHT_LINE_SPEED");
>         SLTResultsTableVersion.FEATURES.add("LINEARITY_OF_FORWARD_PROGRESSION");
>         SLTResultsTableVersion.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_XY");
>         SLTResultsTableVersion.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_YZ");
>         SLTResultsTableVersion.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_ZX");
>         SLTResultsTableVersion.FEATURE_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total distance traveled");
>         SLTResultsTableVersion.FEATURE_NAMES.put("MAX_DISTANCE_TRAVELED", "Max distance traveled");
>         SLTResultsTableVersion.FEATURE_NAMES.put("CONFINMENT_RATIO", "Confinment ratio");
>         SLTResultsTableVersion.FEATURE_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean straight line speed");
>         SLTResultsTableVersion.FEATURE_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Linearity of forward progression");
>         SLTResultsTableVersion.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Absolute angle in xy plane");
>         SLTResultsTableVersion.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Absolute angle in yz plane");
>         SLTResultsTableVersion.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Absolute angle in zx plane");
>         SLTResultsTableVersion.FEATURE_SHORT_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total dist.");
>         SLTResultsTableVersion.FEATURE_SHORT_NAMES.put("MAX_DISTANCE_TRAVELED", "Max dist.");
>         SLTResultsTableVersion.FEATURE_SHORT_NAMES.put("CONFINMENT_RATIO", "Cnfnmnt ratio");
>         SLTResultsTableVersion.FEATURE_SHORT_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean v. line");
>         SLTResultsTableVersion.FEATURE_SHORT_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Lin. fwd. progr.");
>         SLTResultsTableVersion.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Abs. angle xy");
>         SLTResultsTableVersion.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Abs. angle yz");
>         SLTResultsTableVersion.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Abs. angle zx");
>         SLTResultsTableVersion.FEATURE_DIMENSIONS.put("TOTAL_DISTANCE_TRAVELED", Dimension.LENGTH);
>         SLTResultsTableVersion.FEATURE_DIMENSIONS.put("MAX_DISTANCE_TRAVELED", Dimension.LENGTH);
>         SLTResultsTableVersion.FEATURE_DIMENSIONS.put("CONFINMENT_RATIO", Dimension.NONE);
>         SLTResultsTableVersion.FEATURE_DIMENSIONS.put("MEAN_STRAIGHT_LINE_SPEED", Dimension.VELOCITY);
>         SLTResultsTableVersion.FEATURE_DIMENSIONS.put("LINEARITY_OF_FORWARD_PROGRESSION", Dimension.NONE);
>         SLTResultsTableVersion.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_XY", Dimension.ANGLE);
>         SLTResultsTableVersion.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_YZ", Dimension.ANGLE);
>         SLTResultsTableVersion.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_ZX", Dimension.ANGLE);
>         SLTResultsTableVersion.IS_INT.put("TOTAL_DISTANCE_TRAVELED", Boolean.FALSE);
>         SLTResultsTableVersion.IS_INT.put("MAX_DISTANCE_TRAVELED", Boolean.FALSE);
>         SLTResultsTableVersion.IS_INT.put("CONFINMENT_RATIO", Boolean.FALSE);
>         SLTResultsTableVersion.IS_INT.put("MEAN_STRAIGHT_LINE_SPEED", Boolean.FALSE);
>         SLTResultsTableVersion.IS_INT.put("LINEARITY_OF_FORWARD_PROGRESSION", Boolean.FALSE);
>         SLTResultsTableVersion.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_XY", Boolean.FALSE);
>         SLTResultsTableVersion.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_YZ", Boolean.FALSE);
>         SLTResultsTableVersion.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_ZX", Boolean.FALSE);
>         final Model model = trackmate.getModel();
>         final FeatureModel fm = model.getFeatureModel();
>         final Set<Integer> trackIDs = (Set<Integer>)model.getTrackModel().trackIDs(true);
>         this.trackTable = new ResultsTable();
>         for (final Integer trackID : trackIDs) {
>             final List<Spot> spots = new ArrayList<Spot>(model.getTrackModel().trackSpots(trackID));
>             Collections.<Spot>sort(spots, Spot.frameComparator);
>             final Spot first = spots.get(0);
>             final Set<DefaultWeightedEdge> edges = (Set<DefaultWeightedEdge>)model.getTrackModel().trackEdges(trackID);
>             double totalDistance = 0.0;
>             double maxDistanceSq = Double.NEGATIVE_INFINITY;
>             double maxDistance = 0.0;
>             double dx = 0.0;
>             double dy = 0.0;
>             double dz = 0.0;
>             for (final DefaultWeightedEdge edge : edges) {
>                 final Spot source = model.getTrackModel().getEdgeSource(edge);
>                 final Spot target = model.getTrackModel().getEdgeTarget(edge);
>                 final double d = Math.sqrt(source.squareDistanceTo((RealLocalizable)target));
>                 totalDistance += d;
>                 final double dToFirstSq = first.squareDistanceTo((RealLocalizable)target);
>                 if (dToFirstSq > maxDistanceSq) {
>                     maxDistanceSq = dToFirstSq;
>                     maxDistance = Math.sqrt(maxDistanceSq);
>                 }
>                 dx += target.getDoublePosition(0) - source.getDoublePosition(0);
>                 dy += target.getDoublePosition(1) - source.getDoublePosition(1);
>                 dz += target.getDoublePosition(2) - source.getDoublePosition(2);
>             }
>             final double netDistance = fm.getTrackFeature(trackID, "TRACK_DISPLACEMENT");
>             final double tTotal = fm.getTrackFeature(trackID, "TRACK_DURATION");
>             final double vMean = fm.getTrackFeature(trackID, "TRACK_MEAN_SPEED");
>             final double confinmentRatio = netDistance / totalDistance;
>             final double meanStraightLineSpeed = netDistance / tTotal;
>             final double linearityForwardProgression = meanStraightLineSpeed / vMean;
>             final double angleXY = Math.atan2(dy, dx);
>             final double angleYZ = Math.atan2(dz, dy);
>             final double angleZX = Math.atan2(dx, dz);
>             final Collection<String> trackFeatures = (Collection<String>)fm.getTrackFeatures();
>             this.trackTable.incrementCounter();
>             this.trackTable.addLabel(model.getTrackModel().name(trackID));
>             this.trackTable.addValue("TRACK_ID", new StringBuilder().append((int)trackID).toString());
>             for (final String feature : trackFeatures) {
>                 final Double val = fm.getTrackFeature(trackID, feature);
>                 if (val == null) {
>                     this.trackTable.addValue(feature, "None");
>                 }
>                 else if (fm.getTrackFeatureIsInt().get(feature)) {
>                     this.trackTable.addValue(feature, new StringBuilder().append(val.intValue()).toString());
>                 }
>                 else {
>                     this.trackTable.addValue(feature, (double)val);
>                 }
>             }
>             this.trackTable.addValue("TOTAL_DISTANCE_TRAVELED", new StringBuilder().append(Math.round(totalDistance * 1000.0) / 1000.0).toString());
>             this.trackTable.addValue("MAX_DISTANCE_TRAVELED", new StringBuilder().append(Math.round(maxDistance * 1000.0) / 1000.0).toString());
>             this.trackTable.addValue("MEAN_STRAIGHT_LINE_SPEED", new StringBuilder().append(Math.round(meanStraightLineSpeed * 1000.0) / 1000.0).toString());
>             this.trackTable.addValue("LINEARITY_OF_FORWARD_PROGRESSION", new StringBuilder().append(Math.round(linearityForwardProgression * 1000.0) / 1000.0).toString());
>             this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_XY", new StringBuilder().append(Math.round(angleXY * 1000.0) / 1000.0).toString());
>             this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_YZ", new StringBuilder().append(Math.round(angleYZ * 1000.0) / 1000.0).toString());
>             this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_ZX", new StringBuilder().append(Math.round(angleZX * 1000.0) / 1000.0).toString());
>             this.trackTable.addValue("CONFINMENT_RATIO", new StringBuilder().append(Math.round(confinmentRatio * 1000.0) / 1000.0).toString());
>             this.trackTable.addValue("TRACK_CLASSIFICATION", "");
>             if (confinmentRatio == 0.0) {
>                 this.trackTable.addValue("TRACK_CLASSIFICATION", "Total-Confined Track");
>             }
>             if (confinmentRatio == 1.0) {
>                 this.trackTable.addValue("TRACK_CLASSIFICATION", "Perfectly Straight Track");
>             }
>             if (confinmentRatio > 0.0 && confinmentRatio <= 0.5) {
>                 this.trackTable.addValue("TRACK_CLASSIFICATION", "Strongly Confined Track");
>             }
>             if (confinmentRatio > 0.05 && confinmentRatio <= 0.25) {
>                 this.trackTable.addValue("TRACK_CLASSIFICATION", "Purely Random Track");
>             }
>             if (confinmentRatio > 0.25 && confinmentRatio < 1.0) {
>                 this.trackTable.addValue("TRACK_CLASSIFICATION", "Fairly Straight Track");
>             }
>         }
>         return this.trackTable;
>     }
>     
>     public ResultsTable getEdgeTable() {
>         return this.edgeTable;
>     }
>     
>     public ResultsTable getTrackTable() {
>         return this.trackTable;
>     }
>     
>     private static final class EdgeSourceSpotFrameComparator implements Comparator<DefaultWeightedEdge>
>     {
>         private final Model model;
>         
>         public EdgeSourceSpotFrameComparator(final Model model) {
>             this.model = model;
>         }
>         
>         @Override
>         public int compare(final DefaultWeightedEdge e1, final DefaultWeightedEdge e2) {
>             final double t1 = this.model.getTrackModel().getEdgeSource(e1).getFeature("FRAME");
>             final double t2 = this.model.getTrackModel().getEdgeSource(e2).getFeature("FRAME");
>             if (t1 < t2) {
>                 return -1;
>             }
>             if (t1 > t2) {
>                 return 1;
>             }
>             return 0;
>         }
>     }
diff -r TrackAnalyzer_/smileModified/AbstractDistributionModified.java procyon/smileModified/AbstractDistributionModified.java
1,10c1,3
< package smileModified;
< 
< public abstract class AbstractDistributionModified implements DistributionModified {
<    protected double rejection(double pmax, double xmin, double xmax) {
<       double x;
<       double y;
<       do {
<          x = xmin + MathExModified.random() * (xmax - xmin);
<          y = MathExModified.random() * pmax;
<       } while(this.p(x) < y);
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
12,18c5
<       return x;
<    }
< 
<    protected double inverseTransformSampling() {
<       double u = MathExModified.random();
<       return this.quantile(u);
<    }
---
> package smileModified;
20,25c7,29
<    protected double quantile(double p, double xmin, double xmax, double eps) {
<       if (eps <= 0.0D) {
<          throw new IllegalArgumentException("Invalid epsilon: " + eps);
<       } else {
<          while(Math.abs(xmax - xmin) > eps) {
<             double xmed = (xmax + xmin) / 2.0D;
---
> public abstract class AbstractDistributionModified implements DistributionModified
> {
>     protected double rejection(final double pmax, final double xmin, final double xmax) {
>         double x;
>         double y;
>         do {
>             x = xmin + MathExModified.random() * (xmax - xmin);
>             y = MathExModified.random() * pmax;
>         } while (this.p(x) < y);
>         return x;
>     }
>     
>     protected double inverseTransformSampling() {
>         final double u = MathExModified.random();
>         return this.quantile(u);
>     }
>     
>     protected double quantile(final double p, double xmin, double xmax, final double eps) {
>         if (eps <= 0.0) {
>             throw new IllegalArgumentException("Invalid epsilon: " + eps);
>         }
>         while (Math.abs(xmax - xmin) > eps) {
>             final double xmed = (xmax + xmin) / 2.0;
27,29c31
<                xmax = xmed;
<             } else {
<                xmin = xmed;
---
>                 xmax = xmed;
31,39c33,42
<          }
< 
<          return xmin;
<       }
<    }
< 
<    protected double quantile(double p, double xmin, double xmax) {
<       return this.quantile(p, xmin, xmax, 1.0E-6D);
<    }
---
>             else {
>                 xmin = xmed;
>             }
>         }
>         return xmin;
>     }
>     
>     protected double quantile(final double p, final double xmin, final double xmax) {
>         return this.quantile(p, xmin, xmax, 1.0E-6);
>     }
diff -r TrackAnalyzer_/smileModified/BLASModified.java procyon/smileModified/BLASModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import java.nio.DoubleBuffer;
5a9
> import java.nio.DoubleBuffer;
9,222c13,227
< public interface BLASModified {
<    BLASModified engine = getInstance();
< 
<    static BLASModified getInstance() {
<       BLASModified mkl = MKL();
<       return (BLASModified)(mkl != null ? mkl : new OpenBLASModified());
<    }
< 
<    static BLASModified MKL() {
<       Logger logger = LoggerFactory.getLogger(BLASModified.class);
< 
<       try {
<          Class<?> clazz = Class.forName("smile.math.blas.mkl.MKL");
<          logger.info("smile-mkl module is available.");
<          return (BLASModified)clazz.getDeclaredConstructor().newInstance();
<       } catch (Exception var2) {
<          logger.debug("Failed to create MKL instance: ", var2);
<          return null;
<       }
<    }
< 
<    double asum(int var1, double[] var2, int var3);
< 
<    float asum(int var1, float[] var2, int var3);
< 
<    default double asum(double[] x) {
<       return this.asum(x.length, (double[])x, 1);
<    }
< 
<    default float asum(float[] x) {
<       return this.asum(x.length, (float[])x, 1);
<    }
< 
<    void axpy(int var1, double var2, double[] var4, int var5, double[] var6, int var7);
< 
<    void axpy(int var1, float var2, float[] var3, int var4, float[] var5, int var6);
< 
<    default void axpy(double alpha, double[] x, double[] y) {
<       this.axpy(x.length, alpha, x, 1, y, 1);
<    }
< 
<    default void axpy(float alpha, float[] x, float[] y) {
<       this.axpy(x.length, alpha, x, 1, y, 1);
<    }
< 
<    double dot(int var1, double[] var2, int var3, double[] var4, int var5);
< 
<    float dot(int var1, float[] var2, int var3, float[] var4, int var5);
< 
<    default double dot(double[] x, double[] y) {
<       return this.dot(x.length, (double[])x, 1, (double[])y, 1);
<    }
< 
<    default float dot(float[] x, float[] y) {
<       return this.dot(x.length, (float[])x, 1, (float[])y, 1);
<    }
< 
<    double nrm2(int var1, double[] var2, int var3);
< 
<    float nrm2(int var1, float[] var2, int var3);
< 
<    default double nrm2(double[] x) {
<       return this.nrm2(x.length, (double[])x, 1);
<    }
< 
<    default float nrm2(float[] x) {
<       return this.nrm2(x.length, (float[])x, 1);
<    }
< 
<    void scal(int var1, double var2, double[] var4, int var5);
< 
<    void scal(int var1, float var2, float[] var3, int var4);
< 
<    default void scal(double alpha, double[] x) {
<       this.scal(x.length, alpha, x, 1);
<    }
< 
<    default void scal(float alpha, float[] x) {
<       this.scal(x.length, alpha, x, 1);
<    }
< 
<    void swap(int var1, double[] var2, int var3, double[] var4, int var5);
< 
<    void swap(int var1, float[] var2, int var3, float[] var4, int var5);
< 
<    default void swap(double[] x, double[] y) {
<       this.swap(x.length, (double[])x, 1, (double[])y, 1);
<    }
< 
<    default void swap(float[] x, float[] y) {
<       this.swap(x.length, (float[])x, 1, (float[])y, 1);
<    }
< 
<    long iamax(int var1, double[] var2, int var3);
< 
<    long iamax(int var1, float[] var2, int var3);
< 
<    default long iamax(double[] x) {
<       return this.iamax(x.length, (double[])x, 1);
<    }
< 
<    default long iamax(float[] x) {
<       return this.iamax(x.length, (float[])x, 1);
<    }
< 
<    void gemv(LayoutModified var1, TransposeModified var2, int var3, int var4, double var5, double[] var7, int var8, double[] var9, int var10, double var11, double[] var13, int var14);
< 
<    void gemv(LayoutModified var1, TransposeModified var2, int var3, int var4, double var5, DoubleBuffer var7, int var8, DoubleBuffer var9, int var10, double var11, DoubleBuffer var13, int var14);
< 
<    void gemv(LayoutModified var1, TransposeModified var2, int var3, int var4, double var5, DoublePointer var7, int var8, DoublePointer var9, int var10, double var11, DoublePointer var13, int var14);
< 
<    void gemv(LayoutModified var1, TransposeModified var2, int var3, int var4, float var5, float[] var6, int var7, float[] var8, int var9, float var10, float[] var11, int var12);
< 
<    void gemv(LayoutModified var1, TransposeModified var2, int var3, int var4, float var5, FloatBuffer var6, int var7, FloatBuffer var8, int var9, float var10, FloatBuffer var11, int var12);
< 
<    void symv(LayoutModified var1, UPLOModified var2, int var3, double var4, double[] var6, int var7, double[] var8, int var9, double var10, double[] var12, int var13);
< 
<    void symv(LayoutModified var1, UPLOModified var2, int var3, double var4, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9, double var10, DoubleBuffer var12, int var13);
< 
<    void symv(LayoutModified var1, UPLOModified var2, int var3, double var4, DoublePointer var6, int var7, DoublePointer var8, int var9, double var10, DoublePointer var12, int var13);
< 
<    void symv(LayoutModified var1, UPLOModified var2, int var3, float var4, float[] var5, int var6, float[] var7, int var8, float var9, float[] var10, int var11);
< 
<    void symv(LayoutModified var1, UPLOModified var2, int var3, float var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, float var9, FloatBuffer var10, int var11);
< 
<    void spmv(LayoutModified var1, UPLOModified var2, int var3, double var4, double[] var6, double[] var7, int var8, double var9, double[] var11, int var12);
< 
<    void spmv(LayoutModified var1, UPLOModified var2, int var3, double var4, DoubleBuffer var6, DoubleBuffer var7, int var8, double var9, DoubleBuffer var11, int var12);
< 
<    void spmv(LayoutModified var1, UPLOModified var2, int var3, float var4, float[] var5, float[] var6, int var7, float var8, float[] var9, int var10);
< 
<    void spmv(LayoutModified var1, UPLOModified var2, int var3, float var4, FloatBuffer var5, FloatBuffer var6, int var7, float var8, FloatBuffer var9, int var10);
< 
<    void trmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, double[] var6, int var7, double[] var8, int var9);
< 
<    void trmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9);
< 
<    void trmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, DoublePointer var6, int var7, DoublePointer var8, int var9);
< 
<    void trmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, float[] var6, int var7, float[] var8, int var9);
< 
<    void trmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, FloatBuffer var6, int var7, FloatBuffer var8, int var9);
< 
<    void tpmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, double[] var6, double[] var7, int var8);
< 
<    void tpmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, DoubleBuffer var6, DoubleBuffer var7, int var8);
< 
<    void tpmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, float[] var6, float[] var7, int var8);
< 
<    void tpmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, FloatBuffer var6, FloatBuffer var7, int var8);
< 
<    void gbmv(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, double var7, double[] var9, int var10, double[] var11, int var12, double var13, double[] var15, int var16);
< 
<    void gbmv(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, double var7, DoubleBuffer var9, int var10, DoubleBuffer var11, int var12, double var13, DoubleBuffer var15, int var16);
< 
<    void gbmv(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, float var7, float[] var8, int var9, float[] var10, int var11, float var12, float[] var13, int var14);
< 
<    void gbmv(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, float var7, FloatBuffer var8, int var9, FloatBuffer var10, int var11, float var12, FloatBuffer var13, int var14);
< 
<    void sbmv(LayoutModified var1, UPLOModified var2, int var3, int var4, double var5, double[] var7, int var8, double[] var9, int var10, double var11, double[] var13, int var14);
< 
<    void sbmv(LayoutModified var1, UPLOModified var2, int var3, int var4, double var5, DoubleBuffer var7, int var8, DoubleBuffer var9, int var10, double var11, DoubleBuffer var13, int var14);
< 
<    void sbmv(LayoutModified var1, UPLOModified var2, int var3, int var4, float var5, float[] var6, int var7, float[] var8, int var9, float var10, float[] var11, int var12);
< 
<    void sbmv(LayoutModified var1, UPLOModified var2, int var3, int var4, float var5, FloatBuffer var6, int var7, FloatBuffer var8, int var9, float var10, FloatBuffer var11, int var12);
< 
<    void ger(LayoutModified var1, int var2, int var3, double var4, double[] var6, int var7, double[] var8, int var9, double[] var10, int var11);
< 
<    void ger(LayoutModified var1, int var2, int var3, double var4, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9, DoubleBuffer var10, int var11);
< 
<    void ger(LayoutModified var1, int var2, int var3, double var4, DoublePointer var6, int var7, DoublePointer var8, int var9, DoublePointer var10, int var11);
< 
<    void ger(LayoutModified var1, int var2, int var3, float var4, float[] var5, int var6, float[] var7, int var8, float[] var9, int var10);
< 
<    void ger(LayoutModified var1, int var2, int var3, float var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, int var10);
< 
<    void syr(LayoutModified var1, UPLOModified var2, int var3, double var4, double[] var6, int var7, double[] var8, int var9);
< 
<    void syr(LayoutModified var1, UPLOModified var2, int var3, double var4, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9);
< 
<    void syr(LayoutModified var1, UPLOModified var2, int var3, double var4, DoublePointer var6, int var7, DoublePointer var8, int var9);
< 
<    void syr(LayoutModified var1, UPLOModified var2, int var3, float var4, float[] var5, int var6, float[] var7, int var8);
< 
<    void syr(LayoutModified var1, UPLOModified var2, int var3, float var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8);
< 
<    void spr(LayoutModified var1, UPLOModified var2, int var3, double var4, double[] var6, int var7, double[] var8);
< 
<    void spr(LayoutModified var1, UPLOModified var2, int var3, double var4, DoubleBuffer var6, int var7, DoubleBuffer var8);
< 
<    void spr(LayoutModified var1, UPLOModified var2, int var3, float var4, float[] var5, int var6, float[] var7);
< 
<    void spr(LayoutModified var1, UPLOModified var2, int var3, float var4, FloatBuffer var5, int var6, FloatBuffer var7);
< 
<    void gemm(LayoutModified var1, TransposeModified var2, TransposeModified var3, int var4, int var5, int var6, double var7, double[] var9, int var10, double[] var11, int var12, double var13, double[] var15, int var16);
< 
<    void gemm(LayoutModified var1, TransposeModified var2, TransposeModified var3, int var4, int var5, int var6, double var7, DoubleBuffer var9, int var10, DoubleBuffer var11, int var12, double var13, DoubleBuffer var15, int var16);
< 
<    void gemm(LayoutModified var1, TransposeModified var2, TransposeModified var3, int var4, int var5, int var6, double var7, DoublePointer var9, int var10, DoublePointer var11, int var12, double var13, DoublePointer var15, int var16);
< 
<    void gemm(LayoutModified var1, TransposeModified var2, TransposeModified var3, int var4, int var5, int var6, float var7, float[] var8, int var9, float[] var10, int var11, float var12, float[] var13, int var14);
< 
<    void gemm(LayoutModified var1, TransposeModified var2, TransposeModified var3, int var4, int var5, int var6, float var7, FloatBuffer var8, int var9, FloatBuffer var10, int var11, float var12, FloatBuffer var13, int var14);
< 
<    void symm(LayoutModified var1, SideModified var2, UPLOModified var3, int var4, int var5, double var6, double[] var8, int var9, double[] var10, int var11, double var12, double[] var14, int var15);
< 
<    void symm(LayoutModified var1, SideModified var2, UPLOModified var3, int var4, int var5, double var6, DoubleBuffer var8, int var9, DoubleBuffer var10, int var11, double var12, DoubleBuffer var14, int var15);
< 
<    void symm(LayoutModified var1, SideModified var2, UPLOModified var3, int var4, int var5, double var6, DoublePointer var8, int var9, DoublePointer var10, int var11, double var12, DoublePointer var14, int var15);
< 
<    void symm(LayoutModified var1, SideModified var2, UPLOModified var3, int var4, int var5, float var6, float[] var7, int var8, float[] var9, int var10, float var11, float[] var12, int var13);
< 
<    void symm(LayoutModified var1, SideModified var2, UPLOModified var3, int var4, int var5, float var6, FloatBuffer var7, int var8, FloatBuffer var9, int var10, float var11, FloatBuffer var12, int var13);
---
> public interface BLASModified
> {
>     public static final BLASModified engine = getInstance();
>     
>     default BLASModified getInstance() {
>         final BLASModified mkl = MKL();
>         return (mkl != null) ? mkl : new OpenBLASModified();
>     }
>     
>     default BLASModified MKL() {
>         final Logger logger = LoggerFactory.getLogger((Class)BLASModified.class);
>         try {
>             final Class<?> clazz = Class.forName("smile.math.blas.mkl.MKL");
>             logger.info("smile-mkl module is available.");
>             return (BLASModified)clazz.getDeclaredConstructor((Class<?>[])new Class[0]).newInstance(new Object[0]);
>         }
>         catch (Exception e) {
>             logger.debug("Failed to create MKL instance: ", (Throwable)e);
>             return null;
>         }
>     }
>     
>     double asum(final int p0, final double[] p1, final int p2);
>     
>     float asum(final int p0, final float[] p1, final int p2);
>     
>     default double asum(final double[] x) {
>         return this.asum(x.length, x, 1);
>     }
>     
>     default float asum(final float[] x) {
>         return this.asum(x.length, x, 1);
>     }
>     
>     void axpy(final int p0, final double p1, final double[] p2, final int p3, final double[] p4, final int p5);
>     
>     void axpy(final int p0, final float p1, final float[] p2, final int p3, final float[] p4, final int p5);
>     
>     default void axpy(final double alpha, final double[] x, final double[] y) {
>         this.axpy(x.length, alpha, x, 1, y, 1);
>     }
>     
>     default void axpy(final float alpha, final float[] x, final float[] y) {
>         this.axpy(x.length, alpha, x, 1, y, 1);
>     }
>     
>     double dot(final int p0, final double[] p1, final int p2, final double[] p3, final int p4);
>     
>     float dot(final int p0, final float[] p1, final int p2, final float[] p3, final int p4);
>     
>     default double dot(final double[] x, final double[] y) {
>         return this.dot(x.length, x, 1, y, 1);
>     }
>     
>     default float dot(final float[] x, final float[] y) {
>         return this.dot(x.length, x, 1, y, 1);
>     }
>     
>     double nrm2(final int p0, final double[] p1, final int p2);
>     
>     float nrm2(final int p0, final float[] p1, final int p2);
>     
>     default double nrm2(final double[] x) {
>         return this.nrm2(x.length, x, 1);
>     }
>     
>     default float nrm2(final float[] x) {
>         return this.nrm2(x.length, x, 1);
>     }
>     
>     void scal(final int p0, final double p1, final double[] p2, final int p3);
>     
>     void scal(final int p0, final float p1, final float[] p2, final int p3);
>     
>     default void scal(final double alpha, final double[] x) {
>         this.scal(x.length, alpha, x, 1);
>     }
>     
>     default void scal(final float alpha, final float[] x) {
>         this.scal(x.length, alpha, x, 1);
>     }
>     
>     void swap(final int p0, final double[] p1, final int p2, final double[] p3, final int p4);
>     
>     void swap(final int p0, final float[] p1, final int p2, final float[] p3, final int p4);
>     
>     default void swap(final double[] x, final double[] y) {
>         this.swap(x.length, x, 1, y, 1);
>     }
>     
>     default void swap(final float[] x, final float[] y) {
>         this.swap(x.length, x, 1, y, 1);
>     }
>     
>     long iamax(final int p0, final double[] p1, final int p2);
>     
>     long iamax(final int p0, final float[] p1, final int p2);
>     
>     default long iamax(final double[] x) {
>         return this.iamax(x.length, x, 1);
>     }
>     
>     default long iamax(final float[] x) {
>         return this.iamax(x.length, x, 1);
>     }
>     
>     void gemv(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final double p4, final double[] p5, final int p6, final double[] p7, final int p8, final double p9, final double[] p10, final int p11);
>     
>     void gemv(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final double p4, final DoubleBuffer p5, final int p6, final DoubleBuffer p7, final int p8, final double p9, final DoubleBuffer p10, final int p11);
>     
>     void gemv(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final double p4, final DoublePointer p5, final int p6, final DoublePointer p7, final int p8, final double p9, final DoublePointer p10, final int p11);
>     
>     void gemv(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final float p4, final float[] p5, final int p6, final float[] p7, final int p8, final float p9, final float[] p10, final int p11);
>     
>     void gemv(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final float p4, final FloatBuffer p5, final int p6, final FloatBuffer p7, final int p8, final float p9, final FloatBuffer p10, final int p11);
>     
>     void symv(final LayoutModified p0, final UPLOModified p1, final int p2, final double p3, final double[] p4, final int p5, final double[] p6, final int p7, final double p8, final double[] p9, final int p10);
>     
>     void symv(final LayoutModified p0, final UPLOModified p1, final int p2, final double p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final int p7, final double p8, final DoubleBuffer p9, final int p10);
>     
>     void symv(final LayoutModified p0, final UPLOModified p1, final int p2, final double p3, final DoublePointer p4, final int p5, final DoublePointer p6, final int p7, final double p8, final DoublePointer p9, final int p10);
>     
>     void symv(final LayoutModified p0, final UPLOModified p1, final int p2, final float p3, final float[] p4, final int p5, final float[] p6, final int p7, final float p8, final float[] p9, final int p10);
>     
>     void symv(final LayoutModified p0, final UPLOModified p1, final int p2, final float p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final int p7, final float p8, final FloatBuffer p9, final int p10);
>     
>     void spmv(final LayoutModified p0, final UPLOModified p1, final int p2, final double p3, final double[] p4, final double[] p5, final int p6, final double p7, final double[] p8, final int p9);
>     
>     void spmv(final LayoutModified p0, final UPLOModified p1, final int p2, final double p3, final DoubleBuffer p4, final DoubleBuffer p5, final int p6, final double p7, final DoubleBuffer p8, final int p9);
>     
>     void spmv(final LayoutModified p0, final UPLOModified p1, final int p2, final float p3, final float[] p4, final float[] p5, final int p6, final float p7, final float[] p8, final int p9);
>     
>     void spmv(final LayoutModified p0, final UPLOModified p1, final int p2, final float p3, final FloatBuffer p4, final FloatBuffer p5, final int p6, final float p7, final FloatBuffer p8, final int p9);
>     
>     void trmv(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final double[] p5, final int p6, final double[] p7, final int p8);
>     
>     void trmv(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final DoubleBuffer p5, final int p6, final DoubleBuffer p7, final int p8);
>     
>     void trmv(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final DoublePointer p5, final int p6, final DoublePointer p7, final int p8);
>     
>     void trmv(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final float[] p5, final int p6, final float[] p7, final int p8);
>     
>     void trmv(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final FloatBuffer p5, final int p6, final FloatBuffer p7, final int p8);
>     
>     void tpmv(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final double[] p5, final double[] p6, final int p7);
>     
>     void tpmv(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final DoubleBuffer p5, final DoubleBuffer p6, final int p7);
>     
>     void tpmv(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final float[] p5, final float[] p6, final int p7);
>     
>     void tpmv(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final FloatBuffer p5, final FloatBuffer p6, final int p7);
>     
>     void gbmv(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final int p5, final double p6, final double[] p7, final int p8, final double[] p9, final int p10, final double p11, final double[] p12, final int p13);
>     
>     void gbmv(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final int p5, final double p6, final DoubleBuffer p7, final int p8, final DoubleBuffer p9, final int p10, final double p11, final DoubleBuffer p12, final int p13);
>     
>     void gbmv(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final int p5, final float p6, final float[] p7, final int p8, final float[] p9, final int p10, final float p11, final float[] p12, final int p13);
>     
>     void gbmv(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final int p5, final float p6, final FloatBuffer p7, final int p8, final FloatBuffer p9, final int p10, final float p11, final FloatBuffer p12, final int p13);
>     
>     void sbmv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final double p4, final double[] p5, final int p6, final double[] p7, final int p8, final double p9, final double[] p10, final int p11);
>     
>     void sbmv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final double p4, final DoubleBuffer p5, final int p6, final DoubleBuffer p7, final int p8, final double p9, final DoubleBuffer p10, final int p11);
>     
>     void sbmv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final float p4, final float[] p5, final int p6, final float[] p7, final int p8, final float p9, final float[] p10, final int p11);
>     
>     void sbmv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final float p4, final FloatBuffer p5, final int p6, final FloatBuffer p7, final int p8, final float p9, final FloatBuffer p10, final int p11);
>     
>     void ger(final LayoutModified p0, final int p1, final int p2, final double p3, final double[] p4, final int p5, final double[] p6, final int p7, final double[] p8, final int p9);
>     
>     void ger(final LayoutModified p0, final int p1, final int p2, final double p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final int p7, final DoubleBuffer p8, final int p9);
>     
>     void ger(final LayoutModified p0, final int p1, final int p2, final double p3, final DoublePointer p4, final int p5, final DoublePointer p6, final int p7, final DoublePointer p8, final int p9);
>     
>     void ger(final LayoutModified p0, final int p1, final int p2, final float p3, final float[] p4, final int p5, final float[] p6, final int p7, final float[] p8, final int p9);
>     
>     void ger(final LayoutModified p0, final int p1, final int p2, final float p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final int p7, final FloatBuffer p8, final int p9);
>     
>     void syr(final LayoutModified p0, final UPLOModified p1, final int p2, final double p3, final double[] p4, final int p5, final double[] p6, final int p7);
>     
>     void syr(final LayoutModified p0, final UPLOModified p1, final int p2, final double p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final int p7);
>     
>     void syr(final LayoutModified p0, final UPLOModified p1, final int p2, final double p3, final DoublePointer p4, final int p5, final DoublePointer p6, final int p7);
>     
>     void syr(final LayoutModified p0, final UPLOModified p1, final int p2, final float p3, final float[] p4, final int p5, final float[] p6, final int p7);
>     
>     void syr(final LayoutModified p0, final UPLOModified p1, final int p2, final float p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final int p7);
>     
>     void spr(final LayoutModified p0, final UPLOModified p1, final int p2, final double p3, final double[] p4, final int p5, final double[] p6);
>     
>     void spr(final LayoutModified p0, final UPLOModified p1, final int p2, final double p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6);
>     
>     void spr(final LayoutModified p0, final UPLOModified p1, final int p2, final float p3, final float[] p4, final int p5, final float[] p6);
>     
>     void spr(final LayoutModified p0, final UPLOModified p1, final int p2, final float p3, final FloatBuffer p4, final int p5, final FloatBuffer p6);
>     
>     void gemm(final LayoutModified p0, final TransposeModified p1, final TransposeModified p2, final int p3, final int p4, final int p5, final double p6, final double[] p7, final int p8, final double[] p9, final int p10, final double p11, final double[] p12, final int p13);
>     
>     void gemm(final LayoutModified p0, final TransposeModified p1, final TransposeModified p2, final int p3, final int p4, final int p5, final double p6, final DoubleBuffer p7, final int p8, final DoubleBuffer p9, final int p10, final double p11, final DoubleBuffer p12, final int p13);
>     
>     void gemm(final LayoutModified p0, final TransposeModified p1, final TransposeModified p2, final int p3, final int p4, final int p5, final double p6, final DoublePointer p7, final int p8, final DoublePointer p9, final int p10, final double p11, final DoublePointer p12, final int p13);
>     
>     void gemm(final LayoutModified p0, final TransposeModified p1, final TransposeModified p2, final int p3, final int p4, final int p5, final float p6, final float[] p7, final int p8, final float[] p9, final int p10, final float p11, final float[] p12, final int p13);
>     
>     void gemm(final LayoutModified p0, final TransposeModified p1, final TransposeModified p2, final int p3, final int p4, final int p5, final float p6, final FloatBuffer p7, final int p8, final FloatBuffer p9, final int p10, final float p11, final FloatBuffer p12, final int p13);
>     
>     void symm(final LayoutModified p0, final SideModified p1, final UPLOModified p2, final int p3, final int p4, final double p5, final double[] p6, final int p7, final double[] p8, final int p9, final double p10, final double[] p11, final int p12);
>     
>     void symm(final LayoutModified p0, final SideModified p1, final UPLOModified p2, final int p3, final int p4, final double p5, final DoubleBuffer p6, final int p7, final DoubleBuffer p8, final int p9, final double p10, final DoubleBuffer p11, final int p12);
>     
>     void symm(final LayoutModified p0, final SideModified p1, final UPLOModified p2, final int p3, final int p4, final double p5, final DoublePointer p6, final int p7, final DoublePointer p8, final int p9, final double p10, final DoublePointer p11, final int p12);
>     
>     void symm(final LayoutModified p0, final SideModified p1, final UPLOModified p2, final int p3, final int p4, final float p5, final float[] p6, final int p7, final float[] p8, final int p9, final float p10, final float[] p11, final int p12);
>     
>     void symm(final LayoutModified p0, final SideModified p1, final UPLOModified p2, final int p3, final int p4, final float p5, final FloatBuffer p6, final int p7, final FloatBuffer p8, final int p9, final float p10, final FloatBuffer p11, final int p12);
diff -r TrackAnalyzer_/smileModified/DiagModified.java procyon/smileModified/DiagModified.java
1,8c1,3
< package smileModified;
< 
< public enum DiagModified {
<    NON_UNIT(131, (byte)78),
<    UNIT(132, (byte)85);
< 
<    private final int blas;
<    private final byte lapack;
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
10,17c5
<    private DiagModified(int blas, byte lapack) {
<       this.blas = blas;
<       this.lapack = lapack;
<    }
< 
<    public int blas() {
<       return this.blas;
<    }
---
> package smileModified;
19,21c7,26
<    public byte lapack() {
<       return this.lapack;
<    }
---
> public enum DiagModified
> {
>     NON_UNIT("NON_UNIT", 0, 131, (byte)78), 
>     UNIT("UNIT", 1, 132, (byte)85);
>     
>     private final int blas;
>     private final byte lapack;
>     
>     private DiagModified(final String name, final int ordinal, final int blas, final byte lapack) {
>         this.blas = blas;
>         this.lapack = lapack;
>     }
>     
>     public int blas() {
>         return this.blas;
>     }
>     
>     public byte lapack() {
>         return this.lapack;
>     }
diff -r TrackAnalyzer_/smileModified/DistanceModified.java procyon/smileModified/DistanceModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
2a7
> import java.util.stream.IntStream;
5,47d9
< import java.util.stream.IntStream;
< 
< public interface DistanceModified<T> extends ToDoubleBiFunction<T, T>, Serializable {
<    double d(T var1, T var2);
< 
<    default double apply(T x, T y) {
<       return this.d(x, y);
<    }
< 
<    default double applyAsDouble(T x, T y) {
<       return this.d(x, y);
<    }
< 
<    default MatrixModified D(T[] x) {
<       int n = x.length;
<       int N = n * (n - 1) / 2;
<       MatrixModified D = new MatrixModified(n, n);
<       IntStream.range(0, N).parallel().forEach((k) -> {
<          int j = n - 2 - (int)Math.floor(Math.sqrt((double)(-8 * k + 4 * n * (n - 1) - 7)) / 2.0D - 0.5D);
<          int i = k + j + 1 - n * (n - 1) / 2 + (n - j) * (n - j - 1) / 2;
<          D.set(i, j, this.d(x[i], x[j]));
<       });
< 
<       for(int i = 0; i < n; ++i) {
<          for(int j = i + 1; j < n; ++j) {
<             D.set(i, j, D.get(j, i));
<          }
<       }
< 
<       D.uplo(UPLOModified.LOWER);
<       return D;
<    }
< 
<    default MatrixModified D(T[] x, T[] y) {
<       int m = x.length;
<       int n = y.length;
<       MatrixModified D = new MatrixModified(m, n);
<       IntStream.range(0, m).parallel().forEach((i) -> {
<          T xi = x[i];
< 
<          for(int j = 0; j < n; ++j) {
<             D.set(i, j, this.d(xi, y[j]));
<          }
49,51c11,62
<       });
<       return D;
<    }
---
> public interface DistanceModified<T> extends ToDoubleBiFunction<T, T>, Serializable
> {
>     double d(final T p0, final T p1);
>     
>     default double apply(final T x, final T y) {
>         return this.d(x, y);
>     }
>     
>     default double applyAsDouble(final T x, final T y) {
>         return this.d(x, y);
>     }
>     
>     default MatrixModified D(final T[] x) {
>         final int n = x.length;
>         final int N = n * (n - 1) / 2;
>         final MatrixModified D = new MatrixModified(n, n);
>         final int n2;
>         final int j;
>         final int i;
>         final MatrixModified matrixModified;
>         IntStream.range(0, N).parallel().forEach(k -> {
>             j = n2 - 2 - (int)Math.floor(Math.sqrt(-8 * k + 4 * n2 * (n2 - 1) - 7) / 2.0 - 0.5);
>             i = k + j + 1 - n2 * (n2 - 1) / 2 + (n2 - j) * (n2 - j - 1) / 2;
>             matrixModified.set(i, j, this.d(x[i], x[j]));
>             return;
>         });
>         for (int l = 0; l < n; ++l) {
>             for (int m = l + 1; m < n; ++m) {
>                 D.set(l, m, D.get(m, l));
>             }
>         }
>         D.uplo(UPLOModified.LOWER);
>         return D;
>     }
>     
>     default MatrixModified D(final T[] x, final T[] y) {
>         final int m = x.length;
>         final int n = y.length;
>         final MatrixModified D = new MatrixModified(m, n);
>         final T xi;
>         int j;
>         final int n2;
>         final MatrixModified matrixModified;
>         IntStream.range(0, m).parallel().forEach(i -> {
>             xi = x[i];
>             for (j = 0; j < n2; ++j) {
>                 matrixModified.set(i, j, this.d(xi, y[j]));
>             }
>             return;
>         });
>         return D;
>     }
diff -r TrackAnalyzer_/smileModified/DistributionModified.java procyon/smileModified/DistributionModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,53c9,51
< public interface DistributionModified extends Serializable {
<    int length();
< 
<    double mean();
< 
<    double variance();
< 
<    default double sd() {
<       return Math.sqrt(this.variance());
<    }
< 
<    double entropy();
< 
<    double rand();
< 
<    default double[] rand(int n) {
<       double[] data = new double[n];
< 
<       for(int i = 0; i < n; ++i) {
<          data[i] = this.rand();
<       }
< 
<       return data;
<    }
< 
<    double p(double var1);
< 
<    double logp(double var1);
< 
<    double cdf(double var1);
< 
<    double quantile(double var1);
< 
<    default double likelihood(double[] x) {
<       return Math.exp(this.logLikelihood(x));
<    }
< 
<    default double logLikelihood(double[] x) {
<       double L = 0.0D;
<       double[] var8 = x;
<       int var7 = x.length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          double xi = var8[var6];
<          L += this.logp(xi);
<       }
< 
<       return L;
<    }
---
> public interface DistributionModified extends Serializable
> {
>     int length();
>     
>     double mean();
>     
>     double variance();
>     
>     default double sd() {
>         return Math.sqrt(this.variance());
>     }
>     
>     double entropy();
>     
>     double rand();
>     
>     default double[] rand(final int n) {
>         final double[] data = new double[n];
>         for (int i = 0; i < n; ++i) {
>             data[i] = this.rand();
>         }
>         return data;
>     }
>     
>     double p(final double p0);
>     
>     double logp(final double p0);
>     
>     double cdf(final double p0);
>     
>     double quantile(final double p0);
>     
>     default double likelihood(final double[] x) {
>         return Math.exp(this.logLikelihood(x));
>     }
>     
>     default double logLikelihood(final double[] x) {
>         double L = 0.0;
>         for (final double xi : x) {
>             L += this.logp(xi);
>         }
>         return L;
>     }
diff -r TrackAnalyzer_/smileModified/DoubleArrayListModified.java procyon/smileModified/DoubleArrayListModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,6d6
< import java.io.Serializable;
< import java.text.DecimalFormat;
< import java.util.Arrays;
< import java.util.stream.Collectors;
7a8,13
> import java.util.stream.Collector;
> import java.util.stream.Collectors;
> import java.util.function.DoubleFunction;
> import java.util.Arrays;
> import java.text.DecimalFormat;
> import java.io.Serializable;
9,95c15,103
< public final class DoubleArrayListModified implements Serializable {
<    private static final long serialVersionUID = 1L;
<    private static final DecimalFormat format = new DecimalFormat("#.######");
<    double[] data;
<    private int size;
< 
<    public DoubleArrayListModified() {
<       this(10);
<    }
< 
<    public DoubleArrayListModified(int capacity) {
<       this.data = new double[capacity];
<       this.size = 0;
<    }
< 
<    public DoubleArrayListModified(double[] values) {
<       this(Math.max(values.length, 10));
<       this.add(values);
<    }
< 
<    public String toString() {
<       DoubleStream var10000 = Arrays.stream(this.data).limit((long)this.size);
<       DecimalFormat var10001 = format;
<       var10001.getClass();
<       return (String)var10000.mapToObj(var10001::format).collect(Collectors.joining(", ", "[", "]"));
<    }
< 
<    public DoubleStream stream() {
<       return DoubleStream.of(this.data).limit((long)this.size);
<    }
< 
<    public void ensureCapacity(int capacity) {
<       if (capacity > this.data.length) {
<          int newCap = Math.max(this.data.length << 1, capacity);
<          double[] tmp = new double[newCap];
<          System.arraycopy(this.data, 0, tmp, 0, this.data.length);
<          this.data = tmp;
<       }
< 
<    }
< 
<    public int size() {
<       return this.size;
<    }
< 
<    public boolean isEmpty() {
<       return this.size == 0;
<    }
< 
<    public void trim() {
<       if (this.data.length > this.size()) {
<          this.data = this.toArray();
<       }
< 
<    }
< 
<    public void add(double val) {
<       this.ensureCapacity(this.size + 1);
<       this.data[this.size++] = val;
<    }
< 
<    public void add(double[] vals) {
<       this.ensureCapacity(this.size + vals.length);
<       System.arraycopy(vals, 0, this.data, this.size, vals.length);
<       this.size += vals.length;
<    }
< 
<    public double get(int index) {
<       return this.data[index];
<    }
< 
<    public void set(int index, double val) {
<       if (index >= 0 && index < this.size) {
<          this.data[index] = val;
<       } else {
<          throw new IndexOutOfBoundsException(String.valueOf(index));
<       }
<    }
< 
<    public void clear() {
<       this.size = 0;
<    }
< 
<    public double remove(int index) {
<       if (index >= 0 && index < this.size) {
<          double old = this.get(index);
<          if (index == 0) {
---
> public final class DoubleArrayListModified implements Serializable
> {
>     private static final long serialVersionUID = 1L;
>     private static final DecimalFormat format;
>     double[] data;
>     private int size;
>     
>     static {
>         format = new DecimalFormat("#.######");
>     }
>     
>     public DoubleArrayListModified() {
>         this(10);
>     }
>     
>     public DoubleArrayListModified(final int capacity) {
>         this.data = new double[capacity];
>         this.size = 0;
>     }
>     
>     public DoubleArrayListModified(final double[] values) {
>         this(Math.max(values.length, 10));
>         this.add(values);
>     }
>     
>     @Override
>     public String toString() {
>         return Arrays.stream(this.data).limit(this.size).<Object>mapToObj((DoubleFunction<?>)DoubleArrayListModified.format::format).<String, ?>collect((Collector<? super Object, ?, String>)Collectors.joining(", ", "[", "]"));
>     }
>     
>     public DoubleStream stream() {
>         return DoubleStream.of(this.data).limit(this.size);
>     }
>     
>     public void ensureCapacity(final int capacity) {
>         if (capacity > this.data.length) {
>             final int newCap = Math.max(this.data.length << 1, capacity);
>             final double[] tmp = new double[newCap];
>             System.arraycopy(this.data, 0, tmp, 0, this.data.length);
>             this.data = tmp;
>         }
>     }
>     
>     public int size() {
>         return this.size;
>     }
>     
>     public boolean isEmpty() {
>         return this.size == 0;
>     }
>     
>     public void trim() {
>         if (this.data.length > this.size()) {
>             this.data = this.toArray();
>         }
>     }
>     
>     public void add(final double val) {
>         this.ensureCapacity(this.size + 1);
>         this.data[this.size++] = val;
>     }
>     
>     public void add(final double[] vals) {
>         this.ensureCapacity(this.size + vals.length);
>         System.arraycopy(vals, 0, this.data, this.size, vals.length);
>         this.size += vals.length;
>     }
>     
>     public double get(final int index) {
>         return this.data[index];
>     }
>     
>     public void set(final int index, final double val) {
>         if (index < 0 || index >= this.size) {
>             throw new IndexOutOfBoundsException(String.valueOf(index));
>         }
>         this.data[index] = val;
>     }
>     
>     public void clear() {
>         this.size = 0;
>     }
>     
>     public double remove(final int index) {
>         if (index < 0 || index >= this.size) {
>             throw new IndexOutOfBoundsException(String.valueOf(index));
>         }
>         final double old = this.get(index);
>         if (index == 0) {
97c105,106
<          } else if (this.size - 1 != index) {
---
>         }
>         else if (this.size - 1 != index) {
99,119c108,123
<          }
< 
<          --this.size;
<          return old;
<       } else {
<          throw new IndexOutOfBoundsException(String.valueOf(index));
<       }
<    }
< 
<    public double[] toArray() {
<       return this.toArray((double[])null);
<    }
< 
<    public double[] toArray(double[] dest) {
<       if (dest == null || dest.length < this.size()) {
<          dest = new double[this.size];
<       }
< 
<       System.arraycopy(this.data, 0, dest, 0, this.size);
<       return dest;
<    }
---
>         }
>         --this.size;
>         return old;
>     }
>     
>     public double[] toArray() {
>         return this.toArray(null);
>     }
>     
>     public double[] toArray(double[] dest) {
>         if (dest == null || dest.length < this.size()) {
>             dest = new double[this.size];
>         }
>         System.arraycopy(this.data, 0, dest, 0, this.size);
>         return dest;
>     }
diff -r TrackAnalyzer_/smileModified/DoubleConsumerModified.java procyon/smileModified/DoubleConsumerModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,4c7,9
< public interface DoubleConsumerModified {
<    void accept(int var1, int var2, double var3);
---
> public interface DoubleConsumerModified
> {
>     void accept(final int p0, final int p1, final double p2);
diff -r TrackAnalyzer_/smileModified/EigenRangeModified.java procyon/smileModified/EigenRangeModified.java
1,6c1,3
< package smileModified;
< 
< public enum EigenRangeModified {
<    ALL((byte)65),
<    VALUE((byte)86),
<    INDEX((byte)73);
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
8,12c5
<    private final byte lapack;
< 
<    private EigenRangeModified(byte lapack) {
<       this.lapack = lapack;
<    }
---
> package smileModified;
14,16c7,21
<    public byte lapack() {
<       return this.lapack;
<    }
---
> public enum EigenRangeModified
> {
>     ALL("ALL", 0, (byte)65), 
>     VALUE("VALUE", 1, (byte)86), 
>     INDEX("INDEX", 2, (byte)73);
>     
>     private final byte lapack;
>     
>     private EigenRangeModified(final String name, final int ordinal, final byte lapack) {
>         this.lapack = lapack;
>     }
>     
>     public byte lapack() {
>         return this.lapack;
>     }
diff -r TrackAnalyzer_/smileModified/ErfModified.java procyon/smileModified/ErfModified.java
1,22c1,3
< package smileModified;
< 
< public class ErfModified {
<    private static final double[] cof = new double[]{-1.3026537197817094D, 0.6419697923564902D, 0.019476473204185836D, -0.00956151478680863D, -9.46595344482036E-4D, 3.66839497852761E-4D, 4.2523324806907E-5D, -2.0278578112534E-5D, -1.624290004647E-6D, 1.30365583558E-6D, 1.5626441722E-8D, -8.5238095915E-8D, 6.529054439E-9D, 5.059343495E-9D, -9.91364156E-10D, -2.27365122E-10D, 9.6467911E-11D, 2.394038E-12D, -6.886027E-12D, 8.94487E-13D, 3.13092E-13D, -1.12708E-13D, 3.81E-16D, 7.106E-15D, -1.523E-15D, -9.4E-17D, 1.21E-16D, -2.8E-17D};
< 
<    private ErfModified() {
<    }
< 
<    public static double erf(double x) {
<       return x >= 0.0D ? 1.0D - erfccheb(x) : erfccheb(-x) - 1.0D;
<    }
< 
<    public static double erfc(double x) {
<       return x >= 0.0D ? erfccheb(x) : 2.0D - erfccheb(-x);
<    }
< 
<    public static double erfcc(double x) {
<       double z = Math.abs(x);
<       double t = 2.0D / (2.0D + z);
<       double ans = t * Math.exp(-z * z - 1.26551223D + t * (1.00002368D + t * (0.37409196D + t * (0.09678418D + t * (-0.18628806D + t * (0.27886807D + t * (-1.13520398D + t * (1.48851587D + t * (-0.82215223D + t * 0.17087277D)))))))));
<       return x >= 0.0D ? ans : 2.0D - ans;
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
24,31c5
<    private static double erfccheb(double z) {
<       double d = 0.0D;
<       double dd = 0.0D;
<       if (z < 0.0D) {
<          throw new IllegalArgumentException("erfccheb requires non-negative argument");
<       } else {
<          double t = 2.0D / (2.0D + z);
<          double ty = 4.0D * t - 2.0D;
---
> package smileModified;
33,35c7,49
<          for(int j = cof.length - 1; j > 0; --j) {
<             double tmp = d;
<             d = ty * d - dd + cof[j];
---
> public class ErfModified
> {
>     private static final double[] cof;
>     
>     static {
>         cof = new double[] { -1.3026537197817094, 0.6419697923564902, 0.019476473204185836, -0.00956151478680863, -9.46595344482036E-4, 3.66839497852761E-4, 4.2523324806907E-5, -2.0278578112534E-5, -1.624290004647E-6, 1.30365583558E-6, 1.5626441722E-8, -8.5238095915E-8, 6.529054439E-9, 5.059343495E-9, -9.91364156E-10, -2.27365122E-10, 9.6467911E-11, 2.394038E-12, -6.886027E-12, 8.94487E-13, 3.13092E-13, -1.12708E-13, 3.81E-16, 7.106E-15, -1.523E-15, -9.4E-17, 1.21E-16, -2.8E-17 };
>     }
>     
>     private ErfModified() {
>     }
>     
>     public static double erf(final double x) {
>         if (x >= 0.0) {
>             return 1.0 - erfccheb(x);
>         }
>         return erfccheb(-x) - 1.0;
>     }
>     
>     public static double erfc(final double x) {
>         if (x >= 0.0) {
>             return erfccheb(x);
>         }
>         return 2.0 - erfccheb(-x);
>     }
>     
>     public static double erfcc(final double x) {
>         final double z = Math.abs(x);
>         final double t = 2.0 / (2.0 + z);
>         final double ans = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));
>         return (x >= 0.0) ? ans : (2.0 - ans);
>     }
>     
>     private static double erfccheb(final double z) {
>         double d = 0.0;
>         double dd = 0.0;
>         if (z < 0.0) {
>             throw new IllegalArgumentException("erfccheb requires non-negative argument");
>         }
>         final double t = 2.0 / (2.0 + z);
>         final double ty = 4.0 * t - 2.0;
>         for (int j = ErfModified.cof.length - 1; j > 0; --j) {
>             final double tmp = d;
>             d = ty * d - dd + ErfModified.cof[j];
37,64c51,74
<          }
< 
<          return t * Math.exp(-z * z + 0.5D * (cof[0] + ty * d) - dd);
<       }
<    }
< 
<    public static double inverfc(double p) {
<       if (p >= 2.0D) {
<          return -100.0D;
<       } else if (p <= 0.0D) {
<          return 100.0D;
<       } else {
<          double pp = p < 1.0D ? p : 2.0D - p;
<          double t = Math.sqrt(-2.0D * Math.log(pp / 2.0D));
<          double x = -0.70711D * ((2.30753D + t * 0.27061D) / (1.0D + t * (0.99229D + t * 0.04481D)) - t);
< 
<          for(int j = 0; j < 2; ++j) {
<             double err = erfc(x) - pp;
<             x += err / (1.1283791670955126D * Math.exp(-x * x) - x * err);
<          }
< 
<          return p < 1.0D ? x : -x;
<       }
<    }
< 
<    public static double inverf(double p) {
<       return inverfc(1.0D - p);
<    }
---
>         }
>         return t * Math.exp(-z * z + 0.5 * (ErfModified.cof[0] + ty * d) - dd);
>     }
>     
>     public static double inverfc(final double p) {
>         if (p >= 2.0) {
>             return -100.0;
>         }
>         if (p <= 0.0) {
>             return 100.0;
>         }
>         final double pp = (p < 1.0) ? p : (2.0 - p);
>         final double t = Math.sqrt(-2.0 * Math.log(pp / 2.0));
>         double x = -0.70711 * ((2.30753 + t * 0.27061) / (1.0 + t * (0.99229 + t * 0.04481)) - t);
>         for (int j = 0; j < 2; ++j) {
>             final double err = erfc(x) - pp;
>             x += err / (1.1283791670955126 * Math.exp(-x * x) - x * err);
>         }
>         return (p < 1.0) ? x : (-x);
>     }
>     
>     public static double inverf(final double p) {
>         return inverfc(1.0 - p);
>     }
diff -r TrackAnalyzer_/smileModified/EVDJobModified.java procyon/smileModified/EVDJobModified.java
1,5c1,3
< package smileModified;
< 
< public enum EVDJobModified {
<    NO_VECTORS((byte)78),
<    VECTORS((byte)86);
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
7,11c5
<    private final byte lapack;
< 
<    private EVDJobModified(byte lapack) {
<       this.lapack = lapack;
<    }
---
> package smileModified;
13,15c7,20
<    public byte lapack() {
<       return this.lapack;
<    }
---
> public enum EVDJobModified
> {
>     NO_VECTORS("NO_VECTORS", 0, (byte)78), 
>     VECTORS("VECTORS", 1, (byte)86);
>     
>     private final byte lapack;
>     
>     private EVDJobModified(final String name, final int ordinal, final byte lapack) {
>         this.lapack = lapack;
>     }
>     
>     public byte lapack() {
>         return this.lapack;
>     }
diff -r TrackAnalyzer_/smileModified/ExponentialFamilyMixtureModified.java procyon/smileModified/ExponentialFamilyMixtureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import org.slf4j.Logger;
4a8
> import org.slf4j.Logger;
6,107c10,95
< public class ExponentialFamilyMixtureModified extends MixtureModified {
<    private static final long serialVersionUID = 2L;
<    private static final Logger logger = LoggerFactory.getLogger(ExponentialFamilyMixtureModified.class);
<    public final double L;
<    public final double bic;
< 
<    public ExponentialFamilyMixtureModified(MixtureModified.Component... components) {
<       this(0.0D, 1, components);
<    }
< 
<    ExponentialFamilyMixtureModified(double L, int n, MixtureModified.Component... components) {
<       super(components);
<       MixtureModified.Component[] var8 = components;
<       int var7 = components.length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          MixtureModified.Component component = var8[var6];
<          if (!(component.distribution instanceof ExponentialFamilyModified)) {
<             throw new IllegalArgumentException("Component " + component + " is not of exponential family.");
<          }
<       }
< 
<       this.L = L;
<       this.bic = L - 0.5D * (double)this.length() * Math.log((double)n);
<    }
< 
<    public static ExponentialFamilyMixtureModified fit(double[] x, MixtureModified.Component... components) {
<       return fit(x, components, 0.0D, 500, 1.0E-4D);
<    }
< 
<    public static ExponentialFamilyMixtureModified fit(double[] x, MixtureModified.Component[] components, double gamma, int maxIter, double tol) {
<       if (x.length < components.length / 2) {
<          throw new IllegalArgumentException("Too many components");
<       } else if (!(gamma < 0.0D) && !(gamma > 0.2D)) {
<          int n = x.length;
<          int k = components.length;
<          double[][] posteriori = new double[k][n];
<          double L = 0.0D;
<          double diff = Double.MAX_VALUE;
< 
<          for(int iter = 1; iter <= maxIter && diff > tol; ++iter) {
<             int j;
<             int i;
<             for(j = 0; j < k; ++j) {
<                MixtureModified.Component c = components[j];
< 
<                for(i = 0; i < n; ++i) {
<                   posteriori[j][i] = c.priori * c.distribution.p(x[i]);
<                }
<             }
< 
<             for(j = 0; j < n; ++j) {
<                double p = 0.0D;
< 
<                int i;
<                for(i = 0; i < k; ++i) {
<                   p += posteriori[i][j];
<                }
< 
<                for(i = 0; i < k; ++i) {
<                   posteriori[i][j] /= p;
<                }
< 
<                if (gamma > 0.0D) {
<                   for(i = 0; i < k; ++i) {
<                      posteriori[i][j] *= 1.0D + gamma * MathExModified.log2(posteriori[i][j]);
<                      if (Double.isNaN(posteriori[i][j]) || posteriori[i][j] < 0.0D) {
<                         posteriori[i][j] = 0.0D;
<                      }
<                   }
<                }
<             }
< 
<             double Z = 0.0D;
< 
<             for(i = 0; i < k; ++i) {
<                components[i] = ((ExponentialFamilyModified)components[i].distribution).M(x, posteriori[i]);
<                Z += components[i].priori;
<             }
< 
<             for(i = 0; i < k; ++i) {
<                components[i] = new MixtureModified.Component(components[i].priori / Z, components[i].distribution);
<             }
< 
<             double loglikelihood = 0.0D;
<             double[] var23 = x;
<             int var22 = x.length;
< 
<             for(int var21 = 0; var21 < var22; ++var21) {
<                double xi = var23[var21];
<                double p = 0.0D;
<                MixtureModified.Component[] var29 = components;
<                int var28 = components.length;
< 
<                for(int var27 = 0; var27 < var28; ++var27) {
<                   MixtureModified.Component c = var29[var27];
<                   p += c.priori * c.distribution.p(xi);
<                }
< 
<                if (p > 0.0D) {
<                   loglikelihood += Math.log(p);
<                }
---
> public class ExponentialFamilyMixtureModified extends MixtureModified
> {
>     private static final long serialVersionUID = 2L;
>     private static final Logger logger;
>     public final double L;
>     public final double bic;
>     
>     static {
>         logger = LoggerFactory.getLogger((Class)ExponentialFamilyMixtureModified.class);
>     }
>     
>     public ExponentialFamilyMixtureModified(final Component... components) {
>         this(0.0, 1, components);
>     }
>     
>     ExponentialFamilyMixtureModified(final double L, final int n, final Component... components) {
>         super(components);
>         for (final Component component : components) {
>             if (!(component.distribution instanceof ExponentialFamilyModified)) {
>                 throw new IllegalArgumentException("Component " + component + " is not of exponential family.");
>             }
>         }
>         this.L = L;
>         this.bic = L - 0.5 * this.length() * Math.log(n);
>     }
>     
>     public static ExponentialFamilyMixtureModified fit(final double[] x, final Component... components) {
>         return fit(x, components, 0.0, 500, 1.0E-4);
>     }
>     
>     public static ExponentialFamilyMixtureModified fit(final double[] x, final Component[] components, final double gamma, final int maxIter, final double tol) {
>         if (x.length < components.length / 2) {
>             throw new IllegalArgumentException("Too many components");
>         }
>         if (gamma < 0.0 || gamma > 0.2) {
>             throw new IllegalArgumentException("Invalid regularization factor gamma.");
>         }
>         final int n = x.length;
>         final int k = components.length;
>         final double[][] posteriori = new double[k][n];
>         double L = 0.0;
>         double diff = Double.MAX_VALUE;
>         for (int iter = 1; iter <= maxIter && diff > tol; ++iter) {
>             for (int i = 0; i < k; ++i) {
>                 final Component c = components[i];
>                 for (int j = 0; j < n; ++j) {
>                     posteriori[i][j] = c.priori * c.distribution.p(x[j]);
>                 }
>             }
>             for (int l = 0; l < n; ++l) {
>                 double p = 0.0;
>                 for (int m = 0; m < k; ++m) {
>                     p += posteriori[m][l];
>                 }
>                 for (final double[] array : posteriori) {
>                     final int n2 = l;
>                     array[n2] /= p;
>                 }
>                 if (gamma > 0.0) {
>                     for (int m = 0; m < k; ++m) {
>                         final double[] array2 = posteriori[m];
>                         final int n3 = l;
>                         array2[n3] *= 1.0 + gamma * MathExModified.log2(posteriori[m][l]);
>                         if (Double.isNaN(posteriori[m][l]) || posteriori[m][l] < 0.0) {
>                             posteriori[m][l] = 0.0;
>                         }
>                     }
>                 }
>             }
>             double Z = 0.0;
>             for (int i2 = 0; i2 < k; ++i2) {
>                 components[i2] = ((ExponentialFamilyModified)components[i2].distribution).M(x, posteriori[i2]);
>                 Z += components[i2].priori;
>             }
>             for (int i2 = 0; i2 < k; ++i2) {
>                 components[i2] = new Component(components[i2].priori / Z, components[i2].distribution);
>             }
>             double loglikelihood = 0.0;
>             for (final double xi : x) {
>                 double p2 = 0.0;
>                 for (final Component c2 : components) {
>                     p2 += c2.priori * c2.distribution.p(xi);
>                 }
>                 if (p2 > 0.0) {
>                     loglikelihood += Math.log(p2);
>                 }
109d96
< 
113c100
<                logger.info(String.format("The log-likelihood after %d iterations: %.4f", iter, loglikelihood));
---
>                 ExponentialFamilyMixtureModified.logger.info(String.format("The log-likelihood after %d iterations: %.4f", iter, L));
115,121c102,104
<          }
< 
<          return new ExponentialFamilyMixtureModified(L, x.length, components);
<       } else {
<          throw new IllegalArgumentException("Invalid regularization factor gamma.");
<       }
<    }
---
>         }
>         return new ExponentialFamilyMixtureModified(L, x.length, components);
>     }
diff -r TrackAnalyzer_/smileModified/ExponentialFamilyModified.java procyon/smileModified/ExponentialFamilyModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,4c7,9
< public interface ExponentialFamilyModified {
<    MixtureModified.Component M(double[] var1, double[] var2);
---
> public interface ExponentialFamilyModified
> {
>     MixtureModified.Component M(final double[] p0, final double[] p1);
diff -r TrackAnalyzer_/smileModified/GaussianDistributionModified.java procyon/smileModified/GaussianDistributionModified.java
1,78c1,3
< package smileModified;
< 
< public class GaussianDistributionModified extends AbstractDistributionModified implements ExponentialFamilyModified {
<    private static final long serialVersionUID = 2L;
<    private static final double LOG2PIE_2 = Math.log(17.079468445347132D) / 2.0D;
<    private static final double LOG2PI_2 = Math.log(6.283185307179586D) / 2.0D;
<    private static final GaussianDistributionModified singleton = new GaussianDistributionModified(0.0D, 1.0D);
<    public final double mu;
<    public final double sigma;
<    private final double variance;
<    private final double entropy;
<    private final double pdfConstant;
<    private double z1 = Double.NaN;
< 
<    public GaussianDistributionModified(double mu, double sigma) {
<       this.mu = mu;
<       this.sigma = sigma;
<       this.variance = sigma * sigma;
<       this.entropy = Math.log(sigma) + LOG2PIE_2;
<       this.pdfConstant = Math.log(sigma) + LOG2PI_2;
<    }
< 
<    public static GaussianDistributionModified fit(double[] data) {
<       double mu = MathExModified.mean(data);
<       double sigma = MathExModified.sd(data);
<       return new GaussianDistributionModified(mu, sigma);
<    }
< 
<    public static GaussianDistributionModified getInstance() {
<       return singleton;
<    }
< 
<    public int length() {
<       return 2;
<    }
< 
<    public double mean() {
<       return this.mu;
<    }
< 
<    public double variance() {
<       return this.variance;
<    }
< 
<    public double sd() {
<       return this.sigma;
<    }
< 
<    public double entropy() {
<       return this.entropy;
<    }
< 
<    public String toString() {
<       return String.format("Gaussian Distribution(%.4f, %.4f)", this.mu, this.sigma);
<    }
< 
<    public double rand() {
<       double z0;
<       if (Double.isNaN(this.z1)) {
<          double x;
<          double y;
<          double r;
<          do {
<             x = MathExModified.random(-1.0D, 1.0D);
<             y = MathExModified.random(-1.0D, 1.0D);
<             r = x * x + y * y;
<          } while(r >= 1.0D);
< 
<          double z = Math.sqrt(-2.0D * Math.log(r) / r);
<          this.z1 = x * z;
<          z0 = y * z;
<       } else {
<          z0 = this.z1;
<          this.z1 = Double.NaN;
<       }
< 
<       return this.mu + this.sigma * z0;
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
80,178c5
<    public double inverseCDF() {
<       double a0 = 2.50662823884D;
<       double a1 = -18.61500062529D;
<       double a2 = 41.39119773534D;
<       double a3 = -25.44106049637D;
<       double b0 = -8.4735109309D;
<       double b1 = 23.08336743743D;
<       double b2 = -21.06224101826D;
<       double b3 = 3.13082909833D;
<       double c0 = 0.3374754822726147D;
<       double c1 = 0.9761690190917186D;
<       double c2 = 0.1607979714918209D;
<       double c3 = 0.0276438810333863D;
<       double c4 = 0.0038405729373609D;
<       double c5 = 3.951896511919E-4D;
<       double c6 = 3.21767881768E-5D;
<       double c7 = 2.888167364E-7D;
<       double c8 = 3.960315187E-7D;
< 
<       double u;
<       for(u = MathExModified.random(); u == 0.0D; u = MathExModified.random()) {
<       }
< 
<       double y = u - 0.5D;
<       double r;
<       double x;
<       if (Math.abs(y) < 0.42D) {
<          r = y * y;
<          x = y * (((-25.44106049637D * r + 41.39119773534D) * r + -18.61500062529D) * r + 2.50662823884D) / ((((3.13082909833D * r + -21.06224101826D) * r + 23.08336743743D) * r + -8.4735109309D) * r + 1.0D);
<       } else {
<          r = u;
<          if (y > 0.0D) {
<             r = 1.0D - u;
<          }
< 
<          r = Math.log(-Math.log(r));
<          x = 0.3374754822726147D + r * (0.9761690190917186D + r * (0.1607979714918209D + r * (0.0276438810333863D + r * (0.0038405729373609D + r * (3.951896511919E-4D + r * (3.21767881768E-5D + r * (2.888167364E-7D + r * 3.960315187E-7D)))))));
<          if (y < 0.0D) {
<             x = -x;
<          }
<       }
< 
<       return this.mu + this.sigma * x;
<    }
< 
<    public double p(double x) {
<       if (this.sigma == 0.0D) {
<          return x == this.mu ? 1.0D : 0.0D;
<       } else {
<          return Math.exp(this.logp(x));
<       }
<    }
< 
<    public double logp(double x) {
<       if (this.sigma == 0.0D) {
<          return x == this.mu ? 0.0D : Double.NEGATIVE_INFINITY;
<       } else {
<          double d = x - this.mu;
<          return -0.5D * d * d / this.variance - this.pdfConstant;
<       }
<    }
< 
<    public double cdf(double x) {
<       if (this.sigma == 0.0D) {
<          return x < this.mu ? 0.0D : 1.0D;
<       } else {
<          return 0.5D * ErfModified.erfc(-0.7071067811865476D * (x - this.mu) / this.sigma);
<       }
<    }
< 
<    public double quantile(double p) {
<       if (!(p < 0.0D) && !(p > 1.0D)) {
<          if (this.sigma == 0.0D) {
<             return p < 1.0D ? this.mu - 1.0E-10D : this.mu;
<          } else {
<             return -1.4142135623730951D * this.sigma * ErfModified.inverfc(2.0D * p) + this.mu;
<          }
<       } else {
<          throw new IllegalArgumentException("Invalid p: " + p);
<       }
<    }
< 
<    public MixtureModified.Component M(double[] x, double[] posteriori) {
<       double alpha = 0.0D;
<       double mean = 0.0D;
<       double sd = 0.0D;
< 
<       int i;
<       for(i = 0; i < x.length; ++i) {
<          alpha += posteriori[i];
<          mean += x[i] * posteriori[i];
<       }
< 
<       mean /= alpha;
< 
<       for(i = 0; i < x.length; ++i) {
<          double d = x[i] - mean;
<          sd += d * d * posteriori[i];
<       }
---
> package smileModified;
180,182c7,202
<       sd = Math.sqrt(sd / alpha);
<       return new MixtureModified.Component(alpha, new GaussianDistributionModified(mean, sd));
<    }
---
> public class GaussianDistributionModified extends AbstractDistributionModified implements ExponentialFamilyModified
> {
>     private static final long serialVersionUID = 2L;
>     private static final double LOG2PIE_2;
>     private static final double LOG2PI_2;
>     private static final GaussianDistributionModified singleton;
>     public final double mu;
>     public final double sigma;
>     private final double variance;
>     private final double entropy;
>     private final double pdfConstant;
>     private double z1;
>     
>     static {
>         LOG2PIE_2 = Math.log(17.079468445347132) / 2.0;
>         LOG2PI_2 = Math.log(6.283185307179586) / 2.0;
>         singleton = new GaussianDistributionModified(0.0, 1.0);
>     }
>     
>     public GaussianDistributionModified(final double mu, final double sigma) {
>         this.z1 = Double.NaN;
>         this.mu = mu;
>         this.sigma = sigma;
>         this.variance = sigma * sigma;
>         this.entropy = Math.log(sigma) + GaussianDistributionModified.LOG2PIE_2;
>         this.pdfConstant = Math.log(sigma) + GaussianDistributionModified.LOG2PI_2;
>     }
>     
>     public static GaussianDistributionModified fit(final double[] data) {
>         final double mu = MathExModified.mean(data);
>         final double sigma = MathExModified.sd(data);
>         return new GaussianDistributionModified(mu, sigma);
>     }
>     
>     public static GaussianDistributionModified getInstance() {
>         return GaussianDistributionModified.singleton;
>     }
>     
>     @Override
>     public int length() {
>         return 2;
>     }
>     
>     @Override
>     public double mean() {
>         return this.mu;
>     }
>     
>     @Override
>     public double variance() {
>         return this.variance;
>     }
>     
>     @Override
>     public double sd() {
>         return this.sigma;
>     }
>     
>     @Override
>     public double entropy() {
>         return this.entropy;
>     }
>     
>     @Override
>     public String toString() {
>         return String.format("Gaussian Distribution(%.4f, %.4f)", this.mu, this.sigma);
>     }
>     
>     @Override
>     public double rand() {
>         double z2;
>         if (Double.isNaN(this.z1)) {
>             double r;
>             double x;
>             double y;
>             do {
>                 x = MathExModified.random(-1.0, 1.0);
>                 y = MathExModified.random(-1.0, 1.0);
>                 r = x * x + y * y;
>             } while (r >= 1.0);
>             final double z = Math.sqrt(-2.0 * Math.log(r) / r);
>             this.z1 = x * z;
>             z2 = y * z;
>         }
>         else {
>             z2 = this.z1;
>             this.z1 = Double.NaN;
>         }
>         return this.mu + this.sigma * z2;
>     }
>     
>     public double inverseCDF() {
>         final double a0 = 2.50662823884;
>         final double a2 = -18.61500062529;
>         final double a3 = 41.39119773534;
>         final double a4 = -25.44106049637;
>         final double b0 = -8.4735109309;
>         final double b2 = 23.08336743743;
>         final double b3 = -21.06224101826;
>         final double b4 = 3.13082909833;
>         final double c0 = 0.3374754822726147;
>         final double c2 = 0.9761690190917186;
>         final double c3 = 0.1607979714918209;
>         final double c4 = 0.0276438810333863;
>         final double c5 = 0.0038405729373609;
>         final double c6 = 3.951896511919E-4;
>         final double c7 = 3.21767881768E-5;
>         final double c8 = 2.888167364E-7;
>         final double c9 = 3.960315187E-7;
>         double u;
>         for (u = MathExModified.random(); u == 0.0; u = MathExModified.random()) {}
>         final double y = u - 0.5;
>         double x;
>         if (Math.abs(y) < 0.42) {
>             final double r = y * y;
>             x = y * (((-25.44106049637 * r + 41.39119773534) * r - 18.61500062529) * r + 2.50662823884) / ((((3.13082909833 * r - 21.06224101826) * r + 23.08336743743) * r - 8.4735109309) * r + 1.0);
>         }
>         else {
>             double r = u;
>             if (y > 0.0) {
>                 r = 1.0 - u;
>             }
>             r = Math.log(-Math.log(r));
>             x = 0.3374754822726147 + r * (0.9761690190917186 + r * (0.1607979714918209 + r * (0.0276438810333863 + r * (0.0038405729373609 + r * (3.951896511919E-4 + r * (3.21767881768E-5 + r * (2.888167364E-7 + r * 3.960315187E-7)))))));
>             if (y < 0.0) {
>                 x = -x;
>             }
>         }
>         return this.mu + this.sigma * x;
>     }
>     
>     @Override
>     public double p(final double x) {
>         if (this.sigma != 0.0) {
>             return Math.exp(this.logp(x));
>         }
>         if (x == this.mu) {
>             return 1.0;
>         }
>         return 0.0;
>     }
>     
>     @Override
>     public double logp(final double x) {
>         if (this.sigma != 0.0) {
>             final double d = x - this.mu;
>             return -0.5 * d * d / this.variance - this.pdfConstant;
>         }
>         if (x == this.mu) {
>             return 0.0;
>         }
>         return Double.NEGATIVE_INFINITY;
>     }
>     
>     @Override
>     public double cdf(final double x) {
>         if (this.sigma != 0.0) {
>             return 0.5 * ErfModified.erfc(-0.7071067811865476 * (x - this.mu) / this.sigma);
>         }
>         if (x < this.mu) {
>             return 0.0;
>         }
>         return 1.0;
>     }
>     
>     @Override
>     public double quantile(final double p) {
>         if (p < 0.0 || p > 1.0) {
>             throw new IllegalArgumentException("Invalid p: " + p);
>         }
>         if (this.sigma != 0.0) {
>             return -1.4142135623730951 * this.sigma * ErfModified.inverfc(2.0 * p) + this.mu;
>         }
>         if (p < 1.0) {
>             return this.mu - 1.0E-10;
>         }
>         return this.mu;
>     }
>     
>     @Override
>     public MixtureModified.Component M(final double[] x, final double[] posteriori) {
>         double alpha = 0.0;
>         double mean = 0.0;
>         double sd = 0.0;
>         for (int i = 0; i < x.length; ++i) {
>             alpha += posteriori[i];
>             mean += x[i] * posteriori[i];
>         }
>         mean /= alpha;
>         for (int i = 0; i < x.length; ++i) {
>             final double d = x[i] - mean;
>             sd += d * d * posteriori[i];
>         }
>         sd = Math.sqrt(sd / alpha);
>         return new MixtureModified.Component(alpha, new GaussianDistributionModified(mean, sd));
>     }
diff -r TrackAnalyzer_/smileModified/GaussianMixtureModified.java procyon/smileModified/GaussianMixtureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import org.slf4j.Logger;
4a8
> import org.slf4j.Logger;
6,56c10,56
< public class GaussianMixtureModified extends ExponentialFamilyMixtureModified {
<    private static final long serialVersionUID = 2L;
<    private static final Logger logger = LoggerFactory.getLogger(GaussianMixtureModified.class);
< 
<    public GaussianMixtureModified(MixtureModified.Component... components) {
<       this(0.0D, 1, components);
<    }
< 
<    private GaussianMixtureModified(double L, int n, MixtureModified.Component... components) {
<       super(L, n, components);
<       MixtureModified.Component[] var8 = components;
<       int var7 = components.length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          MixtureModified.Component component = var8[var6];
<          if (!(component.distribution instanceof GaussianDistributionModified)) {
<             throw new IllegalArgumentException("Component " + component + " is not of Gaussian distribution.");
<          }
<       }
< 
<    }
< 
<    public static GaussianMixtureModified fit(int k, double[] x) {
<       if (k < 2) {
<          throw new IllegalArgumentException("Invalid number of components in the mixture.");
<       } else {
<          double min = MathExModified.min(x);
<          double max = MathExModified.max(x);
<          double step = (max - min) / (double)(k + 1);
<          MixtureModified.Component[] components = new MixtureModified.Component[k];
< 
<          for(int i = 0; i < k; ++i) {
<             components[i] = new MixtureModified.Component(1.0D / (double)k, new GaussianDistributionModified(min += step, step));
<          }
< 
<          ExponentialFamilyMixtureModified model = fit(x, components);
<          return new GaussianMixtureModified(model.L, x.length, model.components);
<       }
<    }
< 
<    public static GaussianMixtureModified fit(double[] x) {
<       if (x.length < 20) {
<          throw new IllegalArgumentException("Too few samples.");
<       } else {
<          GaussianMixtureModified mixture = new GaussianMixtureModified(new MixtureModified.Component[]{new MixtureModified.Component(1.0D, GaussianDistributionModified.fit(x))});
<          double bic = mixture.bic(x);
<          logger.info(String.format("The BIC of %s = %.4f", mixture, bic));
< 
<          for(int k = 2; k < x.length / 10; ++k) {
<             ExponentialFamilyMixtureModified model = fit(k, x);
<             logger.info(String.format("The BIC of %s = %.4f", model, model.bic));
---
> public class GaussianMixtureModified extends ExponentialFamilyMixtureModified
> {
>     private static final long serialVersionUID = 2L;
>     private static final Logger logger;
>     
>     static {
>         logger = LoggerFactory.getLogger((Class)GaussianMixtureModified.class);
>     }
>     
>     public GaussianMixtureModified(final Component... components) {
>         this(0.0, 1, components);
>     }
>     
>     private GaussianMixtureModified(final double L, final int n, final Component... components) {
>         super(L, n, components);
>         for (final Component component : components) {
>             if (!(component.distribution instanceof GaussianDistributionModified)) {
>                 throw new IllegalArgumentException("Component " + component + " is not of Gaussian distribution.");
>             }
>         }
>     }
>     
>     public static GaussianMixtureModified fit(final int k, final double[] x) {
>         if (k < 2) {
>             throw new IllegalArgumentException("Invalid number of components in the mixture.");
>         }
>         double min = MathExModified.min(x);
>         final double max = MathExModified.max(x);
>         final double step = (max - min) / (k + 1);
>         final Component[] components = new Component[k];
>         for (int i = 0; i < k; ++i) {
>             components[i] = new Component(1.0 / k, new GaussianDistributionModified(min += step, step));
>         }
>         final ExponentialFamilyMixtureModified model = ExponentialFamilyMixtureModified.fit(x, components);
>         return new GaussianMixtureModified(model.L, x.length, model.components);
>     }
>     
>     public static GaussianMixtureModified fit(final double[] x) {
>         if (x.length < 20) {
>             throw new IllegalArgumentException("Too few samples.");
>         }
>         GaussianMixtureModified mixture = new GaussianMixtureModified(new Component[] { new Component(1.0, GaussianDistributionModified.fit(x)) });
>         double bic = mixture.bic(x);
>         GaussianMixtureModified.logger.info(String.format("The BIC of %s = %.4f", mixture, bic));
>         for (int k = 2; k < x.length / 10; ++k) {
>             final ExponentialFamilyMixtureModified model = fit(k, x);
>             GaussianMixtureModified.logger.info(String.format("The BIC of %s = %.4f", model, model.bic));
58c58
<                break;
---
>                 break;
60d59
< 
63,91c62,86
<          }
< 
<          return mixture;
<       }
<    }
< 
<    private static MixtureModified.Component[] split(MixtureModified.Component... components) {
<       int k = components.length;
<       int index = -1;
<       double maxSigma = Double.NEGATIVE_INFINITY;
< 
<       for(int i = 0; i < k; ++i) {
<          MixtureModified.Component c = components[i];
<          if (c.distribution.sd() > maxSigma) {
<             maxSigma = c.distribution.sd();
<             index = i;
<          }
<       }
< 
<       MixtureModified.Component component = components[index];
<       double priori = component.priori / 2.0D;
<       double delta = component.distribution.sd();
<       double mu = component.distribution.mean();
<       MixtureModified.Component[] mixture = new MixtureModified.Component[k + 1];
<       System.arraycopy(components, 0, mixture, 0, k);
<       mixture[index] = new MixtureModified.Component(priori, new GaussianDistributionModified(mu + delta / 2.0D, delta));
<       mixture[k] = new MixtureModified.Component(priori, new GaussianDistributionModified(mu - delta / 2.0D, delta));
<       return mixture;
<    }
---
>         }
>         return mixture;
>     }
>     
>     private static Component[] split(final Component... components) {
>         final int k = components.length;
>         int index = -1;
>         double maxSigma = Double.NEGATIVE_INFINITY;
>         for (int i = 0; i < k; ++i) {
>             final Component c = components[i];
>             if (c.distribution.sd() > maxSigma) {
>                 maxSigma = c.distribution.sd();
>                 index = i;
>             }
>         }
>         final Component component = components[index];
>         final double priori = component.priori / 2.0;
>         final double delta = component.distribution.sd();
>         final double mu = component.distribution.mean();
>         final Component[] mixture = new Component[k + 1];
>         System.arraycopy(components, 0, mixture, 0, k);
>         mixture[index] = new Component(priori, new GaussianDistributionModified(mu + delta / 2.0, delta));
>         mixture[k] = new Component(priori, new GaussianDistributionModified(mu - delta / 2.0, delta));
>         return mixture;
>     }
diff -r TrackAnalyzer_/smileModified/IMatrixModified.java procyon/smileModified/IMatrixModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
4,9d7
< import java.io.LineNumberReader;
< import java.io.Serializable;
< import java.nio.file.Files;
< import java.nio.file.Path;
< import java.text.ParseException;
< import java.util.ArrayList;
11a10,11
> import java.util.ArrayList;
> import java.text.ParseException;
13c13,16
< import org.slf4j.Logger;
---
> import java.io.Reader;
> import java.io.LineNumberReader;
> import java.nio.file.Files;
> import java.nio.file.Path;
14a18,19
> import org.slf4j.Logger;
> import java.io.Serializable;
16,207c21,208
< public abstract class IMatrixModified implements Cloneable, Serializable {
<    private static final Logger logger = LoggerFactory.getLogger(IMatrixModified.class);
<    private String[] rowNames;
<    private String[] colNames;
< 
<    public abstract int nrow();
< 
<    public abstract int ncol();
< 
<    public abstract long size();
< 
<    public String[] rowNames() {
<       return this.rowNames;
<    }
< 
<    public void rowNames(String[] names) {
<       if (names != null && names.length != this.nrow()) {
<          throw new IllegalArgumentException(String.format("Invalid row names length: %d != %d", names.length, this.nrow()));
<       } else {
<          this.rowNames = names;
<       }
<    }
< 
<    public String rowName(int i) {
<       return this.rowNames[i];
<    }
< 
<    public String[] colNames() {
<       return this.colNames;
<    }
< 
<    public void colNames(String[] names) {
<       if (names != null && names.length != this.ncol()) {
<          throw new IllegalArgumentException(String.format("Invalid column names length: %d != %d", names.length, this.ncol()));
<       } else {
<          this.colNames = names;
<       }
<    }
< 
<    public String colName(int i) {
<       return this.colNames[i];
<    }
< 
<    public String toString() {
<       return this.toString(false);
<    }
< 
<    public String toString(boolean full) {
<       return full ? this.toString(this.nrow(), this.ncol()) : this.toString(7, 7);
<    }
< 
<    public String toString(int m, int n) {
<       StringBuilder sb = new StringBuilder(this.nrow() + " x " + this.ncol() + "\n");
<       m = Math.min(m, this.nrow());
<       n = Math.min(n, this.ncol());
<       String newline = n < this.ncol() ? "  ...\n" : "\n";
<       int i;
<       if (this.colNames != null) {
<          if (this.rowNames != null) {
<             sb.append("            ");
<          }
< 
<          for(i = 0; i < n; ++i) {
<             sb.append(String.format(" %12.12s", this.colNames[i]));
<          }
< 
<          sb.append(newline);
<       }
< 
<       for(i = 0; i < m; ++i) {
<          if (this.rowNames != null) {
<             sb.append(String.format("%-12.12s", this.rowNames[i]));
<          }
< 
<          for(int j = 0; j < n; ++j) {
<             sb.append(String.format(" %12.12s", this.str(i, j)));
<          }
< 
<          sb.append(newline);
<       }
< 
<       if (m < this.nrow()) {
<          sb.append("  ...\n");
<       }
< 
<       return sb.toString();
<    }
< 
<    private String str(int i, int j) {
<       return StringsModified.format(this.get(i, j), true);
<    }
< 
<    public abstract void mv(TransposeModified var1, double var2, double[] var4, double var5, double[] var7);
< 
<    public double[] mv(double[] x) {
<       double[] y = new double[this.nrow()];
<       this.mv(TransposeModified.NO_TRANSPOSE, 1.0D, x, 0.0D, y);
<       return y;
<    }
< 
<    public void mv(double[] x, double[] y) {
<       this.mv(TransposeModified.NO_TRANSPOSE, 1.0D, x, 0.0D, y);
<    }
< 
<    public void mv(double alpha, double[] x, double beta, double[] y) {
<       this.mv(TransposeModified.NO_TRANSPOSE, alpha, x, beta, y);
<    }
< 
<    public abstract void mv(double[] var1, int var2, int var3);
< 
<    public double[] tv(double[] x) {
<       double[] y = new double[this.ncol()];
<       this.mv(TransposeModified.TRANSPOSE, 1.0D, x, 0.0D, y);
<       return y;
<    }
< 
<    public void tv(double[] x, double[] y) {
<       this.mv(TransposeModified.TRANSPOSE, 1.0D, x, 0.0D, y);
<    }
< 
<    public void tv(double alpha, double[] x, double beta, double[] y) {
<       this.mv(TransposeModified.TRANSPOSE, alpha, x, beta, y);
<    }
< 
<    public abstract void tv(double[] var1, int var2, int var3);
< 
<    static int ld(int n) {
<       int elementSize = 4;
<       return n <= 256 / elementSize ? n : ((n * elementSize + 511) / 512 * 512 + 64) / elementSize;
<    }
< 
<    static TransposeModified flip(TransposeModified trans) {
<       return trans == TransposeModified.NO_TRANSPOSE ? TransposeModified.TRANSPOSE : TransposeModified.NO_TRANSPOSE;
<    }
< 
<    public void set(int i, int j, double x) {
<       throw new UnsupportedOperationException();
<    }
< 
<    public void update(int i, int j, double x) {
<       this.set(i, j, x);
<    }
< 
<    public double get(int i, int j) {
<       throw new UnsupportedOperationException();
<    }
< 
<    public double apply(int i, int j) {
<       return this.get(i, j);
<    }
< 
<    public double[] diag() {
<       int n = Math.min(this.nrow(), this.ncol());
<       double[] d = new double[n];
< 
<       for(int i = 0; i < n; ++i) {
<          d[i] = this.get(i, i);
<       }
< 
<       return d;
<    }
< 
<    public double trace() {
<       int n = Math.min(this.nrow(), this.ncol());
<       double t = 0.0D;
< 
<       for(int i = 0; i < n; ++i) {
<          t += this.get(i, i);
<       }
< 
<       return t;
<    }
< 
<    public double eigen(double[] v) {
<       return this.eigen(v, 0.0D, Math.max(1.0E-6D, (double)this.nrow() * MathExModified.EPSILON), Math.max(20, 2 * this.nrow()));
<    }
< 
<    public double eigen(double[] v, double p, double tol, int maxIter) {
<       if (this.nrow() != this.ncol()) {
<          throw new IllegalArgumentException("Matrix is not square.");
<       } else if (tol <= 0.0D) {
<          throw new IllegalArgumentException("Invalid tolerance: " + tol);
<       } else if (maxIter <= 0) {
<          throw new IllegalArgumentException("Invalid maximum number of iterations: " + maxIter);
<       } else {
<          int n = this.nrow();
<          tol = Math.max(tol, MathExModified.EPSILON * (double)n);
<          double[] z = new double[n];
<          double lambda = this.power(v, z, p);
< 
<          for(int iter = 1; iter <= maxIter; ++iter) {
<             double l = lambda;
---
> public abstract class IMatrixModified implements Cloneable, Serializable
> {
>     private static final Logger logger;
>     private String[] rowNames;
>     private String[] colNames;
>     
>     static {
>         logger = LoggerFactory.getLogger((Class)IMatrixModified.class);
>     }
>     
>     public abstract int nrow();
>     
>     public abstract int ncol();
>     
>     public abstract long size();
>     
>     public String[] rowNames() {
>         return this.rowNames;
>     }
>     
>     public void rowNames(final String[] names) {
>         if (names != null && names.length != this.nrow()) {
>             throw new IllegalArgumentException(String.format("Invalid row names length: %d != %d", names.length, this.nrow()));
>         }
>         this.rowNames = names;
>     }
>     
>     public String rowName(final int i) {
>         return this.rowNames[i];
>     }
>     
>     public String[] colNames() {
>         return this.colNames;
>     }
>     
>     public void colNames(final String[] names) {
>         if (names != null && names.length != this.ncol()) {
>             throw new IllegalArgumentException(String.format("Invalid column names length: %d != %d", names.length, this.ncol()));
>         }
>         this.colNames = names;
>     }
>     
>     public String colName(final int i) {
>         return this.colNames[i];
>     }
>     
>     @Override
>     public String toString() {
>         return this.toString(false);
>     }
>     
>     public String toString(final boolean full) {
>         return full ? this.toString(this.nrow(), this.ncol()) : this.toString(7, 7);
>     }
>     
>     public String toString(int m, int n) {
>         final StringBuilder sb = new StringBuilder(String.valueOf(this.nrow()) + " x " + this.ncol() + "\n");
>         m = Math.min(m, this.nrow());
>         n = Math.min(n, this.ncol());
>         final String newline = (n < this.ncol()) ? "  ...\n" : "\n";
>         if (this.colNames != null) {
>             if (this.rowNames != null) {
>                 sb.append("            ");
>             }
>             for (int j = 0; j < n; ++j) {
>                 sb.append(String.format(" %12.12s", this.colNames[j]));
>             }
>             sb.append(newline);
>         }
>         for (int i = 0; i < m; ++i) {
>             if (this.rowNames != null) {
>                 sb.append(String.format("%-12.12s", this.rowNames[i]));
>             }
>             for (int k = 0; k < n; ++k) {
>                 sb.append(String.format(" %12.12s", this.str(i, k)));
>             }
>             sb.append(newline);
>         }
>         if (m < this.nrow()) {
>             sb.append("  ...\n");
>         }
>         return sb.toString();
>     }
>     
>     private String str(final int i, final int j) {
>         return StringsModified.format(this.get(i, j), true);
>     }
>     
>     public abstract void mv(final TransposeModified p0, final double p1, final double[] p2, final double p3, final double[] p4);
>     
>     public double[] mv(final double[] x) {
>         final double[] y = new double[this.nrow()];
>         this.mv(TransposeModified.NO_TRANSPOSE, 1.0, x, 0.0, y);
>         return y;
>     }
>     
>     public void mv(final double[] x, final double[] y) {
>         this.mv(TransposeModified.NO_TRANSPOSE, 1.0, x, 0.0, y);
>     }
>     
>     public void mv(final double alpha, final double[] x, final double beta, final double[] y) {
>         this.mv(TransposeModified.NO_TRANSPOSE, alpha, x, beta, y);
>     }
>     
>     public abstract void mv(final double[] p0, final int p1, final int p2);
>     
>     public double[] tv(final double[] x) {
>         final double[] y = new double[this.ncol()];
>         this.mv(TransposeModified.TRANSPOSE, 1.0, x, 0.0, y);
>         return y;
>     }
>     
>     public void tv(final double[] x, final double[] y) {
>         this.mv(TransposeModified.TRANSPOSE, 1.0, x, 0.0, y);
>     }
>     
>     public void tv(final double alpha, final double[] x, final double beta, final double[] y) {
>         this.mv(TransposeModified.TRANSPOSE, alpha, x, beta, y);
>     }
>     
>     public abstract void tv(final double[] p0, final int p1, final int p2);
>     
>     static int ld(final int n) {
>         final int elementSize = 4;
>         if (n <= 256 / elementSize) {
>             return n;
>         }
>         return ((n * elementSize + 511) / 512 * 512 + 64) / elementSize;
>     }
>     
>     static TransposeModified flip(final TransposeModified trans) {
>         return (trans == TransposeModified.NO_TRANSPOSE) ? TransposeModified.TRANSPOSE : TransposeModified.NO_TRANSPOSE;
>     }
>     
>     public void set(final int i, final int j, final double x) {
>         throw new UnsupportedOperationException();
>     }
>     
>     public void update(final int i, final int j, final double x) {
>         this.set(i, j, x);
>     }
>     
>     public double get(final int i, final int j) {
>         throw new UnsupportedOperationException();
>     }
>     
>     public double apply(final int i, final int j) {
>         return this.get(i, j);
>     }
>     
>     public double[] diag() {
>         final int n = Math.min(this.nrow(), this.ncol());
>         final double[] d = new double[n];
>         for (int i = 0; i < n; ++i) {
>             d[i] = this.get(i, i);
>         }
>         return d;
>     }
>     
>     public double trace() {
>         final int n = Math.min(this.nrow(), this.ncol());
>         double t = 0.0;
>         for (int i = 0; i < n; ++i) {
>             t += this.get(i, i);
>         }
>         return t;
>     }
>     
>     public double eigen(final double[] v) {
>         return this.eigen(v, 0.0, Math.max(1.0E-6, this.nrow() * MathExModified.EPSILON), Math.max(20, 2 * this.nrow()));
>     }
>     
>     public double eigen(final double[] v, final double p, double tol, final int maxIter) {
>         if (this.nrow() != this.ncol()) {
>             throw new IllegalArgumentException("Matrix is not square.");
>         }
>         if (tol <= 0.0) {
>             throw new IllegalArgumentException("Invalid tolerance: " + tol);
>         }
>         if (maxIter <= 0) {
>             throw new IllegalArgumentException("Invalid maximum number of iterations: " + maxIter);
>         }
>         final int n = this.nrow();
>         tol = Math.max(tol, MathExModified.EPSILON * n);
>         final double[] z = new double[n];
>         double lambda = this.power(v, z, p);
>         for (int iter = 1; iter <= maxIter; ++iter) {
>             final double l = lambda;
209c210
<             double eps = Math.abs(lambda - l);
---
>             final double eps = Math.abs(lambda - l);
211c212
<                logger.trace(String.format("Largest eigenvalue after %3d power iterations: %.4f", iter, lambda + p));
---
>                 IMatrixModified.logger.trace(String.format("Largest eigenvalue after %3d power iterations: %.4f", iter, lambda + p));
213d213
< 
215,216c215,216
<                logger.info(String.format("Largest eigenvalue after %3d power iterations: %.4f", iter, lambda + p));
<                return lambda + p;
---
>                 IMatrixModified.logger.info(String.format("Largest eigenvalue after %3d power iterations: %.4f", iter, lambda + p));
>                 return lambda + p;
218,321c218,281
<          }
< 
<          logger.info(String.format("Largest eigenvalue after %3d power iterations: %.4f", maxIter, lambda + p));
<          logger.error("Power iteration exceeded the maximum number of iterations.");
<          return lambda + p;
<       }
<    }
< 
<    private double power(double[] x, double[] y, double p) {
<       this.mv(x, y);
<       if (p != 0.0D) {
<          for(int i = 0; i < y.length; ++i) {
<             y[i] -= p * x[i];
<          }
<       }
< 
<       double lambda = y[0];
< 
<       int i;
<       for(i = 1; i < y.length; ++i) {
<          if (Math.abs(y[i]) > Math.abs(lambda)) {
<             lambda = y[i];
<          }
<       }
< 
<       for(i = 0; i < y.length; ++i) {
<          x[i] = y[i] / lambda;
<       }
< 
<       return lambda;
<    }
< 
<    public static IMatrixModified market(Path path) throws IOException, ParseException {
<       Throwable var1 = null;
<       Object var2 = null;
< 
<       try {
<          LineNumberReader reader = new LineNumberReader(Files.newBufferedReader(path));
< 
<          MatrixModified var40;
<          label1105: {
<             SymmMatrixModified var41;
<             label1106: {
<                label1107: {
<                   SparseMatrixModified var10000;
<                   try {
<                      Scanner scanner = new Scanner(reader);
< 
<                      try {
<                         String header = scanner.next();
<                         if (!header.equals("%%MatrixMarket")) {
<                            throw new ParseException("Invalid Matrix Market file header", reader.getLineNumber());
<                         }
< 
<                         String object = scanner.next();
<                         if (!object.equals("matrix")) {
<                            throw new UnsupportedOperationException("The object is not a matrix file: " + object);
<                         }
< 
<                         String format = scanner.next();
<                         String field = scanner.next();
<                         if (field.equals("complex") || field.equals("pattern")) {
<                            throw new UnsupportedOperationException("No support of complex or pattern matrix");
<                         }
< 
<                         String symmetry = scanner.nextLine().trim();
<                         if (symmetry.equals("Hermitian")) {
<                            throw new UnsupportedOperationException("No support of Hermitian matrix");
<                         }
< 
<                         boolean symmetric = symmetry.equals("symmetric");
<                         boolean skew = symmetry.equals("skew-symmetric");
< 
<                         String line;
<                         for(line = scanner.nextLine(); line.startsWith("%"); line = scanner.nextLine()) {
<                         }
< 
<                         Scanner s;
<                         int nrow;
<                         int ncol;
<                         int k;
<                         if (format.equals("array")) {
<                            s = new Scanner(line);
<                            nrow = s.nextInt();
<                            ncol = s.nextInt();
<                            MatrixModified matrix = new MatrixModified(nrow, ncol);
< 
<                            for(int j = 0; j < ncol; ++j) {
<                               for(k = 0; k < nrow; ++k) {
<                                  double x = scanner.nextDouble();
<                                  matrix.set(k, j, x);
<                               }
<                            }
< 
<                            if (symmetric) {
<                               matrix.uplo(UPLOModified.LOWER);
<                            }
< 
<                            var40 = matrix;
<                            break label1105;
<                         }
< 
<                         if (!format.equals("coordinate")) {
<                            throw new ParseException("Invalid Matrix Market format: " + format, 0);
---
>         }
>         IMatrixModified.logger.info(String.format("Largest eigenvalue after %3d power iterations: %.4f", maxIter, lambda + p));
>         IMatrixModified.logger.error("Power iteration exceeded the maximum number of iterations.");
>         return lambda + p;
>     }
>     
>     private double power(final double[] x, final double[] y, final double p) {
>         this.mv(x, y);
>         if (p != 0.0) {
>             for (int i = 0; i < y.length; ++i) {
>                 final int n = i;
>                 y[n] -= p * x[i];
>             }
>         }
>         double lambda = y[0];
>         for (int j = 1; j < y.length; ++j) {
>             if (Math.abs(y[j]) > Math.abs(lambda)) {
>                 lambda = y[j];
>             }
>         }
>         for (int j = 0; j < y.length; ++j) {
>             x[j] = y[j] / lambda;
>         }
>         return lambda;
>     }
>     
>     public static IMatrixModified market(final Path path) throws IOException, ParseException {
>         Throwable t = null;
>         try {
>             final LineNumberReader reader = new LineNumberReader(Files.newBufferedReader(path));
>             try {
>                 final Scanner scanner = new Scanner(reader);
>                 try {
>                     final String header = scanner.next();
>                     if (!header.equals("%%MatrixMarket")) {
>                         throw new ParseException("Invalid Matrix Market file header", reader.getLineNumber());
>                     }
>                     final String object = scanner.next();
>                     if (!object.equals("matrix")) {
>                         throw new UnsupportedOperationException("The object is not a matrix file: " + object);
>                     }
>                     final String format = scanner.next();
>                     final String field = scanner.next();
>                     if (field.equals("complex") || field.equals("pattern")) {
>                         throw new UnsupportedOperationException("No support of complex or pattern matrix");
>                     }
>                     final String symmetry = scanner.nextLine().trim();
>                     if (symmetry.equals("Hermitian")) {
>                         throw new UnsupportedOperationException("No support of Hermitian matrix");
>                     }
>                     final boolean symmetric = symmetry.equals("symmetric");
>                     final boolean skew = symmetry.equals("skew-symmetric");
>                     String line;
>                     for (line = scanner.nextLine(); line.startsWith("%"); line = scanner.nextLine()) {}
>                     if (format.equals("array")) {
>                         final Scanner s = new Scanner(line);
>                         final int nrow = s.nextInt();
>                         final int ncol = s.nextInt();
>                         final MatrixModified matrix = new MatrixModified(nrow, ncol);
>                         for (int j = 0; j < ncol; ++j) {
>                             for (int i = 0; i < nrow; ++i) {
>                                 final double x = scanner.nextDouble();
>                                 matrix.set(i, j, x);
>                             }
323,352c283,284
< 
<                         s = new Scanner(line);
<                         nrow = s.nextInt();
<                         ncol = s.nextInt();
<                         int nz = s.nextInt();
<                         int i;
<                         String[] tokens;
<                         int i;
<                         double x;
<                         if (symmetric && nz == nrow * (nrow + 1) / 2) {
<                            if (nrow != ncol) {
<                               throw new IllegalStateException(String.format("Symmetric matrix is not square: %d != %d", nrow, ncol));
<                            }
< 
<                            SymmMatrixModified matrix = new SymmMatrixModified(UPLOModified.LOWER, nrow);
< 
<                            for(k = 0; k < nz; ++k) {
<                               tokens = scanner.nextLine().trim().split("\\s+");
<                               if (tokens.length != 3) {
<                                  throw new ParseException("Invalid data line: " + line, reader.getLineNumber());
<                               }
< 
<                               i = Integer.parseInt(tokens[0]) - 1;
<                               i = Integer.parseInt(tokens[1]) - 1;
<                               x = Double.parseDouble(tokens[2]);
<                               matrix.set(i, i, x);
<                            }
< 
<                            var41 = matrix;
<                            break label1106;
---
>                         if (symmetric) {
>                             matrix.uplo(UPLOModified.LOWER);
354,376c286,288
< 
<                         if (skew && nz == nrow * (nrow + 1) / 2) {
<                            if (nrow != ncol) {
<                               throw new IllegalStateException(String.format("Skew-symmetric matrix is not square: %d != %d", nrow, ncol));
<                            }
< 
<                            MatrixModified matrix = new MatrixModified(nrow, ncol);
< 
<                            for(k = 0; k < nz; ++k) {
<                               tokens = scanner.nextLine().trim().split("\\s+");
<                               if (tokens.length != 3) {
<                                  throw new ParseException("Invalid data line: " + line, reader.getLineNumber());
<                               }
< 
<                               i = Integer.parseInt(tokens[0]) - 1;
<                               i = Integer.parseInt(tokens[1]) - 1;
<                               x = Double.parseDouble(tokens[2]);
<                               matrix.set(i, i, x);
<                               matrix.set(i, i, -x);
<                            }
< 
<                            var40 = matrix;
<                            break label1107;
---
>                         final MatrixModified matrixModified = matrix;
>                         if (scanner != null) {
>                             scanner.close();
378,384c290,291
< 
<                         int[] colSize = new int[ncol];
<                         List<SparseArrayModified> rows = new ArrayList();
< 
<                         int k;
<                         for(k = 0; k < nrow; ++k) {
<                            rows.add(new SparseArrayModified());
---
>                         if (reader != null) {
>                             reader.close();
386,408c293,315
< 
<                         int var10002;
<                         for(k = 0; k < nz; ++k) {
<                            String[] tokens = scanner.nextLine().trim().split("\\s+");
<                            if (tokens.length != 3) {
<                               throw new ParseException("Invalid data line: " + line, reader.getLineNumber());
<                            }
< 
<                            i = Integer.parseInt(tokens[0]) - 1;
<                            int j = Integer.parseInt(tokens[1]) - 1;
<                            double x = Double.parseDouble(tokens[2]);
<                            SparseArrayModified row = (SparseArrayModified)rows.get(i);
<                            row.set(j, x);
<                            var10002 = colSize[j]++;
<                            if (symmetric) {
<                               row = (SparseArrayModified)rows.get(j);
<                               row.set(i, x);
<                               var10002 = colSize[i]++;
<                            } else if (skew) {
<                               row = (SparseArrayModified)rows.get(j);
<                               row.set(i, -x);
<                               var10002 = colSize[i]++;
<                            }
---
>                         return matrixModified;
>                     }
>                     if (!format.equals("coordinate")) {
>                         throw new ParseException("Invalid Matrix Market format: " + format, 0);
>                     }
>                     final Scanner s = new Scanner(line);
>                     final int nrow = s.nextInt();
>                     final int ncol = s.nextInt();
>                     int nz = s.nextInt();
>                     if (symmetric && nz == nrow * (nrow + 1) / 2) {
>                         if (nrow != ncol) {
>                             throw new IllegalStateException(String.format("Symmetric matrix is not square: %d != %d", nrow, ncol));
>                         }
>                         final SymmMatrixModified matrix2 = new SymmMatrixModified(UPLOModified.LOWER, nrow);
>                         for (int k = 0; k < nz; ++k) {
>                             final String[] tokens = scanner.nextLine().trim().split("\\s+");
>                             if (tokens.length != 3) {
>                                 throw new ParseException("Invalid data line: " + line, reader.getLineNumber());
>                             }
>                             final int l = Integer.parseInt(tokens[0]) - 1;
>                             final int m = Integer.parseInt(tokens[1]) - 1;
>                             final double x2 = Double.parseDouble(tokens[2]);
>                             matrix2.set(l, m, x2);
410,415c317,319
< 
<                         int[] pos = new int[ncol];
<                         int[] colIndex = new int[ncol + 1];
< 
<                         for(i = 0; i < ncol; ++i) {
<                            colIndex[i + 1] = colIndex[i] + colSize[i];
---
>                         final SymmMatrixModified symmMatrixModified = matrix2;
>                         if (scanner != null) {
>                             scanner.close();
417,419c321,322
< 
<                         if (symmetric || skew) {
<                            nz *= 2;
---
>                         if (reader != null) {
>                             reader.close();
421,441c324,404
< 
<                         int[] rowIndex = new int[nz];
<                         double[] x = new double[nz];
<                         int i = 0;
< 
<                         while(true) {
<                            if (i >= nrow) {
<                               var10000 = new SparseMatrixModified(nrow, ncol, x, rowIndex, colIndex);
<                               break;
<                            }
< 
<                            int j;
<                            for(Iterator var56 = ((SparseArrayModified)rows.get(i)).iterator(); var56.hasNext(); var10002 = pos[j]++) {
<                               SparseArrayModified.Entry e = (SparseArrayModified.Entry)var56.next();
<                               j = e.i;
<                               int k = colIndex[j] + pos[j];
<                               rowIndex[k] = i;
<                               x[k] = e.x;
<                            }
< 
<                            ++i;
---
>                         return symmMatrixModified;
>                     }
>                     else {
>                         if (!skew || nz != nrow * (nrow + 1) / 2) {
>                             final int[] colSize = new int[ncol];
>                             final List<SparseArrayModified> rows = new ArrayList<SparseArrayModified>();
>                             for (int i2 = 0; i2 < nrow; ++i2) {
>                                 rows.add(new SparseArrayModified());
>                             }
>                             for (int k2 = 0; k2 < nz; ++k2) {
>                                 final String[] tokens2 = scanner.nextLine().trim().split("\\s+");
>                                 if (tokens2.length != 3) {
>                                     throw new ParseException("Invalid data line: " + line, reader.getLineNumber());
>                                 }
>                                 final int i3 = Integer.parseInt(tokens2[0]) - 1;
>                                 final int j2 = Integer.parseInt(tokens2[1]) - 1;
>                                 final double x3 = Double.parseDouble(tokens2[2]);
>                                 SparseArrayModified row = rows.get(i3);
>                                 row.set(j2, x3);
>                                 final int[] array = colSize;
>                                 final int n = j2;
>                                 ++array[n];
>                                 if (symmetric) {
>                                     row = rows.get(j2);
>                                     row.set(i3, x3);
>                                     final int[] array2 = colSize;
>                                     final int n2 = i3;
>                                     ++array2[n2];
>                                 }
>                                 else if (skew) {
>                                     row = rows.get(j2);
>                                     row.set(i3, -x3);
>                                     final int[] array3 = colSize;
>                                     final int n3 = i3;
>                                     ++array3[n3];
>                                 }
>                             }
>                             final int[] pos = new int[ncol];
>                             final int[] colIndex = new int[ncol + 1];
>                             for (int i3 = 0; i3 < ncol; ++i3) {
>                                 colIndex[i3 + 1] = colIndex[i3] + colSize[i3];
>                             }
>                             if (symmetric || skew) {
>                                 nz *= 2;
>                             }
>                             final int[] rowIndex = new int[nz];
>                             final double[] x4 = new double[nz];
>                             for (int i4 = 0; i4 < nrow; ++i4) {
>                                 for (final SparseArrayModified.Entry e : rows.get(i4)) {
>                                     final int j3 = e.i;
>                                     final int k3 = colIndex[j3] + pos[j3];
>                                     rowIndex[k3] = i4;
>                                     x4[k3] = e.x;
>                                     final int[] array4 = pos;
>                                     final int n4 = j3;
>                                     ++array4[n4];
>                                 }
>                             }
>                             final SparseMatrixModified sparseMatrixModified = new SparseMatrixModified(nrow, ncol, x4, rowIndex, colIndex);
>                             if (scanner != null) {
>                                 scanner.close();
>                             }
>                             if (reader != null) {
>                                 reader.close();
>                             }
>                             return sparseMatrixModified;
>                         }
>                         if (nrow != ncol) {
>                             throw new IllegalStateException(String.format("Skew-symmetric matrix is not square: %d != %d", nrow, ncol));
>                         }
>                         final MatrixModified matrix3 = new MatrixModified(nrow, ncol);
>                         for (int k = 0; k < nz; ++k) {
>                             final String[] tokens = scanner.nextLine().trim().split("\\s+");
>                             if (tokens.length != 3) {
>                                 throw new ParseException("Invalid data line: " + line, reader.getLineNumber());
>                             }
>                             final int l = Integer.parseInt(tokens[0]) - 1;
>                             final int m = Integer.parseInt(tokens[1]) - 1;
>                             final double x2 = Double.parseDouble(tokens[2]);
>                             matrix3.set(l, m, x2);
>                             matrix3.set(m, l, -x2);
443c406
<                      } finally {
---
>                         final MatrixModified matrixModified2 = matrix3;
445c408
<                            scanner.close();
---
>                             scanner.close();
447,474c410,420
< 
<                      }
<                   } catch (Throwable var38) {
<                      if (var1 == null) {
<                         var1 = var38;
<                      } else if (var1 != var38) {
<                         var1.addSuppressed(var38);
<                      }
< 
<                      if (reader != null) {
<                         reader.close();
<                      }
< 
<                      throw var1;
<                   }
< 
<                   if (reader != null) {
<                      reader.close();
<                   }
< 
<                   return var10000;
<                }
< 
<                if (reader != null) {
<                   reader.close();
<                }
< 
<                return var40;
---
>                         if (reader != null) {
>                             reader.close();
>                         }
>                         return matrixModified2;
>                     }
>                 }
>                 finally {
>                     if (scanner != null) {
>                         scanner.close();
>                     }
>                 }
476,478c422,435
< 
<             if (reader != null) {
<                reader.close();
---
>             finally {
>                 if (t == null) {
>                     final Throwable exception;
>                     t = exception;
>                 }
>                 else {
>                     final Throwable exception;
>                     if (t != exception) {
>                         t.addSuppressed(exception);
>                     }
>                 }
>                 if (reader != null) {
>                     reader.close();
>                 }
480,524c437,479
< 
<             return var41;
<          }
< 
<          if (reader != null) {
<             reader.close();
<          }
< 
<          return var40;
<       } catch (Throwable var39) {
<          if (var1 == null) {
<             var1 = var39;
<          } else if (var1 != var39) {
<             var1.addSuppressed(var39);
<          }
< 
<          throw var1;
<       }
<    }
< 
<    public IMatrixModified square() {
<       return new IMatrixModified.Square(this);
<    }
< 
<    public IMatrixModified.Preconditioner Jacobi() {
<       double[] diag = this.diag();
<       return (b, x) -> {
<          int n = diag.length;
< 
<          for(int i = 0; i < n; ++i) {
<             x[i] = diag[i] != 0.0D ? b[i] / diag[i] : b[i];
<          }
< 
<       };
<    }
< 
<    public double solve(double[] b, double[] x) {
<       return this.solve(b, x, this.Jacobi(), 1.0E-6D, 1, 2 * Math.max(this.nrow(), this.ncol()));
<    }
< 
<    public double solve(double[] b, double[] x, IMatrixModified.Preconditioner P, double tol, int itol, int maxIter) {
<       if (tol <= 0.0D) {
<          throw new IllegalArgumentException("Invalid tolerance: " + tol);
<       } else if (itol >= 1 && itol <= 4) {
<          if (maxIter <= 0) {
---
>         }
>         finally {
>             if (t == null) {
>                 final Throwable exception2;
>                 t = exception2;
>             }
>             else {
>                 final Throwable exception2;
>                 if (t != exception2) {
>                     t.addSuppressed(exception2);
>                 }
>             }
>         }
>     }
>     
>     public IMatrixModified square() {
>         return new Square(this);
>     }
>     
>     public Preconditioner Jacobi() {
>         final double[] diag = this.diag();
>         final Object o;
>         int n;
>         int i;
>         return (b, x) -> {
>             for (n = o.length, i = 0; i < n; ++i) {
>                 x[i] = ((o[i] != 0.0) ? (b[i] / o[i]) : b[i]);
>             }
>         };
>     }
>     
>     public double solve(final double[] b, final double[] x) {
>         return this.solve(b, x, this.Jacobi(), 1.0E-6, 1, 2 * Math.max(this.nrow(), this.ncol()));
>     }
>     
>     public double solve(final double[] b, final double[] x, final Preconditioner P, final double tol, final int itol, final int maxIter) {
>         if (tol <= 0.0) {
>             throw new IllegalArgumentException("Invalid tolerance: " + tol);
>         }
>         if (itol < 1 || itol > 4) {
>             throw new IllegalArgumentException("Invalid itol: " + itol);
>         }
>         if (maxIter <= 0) {
526,542c481,508
<          } else {
<             double err = 0.0D;
<             double bkden = 1.0D;
<             double znrm = 0.0D;
<             int n = b.length;
<             double[] p = new double[n];
<             double[] pp = new double[n];
<             double[] r = new double[n];
<             double[] rr = new double[n];
<             double[] z = new double[n];
<             double[] zz = new double[n];
<             this.mv(x, r);
< 
<             int j;
<             for(j = 0; j < n; ++j) {
<                r[j] = b[j] - r[j];
<                rr[j] = r[j];
---
>         }
>         double err = 0.0;
>         double bkden = 1.0;
>         double znrm = 0.0;
>         final int n = b.length;
>         final double[] p = new double[n];
>         final double[] pp = new double[n];
>         final double[] r = new double[n];
>         final double[] rr = new double[n];
>         final double[] z = new double[n];
>         final double[] zz = new double[n];
>         this.mv(x, r);
>         for (int j = 0; j < n; ++j) {
>             rr[j] = (r[j] = b[j] - r[j]);
>         }
>         double bnrm;
>         if (itol == 1) {
>             bnrm = norm(b, itol);
>             P.asolve(r, z);
>         }
>         else if (itol == 2) {
>             P.asolve(b, z);
>             bnrm = norm(z, itol);
>             P.asolve(r, z);
>         }
>         else {
>             if (itol != 3 && itol != 4) {
>                 throw new IllegalArgumentException(String.format("Illegal itol: %d", itol));
544,545c510,552
< 
<             double bnrm;
---
>             P.asolve(b, z);
>             bnrm = norm(z, itol);
>             P.asolve(r, z);
>             znrm = norm(z, itol);
>         }
>         for (int iter = 1; iter <= maxIter; ++iter) {
>             P.asolve(rr, zz);
>             double bknum = 0.0;
>             for (int j = 0; j < n; ++j) {
>                 bknum += z[j] * rr[j];
>             }
>             if (iter == 1) {
>                 for (int j = 0; j < n; ++j) {
>                     p[j] = z[j];
>                     pp[j] = zz[j];
>                 }
>             }
>             else {
>                 final double bk = bknum / bkden;
>                 for (int j = 0; j < n; ++j) {
>                     p[j] = bk * p[j] + z[j];
>                     pp[j] = bk * pp[j] + zz[j];
>                 }
>             }
>             bkden = bknum;
>             this.mv(p, z);
>             double akden = 0.0;
>             for (int j = 0; j < n; ++j) {
>                 akden += z[j] * pp[j];
>             }
>             final double ak = bknum / akden;
>             this.tv(pp, zz);
>             for (int j = 0; j < n; ++j) {
>                 final int n2 = j;
>                 x[n2] += ak * p[j];
>                 final double[] array = r;
>                 final int n3 = j;
>                 array[n3] -= ak * z[j];
>                 final double[] array2 = rr;
>                 final int n4 = j;
>                 array2[n4] -= ak * zz[j];
>             }
>             P.asolve(r, z);
547,561c554
<                bnrm = norm(b, itol);
<                P.asolve(r, z);
<             } else if (itol == 2) {
<                P.asolve(b, z);
<                bnrm = norm(z, itol);
<                P.asolve(r, z);
<             } else {
<                if (itol != 3 && itol != 4) {
<                   throw new IllegalArgumentException(String.format("Illegal itol: %d", itol));
<                }
< 
<                P.asolve(b, z);
<                bnrm = norm(z, itol);
<                P.asolve(r, z);
<                znrm = norm(z, itol);
---
>                 err = norm(r, itol) / bnrm;
563,634c556,557
< 
<             for(int iter = 1; iter <= maxIter; ++iter) {
<                P.asolve(rr, zz);
<                double bknum = 0.0D;
< 
<                for(j = 0; j < n; ++j) {
<                   bknum += z[j] * rr[j];
<                }
< 
<                if (iter == 1) {
<                   for(j = 0; j < n; ++j) {
<                      p[j] = z[j];
<                      pp[j] = zz[j];
<                   }
<                } else {
<                   double bk = bknum / bkden;
< 
<                   for(j = 0; j < n; ++j) {
<                      p[j] = bk * p[j] + z[j];
<                      pp[j] = bk * pp[j] + zz[j];
<                   }
<                }
< 
<                bkden = bknum;
<                this.mv(p, z);
<                double akden = 0.0D;
< 
<                for(j = 0; j < n; ++j) {
<                   akden += z[j] * pp[j];
<                }
< 
<                double ak = bknum / akden;
<                this.tv(pp, zz);
< 
<                for(j = 0; j < n; ++j) {
<                   x[j] += ak * p[j];
<                   r[j] -= ak * z[j];
<                   rr[j] -= ak * zz[j];
<                }
< 
<                P.asolve(r, z);
<                if (itol == 1) {
<                   err = norm(r, itol) / bnrm;
<                } else if (itol == 2) {
<                   err = norm(z, itol) / bnrm;
<                } else if (itol == 3 || itol == 4) {
<                   double zm1nrm = znrm;
<                   znrm = norm(z, itol);
<                   if (!(Math.abs(zm1nrm - znrm) > MathExModified.EPSILON * znrm)) {
<                      err = znrm / bnrm;
<                      continue;
<                   }
< 
<                   double dxnrm = Math.abs(ak) * norm(p, itol);
<                   err = znrm / Math.abs(zm1nrm - znrm) * dxnrm;
<                   double xnrm = norm(x, itol);
<                   if (!(err <= 0.5D * xnrm)) {
<                      err = znrm / bnrm;
<                      continue;
<                   }
< 
<                   err /= xnrm;
<                }
< 
<                if (iter % 10 == 0) {
<                   logger.info(String.format("BCG: the error after %3d iterations: %.5g", iter, err));
<                }
< 
<                if (err <= tol) {
<                   logger.info(String.format("BCG: the error after %3d iterations: %.5g", iter, err));
<                   break;
<                }
---
>             else if (itol == 2) {
>                 err = norm(z, itol) / bnrm;
636,649c559,596
< 
<             return err;
<          }
<       } else {
<          throw new IllegalArgumentException("Invalid itol: " + itol);
<       }
<    }
< 
<    private static double norm(double[] x, int itol) {
<       int n = x.length;
<       if (itol > 3) {
<          int isamax = 0;
< 
<          for(int i = 0; i < n; ++i) {
---
>             else if (itol == 3 || itol == 4) {
>                 final double zm1nrm = znrm;
>                 znrm = norm(z, itol);
>                 if (Math.abs(zm1nrm - znrm) <= MathExModified.EPSILON * znrm) {
>                     err = znrm / bnrm;
>                     continue;
>                 }
>                 final double dxnrm = Math.abs(ak) * norm(p, itol);
>                 err = znrm / Math.abs(zm1nrm - znrm) * dxnrm;
>                 final double xnrm = norm(x, itol);
>                 if (err > 0.5 * xnrm) {
>                     err = znrm / bnrm;
>                     continue;
>                 }
>                 err /= xnrm;
>             }
>             if (iter % 10 == 0) {
>                 IMatrixModified.logger.info(String.format("BCG: the error after %3d iterations: %.5g", iter, err));
>             }
>             if (err <= tol) {
>                 IMatrixModified.logger.info(String.format("BCG: the error after %3d iterations: %.5g", iter, err));
>                 break;
>             }
>         }
>         return err;
>     }
>     
>     private static double norm(final double[] x, final int itol) {
>         final int n = x.length;
>         if (itol <= 3) {
>             double ans = 0.0;
>             for (final double v : x) {
>                 ans += v * v;
>             }
>             return Math.sqrt(ans);
>         }
>         int isamax = 0;
>         for (int i = 0; i < n; ++i) {
651c598
<                isamax = i;
---
>                 isamax = i;
653,726c600,668
<          }
< 
<          return Math.abs(x[isamax]);
<       } else {
<          double ans = 0.0D;
<          double[] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             double v = var9[var7];
<             ans += v * v;
<          }
< 
<          return Math.sqrt(ans);
<       }
<    }
< 
<    public interface Preconditioner {
<       void asolve(double[] var1, double[] var2);
<    }
< 
<    static class Square extends IMatrixModified {
<       private final IMatrixModified A;
<       private final int m;
<       private final int n;
<       private final double[] Ax;
< 
<       public Square(IMatrixModified A) {
<          this.A = A;
<          this.m = Math.max(A.nrow(), A.ncol());
<          this.n = Math.min(A.nrow(), A.ncol());
<          this.Ax = new double[this.m + this.n];
<       }
< 
<       public int nrow() {
<          return this.n;
<       }
< 
<       public int ncol() {
<          return this.n;
<       }
< 
<       public long size() {
<          return this.A.size();
<       }
< 
<       public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
<          if (this.A.nrow() >= this.A.ncol()) {
<             this.A.mv(x, this.Ax);
<             this.A.tv(alpha, this.Ax, beta, y);
<          } else {
<             this.A.tv(x, this.Ax);
<             this.A.mv(alpha, this.Ax, beta, y);
<          }
< 
<       }
< 
<       public void mv(double[] work, int inputOffset, int outputOffset) {
<          System.arraycopy(work, inputOffset, this.Ax, 0, this.n);
<          if (this.A.nrow() >= this.A.ncol()) {
<             this.A.mv(this.Ax, 0, this.n);
<             this.A.tv(this.Ax, this.n, 0);
<          } else {
<             this.A.tv(this.Ax, 0, this.n);
<             this.A.mv(this.Ax, this.n, 0);
<          }
< 
<          System.arraycopy(this.Ax, 0, work, outputOffset, this.n);
<       }
< 
<       public void tv(double[] work, int inputOffset, int outputOffset) {
<          this.mv(work, inputOffset, outputOffset);
<       }
<    }
---
>         }
>         return Math.abs(x[isamax]);
>     }
>     
>     static class Square extends IMatrixModified
>     {
>         private final IMatrixModified A;
>         private final int m;
>         private final int n;
>         private final double[] Ax;
>         
>         public Square(final IMatrixModified A) {
>             this.A = A;
>             this.m = Math.max(A.nrow(), A.ncol());
>             this.n = Math.min(A.nrow(), A.ncol());
>             this.Ax = new double[this.m + this.n];
>         }
>         
>         @Override
>         public int nrow() {
>             return this.n;
>         }
>         
>         @Override
>         public int ncol() {
>             return this.n;
>         }
>         
>         @Override
>         public long size() {
>             return this.A.size();
>         }
>         
>         @Override
>         public void mv(final TransposeModified trans, final double alpha, final double[] x, final double beta, final double[] y) {
>             if (this.A.nrow() >= this.A.ncol()) {
>                 this.A.mv(x, this.Ax);
>                 this.A.tv(alpha, this.Ax, beta, y);
>             }
>             else {
>                 this.A.tv(x, this.Ax);
>                 this.A.mv(alpha, this.Ax, beta, y);
>             }
>         }
>         
>         @Override
>         public void mv(final double[] work, final int inputOffset, final int outputOffset) {
>             System.arraycopy(work, inputOffset, this.Ax, 0, this.n);
>             if (this.A.nrow() >= this.A.ncol()) {
>                 this.A.mv(this.Ax, 0, this.n);
>                 this.A.tv(this.Ax, this.n, 0);
>             }
>             else {
>                 this.A.tv(this.Ax, 0, this.n);
>                 this.A.mv(this.Ax, this.n, 0);
>             }
>             System.arraycopy(this.Ax, 0, work, outputOffset, this.n);
>         }
>         
>         @Override
>         public void tv(final double[] work, final int inputOffset, final int outputOffset) {
>             this.mv(work, inputOffset, outputOffset);
>         }
>     }
>     
>     public interface Preconditioner
>     {
>         void asolve(final double[] p0, final double[] p1);
>     }
diff -r TrackAnalyzer_/smileModified/IntArrayListModified.java procyon/smileModified/IntArrayListModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,5d6
< import java.io.Serializable;
< import java.util.Arrays;
< import java.util.stream.Collectors;
6a8,12
> import java.util.stream.Collector;
> import java.util.stream.Collectors;
> import java.util.function.IntFunction;
> import java.util.Arrays;
> import java.io.Serializable;
8,96c14,103
< public final class IntArrayListModified implements Serializable {
<    private static final long serialVersionUID = 1L;
<    int[] data;
<    private int size;
< 
<    public IntArrayListModified() {
<       this(10);
<    }
< 
<    public IntArrayListModified(int capacity) {
<       this.data = new int[capacity];
<       this.size = 0;
<    }
< 
<    public IntArrayListModified(int[] values) {
<       this(Math.max(values.length, 10));
<       this.add(values);
<    }
< 
<    public String toString() {
<       return (String)Arrays.stream(this.data).limit((long)this.size).mapToObj(String::valueOf).collect(Collectors.joining(", ", "[", "]"));
<    }
< 
<    public IntStream stream() {
<       return IntStream.of(this.data).limit((long)this.size);
<    }
< 
<    public void ensureCapacity(int capacity) {
<       if (capacity > this.data.length) {
<          int newCap = Math.max(this.data.length << 1, capacity);
<          int[] tmp = new int[newCap];
<          System.arraycopy(this.data, 0, tmp, 0, this.data.length);
<          this.data = tmp;
<       }
< 
<    }
< 
<    public int size() {
<       return this.size;
<    }
< 
<    public boolean isEmpty() {
<       return this.size == 0;
<    }
< 
<    public void trim() {
<       if (this.data.length > this.size) {
<          this.data = this.toArray();
<       }
< 
<    }
< 
<    public void add(int val) {
<       this.ensureCapacity(this.size + 1);
<       this.data[this.size++] = val;
<    }
< 
<    public void add(IntArrayListModified vals) {
<       this.ensureCapacity(this.size + vals.size);
<       System.arraycopy(vals.data, 0, this.data, this.size, vals.size);
<       this.size += vals.size;
<    }
< 
<    public void add(int[] vals) {
<       this.ensureCapacity(this.size + vals.length);
<       System.arraycopy(vals, 0, this.data, this.size, vals.length);
<       this.size += vals.length;
<    }
< 
<    public int get(int index) {
<       return this.data[index];
<    }
< 
<    public void set(int index, int val) {
<       if (index >= 0 && index < this.size) {
<          this.data[index] = val;
<       } else {
<          throw new IndexOutOfBoundsException(String.valueOf(index));
<       }
<    }
< 
<    public void clear() {
<       this.size = 0;
<    }
< 
<    public int remove(int index) {
<       if (index >= 0 && index < this.size) {
<          int old = this.get(index);
<          if (index == 0) {
---
> public final class IntArrayListModified implements Serializable
> {
>     private static final long serialVersionUID = 1L;
>     int[] data;
>     private int size;
>     
>     public IntArrayListModified() {
>         this(10);
>     }
>     
>     public IntArrayListModified(final int capacity) {
>         this.data = new int[capacity];
>         this.size = 0;
>     }
>     
>     public IntArrayListModified(final int[] values) {
>         this(Math.max(values.length, 10));
>         this.add(values);
>     }
>     
>     @Override
>     public String toString() {
>         return Arrays.stream(this.data).limit(this.size).<Object>mapToObj((IntFunction<?>)String::valueOf).<String, ?>collect((Collector<? super Object, ?, String>)Collectors.joining(", ", "[", "]"));
>     }
>     
>     public IntStream stream() {
>         return IntStream.of(this.data).limit(this.size);
>     }
>     
>     public void ensureCapacity(final int capacity) {
>         if (capacity > this.data.length) {
>             final int newCap = Math.max(this.data.length << 1, capacity);
>             final int[] tmp = new int[newCap];
>             System.arraycopy(this.data, 0, tmp, 0, this.data.length);
>             this.data = tmp;
>         }
>     }
>     
>     public int size() {
>         return this.size;
>     }
>     
>     public boolean isEmpty() {
>         return this.size == 0;
>     }
>     
>     public void trim() {
>         if (this.data.length > this.size) {
>             this.data = this.toArray();
>         }
>     }
>     
>     public void add(final int val) {
>         this.ensureCapacity(this.size + 1);
>         this.data[this.size++] = val;
>     }
>     
>     public void add(final IntArrayListModified vals) {
>         this.ensureCapacity(this.size + vals.size);
>         System.arraycopy(vals.data, 0, this.data, this.size, vals.size);
>         this.size += vals.size;
>     }
>     
>     public void add(final int[] vals) {
>         this.ensureCapacity(this.size + vals.length);
>         System.arraycopy(vals, 0, this.data, this.size, vals.length);
>         this.size += vals.length;
>     }
>     
>     public int get(final int index) {
>         return this.data[index];
>     }
>     
>     public void set(final int index, final int val) {
>         if (index < 0 || index >= this.size) {
>             throw new IndexOutOfBoundsException(String.valueOf(index));
>         }
>         this.data[index] = val;
>     }
>     
>     public void clear() {
>         this.size = 0;
>     }
>     
>     public int remove(final int index) {
>         if (index < 0 || index >= this.size) {
>             throw new IndexOutOfBoundsException(String.valueOf(index));
>         }
>         final int old = this.get(index);
>         if (index == 0) {
98c105,106
<          } else if (index != this.size - 1) {
---
>         }
>         else if (index != this.size - 1) {
100,120c108,123
<          }
< 
<          --this.size;
<          return old;
<       } else {
<          throw new IndexOutOfBoundsException(String.valueOf(index));
<       }
<    }
< 
<    public int[] toArray() {
<       return this.toArray((int[])null);
<    }
< 
<    public int[] toArray(int[] dest) {
<       if (dest == null || dest.length < this.size()) {
<          dest = new int[this.size];
<       }
< 
<       System.arraycopy(this.data, 0, dest, 0, this.size);
<       return dest;
<    }
---
>         }
>         --this.size;
>         return old;
>     }
>     
>     public int[] toArray() {
>         return this.toArray(null);
>     }
>     
>     public int[] toArray(int[] dest) {
>         if (dest == null || dest.length < this.size()) {
>             dest = new int[this.size];
>         }
>         System.arraycopy(this.data, 0, dest, 0, this.size);
>         return dest;
>     }
diff -r TrackAnalyzer_/smileModified/IntPair.java procyon/smileModified/IntPair.java
1,10c1,3
< package smileModified;
< 
< public class IntPair {
<    public final int i;
<    public final int j;
< 
<    public IntPair(int i, int j) {
<       this.i = i;
<       this.j = j;
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
12,18c5
<    public int hashCode() {
<       return this.i * 31 + this.j;
<    }
< 
<    public String toString() {
<       return String.format("(%d, %d)", this.i, this.j);
<    }
---
> package smileModified;
20,27c7,34
<    public boolean equals(Object o) {
<       if (o instanceof IntPair) {
<          IntPair p = (IntPair)o;
<          return this.i == p.i && this.j == p.j;
<       } else {
<          return false;
<       }
<    }
---
> public class IntPair
> {
>     public final int i;
>     public final int j;
>     
>     public IntPair(final int i, final int j) {
>         this.i = i;
>         this.j = j;
>     }
>     
>     @Override
>     public int hashCode() {
>         return this.i * 31 + this.j;
>     }
>     
>     @Override
>     public String toString() {
>         return String.format("(%d, %d)", this.i, this.j);
>     }
>     
>     @Override
>     public boolean equals(final Object o) {
>         if (o instanceof IntPair) {
>             final IntPair p = (IntPair)o;
>             return this.i == p.i && this.j == p.j;
>         }
>         return false;
>     }
diff -r TrackAnalyzer_/smileModified/LAPACKModified.java procyon/smileModified/LAPACKModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import java.nio.DoubleBuffer;
5,6d7
< import java.nio.IntBuffer;
< import org.bytedeco.javacpp.DoublePointer;
7a9,11
> import org.bytedeco.javacpp.DoublePointer;
> import java.nio.IntBuffer;
> import java.nio.DoubleBuffer;
11,344c15,349
< public interface LAPACKModified {
<    LAPACKModified engine = getInstance();
< 
<    static LAPACKModified getInstance() {
<       LAPACKModified mkl = MKL();
<       return (LAPACKModified)(mkl != null ? mkl : new OpenBLASModified());
<    }
< 
<    static LAPACKModified MKL() {
<       Logger logger = LoggerFactory.getLogger(LAPACKModified.class);
< 
<       try {
<          Class<?> clazz = Class.forName("smile.math.blas.mkl.MKL");
<          logger.info("smile-mkl module is available.");
<          return (LAPACKModified)clazz.getDeclaredConstructor().newInstance();
<       } catch (Exception var2) {
<          logger.debug("Failed to create MKL instance: ", var2);
<          return null;
<       }
<    }
< 
<    int gesv(LayoutModified var1, int var2, int var3, double[] var4, int var5, int[] var6, double[] var7, int var8);
< 
<    int gesv(LayoutModified var1, int var2, int var3, DoubleBuffer var4, int var5, IntBuffer var6, DoubleBuffer var7, int var8);
< 
<    int gesv(LayoutModified var1, int var2, int var3, DoublePointer var4, int var5, IntPointer var6, DoublePointer var7, int var8);
< 
<    int gesv(LayoutModified var1, int var2, int var3, float[] var4, int var5, int[] var6, float[] var7, int var8);
< 
<    int gesv(LayoutModified var1, int var2, int var3, FloatBuffer var4, int var5, IntBuffer var6, FloatBuffer var7, int var8);
< 
<    int sysv(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int var6, int[] var7, double[] var8, int var9);
< 
<    int sysv(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, int var6, IntBuffer var7, DoubleBuffer var8, int var9);
< 
<    int sysv(LayoutModified var1, UPLOModified var2, int var3, int var4, DoublePointer var5, int var6, IntPointer var7, DoublePointer var8, int var9);
< 
<    int sysv(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int var6, int[] var7, float[] var8, int var9);
< 
<    int sysv(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, int var6, IntBuffer var7, FloatBuffer var8, int var9);
< 
<    int spsv(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int[] var6, double[] var7, int var8);
< 
<    int spsv(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, IntBuffer var6, DoubleBuffer var7, int var8);
< 
<    int spsv(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int[] var6, float[] var7, int var8);
< 
<    int spsv(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, IntBuffer var6, FloatBuffer var7, int var8);
< 
<    int posv(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8);
< 
<    int posv(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8);
< 
<    int posv(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8);
< 
<    int posv(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8);
< 
<    int ppsv(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, double[] var6, int var7);
< 
<    int ppsv(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, DoubleBuffer var6, int var7);
< 
<    int ppsv(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, float[] var6, int var7);
< 
<    int ppsv(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, FloatBuffer var6, int var7);
< 
<    int gbsv(LayoutModified var1, int var2, int var3, int var4, int var5, double[] var6, int var7, int[] var8, double[] var9, int var10);
< 
<    int gbsv(LayoutModified var1, int var2, int var3, int var4, int var5, DoubleBuffer var6, int var7, IntBuffer var8, DoubleBuffer var9, int var10);
< 
<    int gbsv(LayoutModified var1, int var2, int var3, int var4, int var5, float[] var6, int var7, int[] var8, float[] var9, int var10);
< 
<    int gbsv(LayoutModified var1, int var2, int var3, int var4, int var5, FloatBuffer var6, int var7, IntBuffer var8, FloatBuffer var9, int var10);
< 
<    int gels(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, double[] var6, int var7, double[] var8, int var9);
< 
<    int gels(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9);
< 
<    int gels(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, float[] var6, int var7, float[] var8, int var9);
< 
<    int gels(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, FloatBuffer var6, int var7, FloatBuffer var8, int var9);
< 
<    int gelsy(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8, int[] var9, double var10, int[] var12);
< 
<    int gelsy(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8, IntBuffer var9, double var10, IntBuffer var12);
< 
<    int gelsy(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8, int[] var9, float var10, int[] var11);
< 
<    int gelsy(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, IntBuffer var9, float var10, IntBuffer var11);
< 
<    int gelss(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8, double[] var9, double var10, int[] var12);
< 
<    int gelss(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, double var10, IntBuffer var12);
< 
<    int gelss(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8, float[] var9, float var10, int[] var11);
< 
<    int gelss(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, float var10, IntBuffer var11);
< 
<    int gelsd(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8, double[] var9, double var10, int[] var12);
< 
<    int gelsd(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, double var10, IntBuffer var12);
< 
<    int gelsd(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8, float[] var9, float var10, int[] var11);
< 
<    int gelsd(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, float var10, IntBuffer var11);
< 
<    int gglse(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8, double[] var9, double[] var10, double[] var11);
< 
<    int gglse(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, DoubleBuffer var10, DoubleBuffer var11);
< 
<    int gglse(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8, float[] var9, float[] var10, float[] var11);
< 
<    int gglse(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, FloatBuffer var10, FloatBuffer var11);
< 
<    int ggglm(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8, double[] var9, double[] var10, double[] var11);
< 
<    int ggglm(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, DoubleBuffer var10, DoubleBuffer var11);
< 
<    int ggglm(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8, float[] var9, float[] var10, float[] var11);
< 
<    int ggglm(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, FloatBuffer var10, FloatBuffer var11);
< 
<    int geev(LayoutModified var1, EVDJobModified var2, EVDJobModified var3, int var4, double[] var5, int var6, double[] var7, double[] var8, double[] var9, int var10, double[] var11, int var12);
< 
<    int geev(LayoutModified var1, EVDJobModified var2, EVDJobModified var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, DoubleBuffer var8, DoubleBuffer var9, int var10, DoubleBuffer var11, int var12);
< 
<    int geev(LayoutModified var1, EVDJobModified var2, EVDJobModified var3, int var4, DoublePointer var5, int var6, DoublePointer var7, DoublePointer var8, DoublePointer var9, int var10, DoublePointer var11, int var12);
< 
<    int geev(LayoutModified var1, EVDJobModified var2, EVDJobModified var3, int var4, float[] var5, int var6, float[] var7, float[] var8, float[] var9, int var10, float[] var11, int var12);
< 
<    int geev(LayoutModified var1, EVDJobModified var2, EVDJobModified var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, FloatBuffer var8, FloatBuffer var9, int var10, FloatBuffer var11, int var12);
< 
<    int syev(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, double[] var5, int var6, double[] var7);
< 
<    int syev(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7);
< 
<    int syev(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, float[] var5, int var6, float[] var7);
< 
<    int syev(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7);
< 
<    int syevd(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, double[] var5, int var6, double[] var7);
< 
<    int syevd(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7);
< 
<    int syevd(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, DoublePointer var5, int var6, DoublePointer var7);
< 
<    int syevd(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, float[] var5, int var6, float[] var7);
< 
<    int syevd(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7);
< 
<    int syevr(LayoutModified var1, EVDJobModified var2, EigenRangeModified var3, UPLOModified var4, int var5, double[] var6, int var7, double var8, double var10, int var12, int var13, double var14, int[] var16, double[] var17, double[] var18, int var19, int[] var20);
< 
<    int syevr(LayoutModified var1, EVDJobModified var2, EigenRangeModified var3, UPLOModified var4, int var5, DoubleBuffer var6, int var7, double var8, double var10, int var12, int var13, double var14, IntBuffer var16, DoubleBuffer var17, DoubleBuffer var18, int var19, IntBuffer var20);
< 
<    int syevr(LayoutModified var1, EVDJobModified var2, EigenRangeModified var3, UPLOModified var4, int var5, float[] var6, int var7, float var8, float var9, int var10, int var11, float var12, int[] var13, float[] var14, float[] var15, int var16, int[] var17);
< 
<    int syevr(LayoutModified var1, EVDJobModified var2, EigenRangeModified var3, UPLOModified var4, int var5, FloatBuffer var6, int var7, float var8, float var9, int var10, int var11, float var12, IntBuffer var13, FloatBuffer var14, FloatBuffer var15, int var16, IntBuffer var17);
< 
<    int gesvd(LayoutModified var1, SVDJobModified var2, SVDJobModified var3, int var4, int var5, double[] var6, int var7, double[] var8, double[] var9, int var10, double[] var11, int var12, double[] var13);
< 
<    int gesvd(LayoutModified var1, SVDJobModified var2, SVDJobModified var3, int var4, int var5, DoubleBuffer var6, int var7, DoubleBuffer var8, DoubleBuffer var9, int var10, DoubleBuffer var11, int var12, DoubleBuffer var13);
< 
<    int gesvd(LayoutModified var1, SVDJobModified var2, SVDJobModified var3, int var4, int var5, float[] var6, int var7, float[] var8, float[] var9, int var10, float[] var11, int var12, float[] var13);
< 
<    int gesvd(LayoutModified var1, SVDJobModified var2, SVDJobModified var3, int var4, int var5, FloatBuffer var6, int var7, FloatBuffer var8, FloatBuffer var9, int var10, FloatBuffer var11, int var12, FloatBuffer var13);
< 
<    int gesdd(LayoutModified var1, SVDJobModified var2, int var3, int var4, double[] var5, int var6, double[] var7, double[] var8, int var9, double[] var10, int var11);
< 
<    int gesdd(LayoutModified var1, SVDJobModified var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, DoubleBuffer var8, int var9, DoubleBuffer var10, int var11);
< 
<    int gesdd(LayoutModified var1, SVDJobModified var2, int var3, int var4, DoublePointer var5, int var6, DoublePointer var7, DoublePointer var8, int var9, DoublePointer var10, int var11);
< 
<    int gesdd(LayoutModified var1, SVDJobModified var2, int var3, int var4, float[] var5, int var6, float[] var7, float[] var8, int var9, float[] var10, int var11);
< 
<    int gesdd(LayoutModified var1, SVDJobModified var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, FloatBuffer var8, int var9, FloatBuffer var10, int var11);
< 
<    int getrf(LayoutModified var1, int var2, int var3, double[] var4, int var5, int[] var6);
< 
<    int getrf(LayoutModified var1, int var2, int var3, DoubleBuffer var4, int var5, IntBuffer var6);
< 
<    int getrf(LayoutModified var1, int var2, int var3, DoublePointer var4, int var5, IntPointer var6);
< 
<    int getrf(LayoutModified var1, int var2, int var3, float[] var4, int var5, int[] var6);
< 
<    int getrf(LayoutModified var1, int var2, int var3, FloatBuffer var4, int var5, IntBuffer var6);
< 
<    int getrf2(LayoutModified var1, int var2, int var3, double[] var4, int var5, int[] var6);
< 
<    int getrf2(LayoutModified var1, int var2, int var3, DoubleBuffer var4, int var5, IntBuffer var6);
< 
<    int getrf2(LayoutModified var1, int var2, int var3, float[] var4, int var5, int[] var6);
< 
<    int getrf2(LayoutModified var1, int var2, int var3, FloatBuffer var4, int var5, IntBuffer var6);
< 
<    int gbtrf(LayoutModified var1, int var2, int var3, int var4, int var5, double[] var6, int var7, int[] var8);
< 
<    int gbtrf(LayoutModified var1, int var2, int var3, int var4, int var5, DoubleBuffer var6, int var7, IntBuffer var8);
< 
<    int gbtrf(LayoutModified var1, int var2, int var3, int var4, int var5, float[] var6, int var7, int[] var8);
< 
<    int gbtrf(LayoutModified var1, int var2, int var3, int var4, int var5, FloatBuffer var6, int var7, IntBuffer var8);
< 
<    int sptrf(LayoutModified var1, UPLOModified var2, int var3, double[] var4, int[] var5);
< 
<    int sptrf(LayoutModified var1, UPLOModified var2, int var3, DoubleBuffer var4, IntBuffer var5);
< 
<    int sptrf(LayoutModified var1, UPLOModified var2, int var3, float[] var4, int[] var5);
< 
<    int sptrf(LayoutModified var1, UPLOModified var2, int var3, FloatBuffer var4, IntBuffer var5);
< 
<    int getrs(LayoutModified var1, TransposeModified var2, int var3, int var4, double[] var5, int var6, int[] var7, double[] var8, int var9);
< 
<    int getrs(LayoutModified var1, TransposeModified var2, int var3, int var4, DoubleBuffer var5, int var6, IntBuffer var7, DoubleBuffer var8, int var9);
< 
<    int getrs(LayoutModified var1, TransposeModified var2, int var3, int var4, DoublePointer var5, int var6, IntPointer var7, DoublePointer var8, int var9);
< 
<    int getrs(LayoutModified var1, TransposeModified var2, int var3, int var4, float[] var5, int var6, int[] var7, float[] var8, int var9);
< 
<    int getrs(LayoutModified var1, TransposeModified var2, int var3, int var4, FloatBuffer var5, int var6, IntBuffer var7, FloatBuffer var8, int var9);
< 
<    int gbtrs(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, double[] var7, int var8, int[] var9, double[] var10, int var11);
< 
<    int gbtrs(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, DoubleBuffer var7, int var8, IntBuffer var9, DoubleBuffer var10, int var11);
< 
<    int gbtrs(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, float[] var7, int var8, int[] var9, float[] var10, int var11);
< 
<    int gbtrs(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, FloatBuffer var7, int var8, IntBuffer var9, FloatBuffer var10, int var11);
< 
<    int sptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int[] var6, double[] var7, int var8);
< 
<    int sptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, IntBuffer var6, DoubleBuffer var7, int var8);
< 
<    int sptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, IntBuffer var6, FloatBuffer var7, int var8);
< 
<    int sptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int[] var6, float[] var7, int var8);
< 
<    int potrf(LayoutModified var1, UPLOModified var2, int var3, double[] var4, int var5);
< 
<    int potrf(LayoutModified var1, UPLOModified var2, int var3, DoubleBuffer var4, int var5);
< 
<    int potrf(LayoutModified var1, UPLOModified var2, int var3, DoublePointer var4, int var5);
< 
<    int potrf(LayoutModified var1, UPLOModified var2, int var3, float[] var4, int var5);
< 
<    int potrf(LayoutModified var1, UPLOModified var2, int var3, FloatBuffer var4, int var5);
< 
<    int potrf2(LayoutModified var1, UPLOModified var2, int var3, double[] var4, int var5);
< 
<    int potrf2(LayoutModified var1, UPLOModified var2, int var3, DoubleBuffer var4, int var5);
< 
<    int potrf2(LayoutModified var1, UPLOModified var2, int var3, float[] var4, int var5);
< 
<    int potrf2(LayoutModified var1, UPLOModified var2, int var3, FloatBuffer var4, int var5);
< 
<    int pbtrf(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int var6);
< 
<    int pbtrf(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, int var6);
< 
<    int pbtrf(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int var6);
< 
<    int pbtrf(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, int var6);
< 
<    int pptrf(LayoutModified var1, UPLOModified var2, int var3, double[] var4);
< 
<    int pptrf(LayoutModified var1, UPLOModified var2, int var3, DoubleBuffer var4);
< 
<    int pptrf(LayoutModified var1, UPLOModified var2, int var3, float[] var4);
< 
<    int pptrf(LayoutModified var1, UPLOModified var2, int var3, FloatBuffer var4);
< 
<    int potrs(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8);
< 
<    int potrs(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8);
< 
<    int potrs(LayoutModified var1, UPLOModified var2, int var3, int var4, DoublePointer var5, int var6, DoublePointer var7, int var8);
< 
<    int potrs(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8);
< 
<    int potrs(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8);
< 
<    int pbtrs(LayoutModified var1, UPLOModified var2, int var3, int var4, int var5, double[] var6, int var7, double[] var8, int var9);
< 
<    int pbtrs(LayoutModified var1, UPLOModified var2, int var3, int var4, int var5, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9);
< 
<    int pbtrs(LayoutModified var1, UPLOModified var2, int var3, int var4, int var5, float[] var6, int var7, float[] var8, int var9);
< 
<    int pbtrs(LayoutModified var1, UPLOModified var2, int var3, int var4, int var5, FloatBuffer var6, int var7, FloatBuffer var8, int var9);
< 
<    int pptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, double[] var6, int var7);
< 
<    int pptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, DoubleBuffer var6, int var7);
< 
<    int pptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, float[] var6, int var7);
< 
<    int pptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, FloatBuffer var6, int var7);
< 
<    int geqrf(LayoutModified var1, int var2, int var3, double[] var4, int var5, double[] var6);
< 
<    int geqrf(LayoutModified var1, int var2, int var3, DoubleBuffer var4, int var5, DoubleBuffer var6);
< 
<    int geqrf(LayoutModified var1, int var2, int var3, DoublePointer var4, int var5, DoublePointer var6);
< 
<    int geqrf(LayoutModified var1, int var2, int var3, float[] var4, int var5, float[] var6);
< 
<    int geqrf(LayoutModified var1, int var2, int var3, FloatBuffer var4, int var5, FloatBuffer var6);
< 
<    int ormqr(LayoutModified var1, SideModified var2, TransposeModified var3, int var4, int var5, int var6, double[] var7, int var8, double[] var9, double[] var10, int var11);
< 
<    int ormqr(LayoutModified var1, SideModified var2, TransposeModified var3, int var4, int var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, DoubleBuffer var10, int var11);
< 
<    int ormqr(LayoutModified var1, SideModified var2, TransposeModified var3, int var4, int var5, int var6, DoublePointer var7, int var8, DoublePointer var9, DoublePointer var10, int var11);
< 
<    int ormqr(LayoutModified var1, SideModified var2, TransposeModified var3, int var4, int var5, int var6, float[] var7, int var8, float[] var9, float[] var10, int var11);
< 
<    int ormqr(LayoutModified var1, SideModified var2, TransposeModified var3, int var4, int var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, FloatBuffer var10, int var11);
< 
<    int orgqr(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7);
< 
<    int orgqr(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7);
< 
<    int orgqr(LayoutModified var1, int var2, int var3, int var4, DoublePointer var5, int var6, DoublePointer var7);
< 
<    int orgqr(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7);
< 
<    int orgqr(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7);
< 
<    int trtrs(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, int var6, double[] var7, int var8, double[] var9, int var10);
< 
<    int trtrs(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, int var10);
< 
<    int trtrs(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, int var6, DoublePointer var7, int var8, DoublePointer var9, int var10);
< 
<    int trtrs(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, int var6, float[] var7, int var8, float[] var9, int var10);
< 
<    int trtrs(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, int var10);
---
> public interface LAPACKModified
> {
>     public static final LAPACKModified engine = getInstance();
>     
>     default LAPACKModified getInstance() {
>         final LAPACKModified mkl = MKL();
>         return (mkl != null) ? mkl : new OpenBLASModified();
>     }
>     
>     default LAPACKModified MKL() {
>         final Logger logger = LoggerFactory.getLogger((Class)LAPACKModified.class);
>         try {
>             final Class<?> clazz = Class.forName("smile.math.blas.mkl.MKL");
>             logger.info("smile-mkl module is available.");
>             return (LAPACKModified)clazz.getDeclaredConstructor((Class<?>[])new Class[0]).newInstance(new Object[0]);
>         }
>         catch (Exception e) {
>             logger.debug("Failed to create MKL instance: ", (Throwable)e);
>             return null;
>         }
>     }
>     
>     int gesv(final LayoutModified p0, final int p1, final int p2, final double[] p3, final int p4, final int[] p5, final double[] p6, final int p7);
>     
>     int gesv(final LayoutModified p0, final int p1, final int p2, final DoubleBuffer p3, final int p4, final IntBuffer p5, final DoubleBuffer p6, final int p7);
>     
>     int gesv(final LayoutModified p0, final int p1, final int p2, final DoublePointer p3, final int p4, final IntPointer p5, final DoublePointer p6, final int p7);
>     
>     int gesv(final LayoutModified p0, final int p1, final int p2, final float[] p3, final int p4, final int[] p5, final float[] p6, final int p7);
>     
>     int gesv(final LayoutModified p0, final int p1, final int p2, final FloatBuffer p3, final int p4, final IntBuffer p5, final FloatBuffer p6, final int p7);
>     
>     int sysv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final double[] p4, final int p5, final int[] p6, final double[] p7, final int p8);
>     
>     int sysv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final DoubleBuffer p4, final int p5, final IntBuffer p6, final DoubleBuffer p7, final int p8);
>     
>     int sysv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final DoublePointer p4, final int p5, final IntPointer p6, final DoublePointer p7, final int p8);
>     
>     int sysv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final float[] p4, final int p5, final int[] p6, final float[] p7, final int p8);
>     
>     int sysv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final FloatBuffer p4, final int p5, final IntBuffer p6, final FloatBuffer p7, final int p8);
>     
>     int spsv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final double[] p4, final int[] p5, final double[] p6, final int p7);
>     
>     int spsv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final DoubleBuffer p4, final IntBuffer p5, final DoubleBuffer p6, final int p7);
>     
>     int spsv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final float[] p4, final int[] p5, final float[] p6, final int p7);
>     
>     int spsv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final FloatBuffer p4, final IntBuffer p5, final FloatBuffer p6, final int p7);
>     
>     int posv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final double[] p4, final int p5, final double[] p6, final int p7);
>     
>     int posv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final int p7);
>     
>     int posv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final float[] p4, final int p5, final float[] p6, final int p7);
>     
>     int posv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final int p7);
>     
>     int ppsv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final double[] p4, final double[] p5, final int p6);
>     
>     int ppsv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final DoubleBuffer p4, final DoubleBuffer p5, final int p6);
>     
>     int ppsv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final float[] p4, final float[] p5, final int p6);
>     
>     int ppsv(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final FloatBuffer p4, final FloatBuffer p5, final int p6);
>     
>     int gbsv(final LayoutModified p0, final int p1, final int p2, final int p3, final int p4, final double[] p5, final int p6, final int[] p7, final double[] p8, final int p9);
>     
>     int gbsv(final LayoutModified p0, final int p1, final int p2, final int p3, final int p4, final DoubleBuffer p5, final int p6, final IntBuffer p7, final DoubleBuffer p8, final int p9);
>     
>     int gbsv(final LayoutModified p0, final int p1, final int p2, final int p3, final int p4, final float[] p5, final int p6, final int[] p7, final float[] p8, final int p9);
>     
>     int gbsv(final LayoutModified p0, final int p1, final int p2, final int p3, final int p4, final FloatBuffer p5, final int p6, final IntBuffer p7, final FloatBuffer p8, final int p9);
>     
>     int gels(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final double[] p5, final int p6, final double[] p7, final int p8);
>     
>     int gels(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final DoubleBuffer p5, final int p6, final DoubleBuffer p7, final int p8);
>     
>     int gels(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final float[] p5, final int p6, final float[] p7, final int p8);
>     
>     int gels(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final FloatBuffer p5, final int p6, final FloatBuffer p7, final int p8);
>     
>     int gelsy(final LayoutModified p0, final int p1, final int p2, final int p3, final double[] p4, final int p5, final double[] p6, final int p7, final int[] p8, final double p9, final int[] p10);
>     
>     int gelsy(final LayoutModified p0, final int p1, final int p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final int p7, final IntBuffer p8, final double p9, final IntBuffer p10);
>     
>     int gelsy(final LayoutModified p0, final int p1, final int p2, final int p3, final float[] p4, final int p5, final float[] p6, final int p7, final int[] p8, final float p9, final int[] p10);
>     
>     int gelsy(final LayoutModified p0, final int p1, final int p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final int p7, final IntBuffer p8, final float p9, final IntBuffer p10);
>     
>     int gelss(final LayoutModified p0, final int p1, final int p2, final int p3, final double[] p4, final int p5, final double[] p6, final int p7, final double[] p8, final double p9, final int[] p10);
>     
>     int gelss(final LayoutModified p0, final int p1, final int p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final int p7, final DoubleBuffer p8, final double p9, final IntBuffer p10);
>     
>     int gelss(final LayoutModified p0, final int p1, final int p2, final int p3, final float[] p4, final int p5, final float[] p6, final int p7, final float[] p8, final float p9, final int[] p10);
>     
>     int gelss(final LayoutModified p0, final int p1, final int p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final int p7, final FloatBuffer p8, final float p9, final IntBuffer p10);
>     
>     int gelsd(final LayoutModified p0, final int p1, final int p2, final int p3, final double[] p4, final int p5, final double[] p6, final int p7, final double[] p8, final double p9, final int[] p10);
>     
>     int gelsd(final LayoutModified p0, final int p1, final int p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final int p7, final DoubleBuffer p8, final double p9, final IntBuffer p10);
>     
>     int gelsd(final LayoutModified p0, final int p1, final int p2, final int p3, final float[] p4, final int p5, final float[] p6, final int p7, final float[] p8, final float p9, final int[] p10);
>     
>     int gelsd(final LayoutModified p0, final int p1, final int p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final int p7, final FloatBuffer p8, final float p9, final IntBuffer p10);
>     
>     int gglse(final LayoutModified p0, final int p1, final int p2, final int p3, final double[] p4, final int p5, final double[] p6, final int p7, final double[] p8, final double[] p9, final double[] p10);
>     
>     int gglse(final LayoutModified p0, final int p1, final int p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final int p7, final DoubleBuffer p8, final DoubleBuffer p9, final DoubleBuffer p10);
>     
>     int gglse(final LayoutModified p0, final int p1, final int p2, final int p3, final float[] p4, final int p5, final float[] p6, final int p7, final float[] p8, final float[] p9, final float[] p10);
>     
>     int gglse(final LayoutModified p0, final int p1, final int p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final int p7, final FloatBuffer p8, final FloatBuffer p9, final FloatBuffer p10);
>     
>     int ggglm(final LayoutModified p0, final int p1, final int p2, final int p3, final double[] p4, final int p5, final double[] p6, final int p7, final double[] p8, final double[] p9, final double[] p10);
>     
>     int ggglm(final LayoutModified p0, final int p1, final int p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final int p7, final DoubleBuffer p8, final DoubleBuffer p9, final DoubleBuffer p10);
>     
>     int ggglm(final LayoutModified p0, final int p1, final int p2, final int p3, final float[] p4, final int p5, final float[] p6, final int p7, final float[] p8, final float[] p9, final float[] p10);
>     
>     int ggglm(final LayoutModified p0, final int p1, final int p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final int p7, final FloatBuffer p8, final FloatBuffer p9, final FloatBuffer p10);
>     
>     int geev(final LayoutModified p0, final EVDJobModified p1, final EVDJobModified p2, final int p3, final double[] p4, final int p5, final double[] p6, final double[] p7, final double[] p8, final int p9, final double[] p10, final int p11);
>     
>     int geev(final LayoutModified p0, final EVDJobModified p1, final EVDJobModified p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final DoubleBuffer p7, final DoubleBuffer p8, final int p9, final DoubleBuffer p10, final int p11);
>     
>     int geev(final LayoutModified p0, final EVDJobModified p1, final EVDJobModified p2, final int p3, final DoublePointer p4, final int p5, final DoublePointer p6, final DoublePointer p7, final DoublePointer p8, final int p9, final DoublePointer p10, final int p11);
>     
>     int geev(final LayoutModified p0, final EVDJobModified p1, final EVDJobModified p2, final int p3, final float[] p4, final int p5, final float[] p6, final float[] p7, final float[] p8, final int p9, final float[] p10, final int p11);
>     
>     int geev(final LayoutModified p0, final EVDJobModified p1, final EVDJobModified p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final FloatBuffer p7, final FloatBuffer p8, final int p9, final FloatBuffer p10, final int p11);
>     
>     int syev(final LayoutModified p0, final EVDJobModified p1, final UPLOModified p2, final int p3, final double[] p4, final int p5, final double[] p6);
>     
>     int syev(final LayoutModified p0, final EVDJobModified p1, final UPLOModified p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6);
>     
>     int syev(final LayoutModified p0, final EVDJobModified p1, final UPLOModified p2, final int p3, final float[] p4, final int p5, final float[] p6);
>     
>     int syev(final LayoutModified p0, final EVDJobModified p1, final UPLOModified p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6);
>     
>     int syevd(final LayoutModified p0, final EVDJobModified p1, final UPLOModified p2, final int p3, final double[] p4, final int p5, final double[] p6);
>     
>     int syevd(final LayoutModified p0, final EVDJobModified p1, final UPLOModified p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6);
>     
>     int syevd(final LayoutModified p0, final EVDJobModified p1, final UPLOModified p2, final int p3, final DoublePointer p4, final int p5, final DoublePointer p6);
>     
>     int syevd(final LayoutModified p0, final EVDJobModified p1, final UPLOModified p2, final int p3, final float[] p4, final int p5, final float[] p6);
>     
>     int syevd(final LayoutModified p0, final EVDJobModified p1, final UPLOModified p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6);
>     
>     int syevr(final LayoutModified p0, final EVDJobModified p1, final EigenRangeModified p2, final UPLOModified p3, final int p4, final double[] p5, final int p6, final double p7, final double p8, final int p9, final int p10, final double p11, final int[] p12, final double[] p13, final double[] p14, final int p15, final int[] p16);
>     
>     int syevr(final LayoutModified p0, final EVDJobModified p1, final EigenRangeModified p2, final UPLOModified p3, final int p4, final DoubleBuffer p5, final int p6, final double p7, final double p8, final int p9, final int p10, final double p11, final IntBuffer p12, final DoubleBuffer p13, final DoubleBuffer p14, final int p15, final IntBuffer p16);
>     
>     int syevr(final LayoutModified p0, final EVDJobModified p1, final EigenRangeModified p2, final UPLOModified p3, final int p4, final float[] p5, final int p6, final float p7, final float p8, final int p9, final int p10, final float p11, final int[] p12, final float[] p13, final float[] p14, final int p15, final int[] p16);
>     
>     int syevr(final LayoutModified p0, final EVDJobModified p1, final EigenRangeModified p2, final UPLOModified p3, final int p4, final FloatBuffer p5, final int p6, final float p7, final float p8, final int p9, final int p10, final float p11, final IntBuffer p12, final FloatBuffer p13, final FloatBuffer p14, final int p15, final IntBuffer p16);
>     
>     int gesvd(final LayoutModified p0, final SVDJobModified p1, final SVDJobModified p2, final int p3, final int p4, final double[] p5, final int p6, final double[] p7, final double[] p8, final int p9, final double[] p10, final int p11, final double[] p12);
>     
>     int gesvd(final LayoutModified p0, final SVDJobModified p1, final SVDJobModified p2, final int p3, final int p4, final DoubleBuffer p5, final int p6, final DoubleBuffer p7, final DoubleBuffer p8, final int p9, final DoubleBuffer p10, final int p11, final DoubleBuffer p12);
>     
>     int gesvd(final LayoutModified p0, final SVDJobModified p1, final SVDJobModified p2, final int p3, final int p4, final float[] p5, final int p6, final float[] p7, final float[] p8, final int p9, final float[] p10, final int p11, final float[] p12);
>     
>     int gesvd(final LayoutModified p0, final SVDJobModified p1, final SVDJobModified p2, final int p3, final int p4, final FloatBuffer p5, final int p6, final FloatBuffer p7, final FloatBuffer p8, final int p9, final FloatBuffer p10, final int p11, final FloatBuffer p12);
>     
>     int gesdd(final LayoutModified p0, final SVDJobModified p1, final int p2, final int p3, final double[] p4, final int p5, final double[] p6, final double[] p7, final int p8, final double[] p9, final int p10);
>     
>     int gesdd(final LayoutModified p0, final SVDJobModified p1, final int p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final DoubleBuffer p7, final int p8, final DoubleBuffer p9, final int p10);
>     
>     int gesdd(final LayoutModified p0, final SVDJobModified p1, final int p2, final int p3, final DoublePointer p4, final int p5, final DoublePointer p6, final DoublePointer p7, final int p8, final DoublePointer p9, final int p10);
>     
>     int gesdd(final LayoutModified p0, final SVDJobModified p1, final int p2, final int p3, final float[] p4, final int p5, final float[] p6, final float[] p7, final int p8, final float[] p9, final int p10);
>     
>     int gesdd(final LayoutModified p0, final SVDJobModified p1, final int p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final FloatBuffer p7, final int p8, final FloatBuffer p9, final int p10);
>     
>     int getrf(final LayoutModified p0, final int p1, final int p2, final double[] p3, final int p4, final int[] p5);
>     
>     int getrf(final LayoutModified p0, final int p1, final int p2, final DoubleBuffer p3, final int p4, final IntBuffer p5);
>     
>     int getrf(final LayoutModified p0, final int p1, final int p2, final DoublePointer p3, final int p4, final IntPointer p5);
>     
>     int getrf(final LayoutModified p0, final int p1, final int p2, final float[] p3, final int p4, final int[] p5);
>     
>     int getrf(final LayoutModified p0, final int p1, final int p2, final FloatBuffer p3, final int p4, final IntBuffer p5);
>     
>     int getrf2(final LayoutModified p0, final int p1, final int p2, final double[] p3, final int p4, final int[] p5);
>     
>     int getrf2(final LayoutModified p0, final int p1, final int p2, final DoubleBuffer p3, final int p4, final IntBuffer p5);
>     
>     int getrf2(final LayoutModified p0, final int p1, final int p2, final float[] p3, final int p4, final int[] p5);
>     
>     int getrf2(final LayoutModified p0, final int p1, final int p2, final FloatBuffer p3, final int p4, final IntBuffer p5);
>     
>     int gbtrf(final LayoutModified p0, final int p1, final int p2, final int p3, final int p4, final double[] p5, final int p6, final int[] p7);
>     
>     int gbtrf(final LayoutModified p0, final int p1, final int p2, final int p3, final int p4, final DoubleBuffer p5, final int p6, final IntBuffer p7);
>     
>     int gbtrf(final LayoutModified p0, final int p1, final int p2, final int p3, final int p4, final float[] p5, final int p6, final int[] p7);
>     
>     int gbtrf(final LayoutModified p0, final int p1, final int p2, final int p3, final int p4, final FloatBuffer p5, final int p6, final IntBuffer p7);
>     
>     int sptrf(final LayoutModified p0, final UPLOModified p1, final int p2, final double[] p3, final int[] p4);
>     
>     int sptrf(final LayoutModified p0, final UPLOModified p1, final int p2, final DoubleBuffer p3, final IntBuffer p4);
>     
>     int sptrf(final LayoutModified p0, final UPLOModified p1, final int p2, final float[] p3, final int[] p4);
>     
>     int sptrf(final LayoutModified p0, final UPLOModified p1, final int p2, final FloatBuffer p3, final IntBuffer p4);
>     
>     int getrs(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final double[] p4, final int p5, final int[] p6, final double[] p7, final int p8);
>     
>     int getrs(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final DoubleBuffer p4, final int p5, final IntBuffer p6, final DoubleBuffer p7, final int p8);
>     
>     int getrs(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final DoublePointer p4, final int p5, final IntPointer p6, final DoublePointer p7, final int p8);
>     
>     int getrs(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final float[] p4, final int p5, final int[] p6, final float[] p7, final int p8);
>     
>     int getrs(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final FloatBuffer p4, final int p5, final IntBuffer p6, final FloatBuffer p7, final int p8);
>     
>     int gbtrs(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final int p5, final double[] p6, final int p7, final int[] p8, final double[] p9, final int p10);
>     
>     int gbtrs(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final int p5, final DoubleBuffer p6, final int p7, final IntBuffer p8, final DoubleBuffer p9, final int p10);
>     
>     int gbtrs(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final int p5, final float[] p6, final int p7, final int[] p8, final float[] p9, final int p10);
>     
>     int gbtrs(final LayoutModified p0, final TransposeModified p1, final int p2, final int p3, final int p4, final int p5, final FloatBuffer p6, final int p7, final IntBuffer p8, final FloatBuffer p9, final int p10);
>     
>     int sptrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final double[] p4, final int[] p5, final double[] p6, final int p7);
>     
>     int sptrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final DoubleBuffer p4, final IntBuffer p5, final DoubleBuffer p6, final int p7);
>     
>     int sptrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final FloatBuffer p4, final IntBuffer p5, final FloatBuffer p6, final int p7);
>     
>     int sptrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final float[] p4, final int[] p5, final float[] p6, final int p7);
>     
>     int potrf(final LayoutModified p0, final UPLOModified p1, final int p2, final double[] p3, final int p4);
>     
>     int potrf(final LayoutModified p0, final UPLOModified p1, final int p2, final DoubleBuffer p3, final int p4);
>     
>     int potrf(final LayoutModified p0, final UPLOModified p1, final int p2, final DoublePointer p3, final int p4);
>     
>     int potrf(final LayoutModified p0, final UPLOModified p1, final int p2, final float[] p3, final int p4);
>     
>     int potrf(final LayoutModified p0, final UPLOModified p1, final int p2, final FloatBuffer p3, final int p4);
>     
>     int potrf2(final LayoutModified p0, final UPLOModified p1, final int p2, final double[] p3, final int p4);
>     
>     int potrf2(final LayoutModified p0, final UPLOModified p1, final int p2, final DoubleBuffer p3, final int p4);
>     
>     int potrf2(final LayoutModified p0, final UPLOModified p1, final int p2, final float[] p3, final int p4);
>     
>     int potrf2(final LayoutModified p0, final UPLOModified p1, final int p2, final FloatBuffer p3, final int p4);
>     
>     int pbtrf(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final double[] p4, final int p5);
>     
>     int pbtrf(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final DoubleBuffer p4, final int p5);
>     
>     int pbtrf(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final float[] p4, final int p5);
>     
>     int pbtrf(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final FloatBuffer p4, final int p5);
>     
>     int pptrf(final LayoutModified p0, final UPLOModified p1, final int p2, final double[] p3);
>     
>     int pptrf(final LayoutModified p0, final UPLOModified p1, final int p2, final DoubleBuffer p3);
>     
>     int pptrf(final LayoutModified p0, final UPLOModified p1, final int p2, final float[] p3);
>     
>     int pptrf(final LayoutModified p0, final UPLOModified p1, final int p2, final FloatBuffer p3);
>     
>     int potrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final double[] p4, final int p5, final double[] p6, final int p7);
>     
>     int potrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6, final int p7);
>     
>     int potrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final DoublePointer p4, final int p5, final DoublePointer p6, final int p7);
>     
>     int potrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final float[] p4, final int p5, final float[] p6, final int p7);
>     
>     int potrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6, final int p7);
>     
>     int pbtrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final int p4, final double[] p5, final int p6, final double[] p7, final int p8);
>     
>     int pbtrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final int p4, final DoubleBuffer p5, final int p6, final DoubleBuffer p7, final int p8);
>     
>     int pbtrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final int p4, final float[] p5, final int p6, final float[] p7, final int p8);
>     
>     int pbtrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final int p4, final FloatBuffer p5, final int p6, final FloatBuffer p7, final int p8);
>     
>     int pptrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final double[] p4, final double[] p5, final int p6);
>     
>     int pptrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final DoubleBuffer p4, final DoubleBuffer p5, final int p6);
>     
>     int pptrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final float[] p4, final float[] p5, final int p6);
>     
>     int pptrs(final LayoutModified p0, final UPLOModified p1, final int p2, final int p3, final FloatBuffer p4, final FloatBuffer p5, final int p6);
>     
>     int geqrf(final LayoutModified p0, final int p1, final int p2, final double[] p3, final int p4, final double[] p5);
>     
>     int geqrf(final LayoutModified p0, final int p1, final int p2, final DoubleBuffer p3, final int p4, final DoubleBuffer p5);
>     
>     int geqrf(final LayoutModified p0, final int p1, final int p2, final DoublePointer p3, final int p4, final DoublePointer p5);
>     
>     int geqrf(final LayoutModified p0, final int p1, final int p2, final float[] p3, final int p4, final float[] p5);
>     
>     int geqrf(final LayoutModified p0, final int p1, final int p2, final FloatBuffer p3, final int p4, final FloatBuffer p5);
>     
>     int ormqr(final LayoutModified p0, final SideModified p1, final TransposeModified p2, final int p3, final int p4, final int p5, final double[] p6, final int p7, final double[] p8, final double[] p9, final int p10);
>     
>     int ormqr(final LayoutModified p0, final SideModified p1, final TransposeModified p2, final int p3, final int p4, final int p5, final DoubleBuffer p6, final int p7, final DoubleBuffer p8, final DoubleBuffer p9, final int p10);
>     
>     int ormqr(final LayoutModified p0, final SideModified p1, final TransposeModified p2, final int p3, final int p4, final int p5, final DoublePointer p6, final int p7, final DoublePointer p8, final DoublePointer p9, final int p10);
>     
>     int ormqr(final LayoutModified p0, final SideModified p1, final TransposeModified p2, final int p3, final int p4, final int p5, final float[] p6, final int p7, final float[] p8, final float[] p9, final int p10);
>     
>     int ormqr(final LayoutModified p0, final SideModified p1, final TransposeModified p2, final int p3, final int p4, final int p5, final FloatBuffer p6, final int p7, final FloatBuffer p8, final FloatBuffer p9, final int p10);
>     
>     int orgqr(final LayoutModified p0, final int p1, final int p2, final int p3, final double[] p4, final int p5, final double[] p6);
>     
>     int orgqr(final LayoutModified p0, final int p1, final int p2, final int p3, final DoubleBuffer p4, final int p5, final DoubleBuffer p6);
>     
>     int orgqr(final LayoutModified p0, final int p1, final int p2, final int p3, final DoublePointer p4, final int p5, final DoublePointer p6);
>     
>     int orgqr(final LayoutModified p0, final int p1, final int p2, final int p3, final float[] p4, final int p5, final float[] p6);
>     
>     int orgqr(final LayoutModified p0, final int p1, final int p2, final int p3, final FloatBuffer p4, final int p5, final FloatBuffer p6);
>     
>     int trtrs(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final int p5, final double[] p6, final int p7, final double[] p8, final int p9);
>     
>     int trtrs(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final int p5, final DoubleBuffer p6, final int p7, final DoubleBuffer p8, final int p9);
>     
>     int trtrs(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final int p5, final DoublePointer p6, final int p7, final DoublePointer p8, final int p9);
>     
>     int trtrs(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final int p5, final float[] p6, final int p7, final float[] p8, final int p9);
>     
>     int trtrs(final LayoutModified p0, final UPLOModified p1, final TransposeModified p2, final DiagModified p3, final int p4, final int p5, final FloatBuffer p6, final int p7, final FloatBuffer p8, final int p9);
diff -r TrackAnalyzer_/smileModified/LayoutModified.java procyon/smileModified/LayoutModified.java
1,8c1,3
< package smileModified;
< 
< public enum LayoutModified {
<    ROW_MAJOR(101),
<    COL_MAJOR(102);
< 
<    private final int blas;
<    private final int lapack;
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
10,17c5
<    private LayoutModified(int value) {
<       this.blas = value;
<       this.lapack = value;
<    }
< 
<    public int blas() {
<       return this.blas;
<    }
---
> package smileModified;
19,21c7,26
<    public int lapack() {
<       return this.lapack;
<    }
---
> public enum LayoutModified
> {
>     ROW_MAJOR("ROW_MAJOR", 0, 101), 
>     COL_MAJOR("COL_MAJOR", 1, 102);
>     
>     private final int blas;
>     private final int lapack;
>     
>     private LayoutModified(final String name, final int ordinal, final int value) {
>         this.blas = value;
>         this.lapack = value;
>     }
>     
>     public int blas() {
>         return this.blas;
>     }
>     
>     public int lapack() {
>         return this.lapack;
>     }
diff -r TrackAnalyzer_/smileModified/MathExModified.java procyon/smileModified/MathExModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
4,7d7
< import java.lang.reflect.Array;
< import java.security.SecureRandom;
< import java.util.Arrays;
< import java.util.Iterator;
8a9,11
> import java.util.Iterator;
> import java.util.Arrays;
> import java.lang.reflect.Array;
10d12
< import org.slf4j.Logger;
11a14,15
> import java.security.SecureRandom;
> import org.slf4j.Logger;
13,128c17,109
< public class MathExModified {
<    private static final Logger logger = LoggerFactory.getLogger(MathExModified.class);
<    private static final MathExModified.FPU fpu = new MathExModified.FPU();
<    public static final double EPSILON;
<    public static final float FLOAT_EPSILON;
<    public static final int RADIX;
<    public static final int DIGITS;
<    public static final int FLOAT_DIGITS;
<    public static final int ROUND_STYLE;
<    public static final int MACHEP;
<    public static final int FLOAT_MACHEP;
<    public static final int NEGEP;
<    public static final int FLOAT_NEGEP;
<    private static final SecureRandom seedRNG;
<    private static final long[] DEFAULT_SEEDS;
<    private static int nextSeed;
<    private static final ThreadLocal<RandomModified> random;
<    private static final double LOG2;
< 
<    static {
<       EPSILON = fpu.EPSILON;
<       FLOAT_EPSILON = fpu.FLOAT_EPSILON;
<       RADIX = fpu.RADIX;
<       DIGITS = fpu.DIGITS;
<       FLOAT_DIGITS = fpu.FLOAT_DIGITS;
<       ROUND_STYLE = fpu.ROUND_STYLE;
<       MACHEP = fpu.MACHEP;
<       FLOAT_MACHEP = fpu.FLOAT_MACHEP;
<       NEGEP = fpu.NEGEP;
<       FLOAT_NEGEP = fpu.FLOAT_NEGEP;
<       seedRNG = new SecureRandom();
<       DEFAULT_SEEDS = new long[]{-4106602711295138952L, 7872020634117869514L, -1722503517109829138L, -3386820675908254116L, -1736715870046201019L, 3854590623768163340L, 4984519038350406438L, 831971085876758331L, 7131773007627236777L, -3609561992173376238L, -8759399602515137276L, 6192158663294695439L, -5656470009161653116L, -7984826214821970800L, -9113192788977418232L, -8979910231410580019L, -4619021025191354324L, -5082417586190057466L, -6554946940783144090L, -3610462176018822900L, 8959796931768911980L, -4251632352234989839L, 4922191169088134258L, -7282805902317830669L, 3869302430595840919L, 2517690626940415460L, 4056663221614950174L, 6429856319379397738L, 7298845553914383313L, 8179510284261677971L, 4282994537597585253L, 7300184601511783348L, 2596703774884172704L, 1089838915342514714L, 4323657609714862439L, 777826126579190548L, -1902743089794461140L, -2460431043688989882L, -3261708534465890932L, 4007861469505443778L, 8067600139237526646L, 5717273542173905853L, 2938568334013652889L, -2972203304739218305L, 6544901794394958069L, 7013723936758841449L, -4215598453287525312L, -1454689091401951913L, -5699280845313829011L, -9147984414924288540L, 5211986845656222459L, -1287642354429721659L, -1509334943513011620L, -9000043616528857326L, -2902817511399216571L, -742823064588229527L, -4937222449957498789L, -455679889440396397L, -6109470266907575296L, 5515435653880394376L, 5557224587324997029L, 8904139390487005840L, 6560726276686488510L, 6959949429287621625L, -6055733513105375650L, 5762016937143172332L, -9186652929482643329L, -1105816448554330895L, -8200377873547841359L, 9107473159863354619L, 3239950546973836199L, -8104429975176305012L, 3822949195131885242L, -5261390396129824777L, 9176101422921943895L, -5102541493993205418L, -1254710019595692814L, -6668066200971989826L, -2118519708589929546L, 5428466612765068681L, -6528627776941116598L, -5945449163896244174L, -3293290115918281076L, 6370347300411991230L, -7043881693953271167L, 8078993941165238212L, 6894961504641498099L, -8798276497942360228L, 2276271091333773917L, -7184141741385833013L, -4787502691178107481L, 1255068205351917608L, -8644146770023935609L, 5124094110137147339L, 4917075344795488880L, 3423242822219783102L, 1588924456880980404L, 8515495360312448868L, -5563691320675461929L, -2352238951654504517L, -7416919543420127888L, 631412478604690114L, 689144891258712875L, -9001615284848119152L, -6275065758899203088L, 8164387857252400515L, -4122060123604826739L, -2016541034210046261L, -7178335877193796678L, 3354303106860129181L, 5731595363486898779L, -2874315602397298018L, 5386746429707619069L, 9036622191596156315L, -7950190733284789459L, -5741691593792426169L, -8600462258998065159L, 5460142111961227035L, 276738899508534641L, 2358776514903881139L, -837649704945720257L, -3608906204977108245L, 2960825464614526243L, 7339056324843827739L, -5709958573878745135L, -5885403829221945248L, 6611935345917126768L, 2588814037559904539L};
<       nextSeed = -1;
<       random = new ThreadLocal<RandomModified>() {
<          protected RandomModified initialValue() {
<             synchronized(MathExModified.DEFAULT_SEEDS) {
<                if (MathExModified.nextSeed < 0) {
<                   MathExModified.nextSeed = 0;
<                   return new RandomModified();
<                } else if (MathExModified.nextSeed < MathExModified.DEFAULT_SEEDS.length) {
<                   long[] var10002 = MathExModified.DEFAULT_SEEDS;
<                   int var10003 = MathExModified.nextSeed;
<                   MathExModified.nextSeed = var10003 + 1;
<                   return new RandomModified(var10002[var10003]);
<                } else {
<                   return new RandomModified(MathExModified.generateSeed());
<                }
<             }
<          }
<       };
<       LOG2 = Math.log(2.0D);
<    }
< 
<    private MathExModified() {
<    }
< 
<    public static double log2(double x) {
<       return Math.log(x) / LOG2;
<    }
< 
<    public static double log(double x) {
<       double y = -690.7755D;
<       if (x > 1.0E-300D) {
<          y = Math.log(x);
<       }
< 
<       return y;
<    }
< 
<    public static double log1pe(double x) {
<       double y = x;
<       if (x <= 15.0D) {
<          y = Math.log1p(Math.exp(x));
<       }
< 
<       return y;
<    }
< 
<    public static boolean isInt(float x) {
<       return x == (float)Math.floor((double)x) && !Float.isInfinite(x);
<    }
< 
<    public static boolean isInt(double x) {
<       return x == Math.floor(x) && !Double.isInfinite(x);
<    }
< 
<    public static boolean equals(double a, double b) {
<       if (a == b) {
<          return true;
<       } else {
<          double absa = Math.abs(a);
<          double absb = Math.abs(b);
<          return Math.abs(a - b) <= Math.min(absa, absb) * 2.220446049250313E-16D;
<       }
<    }
< 
<    public static double sigmoid(double x) {
<       x = Math.max(-36.0D, Math.min(x, 36.0D));
<       return 1.0D / (1.0D + Math.exp(-x));
<    }
< 
<    public static double pow2(double x) {
<       return x * x;
<    }
< 
<    public static boolean isPower2(int x) {
<       return x > 0 && (x & x - 1) == 0;
<    }
< 
<    public static boolean isProbablePrime(long n, int k) {
<       return isProbablePrime(n, k, (RandomModified)random.get());
<    }
< 
<    private static boolean isProbablePrime(long n, int k, RandomModified rng) {
<       if (n > 1L && n != 4L) {
<          if (n <= 3L) {
---
> public class MathExModified
> {
>     private static final Logger logger;
>     private static final FPU fpu;
>     public static final double EPSILON;
>     public static final float FLOAT_EPSILON;
>     public static final int RADIX;
>     public static final int DIGITS;
>     public static final int FLOAT_DIGITS;
>     public static final int ROUND_STYLE;
>     public static final int MACHEP;
>     public static final int FLOAT_MACHEP;
>     public static final int NEGEP;
>     public static final int FLOAT_NEGEP;
>     private static final SecureRandom seedRNG;
>     private static final long[] DEFAULT_SEEDS;
>     private static int nextSeed;
>     private static final ThreadLocal<RandomModified> random;
>     private static final double LOG2;
>     
>     static {
>         logger = LoggerFactory.getLogger((Class)MathExModified.class);
>         fpu = new FPU();
>         EPSILON = MathExModified.fpu.EPSILON;
>         FLOAT_EPSILON = MathExModified.fpu.FLOAT_EPSILON;
>         RADIX = MathExModified.fpu.RADIX;
>         DIGITS = MathExModified.fpu.DIGITS;
>         FLOAT_DIGITS = MathExModified.fpu.FLOAT_DIGITS;
>         ROUND_STYLE = MathExModified.fpu.ROUND_STYLE;
>         MACHEP = MathExModified.fpu.MACHEP;
>         FLOAT_MACHEP = MathExModified.fpu.FLOAT_MACHEP;
>         NEGEP = MathExModified.fpu.NEGEP;
>         FLOAT_NEGEP = MathExModified.fpu.FLOAT_NEGEP;
>         seedRNG = new SecureRandom();
>         DEFAULT_SEEDS = new long[] { -4106602711295138952L, 7872020634117869514L, -1722503517109829138L, -3386820675908254116L, -1736715870046201019L, 3854590623768163340L, 4984519038350406438L, 831971085876758331L, 7131773007627236777L, -3609561992173376238L, -8759399602515137276L, 6192158663294695439L, -5656470009161653116L, -7984826214821970800L, -9113192788977418232L, -8979910231410580019L, -4619021025191354324L, -5082417586190057466L, -6554946940783144090L, -3610462176018822900L, 8959796931768911980L, -4251632352234989839L, 4922191169088134258L, -7282805902317830669L, 3869302430595840919L, 2517690626940415460L, 4056663221614950174L, 6429856319379397738L, 7298845553914383313L, 8179510284261677971L, 4282994537597585253L, 7300184601511783348L, 2596703774884172704L, 1089838915342514714L, 4323657609714862439L, 777826126579190548L, -1902743089794461140L, -2460431043688989882L, -3261708534465890932L, 4007861469505443778L, 8067600139237526646L, 5717273542173905853L, 2938568334013652889L, -2972203304739218305L, 6544901794394958069L, 7013723936758841449L, -4215598453287525312L, -1454689091401951913L, -5699280845313829011L, -9147984414924288540L, 5211986845656222459L, -1287642354429721659L, -1509334943513011620L, -9000043616528857326L, -2902817511399216571L, -742823064588229527L, -4937222449957498789L, -455679889440396397L, -6109470266907575296L, 5515435653880394376L, 5557224587324997029L, 8904139390487005840L, 6560726276686488510L, 6959949429287621625L, -6055733513105375650L, 5762016937143172332L, -9186652929482643329L, -1105816448554330895L, -8200377873547841359L, 9107473159863354619L, 3239950546973836199L, -8104429975176305012L, 3822949195131885242L, -5261390396129824777L, 9176101422921943895L, -5102541493993205418L, -1254710019595692814L, -6668066200971989826L, -2118519708589929546L, 5428466612765068681L, -6528627776941116598L, -5945449163896244174L, -3293290115918281076L, 6370347300411991230L, -7043881693953271167L, 8078993941165238212L, 6894961504641498099L, -8798276497942360228L, 2276271091333773917L, -7184141741385833013L, -4787502691178107481L, 1255068205351917608L, -8644146770023935609L, 5124094110137147339L, 4917075344795488880L, 3423242822219783102L, 1588924456880980404L, 8515495360312448868L, -5563691320675461929L, -2352238951654504517L, -7416919543420127888L, 631412478604690114L, 689144891258712875L, -9001615284848119152L, -6275065758899203088L, 8164387857252400515L, -4122060123604826739L, -2016541034210046261L, -7178335877193796678L, 3354303106860129181L, 5731595363486898779L, -2874315602397298018L, 5386746429707619069L, 9036622191596156315L, -7950190733284789459L, -5741691593792426169L, -8600462258998065159L, 5460142111961227035L, 276738899508534641L, 2358776514903881139L, -837649704945720257L, -3608906204977108245L, 2960825464614526243L, 7339056324843827739L, -5709958573878745135L, -5885403829221945248L, 6611935345917126768L, 2588814037559904539L };
>         MathExModified.nextSeed = -1;
>         random = new ThreadLocal<RandomModified>() {
>             @Override
>             protected RandomModified initialValue() {
>                 synchronized (MathExModified.DEFAULT_SEEDS) {
>                     if (MathExModified.nextSeed < 0) {
>                         MathExModified.access$2(0);
>                         // monitorexit(MathExModified.access$0())
>                         return new RandomModified();
>                     }
>                     if (MathExModified.nextSeed < MathExModified.DEFAULT_SEEDS.length) {
>                         final long[] access$0 = MathExModified.DEFAULT_SEEDS;
>                         final int access$2 = MathExModified.nextSeed;
>                         MathExModified.access$2(access$2 + 1);
>                         // monitorexit(MathExModified.access$0())
>                         return new RandomModified(access$0[access$2]);
>                     }
>                     // monitorexit(MathExModified.access$0())
>                     return new RandomModified(MathExModified.generateSeed());
>                 }
>             }
>         };
>         LOG2 = Math.log(2.0);
>     }
>     
>     private MathExModified() {
>     }
>     
>     public static double log2(final double x) {
>         return Math.log(x) / MathExModified.LOG2;
>     }
>     
>     public static double log(final double x) {
>         double y = -690.7755;
>         if (x > 1.0E-300) {
>             y = Math.log(x);
>         }
>         return y;
>     }
>     
>     public static double log1pe(final double x) {
>         double y = x;
>         if (x <= 15.0) {
>             y = Math.log1p(Math.exp(x));
>         }
>         return y;
>     }
>     
>     public static boolean isInt(final float x) {
>         return x == (float)Math.floor(x) && !Float.isInfinite(x);
>     }
>     
>     public static boolean isInt(final double x) {
>         return x == Math.floor(x) && !Double.isInfinite(x);
>     }
>     
>     public static boolean equals(final double a, final double b) {
>         if (a == b) {
130,145c111,161
<          } else {
<             int s = 0;
< 
<             long d;
<             for(d = n - 1L; d % 2L == 0L; d /= 2L) {
<                ++s;
<             }
< 
<             for(int i = 0; i < k; ++i) {
<                long a = 2L + rng.nextLong() % (n - 4L);
<                long x = power(a, d, n);
<                if (x != 1L && x != n - 1L) {
<                   int r;
<                   for(r = 0; r < s; ++r) {
<                      x = x * x % n;
<                      if (x == 1L) {
---
>         }
>         final double absa = Math.abs(a);
>         final double absb = Math.abs(b);
>         return Math.abs(a - b) <= Math.min(absa, absb) * 2.220446049250313E-16;
>     }
>     
>     public static double sigmoid(double x) {
>         x = Math.max(-36.0, Math.min(x, 36.0));
>         return 1.0 / (1.0 + Math.exp(-x));
>     }
>     
>     public static double pow2(final double x) {
>         return x * x;
>     }
>     
>     public static boolean isPower2(final int x) {
>         return x > 0 && (x & x - 1) == 0x0;
>     }
>     
>     public static boolean isProbablePrime(final long n, final int k) {
>         return isProbablePrime(n, k, MathExModified.random.get());
>     }
>     
>     private static boolean isProbablePrime(final long n, final int k, final RandomModified rng) {
>         if (n <= 1L || n == 4L) {
>             return false;
>         }
>         if (n <= 3L) {
>             return true;
>         }
>         int s = 0;
>         long d;
>         for (d = n - 1L; d % 2L == 0L; d /= 2L) {
>             ++s;
>         }
>         for (int i = 0; i < k; ++i) {
>             final long a = 2L + rng.nextLong() % (n - 4L);
>             long x = power(a, d, n);
>             if (x != 1L) {
>                 if (x != n - 1L) {
>                     int r;
>                     for (r = 0; r < s; ++r) {
>                         x = x * x % n;
>                         if (x == 1L) {
>                             return false;
>                         }
>                         if (x == n - 1L) {
>                             break;
>                         }
>                     }
>                     if (r == s) {
147,157c163,164
<                      }
< 
<                      if (x == n - 1L) {
<                         break;
<                      }
<                   }
< 
<                   if (r == s) {
<                      return false;
<                   }
<                }
---
>                     }
>                 }
159,660c166,593
< 
<             return true;
<          }
<       } else {
<          return false;
<       }
<    }
< 
<    private static long power(long x, long y, long p) {
<       long res = 1L;
< 
<       for(x %= p; y > 0L; x = x * x % p) {
<          if ((y & 1L) == 1L) {
<             res = res * x % p;
<          }
< 
<          y >>= 1;
<       }
< 
<       return res;
<    }
< 
<    public static double round(double x, int decimal) {
<       return decimal < 0 ? (double)Math.round(x / Math.pow(10.0D, (double)(-decimal))) * Math.pow(10.0D, (double)(-decimal)) : (double)Math.round(x * Math.pow(10.0D, (double)decimal)) / Math.pow(10.0D, (double)decimal);
<    }
< 
<    public static double factorial(int n) {
<       if (n < 0) {
<          throw new IllegalArgumentException("n has to be non-negative.");
<       } else {
<          double f = 1.0D;
< 
<          for(int i = 2; i <= n; ++i) {
<             f *= (double)i;
<          }
< 
<          return f;
<       }
<    }
< 
<    public static double lfactorial(int n) {
<       if (n < 0) {
<          throw new IllegalArgumentException(String.format("n has to be non-negative: %d", n));
<       } else {
<          double f = 0.0D;
< 
<          for(int i = 2; i <= n; ++i) {
<             f += Math.log((double)i);
<          }
< 
<          return f;
<       }
<    }
< 
<    public static double choose(int n, int k) {
<       if (n >= 0 && k >= 0) {
<          return n < k ? 0.0D : Math.floor(0.5D + Math.exp(lchoose(n, k)));
<       } else {
<          throw new IllegalArgumentException(String.format("Invalid n = %d, k = %d", n, k));
<       }
<    }
< 
<    public static double lchoose(int n, int k) {
<       if (k >= 0 && k <= n) {
<          return lfactorial(n) - lfactorial(k) - lfactorial(n - k);
<       } else {
<          throw new IllegalArgumentException(String.format("Invalid n = %d, k = %d", n, k));
<       }
<    }
< 
<    public static long generateSeed() {
<       byte[] bytes = generateSeed(8);
<       long seed = 0L;
< 
<       for(int i = 0; i < 8; ++i) {
<          seed <<= 8;
<          seed |= (long)(bytes[i] & 255);
<       }
< 
<       return seed;
<    }
< 
<    public static byte[] generateSeed(int numBytes) {
<       synchronized(seedRNG) {
<          return seedRNG.generateSeed(numBytes);
<       }
<    }
< 
<    public static LongStream seeds() {
<       return LongStream.generate(MathExModified::generateSeed).sequential();
<    }
< 
<    public static void setSeed(long seed) {
<       ((RandomModified)random.get()).setSeed(seed);
<    }
< 
<    public static long probablePrime(long n, int k) {
<       return probablePrime(n, k, (RandomModified)random.get());
<    }
< 
<    private static long probablePrime(long n, int k, RandomModified rng) {
<       long seed = n + (long)rng.nextInt(899999963);
< 
<       for(int i = 0; i < 4096 && !isProbablePrime(seed, k, rng); ++i) {
<          seed = n + (long)rng.nextInt(899999963);
<       }
< 
<       return seed;
<    }
< 
<    public static int random(double[] prob) {
<       int[] ans = random(prob, 1);
<       return ans[0];
<    }
< 
<    public static int[] random(double[] prob, int n) {
<       double[] q = new double[prob.length];
< 
<       for(int i = 0; i < prob.length; ++i) {
<          q[i] = prob[i] * (double)prob.length;
<       }
< 
<       int[] a = new int[prob.length];
< 
<       for(int i = 0; i < prob.length; a[i] = i++) {
<       }
< 
<       int[] HL = new int[prob.length];
<       int head = 0;
<       int tail = prob.length - 1;
< 
<       int i;
<       for(i = 0; i < prob.length; ++i) {
<          if (q[i] >= 1.0D) {
<             HL[head++] = i;
<          } else {
<             HL[tail--] = i;
<          }
<       }
< 
<       int i;
<       while(head != 0 && tail != prob.length - 1) {
<          i = HL[tail + 1];
<          i = HL[head - 1];
<          a[i] = i;
<          q[i] += q[i] - 1.0D;
<          ++tail;
<          if (q[i] < 1.0D) {
<             HL[tail--] = i;
<             --head;
<          }
<       }
< 
<       int[] ans = new int[n];
< 
<       for(i = 0; i < n; ++i) {
<          double rU = random() * (double)prob.length;
<          int k = (int)rU;
<          rU -= (double)k;
<          if (rU < q[k]) {
<             ans[i] = k;
<          } else {
<             ans[i] = a[k];
<          }
<       }
< 
<       return ans;
<    }
< 
<    public static double random() {
<       return ((RandomModified)random.get()).nextDouble();
<    }
< 
<    public static double[] random(int n) {
<       double[] x = new double[n];
<       ((RandomModified)random.get()).nextDoubles(x);
<       return x;
<    }
< 
<    public static double random(double lo, double hi) {
<       return ((RandomModified)random.get()).nextDouble(lo, hi);
<    }
< 
<    public static double[] random(double lo, double hi, int n) {
<       double[] x = new double[n];
<       ((RandomModified)random.get()).nextDoubles(x, lo, hi);
<       return x;
<    }
< 
<    public static long randomLong() {
<       return ((RandomModified)random.get()).nextLong();
<    }
< 
<    public static int randomInt(int n) {
<       return ((RandomModified)random.get()).nextInt(n);
<    }
< 
<    public static int randomInt(int lo, int hi) {
<       int w = hi - lo;
<       return lo + ((RandomModified)random.get()).nextInt(w);
<    }
< 
<    public static int[] permutate(int n) {
<       return ((RandomModified)random.get()).permutate(n);
<    }
< 
<    public static void permutate(int[] x) {
<       ((RandomModified)random.get()).permutate(x);
<    }
< 
<    public static void permutate(float[] x) {
<       ((RandomModified)random.get()).permutate(x);
<    }
< 
<    public static void permutate(double[] x) {
<       ((RandomModified)random.get()).permutate(x);
<    }
< 
<    public static void permutate(Object[] x) {
<       ((RandomModified)random.get()).permutate(x);
<    }
< 
<    public static int softmax(double[] posteriori) {
<       return softmax(posteriori, posteriori.length);
<    }
< 
<    public static int softmax(double[] x, int k) {
<       int y = -1;
<       double max = Double.NEGATIVE_INFINITY;
< 
<       for(int i = 0; i < k; ++i) {
<          if (x[i] > max) {
<             max = x[i];
<             y = i;
<          }
<       }
< 
<       double Z = 0.0D;
< 
<       int i;
<       for(i = 0; i < k; ++i) {
<          double out = Math.exp(x[i] - max);
<          x[i] = out;
<          Z += out;
<       }
< 
<       for(i = 0; i < k; ++i) {
<          x[i] /= Z;
<       }
< 
<       return y;
<    }
< 
<    public static int[] c(int... x) {
<       return x;
<    }
< 
<    public static float[] c(float... x) {
<       return x;
<    }
< 
<    public static double[] c(double... x) {
<       return x;
<    }
< 
<    public static String[] c(String... x) {
<       return x;
<    }
< 
<    public static int[] c(int[]... list) {
<       int n = 0;
<       int[][] var5 = list;
<       int var4 = list.length;
< 
<       int[] y;
<       int pos;
<       for(pos = 0; pos < var4; ++pos) {
<          y = var5[pos];
<          n += y.length;
<       }
< 
<       y = new int[n];
<       pos = 0;
<       int[][] var7 = list;
<       int var6 = list.length;
< 
<       for(int var9 = 0; var9 < var6; ++var9) {
<          int[] x = var7[var9];
<          System.arraycopy(x, 0, y, pos, x.length);
<          pos += x.length;
<       }
< 
<       return y;
<    }
< 
<    public static float[] c(float[]... list) {
<       int n = 0;
<       float[][] var5 = list;
<       int var4 = list.length;
< 
<       float[] y;
<       int pos;
<       for(pos = 0; pos < var4; ++pos) {
<          y = var5[pos];
<          n += y.length;
<       }
< 
<       y = new float[n];
<       pos = 0;
<       float[][] var7 = list;
<       int var6 = list.length;
< 
<       for(int var9 = 0; var9 < var6; ++var9) {
<          float[] x = var7[var9];
<          System.arraycopy(x, 0, y, pos, x.length);
<          pos += x.length;
<       }
< 
<       return y;
<    }
< 
<    public static double[] c(double[]... list) {
<       int n = 0;
<       double[][] var5 = list;
<       int var4 = list.length;
< 
<       double[] y;
<       int pos;
<       for(pos = 0; pos < var4; ++pos) {
<          y = var5[pos];
<          n += y.length;
<       }
< 
<       y = new double[n];
<       pos = 0;
<       double[][] var7 = list;
<       int var6 = list.length;
< 
<       for(int var9 = 0; var9 < var6; ++var9) {
<          double[] x = var7[var9];
<          System.arraycopy(x, 0, y, pos, x.length);
<          pos += x.length;
<       }
< 
<       return y;
<    }
< 
<    public static String[] c(String[]... list) {
<       int n = 0;
<       String[][] var5 = list;
<       int var4 = list.length;
< 
<       String[] y;
<       int pos;
<       for(pos = 0; pos < var4; ++pos) {
<          y = var5[pos];
<          n += y.length;
<       }
< 
<       y = new String[n];
<       pos = 0;
<       String[][] var7 = list;
<       int var6 = list.length;
< 
<       for(int var9 = 0; var9 < var6; ++var9) {
<          String[] x = var7[var9];
<          System.arraycopy(x, 0, y, pos, x.length);
<          pos += x.length;
<       }
< 
<       return y;
<    }
< 
<    public static int[] cbind(int[]... x) {
<       return c(x);
<    }
< 
<    public static float[] cbind(float[]... x) {
<       return c(x);
<    }
< 
<    public static double[] cbind(double[]... x) {
<       return c(x);
<    }
< 
<    public static String[] cbind(String[]... x) {
<       return c(x);
<    }
< 
<    public static int[][] rbind(int[]... x) {
<       return x;
<    }
< 
<    public static float[][] rbind(float[]... x) {
<       return x;
<    }
< 
<    public static double[][] rbind(double[]... x) {
<       return x;
<    }
< 
<    public static String[][] rbind(String[]... x) {
<       return x;
<    }
< 
<    public static <E> E[] slice(E[] data, int[] index) {
<       int n = index.length;
<       Object[] x = (Object[])Array.newInstance(data.getClass().getComponentType(), n);
< 
<       for(int i = 0; i < n; ++i) {
<          x[i] = data[index[i]];
<       }
< 
<       return x;
<    }
< 
<    public static int[] slice(int[] data, int[] index) {
<       int n = index.length;
<       int[] x = new int[n];
< 
<       for(int i = 0; i < n; ++i) {
<          x[i] = data[index[i]];
<       }
< 
<       return x;
<    }
< 
<    public static float[] slice(float[] data, int[] index) {
<       int n = index.length;
<       float[] x = new float[n];
< 
<       for(int i = 0; i < n; ++i) {
<          x[i] = data[index[i]];
<       }
< 
<       return x;
<    }
< 
<    public static double[] slice(double[] data, int[] index) {
<       int n = index.length;
<       double[] x = new double[n];
< 
<       for(int i = 0; i < n; ++i) {
<          x[i] = data[index[i]];
<       }
< 
<       return x;
<    }
< 
<    public static boolean contains(double[][] polygon, double[] point) {
<       return contains(polygon, point[0], point[1]);
<    }
< 
<    public static boolean contains(double[][] polygon, double x, double y) {
<       if (polygon.length <= 2) {
<          return false;
<       } else {
<          int hits = 0;
<          int n = polygon.length;
<          double lastx = polygon[n - 1][0];
<          double lasty = polygon[n - 1][1];
< 
<          for(int i = 0; i < n; ++i) {
<             double curx = polygon[i][0];
<             double cury = polygon[i][1];
<             if (cury != lasty) {
<                label75: {
<                   double leftx;
<                   if (curx < lastx) {
<                      if (x >= lastx) {
<                         break label75;
<                      }
< 
<                      leftx = curx;
<                   } else {
<                      if (x >= curx) {
<                         break label75;
<                      }
< 
<                      leftx = lastx;
<                   }
< 
<                   double test1;
<                   double test2;
<                   if (cury < lasty) {
<                      if (y < cury || y >= lasty) {
<                         break label75;
<                      }
< 
<                      if (x < leftx) {
<                         ++hits;
<                         break label75;
<                      }
< 
<                      test1 = x - curx;
<                      test2 = y - cury;
<                   } else {
<                      if (y < lasty || y >= cury) {
<                         break label75;
<                      }
< 
<                      if (x < leftx) {
---
>         }
>         return true;
>     }
>     
>     private static long power(long x, long y, final long p) {
>         long res = 1L;
>         for (x %= p; y > 0L; y >>= 1, x = x * x % p) {
>             if ((y & 0x1L) == 0x1L) {
>                 res = res * x % p;
>             }
>         }
>         return res;
>     }
>     
>     public static double round(final double x, final int decimal) {
>         if (decimal < 0) {
>             return Math.round(x / Math.pow(10.0, -decimal)) * Math.pow(10.0, -decimal);
>         }
>         return Math.round(x * Math.pow(10.0, decimal)) / Math.pow(10.0, decimal);
>     }
>     
>     public static double factorial(final int n) {
>         if (n < 0) {
>             throw new IllegalArgumentException("n has to be non-negative.");
>         }
>         double f = 1.0;
>         for (int i = 2; i <= n; ++i) {
>             f *= i;
>         }
>         return f;
>     }
>     
>     public static double lfactorial(final int n) {
>         if (n < 0) {
>             throw new IllegalArgumentException(String.format("n has to be non-negative: %d", n));
>         }
>         double f = 0.0;
>         for (int i = 2; i <= n; ++i) {
>             f += Math.log(i);
>         }
>         return f;
>     }
>     
>     public static double choose(final int n, final int k) {
>         if (n < 0 || k < 0) {
>             throw new IllegalArgumentException(String.format("Invalid n = %d, k = %d", n, k));
>         }
>         if (n < k) {
>             return 0.0;
>         }
>         return Math.floor(0.5 + Math.exp(lchoose(n, k)));
>     }
>     
>     public static double lchoose(final int n, final int k) {
>         if (k < 0 || k > n) {
>             throw new IllegalArgumentException(String.format("Invalid n = %d, k = %d", n, k));
>         }
>         return lfactorial(n) - lfactorial(k) - lfactorial(n - k);
>     }
>     
>     public static long generateSeed() {
>         final byte[] bytes = generateSeed(8);
>         long seed = 0L;
>         for (int i = 0; i < 8; ++i) {
>             seed <<= 8;
>             seed |= (bytes[i] & 0xFF);
>         }
>         return seed;
>     }
>     
>     public static byte[] generateSeed(final int numBytes) {
>         synchronized (MathExModified.seedRNG) {
>             // monitorexit(MathExModified.seedRNG)
>             return MathExModified.seedRNG.generateSeed(numBytes);
>         }
>     }
>     
>     public static LongStream seeds() {
>         return LongStream.generate(MathExModified::generateSeed).sequential();
>     }
>     
>     public static void setSeed(final long seed) {
>         MathExModified.random.get().setSeed(seed);
>     }
>     
>     public static long probablePrime(final long n, final int k) {
>         return probablePrime(n, k, MathExModified.random.get());
>     }
>     
>     private static long probablePrime(final long n, final int k, final RandomModified rng) {
>         long seed = n + rng.nextInt(899999963);
>         for (int i = 0; i < 4096 && !isProbablePrime(seed, k, rng); seed = n + rng.nextInt(899999963), ++i) {}
>         return seed;
>     }
>     
>     public static int random(final double[] prob) {
>         final int[] ans = random(prob, 1);
>         return ans[0];
>     }
>     
>     public static int[] random(final double[] prob, final int n) {
>         final double[] q = new double[prob.length];
>         for (int i = 0; i < prob.length; ++i) {
>             q[i] = prob[i] * prob.length;
>         }
>         final int[] a = new int[prob.length];
>         for (int j = 0; j < prob.length; ++j) {
>             a[j] = j;
>         }
>         final int[] HL = new int[prob.length];
>         int head = 0;
>         int tail = prob.length - 1;
>         for (int k = 0; k < prob.length; ++k) {
>             if (q[k] >= 1.0) {
>                 HL[head++] = k;
>             }
>             else {
>                 HL[tail--] = k;
>             }
>         }
>         while (head != 0 && tail != prob.length - 1) {
>             final int l = HL[tail + 1];
>             final int m = HL[head - 1];
>             a[l] = m;
>             final double[] array = q;
>             final int n2 = m;
>             array[n2] += q[l] - 1.0;
>             ++tail;
>             if (q[m] < 1.0) {
>                 HL[tail--] = m;
>                 --head;
>             }
>         }
>         final int[] ans = new int[n];
>         for (int i2 = 0; i2 < n; ++i2) {
>             double rU = random() * prob.length;
>             final int k2 = (int)rU;
>             rU -= k2;
>             if (rU < q[k2]) {
>                 ans[i2] = k2;
>             }
>             else {
>                 ans[i2] = a[k2];
>             }
>         }
>         return ans;
>     }
>     
>     public static double random() {
>         return MathExModified.random.get().nextDouble();
>     }
>     
>     public static double[] random(final int n) {
>         final double[] x = new double[n];
>         MathExModified.random.get().nextDoubles(x);
>         return x;
>     }
>     
>     public static double random(final double lo, final double hi) {
>         return MathExModified.random.get().nextDouble(lo, hi);
>     }
>     
>     public static double[] random(final double lo, final double hi, final int n) {
>         final double[] x = new double[n];
>         MathExModified.random.get().nextDoubles(x, lo, hi);
>         return x;
>     }
>     
>     public static long randomLong() {
>         return MathExModified.random.get().nextLong();
>     }
>     
>     public static int randomInt(final int n) {
>         return MathExModified.random.get().nextInt(n);
>     }
>     
>     public static int randomInt(final int lo, final int hi) {
>         final int w = hi - lo;
>         return lo + MathExModified.random.get().nextInt(w);
>     }
>     
>     public static int[] permutate(final int n) {
>         return MathExModified.random.get().permutate(n);
>     }
>     
>     public static void permutate(final int[] x) {
>         MathExModified.random.get().permutate(x);
>     }
>     
>     public static void permutate(final float[] x) {
>         MathExModified.random.get().permutate(x);
>     }
>     
>     public static void permutate(final double[] x) {
>         MathExModified.random.get().permutate(x);
>     }
>     
>     public static void permutate(final Object[] x) {
>         MathExModified.random.get().permutate(x);
>     }
>     
>     public static int softmax(final double[] posteriori) {
>         return softmax(posteriori, posteriori.length);
>     }
>     
>     public static int softmax(final double[] x, final int k) {
>         int y = -1;
>         double max = Double.NEGATIVE_INFINITY;
>         for (int i = 0; i < k; ++i) {
>             if (x[i] > max) {
>                 max = x[i];
>                 y = i;
>             }
>         }
>         double Z = 0.0;
>         for (int j = 0; j < k; ++j) {
>             final double out = Math.exp(x[j] - max);
>             x[j] = out;
>             Z += out;
>         }
>         for (int j = 0; j < k; ++j) {
>             final int n = j;
>             x[n] /= Z;
>         }
>         return y;
>     }
>     
>     public static int[] c(final int... x) {
>         return x;
>     }
>     
>     public static float[] c(final float... x) {
>         return x;
>     }
>     
>     public static double[] c(final double... x) {
>         return x;
>     }
>     
>     public static String[] c(final String... x) {
>         return x;
>     }
>     
>     public static int[] c(final int[]... list) {
>         int n = 0;
>         for (final int[] x : list) {
>             n += x.length;
>         }
>         final int[] y = new int[n];
>         int pos = 0;
>         for (final int[] x2 : list) {
>             System.arraycopy(x2, 0, y, pos, x2.length);
>             pos += x2.length;
>         }
>         return y;
>     }
>     
>     public static float[] c(final float[]... list) {
>         int n = 0;
>         for (final float[] x : list) {
>             n += x.length;
>         }
>         final float[] y = new float[n];
>         int pos = 0;
>         for (final float[] x2 : list) {
>             System.arraycopy(x2, 0, y, pos, x2.length);
>             pos += x2.length;
>         }
>         return y;
>     }
>     
>     public static double[] c(final double[]... list) {
>         int n = 0;
>         for (final double[] x : list) {
>             n += x.length;
>         }
>         final double[] y = new double[n];
>         int pos = 0;
>         for (final double[] x2 : list) {
>             System.arraycopy(x2, 0, y, pos, x2.length);
>             pos += x2.length;
>         }
>         return y;
>     }
>     
>     public static String[] c(final String[]... list) {
>         int n = 0;
>         for (final String[] x : list) {
>             n += x.length;
>         }
>         final String[] y = new String[n];
>         int pos = 0;
>         for (final String[] x2 : list) {
>             System.arraycopy(x2, 0, y, pos, x2.length);
>             pos += x2.length;
>         }
>         return y;
>     }
>     
>     public static int[] cbind(final int[]... x) {
>         return c(x);
>     }
>     
>     public static float[] cbind(final float[]... x) {
>         return c(x);
>     }
>     
>     public static double[] cbind(final double[]... x) {
>         return c(x);
>     }
>     
>     public static String[] cbind(final String[]... x) {
>         return c(x);
>     }
>     
>     public static int[][] rbind(final int[]... x) {
>         return x;
>     }
>     
>     public static float[][] rbind(final float[]... x) {
>         return x;
>     }
>     
>     public static double[][] rbind(final double[]... x) {
>         return x;
>     }
>     
>     public static String[][] rbind(final String[]... x) {
>         return x;
>     }
>     
>     public static <E> E[] slice(final E[] data, final int[] index) {
>         final int n = index.length;
>         final Object[] x = (Object[])Array.newInstance(data.getClass().getComponentType(), n);
>         for (int i = 0; i < n; ++i) {
>             x[i] = data[index[i]];
>         }
>         return (E[])x;
>     }
>     
>     public static int[] slice(final int[] data, final int[] index) {
>         final int n = index.length;
>         final int[] x = new int[n];
>         for (int i = 0; i < n; ++i) {
>             x[i] = data[index[i]];
>         }
>         return x;
>     }
>     
>     public static float[] slice(final float[] data, final int[] index) {
>         final int n = index.length;
>         final float[] x = new float[n];
>         for (int i = 0; i < n; ++i) {
>             x[i] = data[index[i]];
>         }
>         return x;
>     }
>     
>     public static double[] slice(final double[] data, final int[] index) {
>         final int n = index.length;
>         final double[] x = new double[n];
>         for (int i = 0; i < n; ++i) {
>             x[i] = data[index[i]];
>         }
>         return x;
>     }
>     
>     public static boolean contains(final double[][] polygon, final double[] point) {
>         return contains(polygon, point[0], point[1]);
>     }
>     
>     public static boolean contains(final double[][] polygon, final double x, final double y) {
>         if (polygon.length <= 2) {
>             return false;
>         }
>         int hits = 0;
>         final int n = polygon.length;
>         double lastx = polygon[n - 1][0];
>         double lasty = polygon[n - 1][1];
>         for (int i = 0; i < n; ++i) {
>             final double curx = polygon[i][0];
>             final double cury = polygon[i][1];
>             Label_0225: {
>                 if (cury != lasty) {
>                     double leftx;
>                     if (curx < lastx) {
>                         if (x >= lastx) {
>                             break Label_0225;
>                         }
>                         leftx = curx;
>                     }
>                     else {
>                         if (x >= curx) {
>                             break Label_0225;
>                         }
>                         leftx = lastx;
>                     }
>                     double test1;
>                     double test2;
>                     if (cury < lasty) {
>                         if (y < cury) {
>                             break Label_0225;
>                         }
>                         if (y >= lasty) {
>                             break Label_0225;
>                         }
>                         if (x < leftx) {
>                             ++hits;
>                             break Label_0225;
>                         }
>                         test1 = x - curx;
>                         test2 = y - cury;
>                     }
>                     else {
>                         if (y < lasty) {
>                             break Label_0225;
>                         }
>                         if (y >= cury) {
>                             break Label_0225;
>                         }
>                         if (x < leftx) {
>                             ++hits;
>                             break Label_0225;
>                         }
>                         test1 = x - lastx;
>                         test2 = y - lasty;
>                     }
>                     if (test1 < test2 / (lasty - cury) * (lastx - curx)) {
662,672c595,596
<                         break label75;
<                      }
< 
<                      test1 = x - lastx;
<                      test2 = y - lasty;
<                   }
< 
<                   if (test1 < test2 / (lasty - cury) * (lastx - curx)) {
<                      ++hits;
<                   }
<                }
---
>                     }
>                 }
674d597
< 
677,1637c600,1301
<          }
< 
<          if ((hits & 1) != 0) {
<             return true;
<          } else {
<             return false;
<          }
<       }
<    }
< 
<    public static int[] omit(int[] a, int value) {
<       int n = 0;
<       int[] var6 = a;
<       int x = a.length;
< 
<       int x;
<       for(int var4 = 0; var4 < x; ++var4) {
<          x = var6[var4];
<          if (x != value) {
<             ++n;
<          }
<       }
< 
<       x = 0;
<       int[] b = new int[n];
<       int[] var8 = a;
<       int var7 = a.length;
< 
<       for(int var10 = 0; var10 < var7; ++var10) {
<          x = var8[var10];
<          if (x != value) {
<             b[x++] = x;
<          }
<       }
< 
<       return b;
<    }
< 
<    public static float[] omit(float[] a, float value) {
<       int n = 0;
<       float[] var6 = a;
<       int var5 = a.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          float x = var6[var4];
<          if (x != value) {
<             ++n;
<          }
<       }
< 
<       int i = 0;
<       float[] b = new float[n];
<       float[] var8 = a;
<       int var7 = a.length;
< 
<       for(int var12 = 0; var12 < var7; ++var12) {
<          float x = var8[var12];
<          if (x != value) {
<             b[i++] = x;
<          }
<       }
< 
<       return b;
<    }
< 
<    public static double[] omit(double[] a, double value) {
<       int n = 0;
<       double[] var8 = a;
<       int var7 = a.length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          double x = var8[var6];
<          if (x != value) {
<             ++n;
<          }
<       }
< 
<       int i = 0;
<       double[] b = new double[n];
<       double[] var10 = a;
<       int var9 = a.length;
< 
<       for(int var13 = 0; var13 < var9; ++var13) {
<          double x = var10[var13];
<          if (x != value) {
<             b[i++] = x;
<          }
<       }
< 
<       return b;
<    }
< 
<    public static float[] omitNaN(float[] a) {
<       int n = 0;
<       float[] var5 = a;
<       int var4 = a.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          float x = var5[var3];
<          if (!Float.isNaN(x)) {
<             ++n;
<          }
<       }
< 
<       int i = 0;
<       float[] b = new float[n];
<       float[] var7 = a;
<       int var6 = a.length;
< 
<       for(int var11 = 0; var11 < var6; ++var11) {
<          float x = var7[var11];
<          if (!Float.isNaN(x)) {
<             b[i++] = x;
<          }
<       }
< 
<       return b;
<    }
< 
<    public static double[] omitNaN(double[] a) {
<       int n = 0;
<       double[] var6 = a;
<       int var5 = a.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          double x = var6[var4];
<          if (!Double.isNaN(x)) {
<             ++n;
<          }
<       }
< 
<       int i = 0;
<       double[] b = new double[n];
<       double[] var8 = a;
<       int var7 = a.length;
< 
<       for(int var11 = 0; var11 < var7; ++var11) {
<          double x = var8[var11];
<          if (!Double.isNaN(x)) {
<             b[i++] = x;
<          }
<       }
< 
<       return b;
<    }
< 
<    public static void reverse(int[] a) {
<       int i = 0;
<       int j = a.length - 1;
< 
<       while(i < j) {
<          SortModified.swap(a, i++, j--);
<       }
< 
<    }
< 
<    public static void reverse(float[] a) {
<       int i = 0;
<       int j = a.length - 1;
< 
<       while(i < j) {
<          SortModified.swap(a, i++, j--);
<       }
< 
<    }
< 
<    public static void reverse(double[] a) {
<       int i = 0;
<       int j = a.length - 1;
< 
<       while(i < j) {
<          SortModified.swap(a, i++, j--);
<       }
< 
<    }
< 
<    public static <T> void reverse(T[] a) {
<       int i = 0;
<       int j = a.length - 1;
< 
<       while(i < j) {
<          SortModified.swap(a, i++, j--);
<       }
< 
<    }
< 
<    public static int mode(int[] a) {
<       Arrays.sort(a);
<       int mode = -1;
<       int count = 0;
<       int currentValue = a[0];
<       int currentCount = 1;
< 
<       for(int i = 1; i < a.length; ++i) {
<          if (a[i] != currentValue) {
<             if (currentCount > count) {
<                mode = currentValue;
<                count = currentCount;
<             }
< 
<             currentValue = a[i];
<             currentCount = 1;
<          } else {
<             ++currentCount;
<          }
<       }
< 
<       if (currentCount > count) {
<          mode = currentValue;
<       }
< 
<       return mode;
<    }
< 
<    public static int min(int a, int b, int c) {
<       return Math.min(Math.min(a, b), c);
<    }
< 
<    public static float min(float a, float b, float c) {
<       return Math.min(Math.min(a, b), c);
<    }
< 
<    public static double min(double a, double b, double c) {
<       return Math.min(Math.min(a, b), c);
<    }
< 
<    public static int min(int a, int b, int c, int d) {
<       return Math.min(Math.min(Math.min(a, b), c), d);
<    }
< 
<    public static float min(float a, float b, float c, float d) {
<       return Math.min(Math.min(Math.min(a, b), c), d);
<    }
< 
<    public static double min(double a, double b, double c, double d) {
<       return Math.min(Math.min(Math.min(a, b), c), d);
<    }
< 
<    public static int max(int a, int b, int c) {
<       return Math.max(Math.max(a, b), c);
<    }
< 
<    public static float max(float a, float b, float c) {
<       return Math.max(Math.max(a, b), c);
<    }
< 
<    public static double max(double a, double b, double c) {
<       return Math.max(Math.max(a, b), c);
<    }
< 
<    public static int max(int a, int b, int c, int d) {
<       return Math.max(Math.max(Math.max(a, b), c), d);
<    }
< 
<    public static float max(float a, float b, float c, float d) {
<       return Math.max(Math.max(Math.max(a, b), c), d);
<    }
< 
<    public static double max(double a, double b, double c, double d) {
<       return Math.max(Math.max(Math.max(a, b), c), d);
<    }
< 
<    public static int min(int[] x) {
<       int min = x[0];
<       int[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int n = var5[var3];
<          if (n < min) {
<             min = n;
<          }
<       }
< 
<       return min;
<    }
< 
<    public static float min(float[] x) {
<       float min = Float.POSITIVE_INFINITY;
<       float[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          float n = var5[var3];
<          if (n < min) {
<             min = n;
<          }
<       }
< 
<       return min;
<    }
< 
<    public static double min(double[] x) {
<       double min = Double.POSITIVE_INFINITY;
<       double[] var7 = x;
<       int var6 = x.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double n = var7[var5];
<          if (n < min) {
<             min = n;
<          }
<       }
< 
<       return min;
<    }
< 
<    public static int whichMin(int[] x) {
<       int min = x[0];
<       int which = 0;
< 
<       for(int i = 1; i < x.length; ++i) {
<          if (x[i] < min) {
<             min = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int whichMin(float[] x) {
<       float min = Float.POSITIVE_INFINITY;
<       int which = 0;
< 
<       for(int i = 0; i < x.length; ++i) {
<          if (x[i] < min) {
<             min = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int whichMin(double[] x) {
<       double min = Double.POSITIVE_INFINITY;
<       int which = 0;
< 
<       for(int i = 0; i < x.length; ++i) {
<          if (x[i] < min) {
<             min = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int max(int[] x) {
<       int max = x[0];
<       int[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int n = var5[var3];
<          if (n > max) {
<             max = n;
<          }
<       }
< 
<       return max;
<    }
< 
<    public static float max(float[] x) {
<       float max = Float.NEGATIVE_INFINITY;
<       float[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          float n = var5[var3];
<          if (n > max) {
<             max = n;
<          }
<       }
< 
<       return max;
<    }
< 
<    public static double max(double[] x) {
<       double max = Double.NEGATIVE_INFINITY;
<       double[] var7 = x;
<       int var6 = x.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double n = var7[var5];
<          if (n > max) {
<             max = n;
<          }
<       }
< 
<       return max;
<    }
< 
<    public static int whichMax(int[] x) {
<       int max = x[0];
<       int which = 0;
< 
<       for(int i = 1; i < x.length; ++i) {
<          if (x[i] > max) {
<             max = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int whichMax(float[] x) {
<       float max = Float.NEGATIVE_INFINITY;
<       int which = 0;
< 
<       for(int i = 0; i < x.length; ++i) {
<          if (x[i] > max) {
<             max = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int whichMax(double[] x) {
<       double max = Double.NEGATIVE_INFINITY;
<       int which = 0;
< 
<       for(int i = 0; i < x.length; ++i) {
<          if (x[i] > max) {
<             max = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int min(int[][] matrix) {
<       int min = matrix[0][0];
<       int[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int[] x = var5[var3];
<          int[] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             int y = var9[var7];
<             if (min > y) {
<                min = y;
<             }
<          }
<       }
< 
<       return min;
<    }
< 
<    public static double min(double[][] matrix) {
<       double min = Double.POSITIVE_INFINITY;
<       double[][] var6 = matrix;
<       int var5 = matrix.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          double[] x = var6[var4];
<          double[] var11 = x;
<          int var10 = x.length;
< 
<          for(int var9 = 0; var9 < var10; ++var9) {
<             double y = var11[var9];
<             if (min > y) {
<                min = y;
<             }
<          }
<       }
< 
<       return min;
<    }
< 
<    public static int max(int[][] matrix) {
<       int max = matrix[0][0];
<       int[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int[] x = var5[var3];
<          int[] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             int y = var9[var7];
<             if (max < y) {
<                max = y;
<             }
<          }
<       }
< 
<       return max;
<    }
< 
<    public static double max(double[][] matrix) {
<       double max = Double.NEGATIVE_INFINITY;
<       double[][] var6 = matrix;
<       int var5 = matrix.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          double[] x = var6[var4];
<          double[] var11 = x;
<          int var10 = x.length;
< 
<          for(int var9 = 0; var9 < var10; ++var9) {
<             double y = var11[var9];
<             if (max < y) {
<                max = y;
<             }
<          }
<       }
< 
<       return max;
<    }
< 
<    public static IntPair whichMin(double[][] matrix) {
<       double min = Double.POSITIVE_INFINITY;
<       int whichRow = 0;
<       int whichCol = 0;
< 
<       for(int i = 0; i < matrix.length; ++i) {
<          for(int j = 0; j < matrix[i].length; ++j) {
<             if (matrix[i][j] < min) {
<                min = matrix[i][j];
<                whichRow = i;
<                whichCol = j;
<             }
<          }
<       }
< 
<       return new IntPair(whichRow, whichCol);
<    }
< 
<    public static IntPair whichMax(double[][] matrix) {
<       double max = Double.NEGATIVE_INFINITY;
<       int whichRow = 0;
<       int whichCol = 0;
< 
<       for(int i = 0; i < matrix.length; ++i) {
<          for(int j = 0; j < matrix[i].length; ++j) {
<             if (matrix[i][j] > max) {
<                max = matrix[i][j];
<                whichRow = i;
<                whichCol = j;
<             }
<          }
<       }
< 
<       return new IntPair(whichRow, whichCol);
<    }
< 
<    public static double[][] transpose(double[][] matrix) {
<       int m = matrix.length;
<       int n = matrix[0].length;
<       double[][] t = new double[n][m];
< 
<       for(int i = 0; i < m; ++i) {
<          for(int j = 0; j < n; ++j) {
<             t[j][i] = matrix[i][j];
<          }
<       }
< 
<       return t;
<    }
< 
<    public static int[] rowMin(int[][] matrix) {
<       int[] x = new int[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = min(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static int[] rowMax(int[][] matrix) {
<       int[] x = new int[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = max(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static long[] rowSums(int[][] matrix) {
<       long[] x = new long[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = sum(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static double[] rowMin(double[][] matrix) {
<       double[] x = new double[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = min(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static double[] rowMax(double[][] matrix) {
<       double[] x = new double[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = max(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static double[] rowSums(double[][] matrix) {
<       double[] x = new double[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = sum(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static double[] rowMeans(double[][] matrix) {
<       double[] x = new double[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = mean(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static double[] rowSds(double[][] matrix) {
<       double[] x = new double[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = sd(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static int[] colMin(int[][] matrix) {
<       int[] x = new int[matrix[0].length];
<       Arrays.fill(x, Integer.MAX_VALUE);
<       int[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int[] row = var5[var3];
< 
<          for(int j = 0; j < x.length; ++j) {
<             if (x[j] > row[j]) {
<                x[j] = row[j];
<             }
<          }
<       }
< 
<       return x;
<    }
< 
<    public static int[] colMax(int[][] matrix) {
<       int[] x = new int[matrix[0].length];
<       Arrays.fill(x, Integer.MIN_VALUE);
<       int[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int[] row = var5[var3];
< 
<          for(int j = 0; j < x.length; ++j) {
<             if (x[j] < row[j]) {
<                x[j] = row[j];
<             }
<          }
<       }
< 
<       return x;
<    }
< 
<    public static long[] colSums(int[][] matrix) {
<       long[] x = new long[matrix[0].length];
<       int[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int[] row = var5[var3];
< 
<          for(int j = 0; j < x.length; ++j) {
<             x[j] += (long)row[j];
<          }
<       }
< 
<       return x;
<    }
< 
<    public static double[] colMin(double[][] matrix) {
<       double[] x = new double[matrix[0].length];
<       Arrays.fill(x, Double.POSITIVE_INFINITY);
<       double[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          double[] row = var5[var3];
< 
<          for(int j = 0; j < x.length; ++j) {
<             if (x[j] > row[j]) {
<                x[j] = row[j];
<             }
<          }
<       }
< 
<       return x;
<    }
< 
<    public static double[] colMax(double[][] matrix) {
<       double[] x = new double[matrix[0].length];
<       Arrays.fill(x, Double.NEGATIVE_INFINITY);
<       double[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          double[] row = var5[var3];
< 
<          for(int j = 0; j < x.length; ++j) {
<             if (x[j] < row[j]) {
<                x[j] = row[j];
<             }
<          }
<       }
< 
<       return x;
<    }
< 
<    public static double[] colSums(double[][] matrix) {
<       double[] x = (double[])matrix[0].clone();
< 
<       for(int i = 1; i < matrix.length; ++i) {
<          for(int j = 0; j < x.length; ++j) {
<             x[j] += matrix[i][j];
<          }
<       }
< 
<       return x;
<    }
< 
<    public static double[] colMeans(double[][] matrix) {
<       double[] x = (double[])matrix[0].clone();
< 
<       for(int i = 1; i < matrix.length; ++i) {
<          for(int j = 0; j < x.length; ++j) {
<             x[j] += matrix[i][j];
<          }
<       }
< 
<       scale(1.0D / (double)matrix.length, x);
<       return x;
<    }
< 
<    public static double[] colSds(double[][] matrix) {
<       if (matrix.length < 2) {
<          throw new IllegalArgumentException("matrix length is less than 2.");
<       } else {
<          int p = matrix[0].length;
<          double[] sum = new double[p];
<          double[] sumsq = new double[p];
<          double[][] var7 = matrix;
<          int var6 = matrix.length;
< 
<          int i;
<          for(i = 0; i < var6; ++i) {
<             double[] row = var7[i];
< 
<             for(int i = 0; i < p; ++i) {
<                sum[i] += row[i];
<                sumsq[i] += row[i] * row[i];
<             }
<          }
< 
<          int n = matrix.length - 1;
< 
<          for(i = 0; i < p; ++i) {
<             sumsq[i] = Math.sqrt(sumsq[i] / (double)n - sum[i] / (double)matrix.length * (sum[i] / (double)n));
<          }
< 
<          return sumsq;
<       }
<    }
< 
<    public static int sum(byte[] x) {
<       int sum = 0;
<       byte[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int n = var5[var3];
<          sum += n;
<       }
< 
<       return sum;
<    }
< 
<    public static long sum(int[] x) {
<       long sum = 0L;
<       int[] var6 = x;
<       int var5 = x.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          int n = var6[var4];
<          sum += (long)n;
<       }
< 
<       return (long)((int)sum);
<    }
< 
<    public static double sum(float[] x) {
<       double sum = 0.0D;
<       float[] var6 = x;
<       int var5 = x.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          float n = var6[var4];
<          sum += (double)n;
<       }
< 
<       return sum;
<    }
< 
<    public static double sum(double[] x) {
<       double sum = 0.0D;
<       double[] var7 = x;
<       int var6 = x.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double n = var7[var5];
<          sum += n;
<       }
< 
<       return sum;
<    }
< 
<    public static int median(int[] x) {
<       return QuickSelectModified.median(x);
<    }
< 
<    public static float median(float[] x) {
<       return QuickSelectModified.median(x);
<    }
< 
<    public static double median(double[] x) {
<       return QuickSelectModified.median(x);
<    }
< 
<    public static <T extends Comparable<? super T>> T median(T[] x) {
<       return QuickSelectModified.median(x);
<    }
< 
<    public static int q1(int[] x) {
<       return QuickSelectModified.q1(x);
<    }
< 
<    public static float q1(float[] x) {
<       return QuickSelectModified.q1(x);
<    }
< 
<    public static double q1(double[] x) {
<       return QuickSelectModified.q1(x);
<    }
< 
<    public static <T extends Comparable<? super T>> T q1(T[] x) {
<       return QuickSelectModified.q1(x);
<    }
< 
<    public static int q3(int[] x) {
<       return QuickSelectModified.q3(x);
<    }
< 
<    public static float q3(float[] x) {
<       return QuickSelectModified.q3(x);
<    }
< 
<    public static double q3(double[] x) {
<       return QuickSelectModified.q3(x);
<    }
< 
<    public static <T extends Comparable<? super T>> T q3(T[] x) {
<       return QuickSelectModified.q3(x);
<    }
< 
<    public static double mean(int[] x) {
<       return (double)sum(x) / (double)x.length;
<    }
< 
<    public static double mean(float[] x) {
<       return sum(x) / (double)x.length;
<    }
< 
<    public static double mean(double[] x) {
<       return sum(x) / (double)x.length;
<    }
< 
<    public static double var(int[] x) {
<       if (x.length < 2) {
<          throw new IllegalArgumentException("Array length is less than 2.");
<       } else {
<          double sum = 0.0D;
<          double sumsq = 0.0D;
<          int[] var8 = x;
<          int var7 = x.length;
< 
<          int n;
<          for(int var6 = 0; var6 < var7; ++var6) {
<             n = var8[var6];
<             sum += (double)n;
<             sumsq += (double)(n * n);
<          }
< 
<          n = x.length - 1;
<          return sumsq / (double)n - sum / (double)x.length * (sum / (double)n);
<       }
<    }
< 
<    public static double var(float[] x) {
<       if (x.length < 2) {
<          throw new IllegalArgumentException("Array length is less than 2.");
<       } else {
<          double sum = 0.0D;
<          double sumsq = 0.0D;
<          float[] var8 = x;
<          int var7 = x.length;
< 
<          for(int var6 = 0; var6 < var7; ++var6) {
<             float xi = var8[var6];
<             sum += (double)xi;
<             sumsq += (double)(xi * xi);
<          }
< 
<          int n = x.length - 1;
<          return sumsq / (double)n - sum / (double)x.length * (sum / (double)n);
<       }
<    }
< 
<    public static double var(double[] x) {
<       if (x.length < 2) {
<          throw new IllegalArgumentException("Array length is less than 2.");
<       } else {
<          double sum = 0.0D;
<          double sumsq = 0.0D;
<          double[] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             double xi = var9[var7];
---
>         }
>         return (hits & 0x1) != 0x0;
>     }
>     
>     public static int[] omit(final int[] a, final int value) {
>         int n = 0;
>         for (final int x : a) {
>             if (x != value) {
>                 ++n;
>             }
>         }
>         int i = 0;
>         final int[] b = new int[n];
>         for (final int x2 : a) {
>             if (x2 != value) {
>                 b[i++] = x2;
>             }
>         }
>         return b;
>     }
>     
>     public static float[] omit(final float[] a, final float value) {
>         int n = 0;
>         for (final float x : a) {
>             if (x != value) {
>                 ++n;
>             }
>         }
>         int i = 0;
>         final float[] b = new float[n];
>         for (final float x2 : a) {
>             if (x2 != value) {
>                 b[i++] = x2;
>             }
>         }
>         return b;
>     }
>     
>     public static double[] omit(final double[] a, final double value) {
>         int n = 0;
>         for (final double x : a) {
>             if (x != value) {
>                 ++n;
>             }
>         }
>         int i = 0;
>         final double[] b = new double[n];
>         for (final double x2 : a) {
>             if (x2 != value) {
>                 b[i++] = x2;
>             }
>         }
>         return b;
>     }
>     
>     public static float[] omitNaN(final float[] a) {
>         int n = 0;
>         for (final float x : a) {
>             if (!Float.isNaN(x)) {
>                 ++n;
>             }
>         }
>         int i = 0;
>         final float[] b = new float[n];
>         for (final float x2 : a) {
>             if (!Float.isNaN(x2)) {
>                 b[i++] = x2;
>             }
>         }
>         return b;
>     }
>     
>     public static double[] omitNaN(final double[] a) {
>         int n = 0;
>         for (final double x : a) {
>             if (!Double.isNaN(x)) {
>                 ++n;
>             }
>         }
>         int i = 0;
>         final double[] b = new double[n];
>         for (final double x2 : a) {
>             if (!Double.isNaN(x2)) {
>                 b[i++] = x2;
>             }
>         }
>         return b;
>     }
>     
>     public static void reverse(final int[] a) {
>         int i = 0;
>         int j = a.length - 1;
>         while (i < j) {
>             SortModified.swap(a, i++, j--);
>         }
>     }
>     
>     public static void reverse(final float[] a) {
>         int i = 0;
>         int j = a.length - 1;
>         while (i < j) {
>             SortModified.swap(a, i++, j--);
>         }
>     }
>     
>     public static void reverse(final double[] a) {
>         int i = 0;
>         int j = a.length - 1;
>         while (i < j) {
>             SortModified.swap(a, i++, j--);
>         }
>     }
>     
>     public static <T> void reverse(final T[] a) {
>         int i = 0;
>         int j = a.length - 1;
>         while (i < j) {
>             SortModified.swap(a, i++, j--);
>         }
>     }
>     
>     public static int mode(final int[] a) {
>         Arrays.sort(a);
>         int mode = -1;
>         int count = 0;
>         int currentValue = a[0];
>         int currentCount = 1;
>         for (int i = 1; i < a.length; ++i) {
>             if (a[i] != currentValue) {
>                 if (currentCount > count) {
>                     mode = currentValue;
>                     count = currentCount;
>                 }
>                 currentValue = a[i];
>                 currentCount = 1;
>             }
>             else {
>                 ++currentCount;
>             }
>         }
>         if (currentCount > count) {
>             mode = currentValue;
>         }
>         return mode;
>     }
>     
>     public static int min(final int a, final int b, final int c) {
>         return Math.min(Math.min(a, b), c);
>     }
>     
>     public static float min(final float a, final float b, final float c) {
>         return Math.min(Math.min(a, b), c);
>     }
>     
>     public static double min(final double a, final double b, final double c) {
>         return Math.min(Math.min(a, b), c);
>     }
>     
>     public static int min(final int a, final int b, final int c, final int d) {
>         return Math.min(Math.min(Math.min(a, b), c), d);
>     }
>     
>     public static float min(final float a, final float b, final float c, final float d) {
>         return Math.min(Math.min(Math.min(a, b), c), d);
>     }
>     
>     public static double min(final double a, final double b, final double c, final double d) {
>         return Math.min(Math.min(Math.min(a, b), c), d);
>     }
>     
>     public static int max(final int a, final int b, final int c) {
>         return Math.max(Math.max(a, b), c);
>     }
>     
>     public static float max(final float a, final float b, final float c) {
>         return Math.max(Math.max(a, b), c);
>     }
>     
>     public static double max(final double a, final double b, final double c) {
>         return Math.max(Math.max(a, b), c);
>     }
>     
>     public static int max(final int a, final int b, final int c, final int d) {
>         return Math.max(Math.max(Math.max(a, b), c), d);
>     }
>     
>     public static float max(final float a, final float b, final float c, final float d) {
>         return Math.max(Math.max(Math.max(a, b), c), d);
>     }
>     
>     public static double max(final double a, final double b, final double c, final double d) {
>         return Math.max(Math.max(Math.max(a, b), c), d);
>     }
>     
>     public static int min(final int[] x) {
>         int min = x[0];
>         for (final int n : x) {
>             if (n < min) {
>                 min = n;
>             }
>         }
>         return min;
>     }
>     
>     public static float min(final float[] x) {
>         float min = Float.POSITIVE_INFINITY;
>         for (final float n : x) {
>             if (n < min) {
>                 min = n;
>             }
>         }
>         return min;
>     }
>     
>     public static double min(final double[] x) {
>         double min = Double.POSITIVE_INFINITY;
>         for (final double n : x) {
>             if (n < min) {
>                 min = n;
>             }
>         }
>         return min;
>     }
>     
>     public static int whichMin(final int[] x) {
>         int min = x[0];
>         int which = 0;
>         for (int i = 1; i < x.length; ++i) {
>             if (x[i] < min) {
>                 min = x[i];
>                 which = i;
>             }
>         }
>         return which;
>     }
>     
>     public static int whichMin(final float[] x) {
>         float min = Float.POSITIVE_INFINITY;
>         int which = 0;
>         for (int i = 0; i < x.length; ++i) {
>             if (x[i] < min) {
>                 min = x[i];
>                 which = i;
>             }
>         }
>         return which;
>     }
>     
>     public static int whichMin(final double[] x) {
>         double min = Double.POSITIVE_INFINITY;
>         int which = 0;
>         for (int i = 0; i < x.length; ++i) {
>             if (x[i] < min) {
>                 min = x[i];
>                 which = i;
>             }
>         }
>         return which;
>     }
>     
>     public static int max(final int[] x) {
>         int max = x[0];
>         for (final int n : x) {
>             if (n > max) {
>                 max = n;
>             }
>         }
>         return max;
>     }
>     
>     public static float max(final float[] x) {
>         float max = Float.NEGATIVE_INFINITY;
>         for (final float n : x) {
>             if (n > max) {
>                 max = n;
>             }
>         }
>         return max;
>     }
>     
>     public static double max(final double[] x) {
>         double max = Double.NEGATIVE_INFINITY;
>         for (final double n : x) {
>             if (n > max) {
>                 max = n;
>             }
>         }
>         return max;
>     }
>     
>     public static int whichMax(final int[] x) {
>         int max = x[0];
>         int which = 0;
>         for (int i = 1; i < x.length; ++i) {
>             if (x[i] > max) {
>                 max = x[i];
>                 which = i;
>             }
>         }
>         return which;
>     }
>     
>     public static int whichMax(final float[] x) {
>         float max = Float.NEGATIVE_INFINITY;
>         int which = 0;
>         for (int i = 0; i < x.length; ++i) {
>             if (x[i] > max) {
>                 max = x[i];
>                 which = i;
>             }
>         }
>         return which;
>     }
>     
>     public static int whichMax(final double[] x) {
>         double max = Double.NEGATIVE_INFINITY;
>         int which = 0;
>         for (int i = 0; i < x.length; ++i) {
>             if (x[i] > max) {
>                 max = x[i];
>                 which = i;
>             }
>         }
>         return which;
>     }
>     
>     public static int min(final int[][] matrix) {
>         int min = matrix[0][0];
>         for (final int[] x : matrix) {
>             int[] array;
>             for (int length2 = (array = x).length, j = 0; j < length2; ++j) {
>                 final int y = array[j];
>                 if (min > y) {
>                     min = y;
>                 }
>             }
>         }
>         return min;
>     }
>     
>     public static double min(final double[][] matrix) {
>         double min = Double.POSITIVE_INFINITY;
>         for (final double[] x : matrix) {
>             double[] array;
>             for (int length2 = (array = x).length, j = 0; j < length2; ++j) {
>                 final double y = array[j];
>                 if (min > y) {
>                     min = y;
>                 }
>             }
>         }
>         return min;
>     }
>     
>     public static int max(final int[][] matrix) {
>         int max = matrix[0][0];
>         for (final int[] x : matrix) {
>             int[] array;
>             for (int length2 = (array = x).length, j = 0; j < length2; ++j) {
>                 final int y = array[j];
>                 if (max < y) {
>                     max = y;
>                 }
>             }
>         }
>         return max;
>     }
>     
>     public static double max(final double[][] matrix) {
>         double max = Double.NEGATIVE_INFINITY;
>         for (final double[] x : matrix) {
>             double[] array;
>             for (int length2 = (array = x).length, j = 0; j < length2; ++j) {
>                 final double y = array[j];
>                 if (max < y) {
>                     max = y;
>                 }
>             }
>         }
>         return max;
>     }
>     
>     public static IntPair whichMin(final double[][] matrix) {
>         double min = Double.POSITIVE_INFINITY;
>         int whichRow = 0;
>         int whichCol = 0;
>         for (int i = 0; i < matrix.length; ++i) {
>             for (int j = 0; j < matrix[i].length; ++j) {
>                 if (matrix[i][j] < min) {
>                     min = matrix[i][j];
>                     whichRow = i;
>                     whichCol = j;
>                 }
>             }
>         }
>         return new IntPair(whichRow, whichCol);
>     }
>     
>     public static IntPair whichMax(final double[][] matrix) {
>         double max = Double.NEGATIVE_INFINITY;
>         int whichRow = 0;
>         int whichCol = 0;
>         for (int i = 0; i < matrix.length; ++i) {
>             for (int j = 0; j < matrix[i].length; ++j) {
>                 if (matrix[i][j] > max) {
>                     max = matrix[i][j];
>                     whichRow = i;
>                     whichCol = j;
>                 }
>             }
>         }
>         return new IntPair(whichRow, whichCol);
>     }
>     
>     public static double[][] transpose(final double[][] matrix) {
>         final int m = matrix.length;
>         final int n = matrix[0].length;
>         final double[][] t = new double[n][m];
>         for (int i = 0; i < m; ++i) {
>             for (int j = 0; j < n; ++j) {
>                 t[j][i] = matrix[i][j];
>             }
>         }
>         return t;
>     }
>     
>     public static int[] rowMin(final int[][] matrix) {
>         final int[] x = new int[matrix.length];
>         for (int i = 0; i < x.length; ++i) {
>             x[i] = min(matrix[i]);
>         }
>         return x;
>     }
>     
>     public static int[] rowMax(final int[][] matrix) {
>         final int[] x = new int[matrix.length];
>         for (int i = 0; i < x.length; ++i) {
>             x[i] = max(matrix[i]);
>         }
>         return x;
>     }
>     
>     public static long[] rowSums(final int[][] matrix) {
>         final long[] x = new long[matrix.length];
>         for (int i = 0; i < x.length; ++i) {
>             x[i] = sum(matrix[i]);
>         }
>         return x;
>     }
>     
>     public static double[] rowMin(final double[][] matrix) {
>         final double[] x = new double[matrix.length];
>         for (int i = 0; i < x.length; ++i) {
>             x[i] = min(matrix[i]);
>         }
>         return x;
>     }
>     
>     public static double[] rowMax(final double[][] matrix) {
>         final double[] x = new double[matrix.length];
>         for (int i = 0; i < x.length; ++i) {
>             x[i] = max(matrix[i]);
>         }
>         return x;
>     }
>     
>     public static double[] rowSums(final double[][] matrix) {
>         final double[] x = new double[matrix.length];
>         for (int i = 0; i < x.length; ++i) {
>             x[i] = sum(matrix[i]);
>         }
>         return x;
>     }
>     
>     public static double[] rowMeans(final double[][] matrix) {
>         final double[] x = new double[matrix.length];
>         for (int i = 0; i < x.length; ++i) {
>             x[i] = mean(matrix[i]);
>         }
>         return x;
>     }
>     
>     public static double[] rowSds(final double[][] matrix) {
>         final double[] x = new double[matrix.length];
>         for (int i = 0; i < x.length; ++i) {
>             x[i] = sd(matrix[i]);
>         }
>         return x;
>     }
>     
>     public static int[] colMin(final int[][] matrix) {
>         final int[] x = new int[matrix[0].length];
>         Arrays.fill(x, Integer.MAX_VALUE);
>         for (final int[] row : matrix) {
>             for (int j = 0; j < x.length; ++j) {
>                 if (x[j] > row[j]) {
>                     x[j] = row[j];
>                 }
>             }
>         }
>         return x;
>     }
>     
>     public static int[] colMax(final int[][] matrix) {
>         final int[] x = new int[matrix[0].length];
>         Arrays.fill(x, Integer.MIN_VALUE);
>         for (final int[] row : matrix) {
>             for (int j = 0; j < x.length; ++j) {
>                 if (x[j] < row[j]) {
>                     x[j] = row[j];
>                 }
>             }
>         }
>         return x;
>     }
>     
>     public static long[] colSums(final int[][] matrix) {
>         final long[] x = new long[matrix[0].length];
>         for (final int[] row : matrix) {
>             for (int j = 0; j < x.length; ++j) {
>                 final long[] array = x;
>                 final int n = j;
>                 array[n] += row[j];
>             }
>         }
>         return x;
>     }
>     
>     public static double[] colMin(final double[][] matrix) {
>         final double[] x = new double[matrix[0].length];
>         Arrays.fill(x, Double.POSITIVE_INFINITY);
>         for (final double[] row : matrix) {
>             for (int j = 0; j < x.length; ++j) {
>                 if (x[j] > row[j]) {
>                     x[j] = row[j];
>                 }
>             }
>         }
>         return x;
>     }
>     
>     public static double[] colMax(final double[][] matrix) {
>         final double[] x = new double[matrix[0].length];
>         Arrays.fill(x, Double.NEGATIVE_INFINITY);
>         for (final double[] row : matrix) {
>             for (int j = 0; j < x.length; ++j) {
>                 if (x[j] < row[j]) {
>                     x[j] = row[j];
>                 }
>             }
>         }
>         return x;
>     }
>     
>     public static double[] colSums(final double[][] matrix) {
>         final double[] x = matrix[0].clone();
>         for (int i = 1; i < matrix.length; ++i) {
>             for (int j = 0; j < x.length; ++j) {
>                 final double[] array = x;
>                 final int n = j;
>                 array[n] += matrix[i][j];
>             }
>         }
>         return x;
>     }
>     
>     public static double[] colMeans(final double[][] matrix) {
>         final double[] x = matrix[0].clone();
>         for (int i = 1; i < matrix.length; ++i) {
>             for (int j = 0; j < x.length; ++j) {
>                 final double[] array = x;
>                 final int n = j;
>                 array[n] += matrix[i][j];
>             }
>         }
>         scale(1.0 / matrix.length, x);
>         return x;
>     }
>     
>     public static double[] colSds(final double[][] matrix) {
>         if (matrix.length < 2) {
>             throw new IllegalArgumentException("matrix length is less than 2.");
>         }
>         final int p = matrix[0].length;
>         final double[] sum = new double[p];
>         final double[] sumsq = new double[p];
>         for (final double[] row : matrix) {
>             for (int i = 0; i < p; ++i) {
>                 final double[] array = sum;
>                 final int n2 = i;
>                 array[n2] += row[i];
>                 final double[] array2 = sumsq;
>                 final int n3 = i;
>                 array2[n3] += row[i] * row[i];
>             }
>         }
>         final int n = matrix.length - 1;
>         for (int j = 0; j < p; ++j) {
>             sumsq[j] = Math.sqrt(sumsq[j] / n - sum[j] / matrix.length * (sum[j] / n));
>         }
>         return sumsq;
>     }
>     
>     public static int sum(final byte[] x) {
>         int sum = 0;
>         for (final int n : x) {
>             sum += n;
>         }
>         return sum;
>     }
>     
>     public static long sum(final int[] x) {
>         long sum = 0L;
>         for (final int n : x) {
>             sum += n;
>         }
>         return (int)sum;
>     }
>     
>     public static double sum(final float[] x) {
>         double sum = 0.0;
>         for (final float n : x) {
>             sum += n;
>         }
>         return sum;
>     }
>     
>     public static double sum(final double[] x) {
>         double sum = 0.0;
>         for (final double n : x) {
>             sum += n;
>         }
>         return sum;
>     }
>     
>     public static int median(final int[] x) {
>         return QuickSelectModified.median(x);
>     }
>     
>     public static float median(final float[] x) {
>         return QuickSelectModified.median(x);
>     }
>     
>     public static double median(final double[] x) {
>         return QuickSelectModified.median(x);
>     }
>     
>     public static <T extends Comparable<? super T>> T median(final T[] x) {
>         return QuickSelectModified.<T>median(x);
>     }
>     
>     public static int q1(final int[] x) {
>         return QuickSelectModified.q1(x);
>     }
>     
>     public static float q1(final float[] x) {
>         return QuickSelectModified.q1(x);
>     }
>     
>     public static double q1(final double[] x) {
>         return QuickSelectModified.q1(x);
>     }
>     
>     public static <T extends Comparable<? super T>> T q1(final T[] x) {
>         return QuickSelectModified.<T>q1(x);
>     }
>     
>     public static int q3(final int[] x) {
>         return QuickSelectModified.q3(x);
>     }
>     
>     public static float q3(final float[] x) {
>         return QuickSelectModified.q3(x);
>     }
>     
>     public static double q3(final double[] x) {
>         return QuickSelectModified.q3(x);
>     }
>     
>     public static <T extends Comparable<? super T>> T q3(final T[] x) {
>         return QuickSelectModified.<T>q3(x);
>     }
>     
>     public static double mean(final int[] x) {
>         return sum(x) / (double)x.length;
>     }
>     
>     public static double mean(final float[] x) {
>         return sum(x) / x.length;
>     }
>     
>     public static double mean(final double[] x) {
>         return sum(x) / x.length;
>     }
>     
>     public static double var(final int[] x) {
>         if (x.length < 2) {
>             throw new IllegalArgumentException("Array length is less than 2.");
>         }
>         double sum = 0.0;
>         double sumsq = 0.0;
>         for (final int xi : x) {
1640,1794c1304,1626
<          }
< 
<          int n = x.length - 1;
<          return sumsq / (double)n - sum / (double)x.length * (sum / (double)n);
<       }
<    }
< 
<    public static double sd(int[] x) {
<       return Math.sqrt(var(x));
<    }
< 
<    public static double sd(float[] x) {
<       return Math.sqrt(var(x));
<    }
< 
<    public static double sd(double[] x) {
<       return Math.sqrt(var(x));
<    }
< 
<    public static double mad(int[] x) {
<       int m = median(x);
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = Math.abs(x[i] - m);
<       }
< 
<       return (double)median(x);
<    }
< 
<    public static double mad(float[] x) {
<       float m = median(x);
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = Math.abs(x[i] - m);
<       }
< 
<       return (double)median(x);
<    }
< 
<    public static double mad(double[] x) {
<       double m = median(x);
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = Math.abs(x[i] - m);
<       }
< 
<       return median(x);
<    }
< 
<    public static double distance(int[] x, int[] y) {
<       return Math.sqrt(squaredDistance(x, y));
<    }
< 
<    public static double distance(float[] x, float[] y) {
<       return Math.sqrt(squaredDistance(x, y));
<    }
< 
<    public static double distance(double[] x, double[] y) {
<       return Math.sqrt(squaredDistance(x, y));
<    }
< 
<    public static double distance(SparseArrayModified x, SparseArrayModified y) {
<       return Math.sqrt(squaredDistance(x, y));
<    }
< 
<    public static double squaredDistance(int[] x, int[] y) {
<       double d = 0.0D;
<       int p1 = 0;
<       int p2 = 0;
< 
<       while(p1 < x.length && p2 < y.length) {
<          int i1 = x[p1];
<          int i2 = y[p2];
<          if (i1 == i2) {
<             ++p1;
<             ++p2;
<          } else if (i1 > i2) {
<             ++d;
<             ++p2;
<          } else {
<             ++d;
<             ++p1;
<          }
<       }
< 
<       d += (double)(x.length - p1);
<       d += (double)(y.length - p2);
<       return d;
<    }
< 
<    public static double squaredDistance(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          double sum;
<          double d1;
<          double d2;
<          switch(x.length) {
<          case 2:
<             sum = (double)x[0] - (double)y[0];
<             d1 = (double)x[1] - (double)y[1];
<             return sum * sum + d1 * d1;
<          case 3:
<             sum = (double)x[0] - (double)y[0];
<             d1 = (double)x[1] - (double)y[1];
<             d2 = (double)x[2] - (double)y[2];
<             return sum * sum + d1 * d1 + d2 * d2;
<          case 4:
<             sum = (double)x[0] - (double)y[0];
<             d1 = (double)x[1] - (double)y[1];
<             d2 = (double)x[2] - (double)y[2];
<             double d3 = (double)x[3] - (double)y[3];
<             return sum * sum + d1 * d1 + d2 * d2 + d3 * d3;
<          default:
<             sum = 0.0D;
< 
<             for(int i = 0; i < x.length; ++i) {
<                double d = (double)x[i] - (double)y[i];
<                sum += d * d;
<             }
< 
<             return sum;
<          }
<       }
<    }
< 
<    public static double squaredDistance(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          double sum;
<          double d1;
<          double d2;
<          switch(x.length) {
<          case 2:
<             sum = x[0] - y[0];
<             d1 = x[1] - y[1];
<             return sum * sum + d1 * d1;
<          case 3:
<             sum = x[0] - y[0];
<             d1 = x[1] - y[1];
<             d2 = x[2] - y[2];
<             return sum * sum + d1 * d1 + d2 * d2;
<          case 4:
<             sum = x[0] - y[0];
<             d1 = x[1] - y[1];
<             d2 = x[2] - y[2];
<             double d3 = x[3] - y[3];
<             return sum * sum + d1 * d1 + d2 * d2 + d3 * d3;
<          default:
<             sum = 0.0D;
< 
<             for(int i = 0; i < x.length; ++i) {
<                double d = x[i] - y[i];
<                sum += d * d;
---
>         }
>         final int n = x.length - 1;
>         return sumsq / n - sum / x.length * (sum / n);
>     }
>     
>     public static double var(final float[] x) {
>         if (x.length < 2) {
>             throw new IllegalArgumentException("Array length is less than 2.");
>         }
>         double sum = 0.0;
>         double sumsq = 0.0;
>         for (final float xi : x) {
>             sum += xi;
>             sumsq += xi * xi;
>         }
>         final int n = x.length - 1;
>         return sumsq / n - sum / x.length * (sum / n);
>     }
>     
>     public static double var(final double[] x) {
>         if (x.length < 2) {
>             throw new IllegalArgumentException("Array length is less than 2.");
>         }
>         double sum = 0.0;
>         double sumsq = 0.0;
>         for (final double xi : x) {
>             sum += xi;
>             sumsq += xi * xi;
>         }
>         final int n = x.length - 1;
>         return sumsq / n - sum / x.length * (sum / n);
>     }
>     
>     public static double sd(final int[] x) {
>         return Math.sqrt(var(x));
>     }
>     
>     public static double sd(final float[] x) {
>         return Math.sqrt(var(x));
>     }
>     
>     public static double sd(final double[] x) {
>         return Math.sqrt(var(x));
>     }
>     
>     public static double mad(final int[] x) {
>         final int m = median(x);
>         for (int i = 0; i < x.length; ++i) {
>             x[i] = Math.abs(x[i] - m);
>         }
>         return median(x);
>     }
>     
>     public static double mad(final float[] x) {
>         final float m = median(x);
>         for (int i = 0; i < x.length; ++i) {
>             x[i] = Math.abs(x[i] - m);
>         }
>         return median(x);
>     }
>     
>     public static double mad(final double[] x) {
>         final double m = median(x);
>         for (int i = 0; i < x.length; ++i) {
>             x[i] = Math.abs(x[i] - m);
>         }
>         return median(x);
>     }
>     
>     public static double distance(final int[] x, final int[] y) {
>         return Math.sqrt(squaredDistance(x, y));
>     }
>     
>     public static double distance(final float[] x, final float[] y) {
>         return Math.sqrt(squaredDistance(x, y));
>     }
>     
>     public static double distance(final double[] x, final double[] y) {
>         return Math.sqrt(squaredDistance(x, y));
>     }
>     
>     public static double distance(final SparseArrayModified x, final SparseArrayModified y) {
>         return Math.sqrt(squaredDistance(x, y));
>     }
>     
>     public static double squaredDistance(final int[] x, final int[] y) {
>         double d = 0.0;
>         int p1 = 0;
>         int p2 = 0;
>         while (p1 < x.length && p2 < y.length) {
>             final int i1 = x[p1];
>             final int i2 = y[p2];
>             if (i1 == i2) {
>                 ++p1;
>                 ++p2;
>             }
>             else if (i1 > i2) {
>                 ++d;
>                 ++p2;
>             }
>             else {
>                 ++d;
>                 ++p1;
>             }
>         }
>         d += x.length - p1;
>         d += y.length - p2;
>         return d;
>     }
>     
>     public static double squaredDistance(final float[] x, final float[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Input vector sizes are different.");
>         }
>         switch (x.length) {
>             case 2: {
>                 final double d0 = x[0] - (double)y[0];
>                 final double d2 = x[1] - (double)y[1];
>                 return d0 * d0 + d2 * d2;
>             }
>             case 3: {
>                 final double d0 = x[0] - (double)y[0];
>                 final double d2 = x[1] - (double)y[1];
>                 final double d3 = x[2] - (double)y[2];
>                 return d0 * d0 + d2 * d2 + d3 * d3;
>             }
>             case 4: {
>                 final double d0 = x[0] - (double)y[0];
>                 final double d2 = x[1] - (double)y[1];
>                 final double d3 = x[2] - (double)y[2];
>                 final double d4 = x[3] - (double)y[3];
>                 return d0 * d0 + d2 * d2 + d3 * d3 + d4 * d4;
>             }
>             default: {
>                 double sum = 0.0;
>                 for (int i = 0; i < x.length; ++i) {
>                     final double d5 = x[i] - (double)y[i];
>                     sum += d5 * d5;
>                 }
>                 return sum;
>             }
>         }
>     }
>     
>     public static double squaredDistance(final double[] x, final double[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Input vector sizes are different.");
>         }
>         switch (x.length) {
>             case 2: {
>                 final double d0 = x[0] - y[0];
>                 final double d2 = x[1] - y[1];
>                 return d0 * d0 + d2 * d2;
>             }
>             case 3: {
>                 final double d0 = x[0] - y[0];
>                 final double d2 = x[1] - y[1];
>                 final double d3 = x[2] - y[2];
>                 return d0 * d0 + d2 * d2 + d3 * d3;
>             }
>             case 4: {
>                 final double d0 = x[0] - y[0];
>                 final double d2 = x[1] - y[1];
>                 final double d3 = x[2] - y[2];
>                 final double d4 = x[3] - y[3];
>                 return d0 * d0 + d2 * d2 + d3 * d3 + d4 * d4;
>             }
>             default: {
>                 double sum = 0.0;
>                 for (int i = 0; i < x.length; ++i) {
>                     final double d5 = x[i] - y[i];
>                     sum += d5 * d5;
>                 }
>                 return sum;
>             }
>         }
>     }
>     
>     public static double squaredDistance(final SparseArrayModified x, final SparseArrayModified y) {
>         final Iterator<SparseArrayModified.Entry> it1 = x.iterator();
>         final Iterator<SparseArrayModified.Entry> it2 = y.iterator();
>         SparseArrayModified.Entry e1 = it1.hasNext() ? it1.next() : null;
>         SparseArrayModified.Entry e2 = it2.hasNext() ? it2.next() : null;
>         double sum = 0.0;
>         while (e1 != null) {
>             if (e2 == null) {
>                 break;
>             }
>             if (e1.i == e2.i) {
>                 sum += pow2(e1.x - e2.x);
>                 e1 = (it1.hasNext() ? it1.next() : null);
>                 e2 = (it2.hasNext() ? it2.next() : null);
>             }
>             else if (e1.i > e2.i) {
>                 sum += pow2(e2.x);
>                 e2 = (it2.hasNext() ? it2.next() : null);
>             }
>             else {
>                 sum += pow2(e1.x);
>                 e1 = (it1.hasNext() ? it1.next() : null);
>             }
>         }
>         while (it1.hasNext()) {
>             final double d = it1.next().x;
>             sum += d * d;
>         }
>         while (it2.hasNext()) {
>             final double d = it2.next().x;
>             sum += d * d;
>         }
>         return sum;
>     }
>     
>     public static double squaredDistanceWithMissingValues(final double[] x, final double[] y) {
>         final int n = x.length;
>         int m = 0;
>         double dist = 0.0;
>         for (int i = 0; i < n; ++i) {
>             if (!Double.isNaN(x[i]) && !Double.isNaN(y[i])) {
>                 ++m;
>                 final double d = x[i] - y[i];
>                 dist += d * d;
>             }
>         }
>         if (m == 0) {
>             dist = Double.MAX_VALUE;
>         }
>         else {
>             dist = n * dist / m;
>         }
>         return dist;
>     }
>     
>     public static MatrixModified pdist(final int[][] x) {
>         return pdist(x, false);
>     }
>     
>     public static MatrixModified pdist(final int[][] x, final boolean squared) {
>         final int n = x.length;
>         final double[][] dist = new double[n][n];
>         MathExModified.<int[]>pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
>         return MatrixModified.of(dist);
>     }
>     
>     public static MatrixModified pdist(final float[][] x) {
>         return pdist(x, false);
>     }
>     
>     public static MatrixModified pdist(final float[][] x, final boolean squared) {
>         final int n = x.length;
>         final double[][] dist = new double[n][n];
>         MathExModified.<float[]>pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
>         return MatrixModified.of(dist);
>     }
>     
>     public static MatrixModified pdist(final double[][] x) {
>         return pdist(x, false);
>     }
>     
>     public static MatrixModified pdist(final double[][] x, final boolean squared) {
>         final int n = x.length;
>         final double[][] dist = new double[n][n];
>         MathExModified.<double[]>pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
>         return MatrixModified.of(dist);
>     }
>     
>     public static MatrixModified pdist(final SparseArrayModified[] x) {
>         return pdist(x, false);
>     }
>     
>     public static MatrixModified pdist(final SparseArrayModified[] x, final boolean squared) {
>         final int n = x.length;
>         final double[][] dist = new double[n][n];
>         MathExModified.<SparseArrayModified>pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
>         return MatrixModified.of(dist);
>     }
>     
>     public static <T> void pdist(final T[] x, final double[][] d, final DistanceModified<T> distance) {
>         final int n = x.length;
>         if (d[0].length < n) {
>             final Object xi;
>             final double[] di;
>             int j;
>             IntStream.range(0, n).parallel().forEach(i -> {
>                 xi = x[i];
>                 di = d[i];
>                 for (j = 0; j < i; ++j) {
>                     di[j] = distance.d((T)xi, x[j]);
>                 }
>             });
>         }
>         else {
>             final Object xi2;
>             final double[] di2;
>             int k;
>             final int n2;
>             IntStream.range(0, n).parallel().forEach(i -> {
>                 xi2 = x[i];
>                 di2 = d[i];
>                 for (k = 0; k < n2; ++k) {
>                     di2[k] = distance.d((T)xi2, x[k]);
>                 }
>             });
>         }
>     }
>     
>     public static double entropy(final double[] p) {
>         double h = 0.0;
>         for (final double pi : p) {
>             if (pi > 0.0) {
>                 h -= pi * Math.log(pi);
>             }
>         }
>         return h;
>     }
>     
>     public static double KullbackLeiblerDivergence(final double[] p, final double[] q) {
>         boolean intersection = false;
>         double kl = 0.0;
>         for (int i = 0; i < p.length; ++i) {
>             if (p[i] != 0.0 && q[i] != 0.0) {
>                 intersection = true;
>                 kl += p[i] * Math.log(p[i] / q[i]);
1796,1911c1628,1650
< 
<             return sum;
<          }
<       }
<    }
< 
<    public static double squaredDistance(SparseArrayModified x, SparseArrayModified y) {
<       Iterator<SparseArrayModified.Entry> it1 = x.iterator();
<       Iterator<SparseArrayModified.Entry> it2 = y.iterator();
<       SparseArrayModified.Entry e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<       SparseArrayModified.Entry e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<       double sum = 0.0D;
< 
<       while(e1 != null && e2 != null) {
<          if (e1.i == e2.i) {
<             sum += pow2(e1.x - e2.x);
<             e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<             e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<          } else if (e1.i > e2.i) {
<             sum += pow2(e2.x);
<             e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<          } else {
<             sum += pow2(e1.x);
<             e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<          }
<       }
< 
<       double d;
<       while(it1.hasNext()) {
<          d = ((SparseArrayModified.Entry)it1.next()).x;
<          sum += d * d;
<       }
< 
<       while(it2.hasNext()) {
<          d = ((SparseArrayModified.Entry)it2.next()).x;
<          sum += d * d;
<       }
< 
<       return sum;
<    }
< 
<    public static double squaredDistanceWithMissingValues(double[] x, double[] y) {
<       int n = x.length;
<       int m = 0;
<       double dist = 0.0D;
< 
<       for(int i = 0; i < n; ++i) {
<          if (!Double.isNaN(x[i]) && !Double.isNaN(y[i])) {
<             ++m;
<             double d = x[i] - y[i];
<             dist += d * d;
<          }
<       }
< 
<       if (m == 0) {
<          dist = Double.MAX_VALUE;
<       } else {
<          dist = (double)n * dist / (double)m;
<       }
< 
<       return dist;
<    }
< 
<    public static MatrixModified pdist(int[][] x) {
<       return pdist(x, false);
<    }
< 
<    public static MatrixModified pdist(int[][] x, boolean squared) {
<       int n = x.length;
<       double[][] dist = new double[n][n];
<       pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
<       return MatrixModified.of(dist);
<    }
< 
<    public static MatrixModified pdist(float[][] x) {
<       return pdist(x, false);
<    }
< 
<    public static MatrixModified pdist(float[][] x, boolean squared) {
<       int n = x.length;
<       double[][] dist = new double[n][n];
<       pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
<       return MatrixModified.of(dist);
<    }
< 
<    public static MatrixModified pdist(double[][] x) {
<       return pdist(x, false);
<    }
< 
<    public static MatrixModified pdist(double[][] x, boolean squared) {
<       int n = x.length;
<       double[][] dist = new double[n][n];
<       pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
<       return MatrixModified.of(dist);
<    }
< 
<    public static MatrixModified pdist(SparseArrayModified[] x) {
<       return pdist(x, false);
<    }
< 
<    public static MatrixModified pdist(SparseArrayModified[] x, boolean squared) {
<       int n = x.length;
<       double[][] dist = new double[n][n];
<       pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
<       return MatrixModified.of(dist);
<    }
< 
<    public static <T> void pdist(T[] x, double[][] d, DistanceModified<T> distance) {
<       int n = x.length;
<       if (d[0].length < n) {
<          IntStream.range(0, n).parallel().forEach((i) -> {
<             T xi = x[i];
<             double[] di = d[i];
< 
<             for(int j = 0; j < i; ++j) {
<                di[j] = distance.d(xi, x[j]);
---
>         }
>         if (intersection) {
>             return kl;
>         }
>         return Double.POSITIVE_INFINITY;
>     }
>     
>     public static double KullbackLeiblerDivergence(final SparseArrayModified p, final SparseArrayModified q) {
>         if (p.isEmpty()) {
>             throw new IllegalArgumentException("p is empty.");
>         }
>         if (q.isEmpty()) {
>             throw new IllegalArgumentException("q is empty.");
>         }
>         final Iterator<SparseArrayModified.Entry> pIter = p.iterator();
>         final Iterator<SparseArrayModified.Entry> qIter = q.iterator();
>         SparseArrayModified.Entry a = pIter.hasNext() ? pIter.next() : null;
>         SparseArrayModified.Entry b = qIter.hasNext() ? qIter.next() : null;
>         boolean intersection = false;
>         double kl = 0.0;
>         while (a != null && b != null) {
>             if (a.i < b.i) {
>                 a = (pIter.hasNext() ? pIter.next() : null);
1913,1921c1652,1653
< 
<          });
<       } else {
<          IntStream.range(0, n).parallel().forEach((i) -> {
<             T xi = x[i];
<             double[] di = d[i];
< 
<             for(int j = 0; j < n; ++j) {
<                di[j] = distance.d(xi, x[j]);
---
>             else if (a.i > b.i) {
>                 b = (qIter.hasNext() ? qIter.next() : null);
1923,1984c1655,1659
< 
<          });
<       }
< 
<    }
< 
<    public static double entropy(double[] p) {
<       double h = 0.0D;
<       double[] var7 = p;
<       int var6 = p.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double pi = var7[var5];
<          if (pi > 0.0D) {
<             h -= pi * Math.log(pi);
<          }
<       }
< 
<       return h;
<    }
< 
<    public static double KullbackLeiblerDivergence(double[] p, double[] q) {
<       boolean intersection = false;
<       double kl = 0.0D;
< 
<       for(int i = 0; i < p.length; ++i) {
<          if (p[i] != 0.0D && q[i] != 0.0D) {
<             intersection = true;
<             kl += p[i] * Math.log(p[i] / q[i]);
<          }
<       }
< 
<       if (intersection) {
<          return kl;
<       } else {
<          return Double.POSITIVE_INFINITY;
<       }
<    }
< 
<    public static double KullbackLeiblerDivergence(SparseArrayModified p, SparseArrayModified q) {
<       if (p.isEmpty()) {
<          throw new IllegalArgumentException("p is empty.");
<       } else if (q.isEmpty()) {
<          throw new IllegalArgumentException("q is empty.");
<       } else {
<          Iterator<SparseArrayModified.Entry> pIter = p.iterator();
<          Iterator<SparseArrayModified.Entry> qIter = q.iterator();
<          SparseArrayModified.Entry a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<          SparseArrayModified.Entry b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
<          boolean intersection = false;
<          double kl = 0.0D;
< 
<          while(a != null && b != null) {
<             if (a.i < b.i) {
<                a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<             } else if (a.i > b.i) {
<                b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
<             } else {
<                intersection = true;
<                kl += a.x * Math.log(a.x / b.x);
<                a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<                b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
---
>             else {
>                 intersection = true;
>                 kl += a.x * Math.log(a.x / b.x);
>                 a = (pIter.hasNext() ? pIter.next() : null);
>                 b = (qIter.hasNext() ? qIter.next() : null);
1986,2009c1661,1684
<          }
< 
<          return intersection ? kl : Double.POSITIVE_INFINITY;
<       }
<    }
< 
<    public static double KullbackLeiblerDivergence(double[] p, SparseArrayModified q) {
<       return KullbackLeiblerDivergence(q, p);
<    }
< 
<    public static double KullbackLeiblerDivergence(SparseArrayModified p, double[] q) {
<       if (p.isEmpty()) {
<          throw new IllegalArgumentException("p is empty.");
<       } else {
<          Iterator<SparseArrayModified.Entry> iter = p.iterator();
<          boolean intersection = false;
<          double kl = 0.0D;
< 
<          while(iter.hasNext()) {
<             SparseArrayModified.Entry b = (SparseArrayModified.Entry)iter.next();
<             int i = b.i;
<             if (q[i] > 0.0D) {
<                intersection = true;
<                kl += b.x * Math.log(b.x / q[i]);
---
>         }
>         if (intersection) {
>             return kl;
>         }
>         return Double.POSITIVE_INFINITY;
>     }
>     
>     public static double KullbackLeiblerDivergence(final double[] p, final SparseArrayModified q) {
>         return KullbackLeiblerDivergence(q, p);
>     }
>     
>     public static double KullbackLeiblerDivergence(final SparseArrayModified p, final double[] q) {
>         if (p.isEmpty()) {
>             throw new IllegalArgumentException("p is empty.");
>         }
>         final Iterator<SparseArrayModified.Entry> iter = p.iterator();
>         boolean intersection = false;
>         double kl = 0.0;
>         while (iter.hasNext()) {
>             final SparseArrayModified.Entry b = iter.next();
>             final int i = b.i;
>             if (q[i] > 0.0) {
>                 intersection = true;
>                 kl += b.x * Math.log(b.x / q[i]);
2011,2013c1686,1687
<          }
< 
<          if (intersection) {
---
>         }
>         if (intersection) {
2015,2044c1689,1713
<          } else {
<             return Double.POSITIVE_INFINITY;
<          }
<       }
<    }
< 
<    public static double JensenShannonDivergence(double[] p, double[] q) {
<       double[] m = new double[p.length];
< 
<       for(int i = 0; i < m.length; ++i) {
<          m[i] = (p[i] + q[i]) / 2.0D;
<       }
< 
<       return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2.0D;
<    }
< 
<    public static double JensenShannonDivergence(SparseArrayModified p, SparseArrayModified q) {
<       if (p.isEmpty()) {
<          throw new IllegalArgumentException("p is empty.");
<       } else if (q.isEmpty()) {
<          throw new IllegalArgumentException("q is empty.");
<       } else {
<          Iterator<SparseArrayModified.Entry> pIter = p.iterator();
<          Iterator<SparseArrayModified.Entry> qIter = q.iterator();
<          SparseArrayModified.Entry a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<          SparseArrayModified.Entry b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
<          double js = 0.0D;
< 
<          while(a != null && b != null) {
<             double mi;
---
>         }
>         return Double.POSITIVE_INFINITY;
>     }
>     
>     public static double JensenShannonDivergence(final double[] p, final double[] q) {
>         final double[] m = new double[p.length];
>         for (int i = 0; i < m.length; ++i) {
>             m[i] = (p[i] + q[i]) / 2.0;
>         }
>         return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2.0;
>     }
>     
>     public static double JensenShannonDivergence(final SparseArrayModified p, final SparseArrayModified q) {
>         if (p.isEmpty()) {
>             throw new IllegalArgumentException("p is empty.");
>         }
>         if (q.isEmpty()) {
>             throw new IllegalArgumentException("q is empty.");
>         }
>         final Iterator<SparseArrayModified.Entry> pIter = p.iterator();
>         final Iterator<SparseArrayModified.Entry> qIter = q.iterator();
>         SparseArrayModified.Entry a = pIter.hasNext() ? pIter.next() : null;
>         SparseArrayModified.Entry b = qIter.hasNext() ? qIter.next() : null;
>         double js = 0.0;
>         while (a != null && b != null) {
2046,2079c1715,1747
<                mi = a.x / 2.0D;
<                js += a.x * Math.log(a.x / mi);
<                a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<             } else if (a.i > b.i) {
<                mi = b.x / 2.0D;
<                js += b.x * Math.log(b.x / mi);
<                b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
<             } else {
<                mi = (a.x + b.x) / 2.0D;
<                js += a.x * Math.log(a.x / mi) + b.x * Math.log(b.x / mi);
<                a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<                b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
<             }
<          }
< 
<          return js / 2.0D;
<       }
<    }
< 
<    public static double JensenShannonDivergence(double[] p, SparseArrayModified q) {
<       return JensenShannonDivergence(q, p);
<    }
< 
<    public static double JensenShannonDivergence(SparseArrayModified p, double[] q) {
<       if (p.isEmpty()) {
<          throw new IllegalArgumentException("p is empty.");
<       } else {
<          Iterator<SparseArrayModified.Entry> iter = p.iterator();
<          double js = 0.0D;
< 
<          while(iter.hasNext()) {
<             SparseArrayModified.Entry b = (SparseArrayModified.Entry)iter.next();
<             int i = b.i;
<             double mi = (b.x + q[i]) / 2.0D;
---
>                 final double mi = a.x / 2.0;
>                 js += a.x * Math.log(a.x / mi);
>                 a = (pIter.hasNext() ? pIter.next() : null);
>             }
>             else if (a.i > b.i) {
>                 final double mi = b.x / 2.0;
>                 js += b.x * Math.log(b.x / mi);
>                 b = (qIter.hasNext() ? qIter.next() : null);
>             }
>             else {
>                 final double mi = (a.x + b.x) / 2.0;
>                 js += a.x * Math.log(a.x / mi) + b.x * Math.log(b.x / mi);
>                 a = (pIter.hasNext() ? pIter.next() : null);
>                 b = (qIter.hasNext() ? qIter.next() : null);
>             }
>         }
>         return js / 2.0;
>     }
>     
>     public static double JensenShannonDivergence(final double[] p, final SparseArrayModified q) {
>         return JensenShannonDivergence(q, p);
>     }
>     
>     public static double JensenShannonDivergence(final SparseArrayModified p, final double[] q) {
>         if (p.isEmpty()) {
>             throw new IllegalArgumentException("p is empty.");
>         }
>         final Iterator<SparseArrayModified.Entry> iter = p.iterator();
>         double js = 0.0;
>         while (iter.hasNext()) {
>             final SparseArrayModified.Entry b = iter.next();
>             final int i = b.i;
>             final double mi = (b.x + q[i]) / 2.0;
2081,2082c1749,1750
<             if (q[i] > 0.0D) {
<                js += q[i] * Math.log(q[i] / mi);
---
>             if (q[i] > 0.0) {
>                 js += q[i] * Math.log(q[i] / mi);
2084,2118c1752,1783
<          }
< 
<          return js / 2.0D;
<       }
<    }
< 
<    public static int dot(int[] x, int[] y) {
<       int sum = 0;
<       int p1 = 0;
<       int p2 = 0;
< 
<       while(p1 < x.length && p2 < y.length) {
<          int i1 = x[p1];
<          int i2 = y[p2];
<          if (i1 == i2) {
<             ++sum;
<             ++p1;
<             ++p2;
<          } else if (i1 > i2) {
<             ++p2;
<          } else {
<             ++p1;
<          }
<       }
< 
<       return sum;
<    }
< 
<    public static float dot(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else {
<          float sum = 0.0F;
< 
<          for(int i = 0; i < x.length; ++i) {
---
>         }
>         return js / 2.0;
>     }
>     
>     public static int dot(final int[] x, final int[] y) {
>         int sum = 0;
>         int p1 = 0;
>         int p2 = 0;
>         while (p1 < x.length && p2 < y.length) {
>             final int i1 = x[p1];
>             final int i2 = y[p2];
>             if (i1 == i2) {
>                 ++sum;
>                 ++p1;
>                 ++p2;
>             }
>             else if (i1 > i2) {
>                 ++p2;
>             }
>             else {
>                 ++p1;
>             }
>         }
>         return sum;
>     }
>     
>     public static float dot(final float[] x, final float[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Arrays have different length.");
>         }
>         float sum = 0.0f;
>         for (int i = 0; i < x.length; ++i) {
2120,2132c1785,1794
<          }
< 
<          return sum;
<       }
<    }
< 
<    public static double dot(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else {
<          double sum = 0.0D;
< 
<          for(int i = 0; i < x.length; ++i) {
---
>         }
>         return sum;
>     }
>     
>     public static double dot(final double[] x, final double[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Arrays have different length.");
>         }
>         double sum = 0.0;
>         for (int i = 0; i < x.length; ++i) {
2134,2234c1796,1906
<          }
< 
<          return sum;
<       }
<    }
< 
<    public static double dot(SparseArrayModified x, SparseArrayModified y) {
<       Iterator<SparseArrayModified.Entry> it1 = x.iterator();
<       Iterator<SparseArrayModified.Entry> it2 = y.iterator();
<       SparseArrayModified.Entry e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<       SparseArrayModified.Entry e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<       double sum = 0.0D;
< 
<       while(e1 != null && e2 != null) {
<          if (e1.i == e2.i) {
<             sum += e1.x * e2.x;
<             e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<             e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<          } else if (e1.i > e2.i) {
<             e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<          } else {
<             e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<          }
<       }
< 
<       return sum;
<    }
< 
<    public static MatrixModified pdot(int[][] x) {
<       int n = x.length;
<       MatrixModified matrix = new MatrixModified(n, n);
<       matrix.uplo(UPLOModified.LOWER);
<       IntStream.range(0, n).parallel().forEach((j) -> {
<          int[] xj = x[j];
< 
<          for(int i = 0; i < n; ++i) {
<             matrix.set(i, j, (double)dot(x[i], xj));
<          }
< 
<       });
<       return matrix;
<    }
< 
<    public static MatrixModified pdot(float[][] x) {
<       int n = x.length;
<       MatrixModified matrix = new MatrixModified(n, n);
<       matrix.uplo(UPLOModified.LOWER);
<       IntStream.range(0, n).parallel().forEach((j) -> {
<          float[] xj = x[j];
< 
<          for(int i = 0; i < n; ++i) {
<             matrix.set(i, j, (double)dot(x[i], xj));
<          }
< 
<       });
<       return matrix;
<    }
< 
<    public static MatrixModified pdot(double[][] x) {
<       int n = x.length;
<       MatrixModified matrix = new MatrixModified(n, n);
<       matrix.uplo(UPLOModified.LOWER);
<       IntStream.range(0, n).parallel().forEach((j) -> {
<          double[] xj = x[j];
< 
<          for(int i = 0; i < n; ++i) {
<             matrix.set(i, j, dot(x[i], xj));
<          }
< 
<       });
<       return matrix;
<    }
< 
<    public static MatrixModified pdot(SparseArrayModified[] x) {
<       int n = x.length;
<       MatrixModified matrix = new MatrixModified(n, n);
<       matrix.uplo(UPLOModified.LOWER);
<       IntStream.range(0, n).parallel().forEach((j) -> {
<          SparseArrayModified xj = x[j];
< 
<          for(int i = 0; i < n; ++i) {
<             matrix.set(i, j, dot(x[i], xj));
<          }
< 
<       });
<       return matrix;
<    }
< 
<    public static double cov(int[] x, int[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double mx = mean(x);
<          double my = mean(y);
<          double Sxy = 0.0D;
< 
<          for(int i = 0; i < x.length; ++i) {
<             double dx = (double)x[i] - mx;
<             double dy = (double)y[i] - my;
---
>         }
>         return sum;
>     }
>     
>     public static double dot(final SparseArrayModified x, final SparseArrayModified y) {
>         final Iterator<SparseArrayModified.Entry> it1 = x.iterator();
>         final Iterator<SparseArrayModified.Entry> it2 = y.iterator();
>         SparseArrayModified.Entry e1 = it1.hasNext() ? it1.next() : null;
>         SparseArrayModified.Entry e2 = it2.hasNext() ? it2.next() : null;
>         double sum = 0.0;
>         while (e1 != null && e2 != null) {
>             if (e1.i == e2.i) {
>                 sum += e1.x * e2.x;
>                 e1 = (it1.hasNext() ? it1.next() : null);
>                 e2 = (it2.hasNext() ? it2.next() : null);
>             }
>             else if (e1.i > e2.i) {
>                 e2 = (it2.hasNext() ? it2.next() : null);
>             }
>             else {
>                 e1 = (it1.hasNext() ? it1.next() : null);
>             }
>         }
>         return sum;
>     }
>     
>     public static MatrixModified pdot(final int[][] x) {
>         final int n = x.length;
>         final MatrixModified matrix = new MatrixModified(n, n);
>         matrix.uplo(UPLOModified.LOWER);
>         final int[] xj;
>         int i;
>         final int n2;
>         final MatrixModified matrixModified;
>         IntStream.range(0, n).parallel().forEach(j -> {
>             xj = x[j];
>             for (i = 0; i < n2; ++i) {
>                 matrixModified.set(i, j, dot(x[i], xj));
>             }
>             return;
>         });
>         return matrix;
>     }
>     
>     public static MatrixModified pdot(final float[][] x) {
>         final int n = x.length;
>         final MatrixModified matrix = new MatrixModified(n, n);
>         matrix.uplo(UPLOModified.LOWER);
>         final float[] xj;
>         int i;
>         final int n2;
>         final MatrixModified matrixModified;
>         IntStream.range(0, n).parallel().forEach(j -> {
>             xj = x[j];
>             for (i = 0; i < n2; ++i) {
>                 matrixModified.set(i, j, dot(x[i], xj));
>             }
>             return;
>         });
>         return matrix;
>     }
>     
>     public static MatrixModified pdot(final double[][] x) {
>         final int n = x.length;
>         final MatrixModified matrix = new MatrixModified(n, n);
>         matrix.uplo(UPLOModified.LOWER);
>         final double[] xj;
>         int i;
>         final int n2;
>         final MatrixModified matrixModified;
>         IntStream.range(0, n).parallel().forEach(j -> {
>             xj = x[j];
>             for (i = 0; i < n2; ++i) {
>                 matrixModified.set(i, j, dot(x[i], xj));
>             }
>             return;
>         });
>         return matrix;
>     }
>     
>     public static MatrixModified pdot(final SparseArrayModified[] x) {
>         final int n = x.length;
>         final MatrixModified matrix = new MatrixModified(n, n);
>         matrix.uplo(UPLOModified.LOWER);
>         final SparseArrayModified xj;
>         int i;
>         final int n2;
>         final MatrixModified matrixModified;
>         IntStream.range(0, n).parallel().forEach(j -> {
>             xj = x[j];
>             for (i = 0; i < n2; ++i) {
>                 matrixModified.set(i, j, dot(x[i], xj));
>             }
>             return;
>         });
>         return matrix;
>     }
>     
>     public static double cov(final int[] x, final int[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Arrays have different length.");
>         }
>         if (x.length < 3) {
>             throw new IllegalArgumentException("array length has to be at least 3.");
>         }
>         final double mx = mean(x);
>         final double my = mean(y);
>         double Sxy = 0.0;
>         for (int i = 0; i < x.length; ++i) {
>             final double dx = x[i] - mx;
>             final double dy = y[i] - my;
2236,2254c1908,1924
<          }
< 
<          return Sxy / (double)(x.length - 1);
<       }
<    }
< 
<    public static double cov(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double mx = mean(x);
<          double my = mean(y);
<          double Sxy = 0.0D;
< 
<          for(int i = 0; i < x.length; ++i) {
<             double dx = (double)x[i] - mx;
<             double dy = (double)y[i] - my;
---
>         }
>         return Sxy / (x.length - 1);
>     }
>     
>     public static double cov(final float[] x, final float[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Arrays have different length.");
>         }
>         if (x.length < 3) {
>             throw new IllegalArgumentException("array length has to be at least 3.");
>         }
>         final double mx = mean(x);
>         final double my = mean(y);
>         double Sxy = 0.0;
>         for (int i = 0; i < x.length; ++i) {
>             final double dx = x[i] - mx;
>             final double dy = y[i] - my;
2256,2274c1926,1942
<          }
< 
<          return Sxy / (double)(x.length - 1);
<       }
<    }
< 
<    public static double cov(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double mx = mean(x);
<          double my = mean(y);
<          double Sxy = 0.0D;
< 
<          for(int i = 0; i < x.length; ++i) {
<             double dx = x[i] - mx;
<             double dy = y[i] - my;
---
>         }
>         return Sxy / (x.length - 1);
>     }
>     
>     public static double cov(final double[] x, final double[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Arrays have different length.");
>         }
>         if (x.length < 3) {
>             throw new IllegalArgumentException("array length has to be at least 3.");
>         }
>         final double mx = mean(x);
>         final double my = mean(y);
>         double Sxy = 0.0;
>         for (int i = 0; i < x.length; ++i) {
>             final double dx = x[i] - mx;
>             final double dy = y[i] - my;
2276,2383c1944,2049
<          }
< 
<          return Sxy / (double)(x.length - 1);
<       }
<    }
< 
<    public static double[][] cov(double[][] data) {
<       return cov(data, colMeans(data));
<    }
< 
<    public static double[][] cov(double[][] data, double[] mu) {
<       double[][] sigma = new double[data[0].length][data[0].length];
<       double[][] var6 = data;
<       int k = data.length;
< 
<       int j;
<       for(j = 0; j < k; ++j) {
<          double[] datum = var6[j];
< 
<          for(int j = 0; j < mu.length; ++j) {
<             for(int k = 0; k <= j; ++k) {
<                sigma[j][k] += (datum[j] - mu[j]) * (datum[k] - mu[k]);
<             }
<          }
<       }
< 
<       int n = data.length - 1;
< 
<       for(j = 0; j < mu.length; ++j) {
<          for(k = 0; k <= j; ++k) {
<             sigma[j][k] /= (double)n;
<             sigma[k][j] = sigma[j][k];
<          }
<       }
< 
<       return sigma;
<    }
< 
<    public static double cor(int[] x, int[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double Sxy = cov(x, y);
<          double Sxx = var(x);
<          double Syy = var(y);
<          return Sxx != 0.0D && Syy != 0.0D ? Sxy / Math.sqrt(Sxx * Syy) : Double.NaN;
<       }
<    }
< 
<    public static double cor(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double Sxy = cov(x, y);
<          double Sxx = var(x);
<          double Syy = var(y);
<          return Sxx != 0.0D && Syy != 0.0D ? Sxy / Math.sqrt(Sxx * Syy) : Double.NaN;
<       }
<    }
< 
<    public static double cor(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double Sxy = cov(x, y);
<          double Sxx = var(x);
<          double Syy = var(y);
<          return Sxx != 0.0D && Syy != 0.0D ? Sxy / Math.sqrt(Sxx * Syy) : Double.NaN;
<       }
<    }
< 
<    public static double[][] cor(double[][] data) {
<       return cor(data, colMeans(data));
<    }
< 
<    public static double[][] cor(double[][] data, double[] mu) {
<       double[][] sigma = cov(data, mu);
<       int n = data[0].length;
<       double[] sd = new double[n];
< 
<       int i;
<       for(i = 0; i < n; ++i) {
<          sd[i] = Math.sqrt(sigma[i][i]);
<       }
< 
<       for(i = 0; i < n; ++i) {
<          for(int j = 0; j <= i; ++j) {
<             sigma[i][j] /= sd[i] * sd[j];
<             sigma[j][i] = sigma[i][j];
<          }
<       }
< 
<       return sigma;
<    }
< 
<    private static double crank(double[] w) {
<       int n = w.length;
<       double s = 0.0D;
<       int j = 1;
< 
<       while(true) {
<          while(j < n) {
---
>         }
>         return Sxy / (x.length - 1);
>     }
>     
>     public static double[][] cov(final double[][] data) {
>         return cov(data, colMeans(data));
>     }
>     
>     public static double[][] cov(final double[][] data, final double[] mu) {
>         final double[][] sigma = new double[data[0].length][data[0].length];
>         for (final double[] datum : data) {
>             for (int j = 0; j < mu.length; ++j) {
>                 for (int k = 0; k <= j; ++k) {
>                     final double[] array = sigma[j];
>                     final int n3 = k;
>                     array[n3] += (datum[j] - mu[j]) * (datum[k] - mu[k]);
>                 }
>             }
>         }
>         final int n = data.length - 1;
>         for (int i = 0; i < mu.length; ++i) {
>             for (int l = 0; l <= i; ++l) {
>                 final double[] array2 = sigma[i];
>                 final int n4 = l;
>                 array2[n4] /= n;
>                 sigma[l][i] = sigma[i][l];
>             }
>         }
>         return sigma;
>     }
>     
>     public static double cor(final int[] x, final int[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Arrays have different length.");
>         }
>         if (x.length < 3) {
>             throw new IllegalArgumentException("array length has to be at least 3.");
>         }
>         final double Sxy = cov(x, y);
>         final double Sxx = var(x);
>         final double Syy = var(y);
>         if (Sxx == 0.0 || Syy == 0.0) {
>             return Double.NaN;
>         }
>         return Sxy / Math.sqrt(Sxx * Syy);
>     }
>     
>     public static double cor(final float[] x, final float[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Arrays have different length.");
>         }
>         if (x.length < 3) {
>             throw new IllegalArgumentException("array length has to be at least 3.");
>         }
>         final double Sxy = cov(x, y);
>         final double Sxx = var(x);
>         final double Syy = var(y);
>         if (Sxx == 0.0 || Syy == 0.0) {
>             return Double.NaN;
>         }
>         return Sxy / Math.sqrt(Sxx * Syy);
>     }
>     
>     public static double cor(final double[] x, final double[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Arrays have different length.");
>         }
>         if (x.length < 3) {
>             throw new IllegalArgumentException("array length has to be at least 3.");
>         }
>         final double Sxy = cov(x, y);
>         final double Sxx = var(x);
>         final double Syy = var(y);
>         if (Sxx == 0.0 || Syy == 0.0) {
>             return Double.NaN;
>         }
>         return Sxy / Math.sqrt(Sxx * Syy);
>     }
>     
>     public static double[][] cor(final double[][] data) {
>         return cor(data, colMeans(data));
>     }
>     
>     public static double[][] cor(final double[][] data, final double[] mu) {
>         final double[][] sigma = cov(data, mu);
>         final int n = data[0].length;
>         final double[] sd = new double[n];
>         for (int i = 0; i < n; ++i) {
>             sd[i] = Math.sqrt(sigma[i][i]);
>         }
>         for (int i = 0; i < n; ++i) {
>             for (int j = 0; j <= i; ++j) {
>                 final double[] array = sigma[i];
>                 final int n2 = j;
>                 array[n2] /= sd[i] * sd[j];
>                 sigma[j][i] = sigma[i][j];
>             }
>         }
>         return sigma;
>     }
>     
>     private static double crank(final double[] w) {
>         final int n = w.length;
>         double s = 0.0;
>         int j = 1;
>         while (j < n) {
2385,2400c2051,2052
<                w[j - 1] = (double)j;
<                ++j;
<             } else {
<                int jt;
<                for(jt = j + 1; jt <= n && w[jt - 1] == w[j - 1]; ++jt) {
<                }
< 
<                double rank = 0.5D * (double)(j + jt - 1);
< 
<                for(int ji = j; ji <= jt - 1; ++ji) {
<                   w[ji - 1] = rank;
<                }
< 
<                double t = (double)(jt - j);
<                s += t * t * t - t;
<                j = jt;
---
>                 w[j - 1] = j;
>                 ++j;
2402,2680c2054,2301
<          }
< 
<          if (j == n) {
<             w[n - 1] = (double)n;
<          }
< 
<          return s;
<       }
<    }
< 
<    public static double spearman(int[] x, int[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          int n = x.length;
<          double[] wksp1 = new double[n];
<          double[] wksp2 = new double[n];
< 
<          for(int j = 0; j < n; ++j) {
<             wksp1[j] = (double)x[j];
<             wksp2[j] = (double)y[j];
<          }
< 
<          QuickSortModified.sort(wksp1, wksp2);
<          crank(wksp1);
<          QuickSortModified.sort(wksp2, wksp1);
<          crank(wksp2);
<          return cor(wksp1, wksp2);
<       }
<    }
< 
<    public static double spearman(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          int n = x.length;
<          double[] wksp1 = new double[n];
<          double[] wksp2 = new double[n];
< 
<          for(int j = 0; j < n; ++j) {
<             wksp1[j] = (double)x[j];
<             wksp2[j] = (double)y[j];
<          }
< 
<          QuickSortModified.sort(wksp1, wksp2);
<          crank(wksp1);
<          QuickSortModified.sort(wksp2, wksp1);
<          crank(wksp2);
<          return cor(wksp1, wksp2);
<       }
<    }
< 
<    public static double spearman(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          double[] wksp1 = (double[])x.clone();
<          double[] wksp2 = (double[])y.clone();
<          QuickSortModified.sort(wksp1, wksp2);
<          crank(wksp1);
<          QuickSortModified.sort(wksp2, wksp1);
<          crank(wksp2);
<          return cor(wksp1, wksp2);
<       }
<    }
< 
<    public static double kendall(int[] x, int[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          int is = 0;
<          int n2 = 0;
<          int n1 = 0;
<          int n = x.length;
< 
<          for(int j = 0; j < n - 1; ++j) {
<             for(int k = j + 1; k < n; ++k) {
<                double a1 = (double)(x[j] - x[k]);
<                double a2 = (double)(y[j] - y[k]);
<                double aa = a1 * a2;
<                if (aa != 0.0D) {
<                   ++n1;
<                   ++n2;
<                   if (aa > 0.0D) {
<                      ++is;
<                   } else {
<                      --is;
<                   }
<                } else {
<                   if (a1 != 0.0D) {
<                      ++n1;
<                   }
< 
<                   if (a2 != 0.0D) {
<                      ++n2;
<                   }
<                }
<             }
<          }
< 
<          return (double)is / (Math.sqrt((double)n1) * Math.sqrt((double)n2));
<       }
<    }
< 
<    public static double kendall(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          int is = 0;
<          int n2 = 0;
<          int n1 = 0;
<          int n = x.length;
< 
<          for(int j = 0; j < n - 1; ++j) {
<             for(int k = j + 1; k < n; ++k) {
<                double a1 = (double)(x[j] - x[k]);
<                double a2 = (double)(y[j] - y[k]);
<                double aa = a1 * a2;
<                if (aa != 0.0D) {
<                   ++n1;
<                   ++n2;
<                   if (aa > 0.0D) {
<                      ++is;
<                   } else {
<                      --is;
<                   }
<                } else {
<                   if (a1 != 0.0D) {
<                      ++n1;
<                   }
< 
<                   if (a2 != 0.0D) {
<                      ++n2;
<                   }
<                }
<             }
<          }
< 
<          return (double)is / (Math.sqrt((double)n1) * Math.sqrt((double)n2));
<       }
<    }
< 
<    public static double kendall(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          int is = 0;
<          int n2 = 0;
<          int n1 = 0;
<          int n = x.length;
< 
<          for(int j = 0; j < n - 1; ++j) {
<             for(int k = j + 1; k < n; ++k) {
<                double a1 = x[j] - x[k];
<                double a2 = y[j] - y[k];
<                double aa = a1 * a2;
<                if (aa != 0.0D) {
<                   ++n1;
<                   ++n2;
<                   if (aa > 0.0D) {
<                      ++is;
<                   } else {
<                      --is;
<                   }
<                } else {
<                   if (a1 != 0.0D) {
<                      ++n1;
<                   }
< 
<                   if (a2 != 0.0D) {
<                      ++n2;
<                   }
<                }
<             }
<          }
< 
<          return (double)is / (Math.sqrt((double)n1) * Math.sqrt((double)n2));
<       }
<    }
< 
<    public static float norm1(float[] x) {
<       float norm = 0.0F;
<       float[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          float n = var5[var3];
<          norm += Math.abs(n);
<       }
< 
<       return norm;
<    }
< 
<    public static double norm1(double[] x) {
<       double norm = 0.0D;
<       double[] var7 = x;
<       int var6 = x.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double n = var7[var5];
<          norm += Math.abs(n);
<       }
< 
<       return norm;
<    }
< 
<    public static float norm2(float[] x) {
<       float norm = 0.0F;
<       float[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          float n = var5[var3];
<          norm += n * n;
<       }
< 
<       norm = (float)Math.sqrt((double)norm);
<       return norm;
<    }
< 
<    public static double norm2(double[] x) {
<       double norm = 0.0D;
<       double[] var7 = x;
<       int var6 = x.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double n = var7[var5];
<          norm += n * n;
<       }
< 
<       norm = Math.sqrt(norm);
<       return norm;
<    }
< 
<    public static float normInf(float[] x) {
<       int n = x.length;
<       float f = Math.abs(x[0]);
< 
<       for(int i = 1; i < n; ++i) {
<          f = Math.max(f, Math.abs(x[i]));
<       }
< 
<       return f;
<    }
< 
<    public static double normInf(double[] x) {
<       int n = x.length;
<       double f = Math.abs(x[0]);
< 
<       for(int i = 1; i < n; ++i) {
<          f = Math.max(f, Math.abs(x[i]));
<       }
< 
<       return f;
<    }
< 
<    public static float norm(float[] x) {
<       return norm2(x);
<    }
< 
<    public static double norm(double[] x) {
<       return norm2(x);
<    }
< 
<    public static float cos(float[] x, float[] y) {
<       return dot(x, y) / (norm2(x) * norm2(y));
<    }
< 
<    public static double cos(double[] x, double[] y) {
<       return dot(x, y) / (norm2(x) * norm2(y));
<    }
< 
<    public static void standardize(double[] x) {
<       double mu = mean(x);
<       double sigma = sd(x);
<       if (isZero(sigma)) {
<          logger.warn("array has variance of 0.");
<       } else {
<          for(int i = 0; i < x.length; ++i) {
---
>             else {
>                 int jt;
>                 for (jt = j + 1; jt <= n && w[jt - 1] == w[j - 1]; ++jt) {}
>                 final double rank = 0.5 * (j + jt - 1);
>                 for (int ji = j; ji <= jt - 1; ++ji) {
>                     w[ji - 1] = rank;
>                 }
>                 final double t = jt - j;
>                 s += t * t * t - t;
>                 j = jt;
>             }
>         }
>         if (j == n) {
>             w[n - 1] = n;
>         }
>         return s;
>     }
>     
>     public static double spearman(final int[] x, final int[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Input vector sizes are different.");
>         }
>         final int n = x.length;
>         final double[] wksp1 = new double[n];
>         final double[] wksp2 = new double[n];
>         for (int j = 0; j < n; ++j) {
>             wksp1[j] = x[j];
>             wksp2[j] = y[j];
>         }
>         QuickSortModified.sort(wksp1, wksp2);
>         crank(wksp1);
>         QuickSortModified.sort(wksp2, wksp1);
>         crank(wksp2);
>         return cor(wksp1, wksp2);
>     }
>     
>     public static double spearman(final float[] x, final float[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Input vector sizes are different.");
>         }
>         final int n = x.length;
>         final double[] wksp1 = new double[n];
>         final double[] wksp2 = new double[n];
>         for (int j = 0; j < n; ++j) {
>             wksp1[j] = x[j];
>             wksp2[j] = y[j];
>         }
>         QuickSortModified.sort(wksp1, wksp2);
>         crank(wksp1);
>         QuickSortModified.sort(wksp2, wksp1);
>         crank(wksp2);
>         return cor(wksp1, wksp2);
>     }
>     
>     public static double spearman(final double[] x, final double[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Input vector sizes are different.");
>         }
>         final double[] wksp1 = x.clone();
>         final double[] wksp2 = y.clone();
>         QuickSortModified.sort(wksp1, wksp2);
>         crank(wksp1);
>         QuickSortModified.sort(wksp2, wksp1);
>         crank(wksp2);
>         return cor(wksp1, wksp2);
>     }
>     
>     public static double kendall(final int[] x, final int[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Input vector sizes are different.");
>         }
>         int is = 0;
>         int n2 = 0;
>         int n3 = 0;
>         for (int n4 = x.length, j = 0; j < n4 - 1; ++j) {
>             for (int k = j + 1; k < n4; ++k) {
>                 final double a1 = x[j] - x[k];
>                 final double a2 = y[j] - y[k];
>                 final double aa = a1 * a2;
>                 if (aa != 0.0) {
>                     ++n3;
>                     ++n2;
>                     if (aa > 0.0) {
>                         ++is;
>                     }
>                     else {
>                         --is;
>                     }
>                 }
>                 else {
>                     if (a1 != 0.0) {
>                         ++n3;
>                     }
>                     if (a2 != 0.0) {
>                         ++n2;
>                     }
>                 }
>             }
>         }
>         return is / (Math.sqrt(n3) * Math.sqrt(n2));
>     }
>     
>     public static double kendall(final float[] x, final float[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Input vector sizes are different.");
>         }
>         int is = 0;
>         int n2 = 0;
>         int n3 = 0;
>         for (int n4 = x.length, j = 0; j < n4 - 1; ++j) {
>             for (int k = j + 1; k < n4; ++k) {
>                 final double a1 = x[j] - x[k];
>                 final double a2 = y[j] - y[k];
>                 final double aa = a1 * a2;
>                 if (aa != 0.0) {
>                     ++n3;
>                     ++n2;
>                     if (aa > 0.0) {
>                         ++is;
>                     }
>                     else {
>                         --is;
>                     }
>                 }
>                 else {
>                     if (a1 != 0.0) {
>                         ++n3;
>                     }
>                     if (a2 != 0.0) {
>                         ++n2;
>                     }
>                 }
>             }
>         }
>         return is / (Math.sqrt(n3) * Math.sqrt(n2));
>     }
>     
>     public static double kendall(final double[] x, final double[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException("Input vector sizes are different.");
>         }
>         int is = 0;
>         int n2 = 0;
>         int n3 = 0;
>         for (int n4 = x.length, j = 0; j < n4 - 1; ++j) {
>             for (int k = j + 1; k < n4; ++k) {
>                 final double a1 = x[j] - x[k];
>                 final double a2 = y[j] - y[k];
>                 final double aa = a1 * a2;
>                 if (aa != 0.0) {
>                     ++n3;
>                     ++n2;
>                     if (aa > 0.0) {
>                         ++is;
>                     }
>                     else {
>                         --is;
>                     }
>                 }
>                 else {
>                     if (a1 != 0.0) {
>                         ++n3;
>                     }
>                     if (a2 != 0.0) {
>                         ++n2;
>                     }
>                 }
>             }
>         }
>         return is / (Math.sqrt(n3) * Math.sqrt(n2));
>     }
>     
>     public static float norm1(final float[] x) {
>         float norm = 0.0f;
>         for (final float n : x) {
>             norm += Math.abs(n);
>         }
>         return norm;
>     }
>     
>     public static double norm1(final double[] x) {
>         double norm = 0.0;
>         for (final double n : x) {
>             norm += Math.abs(n);
>         }
>         return norm;
>     }
>     
>     public static float norm2(final float[] x) {
>         float norm = 0.0f;
>         for (final float n : x) {
>             norm += n * n;
>         }
>         norm = (float)Math.sqrt(norm);
>         return norm;
>     }
>     
>     public static double norm2(final double[] x) {
>         double norm = 0.0;
>         for (final double n : x) {
>             norm += n * n;
>         }
>         norm = Math.sqrt(norm);
>         return norm;
>     }
>     
>     public static float normInf(final float[] x) {
>         final int n = x.length;
>         float f = Math.abs(x[0]);
>         for (int i = 1; i < n; ++i) {
>             f = Math.max(f, Math.abs(x[i]));
>         }
>         return f;
>     }
>     
>     public static double normInf(final double[] x) {
>         final int n = x.length;
>         double f = Math.abs(x[0]);
>         for (int i = 1; i < n; ++i) {
>             f = Math.max(f, Math.abs(x[i]));
>         }
>         return f;
>     }
>     
>     public static float norm(final float[] x) {
>         return norm2(x);
>     }
>     
>     public static double norm(final double[] x) {
>         return norm2(x);
>     }
>     
>     public static float cos(final float[] x, final float[] y) {
>         return dot(x, y) / (norm2(x) * norm2(y));
>     }
>     
>     public static double cos(final double[] x, final double[] y) {
>         return dot(x, y) / (norm2(x) * norm2(y));
>     }
>     
>     public static void standardize(final double[] x) {
>         final double mu = mean(x);
>         final double sigma = sd(x);
>         if (isZero(sigma)) {
>             MathExModified.logger.warn("array has variance of 0.");
>             return;
>         }
>         for (int i = 0; i < x.length; ++i) {
2682,2702c2303,2340
<          }
< 
<       }
<    }
< 
<    public static void scale(double[][] x) {
<       int n = x.length;
<       int p = x[0].length;
<       double[] min = colMin(x);
<       double[] max = colMax(x);
< 
<       for(int j = 0; j < p; ++j) {
<          double scale = max[j] - min[j];
<          int i;
<          if (!isZero(scale)) {
<             for(i = 0; i < n; ++i) {
<                x[i][j] = (x[i][j] - min[j]) / scale;
<             }
<          } else {
<             for(i = 0; i < n; ++i) {
<                x[i][j] = 0.5D;
---
>         }
>     }
>     
>     public static void scale(final double[][] x) {
>         final int n = x.length;
>         final int p = x[0].length;
>         final double[] min = colMin(x);
>         final double[] max = colMax(x);
>         for (int j = 0; j < p; ++j) {
>             final double scale = max[j] - min[j];
>             if (!isZero(scale)) {
>                 for (int i = 0; i < n; ++i) {
>                     x[i][j] = (x[i][j] - min[j]) / scale;
>                 }
>             }
>             else {
>                 for (int i = 0; i < n; ++i) {
>                     x[i][j] = 0.5;
>                 }
>             }
>         }
>     }
>     
>     public static void standardize(final double[][] x) {
>         final int n = x.length;
>         final int p = x[0].length;
>         final double[] center = colMeans(x);
>         for (int i = 0; i < n; ++i) {
>             for (int j = 0; j < p; ++j) {
>                 x[i][j] -= center[j];
>             }
>         }
>         final double[] scale = new double[p];
>         for (int j = 0; j < p; ++j) {
>             for (final double[] xi : x) {
>                 final double[] array = scale;
>                 final int n2 = j;
>                 array[n2] += pow2(xi[j]);
2704,2777c2342
<          }
<       }
< 
<    }
< 
<    public static void standardize(double[][] x) {
<       int n = x.length;
<       int p = x[0].length;
<       double[] center = colMeans(x);
< 
<       int j;
<       for(int i = 0; i < n; ++i) {
<          for(j = 0; j < p; ++j) {
<             x[i][j] -= center[j];
<          }
<       }
< 
<       double[] scale = new double[p];
< 
<       for(j = 0; j < p; ++j) {
<          double[][] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             double[] xi = var9[var7];
<             scale[j] += pow2(xi[j]);
<          }
< 
<          scale[j] = Math.sqrt(scale[j] / (double)(n - 1));
<          if (!isZero(scale[j])) {
<             for(int i = 0; i < n; ++i) {
<                x[i][j] /= scale[j];
<             }
<          }
<       }
< 
<    }
< 
<    public static void normalize(double[][] x) {
<       normalize(x, false);
<    }
< 
<    public static void normalize(double[][] x, boolean centerizing) {
<       int n = x.length;
<       int p = x[0].length;
<       double[] scale;
<       int i;
<       int j;
<       if (centerizing) {
<          scale = colMeans(x);
< 
<          for(i = 0; i < n; ++i) {
<             for(j = 0; j < p; ++j) {
<                x[i][j] -= scale[j];
<             }
<          }
<       }
< 
<       scale = new double[p];
< 
<       for(i = 0; i < p; ++i) {
<          double[][] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             double[] xi = var9[var7];
<             scale[i] += pow2(xi[i]);
<          }
< 
<          scale[i] = Math.sqrt(scale[i]);
<       }
< 
<       for(i = 0; i < n; ++i) {
<          for(j = 0; j < p; ++j) {
---
>             scale[j] = Math.sqrt(scale[j] / (n - 1));
2779,2816c2344,2415
<                x[i][j] /= scale[j];
<             }
<          }
<       }
< 
<    }
< 
<    public static void unitize(double[] x) {
<       unitize2(x);
<    }
< 
<    public static void unitize1(double[] x) {
<       double n = norm1(x);
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] /= n;
<       }
< 
<    }
< 
<    public static void unitize2(double[] x) {
<       double n = norm(x);
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] /= n;
<       }
< 
<    }
< 
<    public static boolean equals(float[] x, float[] y) {
<       return equals(x, y, 1.0E-7F);
<    }
< 
<    public static boolean equals(float[] x, float[] y, float epsilon) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
---
>                 for (final double[] array2 : x) {
>                     final int n3 = j;
>                     array2[n3] /= scale[j];
>                 }
>             }
>         }
>     }
>     
>     public static void normalize(final double[][] x) {
>         normalize(x, false);
>     }
>     
>     public static void normalize(final double[][] x, final boolean centerizing) {
>         final int n = x.length;
>         final int p = x[0].length;
>         if (centerizing) {
>             final double[] center = colMeans(x);
>             for (int i = 0; i < n; ++i) {
>                 for (int j = 0; j < p; ++j) {
>                     x[i][j] -= center[j];
>                 }
>             }
>         }
>         final double[] scale = new double[p];
>         for (int k = 0; k < p; ++k) {
>             for (final double[] xi : x) {
>                 final double[] array = scale;
>                 final int n2 = k;
>                 array[n2] += pow2(xi[k]);
>             }
>             scale[k] = Math.sqrt(scale[k]);
>         }
>         for (int i = 0; i < n; ++i) {
>             for (int j = 0; j < p; ++j) {
>                 if (!isZero(scale[j])) {
>                     final double[] array2 = x[i];
>                     final int n3 = j;
>                     array2[n3] /= scale[j];
>                 }
>             }
>         }
>     }
>     
>     public static void unitize(final double[] x) {
>         unitize2(x);
>     }
>     
>     public static void unitize1(final double[] x) {
>         final double n = norm1(x);
>         for (int i = 0; i < x.length; ++i) {
>             final int n2 = i;
>             x[n2] /= n;
>         }
>     }
>     
>     public static void unitize2(final double[] x) {
>         final double n = norm(x);
>         for (int i = 0; i < x.length; ++i) {
>             final int n2 = i;
>             x[n2] /= n;
>         }
>     }
>     
>     public static boolean equals(final float[] x, final float[] y) {
>         return equals(x, y, 1.0E-7f);
>     }
>     
>     public static boolean equals(final float[] x, final float[] y, final float epsilon) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
>         }
>         for (int i = 0; i < x.length; ++i) {
2818c2417
<                return false;
---
>                 return false;
2820,2836c2419,2434
<          }
< 
<          return true;
<       }
<    }
< 
<    public static boolean equals(double[] x, double[] y) {
<       return equals(x, y, 1.0E-10D);
<    }
< 
<    public static boolean equals(double[] x, double[] y, double epsilon) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else if (epsilon <= 0.0D) {
<          throw new IllegalArgumentException("Invalid epsilon: " + epsilon);
<       } else {
<          for(int i = 0; i < x.length; ++i) {
---
>         }
>         return true;
>     }
>     
>     public static boolean equals(final double[] x, final double[] y) {
>         return equals(x, y, 1.0E-10);
>     }
>     
>     public static boolean equals(final double[] x, final double[] y, final double epsilon) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
>         }
>         if (epsilon <= 0.0) {
>             throw new IllegalArgumentException("Invalid epsilon: " + epsilon);
>         }
>         for (int i = 0; i < x.length; ++i) {
2838c2436
<                return false;
---
>                 return false;
2840,2872c2438,2468
<          }
< 
<          return true;
<       }
<    }
< 
<    public static boolean equals(float[][] x, float[][] y) {
<       return equals(x, y, 1.0E-7F);
<    }
< 
<    public static boolean equals(float[][] x, float[][] y, float epsilon) {
<       if (x.length == y.length && x[0].length == y[0].length) {
<          for(int i = 0; i < x.length; ++i) {
<             for(int j = 0; j < x[i].length; ++j) {
<                if (Math.abs(x[i][j] - y[i][j]) > epsilon) {
<                   return false;
<                }
<             }
<          }
< 
<          return true;
<       } else {
<          throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
<       }
<    }
< 
<    public static boolean equals(double[][] x, double[][] y) {
<       return equals(x, y, 1.0E-10D);
<    }
< 
<    public static boolean equals(double[][] x, double[][] y, double epsilon) {
<       if (x.length == y.length && x[0].length == y[0].length) {
<          if (epsilon <= 0.0D) {
---
>         }
>         return true;
>     }
>     
>     public static boolean equals(final float[][] x, final float[][] y) {
>         return equals(x, y, 1.0E-7f);
>     }
>     
>     public static boolean equals(final float[][] x, final float[][] y, final float epsilon) {
>         if (x.length != y.length || x[0].length != y[0].length) {
>             throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
>         }
>         for (int i = 0; i < x.length; ++i) {
>             for (int j = 0; j < x[i].length; ++j) {
>                 if (Math.abs(x[i][j] - y[i][j]) > epsilon) {
>                     return false;
>                 }
>             }
>         }
>         return true;
>     }
>     
>     public static boolean equals(final double[][] x, final double[][] y) {
>         return equals(x, y, 1.0E-10);
>     }
>     
>     public static boolean equals(final double[][] x, final double[][] y, final double epsilon) {
>         if (x.length != y.length || x[0].length != y[0].length) {
>             throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
>         }
>         if (epsilon <= 0.0) {
2874,2965c2470,2550
<          } else {
<             for(int i = 0; i < x.length; ++i) {
<                for(int j = 0; j < x[i].length; ++j) {
<                   if (Math.abs(x[i][j] - y[i][j]) > epsilon) {
<                      return false;
<                   }
<                }
<             }
< 
<             return true;
<          }
<       } else {
<          throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
<       }
<    }
< 
<    public static boolean isZero(float x) {
<       return isZero(x, FLOAT_EPSILON);
<    }
< 
<    public static boolean isZero(float x, float epsilon) {
<       return Math.abs(x) < epsilon;
<    }
< 
<    public static boolean isZero(double x) {
<       return isZero(x, EPSILON);
<    }
< 
<    public static boolean isZero(double x, double epsilon) {
<       return Math.abs(x) < epsilon;
<    }
< 
<    public static int[][] clone(int[][] x) {
<       int[][] matrix = new int[x.length][];
< 
<       for(int i = 0; i < x.length; ++i) {
<          matrix[i] = (int[])x[i].clone();
<       }
< 
<       return matrix;
<    }
< 
<    public static float[][] clone(float[][] x) {
<       float[][] matrix = new float[x.length][];
< 
<       for(int i = 0; i < x.length; ++i) {
<          matrix[i] = (float[])x[i].clone();
<       }
< 
<       return matrix;
<    }
< 
<    public static double[][] clone(double[][] x) {
<       double[][] matrix = new double[x.length][];
< 
<       for(int i = 0; i < x.length; ++i) {
<          matrix[i] = (double[])x[i].clone();
<       }
< 
<       return matrix;
<    }
< 
<    public static void swap(int[] x, int i, int j) {
<       int s = x[i];
<       x[i] = x[j];
<       x[j] = s;
<    }
< 
<    public static void swap(float[] x, int i, int j) {
<       float s = x[i];
<       x[i] = x[j];
<       x[j] = s;
<    }
< 
<    public static void swap(double[] x, int i, int j) {
<       double s = x[i];
<       x[i] = x[j];
<       x[j] = s;
<    }
< 
<    public static void swap(Object[] x, int i, int j) {
<       Object s = x[i];
<       x[i] = x[j];
<       x[j] = s;
<    }
< 
<    public static void swap(int[] x, int[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             int s = x[i];
---
>         }
>         for (int i = 0; i < x.length; ++i) {
>             for (int j = 0; j < x[i].length; ++j) {
>                 if (Math.abs(x[i][j] - y[i][j]) > epsilon) {
>                     return false;
>                 }
>             }
>         }
>         return true;
>     }
>     
>     public static boolean isZero(final float x) {
>         return isZero(x, MathExModified.FLOAT_EPSILON);
>     }
>     
>     public static boolean isZero(final float x, final float epsilon) {
>         return Math.abs(x) < epsilon;
>     }
>     
>     public static boolean isZero(final double x) {
>         return isZero(x, MathExModified.EPSILON);
>     }
>     
>     public static boolean isZero(final double x, final double epsilon) {
>         return Math.abs(x) < epsilon;
>     }
>     
>     public static int[][] clone(final int[][] x) {
>         final int[][] matrix = new int[x.length][];
>         for (int i = 0; i < x.length; ++i) {
>             matrix[i] = x[i].clone();
>         }
>         return matrix;
>     }
>     
>     public static float[][] clone(final float[][] x) {
>         final float[][] matrix = new float[x.length][];
>         for (int i = 0; i < x.length; ++i) {
>             matrix[i] = x[i].clone();
>         }
>         return matrix;
>     }
>     
>     public static double[][] clone(final double[][] x) {
>         final double[][] matrix = new double[x.length][];
>         for (int i = 0; i < x.length; ++i) {
>             matrix[i] = x[i].clone();
>         }
>         return matrix;
>     }
>     
>     public static void swap(final int[] x, final int i, final int j) {
>         final int s = x[i];
>         x[i] = x[j];
>         x[j] = s;
>     }
>     
>     public static void swap(final float[] x, final int i, final int j) {
>         final float s = x[i];
>         x[i] = x[j];
>         x[j] = s;
>     }
>     
>     public static void swap(final double[] x, final int i, final int j) {
>         final double s = x[i];
>         x[i] = x[j];
>         x[j] = s;
>     }
>     
>     public static void swap(final Object[] x, final int i, final int j) {
>         final Object s = x[i];
>         x[i] = x[j];
>         x[j] = s;
>     }
>     
>     public static void swap(final int[] x, final int[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
>         }
>         for (int i = 0; i < x.length; ++i) {
>             final int s = x[i];
2968,2978c2553,2561
<          }
< 
<       }
<    }
< 
<    public static void swap(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             float s = x[i];
---
>         }
>     }
>     
>     public static void swap(final float[] x, final float[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
>         }
>         for (int i = 0; i < x.length; ++i) {
>             final float s = x[i];
2981,2991c2564,2572
<          }
< 
<       }
<    }
< 
<    public static void swap(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             double s = x[i];
---
>         }
>     }
>     
>     public static void swap(final double[] x, final double[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
>         }
>         for (int i = 0; i < x.length; ++i) {
>             final double s = x[i];
2994,3004c2575,2583
<          }
< 
<       }
<    }
< 
<    public static <E> void swap(E[] x, E[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             E s = x[i];
---
>         }
>     }
>     
>     public static <E> void swap(final E[] x, final E[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
>         }
>         for (int i = 0; i < x.length; ++i) {
>             final E s = x[i];
3007,3014c2586,2593
<          }
< 
<       }
<    }
< 
<    public static void copy(int[][] x, int[][] y) {
<       if (x.length == y.length && x[0].length == y[0].length) {
<          for(int i = 0; i < x.length; ++i) {
---
>         }
>     }
>     
>     public static void copy(final int[][] x, final int[][] y) {
>         if (x.length != y.length || x[0].length != y[0].length) {
>             throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
>         }
>         for (int i = 0; i < x.length; ++i) {
3016,3025c2595,2602
<          }
< 
<       } else {
<          throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
<       }
<    }
< 
<    public static void copy(float[][] x, float[][] y) {
<       if (x.length == y.length && x[0].length == y[0].length) {
<          for(int i = 0; i < x.length; ++i) {
---
>         }
>     }
>     
>     public static void copy(final float[][] x, final float[][] y) {
>         if (x.length != y.length || x[0].length != y[0].length) {
>             throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
>         }
>         for (int i = 0; i < x.length; ++i) {
3027,3036c2604,2611
<          }
< 
<       } else {
<          throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
<       }
<    }
< 
<    public static void copy(double[][] x, double[][] y) {
<       if (x.length == y.length && x[0].length == y[0].length) {
<          for(int i = 0; i < x.length; ++i) {
---
>         }
>     }
>     
>     public static void copy(final double[][] x, final double[][] y) {
>         if (x.length != y.length || x[0].length != y[0].length) {
>             throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
>         }
>         for (int i = 0; i < x.length; ++i) {
3038,3124c2613,2685
<          }
< 
<       } else {
<          throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
<       }
<    }
< 
<    public static void add(double[] y, double[] x) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             y[i] += x[i];
<          }
< 
<       }
<    }
< 
<    public static void sub(double[] y, double[] x) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             y[i] -= x[i];
<          }
< 
<       }
<    }
< 
<    public static void scale(double a, double[] x) {
<       for(int i = 0; i < x.length; ++i) {
<          x[i] *= a;
<       }
< 
<    }
< 
<    public static void scale(double a, double[] x, double[] y) {
<       for(int i = 0; i < x.length; ++i) {
<          y[i] = a * x[i];
<       }
< 
<    }
< 
<    public static double[] axpy(double a, double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             y[i] += a * x[i];
<          }
< 
<          return y;
<       }
<    }
< 
<    public static double[] pow(double[] x, double n) {
<       double[] y = new double[x.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          y[i] = Math.pow(x[i], n);
<       }
< 
<       return y;
<    }
< 
<    public static int[] unique(int[] x) {
<       return Arrays.stream(x).distinct().toArray();
<    }
< 
<    public static String[] unique(String[] x) {
<       return (String[])Arrays.stream(x).distinct().toArray((var0) -> {
<          return new String[var0];
<       });
<    }
< 
<    public static double[] solve(double[] a, double[] b, double[] c, double[] r) {
<       if (b[0] == 0.0D) {
<          throw new IllegalArgumentException("Invalid value of b[0] == 0. The equations should be rewritten as a set of order n - 1.");
<       } else {
<          int n = a.length;
<          double[] u = new double[n];
<          double[] gam = new double[n];
<          double bet = b[0];
<          u[0] = r[0] / bet;
< 
<          int j;
<          for(j = 1; j < n; ++j) {
---
>         }
>     }
>     
>     public static void add(final double[] y, final double[] x) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
>         }
>         for (int i = 0; i < x.length; ++i) {
>             final int n = i;
>             y[n] += x[i];
>         }
>     }
>     
>     public static void sub(final double[] y, final double[] x) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
>         }
>         for (int i = 0; i < x.length; ++i) {
>             final int n = i;
>             y[n] -= x[i];
>         }
>     }
>     
>     public static void scale(final double a, final double[] x) {
>         for (int i = 0; i < x.length; ++i) {
>             final int n = i;
>             x[n] *= a;
>         }
>     }
>     
>     public static void scale(final double a, final double[] x, final double[] y) {
>         for (int i = 0; i < x.length; ++i) {
>             y[i] = a * x[i];
>         }
>     }
>     
>     public static double[] axpy(final double a, final double[] x, final double[] y) {
>         if (x.length != y.length) {
>             throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
>         }
>         for (int i = 0; i < x.length; ++i) {
>             final int n = i;
>             y[n] += a * x[i];
>         }
>         return y;
>     }
>     
>     public static double[] pow(final double[] x, final double n) {
>         final double[] y = new double[x.length];
>         for (int i = 0; i < x.length; ++i) {
>             y[i] = Math.pow(x[i], n);
>         }
>         return y;
>     }
>     
>     public static int[] unique(final int[] x) {
>         return Arrays.stream(x).distinct().toArray();
>     }
>     
>     public static String[] unique(final String[] x) {
>         return Arrays.<String>stream(x).distinct().<String>toArray(String[]::new);
>     }
>     
>     public static double[] solve(final double[] a, final double[] b, final double[] c, final double[] r) {
>         if (b[0] == 0.0) {
>             throw new IllegalArgumentException("Invalid value of b[0] == 0. The equations should be rewritten as a set of order n - 1.");
>         }
>         final int n = a.length;
>         final double[] u = new double[n];
>         final double[] gam = new double[n];
>         double bet = b[0];
>         u[0] = r[0] / bet;
>         for (int j = 1; j < n; ++j) {
3127,3128c2688,2689
<             if (bet == 0.0D) {
<                throw new IllegalArgumentException("The tridagonal matrix is not of diagonal dominance.");
---
>             if (bet == 0.0) {
>                 throw new IllegalArgumentException("The tridagonal matrix is not of diagonal dominance.");
3130d2690
< 
3132,3291c2692,2777
<          }
< 
<          for(j = n - 2; j >= 0; --j) {
<             u[j] -= gam[j + 1] * u[j + 1];
<          }
< 
<          return u;
<       }
<    }
< 
<    // $FF: synthetic method
<    private static Object $deserializeLambda$(SerializedLambda var0) {
<       String var1 = var0.getImplMethodName();
<       byte var2 = -1;
<       switch(var1.hashCode()) {
<       case -1421810692:
<          if (var1.equals("squaredDistance")) {
<             var2 = 0;
<          } else if (var1.equals("squaredDistance")) {
<             var2 = 0;
<          } else if (var1.equals("squaredDistance")) {
<             var2 = 0;
<          } else if (var1.equals("squaredDistance")) {
<             var2 = 0;
<          }
<          break;
<       case 288459765:
<          if (var1.equals("distance")) {
<             var2 = 1;
<          } else if (var1.equals("distance")) {
<             var2 = 1;
<          } else if (var1.equals("distance")) {
<             var2 = 1;
<          } else if (var1.equals("distance")) {
<             var2 = 1;
<          }
<       }
< 
<       switch(var2) {
<       case 0:
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([I[I)D")) {
<             return MathExModified::squaredDistance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([F[F)D")) {
<             return MathExModified::squaredDistance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([D[D)D")) {
<             return MathExModified::squaredDistance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("(LsmileModified/SparseArrayModified;LsmileModified/SparseArrayModified;)D")) {
<             return MathExModified::squaredDistance;
<          }
<          break;
<       case 1:
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([I[I)D")) {
<             return MathExModified::distance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([F[F)D")) {
<             return MathExModified::distance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([D[D)D")) {
<             return MathExModified::distance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("(LsmileModified/SparseArrayModified;LsmileModified/SparseArrayModified;)D")) {
<             return MathExModified::distance;
<          }
<       }
< 
<       throw new IllegalArgumentException("Invalid lambda deserialization");
<    }
< 
<    private static class FPU {
<       int RADIX;
<       int DIGITS;
<       int FLOAT_DIGITS = 24;
<       int ROUND_STYLE;
<       int MACHEP;
<       int FLOAT_MACHEP = -23;
<       int NEGEP;
<       int FLOAT_NEGEP = -24;
<       float FLOAT_EPSILON;
<       double EPSILON;
< 
<       FPU() {
<          this.FLOAT_EPSILON = (float)Math.pow(2.0D, (double)this.FLOAT_MACHEP);
<          double ONE = 1.0D;
<          double TWO = ONE + ONE;
<          double ZERO = ONE - ONE;
<          double a = ONE;
< 
<          double temp;
<          double temp1;
<          for(temp1 = ONE; temp1 - ONE == ZERO; temp1 = temp - a) {
<             a += a;
<             temp = a + ONE;
<          }
< 
<          double b = ONE;
< 
<          int itemp;
<          for(itemp = 0; itemp == 0; itemp = (int)(temp - a)) {
<             b += b;
<             temp = a + b;
<          }
< 
<          this.RADIX = itemp;
<          double beta = (double)this.RADIX;
<          this.DIGITS = 0;
<          b = ONE;
< 
<          for(temp1 = ONE; temp1 - ONE == ZERO; temp1 = temp - b) {
<             ++this.DIGITS;
<             b *= beta;
<             temp = b + ONE;
<          }
< 
<          this.ROUND_STYLE = 0;
<          double betah = beta / TWO;
<          temp = a + betah;
<          if (temp - a != ZERO) {
<             this.ROUND_STYLE = 1;
<          }
< 
<          double tempa = a + beta;
<          temp = tempa + betah;
<          if (this.ROUND_STYLE == 0 && temp - tempa != ZERO) {
<             this.ROUND_STYLE = 2;
<          }
< 
<          this.NEGEP = this.DIGITS + 3;
<          double betain = ONE / beta;
<          a = ONE;
< 
<          for(int i = 0; i < this.NEGEP; ++i) {
<             a *= betain;
<          }
< 
<          for(temp = ONE - a; temp - ONE == ZERO; temp = ONE - a) {
<             a *= beta;
<             --this.NEGEP;
<          }
< 
<          this.NEGEP = -this.NEGEP;
<          this.MACHEP = -this.DIGITS - 3;
<          a = a;
< 
<          for(temp = ONE + a; temp - ONE == ZERO; temp = ONE + a) {
<             a *= beta;
<             ++this.MACHEP;
<          }
< 
<          this.EPSILON = a;
<       }
<    }
---
>         }
>         for (int j = n - 2; j >= 0; --j) {
>             final double[] array = u;
>             final int n2 = j;
>             array[n2] -= gam[j + 1] * u[j + 1];
>         }
>         return u;
>     }
>     
>     static /* synthetic */ void access$2(final int nextSeed) {
>         MathExModified.nextSeed = nextSeed;
>     }
>     
>     private static class FPU
>     {
>         int RADIX;
>         int DIGITS;
>         int FLOAT_DIGITS;
>         int ROUND_STYLE;
>         int MACHEP;
>         int FLOAT_MACHEP;
>         int NEGEP;
>         int FLOAT_NEGEP;
>         float FLOAT_EPSILON;
>         double EPSILON;
>         
>         FPU() {
>             this.FLOAT_DIGITS = 24;
>             this.FLOAT_MACHEP = -23;
>             this.FLOAT_NEGEP = -24;
>             this.FLOAT_EPSILON = (float)Math.pow(2.0, this.FLOAT_MACHEP);
>             final double ONE = 1.0;
>             final double TWO = ONE + ONE;
>             final double ZERO = ONE - ONE;
>             double a = ONE;
>             double temp2;
>             for (double temp1 = ONE; temp1 - ONE == ZERO; temp1 = temp2 - a) {
>                 a += a;
>                 temp2 = a + ONE;
>             }
>             double b = ONE;
>             int itemp;
>             for (itemp = 0; itemp == 0; itemp = (int)(temp2 - a)) {
>                 b += b;
>                 temp2 = a + b;
>             }
>             this.RADIX = itemp;
>             final double beta = this.RADIX;
>             this.DIGITS = 0;
>             b = ONE;
>             for (double temp1 = ONE; temp1 - ONE == ZERO; temp1 = temp2 - b) {
>                 ++this.DIGITS;
>                 b *= beta;
>                 temp2 = b + ONE;
>             }
>             this.ROUND_STYLE = 0;
>             final double betah = beta / TWO;
>             temp2 = a + betah;
>             if (temp2 - a != ZERO) {
>                 this.ROUND_STYLE = 1;
>             }
>             final double tempa = a + beta;
>             temp2 = tempa + betah;
>             if (this.ROUND_STYLE == 0 && temp2 - tempa != ZERO) {
>                 this.ROUND_STYLE = 2;
>             }
>             this.NEGEP = this.DIGITS + 3;
>             final double betain = ONE / beta;
>             a = ONE;
>             for (int i = 0; i < this.NEGEP; ++i) {
>                 a *= betain;
>             }
>             b = a;
>             for (temp2 = ONE - a; temp2 - ONE == ZERO; temp2 = ONE - a) {
>                 a *= beta;
>                 --this.NEGEP;
>             }
>             this.NEGEP = -this.NEGEP;
>             this.MACHEP = -this.DIGITS - 3;
>             for (a = b, temp2 = ONE + a; temp2 - ONE == ZERO; temp2 = ONE + a) {
>                 a *= beta;
>                 ++this.MACHEP;
>             }
>             this.EPSILON = a;
>         }
>     }
diff -r TrackAnalyzer_/smileModified/MatrixModified.java procyon/smileModified/MatrixModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
6d9
< import org.slf4j.Logger;
7a11
> import org.slf4j.Logger;
9,29c13,40
< public class MatrixModified extends IMatrixModified {
<    private static final long serialVersionUID = 3L;
<    private static final Logger logger = LoggerFactory.getLogger(MatrixModified.class);
<    double[] A;
<    int ld;
<    int m;
<    int n;
<    UPLOModified uplo;
<    DiagModified diag;
< 
<    public MatrixModified(int m, int n) {
<       this(m, n, 0.0D);
<    }
< 
<    public MatrixModified(int m, int n, double a) {
<       if (m > 0 && n > 0) {
<          this.m = m;
<          this.n = n;
<          this.ld = ld(m);
<          this.A = new double[this.ld * n];
<          if (a != 0.0D) {
---
> public class MatrixModified extends IMatrixModified
> {
>     private static final long serialVersionUID = 3L;
>     private static final Logger logger;
>     double[] A;
>     int ld;
>     int m;
>     int n;
>     UPLOModified uplo;
>     DiagModified diag;
>     
>     static {
>         logger = LoggerFactory.getLogger((Class)MatrixModified.class);
>     }
>     
>     public MatrixModified(final int m, final int n) {
>         this(m, n, 0.0);
>     }
>     
>     public MatrixModified(final int m, final int n, final double a) {
>         if (m <= 0 || n <= 0) {
>             throw new IllegalArgumentException(String.format("Invalid matrix size: %d x %d", m, n));
>         }
>         this.m = m;
>         this.n = n;
>         this.ld = IMatrixModified.ld(m);
>         this.A = new double[this.ld * n];
>         if (a != 0.0) {
31,296c42,276
<          }
< 
<       } else {
<          throw new IllegalArgumentException(String.format("Invalid matrix size: %d x %d", m, n));
<       }
<    }
< 
<    public MatrixModified(int m, int n, int ld, double[] A) {
<       if (this.layout() == LayoutModified.COL_MAJOR && ld < m) {
<          throw new IllegalArgumentException(String.format("Invalid leading dimension for COL_MAJOR: %d < %d", ld, m));
<       } else if (this.layout() == LayoutModified.ROW_MAJOR && ld < n) {
<          throw new IllegalArgumentException(String.format("Invalid leading dimension for ROW_MAJOR: %d < %d", ld, n));
<       } else {
<          this.m = m;
<          this.n = n;
<          this.ld = ld;
<          this.A = A;
<       }
<    }
< 
<    public static MatrixModified of(double[][] A) {
<       int m = A.length;
<       int n = A[0].length;
<       MatrixModified matrix = new MatrixModified(m, n);
< 
<       for(int i = 0; i < m; ++i) {
<          for(int j = 0; j < n; ++j) {
<             matrix.set(i, j, A[i][j]);
<          }
<       }
< 
<       return matrix;
<    }
< 
<    public static MatrixModified column(double[] A) {
<       return column(A, 0, A.length);
<    }
< 
<    public static MatrixModified column(double[] A, int offset, int length) {
<       MatrixModified matrix = new MatrixModified(length, 1, length, new double[length]);
<       System.arraycopy(A, offset, matrix.A, 0, length);
<       return matrix;
<    }
< 
<    public static MatrixModified row(double[] A) {
<       return row(A, 0, A.length);
<    }
< 
<    public static MatrixModified row(double[] A, int offset, int length) {
<       MatrixModified matrix = new MatrixModified(1, length, 1, new double[length]);
<       System.arraycopy(A, offset, matrix.A, 0, length);
<       return matrix;
<    }
< 
<    public static MatrixModified rand(int m, int n, DistributionModified distribution) {
<       MatrixModified matrix = new MatrixModified(m, n);
< 
<       for(int j = 0; j < n; ++j) {
<          for(int i = 0; i < m; ++i) {
<             matrix.set(i, j, distribution.rand());
<          }
<       }
< 
<       return matrix;
<    }
< 
<    public static MatrixModified randn(int m, int n) {
<       return rand(m, n, GaussianDistributionModified.getInstance());
<    }
< 
<    public static MatrixModified rand(int m, int n) {
<       MatrixModified matrix = new MatrixModified(m, n);
< 
<       for(int j = 0; j < n; ++j) {
<          for(int i = 0; i < m; ++i) {
<             matrix.set(i, j, MathExModified.random());
<          }
<       }
< 
<       return matrix;
<    }
< 
<    public static MatrixModified rand(int m, int n, double lo, double hi) {
<       MatrixModified matrix = new MatrixModified(m, n);
< 
<       for(int j = 0; j < n; ++j) {
<          for(int i = 0; i < m; ++i) {
<             matrix.set(i, j, MathExModified.random(lo, hi));
<          }
<       }
< 
<       return matrix;
<    }
< 
<    public static MatrixModified eye(int n) {
<       return diag(n, 1.0D);
<    }
< 
<    public static MatrixModified eye(int m, int n) {
<       return diag(m, n, 1.0D);
<    }
< 
<    public static MatrixModified diag(int n, double diag) {
<       return diag(n, n, diag);
<    }
< 
<    public static MatrixModified diag(int m, int n, double diag) {
<       MatrixModified D = new MatrixModified(m, n);
<       int k = Math.min(m, n);
< 
<       for(int i = 0; i < k; ++i) {
<          D.set(i, i, diag);
<       }
< 
<       return D;
<    }
< 
<    public static MatrixModified diag(double[] diag) {
<       int n = diag.length;
<       MatrixModified D = new MatrixModified(n, n);
< 
<       for(int i = 0; i < n; ++i) {
<          D.set(i, i, diag[i]);
<       }
< 
<       return D;
<    }
< 
<    public static MatrixModified toeplitz(double[] a) {
<       int n = a.length;
<       MatrixModified toeplitz = new MatrixModified(n, n);
<       toeplitz.uplo(UPLOModified.LOWER);
< 
<       for(int i = 0; i < n; ++i) {
<          int j;
<          for(j = 0; j < i; ++j) {
<             toeplitz.set(i, j, a[i - j]);
<          }
< 
<          for(j = i; j < n; ++j) {
<             toeplitz.set(i, j, a[j - i]);
<          }
<       }
< 
<       return toeplitz;
<    }
< 
<    public static MatrixModified toeplitz(double[] kl, double[] ku) {
<       if (kl.length != ku.length - 1) {
<          throw new IllegalArgumentException(String.format("Invalid sub-diagonals and super-diagonals size: %d != %d - 1", kl.length, ku.length));
<       } else {
<          int n = kl.length;
<          MatrixModified toeplitz = new MatrixModified(n, n);
< 
<          for(int i = 0; i < n; ++i) {
<             int j;
<             for(j = 0; j < i; ++j) {
<                toeplitz.set(i, j, kl[i - j]);
<             }
< 
<             for(j = i; j < n; ++j) {
<                toeplitz.set(i, j, ku[j - i]);
<             }
<          }
< 
<          return toeplitz;
<       }
<    }
< 
<    public int nrow() {
<       return this.m;
<    }
< 
<    public int ncol() {
<       return this.n;
<    }
< 
<    public long size() {
<       return (long)(this.m * this.n);
<    }
< 
<    public LayoutModified layout() {
<       return LayoutModified.COL_MAJOR;
<    }
< 
<    public int ld() {
<       return this.ld;
<    }
< 
<    public boolean isSymmetric() {
<       return this.uplo != null && this.diag == null;
<    }
< 
<    public MatrixModified uplo(UPLOModified uplo) {
<       if (this.m != this.n) {
<          throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
<       } else {
<          this.uplo = uplo;
<          return this;
<       }
<    }
< 
<    public UPLOModified uplo() {
<       return this.uplo;
<    }
< 
<    public MatrixModified triangular(DiagModified diag) {
<       if (this.m != this.n) {
<          throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
<       } else {
<          this.diag = diag;
<          return this;
<       }
<    }
< 
<    public DiagModified triangular() {
<       return this.diag;
<    }
< 
<    public MatrixModified clone() {
<       MatrixModified matrix;
<       if (this.layout() == LayoutModified.COL_MAJOR) {
<          matrix = new MatrixModified(this.m, this.n, this.ld, (double[])this.A.clone());
<       } else {
<          matrix = new MatrixModified(this.m, this.n);
< 
<          for(int j = 0; j < this.n; ++j) {
<             for(int i = 0; i < this.m; ++i) {
<                matrix.set(i, j, this.get(i, j));
<             }
<          }
<       }
< 
<       if (this.m == this.n) {
<          matrix.uplo(this.uplo);
<          matrix.triangular(this.diag);
<       }
< 
<       return matrix;
<    }
< 
<    public double[][] toArray() {
<       double[][] array = new double[this.m][this.n];
< 
<       for(int i = 0; i < this.m; ++i) {
<          for(int j = 0; j < this.n; ++j) {
<             array[i][j] = this.get(i, j);
<          }
<       }
< 
<       return array;
<    }
< 
<    public MatrixModified set(MatrixModified b) {
<       this.m = b.m;
<       this.n = b.n;
<       this.diag = b.diag;
<       this.uplo = b.uplo;
<       if (this.layout() == b.layout()) {
<          this.A = b.A;
<          this.ld = b.ld;
<       } else {
<          int j;
<          int i;
<          if (this.layout() == LayoutModified.COL_MAJOR) {
<             this.ld = ld(this.m);
---
>         }
>     }
>     
>     public MatrixModified(final int m, final int n, final int ld, final double[] A) {
>         if (this.layout() == LayoutModified.COL_MAJOR && ld < m) {
>             throw new IllegalArgumentException(String.format("Invalid leading dimension for COL_MAJOR: %d < %d", ld, m));
>         }
>         if (this.layout() == LayoutModified.ROW_MAJOR && ld < n) {
>             throw new IllegalArgumentException(String.format("Invalid leading dimension for ROW_MAJOR: %d < %d", ld, n));
>         }
>         this.m = m;
>         this.n = n;
>         this.ld = ld;
>         this.A = A;
>     }
>     
>     public static MatrixModified of(final double[][] A) {
>         final int m = A.length;
>         final int n = A[0].length;
>         final MatrixModified matrix = new MatrixModified(m, n);
>         for (int i = 0; i < m; ++i) {
>             for (int j = 0; j < n; ++j) {
>                 matrix.set(i, j, A[i][j]);
>             }
>         }
>         return matrix;
>     }
>     
>     public static MatrixModified column(final double[] A) {
>         return column(A, 0, A.length);
>     }
>     
>     public static MatrixModified column(final double[] A, final int offset, final int length) {
>         final MatrixModified matrix = new MatrixModified(length, 1, length, new double[length]);
>         System.arraycopy(A, offset, matrix.A, 0, length);
>         return matrix;
>     }
>     
>     public static MatrixModified row(final double[] A) {
>         return row(A, 0, A.length);
>     }
>     
>     public static MatrixModified row(final double[] A, final int offset, final int length) {
>         final MatrixModified matrix = new MatrixModified(1, length, 1, new double[length]);
>         System.arraycopy(A, offset, matrix.A, 0, length);
>         return matrix;
>     }
>     
>     public static MatrixModified rand(final int m, final int n, final DistributionModified distribution) {
>         final MatrixModified matrix = new MatrixModified(m, n);
>         for (int j = 0; j < n; ++j) {
>             for (int i = 0; i < m; ++i) {
>                 matrix.set(i, j, distribution.rand());
>             }
>         }
>         return matrix;
>     }
>     
>     public static MatrixModified randn(final int m, final int n) {
>         return rand(m, n, GaussianDistributionModified.getInstance());
>     }
>     
>     public static MatrixModified rand(final int m, final int n) {
>         final MatrixModified matrix = new MatrixModified(m, n);
>         for (int j = 0; j < n; ++j) {
>             for (int i = 0; i < m; ++i) {
>                 matrix.set(i, j, MathExModified.random());
>             }
>         }
>         return matrix;
>     }
>     
>     public static MatrixModified rand(final int m, final int n, final double lo, final double hi) {
>         final MatrixModified matrix = new MatrixModified(m, n);
>         for (int j = 0; j < n; ++j) {
>             for (int i = 0; i < m; ++i) {
>                 matrix.set(i, j, MathExModified.random(lo, hi));
>             }
>         }
>         return matrix;
>     }
>     
>     public static MatrixModified eye(final int n) {
>         return diag(n, 1.0);
>     }
>     
>     public static MatrixModified eye(final int m, final int n) {
>         return diag(m, n, 1.0);
>     }
>     
>     public static MatrixModified diag(final int n, final double diag) {
>         return diag(n, n, diag);
>     }
>     
>     public static MatrixModified diag(final int m, final int n, final double diag) {
>         final MatrixModified D = new MatrixModified(m, n);
>         for (int k = Math.min(m, n), i = 0; i < k; ++i) {
>             D.set(i, i, diag);
>         }
>         return D;
>     }
>     
>     public static MatrixModified diag(final double[] diag) {
>         final int n = diag.length;
>         final MatrixModified D = new MatrixModified(n, n);
>         for (int i = 0; i < n; ++i) {
>             D.set(i, i, diag[i]);
>         }
>         return D;
>     }
>     
>     public static MatrixModified toeplitz(final double[] a) {
>         final int n = a.length;
>         final MatrixModified toeplitz = new MatrixModified(n, n);
>         toeplitz.uplo(UPLOModified.LOWER);
>         for (int i = 0; i < n; ++i) {
>             for (int j = 0; j < i; ++j) {
>                 toeplitz.set(i, j, a[i - j]);
>             }
>             for (int j = i; j < n; ++j) {
>                 toeplitz.set(i, j, a[j - i]);
>             }
>         }
>         return toeplitz;
>     }
>     
>     public static MatrixModified toeplitz(final double[] kl, final double[] ku) {
>         if (kl.length != ku.length - 1) {
>             throw new IllegalArgumentException(String.format("Invalid sub-diagonals and super-diagonals size: %d != %d - 1", kl.length, ku.length));
>         }
>         final int n = kl.length;
>         final MatrixModified toeplitz = new MatrixModified(n, n);
>         for (int i = 0; i < n; ++i) {
>             for (int j = 0; j < i; ++j) {
>                 toeplitz.set(i, j, kl[i - j]);
>             }
>             for (int j = i; j < n; ++j) {
>                 toeplitz.set(i, j, ku[j - i]);
>             }
>         }
>         return toeplitz;
>     }
>     
>     @Override
>     public int nrow() {
>         return this.m;
>     }
>     
>     @Override
>     public int ncol() {
>         return this.n;
>     }
>     
>     @Override
>     public long size() {
>         return this.m * this.n;
>     }
>     
>     public LayoutModified layout() {
>         return LayoutModified.COL_MAJOR;
>     }
>     
>     public int ld() {
>         return this.ld;
>     }
>     
>     public boolean isSymmetric() {
>         return this.uplo != null && this.diag == null;
>     }
>     
>     public MatrixModified uplo(final UPLOModified uplo) {
>         if (this.m != this.n) {
>             throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
>         }
>         this.uplo = uplo;
>         return this;
>     }
>     
>     public UPLOModified uplo() {
>         return this.uplo;
>     }
>     
>     public MatrixModified triangular(final DiagModified diag) {
>         if (this.m != this.n) {
>             throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
>         }
>         this.diag = diag;
>         return this;
>     }
>     
>     public DiagModified triangular() {
>         return this.diag;
>     }
>     
>     public MatrixModified clone() {
>         MatrixModified matrix;
>         if (this.layout() == LayoutModified.COL_MAJOR) {
>             matrix = new MatrixModified(this.m, this.n, this.ld, this.A.clone());
>         }
>         else {
>             matrix = new MatrixModified(this.m, this.n);
>             for (int j = 0; j < this.n; ++j) {
>                 for (int i = 0; i < this.m; ++i) {
>                     matrix.set(i, j, this.get(i, j));
>                 }
>             }
>         }
>         if (this.m == this.n) {
>             matrix.uplo(this.uplo);
>             matrix.triangular(this.diag);
>         }
>         return matrix;
>     }
>     
>     public double[][] toArray() {
>         final double[][] array = new double[this.m][this.n];
>         for (int i = 0; i < this.m; ++i) {
>             for (int j = 0; j < this.n; ++j) {
>                 array[i][j] = this.get(i, j);
>             }
>         }
>         return array;
>     }
>     
>     public MatrixModified set(final MatrixModified b) {
>         this.m = b.m;
>         this.n = b.n;
>         this.diag = b.diag;
>         this.uplo = b.uplo;
>         if (this.layout() == b.layout()) {
>             this.A = b.A;
>             this.ld = b.ld;
>         }
>         else if (this.layout() == LayoutModified.COL_MAJOR) {
>             this.ld = IMatrixModified.ld(this.m);
298,305c278,285
< 
<             for(j = 0; j < this.n; ++j) {
<                for(i = 0; i < this.m; ++i) {
<                   this.set(i, j, this.get(i, j));
<                }
<             }
<          } else {
<             this.ld = ld(this.n);
---
>             for (int j = 0; j < this.n; ++j) {
>                 for (int i = 0; i < this.m; ++i) {
>                     this.set(i, j, this.get(i, j));
>                 }
>             }
>         }
>         else {
>             this.ld = IMatrixModified.ld(this.n);
307,340c287,362
< 
<             for(j = 0; j < this.m; ++j) {
<                for(i = 0; i < this.n; ++i) {
<                   this.set(j, i, this.get(j, i));
<                }
<             }
<          }
<       }
< 
<       return this;
<    }
< 
<    protected int index(int i, int j) {
<       return j * this.ld + i;
<    }
< 
<    public double get(int i, int j) {
<       return this.A[this.index(i, j)];
<    }
< 
<    public void set(int i, int j, double x) {
<       this.A[this.index(i, j)] = x;
<    }
< 
<    public MatrixModified get(int[] rows, int[] cols) {
<       MatrixModified sub = new MatrixModified(rows.length, cols.length);
< 
<       for(int j = 0; j < cols.length; ++j) {
<          int col = cols[j];
<          if (col < 0) {
<             col += this.n;
<          }
< 
<          for(int i = 0; i < rows.length; ++i) {
---
>             for (int k = 0; k < this.m; ++k) {
>                 for (int l = 0; l < this.n; ++l) {
>                     this.set(k, l, this.get(k, l));
>                 }
>             }
>         }
>         return this;
>     }
>     
>     protected int index(final int i, final int j) {
>         return j * this.ld + i;
>     }
>     
>     @Override
>     public double get(final int i, final int j) {
>         return this.A[this.index(i, j)];
>     }
>     
>     @Override
>     public void set(final int i, final int j, final double x) {
>         this.A[this.index(i, j)] = x;
>     }
>     
>     public MatrixModified get(final int[] rows, final int[] cols) {
>         final MatrixModified sub = new MatrixModified(rows.length, cols.length);
>         for (int j = 0; j < cols.length; ++j) {
>             int col = cols[j];
>             if (col < 0) {
>                 col += this.n;
>             }
>             for (int i = 0; i < rows.length; ++i) {
>                 int row = rows[i];
>                 if (row < 0) {
>                     row += this.m;
>                 }
>                 sub.set(i, j, this.get(row, col));
>             }
>         }
>         return sub;
>     }
>     
>     public double[] row(int i) {
>         final double[] x = new double[this.n];
>         if (i < 0) {
>             i += this.m;
>         }
>         if (this.layout() == LayoutModified.COL_MAJOR) {
>             for (int j = 0; j < this.n; ++j) {
>                 x[j] = this.get(i, j);
>             }
>         }
>         else {
>             System.arraycopy(this.A, this.index(i, 0), x, 0, this.n);
>         }
>         return x;
>     }
>     
>     public double[] col(int j) {
>         final double[] x = new double[this.m];
>         if (j < 0) {
>             j += this.n;
>         }
>         if (this.layout() == LayoutModified.COL_MAJOR) {
>             System.arraycopy(this.A, this.index(0, j), x, 0, this.m);
>         }
>         else {
>             for (int i = 0; i < this.m; ++i) {
>                 x[i] = this.get(i, j);
>             }
>         }
>         return x;
>     }
>     
>     public MatrixModified rows(final int... rows) {
>         final MatrixModified x = new MatrixModified(rows.length, this.n);
>         for (int i = 0; i < rows.length; ++i) {
343c365
<                row += this.m;
---
>                 row += this.m;
345,421c367,921
< 
<             sub.set(i, j, this.get(row, col));
<          }
<       }
< 
<       return sub;
<    }
< 
<    public double[] row(int i) {
<       double[] x = new double[this.n];
<       if (i < 0) {
<          i += this.m;
<       }
< 
<       if (this.layout() == LayoutModified.COL_MAJOR) {
<          for(int j = 0; j < this.n; ++j) {
<             x[j] = this.get(i, j);
<          }
<       } else {
<          System.arraycopy(this.A, this.index(i, 0), x, 0, this.n);
<       }
< 
<       return x;
<    }
< 
<    public double[] col(int j) {
<       double[] x = new double[this.m];
<       if (j < 0) {
<          j += this.n;
<       }
< 
<       if (this.layout() == LayoutModified.COL_MAJOR) {
<          System.arraycopy(this.A, this.index(0, j), x, 0, this.m);
<       } else {
<          for(int i = 0; i < this.m; ++i) {
<             x[i] = this.get(i, j);
<          }
<       }
< 
<       return x;
<    }
< 
<    public MatrixModified rows(int... rows) {
<       MatrixModified x = new MatrixModified(rows.length, this.n);
< 
<       for(int i = 0; i < rows.length; ++i) {
<          int row = rows[i];
<          if (row < 0) {
<             row += this.m;
<          }
< 
<          if (this.layout() == LayoutModified.COL_MAJOR) {
<             for(int j = 0; j < this.n; ++j) {
<                x.set(i, j, this.get(row, j));
<             }
<          } else {
<             System.arraycopy(this.A, this.index(row, 0), x.A, x.index(i, 0), this.n);
<          }
<       }
< 
<       return x;
<    }
< 
<    public MatrixModified cols(int... cols) {
<       MatrixModified x = new MatrixModified(this.m, cols.length);
< 
<       for(int j = 0; j < cols.length; ++j) {
<          int col = cols[j];
<          if (col < 0) {
<             col += this.n;
<          }
< 
<          if (this.layout() == LayoutModified.COL_MAJOR) {
<             System.arraycopy(this.A, this.index(0, col), x.A, x.index(0, j), this.m);
<          } else {
<             for(int i = 0; i < this.m; ++i) {
<                x.set(i, j, this.get(i, col));
---
>             if (this.layout() == LayoutModified.COL_MAJOR) {
>                 for (int j = 0; j < this.n; ++j) {
>                     x.set(i, j, this.get(row, j));
>                 }
>             }
>             else {
>                 System.arraycopy(this.A, this.index(row, 0), x.A, x.index(i, 0), this.n);
>             }
>         }
>         return x;
>     }
>     
>     public MatrixModified cols(final int... cols) {
>         final MatrixModified x = new MatrixModified(this.m, cols.length);
>         for (int j = 0; j < cols.length; ++j) {
>             int col = cols[j];
>             if (col < 0) {
>                 col += this.n;
>             }
>             if (this.layout() == LayoutModified.COL_MAJOR) {
>                 System.arraycopy(this.A, this.index(0, col), x.A, x.index(0, j), this.m);
>             }
>             else {
>                 for (int i = 0; i < this.m; ++i) {
>                     x.set(i, j, this.get(i, col));
>                 }
>             }
>         }
>         return x;
>     }
>     
>     public MatrixModified submatrix(final int i, final int j, final int k, final int l) {
>         if (i < 0 || i >= this.m || k < i || k >= this.m || j < 0 || j >= this.n || l < j || l >= this.n) {
>             throw new IllegalArgumentException(String.format("Invalid submatrix range (%d:%d, %d:%d) of %d x %d", i, k, j, l, this.m, this.n));
>         }
>         final MatrixModified sub = new MatrixModified(k - i + 1, l - j + 1);
>         for (int jj = j; jj <= l; ++jj) {
>             for (int ii = i; ii <= k; ++ii) {
>                 sub.set(ii - i, jj - j, this.get(ii, jj));
>             }
>         }
>         return sub;
>     }
>     
>     public void fill(final double x) {
>         Arrays.fill(this.A, x);
>     }
>     
>     public MatrixModified transpose() {
>         return this.transpose(true);
>     }
>     
>     public MatrixModified transpose(final boolean share) {
>         MatrixModified matrix;
>         if (share) {
>             if (this.layout() == LayoutModified.ROW_MAJOR) {
>                 matrix = new MatrixModified(this.n, this.m, this.ld, this.A);
>             }
>             else {
>                 matrix = new RowMajor(this.n, this.m, this.ld, this.A);
>             }
>         }
>         else {
>             matrix = new MatrixModified(this.n, this.m);
>             for (int j = 0; j < this.m; ++j) {
>                 for (int i = 0; i < this.n; ++i) {
>                     matrix.set(i, j, this.get(j, i));
>                 }
>             }
>         }
>         if (this.m == this.n) {
>             matrix.uplo(this.uplo);
>             matrix.triangular(this.diag);
>         }
>         return matrix;
>     }
>     
>     @Override
>     public boolean equals(final Object o) {
>         return o instanceof MatrixModified && this.equals((MatrixModified)o, 1.0E-10);
>     }
>     
>     public boolean equals(final MatrixModified o, final double epsilon) {
>         if (this.m != o.m || this.n != o.n) {
>             return false;
>         }
>         for (int j = 0; j < this.n; ++j) {
>             for (int i = 0; i < this.m; ++i) {
>                 if (!MathExModified.isZero(this.get(i, j) - o.get(i, j), epsilon)) {
>                     return false;
>                 }
>             }
>         }
>         return true;
>     }
>     
>     public double add(final int i, final int j, final double b) {
>         final double[] a = this.A;
>         final int index = this.index(i, j);
>         return a[index] += b;
>     }
>     
>     public double sub(final int i, final int j, final double b) {
>         final double[] a = this.A;
>         final int index = this.index(i, j);
>         return a[index] -= b;
>     }
>     
>     public double mul(final int i, final int j, final double b) {
>         final double[] a = this.A;
>         final int index = this.index(i, j);
>         return a[index] *= b;
>     }
>     
>     public double div(final int i, final int j, final double b) {
>         final double[] a = this.A;
>         final int index = this.index(i, j);
>         return a[index] /= b;
>     }
>     
>     public MatrixModified addDiag(final double b) {
>         for (int l = Math.min(this.m, this.n), i = 0; i < l; ++i) {
>             final double[] a = this.A;
>             final int index = this.index(i, i);
>             a[index] += b;
>         }
>         return this;
>     }
>     
>     public MatrixModified addDiag(final double[] b) {
>         final int l = Math.min(this.m, this.n);
>         if (b.length != l) {
>             throw new IllegalArgumentException("Invalid diagonal array size: " + b.length);
>         }
>         for (int i = 0; i < l; ++i) {
>             final double[] a = this.A;
>             final int index = this.index(i, i);
>             a[index] += b[i];
>         }
>         return this;
>     }
>     
>     public MatrixModified add(final double b) {
>         for (int i = 0; i < this.A.length; ++i) {
>             final double[] a = this.A;
>             final int n = i;
>             a[n] += b;
>         }
>         return this;
>     }
>     
>     public MatrixModified sub(final double b) {
>         for (int i = 0; i < this.A.length; ++i) {
>             final double[] a = this.A;
>             final int n = i;
>             a[n] -= b;
>         }
>         return this;
>     }
>     
>     public MatrixModified mul(final double b) {
>         for (int i = 0; i < this.A.length; ++i) {
>             final double[] a = this.A;
>             final int n = i;
>             a[n] *= b;
>         }
>         return this;
>     }
>     
>     public MatrixModified div(final double b) {
>         for (int i = 0; i < this.A.length; ++i) {
>             final double[] a = this.A;
>             final int n = i;
>             a[n] /= b;
>         }
>         return this;
>     }
>     
>     public MatrixModified add(final MatrixModified B) {
>         if (this.m != B.m || this.n != B.n) {
>             throw new IllegalArgumentException("Matrix is not of same size.");
>         }
>         if (this.layout() == B.layout() && this.ld == B.ld) {
>             for (int i = 0; i < this.A.length; ++i) {
>                 final double[] a = this.A;
>                 final int n = i;
>                 a[n] += B.A[i];
>             }
>         }
>         else {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int k = 0; k < this.m; ++k) {
>                     this.add(k, j, B.get(k, j));
>                 }
>             }
>         }
>         return this;
>     }
>     
>     public MatrixModified sub(final MatrixModified B) {
>         if (this.m != B.m || this.n != B.n) {
>             throw new IllegalArgumentException("Matrix is not of same size.");
>         }
>         if (this.layout() == B.layout() && this.ld == B.ld) {
>             for (int i = 0; i < this.A.length; ++i) {
>                 final double[] a = this.A;
>                 final int n = i;
>                 a[n] -= B.A[i];
>             }
>         }
>         else {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int k = 0; k < this.m; ++k) {
>                     this.sub(k, j, B.get(k, j));
>                 }
>             }
>         }
>         return this;
>     }
>     
>     public MatrixModified mul(final MatrixModified B) {
>         if (this.m != B.m || this.n != B.n) {
>             throw new IllegalArgumentException("Matrix is not of same size.");
>         }
>         if (this.layout() == B.layout() && this.ld == B.ld) {
>             for (int i = 0; i < this.A.length; ++i) {
>                 final double[] a = this.A;
>                 final int n = i;
>                 a[n] *= B.A[i];
>             }
>         }
>         else {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int k = 0; k < this.m; ++k) {
>                     this.mul(k, j, B.get(k, j));
>                 }
>             }
>         }
>         return this;
>     }
>     
>     public MatrixModified div(final MatrixModified B) {
>         if (this.m != B.m || this.n != B.n) {
>             throw new IllegalArgumentException("Matrix is not of same size.");
>         }
>         if (this.layout() == B.layout() && this.ld == B.ld) {
>             for (int i = 0; i < this.A.length; ++i) {
>                 final double[] a = this.A;
>                 final int n = i;
>                 a[n] /= B.A[i];
>             }
>         }
>         else {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int k = 0; k < this.m; ++k) {
>                     this.div(k, j, B.get(k, j));
>                 }
>             }
>         }
>         return this;
>     }
>     
>     public MatrixModified add(final double beta, final MatrixModified B) {
>         if (this.m != B.m || this.n != B.n) {
>             throw new IllegalArgumentException("Matrix is not of same size.");
>         }
>         if (this.layout() == B.layout() && this.ld == B.ld) {
>             for (int i = 0; i < this.A.length; ++i) {
>                 final double[] a = this.A;
>                 final int n = i;
>                 a[n] += beta * B.A[i];
>             }
>         }
>         else {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int k = 0; k < this.m; ++k) {
>                     this.add(k, j, beta * B.get(k, j));
>                 }
>             }
>         }
>         return this;
>     }
>     
>     public MatrixModified add(final double alpha, final double beta, final MatrixModified B) {
>         if (this.m != B.m || this.n != B.n) {
>             throw new IllegalArgumentException("Matrix B is not of same size.");
>         }
>         if (this.layout() == B.layout() && this.ld == B.ld) {
>             for (int i = 0; i < this.A.length; ++i) {
>                 this.A[i] = alpha * this.A[i] + beta * B.A[i];
>             }
>         }
>         else {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int k = 0; k < this.m; ++k) {
>                     this.set(k, j, alpha * this.get(k, j) + beta * B.get(k, j));
>                 }
>             }
>         }
>         return this;
>     }
>     
>     public MatrixModified add2(final double alpha, final double beta, final MatrixModified B) {
>         if (this.m != B.m || this.n != B.n) {
>             throw new IllegalArgumentException("Matrix B is not of same size.");
>         }
>         if (this.layout() == B.layout() && this.ld == B.ld) {
>             for (int i = 0; i < this.A.length; ++i) {
>                 this.A[i] = alpha * this.A[i] + beta * B.A[i] * B.A[i];
>             }
>         }
>         else {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int k = 0; k < this.m; ++k) {
>                     this.set(k, j, alpha * this.get(k, j) + beta * B.get(k, j) * B.get(k, j));
>                 }
>             }
>         }
>         return this;
>     }
>     
>     public MatrixModified add(final double alpha, final MatrixModified A, final double beta, final MatrixModified B) {
>         if (this.m != A.m || this.n != A.n) {
>             throw new IllegalArgumentException("Matrix A is not of same size.");
>         }
>         if (this.m != B.m || this.n != B.n) {
>             throw new IllegalArgumentException("Matrix B is not of same size.");
>         }
>         if (this.layout() == A.layout() && this.layout() == B.layout() && this.ld == A.ld && this.ld == B.ld) {
>             for (int i = 0; i < this.A.length; ++i) {
>                 this.A[i] = alpha * A.A[i] + beta * B.A[i];
>             }
>         }
>         else {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int k = 0; k < this.m; ++k) {
>                     this.set(k, j, alpha * A.get(k, j) + beta * B.get(k, j));
>                 }
>             }
>         }
>         return this;
>     }
>     
>     public MatrixModified add(final double alpha, final double[] x, final double[] y) {
>         if (this.m != x.length || this.n != y.length) {
>             throw new IllegalArgumentException("Matrix is not of same size.");
>         }
>         if (this.isSymmetric() && x == y) {
>             BLASModified.engine.syr(this.layout(), this.uplo, this.m, alpha, x, 1, this.A, this.ld);
>         }
>         else {
>             BLASModified.engine.ger(this.layout(), this.m, this.n, alpha, x, 1, y, 1, this.A, this.ld);
>         }
>         return this;
>     }
>     
>     public MatrixModified replaceNaN(final double x) {
>         for (int i = 0; i < this.A.length; ++i) {
>             if (Double.isNaN(this.A[i])) {
>                 this.A[i] = x;
>             }
>         }
>         return this;
>     }
>     
>     public double sum() {
>         double s = 0.0;
>         for (int j = 0; j < this.n; ++j) {
>             for (int i = 0; i < this.m; ++i) {
>                 s += this.get(i, j);
>             }
>         }
>         return s;
>     }
>     
>     public double norm1() {
>         double f = 0.0;
>         for (int j = 0; j < this.n; ++j) {
>             double s = 0.0;
>             for (int i = 0; i < this.m; ++i) {
>                 s += Math.abs(this.get(i, j));
>             }
>             f = Math.max(f, s);
>         }
>         return f;
>     }
>     
>     public double norm2() {
>         return this.svd(false, false).s[0];
>     }
>     
>     public double norm() {
>         return this.norm2();
>     }
>     
>     public double normInf() {
>         final double[] f = new double[this.m];
>         for (int j = 0; j < this.n; ++j) {
>             for (int i = 0; i < this.m; ++i) {
>                 final double[] array = f;
>                 final int n = i;
>                 array[n] += Math.abs(this.get(i, j));
>             }
>         }
>         return MathExModified.max(f);
>     }
>     
>     public double normFro() {
>         double f = 0.0;
>         for (int j = 0; j < this.n; ++j) {
>             for (int i = 0; i < this.m; ++i) {
>                 f = Math.hypot(f, this.get(i, j));
>             }
>         }
>         return f;
>     }
>     
>     public double xAx(final double[] x) {
>         if (this.m != this.n) {
>             throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
>         }
>         if (this.n != x.length) {
>             throw new IllegalArgumentException(String.format("Matrix: %d x %d, Vector: %d", this.m, this.n, x.length));
>         }
>         final double[] Ax = this.mv(x);
>         return MathExModified.dot(x, Ax);
>     }
>     
>     public double[] rowSums() {
>         final double[] x = new double[this.m];
>         for (int j = 0; j < this.n; ++j) {
>             for (int i = 0; i < this.m; ++i) {
>                 final double[] array = x;
>                 final int n = i;
>                 array[n] += this.get(i, j);
>             }
>         }
>         return x;
>     }
>     
>     public double[] rowMeans() {
>         final double[] x = this.rowSums();
>         for (int i = 0; i < this.m; ++i) {
>             final double[] array = x;
>             final int n = i;
>             array[n] /= this.n;
>         }
>         return x;
>     }
>     
>     public double[] rowSds() {
>         final double[] x = new double[this.m];
>         final double[] x2 = new double[this.m];
>         for (int j = 0; j < this.n; ++j) {
>             for (int i = 0; i < this.m; ++i) {
>                 final double a = this.get(i, j);
>                 final double[] array = x;
>                 final int n = i;
>                 array[n] += a;
>                 final double[] array2 = x2;
>                 final int n2 = i;
>                 array2[n2] += a * a;
>             }
>         }
>         for (int k = 0; k < this.m; ++k) {
>             final double mu = x[k] / this.n;
>             x[k] = Math.sqrt(x2[k] / this.n - mu * mu);
>         }
>         return x;
>     }
>     
>     public double[] colSums() {
>         final double[] x = new double[this.n];
>         for (int j = 0; j < this.n; ++j) {
>             for (int i = 0; i < this.m; ++i) {
>                 final double[] array = x;
>                 final int n = j;
>                 array[n] += this.get(i, j);
>             }
>         }
>         return x;
>     }
>     
>     public double[] colMeans() {
>         final double[] x = this.colSums();
>         for (int j = 0; j < this.n; ++j) {
>             final double[] array = x;
>             final int n = j;
>             array[n] /= this.m;
>         }
>         return x;
>     }
>     
>     public double[] colSds() {
>         final double[] x = new double[this.n];
>         for (int j = 0; j < this.n; ++j) {
>             double mu = 0.0;
>             double sumsq = 0.0;
>             for (int i = 0; i < this.m; ++i) {
>                 final double a = this.get(i, j);
>                 mu += a;
>                 sumsq += a * a;
>             }
>             mu /= this.m;
>             x[j] = Math.sqrt(sumsq / this.m - mu * mu);
>         }
>         return x;
>     }
>     
>     public MatrixModified standardize() {
>         final double[] center = this.colMeans();
>         final double[] scale = this.colSds();
>         return this.scale(center, scale);
>     }
>     
>     public MatrixModified scale(final double[] center, final double[] scale) {
>         if (center == null && scale == null) {
>             throw new IllegalArgumentException("Both center and scale are null");
>         }
>         final MatrixModified matrix = new MatrixModified(this.m, this.n);
>         if (center == null) {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int i = 0; i < this.m; ++i) {
>                     matrix.set(i, j, this.get(i, j) / scale[j]);
>                 }
>             }
>         }
>         else if (scale == null) {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int i = 0; i < this.m; ++i) {
>                     matrix.set(i, j, this.get(i, j) - center[j]);
>                 }
>             }
>         }
>         else {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int i = 0; i < this.m; ++i) {
>                     matrix.set(i, j, (this.get(i, j) - center[j]) / scale[j]);
>                 }
>             }
>         }
>         return matrix;
>     }
>     
>     public MatrixModified inverse() {
>         if (this.m != this.n) {
>             throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
>         }
>         final MatrixModified lu = this.clone();
>         final MatrixModified inv = eye(this.n);
>         final int[] ipiv = new int[this.n];
>         if (this.isSymmetric()) {
>             final int info = LAPACKModified.engine.sysv(lu.layout(), this.uplo, this.n, this.n, lu.A, lu.ld, ipiv, inv.A, inv.ld);
>             if (info != 0) {
>                 throw new ArithmeticException("SYSV fails: " + info);
423,435c923,927
<          }
<       }
< 
<       return x;
<    }
< 
<    public MatrixModified submatrix(int i, int j, int k, int l) {
<       if (i >= 0 && i < this.m && k >= i && k < this.m && j >= 0 && j < this.n && l >= j && l < this.n) {
<          MatrixModified sub = new MatrixModified(k - i + 1, l - j + 1);
< 
<          for(int jj = j; jj <= l; ++jj) {
<             for(int ii = i; ii <= k; ++ii) {
<                sub.set(ii - i, jj - j, this.get(ii, jj));
---
>         }
>         else {
>             final int info = LAPACKModified.engine.gesv(lu.layout(), this.n, this.n, lu.A, lu.ld, ipiv, inv.A, inv.ld);
>             if (info != 0) {
>                 throw new ArithmeticException("GESV fails: " + info);
437,466c929,1151
<          }
< 
<          return sub;
<       } else {
<          throw new IllegalArgumentException(String.format("Invalid submatrix range (%d:%d, %d:%d) of %d x %d", i, k, j, l, this.m, this.n));
<       }
<    }
< 
<    public void fill(double x) {
<       Arrays.fill(this.A, x);
<    }
< 
<    public MatrixModified transpose() {
<       return this.transpose(true);
<    }
< 
<    public MatrixModified transpose(boolean share) {
<       Object matrix;
<       if (share) {
<          if (this.layout() == LayoutModified.ROW_MAJOR) {
<             matrix = new MatrixModified(this.n, this.m, this.ld, this.A);
<          } else {
<             matrix = new MatrixModified.RowMajor(this.n, this.m, this.ld, this.A);
<          }
<       } else {
<          matrix = new MatrixModified(this.n, this.m);
< 
<          for(int j = 0; j < this.m; ++j) {
<             for(int i = 0; i < this.n; ++i) {
<                ((MatrixModified)matrix).set(i, j, this.get(j, i));
---
>         }
>         return inv;
>     }
>     
>     private void mv(final TransposeModified trans, final double alpha, final DoubleBuffer x, final double beta, final DoubleBuffer y) {
>         final DoubleBuffer A = DoubleBuffer.wrap(this.A);
>         if (this.uplo != null) {
>             if (this.diag != null) {
>                 if (alpha == 1.0 && beta == 0.0 && x == y) {
>                     BLASModified.engine.trmv(this.layout(), this.uplo, trans, this.diag, this.m, A, this.ld, y, 1);
>                 }
>                 else {
>                     BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, A, this.ld, x, 1, beta, y, 1);
>                 }
>             }
>             else {
>                 BLASModified.engine.symv(this.layout(), this.uplo, this.m, alpha, A, this.ld, x, 1, beta, y, 1);
>             }
>         }
>         else {
>             BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, A, this.ld, x, 1, beta, y, 1);
>         }
>     }
>     
>     @Override
>     public void mv(final TransposeModified trans, final double alpha, final double[] x, final double beta, final double[] y) {
>         if (this.uplo != null) {
>             if (this.diag != null) {
>                 if (alpha == 1.0 && beta == 0.0 && x == y) {
>                     BLASModified.engine.trmv(this.layout(), this.uplo, trans, this.diag, this.m, this.A, this.ld, y, 1);
>                 }
>                 else {
>                     BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, this.A, this.ld, x, 1, beta, y, 1);
>                 }
>             }
>             else {
>                 BLASModified.engine.symv(this.layout(), this.uplo, this.m, alpha, this.A, this.ld, x, 1, beta, y, 1);
>             }
>         }
>         else {
>             BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, this.A, this.ld, x, 1, beta, y, 1);
>         }
>     }
>     
>     @Override
>     public void mv(final double[] work, final int inputOffset, final int outputOffset) {
>         final DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.n);
>         final DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.m);
>         this.mv(TransposeModified.NO_TRANSPOSE, 1.0, xb, 0.0, yb);
>     }
>     
>     @Override
>     public void tv(final double[] work, final int inputOffset, final int outputOffset) {
>         final DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.m);
>         final DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.n);
>         this.mv(TransposeModified.TRANSPOSE, 1.0, xb, 0.0, yb);
>     }
>     
>     public MatrixModified mm(final TransposeModified transA, final MatrixModified A, final TransposeModified transB, final MatrixModified B) {
>         return this.mm(transA, A, transB, B, 1.0, 0.0);
>     }
>     
>     public MatrixModified mm(TransposeModified transA, MatrixModified A, TransposeModified transB, MatrixModified B, final double alpha, final double beta) {
>         if (A.isSymmetric() && transB == TransposeModified.NO_TRANSPOSE && B.layout() == this.layout()) {
>             BLASModified.engine.symm(this.layout(), SideModified.LEFT, A.uplo, this.m, this.n, alpha, A.A, A.ld, B.A, B.ld, beta, this.A, this.ld);
>         }
>         else if (B.isSymmetric() && transA == TransposeModified.NO_TRANSPOSE && A.layout() == this.layout()) {
>             BLASModified.engine.symm(this.layout(), SideModified.RIGHT, B.uplo, this.m, this.n, alpha, B.A, B.ld, A.A, A.ld, beta, this.A, this.ld);
>         }
>         else {
>             if (this.layout() != A.layout()) {
>                 transA = IMatrixModified.flip(transA);
>                 A = A.transpose();
>             }
>             if (this.layout() != B.layout()) {
>                 transB = IMatrixModified.flip(transB);
>                 B = B.transpose();
>             }
>             final int k = (transA == TransposeModified.NO_TRANSPOSE) ? A.n : A.m;
>             BLASModified.engine.gemm(this.layout(), transA, transB, this.m, this.n, k, alpha, A.A, A.ld, B.A, B.ld, beta, this.A, this.ld);
>         }
>         return this;
>     }
>     
>     public MatrixModified ata() {
>         final MatrixModified C = new MatrixModified(this.n, this.n);
>         C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, this);
>         C.uplo(UPLOModified.LOWER);
>         return C;
>     }
>     
>     public MatrixModified aat() {
>         final MatrixModified C = new MatrixModified(this.m, this.m);
>         C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.TRANSPOSE, this);
>         C.uplo(UPLOModified.LOWER);
>         return C;
>     }
>     
>     public static MatrixModified adb(final TransposeModified transA, final MatrixModified A, final double[] D, final TransposeModified transB, final MatrixModified B) {
>         final int m = A.m;
>         final int n = A.n;
>         MatrixModified AD;
>         if (transA == TransposeModified.NO_TRANSPOSE) {
>             AD = new MatrixModified(m, n);
>             for (int j = 0; j < n; ++j) {
>                 final double dj = D[j];
>                 for (int i = 0; i < m; ++i) {
>                     AD.set(i, j, dj * A.get(i, j));
>                 }
>             }
>         }
>         else {
>             AD = new MatrixModified(n, m);
>             for (int j = 0; j < m; ++j) {
>                 final double dj = D[j];
>                 for (int i = 0; i < n; ++i) {
>                     AD.set(i, j, dj * A.get(j, i));
>                 }
>             }
>         }
>         return (transB == TransposeModified.NO_TRANSPOSE) ? AD.mm(B) : AD.mt(B);
>     }
>     
>     public MatrixModified mm(final MatrixModified B) {
>         if (this.n != B.m) {
>             throw new IllegalArgumentException(String.format("Matrix multiplication A * B: %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
>         }
>         final MatrixModified C = new MatrixModified(this.m, B.n);
>         C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, B);
>         return C;
>     }
>     
>     public MatrixModified mt(final MatrixModified B) {
>         if (this.n != B.n) {
>             throw new IllegalArgumentException(String.format("Matrix multiplication A * B': %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
>         }
>         final MatrixModified C = new MatrixModified(this.m, B.m);
>         C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.TRANSPOSE, B);
>         return C;
>     }
>     
>     public MatrixModified tm(final MatrixModified B) {
>         if (this.m != B.m) {
>             throw new IllegalArgumentException(String.format("Matrix multiplication A' * B: %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
>         }
>         final MatrixModified C = new MatrixModified(this.n, B.n);
>         C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, B);
>         return C;
>     }
>     
>     public MatrixModified tt(final MatrixModified B) {
>         if (this.m != B.n) {
>             throw new IllegalArgumentException(String.format("Matrix multiplication A' * B': %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
>         }
>         final MatrixModified C = new MatrixModified(this.n, B.m);
>         C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.TRANSPOSE, B);
>         return C;
>     }
>     
>     public LU lu() {
>         return this.lu(false);
>     }
>     
>     public LU lu(final boolean overwrite) {
>         final MatrixModified lu = overwrite ? this : this.clone();
>         final int[] ipiv = new int[Math.min(this.m, this.n)];
>         final int info = LAPACKModified.engine.getrf(lu.layout(), lu.m, lu.n, lu.A, lu.ld, ipiv);
>         if (info < 0) {
>             MatrixModified.logger.error("LAPACK GETRF error code: {}", (Object)info);
>             throw new ArithmeticException("LAPACK GETRF error code: " + info);
>         }
>         lu.uplo = null;
>         return new LU(lu, ipiv, info);
>     }
>     
>     public Cholesky cholesky() {
>         return this.cholesky(false);
>     }
>     
>     public Cholesky cholesky(final boolean overwrite) {
>         if (this.uplo == null) {
>             throw new IllegalArgumentException("The matrix is not symmetric");
>         }
>         final MatrixModified lu = overwrite ? this : this.clone();
>         final int info = LAPACKModified.engine.potrf(lu.layout(), lu.uplo, lu.n, lu.A, lu.ld);
>         if (info != 0) {
>             MatrixModified.logger.error("LAPACK GETRF error code: {}", (Object)info);
>             throw new ArithmeticException("LAPACK GETRF error code: " + info);
>         }
>         return new Cholesky(lu);
>     }
>     
>     public QR qr() {
>         return this.qr(false);
>     }
>     
>     public QR qr(final boolean overwrite) {
>         final MatrixModified qr = overwrite ? this : this.clone();
>         final double[] tau = new double[Math.min(this.m, this.n)];
>         final int info = LAPACKModified.engine.geqrf(qr.layout(), qr.m, qr.n, qr.A, qr.ld, tau);
>         if (info != 0) {
>             MatrixModified.logger.error("LAPACK GEQRF error code: {}", (Object)info);
>             throw new ArithmeticException("LAPACK GEQRF error code: " + info);
>         }
>         qr.uplo = null;
>         return new QR(qr, tau);
>     }
>     
>     public SVD svd() {
>         return this.svd(true, false);
>     }
>     
>     public SVD svd(final boolean vectors, final boolean overwrite) {
>         final int k = Math.min(this.m, this.n);
>         final double[] s = new double[k];
>         final MatrixModified W = overwrite ? this : this.clone();
>         if (vectors) {
>             final MatrixModified U = new MatrixModified(this.m, k);
>             final MatrixModified VT = new MatrixModified(k, this.n);
>             final int info = LAPACKModified.engine.gesdd(W.layout(), SVDJobModified.COMPACT, W.m, W.n, W.A, W.ld, s, U.A, U.ld, VT.A, VT.ld);
>             if (info != 0) {
>                 MatrixModified.logger.error("LAPACK GESDD error code: {}", (Object)info);
>                 throw new ArithmeticException("LAPACK GESDD error code: " + info);
468,489c1153,1161
<          }
<       }
< 
<       if (this.m == this.n) {
<          ((MatrixModified)matrix).uplo(this.uplo);
<          ((MatrixModified)matrix).triangular(this.diag);
<       }
< 
<       return (MatrixModified)matrix;
<    }
< 
<    public boolean equals(Object o) {
<       return !(o instanceof MatrixModified) ? false : this.equals((MatrixModified)o, 1.0E-10D);
<    }
< 
<    public boolean equals(MatrixModified o, double epsilon) {
<       if (this.m == o.m && this.n == o.n) {
<          for(int j = 0; j < this.n; ++j) {
<             for(int i = 0; i < this.m; ++i) {
<                if (!MathExModified.isZero(this.get(i, j) - o.get(i, j), epsilon)) {
<                   return false;
<                }
---
>             return new SVD(s, U, VT.transpose());
>         }
>         else {
>             final MatrixModified U = new MatrixModified(1, 1);
>             final MatrixModified VT = new MatrixModified(1, 1);
>             final int info = LAPACKModified.engine.gesdd(W.layout(), SVDJobModified.NO_VECTORS, W.m, W.n, W.A, W.ld, s, U.A, U.ld, VT.A, VT.ld);
>             if (info != 0) {
>                 MatrixModified.logger.error("LAPACK GESDD error code: {}", (Object)info);
>                 throw new ArithmeticException("LAPACK GESDD error code: " + info);
491,598c1163,1181
<          }
< 
<          return true;
<       } else {
<          return false;
<       }
<    }
< 
<    public double add(int i, int j, double b) {
<       double[] var10000 = this.A;
<       int var10001 = this.index(i, j);
<       return var10000[var10001] += b;
<    }
< 
<    public double sub(int i, int j, double b) {
<       double[] var10000 = this.A;
<       int var10001 = this.index(i, j);
<       return var10000[var10001] -= b;
<    }
< 
<    public double mul(int i, int j, double b) {
<       double[] var10000 = this.A;
<       int var10001 = this.index(i, j);
<       return var10000[var10001] *= b;
<    }
< 
<    public double div(int i, int j, double b) {
<       double[] var10000 = this.A;
<       int var10001 = this.index(i, j);
<       return var10000[var10001] /= b;
<    }
< 
<    public MatrixModified addDiag(double b) {
<       int l = Math.min(this.m, this.n);
< 
<       for(int i = 0; i < l; ++i) {
<          double[] var10000 = this.A;
<          int var10001 = this.index(i, i);
<          var10000[var10001] += b;
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified addDiag(double[] b) {
<       int l = Math.min(this.m, this.n);
<       if (b.length != l) {
<          throw new IllegalArgumentException("Invalid diagonal array size: " + b.length);
<       } else {
<          for(int i = 0; i < l; ++i) {
<             double[] var10000 = this.A;
<             int var10001 = this.index(i, i);
<             var10000[var10001] += b[i];
<          }
< 
<          return this;
<       }
<    }
< 
<    public MatrixModified add(double b) {
<       for(int i = 0; i < this.A.length; ++i) {
<          double[] var10000 = this.A;
<          var10000[i] += b;
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified sub(double b) {
<       for(int i = 0; i < this.A.length; ++i) {
<          double[] var10000 = this.A;
<          var10000[i] -= b;
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified mul(double b) {
<       for(int i = 0; i < this.A.length; ++i) {
<          double[] var10000 = this.A;
<          var10000[i] *= b;
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified div(double b) {
<       for(int i = 0; i < this.A.length; ++i) {
<          double[] var10000 = this.A;
<          var10000[i] /= b;
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified add(MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                double[] var10000 = this.A;
<                var10000[j] += B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.add(i, j, B.get(i, j));
<                }
---
>             return new SVD(this.m, this.n, s);
>         }
>     }
>     
>     public EVD eigen() {
>         return this.eigen(false, true, false);
>     }
>     
>     public EVD eigen(final boolean vl, final boolean vr, final boolean overwrite) {
>         if (this.m != this.n) {
>             throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
>         }
>         final MatrixModified eig = overwrite ? this : this.clone();
>         if (this.isSymmetric()) {
>             final double[] w = new double[this.n];
>             final int info = LAPACKModified.engine.syevd(eig.layout(), vr ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, eig.uplo, this.n, eig.A, eig.ld, w);
>             if (info != 0) {
>                 MatrixModified.logger.error("LAPACK SYEV error code: {}", (Object)info);
>                 throw new ArithmeticException("LAPACK SYEV error code: " + info);
600,620c1183,1261
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified sub(MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                double[] var10000 = this.A;
<                var10000[j] -= B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.sub(i, j, B.get(i, j));
<                }
---
>             eig.uplo = null;
>             return new EVD(w, vr ? eig : null);
>         }
>         else {
>             final double[] wr = new double[this.n];
>             final double[] wi = new double[this.n];
>             final MatrixModified Vl = vl ? new MatrixModified(this.n, this.n) : new MatrixModified(1, 1);
>             final MatrixModified Vr = vr ? new MatrixModified(this.n, this.n) : new MatrixModified(1, 1);
>             final int info2 = LAPACKModified.engine.geev(eig.layout(), vl ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, vr ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, this.n, eig.A, eig.ld, wr, wi, Vl.A, Vl.ld, Vr.A, Vr.ld);
>             if (info2 != 0) {
>                 MatrixModified.logger.error("LAPACK GEEV error code: {}", (Object)info2);
>                 throw new ArithmeticException("LAPACK GEEV error code: " + info2);
>             }
>             return new EVD(wr, wi, vl ? Vl : null, vr ? Vr : null);
>         }
>     }
>     
>     private static class RowMajor extends MatrixModified
>     {
>         RowMajor(final int m, final int n, final int ld, final double[] A) {
>             super(m, n, ld, A);
>         }
>         
>         @Override
>         public LayoutModified layout() {
>             return LayoutModified.ROW_MAJOR;
>         }
>         
>         @Override
>         protected int index(final int i, final int j) {
>             return i * this.ld + j;
>         }
>     }
>     
>     public static class SVD implements Serializable
>     {
>         private static final long serialVersionUID = 2L;
>         public final int m;
>         public final int n;
>         public final double[] s;
>         public final MatrixModified U;
>         public final MatrixModified V;
>         private transient MatrixModified Ur;
>         
>         public SVD(final int m, final int n, final double[] s) {
>             this.m = m;
>             this.n = n;
>             this.s = s;
>             this.U = null;
>             this.V = null;
>         }
>         
>         public SVD(final double[] s, final MatrixModified U, final MatrixModified V) {
>             this.m = U.m;
>             this.n = V.m;
>             this.s = s;
>             this.U = U;
>             this.V = V;
>         }
>         
>         public MatrixModified diag() {
>             final MatrixModified S = new MatrixModified(this.U.m, this.V.m);
>             for (int i = 0; i < this.s.length; ++i) {
>                 S.set(i, i, this.s[i]);
>             }
>             return S;
>         }
>         
>         public double norm() {
>             return this.s[0];
>         }
>         
>         private double rcond() {
>             return 0.5 * Math.sqrt(this.m + this.n + 1) * this.s[0] * MathExModified.EPSILON;
>         }
>         
>         public int rank() {
>             if (this.s.length != Math.min(this.m, this.n)) {
>                 throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
622,642c1263,1270
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified mul(MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                double[] var10000 = this.A;
<                var10000[j] *= B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.mul(i, j, B.get(i, j));
<                }
---
>             int r = 0;
>             final double tol = this.rcond();
>             double[] s;
>             for (int length = (s = this.s).length, i = 0; i < length; ++i) {
>                 final double si = s[i];
>                 if (si > tol) {
>                     ++r;
>                 }
644,664c1272,1288
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified div(MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                double[] var10000 = this.A;
<                var10000[j] /= B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.div(i, j, B.get(i, j));
<                }
---
>             return r;
>         }
>         
>         public int nullity() {
>             return Math.min(this.m, this.n) - this.rank();
>         }
>         
>         public double condition() {
>             if (this.s.length != Math.min(this.m, this.n)) {
>                 throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
>             }
>             return (this.s[0] <= 0.0 || this.s[this.s.length - 1] <= 0.0) ? Double.POSITIVE_INFINITY : (this.s[0] / this.s[this.s.length - 1]);
>         }
>         
>         public MatrixModified range() {
>             if (this.s.length != Math.min(this.m, this.n)) {
>                 throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
666,686c1290,1291
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified add(double beta, MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                double[] var10000 = this.A;
<                var10000[j] += beta * B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.add(i, j, beta * B.get(i, j));
<                }
---
>             if (this.U == null) {
>                 throw new IllegalStateException("The left singular vectors are not available.");
688,707c1293,1295
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified add(double alpha, double beta, MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                this.A[j] = alpha * this.A[j] + beta * B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.set(i, j, alpha * this.get(i, j) + beta * B.get(i, j));
<                }
---
>             final int r = this.rank();
>             if (r == 0) {
>                 return null;
709,728c1297,1308
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix B is not of same size.");
<       }
<    }
< 
<    public MatrixModified add2(double alpha, double beta, MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                this.A[j] = alpha * this.A[j] + beta * B.A[j] * B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.set(i, j, alpha * this.get(i, j) + beta * B.get(i, j) * B.get(i, j));
<                }
---
>             final MatrixModified R = new MatrixModified(this.m, r);
>             for (int j = 0; j < r; ++j) {
>                 for (int i = 0; i < this.m; ++i) {
>                     R.set(i, j, this.U.get(i, j));
>                 }
>             }
>             return R;
>         }
>         
>         public MatrixModified nullspace() {
>             if (this.s.length != Math.min(this.m, this.n)) {
>                 throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
730,751c1310,1311
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix B is not of same size.");
<       }
<    }
< 
<    public MatrixModified add(double alpha, MatrixModified A, double beta, MatrixModified B) {
<       if (this.m == A.m && this.n == A.n) {
<          if (this.m == B.m && this.n == B.n) {
<             int j;
<             if (this.layout() == A.layout() && this.layout() == B.layout() && this.ld == A.ld && this.ld == B.ld) {
<                for(j = 0; j < this.A.length; ++j) {
<                   this.A[j] = alpha * A.A[j] + beta * B.A[j];
<                }
<             } else {
<                for(j = 0; j < this.n; ++j) {
<                   for(int i = 0; i < this.m; ++i) {
<                      this.set(i, j, alpha * A.get(i, j) + beta * B.get(i, j));
<                   }
<                }
---
>             if (this.V == null) {
>                 throw new IllegalStateException("The right singular vectors are not available.");
753,996c1313,1315
< 
<             return this;
<          } else {
<             throw new IllegalArgumentException("Matrix B is not of same size.");
<          }
<       } else {
<          throw new IllegalArgumentException("Matrix A is not of same size.");
<       }
<    }
< 
<    public MatrixModified add(double alpha, double[] x, double[] y) {
<       if (this.m == x.length && this.n == y.length) {
<          if (this.isSymmetric() && x == y) {
<             BLASModified.engine.syr(this.layout(), this.uplo, this.m, alpha, (double[])x, 1, (double[])this.A, this.ld);
<          } else {
<             BLASModified.engine.ger(this.layout(), this.m, this.n, alpha, (double[])x, 1, (double[])y, 1, (double[])this.A, this.ld);
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified replaceNaN(double x) {
<       for(int i = 0; i < this.A.length; ++i) {
<          if (Double.isNaN(this.A[i])) {
<             this.A[i] = x;
<          }
<       }
< 
<       return this;
<    }
< 
<    public double sum() {
<       double s = 0.0D;
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = 0; i < this.m; ++i) {
<             s += this.get(i, j);
<          }
<       }
< 
<       return s;
<    }
< 
<    public double norm1() {
<       double f = 0.0D;
< 
<       for(int j = 0; j < this.n; ++j) {
<          double s = 0.0D;
< 
<          for(int i = 0; i < this.m; ++i) {
<             s += Math.abs(this.get(i, j));
<          }
< 
<          f = Math.max(f, s);
<       }
< 
<       return f;
<    }
< 
<    public double norm2() {
<       return this.svd(false, false).s[0];
<    }
< 
<    public double norm() {
<       return this.norm2();
<    }
< 
<    public double normInf() {
<       double[] f = new double[this.m];
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = 0; i < this.m; ++i) {
<             f[i] += Math.abs(this.get(i, j));
<          }
<       }
< 
<       return MathExModified.max(f);
<    }
< 
<    public double normFro() {
<       double f = 0.0D;
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = 0; i < this.m; ++i) {
<             f = Math.hypot(f, this.get(i, j));
<          }
<       }
< 
<       return f;
<    }
< 
<    public double xAx(double[] x) {
<       if (this.m != this.n) {
<          throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
<       } else if (this.n != x.length) {
<          throw new IllegalArgumentException(String.format("Matrix: %d x %d, Vector: %d", this.m, this.n, x.length));
<       } else {
<          double[] Ax = this.mv(x);
<          return MathExModified.dot(x, Ax);
<       }
<    }
< 
<    public double[] rowSums() {
<       double[] x = new double[this.m];
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = 0; i < this.m; ++i) {
<             x[i] += this.get(i, j);
<          }
<       }
< 
<       return x;
<    }
< 
<    public double[] rowMeans() {
<       double[] x = this.rowSums();
< 
<       for(int i = 0; i < this.m; ++i) {
<          x[i] /= (double)this.n;
<       }
< 
<       return x;
<    }
< 
<    public double[] rowSds() {
<       double[] x = new double[this.m];
<       double[] x2 = new double[this.m];
< 
<       int i;
<       for(i = 0; i < this.n; ++i) {
<          for(int i = 0; i < this.m; ++i) {
<             double a = this.get(i, i);
<             x[i] += a;
<             x2[i] += a * a;
<          }
<       }
< 
<       for(i = 0; i < this.m; ++i) {
<          double mu = x[i] / (double)this.n;
<          x[i] = Math.sqrt(x2[i] / (double)this.n - mu * mu);
<       }
< 
<       return x;
<    }
< 
<    public double[] colSums() {
<       double[] x = new double[this.n];
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = 0; i < this.m; ++i) {
<             x[j] += this.get(i, j);
<          }
<       }
< 
<       return x;
<    }
< 
<    public double[] colMeans() {
<       double[] x = this.colSums();
< 
<       for(int j = 0; j < this.n; ++j) {
<          x[j] /= (double)this.m;
<       }
< 
<       return x;
<    }
< 
<    public double[] colSds() {
<       double[] x = new double[this.n];
< 
<       for(int j = 0; j < this.n; ++j) {
<          double mu = 0.0D;
<          double sumsq = 0.0D;
< 
<          for(int i = 0; i < this.m; ++i) {
<             double a = this.get(i, j);
<             mu += a;
<             sumsq += a * a;
<          }
< 
<          mu /= (double)this.m;
<          x[j] = Math.sqrt(sumsq / (double)this.m - mu * mu);
<       }
< 
<       return x;
<    }
< 
<    public MatrixModified standardize() {
<       double[] center = this.colMeans();
<       double[] scale = this.colSds();
<       return this.scale(center, scale);
<    }
< 
<    public MatrixModified scale(double[] center, double[] scale) {
<       if (center == null && scale == null) {
<          throw new IllegalArgumentException("Both center and scale are null");
<       } else {
<          MatrixModified matrix = new MatrixModified(this.m, this.n);
<          int j;
<          int i;
<          if (center == null) {
<             for(j = 0; j < this.n; ++j) {
<                for(i = 0; i < this.m; ++i) {
<                   matrix.set(i, j, this.get(i, j) / scale[j]);
<                }
<             }
<          } else if (scale == null) {
<             for(j = 0; j < this.n; ++j) {
<                for(i = 0; i < this.m; ++i) {
<                   matrix.set(i, j, this.get(i, j) - center[j]);
<                }
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(i = 0; i < this.m; ++i) {
<                   matrix.set(i, j, (this.get(i, j) - center[j]) / scale[j]);
<                }
<             }
<          }
< 
<          return matrix;
<       }
<    }
< 
<    public MatrixModified inverse() {
<       if (this.m != this.n) {
<          throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
<       } else {
<          MatrixModified lu = this.clone();
<          MatrixModified inv = eye(this.n);
<          int[] ipiv = new int[this.n];
<          int info;
<          if (this.isSymmetric()) {
<             info = LAPACKModified.engine.sysv(lu.layout(), this.uplo, this.n, this.n, lu.A, lu.ld, ipiv, inv.A, inv.ld);
<             if (info != 0) {
<                throw new ArithmeticException("SYSV fails: " + info);
<             }
<          } else {
<             info = LAPACKModified.engine.gesv(lu.layout(), this.n, this.n, lu.A, lu.ld, ipiv, inv.A, inv.ld);
<             if (info != 0) {
<                throw new ArithmeticException("GESV fails: " + info);
---
>             final int nr = this.nullity();
>             if (nr == 0) {
>                 return null;
998,1106c1317,1337
<          }
< 
<          return inv;
<       }
<    }
< 
<    private void mv(TransposeModified trans, double alpha, DoubleBuffer x, double beta, DoubleBuffer y) {
<       DoubleBuffer A = DoubleBuffer.wrap(this.A);
<       if (this.uplo != null) {
<          if (this.diag != null) {
<             if (alpha == 1.0D && beta == 0.0D && x == y) {
<                BLASModified.engine.trmv(this.layout(), this.uplo, trans, this.diag, this.m, (DoubleBuffer)A, this.ld, (DoubleBuffer)y, 1);
<             } else {
<                BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, (DoubleBuffer)A, this.ld, (DoubleBuffer)x, 1, beta, (DoubleBuffer)y, 1);
<             }
<          } else {
<             BLASModified.engine.symv(this.layout(), this.uplo, this.m, alpha, (DoubleBuffer)A, this.ld, (DoubleBuffer)x, 1, beta, (DoubleBuffer)y, 1);
<          }
<       } else {
<          BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, (DoubleBuffer)A, this.ld, (DoubleBuffer)x, 1, beta, (DoubleBuffer)y, 1);
<       }
< 
<    }
< 
<    public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
<       if (this.uplo != null) {
<          if (this.diag != null) {
<             if (alpha == 1.0D && beta == 0.0D && x == y) {
<                BLASModified.engine.trmv(this.layout(), this.uplo, trans, this.diag, this.m, (double[])this.A, this.ld, (double[])y, 1);
<             } else {
<                BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, (double[])this.A, this.ld, (double[])x, 1, beta, (double[])y, 1);
<             }
<          } else {
<             BLASModified.engine.symv(this.layout(), this.uplo, this.m, alpha, (double[])this.A, this.ld, (double[])x, 1, beta, (double[])y, 1);
<          }
<       } else {
<          BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, (double[])this.A, this.ld, (double[])x, 1, beta, (double[])y, 1);
<       }
< 
<    }
< 
<    public void mv(double[] work, int inputOffset, int outputOffset) {
<       DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.n);
<       DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.m);
<       this.mv(TransposeModified.NO_TRANSPOSE, 1.0D, xb, 0.0D, yb);
<    }
< 
<    public void tv(double[] work, int inputOffset, int outputOffset) {
<       DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.m);
<       DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.n);
<       this.mv(TransposeModified.TRANSPOSE, 1.0D, xb, 0.0D, yb);
<    }
< 
<    public MatrixModified mm(TransposeModified transA, MatrixModified A, TransposeModified transB, MatrixModified B) {
<       return this.mm(transA, A, transB, B, 1.0D, 0.0D);
<    }
< 
<    public MatrixModified mm(TransposeModified transA, MatrixModified A, TransposeModified transB, MatrixModified B, double alpha, double beta) {
<       if (A.isSymmetric() && transB == TransposeModified.NO_TRANSPOSE && B.layout() == this.layout()) {
<          BLASModified.engine.symm(this.layout(), SideModified.LEFT, A.uplo, this.m, this.n, alpha, A.A, A.ld, B.A, B.ld, beta, this.A, this.ld);
<       } else if (B.isSymmetric() && transA == TransposeModified.NO_TRANSPOSE && A.layout() == this.layout()) {
<          BLASModified.engine.symm(this.layout(), SideModified.RIGHT, B.uplo, this.m, this.n, alpha, B.A, B.ld, A.A, A.ld, beta, this.A, this.ld);
<       } else {
<          if (this.layout() != A.layout()) {
<             transA = flip(transA);
<             A = A.transpose();
<          }
< 
<          if (this.layout() != B.layout()) {
<             transB = flip(transB);
<             B = B.transpose();
<          }
< 
<          int k = transA == TransposeModified.NO_TRANSPOSE ? A.n : A.m;
<          BLASModified.engine.gemm(this.layout(), transA, transB, this.m, this.n, k, alpha, A.A, A.ld, B.A, B.ld, beta, this.A, this.ld);
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified ata() {
<       MatrixModified C = new MatrixModified(this.n, this.n);
<       C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, this);
<       C.uplo(UPLOModified.LOWER);
<       return C;
<    }
< 
<    public MatrixModified aat() {
<       MatrixModified C = new MatrixModified(this.m, this.m);
<       C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.TRANSPOSE, this);
<       C.uplo(UPLOModified.LOWER);
<       return C;
<    }
< 
<    public static MatrixModified adb(TransposeModified transA, MatrixModified A, double[] D, TransposeModified transB, MatrixModified B) {
<       int m = A.m;
<       int n = A.n;
<       MatrixModified AD;
<       int j;
<       double dj;
<       int i;
<       if (transA == TransposeModified.NO_TRANSPOSE) {
<          AD = new MatrixModified(m, n);
< 
<          for(j = 0; j < n; ++j) {
<             dj = D[j];
< 
<             for(i = 0; i < m; ++i) {
<                AD.set(i, j, dj * A.get(i, j));
---
>             final MatrixModified N = new MatrixModified(this.n, nr);
>             for (int j = 0; j < nr; ++j) {
>                 for (int i = 0; i < this.n; ++i) {
>                     N.set(i, j, this.V.get(i, this.n - j - 1));
>                 }
>             }
>             return N;
>         }
>         
>         public MatrixModified pinv() {
>             final int k = this.s.length;
>             final double[] sigma = new double[k];
>             for (int r = this.rank(), i = 0; i < r; ++i) {
>                 sigma[i] = 1.0 / this.s[i];
>             }
>             return MatrixModified.adb(TransposeModified.NO_TRANSPOSE, this.V, sigma, TransposeModified.TRANSPOSE, this.U);
>         }
>         
>         public double[] solve(final double[] b) {
>             if (this.U == null || this.V == null) {
>                 throw new IllegalStateException("The singular vectors are not available.");
1108,1116c1339,1340
<          }
<       } else {
<          AD = new MatrixModified(n, m);
< 
<          for(j = 0; j < m; ++j) {
<             dj = D[j];
< 
<             for(i = 0; i < n; ++i) {
<                AD.set(i, j, dj * A.get(j, i));
---
>             if (b.length != this.m) {
>                 throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x 1", this.m, this.n, b.length));
1118,1294c1342,1450
<          }
<       }
< 
<       return transB == TransposeModified.NO_TRANSPOSE ? AD.mm(B) : AD.mt(B);
<    }
< 
<    public MatrixModified mm(MatrixModified B) {
<       if (this.n != B.m) {
<          throw new IllegalArgumentException(String.format("Matrix multiplication A * B: %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
<       } else {
<          MatrixModified C = new MatrixModified(this.m, B.n);
<          C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, B);
<          return C;
<       }
<    }
< 
<    public MatrixModified mt(MatrixModified B) {
<       if (this.n != B.n) {
<          throw new IllegalArgumentException(String.format("Matrix multiplication A * B': %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
<       } else {
<          MatrixModified C = new MatrixModified(this.m, B.m);
<          C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.TRANSPOSE, B);
<          return C;
<       }
<    }
< 
<    public MatrixModified tm(MatrixModified B) {
<       if (this.m != B.m) {
<          throw new IllegalArgumentException(String.format("Matrix multiplication A' * B: %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
<       } else {
<          MatrixModified C = new MatrixModified(this.n, B.n);
<          C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, B);
<          return C;
<       }
<    }
< 
<    public MatrixModified tt(MatrixModified B) {
<       if (this.m != B.n) {
<          throw new IllegalArgumentException(String.format("Matrix multiplication A' * B': %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
<       } else {
<          MatrixModified C = new MatrixModified(this.n, B.m);
<          C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.TRANSPOSE, B);
<          return C;
<       }
<    }
< 
<    public MatrixModified.LU lu() {
<       return this.lu(false);
<    }
< 
<    public MatrixModified.LU lu(boolean overwrite) {
<       MatrixModified lu = overwrite ? this : this.clone();
<       int[] ipiv = new int[Math.min(this.m, this.n)];
<       int info = LAPACKModified.engine.getrf(lu.layout(), lu.m, lu.n, lu.A, lu.ld, ipiv);
<       if (info < 0) {
<          logger.error("LAPACK GETRF error code: {}", info);
<          throw new ArithmeticException("LAPACK GETRF error code: " + info);
<       } else {
<          lu.uplo = null;
<          return new MatrixModified.LU(lu, ipiv, info);
<       }
<    }
< 
<    public MatrixModified.Cholesky cholesky() {
<       return this.cholesky(false);
<    }
< 
<    public MatrixModified.Cholesky cholesky(boolean overwrite) {
<       if (this.uplo == null) {
<          throw new IllegalArgumentException("The matrix is not symmetric");
<       } else {
<          MatrixModified lu = overwrite ? this : this.clone();
<          int info = LAPACKModified.engine.potrf(lu.layout(), lu.uplo, lu.n, lu.A, lu.ld);
<          if (info != 0) {
<             logger.error("LAPACK GETRF error code: {}", info);
<             throw new ArithmeticException("LAPACK GETRF error code: " + info);
<          } else {
<             return new MatrixModified.Cholesky(lu);
<          }
<       }
<    }
< 
<    public MatrixModified.QR qr() {
<       return this.qr(false);
<    }
< 
<    public MatrixModified.QR qr(boolean overwrite) {
<       MatrixModified qr = overwrite ? this : this.clone();
<       double[] tau = new double[Math.min(this.m, this.n)];
<       int info = LAPACKModified.engine.geqrf(qr.layout(), qr.m, qr.n, qr.A, qr.ld, tau);
<       if (info != 0) {
<          logger.error("LAPACK GEQRF error code: {}", info);
<          throw new ArithmeticException("LAPACK GEQRF error code: " + info);
<       } else {
<          qr.uplo = null;
<          return new MatrixModified.QR(qr, tau);
<       }
<    }
< 
<    public MatrixModified.SVD svd() {
<       return this.svd(true, false);
<    }
< 
<    public MatrixModified.SVD svd(boolean vectors, boolean overwrite) {
<       int k = Math.min(this.m, this.n);
<       double[] s = new double[k];
<       MatrixModified W = overwrite ? this : this.clone();
<       MatrixModified U;
<       MatrixModified VT;
<       int info;
<       if (vectors) {
<          U = new MatrixModified(this.m, k);
<          VT = new MatrixModified(k, this.n);
<          info = LAPACKModified.engine.gesdd(W.layout(), SVDJobModified.COMPACT, W.m, W.n, W.A, W.ld, s, U.A, U.ld, VT.A, VT.ld);
<          if (info != 0) {
<             logger.error("LAPACK GESDD error code: {}", info);
<             throw new ArithmeticException("LAPACK GESDD error code: " + info);
<          } else {
<             return new MatrixModified.SVD(s, U, VT.transpose());
<          }
<       } else {
<          U = new MatrixModified(1, 1);
<          VT = new MatrixModified(1, 1);
<          info = LAPACKModified.engine.gesdd(W.layout(), SVDJobModified.NO_VECTORS, W.m, W.n, W.A, W.ld, s, U.A, U.ld, VT.A, VT.ld);
<          if (info != 0) {
<             logger.error("LAPACK GESDD error code: {}", info);
<             throw new ArithmeticException("LAPACK GESDD error code: " + info);
<          } else {
<             return new MatrixModified.SVD(this.m, this.n, s);
<          }
<       }
<    }
< 
<    public MatrixModified.EVD eigen() {
<       return this.eigen(false, true, false);
<    }
< 
<    public MatrixModified.EVD eigen(boolean vl, boolean vr, boolean overwrite) {
<       if (this.m != this.n) {
<          throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
<       } else {
<          MatrixModified eig = overwrite ? this : this.clone();
<          double[] wr;
<          if (this.isSymmetric()) {
<             wr = new double[this.n];
<             int info = LAPACKModified.engine.syevd(eig.layout(), vr ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, eig.uplo, this.n, eig.A, eig.ld, wr);
<             if (info != 0) {
<                logger.error("LAPACK SYEV error code: {}", info);
<                throw new ArithmeticException("LAPACK SYEV error code: " + info);
<             } else {
<                eig.uplo = null;
<                return new MatrixModified.EVD(wr, vr ? eig : null);
<             }
<          } else {
<             wr = new double[this.n];
<             double[] wi = new double[this.n];
<             MatrixModified Vl = vl ? new MatrixModified(this.n, this.n) : new MatrixModified(1, 1);
<             MatrixModified Vr = vr ? new MatrixModified(this.n, this.n) : new MatrixModified(1, 1);
<             int info = LAPACKModified.engine.geev(eig.layout(), vl ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, vr ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, this.n, eig.A, eig.ld, wr, wi, Vl.A, Vl.ld, Vr.A, Vr.ld);
<             if (info != 0) {
<                logger.error("LAPACK GEEV error code: {}", info);
<                throw new ArithmeticException("LAPACK GEEV error code: " + info);
<             } else {
<                return new MatrixModified.EVD(wr, wi, vl ? Vl : null, vr ? Vr : null);
<             }
<          }
<       }
<    }
< 
<    public static class Cholesky implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final MatrixModified lu;
< 
<       public Cholesky(MatrixModified lu) {
<          if (lu.nrow() != lu.ncol()) {
<             throw new UnsupportedOperationException("Cholesky constructor on a non-square matrix");
<          } else {
---
>             final int r = this.rank();
>             if (this.Ur == null) {
>                 this.Ur = ((r == this.U.ncol()) ? this.U : this.U.submatrix(0, 0, this.m - 1, r - 1));
>             }
>             final double[] Utb = new double[this.s.length];
>             this.Ur.tv(b, Utb);
>             for (int i = 0; i < r; ++i) {
>                 final double[] array = Utb;
>                 final int n = i;
>                 array[n] /= this.s[i];
>             }
>             return this.V.mv(Utb);
>         }
>     }
>     
>     public static class EVD implements Serializable
>     {
>         private static final long serialVersionUID = 2L;
>         public final double[] wr;
>         public final double[] wi;
>         public final MatrixModified Vl;
>         public final MatrixModified Vr;
>         
>         public EVD(final double[] w, final MatrixModified V) {
>             this.wr = w;
>             this.wi = null;
>             this.Vl = V;
>             this.Vr = V;
>         }
>         
>         public EVD(final double[] wr, final double[] wi, final MatrixModified Vl, final MatrixModified Vr) {
>             this.wr = wr;
>             this.wi = wi;
>             this.Vl = Vl;
>             this.Vr = Vr;
>         }
>         
>         public MatrixModified diag() {
>             final MatrixModified D = MatrixModified.diag(this.wr);
>             if (this.wi != null) {
>                 for (int n = this.wr.length, i = 0; i < n; ++i) {
>                     if (this.wi[i] > 0.0) {
>                         D.set(i, i + 1, this.wi[i]);
>                     }
>                     else if (this.wi[i] < 0.0) {
>                         D.set(i, i - 1, this.wi[i]);
>                     }
>                 }
>             }
>             return D;
>         }
>         
>         public EVD sort() {
>             final int n = this.wr.length;
>             final double[] w = new double[n];
>             if (this.wi != null) {
>                 for (int i = 0; i < n; ++i) {
>                     w[i] = -(this.wr[i] * this.wr[i] + this.wi[i] * this.wi[i]);
>                 }
>             }
>             else {
>                 for (int i = 0; i < n; ++i) {
>                     w[i] = -(this.wr[i] * this.wr[i]);
>                 }
>             }
>             final int[] index = QuickSortModified.sort(w);
>             final double[] wr2 = new double[n];
>             for (int j = 0; j < n; ++j) {
>                 wr2[j] = this.wr[index[j]];
>             }
>             double[] wi2 = null;
>             if (this.wi != null) {
>                 wi2 = new double[n];
>                 for (int k = 0; k < n; ++k) {
>                     wi2[k] = this.wi[index[k]];
>                 }
>             }
>             MatrixModified Vl2 = null;
>             if (this.Vl != null) {
>                 final int m = this.Vl.m;
>                 Vl2 = new MatrixModified(m, n);
>                 for (int l = 0; l < n; ++l) {
>                     for (int i2 = 0; i2 < m; ++i2) {
>                         Vl2.set(i2, l, this.Vl.get(i2, index[l]));
>                     }
>                 }
>             }
>             MatrixModified Vr2 = null;
>             if (this.Vr != null) {
>                 final int m2 = this.Vr.m;
>                 Vr2 = new MatrixModified(m2, n);
>                 for (int j2 = 0; j2 < n; ++j2) {
>                     for (int i3 = 0; i3 < m2; ++i3) {
>                         Vr2.set(i3, j2, this.Vr.get(i3, index[j2]));
>                     }
>                 }
>             }
>             return new EVD(wr2, wi2, Vl2, Vr2);
>         }
>     }
>     
>     public static class LU implements Serializable
>     {
>         private static final long serialVersionUID = 2L;
>         public final MatrixModified lu;
>         public final int[] ipiv;
>         public final int info;
>         
>         public LU(final MatrixModified lu, final int[] ipiv, final int info) {
1296,1340c1452,1473
<          }
<       }
< 
<       public double det() {
<          int n = this.lu.n;
<          double d = 1.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             d *= this.lu.get(i, i);
<          }
< 
<          return d * d;
<       }
< 
<       public double logdet() {
<          int n = this.lu.n;
<          double d = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             d += Math.log(this.lu.get(i, i));
<          }
< 
<          return 2.0D * d;
<       }
< 
<       public MatrixModified inverse() {
<          MatrixModified inv = MatrixModified.eye(this.lu.n);
<          this.solve(inv);
<          return inv;
<       }
< 
<       public double[] solve(double[] b) {
<          MatrixModified x = MatrixModified.column(b);
<          this.solve(x);
<          return x.A;
<       }
< 
<       public void solve(MatrixModified B) {
<          if (B.m != this.lu.m) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.m, this.lu.n, B.m, B.n));
<          } else {
<             int info = LAPACKModified.engine.potrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.A, this.lu.ld, B.A, B.ld);
<             if (info != 0) {
<                MatrixModified.logger.error("LAPACK POTRS error code: {}", info);
<                throw new ArithmeticException("LAPACK POTRS error code: " + info);
---
>             this.ipiv = ipiv;
>             this.info = info;
>         }
>         
>         public boolean isSingular() {
>             return this.info > 0;
>         }
>         
>         public double det() {
>             final int m = this.lu.m;
>             final int n = this.lu.n;
>             if (m != n) {
>                 throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", m, n));
>             }
>             double d = 1.0;
>             for (int j = 0; j < n; ++j) {
>                 d *= this.lu.get(j, j);
>             }
>             for (int j = 0; j < n; ++j) {
>                 if (j + 1 != this.ipiv[j]) {
>                     d = -d;
>                 }
1342,1410c1475,1495
<          }
<       }
<    }
< 
<    public static class EVD implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final double[] wr;
<       public final double[] wi;
<       public final MatrixModified Vl;
<       public final MatrixModified Vr;
< 
<       public EVD(double[] w, MatrixModified V) {
<          this.wr = w;
<          this.wi = null;
<          this.Vl = V;
<          this.Vr = V;
<       }
< 
<       public EVD(double[] wr, double[] wi, MatrixModified Vl, MatrixModified Vr) {
<          this.wr = wr;
<          this.wi = wi;
<          this.Vl = Vl;
<          this.Vr = Vr;
<       }
< 
<       public MatrixModified diag() {
<          MatrixModified D = MatrixModified.diag(this.wr);
<          if (this.wi != null) {
<             int n = this.wr.length;
< 
<             for(int i = 0; i < n; ++i) {
<                if (this.wi[i] > 0.0D) {
<                   D.set(i, i + 1, this.wi[i]);
<                } else if (this.wi[i] < 0.0D) {
<                   D.set(i, i - 1, this.wi[i]);
<                }
<             }
<          }
< 
<          return D;
<       }
< 
<       public MatrixModified.EVD sort() {
<          int n = this.wr.length;
<          double[] w = new double[n];
<          int i;
<          if (this.wi != null) {
<             for(i = 0; i < n; ++i) {
<                w[i] = -(this.wr[i] * this.wr[i] + this.wi[i] * this.wi[i]);
<             }
<          } else {
<             for(i = 0; i < n; ++i) {
<                w[i] = -(this.wr[i] * this.wr[i]);
<             }
<          }
< 
<          int[] index = QuickSortModified.sort(w);
<          double[] wr2 = new double[n];
< 
<          for(int j = 0; j < n; ++j) {
<             wr2[j] = this.wr[index[j]];
<          }
< 
<          double[] wi2 = null;
<          if (this.wi != null) {
<             wi2 = new double[n];
< 
<             for(int j = 0; j < n; ++j) {
<                wi2[j] = this.wi[index[j]];
---
>             return d;
>         }
>         
>         public MatrixModified inverse() {
>             final MatrixModified inv = MatrixModified.eye(this.lu.n);
>             this.solve(inv);
>             return inv;
>         }
>         
>         public double[] solve(final double[] b) {
>             final MatrixModified x = MatrixModified.column(b);
>             this.solve(x);
>             return x.A;
>         }
>         
>         public void solve(final MatrixModified B) {
>             if (this.lu.m != this.lu.n) {
>                 throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.lu.m, this.lu.n));
>             }
>             if (B.m != this.lu.m) {
>                 throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.m, this.lu.n, B.m, B.n));
1412,1424c1497,1498
<          }
< 
<          MatrixModified Vl2 = null;
<          int m;
<          int j;
<          if (this.Vl != null) {
<             int m = this.Vl.m;
<             Vl2 = new MatrixModified(m, n);
< 
<             for(m = 0; m < n; ++m) {
<                for(j = 0; j < m; ++j) {
<                   Vl2.set(j, m, this.Vl.get(j, index[m]));
<                }
---
>             if (this.lu.layout() != B.layout()) {
>                 throw new IllegalArgumentException("The matrix layout is inconsistent.");
1426,1436c1500,1501
<          }
< 
<          MatrixModified Vr2 = null;
<          if (this.Vr != null) {
<             m = this.Vr.m;
<             Vr2 = new MatrixModified(m, n);
< 
<             for(j = 0; j < n; ++j) {
<                for(int i = 0; i < m; ++i) {
<                   Vr2.set(i, j, this.Vr.get(i, index[j]));
<                }
---
>             if (this.info > 0) {
>                 throw new RuntimeException("The matrix is singular.");
1438,1470c1503,1506
<          }
< 
<          return new MatrixModified.EVD(wr2, wi2, Vl2, Vr2);
<       }
<    }
< 
<    public static class LU implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final MatrixModified lu;
<       public final int[] ipiv;
<       public final int info;
< 
<       public LU(MatrixModified lu, int[] ipiv, int info) {
<          this.lu = lu;
<          this.ipiv = ipiv;
<          this.info = info;
<       }
< 
<       public boolean isSingular() {
<          return this.info > 0;
<       }
< 
<       public double det() {
<          int m = this.lu.m;
<          int n = this.lu.n;
<          if (m != n) {
<             throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", m, n));
<          } else {
<             double d = 1.0D;
< 
<             int j;
<             for(j = 0; j < n; ++j) {
<                d *= this.lu.get(j, j);
---
>             final int ret = LAPACKModified.engine.getrs(this.lu.layout(), TransposeModified.NO_TRANSPOSE, this.lu.n, B.n, this.lu.A, this.lu.ld, this.ipiv, B.A, B.ld);
>             if (ret != 0) {
>                 MatrixModified.logger.error("LAPACK GETRS error code: {}", (Object)ret);
>                 throw new ArithmeticException("LAPACK GETRS error code: " + ret);
1472,1476c1508,1518
< 
<             for(j = 0; j < n; ++j) {
<                if (j + 1 != this.ipiv[j]) {
<                   d = -d;
<                }
---
>         }
>     }
>     
>     public static class Cholesky implements Serializable
>     {
>         private static final long serialVersionUID = 2L;
>         public final MatrixModified lu;
>         
>         public Cholesky(final MatrixModified lu) {
>             if (lu.nrow() != lu.ncol()) {
>                 throw new UnsupportedOperationException("Cholesky constructor on a non-square matrix");
1478,1508c1520,1555
< 
<             return d;
<          }
<       }
< 
<       public MatrixModified inverse() {
<          MatrixModified inv = MatrixModified.eye(this.lu.n);
<          this.solve(inv);
<          return inv;
<       }
< 
<       public double[] solve(double[] b) {
<          MatrixModified x = MatrixModified.column(b);
<          this.solve(x);
<          return x.A;
<       }
< 
<       public void solve(MatrixModified B) {
<          if (this.lu.m != this.lu.n) {
<             throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.lu.m, this.lu.n));
<          } else if (B.m != this.lu.m) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.m, this.lu.n, B.m, B.n));
<          } else if (this.lu.layout() != B.layout()) {
<             throw new IllegalArgumentException("The matrix layout is inconsistent.");
<          } else if (this.info > 0) {
<             throw new RuntimeException("The matrix is singular.");
<          } else {
<             int ret = LAPACKModified.engine.getrs(this.lu.layout(), TransposeModified.NO_TRANSPOSE, this.lu.n, B.n, this.lu.A, this.lu.ld, this.ipiv, B.A, B.ld);
<             if (ret != 0) {
<                MatrixModified.logger.error("LAPACK GETRS error code: {}", ret);
<                throw new ArithmeticException("LAPACK GETRS error code: " + ret);
---
>             this.lu = lu;
>         }
>         
>         public double det() {
>             final int n = this.lu.n;
>             double d = 1.0;
>             for (int i = 0; i < n; ++i) {
>                 d *= this.lu.get(i, i);
>             }
>             return d * d;
>         }
>         
>         public double logdet() {
>             final int n = this.lu.n;
>             double d = 0.0;
>             for (int i = 0; i < n; ++i) {
>                 d += Math.log(this.lu.get(i, i));
>             }
>             return 2.0 * d;
>         }
>         
>         public MatrixModified inverse() {
>             final MatrixModified inv = MatrixModified.eye(this.lu.n);
>             this.solve(inv);
>             return inv;
>         }
>         
>         public double[] solve(final double[] b) {
>             final MatrixModified x = MatrixModified.column(b);
>             this.solve(x);
>             return x.A;
>         }
>         
>         public void solve(final MatrixModified B) {
>             if (B.m != this.lu.m) {
>                 throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.m, this.lu.n, B.m, B.n));
1510,1530c1557,1560
<          }
<       }
<    }
< 
<    public static class QR implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final MatrixModified qr;
<       public final double[] tau;
< 
<       public QR(MatrixModified qr, double[] tau) {
<          this.qr = qr;
<          this.tau = tau;
<       }
< 
<       public MatrixModified.Cholesky CholeskyOfAtA() {
<          int n = this.qr.n;
<          MatrixModified L = new MatrixModified(n, n);
< 
<          for(int i = 0; i < n; ++i) {
<             for(int j = 0; j <= i; ++j) {
<                L.set(i, j, this.qr.get(j, i));
---
>             final int info = LAPACKModified.engine.potrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.A, this.lu.ld, B.A, B.ld);
>             if (info != 0) {
>                 MatrixModified.logger.error("LAPACK POTRS error code: {}", (Object)info);
>                 throw new ArithmeticException("LAPACK POTRS error code: " + info);
1532,1544c1562,1607
<          }
< 
<          L.uplo(UPLOModified.LOWER);
<          return new MatrixModified.Cholesky(L);
<       }
< 
<       public MatrixModified R() {
<          int n = this.qr.n;
<          MatrixModified R = MatrixModified.diag(this.tau);
< 
<          for(int i = 0; i < n; ++i) {
<             for(int j = i; j < n; ++j) {
<                R.set(i, j, this.qr.get(i, j));
---
>         }
>     }
>     
>     public static class QR implements Serializable
>     {
>         private static final long serialVersionUID = 2L;
>         public final MatrixModified qr;
>         public final double[] tau;
>         
>         public QR(final MatrixModified qr, final double[] tau) {
>             this.qr = qr;
>             this.tau = tau;
>         }
>         
>         public Cholesky CholeskyOfAtA() {
>             final int n = this.qr.n;
>             final MatrixModified L = new MatrixModified(n, n);
>             for (int i = 0; i < n; ++i) {
>                 for (int j = 0; j <= i; ++j) {
>                     L.set(i, j, this.qr.get(j, i));
>                 }
>             }
>             L.uplo(UPLOModified.LOWER);
>             return new Cholesky(L);
>         }
>         
>         public MatrixModified R() {
>             final int n = this.qr.n;
>             final MatrixModified R = MatrixModified.diag(this.tau);
>             for (int i = 0; i < n; ++i) {
>                 for (int j = i; j < n; ++j) {
>                     R.set(i, j, this.qr.get(i, j));
>                 }
>             }
>             return R;
>         }
>         
>         public MatrixModified Q() {
>             final int m = this.qr.m;
>             final int n = this.qr.n;
>             final int k = Math.min(m, n);
>             final MatrixModified Q = this.qr.clone();
>             final int info = LAPACKModified.engine.orgqr(this.qr.layout(), m, n, k, Q.A, this.qr.ld, this.tau);
>             if (info != 0) {
>                 MatrixModified.logger.error("LAPACK ORGRQ error code: {}", (Object)info);
>                 throw new ArithmeticException("LAPACK ORGRQ error code: " + info);
1546,1560d1608
<          }
< 
<          return R;
<       }
< 
<       public MatrixModified Q() {
<          int m = this.qr.m;
<          int n = this.qr.n;
<          int k = Math.min(m, n);
<          MatrixModified Q = this.qr.clone();
<          int info = LAPACKModified.engine.orgqr(this.qr.layout(), m, n, k, Q.A, this.qr.ld, this.tau);
<          if (info != 0) {
<             MatrixModified.logger.error("LAPACK ORGRQ error code: {}", info);
<             throw new ArithmeticException("LAPACK ORGRQ error code: " + info);
<          } else {
1562,1569c1610,1616
<          }
<       }
< 
<       public double[] solve(double[] b) {
<          if (b.length != this.qr.m) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x 1", this.qr.m, this.qr.n, b.length));
<          } else {
<             MatrixModified x = MatrixModified.column(b);
---
>         }
>         
>         public double[] solve(final double[] b) {
>             if (b.length != this.qr.m) {
>                 throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x 1", this.qr.m, this.qr.n, b.length));
>             }
>             final MatrixModified x = MatrixModified.column(b);
1572,1581c1619,1627
<          }
<       }
< 
<       public void solve(MatrixModified B) {
<          if (B.m != this.qr.m) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.qr.nrow(), this.qr.nrow(), B.nrow(), B.ncol()));
<          } else {
<             int m = this.qr.m;
<             int n = this.qr.n;
<             int k = Math.min(m, n);
---
>         }
>         
>         public void solve(final MatrixModified B) {
>             if (B.m != this.qr.m) {
>                 throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.qr.nrow(), this.qr.nrow(), B.nrow(), B.ncol()));
>             }
>             final int m = this.qr.m;
>             final int n = this.qr.n;
>             final int k = Math.min(m, n);
1584,1667c1630,1631
<                MatrixModified.logger.error("LAPACK ORMQR error code: {}", info);
<                throw new IllegalArgumentException("LAPACK ORMQR error code: " + info);
<             } else {
<                info = LAPACKModified.engine.trtrs(this.qr.layout(), UPLOModified.UPPER, TransposeModified.NO_TRANSPOSE, DiagModified.NON_UNIT, this.qr.n, B.n, this.qr.A, this.qr.ld, B.A, B.ld);
<                if (info != 0) {
<                   MatrixModified.logger.error("LAPACK TRTRS error code: {}", info);
<                   throw new IllegalArgumentException("LAPACK TRTRS error code: " + info);
<                }
<             }
<          }
<       }
<    }
< 
<    private static class RowMajor extends MatrixModified {
<       RowMajor(int m, int n, int ld, double[] A) {
<          super(m, n, ld, A);
<       }
< 
<       public LayoutModified layout() {
<          return LayoutModified.ROW_MAJOR;
<       }
< 
<       protected int index(int i, int j) {
<          return i * this.ld + j;
<       }
<    }
< 
<    public static class SVD implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final int m;
<       public final int n;
<       public final double[] s;
<       public final MatrixModified U;
<       public final MatrixModified V;
<       private transient MatrixModified Ur;
< 
<       public SVD(int m, int n, double[] s) {
<          this.m = m;
<          this.n = n;
<          this.s = s;
<          this.U = null;
<          this.V = null;
<       }
< 
<       public SVD(double[] s, MatrixModified U, MatrixModified V) {
<          this.m = U.m;
<          this.n = V.m;
<          this.s = s;
<          this.U = U;
<          this.V = V;
<       }
< 
<       public MatrixModified diag() {
<          MatrixModified S = new MatrixModified(this.U.m, this.V.m);
< 
<          for(int i = 0; i < this.s.length; ++i) {
<             S.set(i, i, this.s[i]);
<          }
< 
<          return S;
<       }
< 
<       public double norm() {
<          return this.s[0];
<       }
< 
<       private double rcond() {
<          return 0.5D * Math.sqrt((double)(this.m + this.n + 1)) * this.s[0] * MathExModified.EPSILON;
<       }
< 
<       public int rank() {
<          if (this.s.length != Math.min(this.m, this.n)) {
<             throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
<          } else {
<             int r = 0;
<             double tol = this.rcond();
<             double[] var8;
<             int var7 = (var8 = this.s).length;
< 
<             for(int var6 = 0; var6 < var7; ++var6) {
<                double si = var8[var6];
<                if (si > tol) {
<                   ++r;
<                }
---
>                 MatrixModified.logger.error("LAPACK ORMQR error code: {}", (Object)info);
>                 throw new IllegalArgumentException("LAPACK ORMQR error code: " + info);
1669,1761c1633,1636
< 
<             return r;
<          }
<       }
< 
<       public int nullity() {
<          return Math.min(this.m, this.n) - this.rank();
<       }
< 
<       public double condition() {
<          if (this.s.length != Math.min(this.m, this.n)) {
<             throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
<          } else {
<             return !(this.s[0] <= 0.0D) && !(this.s[this.s.length - 1] <= 0.0D) ? this.s[0] / this.s[this.s.length - 1] : Double.POSITIVE_INFINITY;
<          }
<       }
< 
<       public MatrixModified range() {
<          if (this.s.length != Math.min(this.m, this.n)) {
<             throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
<          } else if (this.U == null) {
<             throw new IllegalStateException("The left singular vectors are not available.");
<          } else {
<             int r = this.rank();
<             if (r == 0) {
<                return null;
<             } else {
<                MatrixModified R = new MatrixModified(this.m, r);
< 
<                for(int j = 0; j < r; ++j) {
<                   for(int i = 0; i < this.m; ++i) {
<                      R.set(i, j, this.U.get(i, j));
<                   }
<                }
< 
<                return R;
<             }
<          }
<       }
< 
<       public MatrixModified nullspace() {
<          if (this.s.length != Math.min(this.m, this.n)) {
<             throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
<          } else if (this.V == null) {
<             throw new IllegalStateException("The right singular vectors are not available.");
<          } else {
<             int nr = this.nullity();
<             if (nr == 0) {
<                return null;
<             } else {
<                MatrixModified N = new MatrixModified(this.n, nr);
< 
<                for(int j = 0; j < nr; ++j) {
<                   for(int i = 0; i < this.n; ++i) {
<                      N.set(i, j, this.V.get(i, this.n - j - 1));
<                   }
<                }
< 
<                return N;
<             }
<          }
<       }
< 
<       public MatrixModified pinv() {
<          int k = this.s.length;
<          double[] sigma = new double[k];
<          int r = this.rank();
< 
<          for(int i = 0; i < r; ++i) {
<             sigma[i] = 1.0D / this.s[i];
<          }
< 
<          return MatrixModified.adb(TransposeModified.NO_TRANSPOSE, this.V, sigma, TransposeModified.TRANSPOSE, this.U);
<       }
< 
<       public double[] solve(double[] b) {
<          if (this.U != null && this.V != null) {
<             if (b.length != this.m) {
<                throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x 1", this.m, this.n, b.length));
<             } else {
<                int r = this.rank();
<                if (this.Ur == null) {
<                   this.Ur = r == this.U.ncol() ? this.U : this.U.submatrix(0, 0, this.m - 1, r - 1);
<                }
< 
<                double[] Utb = new double[this.s.length];
<                this.Ur.tv(b, Utb);
< 
<                for(int i = 0; i < r; ++i) {
<                   Utb[i] /= this.s[i];
<                }
< 
<                return this.V.mv(Utb);
---
>             info = LAPACKModified.engine.trtrs(this.qr.layout(), UPLOModified.UPPER, TransposeModified.NO_TRANSPOSE, DiagModified.NON_UNIT, this.qr.n, B.n, this.qr.A, this.qr.ld, B.A, B.ld);
>             if (info != 0) {
>                 MatrixModified.logger.error("LAPACK TRTRS error code: {}", (Object)info);
>                 throw new IllegalArgumentException("LAPACK TRTRS error code: " + info);
1763,1767c1638,1639
<          } else {
<             throw new IllegalStateException("The singular vectors are not available.");
<          }
<       }
<    }
---
>         }
>     }
diff -r TrackAnalyzer_/smileModified/MersenneTwisterModified.java procyon/smileModified/MersenneTwisterModified.java
1,41c1,3
< package smileModified;
< 
< public class MersenneTwisterModified implements RandomNumberGeneratorModified {
<    private static final int UPPER_MASK = Integer.MIN_VALUE;
<    private static final int LOWER_MASK = Integer.MAX_VALUE;
<    private static final int N = 624;
<    private static final int M = 397;
<    private static final int[] MAGIC = new int[]{0, -1727483681};
<    private static final int MAGIC_FACTOR1 = 1812433253;
<    private static final int MAGIC_FACTOR2 = 1664525;
<    private static final int MAGIC_FACTOR3 = 1566083941;
<    private static final int MAGIC_MASK1 = -1658038656;
<    private static final int MAGIC_MASK2 = -272236544;
<    private static final int MAGIC_SEED = 19650218;
<    private final int[] mt;
<    private int mti;
< 
<    public MersenneTwisterModified() {
<       this(19650218);
<    }
< 
<    public MersenneTwisterModified(int seed) {
<       this.mt = new int[624];
<       this.setSeed(seed);
<    }
< 
<    public MersenneTwisterModified(long seed) {
<       this.mt = new int[624];
<       this.setSeed(seed);
<    }
< 
<    public void setSeed(long seed) {
<       this.setSeed((int)(seed % 2147483647L));
<    }
< 
<    public void setSeed(int seed) {
<       this.mt[0] = seed;
< 
<       for(this.mti = 1; this.mti < 624; ++this.mti) {
<          this.mt[this.mti] = 1812433253 * (this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30) + this.mti;
<       }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
43,49c5
<    }
< 
<    public void setSeed(int[] seed) {
<       this.setSeed(19650218);
<       if (seed != null && seed.length != 0) {
<          int i = 1;
<          int j = 0;
---
> package smileModified;
51,52c7,62
<          int k;
<          for(k = Math.max(624, seed.length); k > 0; --k) {
---
> public class MersenneTwisterModified implements RandomNumberGeneratorModified
> {
>     private static final int UPPER_MASK = Integer.MIN_VALUE;
>     private static final int LOWER_MASK = Integer.MAX_VALUE;
>     private static final int N = 624;
>     private static final int M = 397;
>     private static final int[] MAGIC;
>     private static final int MAGIC_FACTOR1 = 1812433253;
>     private static final int MAGIC_FACTOR2 = 1664525;
>     private static final int MAGIC_FACTOR3 = 1566083941;
>     private static final int MAGIC_MASK1 = -1658038656;
>     private static final int MAGIC_MASK2 = -272236544;
>     private static final int MAGIC_SEED = 19650218;
>     private final int[] mt;
>     private int mti;
>     
>     static {
>         MAGIC = new int[] { 0, -1727483681 };
>     }
>     
>     public MersenneTwisterModified() {
>         this(19650218);
>     }
>     
>     public MersenneTwisterModified(final int seed) {
>         this.mt = new int[624];
>         this.setSeed(seed);
>     }
>     
>     public MersenneTwisterModified(final long seed) {
>         this.mt = new int[624];
>         this.setSeed(seed);
>     }
>     
>     @Override
>     public void setSeed(final long seed) {
>         this.setSeed((int)(seed % 2147483647L));
>     }
>     
>     public void setSeed(final int seed) {
>         this.mt[0] = seed;
>         this.mti = 1;
>         while (this.mti < 624) {
>             this.mt[this.mti] = 1812433253 * (this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30) + this.mti;
>             ++this.mti;
>         }
>     }
>     
>     public void setSeed(final int[] seed) {
>         this.setSeed(19650218);
>         if (seed == null || seed.length == 0) {
>             return;
>         }
>         int i = 1;
>         int j = 0;
>         for (int k = Math.max(624, seed.length); k > 0; --k) {
57,58c67,68
<                this.mt[0] = this.mt[623];
<                i = 1;
---
>                 this.mt[0] = this.mt[623];
>                 i = 1;
60d69
< 
62c71
<                j = 0;
---
>                 j = 0;
64,66c73,74
<          }
< 
<          for(k = 623; k > 0; --k) {
---
>         }
>         for (int k = 623; k > 0; --k) {
68,71c76,78
<             ++i;
<             if (i >= 624) {
<                this.mt[0] = this.mt[623];
<                i = 1;
---
>             if (++i >= 624) {
>                 this.mt[0] = this.mt[623];
>                 i = 1;
73,133c80,138
<          }
< 
<          int[] var10000 = this.mt;
<          var10000[0] |= Integer.MIN_VALUE;
<       }
<    }
< 
<    public int next(int numbits) {
<       return this.nextInt() >>> 32 - numbits;
<    }
< 
<    public double nextDouble() {
<       return (double)(this.nextInt() >>> 1) / 2.147483647E9D;
<    }
< 
<    public void nextDoubles(double[] d) {
<       int n = d.length;
< 
<       for(int i = 0; i < n; ++i) {
<          d[i] = this.nextDouble();
<       }
< 
<    }
< 
<    public int nextInt() {
<       int x;
<       if (this.mti >= 624) {
<          int i;
<          for(i = 0; i < 227; ++i) {
<             x = this.mt[i] & Integer.MIN_VALUE | this.mt[i + 1] & Integer.MAX_VALUE;
<             this.mt[i] = this.mt[i + 397] ^ x >>> 1 ^ MAGIC[x & 1];
<          }
< 
<          while(i < 623) {
<             x = this.mt[i] & Integer.MIN_VALUE | this.mt[i + 1] & Integer.MAX_VALUE;
<             this.mt[i] = this.mt[i + -227] ^ x >>> 1 ^ MAGIC[x & 1];
<             ++i;
<          }
< 
<          x = this.mt[623] & Integer.MIN_VALUE | this.mt[0] & Integer.MAX_VALUE;
<          this.mt[623] = this.mt[396] ^ x >>> 1 ^ MAGIC[x & 1];
<          this.mti = 0;
<       }
< 
<       x = this.mt[this.mti++];
<       x ^= x >>> 11;
<       x ^= x << 7 & -1658038656;
<       x ^= x << 15 & -272236544;
<       x ^= x >>> 18;
<       return x;
<    }
< 
<    public int nextInt(int n) {
<       if (n <= 0) {
<          throw new IllegalArgumentException("n must be positive");
<       } else if ((n & -n) == n) {
<          return (int)((long)n * (long)this.next(31) >> 31);
<       } else {
<          int bits;
<          int val;
<          do {
---
>         }
>         final int[] mt = this.mt;
>         final int n = 0;
>         mt[n] |= Integer.MIN_VALUE;
>     }
>     
>     @Override
>     public int next(final int numbits) {
>         return this.nextInt() >>> 32 - numbits;
>     }
>     
>     @Override
>     public double nextDouble() {
>         return (this.nextInt() >>> 1) / 2.147483647E9;
>     }
>     
>     @Override
>     public void nextDoubles(final double[] d) {
>         for (int n = d.length, i = 0; i < n; ++i) {
>             d[i] = this.nextDouble();
>         }
>     }
>     
>     @Override
>     public int nextInt() {
>         if (this.mti >= 624) {
>             int i;
>             for (i = 0; i < 227; ++i) {
>                 final int x = (this.mt[i] & Integer.MIN_VALUE) | (this.mt[i + 1] & Integer.MAX_VALUE);
>                 this.mt[i] = (this.mt[i + 397] ^ x >>> 1 ^ MersenneTwisterModified.MAGIC[x & 0x1]);
>             }
>             while (i < 623) {
>                 final int x = (this.mt[i] & Integer.MIN_VALUE) | (this.mt[i + 1] & Integer.MAX_VALUE);
>                 this.mt[i] = (this.mt[i - 227] ^ x >>> 1 ^ MersenneTwisterModified.MAGIC[x & 0x1]);
>                 ++i;
>             }
>             final int x = (this.mt[623] & Integer.MIN_VALUE) | (this.mt[0] & Integer.MAX_VALUE);
>             this.mt[623] = (this.mt[396] ^ x >>> 1 ^ MersenneTwisterModified.MAGIC[x & 0x1]);
>             this.mti = 0;
>         }
>         int x = this.mt[this.mti++];
>         x ^= x >>> 11;
>         x ^= (x << 7 & 0x9D2C5680);
>         x ^= (x << 15 & 0xEFC60000);
>         x ^= x >>> 18;
>         return x;
>     }
>     
>     @Override
>     public int nextInt(final int n) {
>         if (n <= 0) {
>             throw new IllegalArgumentException("n must be positive");
>         }
>         if ((n & -n) == n) {
>             return (int)(n * (long)this.next(31) >> 31);
>         }
>         int bits;
>         int val;
>         do {
136,145c141,149
<          } while(bits - val + (n - 1) < 0);
< 
<          return val;
<       }
<    }
< 
<    public long nextLong() {
<       long x = (long)this.nextInt();
<       return x << 32 | (long)this.nextInt();
<    }
---
>         } while (bits - val + (n - 1) < 0);
>         return val;
>     }
>     
>     @Override
>     public long nextLong() {
>         final long x = this.nextInt();
>         return x << 32 | (long)this.nextInt();
>     }
diff -r TrackAnalyzer_/smileModified/MixtureModified.java procyon/smileModified/MixtureModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
4c8
< import java.util.Arrays;
---
> import java.util.stream.Collector;
5a10
> import java.util.Arrays;
7,20c12,22
< public class MixtureModified extends AbstractDistributionModified {
<    private static final long serialVersionUID = 2L;
<    public final MixtureModified.Component[] components;
< 
<    public MixtureModified(MixtureModified.Component... components) {
<       if (components.length == 0) {
<          throw new IllegalStateException("Empty mixture!");
<       } else {
<          double sum = 0.0D;
<          MixtureModified.Component[] var7 = components;
<          int var6 = components.length;
< 
<          for(int var5 = 0; var5 < var6; ++var5) {
<             MixtureModified.Component component = var7[var5];
---
> public class MixtureModified extends AbstractDistributionModified
> {
>     private static final long serialVersionUID = 2L;
>     public final Component[] components;
>     
>     public MixtureModified(final Component... components) {
>         if (components.length == 0) {
>             throw new IllegalStateException("Empty mixture!");
>         }
>         double sum = 0.0;
>         for (final Component component : components) {
22,24c24,25
<          }
< 
<          if (Math.abs(sum - 1.0D) > 0.001D) {
---
>         }
>         if (Math.abs(sum - 1.0) > 0.001) {
26,145c27,135
<          } else {
<             this.components = components;
<          }
<       }
<    }
< 
<    public double[] posteriori(double x) {
<       int k = this.components.length;
<       double[] prob = new double[k];
< 
<       for(int i = 0; i < k; ++i) {
<          MixtureModified.Component c = this.components[i];
<          prob[i] = c.priori * c.distribution.p(x);
<       }
< 
<       double p = MathExModified.sum(prob);
< 
<       for(int i = 0; i < k; ++i) {
<          prob[i] /= p;
<       }
< 
<       return prob;
<    }
< 
<    public int map(double x) {
<       int k = this.components.length;
<       double[] prob = new double[k];
< 
<       for(int i = 0; i < k; ++i) {
<          MixtureModified.Component c = this.components[i];
<          prob[i] = c.priori * c.distribution.p(x);
<       }
< 
<       return MathExModified.whichMax(prob);
<    }
< 
<    public double mean() {
<       double mu = 0.0D;
<       MixtureModified.Component[] var6;
<       int var5 = (var6 = this.components).length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          MixtureModified.Component c = var6[var4];
<          mu += c.priori * c.distribution.mean();
<       }
< 
<       return mu;
<    }
< 
<    public double variance() {
<       double variance = 0.0D;
<       MixtureModified.Component[] var6;
<       int var5 = (var6 = this.components).length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          MixtureModified.Component c = var6[var4];
<          variance += c.priori * c.priori * c.distribution.variance();
<       }
< 
<       return variance;
<    }
< 
<    public double entropy() {
<       throw new UnsupportedOperationException("Mixture does not support entropy()");
<    }
< 
<    public double p(double x) {
<       double p = 0.0D;
<       MixtureModified.Component[] var8;
<       int var7 = (var8 = this.components).length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          MixtureModified.Component c = var8[var6];
<          p += c.priori * c.distribution.p(x);
<       }
< 
<       return p;
<    }
< 
<    public double logp(double x) {
<       return Math.log(this.p(x));
<    }
< 
<    public double cdf(double x) {
<       double p = 0.0D;
<       MixtureModified.Component[] var8;
<       int var7 = (var8 = this.components).length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          MixtureModified.Component c = var8[var6];
<          p += c.priori * c.distribution.cdf(x);
<       }
< 
<       return p;
<    }
< 
<    public double rand() {
<       double r = MathExModified.random();
<       double p = 0.0D;
<       MixtureModified.Component[] var8;
<       int var7 = (var8 = this.components).length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          MixtureModified.Component g = var8[var6];
<          p += g.priori;
<          if (r <= p) {
<             return g.distribution.rand();
<          }
<       }
< 
<       throw new IllegalStateException();
<    }
< 
<    public double quantile(double p) {
<       if (!(p < 0.0D) && !(p > 1.0D)) {
<          double inc = 1.0D;
<          double x = (double)((int)this.mean());
<          double xl;
<          double xu;
<          if (p < this.cdf(x)) {
---
>         }
>         this.components = components;
>     }
>     
>     public double[] posteriori(final double x) {
>         final int k = this.components.length;
>         final double[] prob = new double[k];
>         for (int i = 0; i < k; ++i) {
>             final Component c = this.components[i];
>             prob[i] = c.priori * c.distribution.p(x);
>         }
>         final double p = MathExModified.sum(prob);
>         for (int j = 0; j < k; ++j) {
>             final double[] array = prob;
>             final int n = j;
>             array[n] /= p;
>         }
>         return prob;
>     }
>     
>     public int map(final double x) {
>         final int k = this.components.length;
>         final double[] prob = new double[k];
>         for (int i = 0; i < k; ++i) {
>             final Component c = this.components[i];
>             prob[i] = c.priori * c.distribution.p(x);
>         }
>         return MathExModified.whichMax(prob);
>     }
>     
>     @Override
>     public double mean() {
>         double mu = 0.0;
>         Component[] components;
>         for (int length = (components = this.components).length, i = 0; i < length; ++i) {
>             final Component c = components[i];
>             mu += c.priori * c.distribution.mean();
>         }
>         return mu;
>     }
>     
>     @Override
>     public double variance() {
>         double variance = 0.0;
>         Component[] components;
>         for (int length = (components = this.components).length, i = 0; i < length; ++i) {
>             final Component c = components[i];
>             variance += c.priori * c.priori * c.distribution.variance();
>         }
>         return variance;
>     }
>     
>     @Override
>     public double entropy() {
>         throw new UnsupportedOperationException("Mixture does not support entropy()");
>     }
>     
>     @Override
>     public double p(final double x) {
>         double p = 0.0;
>         Component[] components;
>         for (int length = (components = this.components).length, i = 0; i < length; ++i) {
>             final Component c = components[i];
>             p += c.priori * c.distribution.p(x);
>         }
>         return p;
>     }
>     
>     @Override
>     public double logp(final double x) {
>         return Math.log(this.p(x));
>     }
>     
>     @Override
>     public double cdf(final double x) {
>         double p = 0.0;
>         Component[] components;
>         for (int length = (components = this.components).length, i = 0; i < length; ++i) {
>             final Component c = components[i];
>             p += c.priori * c.distribution.cdf(x);
>         }
>         return p;
>     }
>     
>     @Override
>     public double rand() {
>         final double r = MathExModified.random();
>         double p = 0.0;
>         Component[] components;
>         for (int length = (components = this.components).length, i = 0; i < length; ++i) {
>             final Component g = components[i];
>             p += g.priori;
>             if (r <= p) {
>                 return g.distribution.rand();
>             }
>         }
>         throw new IllegalStateException();
>     }
>     
>     @Override
>     public double quantile(final double p) {
>         if (p < 0.0 || p > 1.0) {
>             throw new IllegalArgumentException("Invalid p: " + p);
>         }
>         double inc = 1.0;
>         double x = (int)this.mean();
>         double xl;
>         double xu;
>         if (p < this.cdf(x)) {
147,150c137,139
<                x -= inc;
<                inc *= 2.0D;
<             } while(p < this.cdf(x));
< 
---
>                 x -= inc;
>                 inc *= 2.0;
>             } while (p < this.cdf(x));
152,153c141,143
<             xu = x + inc / 2.0D;
<          } else {
---
>             xu = x + inc / 2.0;
>         }
>         else {
155,158c145,147
<                x += inc;
<                inc *= 2.0D;
<             } while(p > this.cdf(x));
< 
---
>                 x += inc;
>                 inc *= 2.0;
>             } while (p > this.cdf(x));
160,218c149,196
<             xl = x - inc / 2.0D;
<          }
< 
<          return this.quantile(p, xl, xu);
<       } else {
<          throw new IllegalArgumentException("Invalid p: " + p);
<       }
<    }
< 
<    public int length() {
<       int length = this.components.length - 1;
<       MixtureModified.Component[] var5;
<       int var4 = (var5 = this.components).length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          MixtureModified.Component component = var5[var3];
<          length += component.distribution.length();
<       }
< 
<       return length;
<    }
< 
<    public int size() {
<       return this.components.length;
<    }
< 
<    public double bic(double[] data) {
<       int n = data.length;
<       double logLikelihood = 0.0D;
<       double[] var9 = data;
<       int var8 = data.length;
< 
<       for(int var7 = 0; var7 < var8; ++var7) {
<          double x = var9[var7];
<          double p = this.p(x);
<          if (p > 0.0D) {
<             logLikelihood += Math.log(p);
<          }
<       }
< 
<       return logLikelihood - 0.5D * (double)this.length() * Math.log((double)n);
<    }
< 
<    public String toString() {
<       return (String)Arrays.stream(this.components).map((component) -> {
<          return String.format("%.2f x %s", component.priori, component.distribution);
<       }).collect(Collectors.joining(" + ", String.format("Mixture(%d)[", this.components.length), "]"));
<    }
< 
<    public static class Component implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final double priori;
<       public final DistributionModified distribution;
< 
<       public Component(double priori, DistributionModified distribution) {
<          this.priori = priori;
<          this.distribution = distribution;
<       }
<    }
---
>             xl = x - inc / 2.0;
>         }
>         return this.quantile(p, xl, xu);
>     }
>     
>     @Override
>     public int length() {
>         int length = this.components.length - 1;
>         Component[] components;
>         for (int length2 = (components = this.components).length, i = 0; i < length2; ++i) {
>             final Component component = components[i];
>             length += component.distribution.length();
>         }
>         return length;
>     }
>     
>     public int size() {
>         return this.components.length;
>     }
>     
>     public double bic(final double[] data) {
>         final int n = data.length;
>         double logLikelihood = 0.0;
>         for (final double x : data) {
>             final double p = this.p(x);
>             if (p > 0.0) {
>                 logLikelihood += Math.log(p);
>             }
>         }
>         return logLikelihood - 0.5 * this.length() * Math.log(n);
>     }
>     
>     @Override
>     public String toString() {
>         return Arrays.<Component>stream(this.components).<Object>map(component -> String.format("%.2f x %s", component.priori, component.distribution)).<String, ?>collect((Collector<? super Object, ?, String>)Collectors.joining(" + ", String.format("Mixture(%d)[", this.components.length), "]"));
>     }
>     
>     public static class Component implements Serializable
>     {
>         private static final long serialVersionUID = 2L;
>         public final double priori;
>         public final DistributionModified distribution;
>         
>         public Component(final double priori, final DistributionModified distribution) {
>             this.priori = priori;
>             this.distribution = distribution;
>         }
>     }
diff -r TrackAnalyzer_/smileModified/OpenBLASModified.java procyon/smileModified/OpenBLASModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,4c7
< import java.nio.DoubleBuffer;
< import java.nio.FloatBuffer;
---
> import org.bytedeco.javacpp.IntPointer;
5a9
> import java.nio.FloatBuffer;
7c11
< import org.bytedeco.javacpp.IntPointer;
---
> import java.nio.DoubleBuffer;
10,913c14,1144
< public class OpenBLASModified implements BLASModified, LAPACKModified {
<    public double asum(int n, double[] x, int incx) {
<       return openblas.cblas_dasum(n, x, incx);
<    }
< 
<    public float asum(int n, float[] x, int incx) {
<       return openblas.cblas_sasum(n, x, incx);
<    }
< 
<    public void axpy(int n, double alpha, double[] x, int incx, double[] y, int incy) {
<       openblas.cblas_daxpy(n, alpha, x, incx, y, incy);
<    }
< 
<    public void axpy(int n, float alpha, float[] x, int incx, float[] y, int incy) {
<       openblas.cblas_saxpy(n, alpha, x, incx, y, incy);
<    }
< 
<    public double dot(int n, double[] x, int incx, double[] y, int incy) {
<       return openblas.cblas_ddot(n, x, incx, y, incy);
<    }
< 
<    public float dot(int n, float[] x, int incx, float[] y, int incy) {
<       return openblas.cblas_sdot(n, x, incx, y, incy);
<    }
< 
<    public double nrm2(int n, double[] x, int incx) {
<       return openblas.cblas_dnrm2(n, x, incx);
<    }
< 
<    public float nrm2(int n, float[] x, int incx) {
<       return openblas.cblas_snrm2(n, x, incx);
<    }
< 
<    public void scal(int n, double alpha, double[] x, int incx) {
<       openblas.cblas_dscal(n, alpha, x, incx);
<    }
< 
<    public void scal(int n, float alpha, float[] x, int incx) {
<       openblas.cblas_sscal(n, alpha, x, incx);
<    }
< 
<    public void swap(int n, double[] x, int incx, double[] y, int incy) {
<       openblas.cblas_dswap(n, x, incx, y, incy);
<    }
< 
<    public void swap(int n, float[] x, int incx, float[] y, int incy) {
<       openblas.cblas_sswap(n, x, incx, y, incy);
<    }
< 
<    public long iamax(int n, double[] x, int incx) {
<       return openblas.cblas_idamax(n, x, incx);
<    }
< 
<    public long iamax(int n, float[] x, int incx) {
<       return openblas.cblas_isamax(n, x, incx);
<    }
< 
<    public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
<       openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
<       openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, double alpha, DoublePointer A, int lda, DoublePointer x, int incx, double beta, DoublePointer y, int incy) {
<       openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
<       openblas.cblas_sgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
<       openblas.cblas_sgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void symv(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
<       openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void symv(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
<       openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void symv(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoublePointer A, int lda, DoublePointer x, int incx, double beta, DoublePointer y, int incy) {
<       openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void symv(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
<       openblas.cblas_ssymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void symv(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
<       openblas.cblas_ssymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void spmv(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] A, double[] x, int incx, double beta, double[] y, int incy) {
<       openblas.cblas_dspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
<    }
< 
<    public void spmv(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer A, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
<       openblas.cblas_dspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
<    }
< 
<    public void spmv(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] A, float[] x, int incx, float beta, float[] y, int incy) {
<       openblas.cblas_sspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
<    }
< 
<    public void spmv(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer A, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
<       openblas.cblas_sspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
<    }
< 
<    public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, double[] A, int lda, double[] x, int incx) {
<       openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
<    }
< 
<    public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, DoubleBuffer A, int lda, DoubleBuffer x, int incx) {
<       openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
<    }
< 
<    public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, DoublePointer A, int lda, DoublePointer x, int incx) {
<       openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
<    }
< 
<    public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, float[] A, int lda, float[] x, int incx) {
<       openblas.cblas_strmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
<    }
< 
<    public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, FloatBuffer A, int lda, FloatBuffer x, int incx) {
<       openblas.cblas_strmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
<    }
< 
<    public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, double[] A, double[] x, int incx) {
<       openblas.cblas_dtpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
<    }
< 
<    public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, DoubleBuffer A, DoubleBuffer x, int incx) {
<       openblas.cblas_dtpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
<    }
< 
<    public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, float[] A, float[] x, int incx) {
<       openblas.cblas_stpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
<    }
< 
<    public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, FloatBuffer A, FloatBuffer x, int incx) {
<       openblas.cblas_stpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
<    }
< 
<    public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
<       openblas.cblas_dgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
<       openblas.cblas_dgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
<       openblas.cblas_sgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
<       openblas.cblas_sgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
<       openblas.cblas_dsbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
<       openblas.cblas_dsbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
<       openblas.cblas_ssbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
<       openblas.cblas_ssbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void ger(LayoutModified layout, int m, int n, double alpha, double[] x, int incx, double[] y, int incy, double[] A, int lda) {
<       openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
<    }
< 
<    public void ger(LayoutModified layout, int m, int n, double alpha, DoubleBuffer x, int incx, DoubleBuffer y, int incy, DoubleBuffer A, int lda) {
<       openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
<    }
< 
<    public void ger(LayoutModified layout, int m, int n, double alpha, DoublePointer x, int incx, DoublePointer y, int incy, DoublePointer A, int lda) {
<       openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
<    }
< 
<    public void ger(LayoutModified layout, int m, int n, float alpha, float[] x, int incx, float[] y, int incy, float[] A, int lda) {
<       openblas.cblas_sger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
<    }
< 
<    public void ger(LayoutModified layout, int m, int n, float alpha, FloatBuffer x, int incx, FloatBuffer y, int incy, FloatBuffer A, int lda) {
<       openblas.cblas_sger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
<    }
< 
<    public void syr(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] x, int incx, double[] A, int lda) {
<       openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
<    }
< 
<    public void syr(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer x, int incx, DoubleBuffer A, int lda) {
<       openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
<    }
< 
<    public void syr(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoublePointer x, int incx, DoublePointer A, int lda) {
<       openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
<    }
< 
<    public void syr(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] x, int incx, float[] A, int lda) {
<       openblas.cblas_ssyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
<    }
< 
<    public void syr(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer x, int incx, FloatBuffer A, int lda) {
<       openblas.cblas_ssyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
<    }
< 
<    public void spr(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] x, int incx, double[] A) {
<       openblas.cblas_dspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
<    }
< 
<    public void spr(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer x, int incx, DoubleBuffer A) {
<       openblas.cblas_dspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
<    }
< 
<    public void spr(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] x, int incx, float[] A) {
<       openblas.cblas_sspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
<    }
< 
<    public void spr(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer x, int incx, FloatBuffer A) {
<       openblas.cblas_sspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
<    }
< 
<    public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, double alpha, double[] A, int lda, double[] B, int ldb, double beta, double[] C, int ldc) {
<       openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, double alpha, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, double beta, DoubleBuffer C, int ldc) {
<       openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, double alpha, DoublePointer A, int lda, DoublePointer B, int ldb, double beta, DoublePointer C, int ldc) {
<       openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, float alpha, float[] A, int lda, float[] B, int ldb, float beta, float[] C, int ldc) {
<       openblas.cblas_sgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, float alpha, FloatBuffer A, int lda, FloatBuffer B, int ldb, float beta, FloatBuffer C, int ldc) {
<       openblas.cblas_sgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, double alpha, double[] A, int lda, double[] B, int ldb, double beta, double[] C, int ldc) {
<       openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, double alpha, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, double beta, DoubleBuffer C, int ldc) {
<       openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, double alpha, DoublePointer A, int lda, DoublePointer B, int ldb, double beta, DoublePointer C, int ldc) {
<       openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, float alpha, float[] A, int lda, float[] B, int ldb, float beta, float[] C, int ldc) {
<       openblas.cblas_ssymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, float alpha, FloatBuffer A, int lda, FloatBuffer B, int ldb, float beta, FloatBuffer C, int ldc) {
<       openblas.cblas_ssymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public int gesv(LayoutModified layout, int n, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gesv(LayoutModified layout, int n, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gesv(LayoutModified layout, int n, int nrhs, DoublePointer A, int lda, IntPointer ipiv, DoublePointer B, int ldb) {
<       return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gesv(LayoutModified layout, int n, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_sgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gesv(LayoutModified layout, int n, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoublePointer A, int lda, IntPointer ipiv, DoublePointer B, int ldb) {
<       return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_ssysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_ssysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
<    }
< 
<    public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
<    }
< 
<    public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_sspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
<    }
< 
<    public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
<    }
< 
<    public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
<       return openblas.LAPACKE_dposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
<       return openblas.LAPACKE_sposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, double[] B, int ldb) {
<       return openblas.LAPACKE_dppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
<    }
< 
<    public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
<    }
< 
<    public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, float[] B, int ldb) {
<       return openblas.LAPACKE_sppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
<    }
< 
<    public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
<    }
< 
<    public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_sgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
<       return openblas.LAPACKE_dgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
<       return openblas.LAPACKE_sgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int gelsy(LayoutModified layout, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb, int[] jpvt, double rcond, int[] rank) {
<       return openblas.LAPACKE_dgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
<    }
< 
<    public int gelsy(LayoutModified layout, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, IntBuffer jpvt, double rcond, IntBuffer rank) {
<       return openblas.LAPACKE_dgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
<    }
< 
<    public int gelsy(LayoutModified layout, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb, int[] jpvt, float rcond, int[] rank) {
<       return openblas.LAPACKE_sgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
<    }
< 
<    public int gelsy(LayoutModified layout, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb, IntBuffer jpvt, float rcond, IntBuffer rank) {
<       return openblas.LAPACKE_sgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
<    }
< 
<    public int gelss(LayoutModified layout, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb, double[] s, double rcond, int[] rank) {
<       return openblas.LAPACKE_dgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelss(LayoutModified layout, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer s, double rcond, IntBuffer rank) {
<       return openblas.LAPACKE_dgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelss(LayoutModified layout, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb, float[] s, float rcond, int[] rank) {
<       return openblas.LAPACKE_sgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelss(LayoutModified layout, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer s, float rcond, IntBuffer rank) {
<       return openblas.LAPACKE_sgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelsd(LayoutModified layout, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb, double[] s, double rcond, int[] rank) {
<       return openblas.LAPACKE_dgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelsd(LayoutModified layout, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer s, double rcond, IntBuffer rank) {
<       return openblas.LAPACKE_dgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelsd(LayoutModified layout, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb, float[] s, float rcond, int[] rank) {
<       return openblas.LAPACKE_sgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelsd(LayoutModified layout, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer s, float rcond, IntBuffer rank) {
<       return openblas.LAPACKE_sgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gglse(LayoutModified layout, int m, int n, int p, double[] A, int lda, double[] B, int ldb, double[] c, double[] d, double[] x) {
<       return openblas.LAPACKE_dgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
<    }
< 
<    public int gglse(LayoutModified layout, int m, int n, int p, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer c, DoubleBuffer d, DoubleBuffer x) {
<       return openblas.LAPACKE_dgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
<    }
< 
<    public int gglse(LayoutModified layout, int m, int n, int p, float[] A, int lda, float[] B, int ldb, float[] c, float[] d, float[] x) {
<       return openblas.LAPACKE_sgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
<    }
< 
<    public int gglse(LayoutModified layout, int m, int n, int p, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer c, FloatBuffer d, FloatBuffer x) {
<       return openblas.LAPACKE_sgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
<    }
< 
<    public int ggglm(LayoutModified layout, int n, int m, int p, double[] A, int lda, double[] B, int ldb, double[] d, double[] x, double[] y) {
<       return openblas.LAPACKE_dggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
<    }
< 
<    public int ggglm(LayoutModified layout, int n, int m, int p, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer d, DoubleBuffer x, DoubleBuffer y) {
<       return openblas.LAPACKE_dggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
<    }
< 
<    public int ggglm(LayoutModified layout, int n, int m, int p, float[] A, int lda, float[] B, int ldb, float[] d, float[] x, float[] y) {
<       return openblas.LAPACKE_sggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
<    }
< 
<    public int ggglm(LayoutModified layout, int n, int m, int p, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer d, FloatBuffer x, FloatBuffer y) {
<       return openblas.LAPACKE_sggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
<    }
< 
<    public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, double[] A, int lda, double[] wr, double[] wi, double[] Vl, int ldvl, double[] Vr, int ldvr) {
<       return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
<    }
< 
<    public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, DoubleBuffer A, int lda, DoubleBuffer wr, DoubleBuffer wi, DoubleBuffer Vl, int ldvl, DoubleBuffer Vr, int ldvr) {
<       return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
<    }
< 
<    public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, DoublePointer A, int lda, DoublePointer wr, DoublePointer wi, DoublePointer Vl, int ldvl, DoublePointer Vr, int ldvr) {
<       return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
<    }
< 
<    public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, float[] A, int lda, float[] wr, float[] wi, float[] Vl, int ldvl, float[] Vr, int ldvr) {
<       return openblas.LAPACKE_sgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
<    }
< 
<    public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, FloatBuffer A, int lda, FloatBuffer wr, FloatBuffer wi, FloatBuffer Vl, int ldvl, FloatBuffer Vr, int ldvr) {
<       return openblas.LAPACKE_sgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
<    }
< 
<    public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, double[] A, int lda, double[] w) {
<       return openblas.LAPACKE_dsyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, DoubleBuffer A, int lda, DoubleBuffer w) {
<       return openblas.LAPACKE_dsyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, float[] A, int lda, float[] w) {
<       return openblas.LAPACKE_ssyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, FloatBuffer A, int lda, FloatBuffer w) {
<       return openblas.LAPACKE_ssyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, double[] A, int lda, double[] w) {
<       return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, DoubleBuffer A, int lda, DoubleBuffer w) {
<       return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, DoublePointer A, int lda, DoublePointer w) {
<       return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, float[] A, int lda, float[] w) {
<       return openblas.LAPACKE_ssyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, FloatBuffer A, int lda, FloatBuffer w) {
<       return openblas.LAPACKE_ssyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, double[] A, int lda, double vl, double vu, int il, int iu, double abstol, int[] m, double[] w, double[] Z, int ldz, int[] isuppz) {
<       return openblas.LAPACKE_dsyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
<    }
< 
<    public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, DoubleBuffer A, int lda, double vl, double vu, int il, int iu, double abstol, IntBuffer m, DoubleBuffer w, DoubleBuffer Z, int ldz, IntBuffer isuppz) {
<       return openblas.LAPACKE_dsyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
<    }
< 
<    public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, float[] A, int lda, float vl, float vu, int il, int iu, float abstol, int[] m, float[] w, float[] Z, int ldz, int[] isuppz) {
<       return openblas.LAPACKE_ssyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
<    }
< 
<    public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, FloatBuffer A, int lda, float vl, float vu, int il, int iu, float abstol, IntBuffer m, FloatBuffer w, FloatBuffer Z, int ldz, IntBuffer isuppz) {
<       return openblas.LAPACKE_ssyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
<    }
< 
<    public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, double[] A, int lda, double[] s, double[] U, int ldu, double[] VT, int ldvt, double[] superb) {
<       return openblas.LAPACKE_dgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
<    }
< 
<    public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, DoubleBuffer A, int lda, DoubleBuffer s, DoubleBuffer U, int ldu, DoubleBuffer VT, int ldvt, DoubleBuffer superb) {
<       return openblas.LAPACKE_dgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
<    }
< 
<    public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, float[] A, int lda, float[] s, float[] U, int ldu, float[] VT, int ldvt, float[] superb) {
<       return openblas.LAPACKE_sgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
<    }
< 
<    public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, FloatBuffer A, int lda, FloatBuffer s, FloatBuffer U, int ldu, FloatBuffer VT, int ldvt, FloatBuffer superb) {
<       return openblas.LAPACKE_sgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
<    }
< 
<    public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, double[] A, int lda, double[] s, double[] U, int ldu, double[] VT, int ldvt) {
<       return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
<    }
< 
<    public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, DoubleBuffer A, int lda, DoubleBuffer s, DoubleBuffer U, int ldu, DoubleBuffer VT, int ldvt) {
<       return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
<    }
< 
<    public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, DoublePointer A, int lda, DoublePointer s, DoublePointer U, int ldu, DoublePointer VT, int ldvt) {
<       return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
<    }
< 
<    public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, float[] A, int lda, float[] s, float[] U, int ldu, float[] VT, int ldvt) {
<       return openblas.LAPACKE_sgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
<    }
< 
<    public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, FloatBuffer A, int lda, FloatBuffer s, FloatBuffer U, int ldu, FloatBuffer VT, int ldvt) {
<       return openblas.LAPACKE_sgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
<    }
< 
<    public int getrf(LayoutModified layout, int m, int n, double[] A, int lda, int[] ipiv) {
<       return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf(LayoutModified layout, int m, int n, DoubleBuffer A, int lda, IntBuffer ipiv) {
<       return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf(LayoutModified layout, int m, int n, DoublePointer A, int lda, IntPointer ipiv) {
<       return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf(LayoutModified layout, int m, int n, float[] A, int lda, int[] ipiv) {
<       return openblas.LAPACKE_sgetrf(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf(LayoutModified layout, int m, int n, FloatBuffer A, int lda, IntBuffer ipiv) {
<       return openblas.LAPACKE_sgetrf(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf2(LayoutModified layout, int m, int n, double[] A, int lda, int[] ipiv) {
<       return openblas.LAPACKE_dgetrf2(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf2(LayoutModified layout, int m, int n, DoubleBuffer A, int lda, IntBuffer ipiv) {
<       return openblas.LAPACKE_dgetrf2(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf2(LayoutModified layout, int m, int n, float[] A, int lda, int[] ipiv) {
<       return openblas.LAPACKE_sgetrf2(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf2(LayoutModified layout, int m, int n, FloatBuffer A, int lda, IntBuffer ipiv) {
<       return openblas.LAPACKE_sgetrf2(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, double[] AB, int ldab, int[] ipiv) {
<       return openblas.LAPACKE_dgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
<    }
< 
<    public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, DoubleBuffer AB, int ldab, IntBuffer ipiv) {
<       return openblas.LAPACKE_dgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
<    }
< 
<    public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, float[] AB, int ldab, int[] ipiv) {
<       return openblas.LAPACKE_sgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
<    }
< 
<    public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, FloatBuffer AB, int ldab, IntBuffer ipiv) {
<       return openblas.LAPACKE_sgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
<    }
< 
<    public int sptrf(LayoutModified layout, UPLOModified uplo, int n, double[] AP, int[] ipiv) {
<       return openblas.LAPACKE_dsptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
<    }
< 
<    public int sptrf(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer AP, IntBuffer ipiv) {
<       return openblas.LAPACKE_dsptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
<    }
< 
<    public int sptrf(LayoutModified layout, UPLOModified uplo, int n, float[] AP, int[] ipiv) {
<       return openblas.LAPACKE_ssptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
<    }
< 
<    public int sptrf(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer AP, IntBuffer ipiv) {
<       return openblas.LAPACKE_ssptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
<    }
< 
<    public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, DoublePointer A, int lda, IntPointer ipiv, DoublePointer B, int ldb) {
<       return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_sgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_sgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] AP, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dsptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
<    }
< 
<    public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer AP, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dsptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
<    }
< 
<    public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] AP, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_ssptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
<    }
< 
<    public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer AP, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_ssptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
<    }
< 
<    public int potrf(LayoutModified layout, UPLOModified uplo, int n, double[] A, int lda) {
<       return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer A, int lda) {
<       return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf(LayoutModified layout, UPLOModified uplo, int n, DoublePointer A, int lda) {
<       return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf(LayoutModified layout, UPLOModified uplo, int n, float[] A, int lda) {
<       return openblas.LAPACKE_spotrf(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer A, int lda) {
<       return openblas.LAPACKE_spotrf(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf2(LayoutModified layout, UPLOModified uplo, int n, double[] A, int lda) {
<       return openblas.LAPACKE_dpotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf2(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer A, int lda) {
<       return openblas.LAPACKE_dpotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf2(LayoutModified layout, UPLOModified uplo, int n, float[] A, int lda) {
<       return openblas.LAPACKE_spotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf2(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer A, int lda) {
<       return openblas.LAPACKE_spotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, double[] AB, int ldab) {
<       return openblas.LAPACKE_dpbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
<    }
< 
<    public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, DoubleBuffer AB, int ldab) {
<       return openblas.LAPACKE_dpbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
<    }
< 
<    public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, float[] AB, int ldab) {
<       return openblas.LAPACKE_spbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
<    }
< 
<    public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, FloatBuffer AB, int ldab) {
<       return openblas.LAPACKE_spbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
<    }
< 
<    public int pptrf(LayoutModified layout, UPLOModified uplo, int n, double[] AP) {
<       return openblas.LAPACKE_dpptrf(layout.lapack(), uplo.lapack(), n, AP);
<    }
< 
<    public int pptrf(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer AP) {
<       return openblas.LAPACKE_dpptrf(layout.lapack(), uplo.lapack(), n, AP);
<    }
< 
<    public int pptrf(LayoutModified layout, UPLOModified uplo, int n, float[] AP) {
<       return openblas.LAPACKE_spptrf(layout.lapack(), uplo.lapack(), n, AP);
<    }
< 
<    public int pptrf(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer AP) {
<       return openblas.LAPACKE_spptrf(layout.lapack(), uplo.lapack(), n, AP);
<    }
< 
<    public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
<       return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoublePointer A, int lda, DoublePointer B, int ldb) {
<       return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
<       return openblas.LAPACKE_spotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_spotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, double[] AB, int ldab, double[] B, int ldb) {
<       return openblas.LAPACKE_dpbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
<    }
< 
<    public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, DoubleBuffer AB, int ldab, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dpbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
<    }
< 
<    public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, float[] AB, int ldab, float[] B, int ldb) {
<       return openblas.LAPACKE_spbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
<    }
< 
<    public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, FloatBuffer AB, int ldab, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_spbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
<    }
< 
<    public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] AP, double[] B, int ldb) {
<       return openblas.LAPACKE_dpptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
<    }
< 
<    public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer AP, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dpptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
<    }
< 
<    public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] AP, float[] B, int ldb) {
<       return openblas.LAPACKE_spptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
<    }
< 
<    public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer AP, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_spptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
<    }
< 
<    public int geqrf(LayoutModified layout, int m, int n, double[] A, int lda, double[] tau) {
<       return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
<    }
< 
<    public int geqrf(LayoutModified layout, int m, int n, DoubleBuffer A, int lda, DoubleBuffer tau) {
<       return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
<    }
< 
<    public int geqrf(LayoutModified layout, int m, int n, DoublePointer A, int lda, DoublePointer tau) {
<       return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
<    }
< 
<    public int geqrf(LayoutModified layout, int m, int n, float[] A, int lda, float[] tau) {
<       return openblas.LAPACKE_sgeqrf(layout.lapack(), m, n, A, lda, tau);
<    }
< 
<    public int geqrf(LayoutModified layout, int m, int n, FloatBuffer A, int lda, FloatBuffer tau) {
<       return openblas.LAPACKE_sgeqrf(layout.lapack(), m, n, A, lda, tau);
<    }
< 
<    public int orgqr(LayoutModified layout, int m, int n, int k, double[] A, int lda, double[] tau) {
<       return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
<    }
< 
<    public int orgqr(LayoutModified layout, int m, int n, int k, DoubleBuffer A, int lda, DoubleBuffer tau) {
<       return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
<    }
< 
<    public int orgqr(LayoutModified layout, int m, int n, int k, DoublePointer A, int lda, DoublePointer tau) {
<       return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
<    }
< 
<    public int orgqr(LayoutModified layout, int m, int n, int k, float[] A, int lda, float[] tau) {
<       return openblas.LAPACKE_sorgqr(layout.lapack(), m, n, k, A, lda, tau);
<    }
< 
<    public int orgqr(LayoutModified layout, int m, int n, int k, FloatBuffer A, int lda, FloatBuffer tau) {
<       return openblas.LAPACKE_sorgqr(layout.lapack(), m, n, k, A, lda, tau);
<    }
< 
<    public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, double[] A, int lda, double[] tau, double[] C, int ldc) {
<       return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
<    }
< 
<    public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, DoubleBuffer A, int lda, DoubleBuffer tau, DoubleBuffer C, int ldc) {
<       return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
<    }
< 
<    public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, DoublePointer A, int lda, DoublePointer tau, DoublePointer C, int ldc) {
<       return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
<    }
< 
<    public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, float[] A, int lda, float[] tau, float[] C, int ldc) {
<       return openblas.LAPACKE_sormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
<    }
< 
<    public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, FloatBuffer A, int lda, FloatBuffer tau, FloatBuffer C, int ldc) {
<       return openblas.LAPACKE_sormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
<    }
< 
<    public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
<       return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, DoublePointer A, int lda, DoublePointer B, int ldb) {
<       return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
<       return openblas.LAPACKE_strtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_strtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
<    }
---
> public class OpenBLASModified implements BLASModified, LAPACKModified
> {
>     @Override
>     public double asum(final int n, final double[] x, final int incx) {
>         return openblas.cblas_dasum(n, x, incx);
>     }
>     
>     @Override
>     public float asum(final int n, final float[] x, final int incx) {
>         return openblas.cblas_sasum(n, x, incx);
>     }
>     
>     @Override
>     public void axpy(final int n, final double alpha, final double[] x, final int incx, final double[] y, final int incy) {
>         openblas.cblas_daxpy(n, alpha, x, incx, y, incy);
>     }
>     
>     @Override
>     public void axpy(final int n, final float alpha, final float[] x, final int incx, final float[] y, final int incy) {
>         openblas.cblas_saxpy(n, alpha, x, incx, y, incy);
>     }
>     
>     @Override
>     public double dot(final int n, final double[] x, final int incx, final double[] y, final int incy) {
>         return openblas.cblas_ddot(n, x, incx, y, incy);
>     }
>     
>     @Override
>     public float dot(final int n, final float[] x, final int incx, final float[] y, final int incy) {
>         return openblas.cblas_sdot(n, x, incx, y, incy);
>     }
>     
>     @Override
>     public double nrm2(final int n, final double[] x, final int incx) {
>         return openblas.cblas_dnrm2(n, x, incx);
>     }
>     
>     @Override
>     public float nrm2(final int n, final float[] x, final int incx) {
>         return openblas.cblas_snrm2(n, x, incx);
>     }
>     
>     @Override
>     public void scal(final int n, final double alpha, final double[] x, final int incx) {
>         openblas.cblas_dscal(n, alpha, x, incx);
>     }
>     
>     @Override
>     public void scal(final int n, final float alpha, final float[] x, final int incx) {
>         openblas.cblas_sscal(n, alpha, x, incx);
>     }
>     
>     @Override
>     public void swap(final int n, final double[] x, final int incx, final double[] y, final int incy) {
>         openblas.cblas_dswap(n, x, incx, y, incy);
>     }
>     
>     @Override
>     public void swap(final int n, final float[] x, final int incx, final float[] y, final int incy) {
>         openblas.cblas_sswap(n, x, incx, y, incy);
>     }
>     
>     @Override
>     public long iamax(final int n, final double[] x, final int incx) {
>         return openblas.cblas_idamax(n, x, incx);
>     }
>     
>     @Override
>     public long iamax(final int n, final float[] x, final int incx) {
>         return openblas.cblas_isamax(n, x, incx);
>     }
>     
>     @Override
>     public void gemv(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final double alpha, final double[] A, final int lda, final double[] x, final int incx, final double beta, final double[] y, final int incy) {
>         openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void gemv(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final double alpha, final DoubleBuffer A, final int lda, final DoubleBuffer x, final int incx, final double beta, final DoubleBuffer y, final int incy) {
>         openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void gemv(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final double alpha, final DoublePointer A, final int lda, final DoublePointer x, final int incx, final double beta, final DoublePointer y, final int incy) {
>         openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void gemv(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final float alpha, final float[] A, final int lda, final float[] x, final int incx, final float beta, final float[] y, final int incy) {
>         openblas.cblas_sgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void gemv(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final float alpha, final FloatBuffer A, final int lda, final FloatBuffer x, final int incx, final float beta, final FloatBuffer y, final int incy) {
>         openblas.cblas_sgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void symv(final LayoutModified layout, final UPLOModified uplo, final int n, final double alpha, final double[] A, final int lda, final double[] x, final int incx, final double beta, final double[] y, final int incy) {
>         openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void symv(final LayoutModified layout, final UPLOModified uplo, final int n, final double alpha, final DoubleBuffer A, final int lda, final DoubleBuffer x, final int incx, final double beta, final DoubleBuffer y, final int incy) {
>         openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void symv(final LayoutModified layout, final UPLOModified uplo, final int n, final double alpha, final DoublePointer A, final int lda, final DoublePointer x, final int incx, final double beta, final DoublePointer y, final int incy) {
>         openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void symv(final LayoutModified layout, final UPLOModified uplo, final int n, final float alpha, final float[] A, final int lda, final float[] x, final int incx, final float beta, final float[] y, final int incy) {
>         openblas.cblas_ssymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void symv(final LayoutModified layout, final UPLOModified uplo, final int n, final float alpha, final FloatBuffer A, final int lda, final FloatBuffer x, final int incx, final float beta, final FloatBuffer y, final int incy) {
>         openblas.cblas_ssymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void spmv(final LayoutModified layout, final UPLOModified uplo, final int n, final double alpha, final double[] A, final double[] x, final int incx, final double beta, final double[] y, final int incy) {
>         openblas.cblas_dspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void spmv(final LayoutModified layout, final UPLOModified uplo, final int n, final double alpha, final DoubleBuffer A, final DoubleBuffer x, final int incx, final double beta, final DoubleBuffer y, final int incy) {
>         openblas.cblas_dspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void spmv(final LayoutModified layout, final UPLOModified uplo, final int n, final float alpha, final float[] A, final float[] x, final int incx, final float beta, final float[] y, final int incy) {
>         openblas.cblas_sspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void spmv(final LayoutModified layout, final UPLOModified uplo, final int n, final float alpha, final FloatBuffer A, final FloatBuffer x, final int incx, final float beta, final FloatBuffer y, final int incy) {
>         openblas.cblas_sspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void trmv(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final double[] A, final int lda, final double[] x, final int incx) {
>         openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
>     }
>     
>     @Override
>     public void trmv(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final DoubleBuffer A, final int lda, final DoubleBuffer x, final int incx) {
>         openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
>     }
>     
>     @Override
>     public void trmv(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final DoublePointer A, final int lda, final DoublePointer x, final int incx) {
>         openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
>     }
>     
>     @Override
>     public void trmv(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final float[] A, final int lda, final float[] x, final int incx) {
>         openblas.cblas_strmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
>     }
>     
>     @Override
>     public void trmv(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final FloatBuffer A, final int lda, final FloatBuffer x, final int incx) {
>         openblas.cblas_strmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
>     }
>     
>     @Override
>     public void tpmv(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final double[] A, final double[] x, final int incx) {
>         openblas.cblas_dtpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
>     }
>     
>     @Override
>     public void tpmv(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final DoubleBuffer A, final DoubleBuffer x, final int incx) {
>         openblas.cblas_dtpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
>     }
>     
>     @Override
>     public void tpmv(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final float[] A, final float[] x, final int incx) {
>         openblas.cblas_stpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
>     }
>     
>     @Override
>     public void tpmv(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final FloatBuffer A, final FloatBuffer x, final int incx) {
>         openblas.cblas_stpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
>     }
>     
>     @Override
>     public void gbmv(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final int kl, final int ku, final double alpha, final double[] A, final int lda, final double[] x, final int incx, final double beta, final double[] y, final int incy) {
>         openblas.cblas_dgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void gbmv(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final int kl, final int ku, final double alpha, final DoubleBuffer A, final int lda, final DoubleBuffer x, final int incx, final double beta, final DoubleBuffer y, final int incy) {
>         openblas.cblas_dgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void gbmv(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final int kl, final int ku, final float alpha, final float[] A, final int lda, final float[] x, final int incx, final float beta, final float[] y, final int incy) {
>         openblas.cblas_sgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void gbmv(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final int kl, final int ku, final float alpha, final FloatBuffer A, final int lda, final FloatBuffer x, final int incx, final float beta, final FloatBuffer y, final int incy) {
>         openblas.cblas_sgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void sbmv(final LayoutModified layout, final UPLOModified uplo, final int n, final int k, final double alpha, final double[] A, final int lda, final double[] x, final int incx, final double beta, final double[] y, final int incy) {
>         openblas.cblas_dsbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void sbmv(final LayoutModified layout, final UPLOModified uplo, final int n, final int k, final double alpha, final DoubleBuffer A, final int lda, final DoubleBuffer x, final int incx, final double beta, final DoubleBuffer y, final int incy) {
>         openblas.cblas_dsbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void sbmv(final LayoutModified layout, final UPLOModified uplo, final int n, final int k, final float alpha, final float[] A, final int lda, final float[] x, final int incx, final float beta, final float[] y, final int incy) {
>         openblas.cblas_ssbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void sbmv(final LayoutModified layout, final UPLOModified uplo, final int n, final int k, final float alpha, final FloatBuffer A, final int lda, final FloatBuffer x, final int incx, final float beta, final FloatBuffer y, final int incy) {
>         openblas.cblas_ssbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
>     }
>     
>     @Override
>     public void ger(final LayoutModified layout, final int m, final int n, final double alpha, final double[] x, final int incx, final double[] y, final int incy, final double[] A, final int lda) {
>         openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
>     }
>     
>     @Override
>     public void ger(final LayoutModified layout, final int m, final int n, final double alpha, final DoubleBuffer x, final int incx, final DoubleBuffer y, final int incy, final DoubleBuffer A, final int lda) {
>         openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
>     }
>     
>     @Override
>     public void ger(final LayoutModified layout, final int m, final int n, final double alpha, final DoublePointer x, final int incx, final DoublePointer y, final int incy, final DoublePointer A, final int lda) {
>         openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
>     }
>     
>     @Override
>     public void ger(final LayoutModified layout, final int m, final int n, final float alpha, final float[] x, final int incx, final float[] y, final int incy, final float[] A, final int lda) {
>         openblas.cblas_sger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
>     }
>     
>     @Override
>     public void ger(final LayoutModified layout, final int m, final int n, final float alpha, final FloatBuffer x, final int incx, final FloatBuffer y, final int incy, final FloatBuffer A, final int lda) {
>         openblas.cblas_sger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
>     }
>     
>     @Override
>     public void syr(final LayoutModified layout, final UPLOModified uplo, final int n, final double alpha, final double[] x, final int incx, final double[] A, final int lda) {
>         openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
>     }
>     
>     @Override
>     public void syr(final LayoutModified layout, final UPLOModified uplo, final int n, final double alpha, final DoubleBuffer x, final int incx, final DoubleBuffer A, final int lda) {
>         openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
>     }
>     
>     @Override
>     public void syr(final LayoutModified layout, final UPLOModified uplo, final int n, final double alpha, final DoublePointer x, final int incx, final DoublePointer A, final int lda) {
>         openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
>     }
>     
>     @Override
>     public void syr(final LayoutModified layout, final UPLOModified uplo, final int n, final float alpha, final float[] x, final int incx, final float[] A, final int lda) {
>         openblas.cblas_ssyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
>     }
>     
>     @Override
>     public void syr(final LayoutModified layout, final UPLOModified uplo, final int n, final float alpha, final FloatBuffer x, final int incx, final FloatBuffer A, final int lda) {
>         openblas.cblas_ssyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
>     }
>     
>     @Override
>     public void spr(final LayoutModified layout, final UPLOModified uplo, final int n, final double alpha, final double[] x, final int incx, final double[] A) {
>         openblas.cblas_dspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
>     }
>     
>     @Override
>     public void spr(final LayoutModified layout, final UPLOModified uplo, final int n, final double alpha, final DoubleBuffer x, final int incx, final DoubleBuffer A) {
>         openblas.cblas_dspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
>     }
>     
>     @Override
>     public void spr(final LayoutModified layout, final UPLOModified uplo, final int n, final float alpha, final float[] x, final int incx, final float[] A) {
>         openblas.cblas_sspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
>     }
>     
>     @Override
>     public void spr(final LayoutModified layout, final UPLOModified uplo, final int n, final float alpha, final FloatBuffer x, final int incx, final FloatBuffer A) {
>         openblas.cblas_sspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
>     }
>     
>     @Override
>     public void gemm(final LayoutModified layout, final TransposeModified transA, final TransposeModified transB, final int m, final int n, final int k, final double alpha, final double[] A, final int lda, final double[] B, final int ldb, final double beta, final double[] C, final int ldc) {
>         openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
>     }
>     
>     @Override
>     public void gemm(final LayoutModified layout, final TransposeModified transA, final TransposeModified transB, final int m, final int n, final int k, final double alpha, final DoubleBuffer A, final int lda, final DoubleBuffer B, final int ldb, final double beta, final DoubleBuffer C, final int ldc) {
>         openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
>     }
>     
>     @Override
>     public void gemm(final LayoutModified layout, final TransposeModified transA, final TransposeModified transB, final int m, final int n, final int k, final double alpha, final DoublePointer A, final int lda, final DoublePointer B, final int ldb, final double beta, final DoublePointer C, final int ldc) {
>         openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
>     }
>     
>     @Override
>     public void gemm(final LayoutModified layout, final TransposeModified transA, final TransposeModified transB, final int m, final int n, final int k, final float alpha, final float[] A, final int lda, final float[] B, final int ldb, final float beta, final float[] C, final int ldc) {
>         openblas.cblas_sgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
>     }
>     
>     @Override
>     public void gemm(final LayoutModified layout, final TransposeModified transA, final TransposeModified transB, final int m, final int n, final int k, final float alpha, final FloatBuffer A, final int lda, final FloatBuffer B, final int ldb, final float beta, final FloatBuffer C, final int ldc) {
>         openblas.cblas_sgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
>     }
>     
>     @Override
>     public void symm(final LayoutModified layout, final SideModified side, final UPLOModified uplo, final int m, final int n, final double alpha, final double[] A, final int lda, final double[] B, final int ldb, final double beta, final double[] C, final int ldc) {
>         openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
>     }
>     
>     @Override
>     public void symm(final LayoutModified layout, final SideModified side, final UPLOModified uplo, final int m, final int n, final double alpha, final DoubleBuffer A, final int lda, final DoubleBuffer B, final int ldb, final double beta, final DoubleBuffer C, final int ldc) {
>         openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
>     }
>     
>     @Override
>     public void symm(final LayoutModified layout, final SideModified side, final UPLOModified uplo, final int m, final int n, final double alpha, final DoublePointer A, final int lda, final DoublePointer B, final int ldb, final double beta, final DoublePointer C, final int ldc) {
>         openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
>     }
>     
>     @Override
>     public void symm(final LayoutModified layout, final SideModified side, final UPLOModified uplo, final int m, final int n, final float alpha, final float[] A, final int lda, final float[] B, final int ldb, final float beta, final float[] C, final int ldc) {
>         openblas.cblas_ssymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
>     }
>     
>     @Override
>     public void symm(final LayoutModified layout, final SideModified side, final UPLOModified uplo, final int m, final int n, final float alpha, final FloatBuffer A, final int lda, final FloatBuffer B, final int ldb, final float beta, final FloatBuffer C, final int ldc) {
>         openblas.cblas_ssymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
>     }
>     
>     @Override
>     public int gesv(final LayoutModified layout, final int n, final int nrhs, final double[] A, final int lda, final int[] ipiv, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gesv(final LayoutModified layout, final int n, final int nrhs, final DoubleBuffer A, final int lda, final IntBuffer ipiv, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gesv(final LayoutModified layout, final int n, final int nrhs, final DoublePointer A, final int lda, final IntPointer ipiv, final DoublePointer B, final int ldb) {
>         return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gesv(final LayoutModified layout, final int n, final int nrhs, final float[] A, final int lda, final int[] ipiv, final float[] B, final int ldb) {
>         return openblas.LAPACKE_sgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gesv(final LayoutModified layout, final int n, final int nrhs, final FloatBuffer A, final int lda, final IntBuffer ipiv, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_sgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int sysv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final double[] A, final int lda, final int[] ipiv, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int sysv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final DoubleBuffer A, final int lda, final IntBuffer ipiv, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int sysv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final DoublePointer A, final int lda, final IntPointer ipiv, final DoublePointer B, final int ldb) {
>         return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int sysv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final float[] A, final int lda, final int[] ipiv, final float[] B, final int ldb) {
>         return openblas.LAPACKE_ssysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int sysv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final FloatBuffer A, final int lda, final IntBuffer ipiv, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_ssysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int spsv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final double[] A, final int[] ipiv, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int spsv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final DoubleBuffer A, final IntBuffer ipiv, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int spsv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final float[] A, final int[] ipiv, final float[] B, final int ldb) {
>         return openblas.LAPACKE_sspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int spsv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final FloatBuffer A, final IntBuffer ipiv, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_sspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int posv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final double[] A, final int lda, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int posv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final DoubleBuffer A, final int lda, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int posv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final float[] A, final int lda, final float[] B, final int ldb) {
>         return openblas.LAPACKE_sposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int posv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final FloatBuffer A, final int lda, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_sposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int ppsv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final double[] A, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
>     }
>     
>     @Override
>     public int ppsv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final DoubleBuffer A, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
>     }
>     
>     @Override
>     public int ppsv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final float[] A, final float[] B, final int ldb) {
>         return openblas.LAPACKE_sppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
>     }
>     
>     @Override
>     public int ppsv(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final FloatBuffer A, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_sppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
>     }
>     
>     @Override
>     public int gbsv(final LayoutModified layout, final int n, final int kl, final int ku, final int nrhs, final double[] A, final int lda, final int[] ipiv, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gbsv(final LayoutModified layout, final int n, final int kl, final int ku, final int nrhs, final DoubleBuffer A, final int lda, final IntBuffer ipiv, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gbsv(final LayoutModified layout, final int n, final int kl, final int ku, final int nrhs, final float[] A, final int lda, final int[] ipiv, final float[] B, final int ldb) {
>         return openblas.LAPACKE_sgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gbsv(final LayoutModified layout, final int n, final int kl, final int ku, final int nrhs, final FloatBuffer A, final int lda, final IntBuffer ipiv, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_sgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gels(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final int nrhs, final double[] A, final int lda, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int gels(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final int nrhs, final DoubleBuffer A, final int lda, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int gels(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final int nrhs, final float[] A, final int lda, final float[] B, final int ldb) {
>         return openblas.LAPACKE_sgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int gels(final LayoutModified layout, final TransposeModified trans, final int m, final int n, final int nrhs, final FloatBuffer A, final int lda, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_sgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int gelsy(final LayoutModified layout, final int m, final int n, final int nrhs, final double[] A, final int lda, final double[] B, final int ldb, final int[] jpvt, final double rcond, final int[] rank) {
>         return openblas.LAPACKE_dgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
>     }
>     
>     @Override
>     public int gelsy(final LayoutModified layout, final int m, final int n, final int nrhs, final DoubleBuffer A, final int lda, final DoubleBuffer B, final int ldb, final IntBuffer jpvt, final double rcond, final IntBuffer rank) {
>         return openblas.LAPACKE_dgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
>     }
>     
>     @Override
>     public int gelsy(final LayoutModified layout, final int m, final int n, final int nrhs, final float[] A, final int lda, final float[] B, final int ldb, final int[] jpvt, final float rcond, final int[] rank) {
>         return openblas.LAPACKE_sgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
>     }
>     
>     @Override
>     public int gelsy(final LayoutModified layout, final int m, final int n, final int nrhs, final FloatBuffer A, final int lda, final FloatBuffer B, final int ldb, final IntBuffer jpvt, final float rcond, final IntBuffer rank) {
>         return openblas.LAPACKE_sgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
>     }
>     
>     @Override
>     public int gelss(final LayoutModified layout, final int m, final int n, final int nrhs, final double[] A, final int lda, final double[] B, final int ldb, final double[] s, final double rcond, final int[] rank) {
>         return openblas.LAPACKE_dgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
>     }
>     
>     @Override
>     public int gelss(final LayoutModified layout, final int m, final int n, final int nrhs, final DoubleBuffer A, final int lda, final DoubleBuffer B, final int ldb, final DoubleBuffer s, final double rcond, final IntBuffer rank) {
>         return openblas.LAPACKE_dgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
>     }
>     
>     @Override
>     public int gelss(final LayoutModified layout, final int m, final int n, final int nrhs, final float[] A, final int lda, final float[] B, final int ldb, final float[] s, final float rcond, final int[] rank) {
>         return openblas.LAPACKE_sgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
>     }
>     
>     @Override
>     public int gelss(final LayoutModified layout, final int m, final int n, final int nrhs, final FloatBuffer A, final int lda, final FloatBuffer B, final int ldb, final FloatBuffer s, final float rcond, final IntBuffer rank) {
>         return openblas.LAPACKE_sgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
>     }
>     
>     @Override
>     public int gelsd(final LayoutModified layout, final int m, final int n, final int nrhs, final double[] A, final int lda, final double[] B, final int ldb, final double[] s, final double rcond, final int[] rank) {
>         return openblas.LAPACKE_dgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
>     }
>     
>     @Override
>     public int gelsd(final LayoutModified layout, final int m, final int n, final int nrhs, final DoubleBuffer A, final int lda, final DoubleBuffer B, final int ldb, final DoubleBuffer s, final double rcond, final IntBuffer rank) {
>         return openblas.LAPACKE_dgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
>     }
>     
>     @Override
>     public int gelsd(final LayoutModified layout, final int m, final int n, final int nrhs, final float[] A, final int lda, final float[] B, final int ldb, final float[] s, final float rcond, final int[] rank) {
>         return openblas.LAPACKE_sgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
>     }
>     
>     @Override
>     public int gelsd(final LayoutModified layout, final int m, final int n, final int nrhs, final FloatBuffer A, final int lda, final FloatBuffer B, final int ldb, final FloatBuffer s, final float rcond, final IntBuffer rank) {
>         return openblas.LAPACKE_sgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
>     }
>     
>     @Override
>     public int gglse(final LayoutModified layout, final int m, final int n, final int p, final double[] A, final int lda, final double[] B, final int ldb, final double[] c, final double[] d, final double[] x) {
>         return openblas.LAPACKE_dgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
>     }
>     
>     @Override
>     public int gglse(final LayoutModified layout, final int m, final int n, final int p, final DoubleBuffer A, final int lda, final DoubleBuffer B, final int ldb, final DoubleBuffer c, final DoubleBuffer d, final DoubleBuffer x) {
>         return openblas.LAPACKE_dgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
>     }
>     
>     @Override
>     public int gglse(final LayoutModified layout, final int m, final int n, final int p, final float[] A, final int lda, final float[] B, final int ldb, final float[] c, final float[] d, final float[] x) {
>         return openblas.LAPACKE_sgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
>     }
>     
>     @Override
>     public int gglse(final LayoutModified layout, final int m, final int n, final int p, final FloatBuffer A, final int lda, final FloatBuffer B, final int ldb, final FloatBuffer c, final FloatBuffer d, final FloatBuffer x) {
>         return openblas.LAPACKE_sgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
>     }
>     
>     @Override
>     public int ggglm(final LayoutModified layout, final int n, final int m, final int p, final double[] A, final int lda, final double[] B, final int ldb, final double[] d, final double[] x, final double[] y) {
>         return openblas.LAPACKE_dggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
>     }
>     
>     @Override
>     public int ggglm(final LayoutModified layout, final int n, final int m, final int p, final DoubleBuffer A, final int lda, final DoubleBuffer B, final int ldb, final DoubleBuffer d, final DoubleBuffer x, final DoubleBuffer y) {
>         return openblas.LAPACKE_dggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
>     }
>     
>     @Override
>     public int ggglm(final LayoutModified layout, final int n, final int m, final int p, final float[] A, final int lda, final float[] B, final int ldb, final float[] d, final float[] x, final float[] y) {
>         return openblas.LAPACKE_sggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
>     }
>     
>     @Override
>     public int ggglm(final LayoutModified layout, final int n, final int m, final int p, final FloatBuffer A, final int lda, final FloatBuffer B, final int ldb, final FloatBuffer d, final FloatBuffer x, final FloatBuffer y) {
>         return openblas.LAPACKE_sggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
>     }
>     
>     @Override
>     public int geev(final LayoutModified layout, final EVDJobModified jobvl, final EVDJobModified jobvr, final int n, final double[] A, final int lda, final double[] wr, final double[] wi, final double[] Vl, final int ldvl, final double[] Vr, final int ldvr) {
>         return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
>     }
>     
>     @Override
>     public int geev(final LayoutModified layout, final EVDJobModified jobvl, final EVDJobModified jobvr, final int n, final DoubleBuffer A, final int lda, final DoubleBuffer wr, final DoubleBuffer wi, final DoubleBuffer Vl, final int ldvl, final DoubleBuffer Vr, final int ldvr) {
>         return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
>     }
>     
>     @Override
>     public int geev(final LayoutModified layout, final EVDJobModified jobvl, final EVDJobModified jobvr, final int n, final DoublePointer A, final int lda, final DoublePointer wr, final DoublePointer wi, final DoublePointer Vl, final int ldvl, final DoublePointer Vr, final int ldvr) {
>         return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
>     }
>     
>     @Override
>     public int geev(final LayoutModified layout, final EVDJobModified jobvl, final EVDJobModified jobvr, final int n, final float[] A, final int lda, final float[] wr, final float[] wi, final float[] Vl, final int ldvl, final float[] Vr, final int ldvr) {
>         return openblas.LAPACKE_sgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
>     }
>     
>     @Override
>     public int geev(final LayoutModified layout, final EVDJobModified jobvl, final EVDJobModified jobvr, final int n, final FloatBuffer A, final int lda, final FloatBuffer wr, final FloatBuffer wi, final FloatBuffer Vl, final int ldvl, final FloatBuffer Vr, final int ldvr) {
>         return openblas.LAPACKE_sgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
>     }
>     
>     @Override
>     public int syev(final LayoutModified layout, final EVDJobModified jobz, final UPLOModified uplo, final int n, final double[] A, final int lda, final double[] w) {
>         return openblas.LAPACKE_dsyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
>     }
>     
>     @Override
>     public int syev(final LayoutModified layout, final EVDJobModified jobz, final UPLOModified uplo, final int n, final DoubleBuffer A, final int lda, final DoubleBuffer w) {
>         return openblas.LAPACKE_dsyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
>     }
>     
>     @Override
>     public int syev(final LayoutModified layout, final EVDJobModified jobz, final UPLOModified uplo, final int n, final float[] A, final int lda, final float[] w) {
>         return openblas.LAPACKE_ssyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
>     }
>     
>     @Override
>     public int syev(final LayoutModified layout, final EVDJobModified jobz, final UPLOModified uplo, final int n, final FloatBuffer A, final int lda, final FloatBuffer w) {
>         return openblas.LAPACKE_ssyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
>     }
>     
>     @Override
>     public int syevd(final LayoutModified layout, final EVDJobModified jobz, final UPLOModified uplo, final int n, final double[] A, final int lda, final double[] w) {
>         return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
>     }
>     
>     @Override
>     public int syevd(final LayoutModified layout, final EVDJobModified jobz, final UPLOModified uplo, final int n, final DoubleBuffer A, final int lda, final DoubleBuffer w) {
>         return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
>     }
>     
>     @Override
>     public int syevd(final LayoutModified layout, final EVDJobModified jobz, final UPLOModified uplo, final int n, final DoublePointer A, final int lda, final DoublePointer w) {
>         return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
>     }
>     
>     @Override
>     public int syevd(final LayoutModified layout, final EVDJobModified jobz, final UPLOModified uplo, final int n, final float[] A, final int lda, final float[] w) {
>         return openblas.LAPACKE_ssyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
>     }
>     
>     @Override
>     public int syevd(final LayoutModified layout, final EVDJobModified jobz, final UPLOModified uplo, final int n, final FloatBuffer A, final int lda, final FloatBuffer w) {
>         return openblas.LAPACKE_ssyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
>     }
>     
>     @Override
>     public int syevr(final LayoutModified layout, final EVDJobModified jobz, final EigenRangeModified range, final UPLOModified uplo, final int n, final double[] A, final int lda, final double vl, final double vu, final int il, final int iu, final double abstol, final int[] m, final double[] w, final double[] Z, final int ldz, final int[] isuppz) {
>         return openblas.LAPACKE_dsyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
>     }
>     
>     @Override
>     public int syevr(final LayoutModified layout, final EVDJobModified jobz, final EigenRangeModified range, final UPLOModified uplo, final int n, final DoubleBuffer A, final int lda, final double vl, final double vu, final int il, final int iu, final double abstol, final IntBuffer m, final DoubleBuffer w, final DoubleBuffer Z, final int ldz, final IntBuffer isuppz) {
>         return openblas.LAPACKE_dsyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
>     }
>     
>     @Override
>     public int syevr(final LayoutModified layout, final EVDJobModified jobz, final EigenRangeModified range, final UPLOModified uplo, final int n, final float[] A, final int lda, final float vl, final float vu, final int il, final int iu, final float abstol, final int[] m, final float[] w, final float[] Z, final int ldz, final int[] isuppz) {
>         return openblas.LAPACKE_ssyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
>     }
>     
>     @Override
>     public int syevr(final LayoutModified layout, final EVDJobModified jobz, final EigenRangeModified range, final UPLOModified uplo, final int n, final FloatBuffer A, final int lda, final float vl, final float vu, final int il, final int iu, final float abstol, final IntBuffer m, final FloatBuffer w, final FloatBuffer Z, final int ldz, final IntBuffer isuppz) {
>         return openblas.LAPACKE_ssyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
>     }
>     
>     @Override
>     public int gesvd(final LayoutModified layout, final SVDJobModified jobu, final SVDJobModified jobvt, final int m, final int n, final double[] A, final int lda, final double[] s, final double[] U, final int ldu, final double[] VT, final int ldvt, final double[] superb) {
>         return openblas.LAPACKE_dgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
>     }
>     
>     @Override
>     public int gesvd(final LayoutModified layout, final SVDJobModified jobu, final SVDJobModified jobvt, final int m, final int n, final DoubleBuffer A, final int lda, final DoubleBuffer s, final DoubleBuffer U, final int ldu, final DoubleBuffer VT, final int ldvt, final DoubleBuffer superb) {
>         return openblas.LAPACKE_dgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
>     }
>     
>     @Override
>     public int gesvd(final LayoutModified layout, final SVDJobModified jobu, final SVDJobModified jobvt, final int m, final int n, final float[] A, final int lda, final float[] s, final float[] U, final int ldu, final float[] VT, final int ldvt, final float[] superb) {
>         return openblas.LAPACKE_sgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
>     }
>     
>     @Override
>     public int gesvd(final LayoutModified layout, final SVDJobModified jobu, final SVDJobModified jobvt, final int m, final int n, final FloatBuffer A, final int lda, final FloatBuffer s, final FloatBuffer U, final int ldu, final FloatBuffer VT, final int ldvt, final FloatBuffer superb) {
>         return openblas.LAPACKE_sgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
>     }
>     
>     @Override
>     public int gesdd(final LayoutModified layout, final SVDJobModified jobz, final int m, final int n, final double[] A, final int lda, final double[] s, final double[] U, final int ldu, final double[] VT, final int ldvt) {
>         return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
>     }
>     
>     @Override
>     public int gesdd(final LayoutModified layout, final SVDJobModified jobz, final int m, final int n, final DoubleBuffer A, final int lda, final DoubleBuffer s, final DoubleBuffer U, final int ldu, final DoubleBuffer VT, final int ldvt) {
>         return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
>     }
>     
>     @Override
>     public int gesdd(final LayoutModified layout, final SVDJobModified jobz, final int m, final int n, final DoublePointer A, final int lda, final DoublePointer s, final DoublePointer U, final int ldu, final DoublePointer VT, final int ldvt) {
>         return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
>     }
>     
>     @Override
>     public int gesdd(final LayoutModified layout, final SVDJobModified jobz, final int m, final int n, final float[] A, final int lda, final float[] s, final float[] U, final int ldu, final float[] VT, final int ldvt) {
>         return openblas.LAPACKE_sgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
>     }
>     
>     @Override
>     public int gesdd(final LayoutModified layout, final SVDJobModified jobz, final int m, final int n, final FloatBuffer A, final int lda, final FloatBuffer s, final FloatBuffer U, final int ldu, final FloatBuffer VT, final int ldvt) {
>         return openblas.LAPACKE_sgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
>     }
>     
>     @Override
>     public int getrf(final LayoutModified layout, final int m, final int n, final double[] A, final int lda, final int[] ipiv) {
>         return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
>     }
>     
>     @Override
>     public int getrf(final LayoutModified layout, final int m, final int n, final DoubleBuffer A, final int lda, final IntBuffer ipiv) {
>         return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
>     }
>     
>     @Override
>     public int getrf(final LayoutModified layout, final int m, final int n, final DoublePointer A, final int lda, final IntPointer ipiv) {
>         return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
>     }
>     
>     @Override
>     public int getrf(final LayoutModified layout, final int m, final int n, final float[] A, final int lda, final int[] ipiv) {
>         return openblas.LAPACKE_sgetrf(layout.lapack(), m, n, A, lda, ipiv);
>     }
>     
>     @Override
>     public int getrf(final LayoutModified layout, final int m, final int n, final FloatBuffer A, final int lda, final IntBuffer ipiv) {
>         return openblas.LAPACKE_sgetrf(layout.lapack(), m, n, A, lda, ipiv);
>     }
>     
>     @Override
>     public int getrf2(final LayoutModified layout, final int m, final int n, final double[] A, final int lda, final int[] ipiv) {
>         return openblas.LAPACKE_dgetrf2(layout.lapack(), m, n, A, lda, ipiv);
>     }
>     
>     @Override
>     public int getrf2(final LayoutModified layout, final int m, final int n, final DoubleBuffer A, final int lda, final IntBuffer ipiv) {
>         return openblas.LAPACKE_dgetrf2(layout.lapack(), m, n, A, lda, ipiv);
>     }
>     
>     @Override
>     public int getrf2(final LayoutModified layout, final int m, final int n, final float[] A, final int lda, final int[] ipiv) {
>         return openblas.LAPACKE_sgetrf2(layout.lapack(), m, n, A, lda, ipiv);
>     }
>     
>     @Override
>     public int getrf2(final LayoutModified layout, final int m, final int n, final FloatBuffer A, final int lda, final IntBuffer ipiv) {
>         return openblas.LAPACKE_sgetrf2(layout.lapack(), m, n, A, lda, ipiv);
>     }
>     
>     @Override
>     public int gbtrf(final LayoutModified layout, final int m, final int n, final int kl, final int ku, final double[] AB, final int ldab, final int[] ipiv) {
>         return openblas.LAPACKE_dgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
>     }
>     
>     @Override
>     public int gbtrf(final LayoutModified layout, final int m, final int n, final int kl, final int ku, final DoubleBuffer AB, final int ldab, final IntBuffer ipiv) {
>         return openblas.LAPACKE_dgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
>     }
>     
>     @Override
>     public int gbtrf(final LayoutModified layout, final int m, final int n, final int kl, final int ku, final float[] AB, final int ldab, final int[] ipiv) {
>         return openblas.LAPACKE_sgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
>     }
>     
>     @Override
>     public int gbtrf(final LayoutModified layout, final int m, final int n, final int kl, final int ku, final FloatBuffer AB, final int ldab, final IntBuffer ipiv) {
>         return openblas.LAPACKE_sgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
>     }
>     
>     @Override
>     public int sptrf(final LayoutModified layout, final UPLOModified uplo, final int n, final double[] AP, final int[] ipiv) {
>         return openblas.LAPACKE_dsptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
>     }
>     
>     @Override
>     public int sptrf(final LayoutModified layout, final UPLOModified uplo, final int n, final DoubleBuffer AP, final IntBuffer ipiv) {
>         return openblas.LAPACKE_dsptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
>     }
>     
>     @Override
>     public int sptrf(final LayoutModified layout, final UPLOModified uplo, final int n, final float[] AP, final int[] ipiv) {
>         return openblas.LAPACKE_ssptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
>     }
>     
>     @Override
>     public int sptrf(final LayoutModified layout, final UPLOModified uplo, final int n, final FloatBuffer AP, final IntBuffer ipiv) {
>         return openblas.LAPACKE_ssptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
>     }
>     
>     @Override
>     public int getrs(final LayoutModified layout, final TransposeModified trans, final int n, final int nrhs, final double[] A, final int lda, final int[] ipiv, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int getrs(final LayoutModified layout, final TransposeModified trans, final int n, final int nrhs, final DoubleBuffer A, final int lda, final IntBuffer ipiv, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int getrs(final LayoutModified layout, final TransposeModified trans, final int n, final int nrhs, final DoublePointer A, final int lda, final IntPointer ipiv, final DoublePointer B, final int ldb) {
>         return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int getrs(final LayoutModified layout, final TransposeModified trans, final int n, final int nrhs, final float[] A, final int lda, final int[] ipiv, final float[] B, final int ldb) {
>         return openblas.LAPACKE_sgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int getrs(final LayoutModified layout, final TransposeModified trans, final int n, final int nrhs, final FloatBuffer A, final int lda, final IntBuffer ipiv, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_sgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gbtrs(final LayoutModified layout, final TransposeModified trans, final int n, final int kl, final int ku, final int nrhs, final double[] A, final int lda, final int[] ipiv, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gbtrs(final LayoutModified layout, final TransposeModified trans, final int n, final int kl, final int ku, final int nrhs, final DoubleBuffer A, final int lda, final IntBuffer ipiv, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gbtrs(final LayoutModified layout, final TransposeModified trans, final int n, final int kl, final int ku, final int nrhs, final float[] A, final int lda, final int[] ipiv, final float[] B, final int ldb) {
>         return openblas.LAPACKE_sgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int gbtrs(final LayoutModified layout, final TransposeModified trans, final int n, final int kl, final int ku, final int nrhs, final FloatBuffer A, final int lda, final IntBuffer ipiv, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_sgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int sptrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final double[] AP, final int[] ipiv, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dsptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int sptrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final DoubleBuffer AP, final IntBuffer ipiv, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dsptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int sptrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final float[] AP, final int[] ipiv, final float[] B, final int ldb) {
>         return openblas.LAPACKE_ssptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int sptrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final FloatBuffer AP, final IntBuffer ipiv, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_ssptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
>     }
>     
>     @Override
>     public int potrf(final LayoutModified layout, final UPLOModified uplo, final int n, final double[] A, final int lda) {
>         return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
>     }
>     
>     @Override
>     public int potrf(final LayoutModified layout, final UPLOModified uplo, final int n, final DoubleBuffer A, final int lda) {
>         return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
>     }
>     
>     @Override
>     public int potrf(final LayoutModified layout, final UPLOModified uplo, final int n, final DoublePointer A, final int lda) {
>         return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
>     }
>     
>     @Override
>     public int potrf(final LayoutModified layout, final UPLOModified uplo, final int n, final float[] A, final int lda) {
>         return openblas.LAPACKE_spotrf(layout.lapack(), uplo.lapack(), n, A, lda);
>     }
>     
>     @Override
>     public int potrf(final LayoutModified layout, final UPLOModified uplo, final int n, final FloatBuffer A, final int lda) {
>         return openblas.LAPACKE_spotrf(layout.lapack(), uplo.lapack(), n, A, lda);
>     }
>     
>     @Override
>     public int potrf2(final LayoutModified layout, final UPLOModified uplo, final int n, final double[] A, final int lda) {
>         return openblas.LAPACKE_dpotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
>     }
>     
>     @Override
>     public int potrf2(final LayoutModified layout, final UPLOModified uplo, final int n, final DoubleBuffer A, final int lda) {
>         return openblas.LAPACKE_dpotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
>     }
>     
>     @Override
>     public int potrf2(final LayoutModified layout, final UPLOModified uplo, final int n, final float[] A, final int lda) {
>         return openblas.LAPACKE_spotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
>     }
>     
>     @Override
>     public int potrf2(final LayoutModified layout, final UPLOModified uplo, final int n, final FloatBuffer A, final int lda) {
>         return openblas.LAPACKE_spotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
>     }
>     
>     @Override
>     public int pbtrf(final LayoutModified layout, final UPLOModified uplo, final int n, final int kd, final double[] AB, final int ldab) {
>         return openblas.LAPACKE_dpbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
>     }
>     
>     @Override
>     public int pbtrf(final LayoutModified layout, final UPLOModified uplo, final int n, final int kd, final DoubleBuffer AB, final int ldab) {
>         return openblas.LAPACKE_dpbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
>     }
>     
>     @Override
>     public int pbtrf(final LayoutModified layout, final UPLOModified uplo, final int n, final int kd, final float[] AB, final int ldab) {
>         return openblas.LAPACKE_spbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
>     }
>     
>     @Override
>     public int pbtrf(final LayoutModified layout, final UPLOModified uplo, final int n, final int kd, final FloatBuffer AB, final int ldab) {
>         return openblas.LAPACKE_spbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
>     }
>     
>     @Override
>     public int pptrf(final LayoutModified layout, final UPLOModified uplo, final int n, final double[] AP) {
>         return openblas.LAPACKE_dpptrf(layout.lapack(), uplo.lapack(), n, AP);
>     }
>     
>     @Override
>     public int pptrf(final LayoutModified layout, final UPLOModified uplo, final int n, final DoubleBuffer AP) {
>         return openblas.LAPACKE_dpptrf(layout.lapack(), uplo.lapack(), n, AP);
>     }
>     
>     @Override
>     public int pptrf(final LayoutModified layout, final UPLOModified uplo, final int n, final float[] AP) {
>         return openblas.LAPACKE_spptrf(layout.lapack(), uplo.lapack(), n, AP);
>     }
>     
>     @Override
>     public int pptrf(final LayoutModified layout, final UPLOModified uplo, final int n, final FloatBuffer AP) {
>         return openblas.LAPACKE_spptrf(layout.lapack(), uplo.lapack(), n, AP);
>     }
>     
>     @Override
>     public int potrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final double[] A, final int lda, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int potrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final DoubleBuffer A, final int lda, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int potrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final DoublePointer A, final int lda, final DoublePointer B, final int ldb) {
>         return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int potrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final float[] A, final int lda, final float[] B, final int ldb) {
>         return openblas.LAPACKE_spotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int potrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final FloatBuffer A, final int lda, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_spotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int pbtrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int kd, final int nrhs, final double[] AB, final int ldab, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dpbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
>     }
>     
>     @Override
>     public int pbtrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int kd, final int nrhs, final DoubleBuffer AB, final int ldab, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dpbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
>     }
>     
>     @Override
>     public int pbtrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int kd, final int nrhs, final float[] AB, final int ldab, final float[] B, final int ldb) {
>         return openblas.LAPACKE_spbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
>     }
>     
>     @Override
>     public int pbtrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int kd, final int nrhs, final FloatBuffer AB, final int ldab, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_spbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
>     }
>     
>     @Override
>     public int pptrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final double[] AP, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dpptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
>     }
>     
>     @Override
>     public int pptrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final DoubleBuffer AP, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dpptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
>     }
>     
>     @Override
>     public int pptrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final float[] AP, final float[] B, final int ldb) {
>         return openblas.LAPACKE_spptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
>     }
>     
>     @Override
>     public int pptrs(final LayoutModified layout, final UPLOModified uplo, final int n, final int nrhs, final FloatBuffer AP, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_spptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
>     }
>     
>     @Override
>     public int geqrf(final LayoutModified layout, final int m, final int n, final double[] A, final int lda, final double[] tau) {
>         return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
>     }
>     
>     @Override
>     public int geqrf(final LayoutModified layout, final int m, final int n, final DoubleBuffer A, final int lda, final DoubleBuffer tau) {
>         return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
>     }
>     
>     @Override
>     public int geqrf(final LayoutModified layout, final int m, final int n, final DoublePointer A, final int lda, final DoublePointer tau) {
>         return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
>     }
>     
>     @Override
>     public int geqrf(final LayoutModified layout, final int m, final int n, final float[] A, final int lda, final float[] tau) {
>         return openblas.LAPACKE_sgeqrf(layout.lapack(), m, n, A, lda, tau);
>     }
>     
>     @Override
>     public int geqrf(final LayoutModified layout, final int m, final int n, final FloatBuffer A, final int lda, final FloatBuffer tau) {
>         return openblas.LAPACKE_sgeqrf(layout.lapack(), m, n, A, lda, tau);
>     }
>     
>     @Override
>     public int orgqr(final LayoutModified layout, final int m, final int n, final int k, final double[] A, final int lda, final double[] tau) {
>         return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
>     }
>     
>     @Override
>     public int orgqr(final LayoutModified layout, final int m, final int n, final int k, final DoubleBuffer A, final int lda, final DoubleBuffer tau) {
>         return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
>     }
>     
>     @Override
>     public int orgqr(final LayoutModified layout, final int m, final int n, final int k, final DoublePointer A, final int lda, final DoublePointer tau) {
>         return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
>     }
>     
>     @Override
>     public int orgqr(final LayoutModified layout, final int m, final int n, final int k, final float[] A, final int lda, final float[] tau) {
>         return openblas.LAPACKE_sorgqr(layout.lapack(), m, n, k, A, lda, tau);
>     }
>     
>     @Override
>     public int orgqr(final LayoutModified layout, final int m, final int n, final int k, final FloatBuffer A, final int lda, final FloatBuffer tau) {
>         return openblas.LAPACKE_sorgqr(layout.lapack(), m, n, k, A, lda, tau);
>     }
>     
>     @Override
>     public int ormqr(final LayoutModified layout, final SideModified side, final TransposeModified trans, final int m, final int n, final int k, final double[] A, final int lda, final double[] tau, final double[] C, final int ldc) {
>         return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
>     }
>     
>     @Override
>     public int ormqr(final LayoutModified layout, final SideModified side, final TransposeModified trans, final int m, final int n, final int k, final DoubleBuffer A, final int lda, final DoubleBuffer tau, final DoubleBuffer C, final int ldc) {
>         return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
>     }
>     
>     @Override
>     public int ormqr(final LayoutModified layout, final SideModified side, final TransposeModified trans, final int m, final int n, final int k, final DoublePointer A, final int lda, final DoublePointer tau, final DoublePointer C, final int ldc) {
>         return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
>     }
>     
>     @Override
>     public int ormqr(final LayoutModified layout, final SideModified side, final TransposeModified trans, final int m, final int n, final int k, final float[] A, final int lda, final float[] tau, final float[] C, final int ldc) {
>         return openblas.LAPACKE_sormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
>     }
>     
>     @Override
>     public int ormqr(final LayoutModified layout, final SideModified side, final TransposeModified trans, final int m, final int n, final int k, final FloatBuffer A, final int lda, final FloatBuffer tau, final FloatBuffer C, final int ldc) {
>         return openblas.LAPACKE_sormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
>     }
>     
>     @Override
>     public int trtrs(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final int nrhs, final double[] A, final int lda, final double[] B, final int ldb) {
>         return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int trtrs(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final int nrhs, final DoubleBuffer A, final int lda, final DoubleBuffer B, final int ldb) {
>         return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int trtrs(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final int nrhs, final DoublePointer A, final int lda, final DoublePointer B, final int ldb) {
>         return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int trtrs(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final int nrhs, final float[] A, final int lda, final float[] B, final int ldb) {
>         return openblas.LAPACKE_strtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
>     }
>     
>     @Override
>     public int trtrs(final LayoutModified layout, final UPLOModified uplo, final TransposeModified trans, final DiagModified diag, final int n, final int nrhs, final FloatBuffer A, final int lda, final FloatBuffer B, final int ldb) {
>         return openblas.LAPACKE_strtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
>     }
diff -r TrackAnalyzer_/smileModified/QuickSelectModified.java procyon/smileModified/QuickSelectModified.java
1c1,3
< package smileModified;
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
3,7c5
< public interface QuickSelectModified {
<    static int select(int[] x, int k) {
<       int n = x.length;
<       int l = 0;
<       int ir = n - 1;
---
> package smileModified;
9,12c7,48
<       while(ir > l + 1) {
<          int mid = l + ir >> 1;
<          SortModified.swap(x, mid, l + 1);
<          if (x[l] > x[ir]) {
---
> public interface QuickSelectModified
> {
>     default int select(final int[] x, final int k) {
>         final int n = x.length;
>         int l;
>         int ir;
>         int i;
>         for (l = 0, ir = n - 1; ir > l + 1; l = i) {
>             final int mid = l + ir >> 1;
>             SortModified.swap(x, mid, l + 1);
>             if (x[l] > x[ir]) {
>                 SortModified.swap(x, l, ir);
>             }
>             if (x[l + 1] > x[ir]) {
>                 SortModified.swap(x, l + 1, ir);
>             }
>             if (x[l] > x[l + 1]) {
>                 SortModified.swap(x, l, l + 1);
>             }
>             i = l + 1;
>             int j = ir;
>             final int a = x[l + 1];
>             while (true) {
>                 ++i;
>                 if (x[i] >= a) {
>                     do {
>                         --j;
>                     } while (x[j] > a);
>                     if (j < i) {
>                         break;
>                     }
>                     SortModified.swap(x, i, j);
>                 }
>             }
>             x[l + 1] = x[j];
>             x[j] = a;
>             if (j >= k) {
>                 ir = j - 1;
>             }
>             if (j <= k) {}
>         }
>         if (ir == l + 1 && x[ir] < x[l]) {
14,47c50,63
<          }
< 
<          if (x[l + 1] > x[ir]) {
<             SortModified.swap(x, l + 1, ir);
<          }
< 
<          if (x[l] > x[l + 1]) {
<             SortModified.swap(x, l, l + 1);
<          }
< 
<          int i = l + 1;
<          int j = ir;
<          int a = x[l + 1];
< 
<          while(true) {
<             do {
<                ++i;
<             } while(x[i] < a);
< 
<             do {
<                --j;
<             } while(x[j] > a);
< 
<             if (j < i) {
<                x[l + 1] = x[j];
<                x[j] = a;
<                if (j >= k) {
<                   ir = j - 1;
<                }
< 
<                if (j <= k) {
<                   l = i;
<                }
<                break;
---
>         }
>         return x[k];
>     }
>     
>     default float select(final float[] x, final int k) {
>         final int n = x.length;
>         int l;
>         int ir;
>         int i;
>         for (l = 0, ir = n - 1; ir > l + 1; l = i) {
>             final int mid = l + ir >> 1;
>             SortModified.swap(x, mid, l + 1);
>             if (x[l] > x[ir]) {
>                 SortModified.swap(x, l, ir);
49,69c65,93
< 
<             SortModified.swap(x, i, j);
<          }
<       }
< 
<       if (ir == l + 1 && x[ir] < x[l]) {
<          SortModified.swap(x, l, ir);
<       }
< 
<       return x[k];
<    }
< 
<    static float select(float[] x, int k) {
<       int n = x.length;
<       int l = 0;
<       int ir = n - 1;
< 
<       while(ir > l + 1) {
<          int mid = l + ir >> 1;
<          SortModified.swap(x, mid, l + 1);
<          if (x[l] > x[ir]) {
---
>             if (x[l + 1] > x[ir]) {
>                 SortModified.swap(x, l + 1, ir);
>             }
>             if (x[l] > x[l + 1]) {
>                 SortModified.swap(x, l, l + 1);
>             }
>             i = l + 1;
>             int j = ir;
>             final float a = x[l + 1];
>             while (true) {
>                 ++i;
>                 if (x[i] >= a) {
>                     do {
>                         --j;
>                     } while (x[j] > a);
>                     if (j < i) {
>                         break;
>                     }
>                     SortModified.swap(x, i, j);
>                 }
>             }
>             x[l + 1] = x[j];
>             x[j] = a;
>             if (j >= k) {
>                 ir = j - 1;
>             }
>             if (j <= k) {}
>         }
>         if (ir == l + 1 && x[ir] < x[l]) {
71,104c95,108
<          }
< 
<          if (x[l + 1] > x[ir]) {
<             SortModified.swap(x, l + 1, ir);
<          }
< 
<          if (x[l] > x[l + 1]) {
<             SortModified.swap(x, l, l + 1);
<          }
< 
<          int i = l + 1;
<          int j = ir;
<          float a = x[l + 1];
< 
<          while(true) {
<             do {
<                ++i;
<             } while(x[i] < a);
< 
<             do {
<                --j;
<             } while(x[j] > a);
< 
<             if (j < i) {
<                x[l + 1] = x[j];
<                x[j] = a;
<                if (j >= k) {
<                   ir = j - 1;
<                }
< 
<                if (j <= k) {
<                   l = i;
<                }
<                break;
---
>         }
>         return x[k];
>     }
>     
>     default double select(final double[] x, final int k) {
>         final int n = x.length;
>         int l;
>         int ir;
>         int i;
>         for (l = 0, ir = n - 1; ir > l + 1; l = i) {
>             final int mid = l + ir >> 1;
>             SortModified.swap(x, mid, l + 1);
>             if (x[l] > x[ir]) {
>                 SortModified.swap(x, l, ir);
106,126c110,138
< 
<             SortModified.swap(x, i, j);
<          }
<       }
< 
<       if (ir == l + 1 && x[ir] < x[l]) {
<          SortModified.swap(x, l, ir);
<       }
< 
<       return x[k];
<    }
< 
<    static double select(double[] x, int k) {
<       int n = x.length;
<       int l = 0;
<       int ir = n - 1;
< 
<       while(ir > l + 1) {
<          int mid = l + ir >> 1;
<          SortModified.swap(x, mid, l + 1);
<          if (x[l] > x[ir]) {
---
>             if (x[l + 1] > x[ir]) {
>                 SortModified.swap(x, l + 1, ir);
>             }
>             if (x[l] > x[l + 1]) {
>                 SortModified.swap(x, l, l + 1);
>             }
>             i = l + 1;
>             int j = ir;
>             final double a = x[l + 1];
>             while (true) {
>                 ++i;
>                 if (x[i] >= a) {
>                     do {
>                         --j;
>                     } while (x[j] > a);
>                     if (j < i) {
>                         break;
>                     }
>                     SortModified.swap(x, i, j);
>                 }
>             }
>             x[l + 1] = x[j];
>             x[j] = a;
>             if (j >= k) {
>                 ir = j - 1;
>             }
>             if (j <= k) {}
>         }
>         if (ir == l + 1 && x[ir] < x[l]) {
128,161c140,153
<          }
< 
<          if (x[l + 1] > x[ir]) {
<             SortModified.swap(x, l + 1, ir);
<          }
< 
<          if (x[l] > x[l + 1]) {
<             SortModified.swap(x, l, l + 1);
<          }
< 
<          int i = l + 1;
<          int j = ir;
<          double a = x[l + 1];
< 
<          while(true) {
<             do {
<                ++i;
<             } while(x[i] < a);
< 
<             do {
<                --j;
<             } while(x[j] > a);
< 
<             if (j < i) {
<                x[l + 1] = x[j];
<                x[j] = a;
<                if (j >= k) {
<                   ir = j - 1;
<                }
< 
<                if (j <= k) {
<                   l = i;
<                }
<                break;
---
>         }
>         return x[k];
>     }
>     
>     default <T extends Comparable<? super T>> T select(final T[] x, final int k) {
>         final int n = x.length;
>         int l;
>         int ir;
>         int i;
>         for (l = 0, ir = n - 1; ir > l + 1; l = i) {
>             final int mid = l + ir >> 1;
>             SortModified.swap(x, mid, l + 1);
>             if (x[l].compareTo((Object)x[ir]) > 0) {
>                 SortModified.swap(x, l, ir);
163,218c155,156
< 
<             SortModified.swap(x, i, j);
<          }
<       }
< 
<       if (ir == l + 1 && x[ir] < x[l]) {
<          SortModified.swap(x, l, ir);
<       }
< 
<       return x[k];
<    }
< 
<    static <T extends Comparable<? super T>> T select(T[] x, int k) {
<       int n = x.length;
<       int l = 0;
<       int ir = n - 1;
< 
<       while(ir > l + 1) {
<          int mid = l + ir >> 1;
<          SortModified.swap((Object[])x, mid, l + 1);
<          if (x[l].compareTo(x[ir]) > 0) {
<             SortModified.swap((Object[])x, l, ir);
<          }
< 
<          if (x[l + 1].compareTo(x[ir]) > 0) {
<             SortModified.swap((Object[])x, l + 1, ir);
<          }
< 
<          if (x[l].compareTo(x[l + 1]) > 0) {
<             SortModified.swap((Object[])x, l, l + 1);
<          }
< 
<          int i = l + 1;
<          int j = ir;
<          Comparable a = x[l + 1];
< 
<          while(true) {
<             do {
<                ++i;
<             } while(x[i].compareTo(a) < 0);
< 
<             do {
<                --j;
<             } while(x[j].compareTo(a) > 0);
< 
<             if (j < i) {
<                x[l + 1] = x[j];
<                x[j] = a;
<                if (j >= k) {
<                   ir = j - 1;
<                }
< 
<                if (j <= k) {
<                   l = i;
<                }
<                break;
---
>             if (x[l + 1].compareTo((Object)x[ir]) > 0) {
>                 SortModified.swap(x, l + 1, ir);
220,290c158,247
< 
<             SortModified.swap((Object[])x, i, j);
<          }
<       }
< 
<       if (ir == l + 1 && x[ir].compareTo(x[l]) < 0) {
<          SortModified.swap((Object[])x, l, ir);
<       }
< 
<       return x[k];
<    }
< 
<    static int median(int[] x) {
<       int k = x.length / 2;
<       return select(x, k);
<    }
< 
<    static float median(float[] x) {
<       int k = x.length / 2;
<       return select(x, k);
<    }
< 
<    static double median(double[] x) {
<       int k = x.length / 2;
<       return select(x, k);
<    }
< 
<    static <T extends Comparable<? super T>> T median(T[] x) {
<       int k = x.length / 2;
<       return select(x, k);
<    }
< 
<    static int q1(int[] x) {
<       int k = x.length / 4;
<       return select(x, k);
<    }
< 
<    static float q1(float[] x) {
<       int k = x.length / 4;
<       return select(x, k);
<    }
< 
<    static double q1(double[] x) {
<       int k = x.length / 4;
<       return select(x, k);
<    }
< 
<    static <T extends Comparable<? super T>> T q1(T[] x) {
<       int k = x.length / 4;
<       return select(x, k);
<    }
< 
<    static int q3(int[] x) {
<       int k = 3 * x.length / 4;
<       return select(x, k);
<    }
< 
<    static float q3(float[] x) {
<       int k = 3 * x.length / 4;
<       return select(x, k);
<    }
< 
<    static double q3(double[] x) {
<       int k = 3 * x.length / 4;
<       return select(x, k);
<    }
< 
<    static <T extends Comparable<? super T>> T q3(T[] x) {
<       int k = 3 * x.length / 4;
<       return select(x, k);
<    }
---
>             if (x[l].compareTo((Object)x[l + 1]) > 0) {
>                 SortModified.swap(x, l, l + 1);
>             }
>             i = l + 1;
>             int j = ir;
>             final T a = x[l + 1];
>             while (true) {
>                 ++i;
>                 if (x[i].compareTo((Object)a) >= 0) {
>                     do {
>                         --j;
>                     } while (x[j].compareTo((Object)a) > 0);
>                     if (j < i) {
>                         break;
>                     }
>                     SortModified.swap(x, i, j);
>                 }
>             }
>             x[l + 1] = x[j];
>             x[j] = a;
>             if (j >= k) {
>                 ir = j - 1;
>             }
>             if (j <= k) {}
>         }
>         if (ir == l + 1 && x[ir].compareTo((Object)x[l]) < 0) {
>             SortModified.swap(x, l, ir);
>         }
>         return x[k];
>     }
>     
>     default int median(final int[] x) {
>         final int k = x.length / 2;
>         return select(x, k);
>     }
>     
>     default float median(final float[] x) {
>         final int k = x.length / 2;
>         return select(x, k);
>     }
>     
>     default double median(final double[] x) {
>         final int k = x.length / 2;
>         return select(x, k);
>     }
>     
>     default <T extends Comparable<? super T>> T median(final T[] x) {
>         final int k = x.length / 2;
>         return QuickSelectModified.<T>select(x, k);
>     }
>     
>     default int q1(final int[] x) {
>         final int k = x.length / 4;
>         return select(x, k);
>     }
>     
>     default float q1(final float[] x) {
>         final int k = x.length / 4;
>         return select(x, k);
>     }
>     
>     default double q1(final double[] x) {
>         final int k = x.length / 4;
>         return select(x, k);
>     }
>     
>     default <T extends Comparable<? super T>> T q1(final T[] x) {
>         final int k = x.length / 4;
>         return QuickSelectModified.<T>select(x, k);
>     }
>     
>     default int q3(final int[] x) {
>         final int k = 3 * x.length / 4;
>         return select(x, k);
>     }
>     
>     default float q3(final float[] x) {
>         final int k = 3 * x.length / 4;
>         return select(x, k);
>     }
>     
>     default double q3(final double[] x) {
>         final int k = 3 * x.length / 4;
>         return select(x, k);
>     }
>     
>     default <T extends Comparable<? super T>> T q3(final T[] x) {
>         final int k = 3 * x.length / 4;
>         return QuickSelectModified.<T>select(x, k);
>     }
diff -r TrackAnalyzer_/smileModified/QuickSortModified.java procyon/smileModified/QuickSortModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,1099c9,1040
< public class QuickSortModified {
<    private static final int M = 7;
<    private static final int NSTACK = 64;
< 
<    private QuickSortModified() {
<    }
< 
<    public static int[] sort(int[] x) {
<       int[] order = new int[x.length];
< 
<       for(int i = 0; i < order.length; order[i] = i++) {
<       }
< 
<       sort(x, order);
<       return order;
<    }
< 
<    public static void sort(int[] x, int[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(int[] x, int[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          int a;
<          int b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && x[i] > a; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(int[] x, double[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(int[] x, double[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          int a;
<          double b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && x[i] > a; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(int[] x, Object[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(int[] x, Object[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          int a;
<          Object b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && x[i] > a; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static int[] sort(float[] x) {
<       int[] order = new int[x.length];
< 
<       for(int i = 0; i < order.length; order[i] = i++) {
<       }
< 
<       sort(x, order);
<       return order;
<    }
< 
<    public static void sort(float[] x, int[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(float[] x, int[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          float a;
<          int b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(float[] x, float[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(float[] x, float[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          float a;
<          float b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(float[] x, Object[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(float[] x, Object[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          float a;
<          Object b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static int[] sort(double[] x) {
<       int[] order = new int[x.length];
< 
<       for(int i = 0; i < order.length; order[i] = i++) {
<       }
< 
<       sort(x, order);
<       return order;
<    }
< 
<    public static void sort(double[] x, int[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(double[] x, int[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          double a;
<          int b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(double[] x, double[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(double[] x, double[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          double a;
<          double b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(double[] x, Object[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(double[] x, Object[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          double a;
<          Object b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static <T extends Comparable<? super T>> int[] sort(T[] x) {
<       int[] order = new int[x.length];
< 
<       for(int i = 0; i < order.length; order[i] = i++) {
<       }
< 
<       sort(x, order);
<       return order;
<    }
< 
<    public static <T extends Comparable<? super T>> void sort(T[] x, int[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static <T extends Comparable<? super T>> void sort(T[] x, int[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          Comparable a;
<          int b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap((Object[])x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l].compareTo(x[ir]) > 0) {
<                SortModified.swap((Object[])x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1].compareTo(x[ir]) > 0) {
<                SortModified.swap((Object[])x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l].compareTo(x[l + 1]) > 0) {
<                SortModified.swap((Object[])x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i].compareTo(a) < 0);
< 
<                do {
<                   --j;
<                } while(x[j].compareTo(a) > 0);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap((Object[])x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && x[i].compareTo(a) > 0; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static <T> void sort(T[] x, int[] y, int n, Comparator<T> comparator) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          Object a;
<          int b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (comparator.compare(x[l], x[ir]) > 0) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (comparator.compare(x[l + 1], x[ir]) > 0) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (comparator.compare(x[l], x[l + 1]) > 0) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(comparator.compare(x[i], a) < 0);
< 
<                do {
<                   --j;
<                } while(comparator.compare(x[j], a) > 0);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && comparator.compare(x[i], a) > 0; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
---
> public class QuickSortModified
> {
>     private static final int M = 7;
>     private static final int NSTACK = 64;
>     
>     private QuickSortModified() {
>     }
>     
>     public static int[] sort(final int[] x) {
>         final int[] order = new int[x.length];
>         for (int i = 0; i < order.length; ++i) {
>             order[i] = i;
>         }
>         sort(x, order);
>         return order;
>     }
>     
>     public static void sort(final int[] x, final int[] y) {
>         sort(x, y, x.length);
>     }
>     
>     public static void sort(final int[] x, final int[] y, final int n) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final int a = x[j];
>                     final int b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && x[i] > a; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (x[l] > x[ir]) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (x[l + 1] > x[ir]) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (x[l] > x[l + 1]) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final int a = x[l + 1];
>                 final int b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (x[i] >= a) {
>                         do {
>                             --j;
>                         } while (x[j] > a);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
>             }
>         }
>     }
>     
>     public static void sort(final int[] x, final double[] y) {
>         sort(x, y, x.length);
>     }
>     
>     public static void sort(final int[] x, final double[] y, final int n) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final int a = x[j];
>                     final double b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && x[i] > a; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (x[l] > x[ir]) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (x[l + 1] > x[ir]) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (x[l] > x[l + 1]) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final int a = x[l + 1];
>                 final double b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (x[i] >= a) {
>                         do {
>                             --j;
>                         } while (x[j] > a);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
>             }
>         }
>     }
>     
>     public static void sort(final int[] x, final Object[] y) {
>         sort(x, y, x.length);
>     }
>     
>     public static void sort(final int[] x, final Object[] y, final int n) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final int a = x[j];
>                     final Object b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && x[i] > a; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (x[l] > x[ir]) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (x[l + 1] > x[ir]) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (x[l] > x[l + 1]) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final int a = x[l + 1];
>                 final Object b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (x[i] >= a) {
>                         do {
>                             --j;
>                         } while (x[j] > a);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
>             }
>         }
>     }
>     
>     public static int[] sort(final float[] x) {
>         final int[] order = new int[x.length];
>         for (int i = 0; i < order.length; ++i) {
>             order[i] = i;
>         }
>         sort(x, order);
>         return order;
>     }
>     
>     public static void sort(final float[] x, final int[] y) {
>         sort(x, y, x.length);
>     }
>     
>     public static void sort(final float[] x, final int[] y, final int n) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final float a = x[j];
>                     final int b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && x[i] > a; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (x[l] > x[ir]) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (x[l + 1] > x[ir]) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (x[l] > x[l + 1]) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final float a = x[l + 1];
>                 final int b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (x[i] >= a) {
>                         do {
>                             --j;
>                         } while (x[j] > a);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
>             }
>         }
>     }
>     
>     public static void sort(final float[] x, final float[] y) {
>         sort(x, y, x.length);
>     }
>     
>     public static void sort(final float[] x, final float[] y, final int n) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final float a = x[j];
>                     final float b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && x[i] > a; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (x[l] > x[ir]) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (x[l + 1] > x[ir]) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (x[l] > x[l + 1]) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final float a = x[l + 1];
>                 final float b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (x[i] >= a) {
>                         do {
>                             --j;
>                         } while (x[j] > a);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
>             }
>         }
>     }
>     
>     public static void sort(final float[] x, final Object[] y) {
>         sort(x, y, x.length);
>     }
>     
>     public static void sort(final float[] x, final Object[] y, final int n) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final float a = x[j];
>                     final Object b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && x[i] > a; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (x[l] > x[ir]) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (x[l + 1] > x[ir]) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (x[l] > x[l + 1]) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final float a = x[l + 1];
>                 final Object b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (x[i] >= a) {
>                         do {
>                             --j;
>                         } while (x[j] > a);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
>             }
>         }
>     }
>     
>     public static int[] sort(final double[] x) {
>         final int[] order = new int[x.length];
>         for (int i = 0; i < order.length; ++i) {
>             order[i] = i;
>         }
>         sort(x, order);
>         return order;
>     }
>     
>     public static void sort(final double[] x, final int[] y) {
>         sort(x, y, x.length);
>     }
>     
>     public static void sort(final double[] x, final int[] y, final int n) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final double a = x[j];
>                     final int b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && x[i] > a; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (x[l] > x[ir]) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (x[l + 1] > x[ir]) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (x[l] > x[l + 1]) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final double a = x[l + 1];
>                 final int b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (x[i] >= a) {
>                         do {
>                             --j;
>                         } while (x[j] > a);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
>             }
>         }
>     }
>     
>     public static void sort(final double[] x, final double[] y) {
>         sort(x, y, x.length);
>     }
>     
>     public static void sort(final double[] x, final double[] y, final int n) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final double a = x[j];
>                     final double b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && x[i] > a; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (x[l] > x[ir]) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (x[l + 1] > x[ir]) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (x[l] > x[l + 1]) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final double a = x[l + 1];
>                 final double b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (x[i] >= a) {
>                         do {
>                             --j;
>                         } while (x[j] > a);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
>             }
>         }
>     }
>     
>     public static void sort(final double[] x, final Object[] y) {
>         sort(x, y, x.length);
>     }
>     
>     public static void sort(final double[] x, final Object[] y, final int n) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final double a = x[j];
>                     final Object b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && x[i] > a; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (x[l] > x[ir]) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (x[l + 1] > x[ir]) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (x[l] > x[l + 1]) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final double a = x[l + 1];
>                 final Object b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (x[i] >= a) {
>                         do {
>                             --j;
>                         } while (x[j] > a);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
>             }
>         }
>     }
>     
>     public static <T extends Comparable<? super T>> int[] sort(final T[] x) {
>         final int[] order = new int[x.length];
>         for (int i = 0; i < order.length; ++i) {
>             order[i] = i;
>         }
>         QuickSortModified.<T>sort(x, order);
>         return order;
>     }
>     
>     public static <T extends Comparable<? super T>> void sort(final T[] x, final int[] y) {
>         QuickSortModified.<T>sort(x, y, x.length);
>     }
>     
>     public static <T extends Comparable<? super T>> void sort(final T[] x, final int[] y, final int n) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final T a = x[j];
>                     final int b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && x[i].compareTo((Object)a) > 0; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (x[l].compareTo((Object)x[ir]) > 0) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (x[l + 1].compareTo((Object)x[ir]) > 0) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (x[l].compareTo((Object)x[l + 1]) > 0) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final T a = x[l + 1];
>                 final int b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (x[i].compareTo((Object)a) >= 0) {
>                         do {
>                             --j;
>                         } while (x[j].compareTo((Object)a) > 0);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
>             }
>         }
>     }
>     
>     public static <T> void sort(final T[] x, final int[] y, final int n, final Comparator<T> comparator) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final T a = x[j];
>                     final int b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && comparator.compare(x[i], a) > 0; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (comparator.compare(x[l], x[ir]) > 0) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (comparator.compare(x[l + 1], x[ir]) > 0) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (comparator.compare(x[l], x[l + 1]) > 0) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final T a = x[l + 1];
>                 final int b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (comparator.compare(x[i], a) >= 0) {
>                         do {
>                             --j;
>                         } while (comparator.compare(x[j], a) > 0);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
>             }
>         }
>     }
>     
>     public static <T extends Comparable<? super T>> void sort(final T[] x, final Object[] y) {
>         QuickSortModified.<T>sort(x, y, x.length);
>     }
>     
>     public static <T extends Comparable<? super T>> void sort(final T[] x, final Object[] y, final int n) {
>         int jstack = -1;
>         int l = 0;
>         final int[] istack = new int[64];
>         int ir = n - 1;
>         while (true) {
>             if (ir - l < 7) {
>                 for (int j = l + 1; j <= ir; ++j) {
>                     final T a = x[j];
>                     final Object b = y[j];
>                     int i;
>                     for (i = j - 1; i >= l && x[i].compareTo((Object)a) > 0; --i) {
>                         x[i + 1] = x[i];
>                         y[i + 1] = y[i];
>                     }
>                     x[i + 1] = a;
>                     y[i + 1] = b;
>                 }
>                 if (jstack < 0) {
>                     return;
>                 }
>                 ir = istack[jstack--];
>                 l = istack[jstack--];
>             }
>             else {
>                 final int k = l + ir >> 1;
>                 SortModified.swap(x, k, l + 1);
>                 SortModified.swap(y, k, l + 1);
>                 if (x[l].compareTo((Object)x[ir]) > 0) {
>                     SortModified.swap(x, l, ir);
>                     SortModified.swap(y, l, ir);
>                 }
>                 if (x[l + 1].compareTo((Object)x[ir]) > 0) {
>                     SortModified.swap(x, l + 1, ir);
>                     SortModified.swap(y, l + 1, ir);
>                 }
>                 if (x[l].compareTo((Object)x[l + 1]) > 0) {
>                     SortModified.swap(x, l, l + 1);
>                     SortModified.swap(y, l, l + 1);
>                 }
>                 int i = l + 1;
>                 int j = ir;
>                 final T a = x[l + 1];
>                 final Object b = y[l + 1];
>                 while (true) {
>                     ++i;
>                     if (x[i].compareTo((Object)a) >= 0) {
>                         do {
>                             --j;
>                         } while (x[j].compareTo((Object)a) > 0);
>                         if (j < i) {
>                             break;
>                         }
>                         SortModified.swap(x, i, j);
>                         SortModified.swap(y, i, j);
>                     }
>                 }
>                 x[l + 1] = x[j];
>                 x[j] = a;
>                 y[l + 1] = y[j];
>                 y[j] = b;
>                 jstack += 2;
>                 if (jstack >= 64) {
>                     throw new IllegalStateException("NSTACK too small in SortModified.");
>                 }
>                 if (ir - i + 1 >= j - l) {
>                     istack[jstack] = ir;
>                     istack[jstack - 1] = i;
>                     ir = j - 1;
>                 }
>                 else {
>                     istack[jstack] = j - 1;
>                     istack[jstack - 1] = l;
>                     l = i;
>                 }
1101,1210c1042,1043
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static <T extends Comparable<? super T>> void sort(T[] x, Object[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static <T extends Comparable<? super T>> void sort(T[] x, Object[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          Comparable a;
<          Object b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap((Object[])x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l].compareTo(x[ir]) > 0) {
<                SortModified.swap((Object[])x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1].compareTo(x[ir]) > 0) {
<                SortModified.swap((Object[])x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l].compareTo(x[l + 1]) > 0) {
<                SortModified.swap((Object[])x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i].compareTo(a) < 0);
< 
<                do {
<                   --j;
<                } while(x[j].compareTo(a) > 0);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap((Object[])x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && x[i].compareTo(a) > 0; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
---
>         }
>     }
diff -r TrackAnalyzer_/smileModified/RandomModified.java procyon/smileModified/RandomModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,95c9,93
< public class RandomModified {
<    private final UniversalGeneratorModified real;
<    private final MersenneTwisterModified twister;
< 
<    public RandomModified() {
<       this.real = new UniversalGeneratorModified();
<       this.twister = new MersenneTwisterModified();
<    }
< 
<    public RandomModified(long seed) {
<       this.real = new UniversalGeneratorModified(seed);
<       this.twister = new MersenneTwisterModified(seed);
<    }
< 
<    public void setSeed(long seed) {
<       this.real.setSeed(seed);
<       this.twister.setSeed(seed);
<    }
< 
<    public double nextDouble() {
<       return this.real.nextDouble();
<    }
< 
<    public void nextDoubles(double[] d) {
<       this.real.nextDoubles(d);
<    }
< 
<    public double nextDouble(double lo, double hi) {
<       return lo + (hi - lo) * this.nextDouble();
<    }
< 
<    public void nextDoubles(double[] d, double lo, double hi) {
<       this.real.nextDoubles(d);
<       double l = hi - lo;
<       int n = d.length;
< 
<       for(int i = 0; i < n; ++i) {
<          d[i] = lo + l * d[i];
<       }
< 
<    }
< 
<    public int nextInt() {
<       return this.twister.nextInt();
<    }
< 
<    public int nextInt(int n) {
<       return this.twister.nextInt(n);
<    }
< 
<    public long nextLong() {
<       return this.twister.nextLong();
<    }
< 
<    public int[] permutate(int n) {
<       int[] x = IntStream.range(0, n).toArray();
<       this.permutate(x);
<       return x;
<    }
< 
<    public void permutate(int[] x) {
<       for(int i = 0; i < x.length; ++i) {
<          int j = i + this.nextInt(x.length - i);
<          MathExModified.swap(x, i, j);
<       }
< 
<    }
< 
<    public void permutate(float[] x) {
<       for(int i = 0; i < x.length; ++i) {
<          int j = i + this.nextInt(x.length - i);
<          MathExModified.swap(x, i, j);
<       }
< 
<    }
< 
<    public void permutate(double[] x) {
<       for(int i = 0; i < x.length; ++i) {
<          int j = i + this.nextInt(x.length - i);
<          MathExModified.swap(x, i, j);
<       }
< 
<    }
< 
<    public void permutate(Object[] x) {
<       for(int i = 0; i < x.length; ++i) {
<          int j = i + this.nextInt(x.length - i);
<          MathExModified.swap(x, i, j);
<       }
< 
<    }
---
> public class RandomModified
> {
>     private final UniversalGeneratorModified real;
>     private final MersenneTwisterModified twister;
>     
>     public RandomModified() {
>         this.real = new UniversalGeneratorModified();
>         this.twister = new MersenneTwisterModified();
>     }
>     
>     public RandomModified(final long seed) {
>         this.real = new UniversalGeneratorModified(seed);
>         this.twister = new MersenneTwisterModified(seed);
>     }
>     
>     public void setSeed(final long seed) {
>         this.real.setSeed(seed);
>         this.twister.setSeed(seed);
>     }
>     
>     public double nextDouble() {
>         return this.real.nextDouble();
>     }
>     
>     public void nextDoubles(final double[] d) {
>         this.real.nextDoubles(d);
>     }
>     
>     public double nextDouble(final double lo, final double hi) {
>         return lo + (hi - lo) * this.nextDouble();
>     }
>     
>     public void nextDoubles(final double[] d, final double lo, final double hi) {
>         this.real.nextDoubles(d);
>         final double l = hi - lo;
>         for (int n = d.length, i = 0; i < n; ++i) {
>             d[i] = lo + l * d[i];
>         }
>     }
>     
>     public int nextInt() {
>         return this.twister.nextInt();
>     }
>     
>     public int nextInt(final int n) {
>         return this.twister.nextInt(n);
>     }
>     
>     public long nextLong() {
>         return this.twister.nextLong();
>     }
>     
>     public int[] permutate(final int n) {
>         final int[] x = IntStream.range(0, n).toArray();
>         this.permutate(x);
>         return x;
>     }
>     
>     public void permutate(final int[] x) {
>         for (int i = 0; i < x.length; ++i) {
>             final int j = i + this.nextInt(x.length - i);
>             MathExModified.swap(x, i, j);
>         }
>     }
>     
>     public void permutate(final float[] x) {
>         for (int i = 0; i < x.length; ++i) {
>             final int j = i + this.nextInt(x.length - i);
>             MathExModified.swap(x, i, j);
>         }
>     }
>     
>     public void permutate(final double[] x) {
>         for (int i = 0; i < x.length; ++i) {
>             final int j = i + this.nextInt(x.length - i);
>             MathExModified.swap(x, i, j);
>         }
>     }
>     
>     public void permutate(final Object[] x) {
>         for (int i = 0; i < x.length; ++i) {
>             final int j = i + this.nextInt(x.length - i);
>             MathExModified.swap(x, i, j);
>         }
>     }
diff -r TrackAnalyzer_/smileModified/RandomNumberGeneratorModified.java procyon/smileModified/RandomNumberGeneratorModified.java
1,8c1,3
< package smileModified;
< 
< public interface RandomNumberGeneratorModified {
<    void setSeed(long var1);
< 
<    int next(int var1);
< 
<    int nextInt();
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
10,14c5
<    int nextInt(int var1);
< 
<    long nextLong();
< 
<    double nextDouble();
---
> package smileModified;
16c7,21
<    void nextDoubles(double[] var1);
---
> public interface RandomNumberGeneratorModified
> {
>     void setSeed(final long p0);
>     
>     int next(final int p0);
>     
>     int nextInt();
>     
>     int nextInt(final int p0);
>     
>     long nextLong();
>     
>     double nextDouble();
>     
>     void nextDoubles(final double[] p0);
diff -r TrackAnalyzer_/smileModified/SideModified.java procyon/smileModified/SideModified.java
1,8c1,3
< package smileModified;
< 
< public enum SideModified {
<    LEFT(141, (byte)76),
<    RIGHT(142, (byte)82);
< 
<    private final int blas;
<    private final byte lapack;
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
10,17c5
<    private SideModified(int blas, byte lapack) {
<       this.blas = blas;
<       this.lapack = lapack;
<    }
< 
<    public int blas() {
<       return this.blas;
<    }
---
> package smileModified;
19,21c7,26
<    public byte lapack() {
<       return this.lapack;
<    }
---
> public enum SideModified
> {
>     LEFT("LEFT", 0, 141, (byte)76), 
>     RIGHT("RIGHT", 1, 142, (byte)82);
>     
>     private final int blas;
>     private final byte lapack;
>     
>     private SideModified(final String name, final int ordinal, final int blas, final byte lapack) {
>         this.blas = blas;
>         this.lapack = lapack;
>     }
>     
>     public int blas() {
>         return this.blas;
>     }
>     
>     public byte lapack() {
>         return this.lapack;
>     }
diff -r TrackAnalyzer_/smileModified/SortModified.java procyon/smileModified/SortModified.java
1,56c1,3
< package smileModified;
< 
< public interface SortModified {
<    static void swap(int[] x, int i, int j) {
<       int a = x[i];
<       x[i] = x[j];
<       x[j] = a;
<    }
< 
<    static void swap(float[] x, int i, int j) {
<       float a = x[i];
<       x[i] = x[j];
<       x[j] = a;
<    }
< 
<    static void swap(double[] x, int i, int j) {
<       double a = x[i];
<       x[i] = x[j];
<       x[j] = a;
<    }
< 
<    static void swap(Object[] x, int i, int j) {
<       Object a = x[i];
<       x[i] = x[j];
<       x[j] = a;
<    }
< 
<    static void siftUp(int[] x, int k) {
<       while(k > 1 && x[k / 2] < x[k]) {
<          swap(x, k, k / 2);
<          k /= 2;
<       }
< 
<    }
< 
<    static void siftUp(float[] x, int k) {
<       while(k > 1 && x[k / 2] < x[k]) {
<          swap(x, k, k / 2);
<          k /= 2;
<       }
< 
<    }
< 
<    static void siftUp(double[] x, int k) {
<       while(k > 1 && x[k / 2] < x[k]) {
<          swap(x, k, k / 2);
<          k /= 2;
<       }
< 
<    }
< 
<    static <T extends Comparable<? super T>> void siftUp(T[] x, int k) {
<       while(k > 1 && x[k / 2].compareTo(x[k]) < 0) {
<          swap((Object[])x, k, k / 2);
<          k /= 2;
<       }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
58c5
<    }
---
> package smileModified;
60,62c7,62
<    static void siftDown(int[] x, int k, int n) {
<       while(true) {
<          if (2 * k <= n) {
---
> public interface SortModified
> {
>     default void swap(final int[] x, final int i, final int j) {
>         final int a = x[i];
>         x[i] = x[j];
>         x[j] = a;
>     }
>     
>     default void swap(final float[] x, final int i, final int j) {
>         final float a = x[i];
>         x[i] = x[j];
>         x[j] = a;
>     }
>     
>     default void swap(final double[] x, final int i, final int j) {
>         final double a = x[i];
>         x[i] = x[j];
>         x[j] = a;
>     }
>     
>     default void swap(final Object[] x, final int i, final int j) {
>         final Object a = x[i];
>         x[i] = x[j];
>         x[j] = a;
>     }
>     
>     default void siftUp(final int[] x, int k) {
>         while (k > 1 && x[k / 2] < x[k]) {
>             swap(x, k, k / 2);
>             k /= 2;
>         }
>     }
>     
>     default void siftUp(final float[] x, int k) {
>         while (k > 1 && x[k / 2] < x[k]) {
>             swap(x, k, k / 2);
>             k /= 2;
>         }
>     }
>     
>     default void siftUp(final double[] x, int k) {
>         while (k > 1 && x[k / 2] < x[k]) {
>             swap(x, k, k / 2);
>             k /= 2;
>         }
>     }
>     
>     default <T extends Comparable<? super T>> void siftUp(final T[] x, int k) {
>         while (k > 1 && x[k / 2].compareTo((Object)x[k]) < 0) {
>             swap(x, k, k / 2);
>             k /= 2;
>         }
>     }
>     
>     default void siftDown(final int[] x, int k, final int n) {
>         while (2 * k <= n) {
65c65
<                ++j;
---
>                 ++j;
67,71c67,68
< 
<             if (x[k] < x[j]) {
<                swap(x, k, j);
<                k = j;
<                continue;
---
>             if (x[k] >= x[j]) {
>                 break;
73,81c70,76
<          }
< 
<          return;
<       }
<    }
< 
<    static void siftDown(float[] x, int k, int n) {
<       while(true) {
<          if (2 * k <= n) {
---
>             swap(x, k, j);
>             k = j;
>         }
>     }
>     
>     default void siftDown(final float[] x, int k, final int n) {
>         while (2 * k <= n) {
84c79
<                ++j;
---
>                 ++j;
86,90c81,82
< 
<             if (!(x[k] >= x[j])) {
<                swap(x, k, j);
<                k = j;
<                continue;
---
>             if (x[k] >= x[j]) {
>                 break;
92,100c84,90
<          }
< 
<          return;
<       }
<    }
< 
<    static void siftDown(double[] x, int k, int n) {
<       while(true) {
<          if (2 * k <= n) {
---
>             swap(x, k, j);
>             k = j;
>         }
>     }
>     
>     default void siftDown(final double[] x, int k, final int n) {
>         while (2 * k <= n) {
103c93
<                ++j;
---
>                 ++j;
105,109c95,96
< 
<             if (!(x[k] >= x[j])) {
<                swap(x, k, j);
<                k = j;
<                continue;
---
>             if (x[k] >= x[j]) {
>                 break;
111,119c98,104
<          }
< 
<          return;
<       }
<    }
< 
<    static <T extends Comparable<? super T>> void siftDown(T[] x, int k, int n) {
<       while(true) {
<          if (2 * k <= n) {
---
>             swap(x, k, j);
>             k = j;
>         }
>     }
>     
>     default <T extends Comparable<? super T>> void siftDown(final T[] x, int k, final int n) {
>         while (2 * k <= n) {
121,122c106,107
<             if (j < n && x[j].compareTo(x[j + 1]) < 0) {
<                ++j;
---
>             if (j < n && x[j].compareTo((Object)x[j + 1]) < 0) {
>                 ++j;
124,128c109,110
< 
<             if (x[k].compareTo(x[j]) < 0) {
<                swap((Object[])x, k, j);
<                k = j;
<                continue;
---
>             if (x[k].compareTo((Object)x[j]) >= 0) {
>                 break;
130,134c112,115
<          }
< 
<          return;
<       }
<    }
---
>             swap(x, k, j);
>             k = j;
>         }
>     }
diff -r TrackAnalyzer_/smileModified/SparseArrayModified.java procyon/smileModified/SparseArrayModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,6d6
< import java.io.Serializable;
< import java.util.Iterator;
< import java.util.List;
< import java.util.stream.Collectors;
7a8,10
> import java.util.function.Function;
> import java.util.stream.Collector;
> import java.util.stream.Collectors;
8a12,14
> import java.util.Iterator;
> import java.util.List;
> import java.io.Serializable;
10,96c16,83
< public class SparseArrayModified implements Iterable<SparseArrayModified.Entry>, Serializable {
<    private static final long serialVersionUID = 2L;
<    private final IntArrayListModified index;
<    private final DoubleArrayListModified value;
< 
<    public SparseArrayModified() {
<       this(10);
<    }
< 
<    public SparseArrayModified(int initialCapacity) {
<       this.index = new IntArrayListModified(initialCapacity);
<       this.value = new DoubleArrayListModified(initialCapacity);
<    }
< 
<    public SparseArrayModified(List<SparseArrayModified.Entry> entries) {
<       this.index = new IntArrayListModified(entries.size());
<       this.value = new DoubleArrayListModified(entries.size());
<       Iterator var3 = entries.iterator();
< 
<       while(var3.hasNext()) {
<          SparseArrayModified.Entry e = (SparseArrayModified.Entry)var3.next();
<          this.index.add(e.i);
<          this.value.add(e.x);
<       }
< 
<    }
< 
<    public SparseArrayModified(Stream<SparseArrayModified.Entry> stream) {
<       this((List)stream.collect(Collectors.toList()));
<    }
< 
<    public String toString() {
<       return (String)this.stream().map(SparseArrayModified.Entry::toString).collect(Collectors.joining(", ", "[", "]"));
<    }
< 
<    public int size() {
<       return this.index.size();
<    }
< 
<    public boolean isEmpty() {
<       return this.index.isEmpty();
<    }
< 
<    public Iterator<SparseArrayModified.Entry> iterator() {
<       return new Iterator<SparseArrayModified.Entry>() {
<          int i = 0;
< 
<          public boolean hasNext() {
<             return this.i < SparseArrayModified.this.size();
<          }
< 
<          public SparseArrayModified.Entry next() {
<             return SparseArrayModified.this.new Entry(this.i++, (SparseArrayModified.Entry)null);
<          }
<       };
<    }
< 
<    public Stream<SparseArrayModified.Entry> stream() {
<       return IntStream.range(0, this.size()).mapToObj((var1) -> {
<          return this.new Entry(var1, (SparseArrayModified.Entry)null);
<       });
<    }
< 
<    public void sort() {
<       QuickSortModified.sort(this.index.data, this.value.data, this.size());
<    }
< 
<    public double get(int i) {
<       int length = this.size();
< 
<       for(int k = 0; k < length; ++k) {
<          if (this.index.get(k) == i) {
<             return this.value.get(k);
<          }
<       }
< 
<       return 0.0D;
<    }
< 
<    public boolean set(int i, double x) {
<       if (x == 0.0D) {
<          this.remove(i);
<          return false;
<       } else {
<          int length = this.size();
< 
<          for(int k = 0; k < length; ++k) {
---
> public class SparseArrayModified implements Iterable<Entry>, Serializable
> {
>     private static final long serialVersionUID = 2L;
>     private final IntArrayListModified index;
>     private final DoubleArrayListModified value;
>     
>     public SparseArrayModified() {
>         this(10);
>     }
>     
>     public SparseArrayModified(final int initialCapacity) {
>         this.index = new IntArrayListModified(initialCapacity);
>         this.value = new DoubleArrayListModified(initialCapacity);
>     }
>     
>     public SparseArrayModified(final List<Entry> entries) {
>         this.index = new IntArrayListModified(entries.size());
>         this.value = new DoubleArrayListModified(entries.size());
>         for (final Entry e : entries) {
>             this.index.add(e.i);
>             this.value.add(e.x);
>         }
>     }
>     
>     public SparseArrayModified(final Stream<Entry> stream) {
>         this((List<Entry>)stream.<List<? super Entry>, ?>collect((Collector<? super Entry, ?, List<? super Entry>>)Collectors.<Entry>toList()));
>     }
>     
>     @Override
>     public String toString() {
>         return this.stream().<Object>map((Function<? super Entry, ?>)Entry::toString).<String, ?>collect((Collector<? super Object, ?, String>)Collectors.joining(", ", "[", "]"));
>     }
>     
>     public int size() {
>         return this.index.size();
>     }
>     
>     public boolean isEmpty() {
>         return this.index.isEmpty();
>     }
>     
>     @Override
>     public Iterator<Entry> iterator() {
>         return new Iterator<Entry>() {
>             int i = 0;
>             
>             @Override
>             public boolean hasNext() {
>                 return this.i < SparseArrayModified.this.size();
>             }
>             
>             @Override
>             public Entry next() {
>                 return new Entry(this.i++, (Entry)null);
>             }
>         };
>     }
>     
>     public Stream<Entry> stream() {
>         return IntStream.range(0, this.size()).<Entry>mapToObj(n -> new Entry(n, (Entry)null));
>     }
>     
>     public void sort() {
>         QuickSortModified.sort(this.index.data, this.value.data, this.size());
>     }
>     
>     public double get(final int i) {
>         for (int length = this.size(), k = 0; k < length; ++k) {
98,99c85
<                this.value.set(k, x);
<                return false;
---
>                 return this.value.get(k);
101,153c87,144
<          }
< 
<          this.index.add(i);
<          this.value.add(x);
<          return true;
<       }
<    }
< 
<    public void append(int i, double x) {
<       if (x != 0.0D) {
<          this.index.add(i);
<          this.value.add(x);
<       }
< 
<    }
< 
<    public void remove(int i) {
<       int length = this.size();
< 
<       for(int k = 0; k < length; ++k) {
<          if (this.index.get(k) == i) {
<             this.index.remove(k);
<             this.value.remove(k);
<             return;
<          }
<       }
< 
<    }
< 
<    public class Entry {
<       public final int i;
<       public final double x;
<       private final int index;
< 
<       private Entry(int index) {
<          this.i = SparseArrayModified.this.index.get(index);
<          this.x = SparseArrayModified.this.value.get(index);
<          this.index = index;
<       }
< 
<       public void update(double x) {
<          SparseArrayModified.this.value.set(this.index, x);
<       }
< 
<       public String toString() {
<          return String.format("%d:%s", this.i, StringsModified.format(this.x));
<       }
< 
<       // $FF: synthetic method
<       Entry(int var2, SparseArrayModified.Entry var3) {
<          this(var2);
<       }
<    }
---
>         }
>         return 0.0;
>     }
>     
>     public boolean set(final int i, final double x) {
>         if (x == 0.0) {
>             this.remove(i);
>             return false;
>         }
>         for (int length = this.size(), k = 0; k < length; ++k) {
>             if (this.index.get(k) == i) {
>                 this.value.set(k, x);
>                 return false;
>             }
>         }
>         this.index.add(i);
>         this.value.add(x);
>         return true;
>     }
>     
>     public void append(final int i, final double x) {
>         if (x != 0.0) {
>             this.index.add(i);
>             this.value.add(x);
>         }
>     }
>     
>     public void remove(final int i) {
>         for (int length = this.size(), k = 0; k < length; ++k) {
>             if (this.index.get(k) == i) {
>                 this.index.remove(k);
>                 this.value.remove(k);
>                 return;
>             }
>         }
>     }
>     
>     public class Entry
>     {
>         public final int i;
>         public final double x;
>         private final int index;
>         
>         private Entry(final int index) {
>             this.i = SparseArrayModified.this.index.get(index);
>             this.x = SparseArrayModified.this.value.get(index);
>             this.index = index;
>         }
>         
>         public void update(final double x) {
>             SparseArrayModified.this.value.set(this.index, x);
>         }
>         
>         @Override
>         public String toString() {
>             return String.format("%d:%s", this.i, StringsModified.format(this.x));
>         }
>     }
diff -r TrackAnalyzer_/smileModified/SparseMatrixModified.java procyon/smileModified/SparseMatrixModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
4a9
> import java.util.Scanner;
5a11
> import java.nio.file.OpenOption;
8,9d13
< import java.util.Iterator;
< import java.util.Scanner;
10a15,16
> import java.util.stream.StreamSupport;
> import java.util.Iterator;
13,14d18
< import java.util.stream.StreamSupport;
< import org.slf4j.Logger;
15a20
> import org.slf4j.Logger;
17,135c22,121
< public class SparseMatrixModified extends IMatrixModified implements Iterable<SparseMatrixModified.Entry> {
<    private static final Logger logger = LoggerFactory.getLogger(SparseMatrixModified.class);
<    private static final long serialVersionUID = 2L;
<    private final int m;
<    private final int n;
<    private final int[] colIndex;
<    private final int[] rowIndex;
<    private final double[] nonzeros;
< 
<    private SparseMatrixModified(int m, int n, int nvals) {
<       this.m = m;
<       this.n = n;
<       this.rowIndex = new int[nvals];
<       this.colIndex = new int[n + 1];
<       this.nonzeros = new double[nvals];
<    }
< 
<    public SparseMatrixModified(int m, int n, double[] nonzeros, int[] rowIndex, int[] colIndex) {
<       this.m = m;
<       this.n = n;
<       this.rowIndex = rowIndex;
<       this.colIndex = colIndex;
<       this.nonzeros = nonzeros;
<    }
< 
<    public SparseMatrixModified(double[][] A) {
<       this(A, 100.0D * MathExModified.EPSILON);
<    }
< 
<    public SparseMatrixModified(double[][] A, double tol) {
<       this.m = A.length;
<       this.n = A[0].length;
<       int nvals = 0;
< 
<       int k;
<       int j;
<       for(k = 0; k < this.m; ++k) {
<          for(j = 0; j < this.n; ++j) {
<             if (Math.abs(A[k][j]) >= tol) {
<                ++nvals;
<             }
<          }
<       }
< 
<       this.nonzeros = new double[nvals];
<       this.rowIndex = new int[nvals];
<       this.colIndex = new int[this.n + 1];
<       this.colIndex[this.n] = nvals;
<       k = 0;
< 
<       for(j = 0; j < this.n; ++j) {
<          this.colIndex[j] = k;
< 
<          for(int i = 0; i < this.m; ++i) {
<             if (Math.abs(A[i][j]) >= tol) {
<                this.rowIndex[k] = i;
<                this.nonzeros[k] = A[i][j];
<                ++k;
<             }
<          }
<       }
< 
<    }
< 
<    public SparseMatrixModified clone() {
<       return new SparseMatrixModified(this.m, this.n, (double[])this.nonzeros.clone(), (int[])this.rowIndex.clone(), (int[])this.colIndex.clone());
<    }
< 
<    public int nrow() {
<       return this.m;
<    }
< 
<    public int ncol() {
<       return this.n;
<    }
< 
<    public long size() {
<       return (long)this.colIndex[this.n];
<    }
< 
<    public Stream<SparseMatrixModified.Entry> nonzeros() {
<       Spliterator<SparseMatrixModified.Entry> spliterator = Spliterators.spliterator(this.iterator(), this.size(), 1104);
<       return StreamSupport.stream(spliterator, false);
<    }
< 
<    public Stream<SparseMatrixModified.Entry> nonzeros(int beginColumn, int endColumn) {
<       Spliterator<SparseMatrixModified.Entry> spliterator = Spliterators.spliterator(this.iterator(beginColumn, endColumn), (long)(this.colIndex[endColumn] - this.colIndex[beginColumn]), 1104);
<       return StreamSupport.stream(spliterator, false);
<    }
< 
<    public Iterator<SparseMatrixModified.Entry> iterator() {
<       return this.iterator(0, this.n);
<    }
< 
<    public Iterator<SparseMatrixModified.Entry> iterator(int beginColumn, final int endColumn) {
<       if (beginColumn >= 0 && beginColumn < this.n) {
<          if (endColumn > beginColumn && endColumn <= this.n) {
<             return new Iterator<SparseMatrixModified.Entry>(beginColumn) {
<                int k;
<                int j;
< 
<                {
<                   this.k = SparseMatrixModified.this.colIndex[var2];
<                   this.j = var2;
<                }
< 
<                public boolean hasNext() {
<                   return this.k < SparseMatrixModified.this.colIndex[endColumn];
<                }
< 
<                public SparseMatrixModified.Entry next() {
<                   int i;
<                   for(i = SparseMatrixModified.this.rowIndex[this.k]; this.k >= SparseMatrixModified.this.colIndex[this.j + 1]; ++this.j) {
<                   }
< 
<                   return SparseMatrixModified.this.new Entry(i, this.j, this.k++, (SparseMatrixModified.Entry)null);
<                }
<             };
<          } else {
---
> public class SparseMatrixModified extends IMatrixModified implements Iterable<Entry>
> {
>     private static final Logger logger;
>     private static final long serialVersionUID = 2L;
>     private final int m;
>     private final int n;
>     private final int[] colIndex;
>     private final int[] rowIndex;
>     private final double[] nonzeros;
>     
>     static {
>         logger = LoggerFactory.getLogger((Class)SparseMatrixModified.class);
>     }
>     
>     private SparseMatrixModified(final int m, final int n, final int nvals) {
>         this.m = m;
>         this.n = n;
>         this.rowIndex = new int[nvals];
>         this.colIndex = new int[n + 1];
>         this.nonzeros = new double[nvals];
>     }
>     
>     public SparseMatrixModified(final int m, final int n, final double[] nonzeros, final int[] rowIndex, final int[] colIndex) {
>         this.m = m;
>         this.n = n;
>         this.rowIndex = rowIndex;
>         this.colIndex = colIndex;
>         this.nonzeros = nonzeros;
>     }
>     
>     public SparseMatrixModified(final double[][] A) {
>         this(A, 100.0 * MathExModified.EPSILON);
>     }
>     
>     public SparseMatrixModified(final double[][] A, final double tol) {
>         this.m = A.length;
>         this.n = A[0].length;
>         int nvals = 0;
>         for (int i = 0; i < this.m; ++i) {
>             for (int j = 0; j < this.n; ++j) {
>                 if (Math.abs(A[i][j]) >= tol) {
>                     ++nvals;
>                 }
>             }
>         }
>         this.nonzeros = new double[nvals];
>         this.rowIndex = new int[nvals];
>         (this.colIndex = new int[this.n + 1])[this.n] = nvals;
>         int k = 0;
>         for (int j = 0; j < this.n; ++j) {
>             this.colIndex[j] = k;
>             for (int l = 0; l < this.m; ++l) {
>                 if (Math.abs(A[l][j]) >= tol) {
>                     this.rowIndex[k] = l;
>                     this.nonzeros[k] = A[l][j];
>                     ++k;
>                 }
>             }
>         }
>     }
>     
>     public SparseMatrixModified clone() {
>         return new SparseMatrixModified(this.m, this.n, this.nonzeros.clone(), this.rowIndex.clone(), this.colIndex.clone());
>     }
>     
>     @Override
>     public int nrow() {
>         return this.m;
>     }
>     
>     @Override
>     public int ncol() {
>         return this.n;
>     }
>     
>     @Override
>     public long size() {
>         return this.colIndex[this.n];
>     }
>     
>     public Stream<Entry> nonzeros() {
>         final Spliterator<Entry> spliterator = Spliterators.<Entry>spliterator((Iterator<? extends Entry>)this.iterator(), this.size(), 1104);
>         return StreamSupport.<Entry>stream(spliterator, false);
>     }
>     
>     public Stream<Entry> nonzeros(final int beginColumn, final int endColumn) {
>         final Spliterator<Entry> spliterator = Spliterators.<Entry>spliterator((Iterator<? extends Entry>)this.iterator(beginColumn, endColumn), (long)(this.colIndex[endColumn] - this.colIndex[beginColumn]), 1104);
>         return StreamSupport.<Entry>stream(spliterator, false);
>     }
>     
>     @Override
>     public Iterator<Entry> iterator() {
>         return this.iterator(0, this.n);
>     }
>     
>     public Iterator<Entry> iterator(final int beginColumn, final int endColumn) {
>         if (beginColumn < 0 || beginColumn >= this.n) {
>             throw new IllegalArgumentException("Invalid begin column: " + beginColumn);
>         }
>         if (endColumn <= beginColumn || endColumn > this.n) {
137,163c123,157
<          }
<       } else {
<          throw new IllegalArgumentException("Invalid begin column: " + beginColumn);
<       }
<    }
< 
<    public void forEachNonZero(DoubleConsumerModified consumer) {
<       for(int j = 0; j < this.n; ++j) {
<          for(int k = this.colIndex[j]; k < this.colIndex[j + 1]; ++k) {
<             int i = this.rowIndex[k];
<             consumer.accept(i, j, this.nonzeros[k]);
<          }
<       }
< 
<    }
< 
<    public void forEachNonZero(int beginColumn, int endColumn, DoubleConsumerModified consumer) {
<       if (beginColumn >= 0 && beginColumn < this.n) {
<          if (endColumn > beginColumn && endColumn <= this.n) {
<             for(int j = beginColumn; j < endColumn; ++j) {
<                for(int k = this.colIndex[j]; k < this.colIndex[j + 1]; ++k) {
<                   int i = this.rowIndex[k];
<                   consumer.accept(i, j, this.nonzeros[k]);
<                }
<             }
< 
<          } else {
---
>         }
>         return new Iterator<Entry>(beginColumn) {
>             int k = SparseMatrixModified.this.colIndex[j];
>             int j = j;
>             
>             @Override
>             public boolean hasNext() {
>                 return this.k < SparseMatrixModified.this.colIndex[endColumn];
>             }
>             
>             @Override
>             public Entry next() {
>                 final int i = SparseMatrixModified.this.rowIndex[this.k];
>                 while (this.k >= SparseMatrixModified.this.colIndex[this.j + 1]) {
>                     ++this.j;
>                 }
>                 return new Entry(i, this.j, this.k++, (Entry)null);
>             }
>         };
>     }
>     
>     public void forEachNonZero(final DoubleConsumerModified consumer) {
>         for (int j = 0; j < this.n; ++j) {
>             for (int k = this.colIndex[j]; k < this.colIndex[j + 1]; ++k) {
>                 final int i = this.rowIndex[k];
>                 consumer.accept(i, j, this.nonzeros[k]);
>             }
>         }
>     }
>     
>     public void forEachNonZero(final int beginColumn, final int endColumn, final DoubleConsumerModified consumer) {
>         if (beginColumn < 0 || beginColumn >= this.n) {
>             throw new IllegalArgumentException("Invalid begin column: " + beginColumn);
>         }
>         if (endColumn <= beginColumn || endColumn > this.n) {
165,181c159,181
<          }
<       } else {
<          throw new IllegalArgumentException("Invalid begin column: " + beginColumn);
<       }
<    }
< 
<    public double get(int index) {
<       return this.nonzeros[index];
<    }
< 
<    public void set(int index, double value) {
<       this.nonzeros[index] = value;
<    }
< 
<    public double get(int i, int j) {
<       if (i >= 0 && i < this.m && j >= 0 && j < this.n) {
<          for(int k = this.colIndex[j]; k < this.colIndex[j + 1]; ++k) {
---
>         }
>         for (int j = beginColumn; j < endColumn; ++j) {
>             for (int k = this.colIndex[j]; k < this.colIndex[j + 1]; ++k) {
>                 final int i = this.rowIndex[k];
>                 consumer.accept(i, j, this.nonzeros[k]);
>             }
>         }
>     }
>     
>     public double get(final int index) {
>         return this.nonzeros[index];
>     }
>     
>     public void set(final int index, final double value) {
>         this.nonzeros[index] = value;
>     }
>     
>     @Override
>     public double get(final int i, final int j) {
>         if (i < 0 || i >= this.m || j < 0 || j >= this.n) {
>             throw new IllegalArgumentException("Invalid index: row = " + i + " col = " + j);
>         }
>         for (int k = this.colIndex[j]; k < this.colIndex[j + 1]; ++k) {
183c183
<                return this.nonzeros[k];
---
>                 return this.nonzeros[k];
185,303c185,293
<          }
< 
<          return 0.0D;
<       } else {
<          throw new IllegalArgumentException("Invalid index: row = " + i + " col = " + j);
<       }
<    }
< 
<    public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
<       int k = trans == TransposeModified.NO_TRANSPOSE ? this.m : this.n;
<       double[] ax = y;
<       if (beta == 0.0D) {
<          Arrays.fill(y, 0.0D);
<       } else {
<          ax = new double[k];
<       }
< 
<       int i;
<       int i;
<       if (trans == TransposeModified.NO_TRANSPOSE) {
<          for(i = 0; i < this.n; ++i) {
<             for(i = this.colIndex[i]; i < this.colIndex[i + 1]; ++i) {
<                int var10001 = this.rowIndex[i];
<                ax[var10001] += this.nonzeros[i] * x[i];
<             }
<          }
<       } else {
<          for(i = 0; i < this.n; ++i) {
<             for(i = this.colIndex[i]; i < this.colIndex[i + 1]; ++i) {
<                ax[i] += this.nonzeros[i] * x[this.rowIndex[i]];
<             }
<          }
<       }
< 
<       if (beta != 0.0D || alpha != 1.0D) {
<          for(i = 0; i < k; ++i) {
<             y[i] = alpha * ax[i] + beta * y[i];
<          }
<       }
< 
<    }
< 
<    public void mv(double[] work, int inputOffset, int outputOffset) {
<       Arrays.fill(work, outputOffset, outputOffset + this.m, 0.0D);
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = this.colIndex[j]; i < this.colIndex[j + 1]; ++i) {
<             int var10001 = outputOffset + this.rowIndex[i];
<             work[var10001] += this.nonzeros[i] * work[inputOffset + j];
<          }
<       }
< 
<    }
< 
<    public void tv(double[] work, int inputOffset, int outputOffset) {
<       Arrays.fill(work, outputOffset, outputOffset + this.n, 0.0D);
< 
<       for(int i = 0; i < this.n; ++i) {
<          for(int j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
<             work[outputOffset + i] += this.nonzeros[j] * work[inputOffset + this.rowIndex[j]];
<          }
<       }
< 
<    }
< 
<    public SparseMatrixModified transpose() {
<       SparseMatrixModified trans = new SparseMatrixModified(this.n, this.m, this.nonzeros.length);
<       int[] count = new int[this.m];
< 
<       int var10002;
<       int i;
<       int j;
<       int k;
<       for(i = 0; i < this.n; ++i) {
<          for(j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
<             k = this.rowIndex[j];
<             var10002 = count[k]++;
<          }
<       }
< 
<       for(i = 0; i < this.m; ++i) {
<          trans.colIndex[i + 1] = trans.colIndex[i] + count[i];
<       }
< 
<       Arrays.fill(count, 0);
< 
<       for(i = 0; i < this.n; ++i) {
<          for(j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
<             k = this.rowIndex[j];
<             int index = trans.colIndex[k] + count[k];
<             trans.rowIndex[index] = i;
<             trans.nonzeros[index] = this.nonzeros[j];
<             var10002 = count[k]++;
<          }
<       }
< 
<       return trans;
<    }
< 
<    public SparseMatrixModified mm(SparseMatrixModified B) {
<       if (this.n != B.m) {
<          throw new IllegalArgumentException(String.format("Matrix dimensions do not match for matrix multiplication: %d x %d vs %d x %d", this.nrow(), this.ncol(), B.nrow(), B.ncol()));
<       } else {
<          int n = B.n;
<          int anz = this.colIndex[n];
<          int[] Bp = B.colIndex;
<          int[] Bi = B.rowIndex;
<          double[] Bx = B.nonzeros;
<          int bnz = Bp[n];
<          int[] w = new int[this.m];
<          double[] abj = new double[this.m];
<          int nzmax = Math.max(anz + bnz, this.m);
<          SparseMatrixModified C = new SparseMatrixModified(this.m, n, nzmax);
<          int[] Cp = C.colIndex;
<          int[] Ci = C.rowIndex;
<          double[] Cx = C.nonzeros;
<          int nz = 0;
< 
<          for(int j = 0; j < n; ++j) {
---
>         }
>         return 0.0;
>     }
>     
>     @Override
>     public void mv(final TransposeModified trans, final double alpha, final double[] x, final double beta, final double[] y) {
>         final int k = (trans == TransposeModified.NO_TRANSPOSE) ? this.m : this.n;
>         double[] ax = y;
>         if (beta == 0.0) {
>             Arrays.fill(y, 0.0);
>         }
>         else {
>             ax = new double[k];
>         }
>         if (trans == TransposeModified.NO_TRANSPOSE) {
>             for (int j = 0; j < this.n; ++j) {
>                 for (int i = this.colIndex[j]; i < this.colIndex[j + 1]; ++i) {
>                     final double[] array = ax;
>                     final int n = this.rowIndex[i];
>                     array[n] += this.nonzeros[i] * x[j];
>                 }
>             }
>         }
>         else {
>             for (int l = 0; l < this.n; ++l) {
>                 for (int m = this.colIndex[l]; m < this.colIndex[l + 1]; ++m) {
>                     final double[] array2 = ax;
>                     final int n2 = l;
>                     array2[n2] += this.nonzeros[m] * x[this.rowIndex[m]];
>                 }
>             }
>         }
>         if (beta != 0.0 || alpha != 1.0) {
>             for (int l = 0; l < k; ++l) {
>                 y[l] = alpha * ax[l] + beta * y[l];
>             }
>         }
>     }
>     
>     @Override
>     public void mv(final double[] work, final int inputOffset, final int outputOffset) {
>         Arrays.fill(work, outputOffset, outputOffset + this.m, 0.0);
>         for (int j = 0; j < this.n; ++j) {
>             for (int i = this.colIndex[j]; i < this.colIndex[j + 1]; ++i) {
>                 final int n = outputOffset + this.rowIndex[i];
>                 work[n] += this.nonzeros[i] * work[inputOffset + j];
>             }
>         }
>     }
>     
>     @Override
>     public void tv(final double[] work, final int inputOffset, final int outputOffset) {
>         Arrays.fill(work, outputOffset, outputOffset + this.n, 0.0);
>         for (int i = 0; i < this.n; ++i) {
>             for (int j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
>                 final int n = outputOffset + i;
>                 work[n] += this.nonzeros[j] * work[inputOffset + this.rowIndex[j]];
>             }
>         }
>     }
>     
>     public SparseMatrixModified transpose() {
>         final SparseMatrixModified trans = new SparseMatrixModified(this.n, this.m, this.nonzeros.length);
>         final int[] count = new int[this.m];
>         for (int i = 0; i < this.n; ++i) {
>             for (int j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
>                 final int k = this.rowIndex[j];
>                 final int[] array = count;
>                 final int n = k;
>                 ++array[n];
>             }
>         }
>         for (int l = 0; l < this.m; ++l) {
>             trans.colIndex[l + 1] = trans.colIndex[l] + count[l];
>         }
>         Arrays.fill(count, 0);
>         for (int i = 0; i < this.n; ++i) {
>             for (int j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
>                 final int k = this.rowIndex[j];
>                 final int index = trans.colIndex[k] + count[k];
>                 trans.rowIndex[index] = i;
>                 trans.nonzeros[index] = this.nonzeros[j];
>                 final int[] array2 = count;
>                 final int n2 = k;
>                 ++array2[n2];
>             }
>         }
>         return trans;
>     }
>     
>     public SparseMatrixModified mm(final SparseMatrixModified B) {
>         if (this.n != B.m) {
>             throw new IllegalArgumentException(String.format("Matrix dimensions do not match for matrix multiplication: %d x %d vs %d x %d", this.nrow(), this.ncol(), B.nrow(), B.ncol()));
>         }
>         final int n = B.n;
>         final int anz = this.colIndex[n];
>         final int[] Bp = B.colIndex;
>         final int[] Bi = B.rowIndex;
>         final double[] Bx = B.nonzeros;
>         final int bnz = Bp[n];
>         final int[] w = new int[this.m];
>         final double[] abj = new double[this.m];
>         int nzmax = Math.max(anz + bnz, this.m);
>         SparseMatrixModified C = new SparseMatrixModified(this.m, n, nzmax);
>         final int[] Cp = C.colIndex;
>         int[] Ci = C.rowIndex;
>         double[] Cx = C.nonzeros;
>         int nz = 0;
>         for (int j = 0; j < n; ++j) {
305,312c295,302
<                nzmax = 2 * nzmax + this.m;
<                double[] Cx2 = new double[nzmax];
<                int[] Ci2 = new int[nzmax];
<                System.arraycopy(Ci, 0, Ci2, 0, nz);
<                System.arraycopy(Cx, 0, Cx2, 0, nz);
<                Ci = Ci2;
<                Cx = Cx2;
<                C = new SparseMatrixModified(this.m, n, Cx2, Ci2, Cp);
---
>                 nzmax = 2 * nzmax + this.m;
>                 final double[] Cx2 = new double[nzmax];
>                 final int[] Ci2 = new int[nzmax];
>                 System.arraycopy(Ci, 0, Ci2, 0, nz);
>                 System.arraycopy(Cx, 0, Cx2, 0, nz);
>                 Ci = Ci2;
>                 Cx = Cx2;
>                 C = new SparseMatrixModified(this.m, n, Cx2, Ci2, Cp);
314d303
< 
316,431c305,306
< 
<             int p;
<             for(p = Bp[j]; p < Bp[j + 1]; ++p) {
<                nz = scatter(this, Bi[p], Bx[p], w, abj, j + 1, C, nz);
<             }
< 
<             for(p = Cp[j]; p < nz; ++p) {
<                Cx[p] = abj[Ci[p]];
<             }
<          }
< 
<          Cp[n] = nz;
<          return C;
<       }
<    }
< 
<    private static int scatter(SparseMatrixModified A, int j, double beta, int[] w, double[] x, int mark, SparseMatrixModified C, int nz) {
<       int[] Ap = A.colIndex;
<       int[] Ai = A.rowIndex;
<       double[] Ax = A.nonzeros;
<       int[] Ci = C.rowIndex;
< 
<       for(int p = Ap[j]; p < Ap[j + 1]; ++p) {
<          int i = Ai[p];
<          if (w[i] < mark) {
<             w[i] = mark;
<             Ci[nz++] = i;
<             x[i] = beta * Ax[p];
<          } else {
<             x[i] += beta * Ax[p];
<          }
<       }
< 
<       return nz;
<    }
< 
<    public SparseMatrixModified ata() {
<       SparseMatrixModified AT = this.transpose();
<       return AT.aat(this);
<    }
< 
<    public SparseMatrixModified aat() {
<       SparseMatrixModified AT = this.transpose();
<       return this.aat(AT);
<    }
< 
<    private SparseMatrixModified aat(SparseMatrixModified AT) {
<       int[] done = new int[this.m];
< 
<       int nvals;
<       for(nvals = 0; nvals < this.m; ++nvals) {
<          done[nvals] = -1;
<       }
< 
<       nvals = 0;
< 
<       int j;
<       int i;
<       int j;
<       int k;
<       for(int j = 0; j < this.m; ++j) {
<          for(j = AT.colIndex[j]; j < AT.colIndex[j + 1]; ++j) {
<             i = AT.rowIndex[j];
< 
<             for(j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
<                k = this.rowIndex[j];
<                if (done[k] != j) {
<                   done[k] = j;
<                   ++nvals;
<                }
<             }
<          }
<       }
< 
<       SparseMatrixModified aat = new SparseMatrixModified(this.m, this.m, nvals);
<       nvals = 0;
< 
<       for(j = 0; j < this.m; ++j) {
<          done[j] = -1;
<       }
< 
<       int l;
<       for(j = 0; j < this.m; ++j) {
<          aat.colIndex[j] = nvals;
< 
<          for(i = AT.colIndex[j]; i < AT.colIndex[j + 1]; ++i) {
<             j = AT.rowIndex[i];
< 
<             for(k = this.colIndex[j]; k < this.colIndex[j + 1]; ++k) {
<                l = this.rowIndex[k];
<                if (done[l] != j) {
<                   done[l] = j;
<                   aat.rowIndex[nvals] = l;
<                   ++nvals;
<                }
<             }
<          }
<       }
< 
<       aat.colIndex[this.m] = nvals;
< 
<       for(j = 0; j < this.m; ++j) {
<          if (aat.colIndex[j + 1] - aat.colIndex[j] > 1) {
<             Arrays.sort(aat.rowIndex, aat.colIndex[j], aat.colIndex[j + 1]);
<          }
<       }
< 
<       double[] temp = new double[this.m];
< 
<       for(i = 0; i < this.m; ++i) {
<          for(j = AT.colIndex[i]; j < AT.colIndex[i + 1]; ++j) {
<             k = AT.rowIndex[j];
< 
<             for(l = this.colIndex[k]; l < this.colIndex[k + 1]; ++l) {
<                int h = this.rowIndex[l];
<                temp[h] += AT.nonzeros[j] * this.nonzeros[l];
---
>             for (int p = Bp[j]; p < Bp[j + 1]; ++p) {
>                 nz = scatter(this, Bi[p], Bx[p], w, abj, j + 1, C, nz);
433,453c308,309
<          }
< 
<          for(j = aat.colIndex[i]; j < aat.colIndex[i + 1]; ++j) {
<             k = aat.rowIndex[j];
<             aat.nonzeros[j] = temp[k];
<             temp[k] = 0.0D;
<          }
<       }
< 
<       return aat;
<    }
< 
<    public double[] diag() {
<       int n = Math.min(this.nrow(), this.ncol());
<       double[] d = new double[n];
< 
<       for(int i = 0; i < n; ++i) {
<          for(int j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
<             if (this.rowIndex[j] == i) {
<                d[i] = this.nonzeros[j];
<                break;
---
>             for (int p = Cp[j]; p < nz; ++p) {
>                 Cx[p] = abj[Ci[p]];
455,472c311,424
<          }
<       }
< 
<       return d;
<    }
< 
<    public static SparseMatrixModified harwell(Path path) throws IOException {
<       logger.info("Reads sparse matrix file '{}'", path.toAbsolutePath());
<       Throwable var1 = null;
<       Object var2 = null;
< 
<       try {
<          InputStream stream = Files.newInputStream(path);
< 
<          SparseMatrixModified var10000;
<          try {
<             Scanner scanner = new Scanner(stream);
< 
---
>         }
>         Cp[n] = nz;
>         return C;
>     }
>     
>     private static int scatter(final SparseMatrixModified A, final int j, final double beta, final int[] w, final double[] x, final int mark, final SparseMatrixModified C, int nz) {
>         final int[] Ap = A.colIndex;
>         final int[] Ai = A.rowIndex;
>         final double[] Ax = A.nonzeros;
>         final int[] Ci = C.rowIndex;
>         for (int p = Ap[j]; p < Ap[j + 1]; ++p) {
>             final int i = Ai[p];
>             if (w[i] < mark) {
>                 w[i] = mark;
>                 x[Ci[nz++] = i] = beta * Ax[p];
>             }
>             else {
>                 final int n = i;
>                 x[n] += beta * Ax[p];
>             }
>         }
>         return nz;
>     }
>     
>     public SparseMatrixModified ata() {
>         final SparseMatrixModified AT = this.transpose();
>         return AT.aat(this);
>     }
>     
>     public SparseMatrixModified aat() {
>         final SparseMatrixModified AT = this.transpose();
>         return this.aat(AT);
>     }
>     
>     private SparseMatrixModified aat(final SparseMatrixModified AT) {
>         final int[] done = new int[this.m];
>         for (int i = 0; i < this.m; ++i) {
>             done[i] = -1;
>         }
>         int nvals = 0;
>         for (int j = 0; j < this.m; ++j) {
>             for (int k = AT.colIndex[j]; k < AT.colIndex[j + 1]; ++k) {
>                 for (int l = AT.rowIndex[k], m = this.colIndex[l]; m < this.colIndex[l + 1]; ++m) {
>                     final int h = this.rowIndex[m];
>                     if (done[h] != j) {
>                         done[h] = j;
>                         ++nvals;
>                     }
>                 }
>             }
>         }
>         final SparseMatrixModified aat = new SparseMatrixModified(this.m, this.m, nvals);
>         nvals = 0;
>         for (int k = 0; k < this.m; ++k) {
>             done[k] = -1;
>         }
>         for (int j2 = 0; j2 < this.m; ++j2) {
>             aat.colIndex[j2] = nvals;
>             for (int i2 = AT.colIndex[j2]; i2 < AT.colIndex[j2 + 1]; ++i2) {
>                 for (int k2 = AT.rowIndex[i2], l2 = this.colIndex[k2]; l2 < this.colIndex[k2 + 1]; ++l2) {
>                     final int h2 = this.rowIndex[l2];
>                     if (done[h2] != j2) {
>                         done[h2] = j2;
>                         aat.rowIndex[nvals] = h2;
>                         ++nvals;
>                     }
>                 }
>             }
>         }
>         aat.colIndex[this.m] = nvals;
>         for (int j2 = 0; j2 < this.m; ++j2) {
>             if (aat.colIndex[j2 + 1] - aat.colIndex[j2] > 1) {
>                 Arrays.sort(aat.rowIndex, aat.colIndex[j2], aat.colIndex[j2 + 1]);
>             }
>         }
>         final double[] temp = new double[this.m];
>         for (int i2 = 0; i2 < this.m; ++i2) {
>             for (int j3 = AT.colIndex[i2]; j3 < AT.colIndex[i2 + 1]; ++j3) {
>                 for (int k3 = AT.rowIndex[j3], l3 = this.colIndex[k3]; l3 < this.colIndex[k3 + 1]; ++l3) {
>                     final int h3 = this.rowIndex[l3];
>                     final double[] array = temp;
>                     final int n = h3;
>                     array[n] += AT.nonzeros[j3] * this.nonzeros[l3];
>                 }
>             }
>             for (int j3 = aat.colIndex[i2]; j3 < aat.colIndex[i2 + 1]; ++j3) {
>                 final int k3 = aat.rowIndex[j3];
>                 aat.nonzeros[j3] = temp[k3];
>                 temp[k3] = 0.0;
>             }
>         }
>         return aat;
>     }
>     
>     @Override
>     public double[] diag() {
>         final int n = Math.min(this.nrow(), this.ncol());
>         final double[] d = new double[n];
>         for (int i = 0; i < n; ++i) {
>             for (int j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
>                 if (this.rowIndex[j] == i) {
>                     d[i] = this.nonzeros[j];
>                     break;
>                 }
>             }
>         }
>         return d;
>     }
>     
>     public static SparseMatrixModified harwell(final Path path) throws IOException {
>         SparseMatrixModified.logger.info("Reads sparse matrix file '{}'", (Object)path.toAbsolutePath());
>         Throwable t = null;
>         try {
>             final InputStream stream = Files.newInputStream(path, new OpenOption[0]);
474,565c426,513
<                String line = scanner.nextLine();
<                logger.info(line);
<                line = scanner.nextLine().trim();
<                logger.info(line);
<                String[] tokens = line.split("\\s+");
<                int RHSCRD = Integer.parseInt(tokens[4]);
<                line = scanner.nextLine().trim();
<                logger.info(line);
<                if (!line.startsWith("R")) {
<                   throw new UnsupportedOperationException("SparseMatrix supports only real-valued matrix.");
<                }
< 
<                tokens = line.split("\\s+");
<                int nrow = Integer.parseInt(tokens[1]);
<                int ncol = Integer.parseInt(tokens[2]);
<                int nz = Integer.parseInt(tokens[3]);
<                line = scanner.nextLine();
<                logger.info(line);
<                if (RHSCRD > 0) {
<                   line = scanner.nextLine();
<                   logger.info(line);
<                }
< 
<                int[] colIndex = new int[ncol + 1];
<                int[] rowIndex = new int[nz];
<                double[] data = new double[nz];
< 
<                int i;
<                for(i = 0; i <= ncol; ++i) {
<                   colIndex[i] = scanner.nextInt() - 1;
<                }
< 
<                for(i = 0; i < nz; ++i) {
<                   rowIndex[i] = scanner.nextInt() - 1;
<                }
< 
<                for(i = 0; i < nz; ++i) {
<                   data[i] = scanner.nextDouble();
<                }
< 
<                var10000 = new SparseMatrixModified(nrow, ncol, data, rowIndex, colIndex);
<             } finally {
<                if (scanner != null) {
<                   scanner.close();
<                }
< 
<             }
<          } catch (Throwable var25) {
<             if (var1 == null) {
<                var1 = var25;
<             } else if (var1 != var25) {
<                var1.addSuppressed(var25);
<             }
< 
<             if (stream != null) {
<                stream.close();
<             }
< 
<             throw var1;
<          }
< 
<          if (stream != null) {
<             stream.close();
<          }
< 
<          return var10000;
<       } catch (Throwable var26) {
<          if (var1 == null) {
<             var1 = var26;
<          } else if (var1 != var26) {
<             var1.addSuppressed(var26);
<          }
< 
<          throw var1;
<       }
<    }
< 
<    public static SparseMatrixModified rutherford(Path path) throws IOException {
<       return harwell(path);
<    }
< 
<    public static SparseMatrixModified text(Path path) throws IOException {
<       Throwable var1 = null;
<       Object var2 = null;
< 
<       try {
<          InputStream stream = Files.newInputStream(path);
< 
<          SparseMatrixModified var10000;
<          try {
<             Scanner scanner = new Scanner(stream);
< 
---
>                 final Scanner scanner = new Scanner(stream);
>                 try {
>                     String line = scanner.nextLine();
>                     SparseMatrixModified.logger.info(line);
>                     line = scanner.nextLine().trim();
>                     SparseMatrixModified.logger.info(line);
>                     String[] tokens = line.split("\\s+");
>                     final int RHSCRD = Integer.parseInt(tokens[4]);
>                     line = scanner.nextLine().trim();
>                     SparseMatrixModified.logger.info(line);
>                     if (!line.startsWith("R")) {
>                         throw new UnsupportedOperationException("SparseMatrix supports only real-valued matrix.");
>                     }
>                     tokens = line.split("\\s+");
>                     final int nrow = Integer.parseInt(tokens[1]);
>                     final int ncol = Integer.parseInt(tokens[2]);
>                     final int nz = Integer.parseInt(tokens[3]);
>                     line = scanner.nextLine();
>                     SparseMatrixModified.logger.info(line);
>                     if (RHSCRD > 0) {
>                         line = scanner.nextLine();
>                         SparseMatrixModified.logger.info(line);
>                     }
>                     final int[] colIndex = new int[ncol + 1];
>                     final int[] rowIndex = new int[nz];
>                     final double[] data = new double[nz];
>                     for (int i = 0; i <= ncol; ++i) {
>                         colIndex[i] = scanner.nextInt() - 1;
>                     }
>                     for (int i = 0; i < nz; ++i) {
>                         rowIndex[i] = scanner.nextInt() - 1;
>                     }
>                     for (int i = 0; i < nz; ++i) {
>                         data[i] = scanner.nextDouble();
>                     }
>                     final SparseMatrixModified sparseMatrixModified = new SparseMatrixModified(nrow, ncol, data, rowIndex, colIndex);
>                     if (scanner != null) {
>                         scanner.close();
>                     }
>                     if (stream != null) {
>                         stream.close();
>                     }
>                     return sparseMatrixModified;
>                 }
>                 finally {
>                     if (scanner != null) {
>                         scanner.close();
>                     }
>                 }
>             }
>             finally {
>                 if (t == null) {
>                     final Throwable exception;
>                     t = exception;
>                 }
>                 else {
>                     final Throwable exception;
>                     if (t != exception) {
>                         t.addSuppressed(exception);
>                     }
>                 }
>                 if (stream != null) {
>                     stream.close();
>                 }
>             }
>         }
>         finally {
>             if (t == null) {
>                 final Throwable exception2;
>                 t = exception2;
>             }
>             else {
>                 final Throwable exception2;
>                 if (t != exception2) {
>                     t.addSuppressed(exception2);
>                 }
>             }
>         }
>     }
>     
>     public static SparseMatrixModified rutherford(final Path path) throws IOException {
>         return harwell(path);
>     }
>     
>     public static SparseMatrixModified text(final Path path) throws IOException {
>         Throwable t = null;
>         try {
>             final InputStream stream = Files.newInputStream(path, new OpenOption[0]);
567,655c515,599
<                int nrow = scanner.nextInt();
<                int ncol = scanner.nextInt();
<                int nz = scanner.nextInt();
<                int[] colIndex = new int[ncol + 1];
<                int[] rowIndex = new int[nz];
<                double[] data = new double[nz];
< 
<                int i;
<                for(i = 0; i <= ncol; ++i) {
<                   colIndex[i] = scanner.nextInt() - 1;
<                }
< 
<                for(i = 0; i < nz; ++i) {
<                   rowIndex[i] = scanner.nextInt() - 1;
<                }
< 
<                i = 0;
< 
<                while(true) {
<                   if (i >= nz) {
<                      var10000 = new SparseMatrixModified(nrow, ncol, data, rowIndex, colIndex);
<                      break;
<                   }
< 
<                   data[i] = scanner.nextDouble();
<                   ++i;
<                }
<             } finally {
<                if (scanner != null) {
<                   scanner.close();
<                }
< 
<             }
<          } catch (Throwable var22) {
<             if (var1 == null) {
<                var1 = var22;
<             } else if (var1 != var22) {
<                var1.addSuppressed(var22);
<             }
< 
<             if (stream != null) {
<                stream.close();
<             }
< 
<             throw var1;
<          }
< 
<          if (stream != null) {
<             stream.close();
<          }
< 
<          return var10000;
<       } catch (Throwable var23) {
<          if (var1 == null) {
<             var1 = var23;
<          } else if (var1 != var23) {
<             var1.addSuppressed(var23);
<          }
< 
<          throw var1;
<       }
<    }
< 
<    public class Entry {
<       public final int i;
<       public final int j;
<       public final double x;
<       public final int index;
< 
<       private Entry(int i, int j, int index) {
<          this.i = i;
<          this.j = j;
<          this.x = SparseMatrixModified.this.nonzeros[index];
<          this.index = index;
<       }
< 
<       public void update(double value) {
<          SparseMatrixModified.this.nonzeros[this.index] = value;
<       }
< 
<       public String toString() {
<          return String.format("(%d, %d):%s", this.i, this.j, StringsModified.format(this.x));
<       }
< 
<       // $FF: synthetic method
<       Entry(int var2, int var3, int var4, SparseMatrixModified.Entry var5) {
<          this(var2, var3, var4);
<       }
<    }
---
>                 final Scanner scanner = new Scanner(stream);
>                 try {
>                     final int nrow = scanner.nextInt();
>                     final int ncol = scanner.nextInt();
>                     final int nz = scanner.nextInt();
>                     final int[] colIndex = new int[ncol + 1];
>                     final int[] rowIndex = new int[nz];
>                     final double[] data = new double[nz];
>                     for (int i = 0; i <= ncol; ++i) {
>                         colIndex[i] = scanner.nextInt() - 1;
>                     }
>                     for (int i = 0; i < nz; ++i) {
>                         rowIndex[i] = scanner.nextInt() - 1;
>                     }
>                     for (int i = 0; i < nz; ++i) {
>                         data[i] = scanner.nextDouble();
>                     }
>                     final SparseMatrixModified sparseMatrixModified = new SparseMatrixModified(nrow, ncol, data, rowIndex, colIndex);
>                     if (scanner != null) {
>                         scanner.close();
>                     }
>                     if (stream != null) {
>                         stream.close();
>                     }
>                     return sparseMatrixModified;
>                 }
>                 finally {
>                     if (scanner != null) {
>                         scanner.close();
>                     }
>                 }
>             }
>             finally {
>                 if (t == null) {
>                     final Throwable exception;
>                     t = exception;
>                 }
>                 else {
>                     final Throwable exception;
>                     if (t != exception) {
>                         t.addSuppressed(exception);
>                     }
>                 }
>                 if (stream != null) {
>                     stream.close();
>                 }
>             }
>         }
>         finally {
>             if (t == null) {
>                 final Throwable exception2;
>                 t = exception2;
>             }
>             else {
>                 final Throwable exception2;
>                 if (t != exception2) {
>                     t.addSuppressed(exception2);
>                 }
>             }
>         }
>     }
>     
>     public class Entry
>     {
>         public final int i;
>         public final int j;
>         public final double x;
>         public final int index;
>         
>         private Entry(final int i, final int j, final int index) {
>             this.i = i;
>             this.j = j;
>             this.x = SparseMatrixModified.this.nonzeros[index];
>             this.index = index;
>         }
>         
>         public void update(final double value) {
>             SparseMatrixModified.this.nonzeros[this.index] = value;
>         }
>         
>         @Override
>         public String toString() {
>             return String.format("(%d, %d):%s", this.i, this.j, StringsModified.format(this.x));
>         }
>     }
diff -r TrackAnalyzer_/smileModified/StringsModified.java procyon/smileModified/StringsModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3c7,9
< import java.text.DecimalFormat;
---
> import java.util.function.ToDoubleFunction;
> import java.util.function.ToIntFunction;
> import java.util.function.Function;
4a11
> import java.text.DecimalFormat;
6,33c13,83
< public interface StringsModified {
<    DecimalFormat DECIMAL_FORMAT = new DecimalFormat("#.####");
< 
<    static boolean isNullOrEmpty(String s) {
<       return s == null || s.isEmpty();
<    }
< 
<    static String unescape(String s) {
<       StringBuilder sb = new StringBuilder(s.length());
< 
<       for(int i = 0; i < s.length(); ++i) {
<          char ch = s.charAt(i);
<          if (ch == '\\') {
<             char nextChar = i == s.length() - 1 ? 92 : s.charAt(i + 1);
<             if (nextChar >= '0' && nextChar <= '7') {
<                String code = String.valueOf(nextChar);
<                ++i;
<                if (i < s.length() - 1 && s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '7') {
<                   code = code + s.charAt(i + 1);
<                   ++i;
<                   if (i < s.length() - 1 && s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '7') {
<                      code = code + s.charAt(i + 1);
<                      ++i;
<                   }
<                }
< 
<                sb.append((char)Integer.parseInt(code, 8));
<                continue;
---
> public interface StringsModified
> {
>     public static final DecimalFormat DECIMAL_FORMAT = new DecimalFormat("#.####");
>     
>     default boolean isNullOrEmpty(final String s) {
>         return s == null || s.isEmpty();
>     }
>     
>     default String unescape(final String s) {
>         final StringBuilder sb = new StringBuilder(s.length());
>         for (int i = 0; i < s.length(); ++i) {
>             char ch = s.charAt(i);
>             if (ch == '\\') {
>                 final char nextChar = (i == s.length() - 1) ? '\\' : s.charAt(i + 1);
>                 if (nextChar >= '0' && nextChar <= '7') {
>                     String code = String.valueOf(nextChar);
>                     if (++i < s.length() - 1 && s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '7') {
>                         code = String.valueOf(code) + s.charAt(i + 1);
>                         if (++i < s.length() - 1 && s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '7') {
>                             code = String.valueOf(code) + s.charAt(i + 1);
>                             ++i;
>                         }
>                     }
>                     sb.append((char)Integer.parseInt(code, 8));
>                     continue;
>                 }
>                 switch (nextChar) {
>                     case '\\': {
>                         ch = '\\';
>                         break;
>                     }
>                     case 'b': {
>                         ch = '\b';
>                         break;
>                     }
>                     case 'f': {
>                         ch = '\f';
>                         break;
>                     }
>                     case 'n': {
>                         ch = '\n';
>                         break;
>                     }
>                     case 'r': {
>                         ch = '\r';
>                         break;
>                     }
>                     case 't': {
>                         ch = '\t';
>                         break;
>                     }
>                     case '\"': {
>                         ch = '\"';
>                         break;
>                     }
>                     case '\'': {
>                         ch = '\'';
>                         break;
>                     }
>                     case 'u': {
>                         if (i >= s.length() - 5) {
>                             ch = 'u';
>                             break;
>                         }
>                         final int code2 = Integer.parseInt(s.substring(i + 2, i + 6), 16);
>                         sb.append(Character.toChars(code2));
>                         i += 5;
>                         continue;
>                     }
>                 }
>                 ++i;
35,69c85,96
< 
<             switch(nextChar) {
<             case '"':
<                ch = '"';
<                break;
<             case '\'':
<                ch = '\'';
<                break;
<             case '\\':
<                ch = '\\';
<                break;
<             case 'b':
<                ch = '\b';
<                break;
<             case 'f':
<                ch = '\f';
<                break;
<             case 'n':
<                ch = '\n';
<                break;
<             case 'r':
<                ch = '\r';
<                break;
<             case 't':
<                ch = '\t';
<                break;
<             case 'u':
<                if (i < s.length() - 5) {
<                   int code = Integer.parseInt(s.substring(i + 2, i + 6), 16);
<                   sb.append(Character.toChars(code));
<                   i += 5;
<                   continue;
<                }
< 
<                ch = 'u';
---
>             sb.append(ch);
>         }
>         return sb.toString();
>     }
>     
>     default String ordinal(final int i) {
>         final String[] suffixes = { "th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th" };
>         switch (i % 100) {
>             case 11:
>             case 12:
>             case 13: {
>                 return String.valueOf(i) + "th";
71,159c98,167
< 
<             ++i;
<          }
< 
<          sb.append(ch);
<       }
< 
<       return sb.toString();
<    }
< 
<    static String ordinal(int i) {
<       String[] suffixes = new String[]{"th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th"};
<       switch(i % 100) {
<       case 11:
<       case 12:
<       case 13:
<          return i + "th";
<       default:
<          return i + suffixes[i % 10];
<       }
<    }
< 
<    static String leftPad(String s, int size, char padChar) {
<       if (s == null) {
<          return null;
<       } else {
<          int pads = size - s.length();
<          return pads <= 0 ? s : fill(padChar, pads).concat(s);
<       }
<    }
< 
<    static String rightPad(String s, int size, char padChar) {
<       if (s == null) {
<          return null;
<       } else {
<          int pads = size - s.length();
<          return pads <= 0 ? s : s.concat(fill(padChar, pads));
<       }
<    }
< 
<    static String fill(char ch, int len) {
<       char[] chars = new char[len];
<       Arrays.fill(chars, ch);
<       return new String(chars);
<    }
< 
<    static String format(float x) {
<       return format(x, false);
<    }
< 
<    static String format(float x, boolean trailingZeros) {
<       if (MathExModified.isZero(x, 1.0E-7F)) {
<          return trailingZeros ? "0.0000" : "0";
<       } else {
<          float ax = Math.abs(x);
<          if (ax >= 0.001F && ax < 1.0E7F) {
<             return trailingZeros ? String.format("%.4f", x) : DECIMAL_FORMAT.format((double)x);
<          } else {
<             return String.format("%.4e", x);
<          }
<       }
<    }
< 
<    static String format(double x) {
<       return format(x, false);
<    }
< 
<    static String format(double x, boolean trailingZeros) {
<       if (MathExModified.isZero(x, 1.0E-14D)) {
<          return trailingZeros ? "0.0000" : "0";
<       } else {
<          double ax = Math.abs(x);
<          if (ax >= 0.001D && ax < 1.0E7D) {
<             return trailingZeros ? String.format("%.4f", x) : DECIMAL_FORMAT.format(x);
<          } else {
<             return String.format("%.4e", x);
<          }
<       }
<    }
< 
<    static int[] parseIntArray(String s) {
<       if (isNullOrEmpty(s)) {
<          return null;
<       } else {
<          s = s.trim();
<          if (s.startsWith("[") && s.endsWith("]")) {
<             String[] tokens = s.substring(1, s.length() - 1).split(",");
<             return Arrays.stream(tokens).map(String::trim).mapToInt(Integer::parseInt).toArray();
<          } else {
---
>             default: {
>                 return String.valueOf(i) + suffixes[i % 10];
>             }
>         }
>     }
>     
>     default String leftPad(final String s, final int size, final char padChar) {
>         if (s == null) {
>             return null;
>         }
>         final int pads = size - s.length();
>         if (pads <= 0) {
>             return s;
>         }
>         return fill(padChar, pads).concat(s);
>     }
>     
>     default String rightPad(final String s, final int size, final char padChar) {
>         if (s == null) {
>             return null;
>         }
>         final int pads = size - s.length();
>         if (pads <= 0) {
>             return s;
>         }
>         return s.concat(fill(padChar, pads));
>     }
>     
>     default String fill(final char ch, final int len) {
>         final char[] chars = new char[len];
>         Arrays.fill(chars, ch);
>         return new String(chars);
>     }
>     
>     default String format(final float x) {
>         return format(x, false);
>     }
>     
>     default String format(final float x, final boolean trailingZeros) {
>         if (MathExModified.isZero(x, 1.0E-7f)) {
>             return trailingZeros ? "0.0000" : "0";
>         }
>         final float ax = Math.abs(x);
>         if (ax >= 0.001f && ax < 1.0E7f) {
>             return trailingZeros ? String.format("%.4f", x) : StringsModified.DECIMAL_FORMAT.format(x);
>         }
>         return String.format("%.4e", x);
>     }
>     
>     default String format(final double x) {
>         return format(x, false);
>     }
>     
>     default String format(final double x, final boolean trailingZeros) {
>         if (MathExModified.isZero(x, 1.0E-14)) {
>             return trailingZeros ? "0.0000" : "0";
>         }
>         final double ax = Math.abs(x);
>         if (ax >= 0.001 && ax < 1.0E7) {
>             return trailingZeros ? String.format("%.4f", x) : StringsModified.DECIMAL_FORMAT.format(x);
>         }
>         return String.format("%.4e", x);
>     }
>     
>     default int[] parseIntArray(String s) {
>         if (isNullOrEmpty(s)) {
>             return null;
>         }
>         s = s.trim();
>         if (!s.startsWith("[") || !s.endsWith("]")) {
161,173c169,179
<          }
<       }
<    }
< 
<    static double[] parseDoubleArray(String s) {
<       if (isNullOrEmpty(s)) {
<          return null;
<       } else {
<          s = s.trim();
<          if (s.startsWith("[") && s.endsWith("]")) {
<             String[] tokens = s.substring(1, s.length() - 1).split(",");
<             return Arrays.stream(tokens).map(String::trim).mapToDouble(Double::parseDouble).toArray();
<          } else {
---
>         }
>         final String[] tokens = s.substring(1, s.length() - 1).split(",");
>         return Arrays.<String>stream(tokens).<Object>map((Function<? super String, ?>)String::trim).mapToInt((ToIntFunction<? super Object>)Integer::parseInt).toArray();
>     }
>     
>     default double[] parseDoubleArray(String s) {
>         if (isNullOrEmpty(s)) {
>             return null;
>         }
>         s = s.trim();
>         if (!s.startsWith("[") || !s.endsWith("]")) {
175,177c181,184
<          }
<       }
<    }
---
>         }
>         final String[] tokens = s.substring(1, s.length() - 1).split(",");
>         return Arrays.<String>stream(tokens).<Object>map((Function<? super String, ?>)String::trim).mapToDouble((ToDoubleFunction<? super Object>)Double::parseDouble).toArray();
>     }
diff -r TrackAnalyzer_/smileModified/SVDJobModified.java procyon/smileModified/SVDJobModified.java
1,7c1,3
< package smileModified;
< 
< public enum SVDJobModified {
<    ALL((byte)65),
<    COMPACT((byte)83),
<    OVERWRITE((byte)79),
<    NO_VECTORS((byte)78);
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
9,13c5
<    private final byte lapack;
< 
<    private SVDJobModified(byte lapack) {
<       this.lapack = lapack;
<    }
---
> package smileModified;
15,17c7,22
<    public byte lapack() {
<       return this.lapack;
<    }
---
> public enum SVDJobModified
> {
>     ALL("ALL", 0, (byte)65), 
>     COMPACT("COMPACT", 1, (byte)83), 
>     OVERWRITE("OVERWRITE", 2, (byte)79), 
>     NO_VECTORS("NO_VECTORS", 3, (byte)78);
>     
>     private final byte lapack;
>     
>     private SVDJobModified(final String name, final int ordinal, final byte lapack) {
>         this.lapack = lapack;
>     }
>     
>     public byte lapack() {
>         return this.lapack;
>     }
diff -r TrackAnalyzer_/smileModified/SymmMatrixModified.java procyon/smileModified/SymmMatrixModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5d8
< import org.slf4j.Logger;
6a10
> import org.slf4j.Logger;
8,38c12,39
< public class SymmMatrixModified extends IMatrixModified {
<    private static final long serialVersionUID = 2L;
<    private static final Logger logger = LoggerFactory.getLogger(SymmMatrixModified.class);
<    final double[] AP;
<    final int n;
<    final UPLOModified uplo;
< 
<    public SymmMatrixModified(UPLOModified uplo, int n) {
<       if (uplo == null) {
<          throw new NullPointerException("UPLO is null");
<       } else {
<          this.uplo = uplo;
<          this.n = n;
<          this.AP = new double[n * (n + 1) / 2];
<       }
<    }
< 
<    public SymmMatrixModified(UPLOModified uplo, double[][] AP) {
<       this(uplo, AP.length);
<       int i;
<       int j;
<       if (uplo == UPLOModified.LOWER) {
<          for(i = 0; i < this.n; ++i) {
<             for(j = 0; j <= i; ++j) {
<                this.AP[i + (2 * this.n - j - 1) * j / 2] = AP[i][j];
<             }
<          }
<       } else {
<          for(i = 0; i < this.n; ++i) {
<             for(j = i; j < this.n; ++j) {
<                this.AP[i + j * (j + 1) / 2] = AP[i][j];
---
> public class SymmMatrixModified extends IMatrixModified
> {
>     private static final long serialVersionUID = 2L;
>     private static final Logger logger;
>     final double[] AP;
>     final int n;
>     final UPLOModified uplo;
>     
>     static {
>         logger = LoggerFactory.getLogger((Class)SymmMatrixModified.class);
>     }
>     
>     public SymmMatrixModified(final UPLOModified uplo, final int n) {
>         if (uplo == null) {
>             throw new NullPointerException("UPLO is null");
>         }
>         this.uplo = uplo;
>         this.n = n;
>         this.AP = new double[n * (n + 1) / 2];
>     }
>     
>     public SymmMatrixModified(final UPLOModified uplo, final double[][] AP) {
>         this(uplo, AP.length);
>         if (uplo == UPLOModified.LOWER) {
>             for (int i = 0; i < this.n; ++i) {
>                 for (int j = 0; j <= i; ++j) {
>                     this.AP[i + (2 * this.n - j - 1) * j / 2] = AP[i][j];
>                 }
40,83c41,46
<          }
<       }
< 
<    }
< 
<    public SymmMatrixModified clone() {
<       SymmMatrixModified matrix = new SymmMatrixModified(this.uplo, this.n);
<       System.arraycopy(this.AP, 0, matrix.AP, 0, this.AP.length);
<       return matrix;
<    }
< 
<    public int nrow() {
<       return this.n;
<    }
< 
<    public int ncol() {
<       return this.n;
<    }
< 
<    public long size() {
<       return (long)this.AP.length;
<    }
< 
<    public LayoutModified layout() {
<       return LayoutModified.COL_MAJOR;
<    }
< 
<    public UPLOModified uplo() {
<       return this.uplo;
<    }
< 
<    public boolean equals(Object o) {
<       return !(o instanceof SymmMatrixModified) ? false : this.equals((SymmMatrixModified)o, 1.0E-10D);
<    }
< 
<    public boolean equals(SymmMatrixModified o, double epsilon) {
<       if (this.n != o.n) {
<          return false;
<       } else {
<          for(int j = 0; j < this.n; ++j) {
<             for(int i = 0; i < this.n; ++i) {
<                if (!MathExModified.isZero(this.get(i, j) - o.get(i, j), epsilon)) {
<                   return false;
<                }
---
>         }
>         else {
>             for (int i = 0; i < this.n; ++i) {
>                 for (int j = i; j < this.n; ++j) {
>                     this.AP[i + j * (j + 1) / 2] = AP[i][j];
>                 }
85,124c48,110
<          }
< 
<          return true;
<       }
<    }
< 
<    public double get(int i, int j) {
<       int tmp;
<       if (this.uplo == UPLOModified.LOWER) {
<          if (j > i) {
<             tmp = i;
<             i = j;
<             j = tmp;
<          }
< 
<          return this.AP[i + (2 * this.n - j - 1) * j / 2];
<       } else {
<          if (i > j) {
<             tmp = i;
<             i = j;
<             j = tmp;
<          }
< 
<          return this.AP[i + j * (j + 1) / 2];
<       }
<    }
< 
<    public void set(int i, int j, double x) {
<       int tmp;
<       if (this.uplo == UPLOModified.LOWER) {
<          if (j > i) {
<             tmp = i;
<             i = j;
<             j = tmp;
<          }
< 
<          this.AP[i + (2 * this.n - j - 1) * j / 2] = x;
<       } else {
<          if (i > j) {
<             tmp = i;
---
>         }
>     }
>     
>     public SymmMatrixModified clone() {
>         final SymmMatrixModified matrix = new SymmMatrixModified(this.uplo, this.n);
>         System.arraycopy(this.AP, 0, matrix.AP, 0, this.AP.length);
>         return matrix;
>     }
>     
>     @Override
>     public int nrow() {
>         return this.n;
>     }
>     
>     @Override
>     public int ncol() {
>         return this.n;
>     }
>     
>     @Override
>     public long size() {
>         return this.AP.length;
>     }
>     
>     public LayoutModified layout() {
>         return LayoutModified.COL_MAJOR;
>     }
>     
>     public UPLOModified uplo() {
>         return this.uplo;
>     }
>     
>     @Override
>     public boolean equals(final Object o) {
>         return o instanceof SymmMatrixModified && this.equals((SymmMatrixModified)o, 1.0E-10);
>     }
>     
>     public boolean equals(final SymmMatrixModified o, final double epsilon) {
>         if (this.n != o.n) {
>             return false;
>         }
>         for (int j = 0; j < this.n; ++j) {
>             for (int i = 0; i < this.n; ++i) {
>                 if (!MathExModified.isZero(this.get(i, j) - o.get(i, j), epsilon)) {
>                     return false;
>                 }
>             }
>         }
>         return true;
>     }
>     
>     @Override
>     public double get(int i, int j) {
>         if (this.uplo == UPLOModified.LOWER) {
>             if (j > i) {
>                 final int tmp = i;
>                 i = j;
>                 j = tmp;
>             }
>             return this.AP[i + (2 * this.n - j - 1) * j / 2];
>         }
>         if (i > j) {
>             final int tmp = i;
127,167c113,172
<          }
< 
<          this.AP[i + j * (j + 1) / 2] = x;
<       }
< 
<    }
< 
<    public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
<       BLASModified.engine.spmv(this.layout(), this.uplo, this.n, alpha, (double[])this.AP, (double[])x, 1, beta, (double[])y, 1);
<    }
< 
<    public void mv(double[] work, int inputOffset, int outputOffset) {
<       DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.n);
<       DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.n);
<       BLASModified.engine.spmv(this.layout(), this.uplo, this.n, 1.0D, (DoubleBuffer)DoubleBuffer.wrap(this.AP), (DoubleBuffer)xb, 1, 0.0D, (DoubleBuffer)yb, 1);
<    }
< 
<    public void tv(double[] work, int inputOffset, int outputOffset) {
<       this.mv(work, inputOffset, outputOffset);
<    }
< 
<    public SymmMatrixModified.BunchKaufman bk() {
<       SymmMatrixModified lu = this.clone();
<       int[] ipiv = new int[this.n];
<       int info = LAPACKModified.engine.sptrf(lu.layout(), lu.uplo, lu.n, lu.AP, ipiv);
<       if (info < 0) {
<          logger.error("LAPACK SPTRF error code: {}", info);
<          throw new ArithmeticException("LAPACK SPTRF error code: " + info);
<       } else {
<          return new SymmMatrixModified.BunchKaufman(lu, ipiv, info);
<       }
<    }
< 
<    public SymmMatrixModified.Cholesky cholesky() {
<       if (this.uplo == null) {
<          throw new IllegalArgumentException("The matrix is not symmetric");
<       } else {
<          SymmMatrixModified lu = this.clone();
<          int info = LAPACKModified.engine.pptrf(lu.layout(), lu.uplo, lu.n, lu.AP);
<          if (info != 0) {
<             logger.error("LAPACK PPTRF error code: {}", info);
---
>         }
>         return this.AP[i + j * (j + 1) / 2];
>     }
>     
>     @Override
>     public void set(int i, int j, final double x) {
>         if (this.uplo == UPLOModified.LOWER) {
>             if (j > i) {
>                 final int tmp = i;
>                 i = j;
>                 j = tmp;
>             }
>             this.AP[i + (2 * this.n - j - 1) * j / 2] = x;
>         }
>         else {
>             if (i > j) {
>                 final int tmp = i;
>                 i = j;
>                 j = tmp;
>             }
>             this.AP[i + j * (j + 1) / 2] = x;
>         }
>     }
>     
>     @Override
>     public void mv(final TransposeModified trans, final double alpha, final double[] x, final double beta, final double[] y) {
>         BLASModified.engine.spmv(this.layout(), this.uplo, this.n, alpha, this.AP, x, 1, beta, y, 1);
>     }
>     
>     @Override
>     public void mv(final double[] work, final int inputOffset, final int outputOffset) {
>         final DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.n);
>         final DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.n);
>         BLASModified.engine.spmv(this.layout(), this.uplo, this.n, 1.0, DoubleBuffer.wrap(this.AP), xb, 1, 0.0, yb, 1);
>     }
>     
>     @Override
>     public void tv(final double[] work, final int inputOffset, final int outputOffset) {
>         this.mv(work, inputOffset, outputOffset);
>     }
>     
>     public BunchKaufman bk() {
>         final SymmMatrixModified lu = this.clone();
>         final int[] ipiv = new int[this.n];
>         final int info = LAPACKModified.engine.sptrf(lu.layout(), lu.uplo, lu.n, lu.AP, ipiv);
>         if (info < 0) {
>             SymmMatrixModified.logger.error("LAPACK SPTRF error code: {}", (Object)info);
>             throw new ArithmeticException("LAPACK SPTRF error code: " + info);
>         }
>         return new BunchKaufman(lu, ipiv, info);
>     }
>     
>     public Cholesky cholesky() {
>         if (this.uplo == null) {
>             throw new IllegalArgumentException("The matrix is not symmetric");
>         }
>         final SymmMatrixModified lu = this.clone();
>         final int info = LAPACKModified.engine.pptrf(lu.layout(), lu.uplo, lu.n, lu.AP);
>         if (info != 0) {
>             SymmMatrixModified.logger.error("LAPACK PPTRF error code: {}", (Object)info);
169,202c174,199
<          } else {
<             return new SymmMatrixModified.Cholesky(lu);
<          }
<       }
<    }
< 
<    public static class BunchKaufman implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final SymmMatrixModified lu;
<       public final int[] ipiv;
<       public final int info;
< 
<       public BunchKaufman(SymmMatrixModified lu, int[] ipiv, int info) {
<          this.lu = lu;
<          this.ipiv = ipiv;
<          this.info = info;
<       }
< 
<       public boolean isSingular() {
<          return this.info > 0;
<       }
< 
<       public double det() {
<          int n = this.lu.n;
<          double d = 1.0D;
< 
<          int j;
<          for(j = 0; j < n; ++j) {
<             d *= this.lu.get(j, j);
<          }
< 
<          for(j = 0; j < n; ++j) {
<             if (j + 1 != this.ipiv[j]) {
<                d = -d;
---
>         }
>         return new Cholesky(lu);
>     }
>     
>     public static class BunchKaufman implements Serializable
>     {
>         private static final long serialVersionUID = 2L;
>         public final SymmMatrixModified lu;
>         public final int[] ipiv;
>         public final int info;
>         
>         public BunchKaufman(final SymmMatrixModified lu, final int[] ipiv, final int info) {
>             this.lu = lu;
>             this.ipiv = ipiv;
>             this.info = info;
>         }
>         
>         public boolean isSingular() {
>             return this.info > 0;
>         }
>         
>         public double det() {
>             final int n = this.lu.n;
>             double d = 1.0;
>             for (int j = 0; j < n; ++j) {
>                 d *= this.lu.get(j, j);
204,229c201,231
<          }
< 
<          return d;
<       }
< 
<       public MatrixModified inverse() {
<          MatrixModified inv = MatrixModified.eye(this.lu.n);
<          this.solve(inv);
<          return inv;
<       }
< 
<       public double[] solve(double[] b) {
<          MatrixModified x = MatrixModified.column(b);
<          this.solve(x);
<          return x.A;
<       }
< 
<       public void solve(MatrixModified B) {
<          if (B.m != this.lu.n) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.n, this.lu.n, B.m, B.n));
<          } else if (this.lu.layout() != B.layout()) {
<             throw new IllegalArgumentException("The matrix layout is inconsistent.");
<          } else if (this.info > 0) {
<             throw new RuntimeException("The matrix is singular.");
<          } else {
<             int ret = LAPACKModified.engine.sptrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.AP, this.ipiv, B.A, B.ld);
---
>             for (int j = 0; j < n; ++j) {
>                 if (j + 1 != this.ipiv[j]) {
>                     d = -d;
>                 }
>             }
>             return d;
>         }
>         
>         public MatrixModified inverse() {
>             final MatrixModified inv = MatrixModified.eye(this.lu.n);
>             this.solve(inv);
>             return inv;
>         }
>         
>         public double[] solve(final double[] b) {
>             final MatrixModified x = MatrixModified.column(b);
>             this.solve(x);
>             return x.A;
>         }
>         
>         public void solve(final MatrixModified B) {
>             if (B.m != this.lu.n) {
>                 throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.n, this.lu.n, B.m, B.n));
>             }
>             if (this.lu.layout() != B.layout()) {
>                 throw new IllegalArgumentException("The matrix layout is inconsistent.");
>             }
>             if (this.info > 0) {
>                 throw new RuntimeException("The matrix is singular.");
>             }
>             final int ret = LAPACKModified.engine.sptrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.AP, this.ipiv, B.A, B.ld);
231,232c233,246
<                SymmMatrixModified.logger.error("LAPACK GETRS error code: {}", ret);
<                throw new ArithmeticException("LAPACK GETRS error code: " + ret);
---
>                 SymmMatrixModified.logger.error("LAPACK GETRS error code: {}", (Object)ret);
>                 throw new ArithmeticException("LAPACK GETRS error code: " + ret);
>             }
>         }
>     }
>     
>     public static class Cholesky implements Serializable
>     {
>         private static final long serialVersionUID = 2L;
>         public final SymmMatrixModified lu;
>         
>         public Cholesky(final SymmMatrixModified lu) {
>             if (lu.nrow() != lu.ncol()) {
>                 throw new UnsupportedOperationException("Cholesky constructor on a non-square matrix");
234,245d247
<          }
<       }
<    }
< 
<    public static class Cholesky implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final SymmMatrixModified lu;
< 
<       public Cholesky(SymmMatrixModified lu) {
<          if (lu.nrow() != lu.ncol()) {
<             throw new UnsupportedOperationException("Cholesky constructor on a non-square matrix");
<          } else {
247,287c249,284
<          }
<       }
< 
<       public double det() {
<          double d = 1.0D;
< 
<          for(int i = 0; i < this.lu.n; ++i) {
<             d *= this.lu.get(i, i);
<          }
< 
<          return d * d;
<       }
< 
<       public double logdet() {
<          int n = this.lu.n;
<          double d = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             d += Math.log(this.lu.get(i, i));
<          }
< 
<          return 2.0D * d;
<       }
< 
<       public MatrixModified inverse() {
<          MatrixModified inv = MatrixModified.eye(this.lu.n);
<          this.solve(inv);
<          return inv;
<       }
< 
<       public double[] solve(double[] b) {
<          MatrixModified x = MatrixModified.column(b);
<          this.solve(x);
<          return x.A;
<       }
< 
<       public void solve(MatrixModified B) {
<          if (B.m != this.lu.n) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.n, this.lu.n, B.m, B.n));
<          } else {
<             int info = LAPACKModified.engine.pptrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.AP, B.A, B.ld);
---
>         }
>         
>         public double det() {
>             double d = 1.0;
>             for (int i = 0; i < this.lu.n; ++i) {
>                 d *= this.lu.get(i, i);
>             }
>             return d * d;
>         }
>         
>         public double logdet() {
>             final int n = this.lu.n;
>             double d = 0.0;
>             for (int i = 0; i < n; ++i) {
>                 d += Math.log(this.lu.get(i, i));
>             }
>             return 2.0 * d;
>         }
>         
>         public MatrixModified inverse() {
>             final MatrixModified inv = MatrixModified.eye(this.lu.n);
>             this.solve(inv);
>             return inv;
>         }
>         
>         public double[] solve(final double[] b) {
>             final MatrixModified x = MatrixModified.column(b);
>             this.solve(x);
>             return x.A;
>         }
>         
>         public void solve(final MatrixModified B) {
>             if (B.m != this.lu.n) {
>                 throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.n, this.lu.n, B.m, B.n));
>             }
>             final int info = LAPACKModified.engine.pptrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.AP, B.A, B.ld);
289,290c286,287
<                SymmMatrixModified.logger.error("LAPACK POTRS error code: {}", info);
<                throw new ArithmeticException("LAPACK POTRS error code: " + info);
---
>                 SymmMatrixModified.logger.error("LAPACK POTRS error code: {}", (Object)info);
>                 throw new ArithmeticException("LAPACK POTRS error code: " + info);
292,294c289,290
<          }
<       }
<    }
---
>         }
>     }
diff -r TrackAnalyzer_/smileModified/TransposeModified.java procyon/smileModified/TransposeModified.java
1,9c1,3
< package smileModified;
< 
< public enum TransposeModified {
<    NO_TRANSPOSE(111, (byte)78),
<    TRANSPOSE(112, (byte)84),
<    CONJUGATE_TRANSPOSE(113, (byte)67);
< 
<    private final int blas;
<    private final byte lapack;
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
11,18c5
<    private TransposeModified(int blas, byte lapack) {
<       this.blas = blas;
<       this.lapack = lapack;
<    }
< 
<    public int blas() {
<       return this.blas;
<    }
---
> package smileModified;
20,22c7,27
<    public byte lapack() {
<       return this.lapack;
<    }
---
> public enum TransposeModified
> {
>     NO_TRANSPOSE("NO_TRANSPOSE", 0, 111, (byte)78), 
>     TRANSPOSE("TRANSPOSE", 1, 112, (byte)84), 
>     CONJUGATE_TRANSPOSE("CONJUGATE_TRANSPOSE", 2, 113, (byte)67);
>     
>     private final int blas;
>     private final byte lapack;
>     
>     private TransposeModified(final String name, final int ordinal, final int blas, final byte lapack) {
>         this.blas = blas;
>         this.lapack = lapack;
>     }
>     
>     public int blas() {
>         return this.blas;
>     }
>     
>     public byte lapack() {
>         return this.lapack;
>     }
diff -r TrackAnalyzer_/smileModified/UniversalGeneratorModified.java procyon/smileModified/UniversalGeneratorModified.java
1,23c1,3
< package smileModified;
< 
< public class UniversalGeneratorModified implements RandomNumberGeneratorModified {
<    private static final int DEFAULT_SEED = 54217137;
<    private static final int BIG_PRIME = 899999963;
<    private double c;
<    private double cd;
<    private double cm;
<    private double[] u;
<    private int i97;
<    private int j97;
< 
<    public UniversalGeneratorModified() {
<       this.setSeed(54217137L);
<    }
< 
<    public UniversalGeneratorModified(int seed) {
<       this.setSeed((long)seed);
<    }
< 
<    public UniversalGeneratorModified(long seed) {
<       this.setSeed(seed);
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
25,42c5
<    public void setSeed(long seed) {
<       this.u = new double[97];
<       int ijkl = Math.abs((int)(seed % 899999963L));
<       int ij = ijkl / 30082;
<       int kl = ijkl % 30082;
<       if (ij < 0 || ij > 31328 || kl < 0 || kl > 30081) {
<          ij %= 31329;
<          kl %= 30082;
<       }
< 
<       int i = ij / 177 % 177 + 2;
<       int j = ij % 177 + 2;
<       int k = kl / 169 % 178 + 1;
<       int l = kl % 169;
< 
<       for(int ii = 0; ii < 97; ++ii) {
<          double s = 0.0D;
<          double t = 0.5D;
---
> package smileModified;
44,51c7,56
<          for(int jj = 0; jj < 24; ++jj) {
<             int m = i * j % 179 * k % 179;
<             i = j;
<             j = k;
<             k = m;
<             l = (53 * l + 1) % 169;
<             if (l * m % 64 >= 32) {
<                s += t;
---
> public class UniversalGeneratorModified implements RandomNumberGeneratorModified
> {
>     private static final int DEFAULT_SEED = 54217137;
>     private static final int BIG_PRIME = 899999963;
>     private double c;
>     private double cd;
>     private double cm;
>     private double[] u;
>     private int i97;
>     private int j97;
>     
>     public UniversalGeneratorModified() {
>         this.setSeed(54217137L);
>     }
>     
>     public UniversalGeneratorModified(final int seed) {
>         this.setSeed(seed);
>     }
>     
>     public UniversalGeneratorModified(final long seed) {
>         this.setSeed(seed);
>     }
>     
>     @Override
>     public void setSeed(final long seed) {
>         this.u = new double[97];
>         final int ijkl = Math.abs((int)(seed % 899999963L));
>         int ij = ijkl / 30082;
>         int kl = ijkl % 30082;
>         if (ij < 0 || ij > 31328 || kl < 0 || kl > 30081) {
>             ij %= 31329;
>             kl %= 30082;
>         }
>         int i = ij / 177 % 177 + 2;
>         int j = ij % 177 + 2;
>         int k = kl / 169 % 178 + 1;
>         int l = kl % 169;
>         for (int ii = 0; ii < 97; ++ii) {
>             double s = 0.0;
>             double t = 0.5;
>             for (int jj = 0; jj < 24; ++jj) {
>                 final int m = i * j % 179 * k % 179;
>                 i = j;
>                 j = k;
>                 k = m;
>                 l = (53 * l + 1) % 169;
>                 if (l * m % 64 >= 32) {
>                     s += t;
>                 }
>                 t *= 0.5;
53,100c58,70
< 
<             t *= 0.5D;
<          }
< 
<          this.u[ii] = s;
<       }
< 
<       this.c = 0.021602869033813477D;
<       this.cd = 0.45623308420181274D;
<       this.cm = 0.9999998211860657D;
<       this.i97 = 96;
<       this.j97 = 32;
<    }
< 
<    public double nextDouble() {
<       double uni = this.u[this.i97] - this.u[this.j97];
<       if (uni < 0.0D) {
<          ++uni;
<       }
< 
<       this.u[this.i97] = uni;
<       if (--this.i97 < 0) {
<          this.i97 = 96;
<       }
< 
<       if (--this.j97 < 0) {
<          this.j97 = 96;
<       }
< 
<       this.c -= this.cd;
<       if (this.c < 0.0D) {
<          this.c += this.cm;
<       }
< 
<       uni -= this.c;
<       if (uni < 0.0D) {
<          ++uni;
<       }
< 
<       return uni;
<    }
< 
<    public void nextDoubles(double[] d) {
<       int n = d.length;
< 
<       for(int i = 0; i < n; ++i) {
<          double uni = this.u[this.i97] - this.u[this.j97];
<          if (uni < 0.0D) {
---
>             this.u[ii] = s;
>         }
>         this.c = 0.021602869033813477;
>         this.cd = 0.45623308420181274;
>         this.cm = 0.9999998211860657;
>         this.i97 = 96;
>         this.j97 = 32;
>     }
>     
>     @Override
>     public double nextDouble() {
>         double uni = this.u[this.i97] - this.u[this.j97];
>         if (uni < 0.0) {
102,105c72,74
<          }
< 
<          this.u[this.i97] = uni;
<          if (--this.i97 < 0) {
---
>         }
>         this.u[this.i97] = uni;
>         if (--this.i97 < 0) {
107,109c76,77
<          }
< 
<          if (--this.j97 < 0) {
---
>         }
>         if (--this.j97 < 0) {
111,114c79,81
<          }
< 
<          this.c -= this.cd;
<          if (this.c < 0.0D) {
---
>         }
>         this.c -= this.cd;
>         if (this.c < 0.0) {
116,119c83,85
<          }
< 
<          uni -= this.c;
<          if (uni < 0.0D) {
---
>         }
>         uni -= this.c;
>         if (uni < 0.0) {
121,146c87,138
<          }
< 
<          d[i] = uni;
<       }
< 
<    }
< 
<    public int next(int numbits) {
<       return this.nextInt() >>> 32 - numbits;
<    }
< 
<    public int nextInt() {
<       return (int)Math.floor(2.147483647E9D * (2.0D * this.nextDouble() - 1.0D));
<    }
< 
<    public int nextInt(int n) {
<       if (n <= 0) {
<          throw new IllegalArgumentException("n must be positive");
<       } else {
<          return (int)(this.nextDouble() * (double)n);
<       }
<    }
< 
<    public long nextLong() {
<       return (long)Math.floor(9.223372036854776E18D * (2.0D * this.nextDouble() - 1.0D));
<    }
---
>         }
>         return uni;
>     }
>     
>     @Override
>     public void nextDoubles(final double[] d) {
>         for (int n = d.length, i = 0; i < n; ++i) {
>             double uni = this.u[this.i97] - this.u[this.j97];
>             if (uni < 0.0) {
>                 ++uni;
>             }
>             this.u[this.i97] = uni;
>             if (--this.i97 < 0) {
>                 this.i97 = 96;
>             }
>             if (--this.j97 < 0) {
>                 this.j97 = 96;
>             }
>             this.c -= this.cd;
>             if (this.c < 0.0) {
>                 this.c += this.cm;
>             }
>             uni -= this.c;
>             if (uni < 0.0) {
>                 ++uni;
>             }
>             d[i] = uni;
>         }
>     }
>     
>     @Override
>     public int next(final int numbits) {
>         return this.nextInt() >>> 32 - numbits;
>     }
>     
>     @Override
>     public int nextInt() {
>         return (int)Math.floor(2.147483647E9 * (2.0 * this.nextDouble() - 1.0));
>     }
>     
>     @Override
>     public int nextInt(final int n) {
>         if (n <= 0) {
>             throw new IllegalArgumentException("n must be positive");
>         }
>         return (int)(this.nextDouble() * n);
>     }
>     
>     @Override
>     public long nextLong() {
>         return (long)Math.floor(9.223372036854776E18 * (2.0 * this.nextDouble() - 1.0));
>     }
diff -r TrackAnalyzer_/smileModified/UPLOModified.java procyon/smileModified/UPLOModified.java
1,8c1,3
< package smileModified;
< 
< public enum UPLOModified {
<    UPPER(121, (byte)85),
<    LOWER(122, (byte)76);
< 
<    private final int blas;
<    private final byte lapack;
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
10,17c5
<    private UPLOModified(int blas, byte lapack) {
<       this.blas = blas;
<       this.lapack = lapack;
<    }
< 
<    public int blas() {
<       return this.blas;
<    }
---
> package smileModified;
19,21c7,26
<    public byte lapack() {
<       return this.lapack;
<    }
---
> public enum UPLOModified
> {
>     UPPER("UPPER", 0, 121, (byte)85), 
>     LOWER("LOWER", 1, 122, (byte)76);
>     
>     private final int blas;
>     private final byte lapack;
>     
>     private UPLOModified(final String name, final int ordinal, final int blas, final byte lapack) {
>         this.blas = blas;
>         this.lapack = lapack;
>     }
>     
>     public int blas() {
>         return this.blas;
>     }
>     
>     public byte lapack() {
>         return this.lapack;
>     }
diff -r TrackAnalyzer_/SPTBatch_.java procyon/SPTBatch_.java
1,4276d0
< import checkable.CheckableItem;
< import checkable.CheckedComboBox;
< import fiji.plugin.trackmate.Dimension;
< import fiji.plugin.trackmate.FeatureModel;
< import fiji.plugin.trackmate.Logger;
< import fiji.plugin.trackmate.Model;
< import fiji.plugin.trackmate.SelectionModel;
< import fiji.plugin.trackmate.Settings;
< import fiji.plugin.trackmate.Spot;
< import fiji.plugin.trackmate.SpotCollection;
< import fiji.plugin.trackmate.SpotRoi;
< import fiji.plugin.trackmate.TrackMate;
< import fiji.plugin.trackmate.action.PlotNSpotsVsTimeAction;
< import fiji.plugin.trackmate.detection.DogDetectorFactory;
< import fiji.plugin.trackmate.detection.LogDetectorFactory;
< import fiji.plugin.trackmate.features.EdgeCollectionDataset;
< import fiji.plugin.trackmate.features.FeatureFilter;
< import fiji.plugin.trackmate.features.FeatureUtils;
< import fiji.plugin.trackmate.features.ModelDataset;
< import fiji.plugin.trackmate.features.SpotCollectionDataset;
< import fiji.plugin.trackmate.features.TrackCollectionDataset;
< import fiji.plugin.trackmate.graph.ConvexBranchesDecomposition;
< import fiji.plugin.trackmate.graph.TimeDirectedNeighborIndex;
< import fiji.plugin.trackmate.graph.ConvexBranchesDecomposition.TrackBranchDecomposition;
< import fiji.plugin.trackmate.gui.Fonts;
< import fiji.plugin.trackmate.gui.displaysettings.Colormap;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettingsIO;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings.TrackDisplayMode;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings.TrackMateObject;
< import fiji.plugin.trackmate.io.TmXmlReader;
< import fiji.plugin.trackmate.tracking.LAPUtils;
< import fiji.plugin.trackmate.tracking.ManualTrackerFactory;
< import fiji.plugin.trackmate.tracking.kalman.KalmanTrackerFactory;
< import fiji.plugin.trackmate.tracking.sparselap.SimpleSparseLAPTrackerFactory;
< import fiji.plugin.trackmate.tracking.sparselap.SparseLAPTrackerFactory;
< import fiji.plugin.trackmate.util.ExportableChartPanel;
< import fiji.plugin.trackmate.util.TMUtils;
< import fiji.plugin.trackmate.visualization.FeatureColorGenerator;
< import fiji.plugin.trackmate.visualization.PerTrackFeatureColorGenerator;
< import fiji.plugin.trackmate.visualization.hyperstack.HyperStackDisplayer;
< import fiji.plugin.trackmate.visualization.hyperstack.SpotOverlay;
< import fiji.plugin.trackmate.visualization.hyperstack.TrackOverlay;
< import fiji.plugin.trackmate.visualization.table.TablePanel;
< import ij.IJ;
< import ij.ImagePlus;
< import ij.ImageStack;
< import ij.gui.OvalRoi;
< import ij.gui.Overlay;
< import ij.gui.PolygonRoi;
< import ij.gui.Roi;
< import ij.gui.ShapeRoi;
< import ij.measure.Calibration;
< import ij.measure.ResultsTable;
< import ij.plugin.ZProjector;
< import ij.plugin.frame.RoiManager;
< import ij.process.ColorProcessor;
< import ij.process.ImageProcessor;
< import inra.ijpb.morphology.Morphology;
< import inra.ijpb.morphology.Strel.Shape;
< import java.awt.BorderLayout;
< import java.awt.Button;
< import java.awt.Color;
< import java.awt.Component;
< import java.awt.FlowLayout;
< import java.awt.Font;
< import java.awt.Graphics2D;
< import java.awt.GridBagConstraints;
< import java.awt.GridBagLayout;
< import java.awt.GridLayout;
< import java.awt.Image;
< import java.awt.Insets;
< import java.awt.Panel;
< import java.awt.Rectangle;
< import java.awt.RenderingHints;
< import java.awt.TextField;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.ItemEvent;
< import java.awt.event.ItemListener;
< import java.awt.event.MouseAdapter;
< import java.awt.event.MouseEvent;
< import java.awt.image.BufferedImage;
< import java.awt.image.ImageObserver;
< import java.io.File;
< import java.io.FileWriter;
< import java.io.IOException;
< import java.net.URL;
< import java.text.DecimalFormat;
< import java.text.NumberFormat;
< import java.util.ArrayList;
< import java.util.Arrays;
< import java.util.Collections;
< import java.util.Comparator;
< import java.util.HashMap;
< import java.util.HashSet;
< import java.util.Iterator;
< import java.util.LinkedHashSet;
< import java.util.List;
< import java.util.Map;
< import java.util.Set;
< import java.util.function.BiConsumer;
< import java.util.function.BiFunction;
< import java.util.function.Function;
< import java.util.function.Supplier;
< import java.util.prefs.Preferences;
< import java.util.stream.Collectors;
< import java.util.stream.Stream;
< import javax.swing.BorderFactory;
< import javax.swing.Box;
< import javax.swing.BoxLayout;
< import javax.swing.ButtonGroup;
< import javax.swing.DefaultComboBoxModel;
< import javax.swing.Icon;
< import javax.swing.ImageIcon;
< import javax.swing.JButton;
< import javax.swing.JCheckBox;
< import javax.swing.JComboBox;
< import javax.swing.JComponent;
< import javax.swing.JFrame;
< import javax.swing.JLabel;
< import javax.swing.JOptionPane;
< import javax.swing.JPanel;
< import javax.swing.JProgressBar;
< import javax.swing.JScrollPane;
< import javax.swing.JSeparator;
< import javax.swing.JTabbedPane;
< import javax.swing.JTable;
< import javax.swing.JTextArea;
< import javax.swing.JTextField;
< import javax.swing.SwingUtilities;
< import javax.swing.UIManager;
< import javax.swing.UnsupportedLookAndFeelException;
< import javax.swing.UIManager.LookAndFeelInfo;
< import javax.swing.table.DefaultTableModel;
< import javax.swing.text.DefaultCaret;
< import javax.xml.parsers.DocumentBuilder;
< import javax.xml.parsers.DocumentBuilderFactory;
< import javax.xml.parsers.ParserConfigurationException;
< import javax.xml.xpath.XPath;
< import javax.xml.xpath.XPathConstants;
< import javax.xml.xpath.XPathExpression;
< import javax.xml.xpath.XPathExpressionException;
< import javax.xml.xpath.XPathFactory;
< import jwizardcomponent.JWizardComponents;
< import jwizardcomponent.JWizardPanel;
< import jwizardcomponent.Utilities;
< import jwizardcomponent.frame.JWizardFrame;
< import loci.plugins.in.DisplayHandler;
< import loci.plugins.in.ImportProcess;
< import loci.plugins.in.ImporterOptions;
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartUtils;
< import org.jfree.chart.JFreeChart;
< import org.jfree.chart.axis.NumberAxis;
< import org.jfree.chart.labels.CategoryItemLabelGenerator;
< import org.jfree.chart.labels.StandardCategoryItemLabelGenerator;
< import org.jfree.chart.plot.CategoryPlot;
< import org.jfree.chart.plot.PlotOrientation;
< import org.jfree.chart.plot.XYPlot;
< import org.jfree.chart.renderer.category.CategoryItemRenderer;
< import org.jfree.chart.renderer.xy.XYItemRenderer;
< import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
< import org.jfree.chart.ui.RectangleInsets;
< import org.jfree.data.category.DefaultCategoryDataset;
< import org.jfree.data.xy.DefaultXYDataset;
< import org.jgrapht.graph.DefaultEdge;
< import org.jgrapht.graph.DefaultWeightedEdge;
< import org.jgrapht.graph.SimpleDirectedGraph;
< import org.w3c.dom.Document;
< import org.w3c.dom.Node;
< import org.w3c.dom.NodeList;
< import org.xml.sax.SAXException;
< import smileModified.GaussianMixtureModified;
< 
< public class SPTBatch_ {
<    static String csvPath;
<    static String imgTitle;
<    static String RADIUS;
<    private String imagesPath;
<    private String zstart;
<    private String zend;
<    private String ystart;
<    private String yend;
<    private String xstart;
<    private String xend;
<    private String tstart;
<    private String tend;
<    private String THRESHOLD;
<    private String TARGET_CHANNEL;
<    private String DO_SUBPIXEL_LOCALIZATION;
<    private String DO_MEDIAN_FILTERING;
<    private String DETECTOR_NAME;
<    private String NSPLIT;
<    private String DOWNSAMPLE_FACTOR;
<    private String initialSpotFilter;
<    private String TRACKER_NAME;
<    private String CUTOFF_PERCENTILE;
<    private String ALTERNATIVE_LINKING_COST_FACTOR;
<    private String LINKING_MAX_DISTANCE;
<    private String MAX_FRAME_GAP;
<    private String MAX_DISTANCE;
<    private String ALLOW_GAP_CLOSING;
<    private String SPLITTING_MAX_DISTANCE;
<    private String ALLOW_TRACK_SPLITTING;
<    private String MERGING_MAX_DISTANCE;
<    private String ALLOW_TRACK_MERGING;
<    private String BLOCKING_VALUE;
<    private String TransfPath;
<    private String enableImages;
<    private String enableLog;
<    private String enableXML;
<    private String enableRois;
<    private String xmlPath;
<    private String checkEnable;
<    private String enableCsv;
<    private String TRACKMATE_TRANSF_PATH;
<    private String TRACKMATE_IMAGES_PATH;
<    private String TRACKMATE_CSV_PATH;
<    private String TRACKMATE_XML_PATH;
<    private String TRACKMATE_TXT_PATH;
<    private String TRACKMATE_OUT_PATH;
<    private String xSelectedSpot;
<    private String ySelectedSpot;
<    private String xSelectedLink;
<    private String ySelectedLink;
<    private String xSelectedTrack;
<    private String ySelectedTrack;
<    private String enablePlotF;
<    private String enableSql;
<    private String enableST;
<    private String enableSpotTable;
<    private String enableLinkTable;
<    private String enableTrackTable;
<    private String enableBranchTable;
<    private String enablePlot;
<    private String titleExportLink;
<    private String titleExportTrack;
<    private String linkingNames;
<    private String linkingValues;
<    private String initialFilterFeature;
<    private String initialFilterValue;
<    private String initialFilterAbove;
<    private String selectedOption = "N";
<    private String enableCovariance;
<    private String enableRegression;
<    private String enableKalman;
<    private String trackFilterFeature;
<    private String trackFilterValue;
<    private String trackFilterAbove;
<    private String TRACKMATE_MIN_SPOT;
<    private String TRACKMATE_MAX_SPOT;
<    private String TRACKMATE_LENGTH_TH;
<    private String TRACKMATE_DIFF_TH;
<    public static String TRACKMATE_MIN_TRACK;
<    public static String TRACKMATE_WINDOW;
<    public static String TRACKMATE_MIN_SEGMENT;
<    public static String TRACKMATE_COLUMN_PARAM;
<    String[] columnsMovements = new String[]{"Total Tracks.", "Long Tracks", "Long Confined", "Long Unidirectional Ballistic", "Long Free.", "Long Direct.", "Immob"};
<    private int[] dims;
<    private JFreeChart chart;
<    private JFrame frameChartNS;
<    private Map<String, Double> hm;
<    public static Thread mainProcess;
<    public static final int PANEL_FIRST = 0;
<    public static final int PANEL_CHOOSER = 1;
<    public static final int PANEL_OPTION_A = 2;
<    public static final int PANEL_OPTION_B = 3;
<    public static final int PANEL_LAST = 4;
<    private ImagePlus imp;
<    private ImagePlus capture;
<    private JWizardPanel panel;
<    private JButton nextButton;
<    private JButton backButton;
<    private JButton cancelButton;
<    private JButton finishButton;
<    private JButton buttonCsv;
<    private JButton trajButton;
<    private JButton summaryButton;
<    private CheckedComboBox comboP;
<    public static JCheckBox checkbox2;
<    public static JCheckBox checkbox3;
<    public static JCheckBox checkbox4;
<    public static JCheckBox checkboxRoi;
<    public static JCheckBox checkboxPlot;
<    public static JCheckBox checkPlot;
<    public static JCheckBox checkboxAnalysis;
<    public static JCheckBox checkboxST;
<    public static JCheckBox ESP;
<    public static JCheckBox ELP;
<    public static JCheckBox ETP;
<    public static JCheckBox checkbox1;
<    public static JCheckBox checkboxDiff;
<    public static JCheckBox checkboxSP;
<    public static JCheckBox checkboxMSD;
<    public static JCheckBox checkDispSpots;
<    public static JCheckBox checkDispSpotName;
<    public static JCheckBox checkDispTracks;
<    public static JCheckBox checkSummary;
<    public static JCheckBox checkPBS;
<    public static JCheckBox checkCluster;
<    public static JCheckBox checkMonomer;
<    public static JCheckBox checkTracks;
<    public static JCheckBox checkboxSubBg;
<    public static JCheckBox checkExcludeTracks;
<    private int itemCheckPlot;
<    private Button buttonXMLL;
<    private Button buttonImg;
<    public static Preferences pref1;
<    private Settings settings;
<    public static int a;
<    public static int minTracksJTF;
<    public static int maxTracksJTF;
<    public static int thLengthJTF;
<    public static int i;
<    private double thD14JTF;
<    private JFrame f;
<    private JWizardFrame wizard;
<    private TrackMate trackmate;
<    private Logger loggers;
<    private ResultsTable spotTable;
<    private ResultsTable linkTable;
<    private ResultsTable trackTable;
<    private ResultsTable rtSpot;
<    private ResultsTable rtLink;
<    private ResultsTable rtTrack;
<    private final String SPOT_TABLE_NAME = "Spots in tracks statistics";
<    private final String EDGE_TABLE_NAME = "Links in tracks statistics";
<    private final String TRACK_TABLE_NAME = "Track statistics";
<    private final String ID_COLUMN = "ID";
<    private Spot[] source;
<    public static Model model;
<    public static SelectionModel selectionModel;
<    public static ImagePlus imps;
<    public static ImagePlus impsSubBg;
<    public ImagePlus impsNano;
<    private HyperStackDisplayer displayer;
<    private String[] imageTitles;
<    private Set<Spot> track;
<    private static final String TRACK_ID_COLUMN = "TRACK_ID";
<    private PlotNSpotsVsTimeAction plot;
<    private JFreeChart chartSpot;
<    private JFreeChart chartLink;
<    private JFreeChart chartTrack;
<    private int itemPlot2;
<    private int totalTracksDef;
<    private int longTracksDef;
<    private int longConfinedDef;
<    private int longUniBalDef;
<    private int longFreeDef;
<    private int longDirectDef;
<    private int immobDef;
<    private int shortTracksDef;
<    private int shortConfinedDef;
<    private int shortAnomDef;
<    private int shortFreeDef;
<    private int shortDirectDef;
<    public static File directImages;
<    public static File directChemo;
<    public static File directDiff;
<    public static File directMSS;
<    public static File directCluster;
<    private JProgressBar progressBar;
<    public static File directSummary;
<    public static File fileXmlInitial;
<    public static File directPBS;
<    public static File directSPT;
<    static JTextArea taskOutput;
<    private JComboBox comboSpotsX;
<    private JComboBox comboSpotsY;
<    private JComboBox comboLinkX;
<    private JComboBox comboLinkY;
<    private JComboBox comboTrackX;
<    private JComboBox comboTrackY;
<    private JComboBox comboSubBg;
<    private JComboBox comboDispTracks;
<    PerTrackFeatureColorGenerator tcg;
<    Calibration calibration;
<    static JTable trackJTable;
<    static JTable linkJTable;
<    public ImagePlus[] lifs;
<    ArrayList<Float> xPosition;
<    ArrayList<Float> yPosition;
<    ArrayList<Integer> tracksID;
<    ArrayList<Integer> framePosition;
<    static JTextField chemoScaling;
<    static JTextField minTracks;
<    static JTextField maxTracks;
<    static JTextField thLength;
<    static JTextField thD14;
<    static JTextField monomerField;
<    public static RoiManager roiManager;
<    public static ImagePlus impMaxProject;
<    public static ImagePlus impMainRoi;
<    public static ImagePlus[] slices;
<    public static double[] slicesIntensityBg;
<    public static double[] slicesIntensitySpot;
<    static JTable tableSpot = null;
<    static String[] columnNamesTrack;
<    static String[] columnNamesSpot;
<    List<List<List<String>>> dataAllItemsDef = new ArrayList();
<    ArrayList<Integer> indexes;
<    static List<Integer> nOfTracks;
<    List<String> selectedItems = null;
<    static double fps;
<    ResultsTable[] rtSpots = null;
<    ResultsTable[] rtLinks = null;
<    ResultsTable[] rtTracks = null;
<    List<Boolean> excludeTrack;
<    DisplaySettings ds;
<    ResultsTable rtTrackPerImage;
<    private static final String TRACK_ID = "TRACK_ID";
<    private static final String N_PREDECESSORS = "N_PREDECESSORS";
<    private static final String N_SUCCESSORS = "N_SUCCESSORS";
<    private static final String DELTA_T = "DELTA_T";
<    private static final String DISTANCE = "DISTANCE";
<    private static final String MEAN_VELOCITY = "MEAN_VELOCITY";
<    private static final String FIRST = "FIRST";
<    private static final String LAST = "LAST";
<    private static final List<String> BRANCH_FEATURES = Arrays.asList("TRACK_ID", "N_PREDECESSORS", "N_SUCCESSORS", "DELTA_T", "DISTANCE", "MEAN_VELOCITY", "FIRST", "LAST");
<    private static final Map<String, String> BRANCH_FEATURES_NAMES = new HashMap();
<    private static final Map<String, String> BRANCH_FEATURES_SHORTNAMES = new HashMap();
<    private static final Map<String, Boolean> BRANCH_FEATURES_ISINTS = new HashMap();
<    private static final Map<String, Dimension> BRANCH_FEATURES_DIMENSIONS = new HashMap();
< 
<    static {
<       BRANCH_FEATURES_NAMES.put("TRACK_ID", "Track ID");
<       BRANCH_FEATURES_SHORTNAMES.put("TRACK_ID", "Track ID");
<       BRANCH_FEATURES_ISINTS.put("TRACK_ID", Boolean.TRUE);
<       BRANCH_FEATURES_DIMENSIONS.put("TRACK_ID", Dimension.NONE);
<       BRANCH_FEATURES_NAMES.put("N_PREDECESSORS", "Track ID");
<       BRANCH_FEATURES_SHORTNAMES.put("N_PREDECESSORS", "N predecessors");
<       BRANCH_FEATURES_ISINTS.put("N_PREDECESSORS", Boolean.TRUE);
<       BRANCH_FEATURES_DIMENSIONS.put("N_PREDECESSORS", Dimension.NONE);
<       BRANCH_FEATURES_NAMES.put("N_SUCCESSORS", "Track ID");
<       BRANCH_FEATURES_SHORTNAMES.put("N_SUCCESSORS", "N successors");
<       BRANCH_FEATURES_ISINTS.put("N_SUCCESSORS", Boolean.TRUE);
<       BRANCH_FEATURES_DIMENSIONS.put("N_SUCCESSORS", Dimension.NONE);
<       BRANCH_FEATURES_NAMES.put("DELTA_T", "Branch duration");
<       BRANCH_FEATURES_SHORTNAMES.put("DELTA_T", "Delta T");
<       BRANCH_FEATURES_ISINTS.put("DELTA_T", Boolean.FALSE);
<       BRANCH_FEATURES_DIMENSIONS.put("DELTA_T", Dimension.TIME);
<       BRANCH_FEATURES_NAMES.put("DISTANCE", "Distance traveled");
<       BRANCH_FEATURES_SHORTNAMES.put("DISTANCE", "Dist");
<       BRANCH_FEATURES_ISINTS.put("DISTANCE", Boolean.FALSE);
<       BRANCH_FEATURES_DIMENSIONS.put("DISTANCE", Dimension.LENGTH);
<       BRANCH_FEATURES_NAMES.put("MEAN_VELOCITY", "Mean velocity");
<       BRANCH_FEATURES_SHORTNAMES.put("MEAN_VELOCITY", "Mean V");
<       BRANCH_FEATURES_ISINTS.put("MEAN_VELOCITY", Boolean.FALSE);
<       BRANCH_FEATURES_DIMENSIONS.put("MEAN_VELOCITY", Dimension.VELOCITY);
<       BRANCH_FEATURES_NAMES.put("FIRST", "First spot ID");
<       BRANCH_FEATURES_SHORTNAMES.put("FIRST", "First ID");
<       BRANCH_FEATURES_ISINTS.put("FIRST", Boolean.TRUE);
<       BRANCH_FEATURES_DIMENSIONS.put("FIRST", Dimension.NONE);
<       BRANCH_FEATURES_NAMES.put("LAST", "Last spot ID");
<       BRANCH_FEATURES_SHORTNAMES.put("LAST", "Last ID");
<       BRANCH_FEATURES_ISINTS.put("LAST", Boolean.TRUE);
<       BRANCH_FEATURES_DIMENSIONS.put("LAST", Dimension.NONE);
<    }
< 
<    public SPTBatch_(String xmlPath, String imagesPath) {
<       this.xmlPath = xmlPath;
<       this.imagesPath = imagesPath;
<    }
< 
<    public void run(String arg) {
<       this.TRACKMATE_TRANSF_PATH = "transf_path";
<       this.TRACKMATE_IMAGES_PATH = "images_path";
<       this.TRACKMATE_CSV_PATH = "csv_path";
<       this.TRACKMATE_XML_PATH = "xml_path";
<       this.TRACKMATE_TXT_PATH = "txt_path";
<       this.TRACKMATE_OUT_PATH = "out_path";
<       this.TRACKMATE_MIN_SPOT = "min_spot";
<       this.TRACKMATE_MAX_SPOT = "max_spot";
<       this.TRACKMATE_LENGTH_TH = "length_th";
<       this.TRACKMATE_DIFF_TH = "diff_th";
<       TRACKMATE_MIN_TRACK = "min_track";
<       TRACKMATE_WINDOW = "window";
<       TRACKMATE_MIN_SEGMENT = "min_segment";
<       TRACKMATE_COLUMN_PARAM = "column_param";
<       pref1 = Preferences.userRoot();
<       JFrame.setDefaultLookAndFeelDecorated(true);
< 
<       try {
<          LookAndFeelInfo[] var5;
<          int var4 = (var5 = UIManager.getInstalledLookAndFeels()).length;
< 
<          for(int var3 = 0; var3 < var4; ++var3) {
<             LookAndFeelInfo info = var5[var3];
<             if ("Nimbus".equals(info.getName())) {
<                UIManager.setLookAndFeel(info.getClassName());
<                break;
<             }
<          }
<       } catch (UnsupportedLookAndFeelException var6) {
<       } catch (ClassNotFoundException var7) {
<       } catch (InstantiationException var8) {
<       } catch (IllegalAccessException var9) {
<       }
< 
<       this.wizard = new JWizardFrame();
<       this.wizard.setTitle("SPT-Batch");
<       this.panel = new SPTBatch_.FirstWizardPanel(this.wizard.getWizardComponents());
<       this.wizard.getWizardComponents().addWizardPanel(0, this.panel);
<       this.panel = new SPTBatch_.ChooserWizardPanel(this.wizard.getWizardComponents());
<       this.wizard.getWizardComponents().addWizardPanel(1, this.panel);
<       this.panel = new SPTBatch_.OptionWizardPanel(this.wizard.getWizardComponents(), "A");
<       this.wizard.getWizardComponents().addWizardPanel(2, this.panel);
<       this.panel = new SPTBatch_.OptionWizardPanel(this.wizard.getWizardComponents(), "B");
<       this.wizard.getWizardComponents().addWizardPanel(3, this.panel);
<       this.panel = new SPTBatch_.LastWizardPanel(this.wizard.getWizardComponents());
<       this.wizard.getWizardComponents().addWizardPanel(4, this.panel);
<       this.wizard.getWizardComponents().removeWizardPanel(0);
<       this.wizard.setSize(550, 700);
<       Utilities.centerComponentOnScreen(this.wizard);
<       this.wizard.setResizable(false);
<       this.wizard.setVisible(true);
<       mainProcess = new Thread(new Runnable() {
<          public void run() {
<             SPTBatch_.this.xSelectedSpot = SPTBatch_.this.comboSpotsX.getSelectedItem().toString();
<             SPTBatch_.this.ySelectedSpot = SPTBatch_.this.comboSpotsY.getSelectedItem().toString();
<             SPTBatch_.this.xSelectedLink = SPTBatch_.this.comboLinkX.getSelectedItem().toString();
<             SPTBatch_.this.ySelectedLink = SPTBatch_.this.comboLinkY.getSelectedItem().toString();
<             SPTBatch_.this.xSelectedTrack = SPTBatch_.this.comboTrackX.getSelectedItem().toString();
<             SPTBatch_.this.ySelectedTrack = SPTBatch_.this.comboTrackY.getSelectedItem().toString();
<             SPTBatch_.fileXmlInitial = new File(SPTBatch_.this.xmlPath);
<             File imageFolder = new File(SPTBatch_.this.imagesPath);
<             final File[] listOfFiles = imageFolder.listFiles();
<             SPTBatch_.this.imageTitles = new String[listOfFiles.length];
<             File[] filesXML = new File[listOfFiles.length];
< 
<             for(int u = 0; u < filesXML.length; ++u) {
<                filesXML[u] = new File(SPTBatch_.this.xmlPath);
<             }
< 
<             Object[] columHeadersFinalSpot = new Object[]{"IMAGE_TITLE", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MEAN_INTENSITY", "MEDIAN_INTENSITY", "MIN_INTENSITY", "MAX_INTENSITY", "TOTAL_INTENSITY", "STANDARD_DEVIATION", "CONTRAST", "SNR", "ESTIMATED_DIAMETER", "MORPHOLOGY", "ELLIPSOIDFIT_SEMIAXISLENGTH_C", "ELLIPSOIDFIT_SEMIAXISLENGTH_B", "ELLIPSOIDFIT_SEMIAXISLENGTH_A", "ELLIPSOIDFIT_AXISPHI_C", "ELLIPSOIDFIT_AXISPHI_B", "ELLIPSOIDFIT_AXISPHI_A", "ELLIPSOIDFIT_AXISTHETA_C", "ELLIPSOIDFIT_AXISTHETA_B", "ELLIPSOIDFIT_AXISTHETA_A"};
<             Object[] columHeadersFinalLink = new Object[]{"IMAGE_TITLE", "LINK_COST", "EDGE_TIME", "EDGE_X_LOCATION", "EDGE_Y_LOCATION", "EDGE_Z_LOCATION", "VELOCITY", "DISPLACEMENT"};
<             Object[] columHeadersFinalTrack = new Object[]{"IMAGE_TITLE", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_INDEX", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "NUMBER_SPOTS", "NUMBER_GAPS", "LONGEST_GAP", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "TRACK_MEAN_QUALITY", "TRACK_MAX_QUALITY", "TRACK_MIN_QUALITY", "TRACK_MEDIAN_QUALITY", "TRACK_STD_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "TOTAL_ABSOLUTE_ANGLE_XY", "TOTAL_ABSOLUTE_ANGLE_YZ", "TOTAL_ABSOLUTE_ANGLE_ZX", "CONFINMENT_RATIO"};
<             SPTBatch_.this.rtSpot = new ResultsTable(SPTBatch_.this.imageTitles.length);
<             SPTBatch_.this.rtLink = new ResultsTable(SPTBatch_.this.imageTitles.length);
<             SPTBatch_.this.rtTrack = new ResultsTable(SPTBatch_.this.imageTitles.length);
<             SPTBatch_.this.rtSpots = new ResultsTable[listOfFiles.length];
<             SPTBatch_.this.rtLinks = new ResultsTable[listOfFiles.length];
<             SPTBatch_.this.rtTracks = new ResultsTable[listOfFiles.length];
< 
<             int MAX;
<             for(MAX = 0; MAX < columHeadersFinalSpot.length; ++MAX) {
<                SPTBatch_.this.rtSpot.setHeading(MAX, (String)columHeadersFinalSpot[MAX]);
<             }
< 
<             for(MAX = 0; MAX < columHeadersFinalLink.length; ++MAX) {
<                SPTBatch_.this.rtLink.setHeading(MAX, (String)columHeadersFinalLink[MAX]);
<             }
< 
<             for(MAX = 0; MAX < columHeadersFinalTrack.length; ++MAX) {
<                SPTBatch_.this.rtTrack.setHeading(MAX, (String)columHeadersFinalTrack[MAX]);
<             }
< 
<             MAX = listOfFiles.length;
<             JFrame frameAnalyzer = new JFrame("Analyzing...");
<             final JProgressBar pb = new JProgressBar();
<             pb.setMinimum(0);
<             pb.setMaximum(MAX);
<             pb.setStringPainted(true);
<             SPTBatch_.taskOutput = new JTextArea(5, 20);
<             SPTBatch_.taskOutput.setMargin(new Insets(5, 5, 5, 5));
<             SPTBatch_.taskOutput.setEditable(false);
<             DefaultCaret caret = (DefaultCaret)SPTBatch_.taskOutput.getCaret();
<             caret.setUpdatePolicy(2);
<             JPanel panel = new JPanel();
<             panel.setLayout(new BoxLayout(panel, 1));
<             panel.add(pb);
<             panel.add(Box.createVerticalStrut(5));
<             panel.add(new JScrollPane(SPTBatch_.taskOutput), "Center");
<             panel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));
<             frameAnalyzer.getContentPane().add(panel);
<             frameAnalyzer.setDefaultCloseOperation(2);
<             frameAnalyzer.setSize(550, 500);
<             frameAnalyzer.setVisible(true);
<             SPTBatch_.this.selectedItems = new ArrayList();
<             final int i;
<             if (SPTBatch_.checkSummary.isSelected()) {
<                if (summaryColsWindow.combo.getSelectedIndex() == 0) {
<                   for(i = 0; i < summaryColsWindow.itemsSpots.length; ++i) {
<                      if (summaryColsWindow.itemsSpots[i].isSelected()) {
<                         SPTBatch_.this.selectedItems.add(summaryColsWindow.itemsSpots[i].text);
<                      }
<                   }
<                }
< 
<                if (summaryColsWindow.combo.getSelectedIndex() == 1) {
<                   for(i = 0; i < summaryColsWindow.itemsLinks.length; ++i) {
<                      if (summaryColsWindow.itemsLinks[i].isSelected()) {
<                         SPTBatch_.this.selectedItems.add(summaryColsWindow.itemsLinks[i].text);
<                      }
<                   }
<                }
< 
<                if (summaryColsWindow.combo.getSelectedIndex() == 2) {
<                   for(i = 0; i < summaryColsWindow.itemsTracks.length; ++i) {
<                      if (summaryColsWindow.itemsTracks[i].isSelected()) {
<                         SPTBatch_.this.selectedItems.add(summaryColsWindow.itemsTracks[i].text);
<                      }
<                   }
<                }
<             }
< 
<             for(SPTBatch_.i = 0; SPTBatch_.i < listOfFiles.length; ++SPTBatch_.i) {
<                if (SPTBatch_.imps != null) {
<                   SPTBatch_.imps.hide();
<                }
< 
<                if (listOfFiles[SPTBatch_.i].isFile()) {
<                   SPTBatch_.this.imageTitles[SPTBatch_.i] = listOfFiles[SPTBatch_.i].getName();
<                   SPTBatch_.imgTitle = SPTBatch_.this.imageTitles[SPTBatch_.i];
<                }
< 
<                i = SPTBatch_.i + 1;
< 
<                try {
<                   SwingUtilities.invokeLater(new Runnable() {
<                      public void run() {
<                         pb.setValue(i);
<                         SPTBatch_.taskOutput.append(String.format("Completed %f%% of task.\n", (double)i * 100.0D / (double)listOfFiles.length));
<                      }
<                   });
<                   Thread.sleep(100L);
<                } catch (InterruptedException var158) {
<                   JOptionPane.showMessageDialog(frameAnalyzer, var158.getMessage());
<                }
< 
<                if (listOfFiles[SPTBatch_.i].getName().contains(".lif")) {
<                   SPTBatch_.this.lifs = SPTBatch_.openBF(SPTBatch_.this.imagesPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i], false, false, false, false, false, true);
< 
<                   for(int x = 0; x < SPTBatch_.this.lifs.length; ++x) {
<                      SPTBatch_.imps = new ImagePlus(SPTBatch_.this.imagesPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]);
<                   }
<                }
< 
<                if (!listOfFiles[SPTBatch_.i].getName().contains(".lif")) {
<                   SPTBatch_.imps = new ImagePlus(SPTBatch_.this.imagesPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]);
<                }
< 
<                IJ.resetMinAndMax(SPTBatch_.imps);
<                SPTBatch_.this.dims = SPTBatch_.imps.getDimensions();
<                SPTBatch_.this.calibration = SPTBatch_.imps.getCalibration();
<                SPTBatch_.fps = SPTBatch_.imps.getFileInfo().frameInterval;
<                if (SPTBatch_.this.dims[4] == 1 && SPTBatch_.this.dims[3] > 1) {
<                   SPTBatch_.imps.setDimensions(SPTBatch_.this.dims[2], SPTBatch_.this.dims[4], SPTBatch_.this.dims[3]);
<                   SPTBatch_.this.calibration.frameInterval = SPTBatch_.this.calibration.frameInterval;
<                   SPTBatch_.this.loggers = Logger.IJ_LOGGER;
<                }
< 
<                SPTBatch_.impsSubBg = SPTBatch_.imps.duplicate();
<                SPTBatch_.impsSubBg.setCalibration(SPTBatch_.this.calibration);
<                SPTBatch_.directImages = new File(SPTBatch_.csvPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", ""));
<                boolean resultx;
<                if (!SPTBatch_.directImages.exists()) {
<                   SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directImages.getName());
<                   resultx = false;
< 
<                   try {
<                      SPTBatch_.directImages.mkdir();
<                      resultx = true;
<                   } catch (SecurityException var157) {
<                   }
< 
<                   if (resultx) {
<                      SPTBatch_.taskOutput.append("DIR created");
<                   }
<                }
< 
<                SPTBatch_.directSummary = new File(SPTBatch_.csvPath + File.separator + "Summary_Analysis");
<                if (!SPTBatch_.directSummary.exists()) {
<                   resultx = false;
< 
<                   try {
<                      SPTBatch_.directSummary.mkdir();
<                      resultx = true;
<                   } catch (SecurityException var156) {
<                   }
< 
<                   if (resultx) {
<                      SPTBatch_.taskOutput.append("DIR created-Summary_Analysis");
<                   }
<                }
< 
<                SPTBatch_.directSPT = new File(SPTBatch_.csvPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", "") + File.separator + "SPT_Analysis");
<                if (!SPTBatch_.directSPT.exists()) {
<                   resultx = false;
< 
<                   try {
<                      SPTBatch_.directSPT.mkdir();
<                      resultx = true;
<                   } catch (SecurityException var155) {
<                   }
< 
<                   if (resultx) {
<                      SPTBatch_.taskOutput.append("DIR created-SPT_Analysis");
<                   }
<                }
< 
<                SPTBatch_.directPBS = new File(SPTBatch_.csvPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", "") + File.separator + "Photobleaching_Analysis");
<                if (SPTBatch_.checkPBS.isSelected() && !SPTBatch_.directPBS.exists()) {
<                   resultx = false;
< 
<                   try {
<                      SPTBatch_.directPBS.mkdir();
<                      resultx = true;
<                   } catch (SecurityException var154) {
<                   }
< 
<                   if (resultx) {
<                      SPTBatch_.taskOutput.append("DIR created-Photobleching_Analysis");
<                   }
<                }
< 
<                if (SPTBatch_.checkboxMSD.isSelected() == Boolean.TRUE) {
<                   SPTBatch_.directMSS = new File(SPTBatch_.directImages.getAbsolutePath() + File.separator + "MSS_Analysis");
<                   if (!SPTBatch_.directMSS.exists()) {
<                      SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directMSS.getName());
<                      resultx = false;
< 
<                      try {
<                         SPTBatch_.directMSS.mkdir();
<                         resultx = true;
<                      } catch (SecurityException var153) {
<                      }
< 
<                      if (resultx) {
<                         SPTBatch_.taskOutput.append(SPTBatch_.directMSS.getName() + "  DIR created");
<                      }
<                   }
<                }
< 
<                if (SPTBatch_.checkCluster.isSelected() == Boolean.TRUE) {
<                   SPTBatch_.directCluster = new File(SPTBatch_.directImages.getAbsolutePath() + File.separator + "Cluster_Size_Analysis");
<                   if (!SPTBatch_.directCluster.exists()) {
<                      SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directCluster.getName());
<                      resultx = false;
< 
<                      try {
<                         SPTBatch_.directCluster.mkdir();
<                         resultx = true;
<                      } catch (SecurityException var152) {
<                      }
< 
<                      if (resultx) {
<                         SPTBatch_.taskOutput.append(SPTBatch_.directCluster.getName() + "  DIR created");
<                      }
<                   }
<                }
< 
<                new TmXmlReader(SPTBatch_.fileXmlInitial);
<                DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
<                DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
<                DocumentBuilder builder = null;
< 
<                try {
<                   builder = factory.newDocumentBuilder();
<                } catch (ParserConfigurationException var151) {
<                   var151.printStackTrace();
<                }
< 
<                Document doc = null;
< 
<                try {
<                   doc = builder.parse(SPTBatch_.fileXmlInitial);
<                } catch (SAXException var149) {
<                   var149.printStackTrace();
<                } catch (IOException var150) {
<                   var150.printStackTrace();
<                }
< 
<                XPathFactory xPathfactory = XPathFactory.newInstance();
<                XPath xpath = xPathfactory.newXPath();
<                XPathExpression exprBasicSettings = null;
<                XPathExpression exprDetectorSettings = null;
<                XPathExpression exprInitialSpotFilter = null;
<                XPathExpression exprFilter = null;
<                XPathExpression exprTrackerSettings = null;
<                XPathExpression exprLinking = null;
<                XPathExpression exprGapClosing = null;
<                XPathExpression exprSplitting = null;
<                XPathExpression exprMerging = null;
<                XPathExpression exprTrackFilter = null;
<                XPathExpression exprLinkingP = null;
< 
<                try {
<                   exprBasicSettings = xpath.compile("//Settings/BasicSettings[@zstart]");
<                } catch (XPathExpressionException var148) {
<                   var148.printStackTrace();
<                }
< 
<                try {
<                   exprLinkingP = xpath.compile("//Linking/FeaturePenalties[@MEAN_INTENSITY]");
<                } catch (XPathExpressionException var147) {
<                   var147.printStackTrace();
<                }
< 
<                try {
<                   exprDetectorSettings = xpath.compile("//Settings/DetectorSettings[@RADIUS]");
<                } catch (XPathExpressionException var146) {
<                   var146.printStackTrace();
<                }
< 
<                try {
<                   exprInitialSpotFilter = xpath.compile("//Settings/InitialSpotFilter[@feature]");
<                } catch (XPathExpressionException var145) {
<                   var145.printStackTrace();
<                }
< 
<                try {
<                   exprFilter = xpath.compile("//SpotFilterCollection/Filter[@feature]");
<                } catch (XPathExpressionException var144) {
<                   var144.printStackTrace();
<                }
< 
<                try {
<                   exprTrackerSettings = xpath.compile("//Settings/TrackerSettings[@TRACKER_NAME]");
<                } catch (XPathExpressionException var143) {
<                   var143.printStackTrace();
<                }
< 
<                try {
<                   exprLinking = xpath.compile("//TrackerSettings/Linking[@LINKING_MAX_DISTANCE]");
<                } catch (XPathExpressionException var142) {
<                   var142.printStackTrace();
<                }
< 
<                try {
<                   exprGapClosing = xpath.compile("//TrackerSettings/GapClosing[@MAX_FRAME_GAP]");
<                } catch (XPathExpressionException var141) {
<                   var141.printStackTrace();
<                }
< 
<                try {
<                   exprSplitting = xpath.compile("//TrackerSettings/TrackSplitting[@SPLITTING_MAX_DISTANCE]");
<                } catch (XPathExpressionException var140) {
<                   var140.printStackTrace();
<                }
< 
<                try {
<                   exprMerging = xpath.compile("//TrackerSettings/TrackMerging[@MERGING_MAX_DISTANCE]");
<                } catch (XPathExpressionException var139) {
<                   var139.printStackTrace();
<                }
< 
<                try {
<                   exprTrackFilter = xpath.compile("//TrackFilterCollection/Filter[@feature]");
<                } catch (XPathExpressionException var138) {
<                   var138.printStackTrace();
<                }
< 
<                NodeList nlBasicSettings = null;
<                NodeList nlDetectorSettings = null;
<                NodeList nlInitialSpotFilter = null;
<                NodeList nlFilter = null;
<                NodeList nlTrackerSettings = null;
<                NodeList nlLinking = null;
<                NodeList nlGapClosing = null;
<                NodeList nlSplitting = null;
<                NodeList nlMerging = null;
<                NodeList nlTrackFilter = null;
<                NodeList nlLinkingP = null;
< 
<                try {
<                   nlBasicSettings = (NodeList)exprBasicSettings.evaluate(doc, XPathConstants.NODESET);
<                   nlDetectorSettings = (NodeList)exprDetectorSettings.evaluate(doc, XPathConstants.NODESET);
<                   nlInitialSpotFilter = (NodeList)exprInitialSpotFilter.evaluate(doc, XPathConstants.NODESET);
<                   nlFilter = (NodeList)exprFilter.evaluate(doc, XPathConstants.NODESET);
<                   nlTrackerSettings = (NodeList)exprTrackerSettings.evaluate(doc, XPathConstants.NODESET);
<                   nlLinking = (NodeList)exprLinking.evaluate(doc, XPathConstants.NODESET);
<                   nlGapClosing = (NodeList)exprGapClosing.evaluate(doc, XPathConstants.NODESET);
<                   nlSplitting = (NodeList)exprSplitting.evaluate(doc, XPathConstants.NODESET);
<                   nlMerging = (NodeList)exprMerging.evaluate(doc, XPathConstants.NODESET);
<                   nlTrackFilter = (NodeList)exprTrackFilter.evaluate(doc, XPathConstants.NODESET);
<                   nlLinkingP = (NodeList)exprLinkingP.evaluate(doc, XPathConstants.NODESET);
<                } catch (XPathExpressionException var137) {
<                   var137.printStackTrace();
<                }
< 
<                int j;
<                Node currentItem;
<                for(j = 0; j < nlBasicSettings.getLength(); ++j) {
<                   currentItem = nlBasicSettings.item(j);
<                   SPTBatch_.this.zstart = currentItem.getAttributes().getNamedItem("zstart").getNodeValue();
<                   SPTBatch_.this.zend = currentItem.getAttributes().getNamedItem("zend").getNodeValue();
<                   SPTBatch_.this.ystart = currentItem.getAttributes().getNamedItem("ystart").getNodeValue();
<                   SPTBatch_.this.yend = currentItem.getAttributes().getNamedItem("yend").getNodeValue();
<                   SPTBatch_.this.xstart = currentItem.getAttributes().getNamedItem("xstart").getNodeValue();
<                   SPTBatch_.this.xend = currentItem.getAttributes().getNamedItem("xend").getNodeValue();
<                   SPTBatch_.this.tstart = currentItem.getAttributes().getNamedItem("tstart").getNodeValue();
<                   SPTBatch_.this.tend = currentItem.getAttributes().getNamedItem("tend").getNodeValue();
<                }
< 
<                for(j = 0; j < nlDetectorSettings.getLength(); ++j) {
<                   currentItem = nlDetectorSettings.item(j);
<                   SPTBatch_.RADIUS = currentItem.getAttributes().getNamedItem("RADIUS").getNodeValue();
<                   SPTBatch_.this.THRESHOLD = currentItem.getAttributes().getNamedItem("THRESHOLD").getNodeValue();
<                   SPTBatch_.this.TARGET_CHANNEL = currentItem.getAttributes().getNamedItem("TARGET_CHANNEL").getNodeValue();
<                   SPTBatch_.this.DO_SUBPIXEL_LOCALIZATION = currentItem.getAttributes().getNamedItem("DO_SUBPIXEL_LOCALIZATION").getNodeValue();
<                   SPTBatch_.this.DO_MEDIAN_FILTERING = currentItem.getAttributes().getNamedItem("DO_MEDIAN_FILTERING").getNodeValue();
<                   SPTBatch_.this.DETECTOR_NAME = currentItem.getAttributes().getNamedItem("DETECTOR_NAME").getNodeValue();
<                   if (SPTBatch_.this.DETECTOR_NAME.equals("BLOCK_LOG_DETECTOR")) {
<                      SPTBatch_.this.NSPLIT = currentItem.getAttributes().getNamedItem("NSPLIT").getNodeValue();
<                   }
< 
<                   if (SPTBatch_.this.DETECTOR_NAME.equals("DOWNSAMLE_LOG_DETECTOR")) {
<                      SPTBatch_.this.DOWNSAMPLE_FACTOR = currentItem.getAttributes().getNamedItem("DOWNSAMPLE_FACTOR").getNodeValue();
<                   }
<                }
< 
<                for(j = 0; j < nlLinkingP.getLength(); ++j) {
<                   SPTBatch_.this.linkingNames = nlLinkingP.item(j).getAttributes().item(j).getNodeName();
<                   SPTBatch_.this.linkingValues = nlLinkingP.item(j).getAttributes().item(j).getNodeValue();
<                }
< 
<                for(j = 0; j < nlInitialSpotFilter.getLength(); ++j) {
<                   currentItem = nlInitialSpotFilter.item(j);
<                   SPTBatch_.this.initialSpotFilter = currentItem.getAttributes().getNamedItem("value").getNodeValue();
<                }
< 
<                List<String> spotFilterFeature = new ArrayList();
<                List<String> spotFilterValue = new ArrayList();
<                List<String> spotFilterAbove = new ArrayList();
< 
<                for(int jx = 0; jx < nlFilter.getLength(); ++jx) {
<                   Node currentItemx = nlFilter.item(jx);
<                   spotFilterFeature.add(currentItemx.getAttributes().getNamedItem("feature").getNodeValue());
<                   spotFilterValue.add(currentItemx.getAttributes().getNamedItem("value").getNodeValue());
<                   spotFilterAbove.add(currentItemx.getAttributes().getNamedItem("isabove").getNodeValue());
<                }
< 
<                List<String> trackFilterFeature = new ArrayList();
<                List<String> trackFilterValue = new ArrayList();
<                List<String> trackFilterAbove = new ArrayList();
< 
<                int jxx;
<                Node currentItemxx;
<                for(jxx = 0; jxx < nlTrackFilter.getLength(); ++jxx) {
<                   currentItemxx = nlTrackFilter.item(jxx);
<                   trackFilterFeature.add(currentItemxx.getAttributes().getNamedItem("feature").getNodeValue());
<                   trackFilterValue.add(currentItemxx.getAttributes().getNamedItem("value").getNodeValue());
<                   trackFilterAbove.add(currentItemxx.getAttributes().getNamedItem("isabove").getNodeValue());
<                }
< 
<                for(jxx = 0; jxx < nlTrackerSettings.getLength(); ++jxx) {
<                   currentItemxx = nlTrackerSettings.item(jxx);
<                   SPTBatch_.this.TRACKER_NAME = currentItemxx.getAttributes().getNamedItem("TRACKER_NAME").getNodeValue();
<                   SPTBatch_.this.CUTOFF_PERCENTILE = currentItemxx.getAttributes().getNamedItem("CUTOFF_PERCENTILE").getNodeValue();
<                   SPTBatch_.this.BLOCKING_VALUE = currentItemxx.getAttributes().getNamedItem("BLOCKING_VALUE").getNodeValue();
<                   SPTBatch_.this.ALTERNATIVE_LINKING_COST_FACTOR = currentItemxx.getAttributes().getNamedItem("ALTERNATIVE_LINKING_COST_FACTOR").getNodeValue();
<                }
< 
<                for(jxx = 0; jxx < nlLinking.getLength(); ++jxx) {
<                   currentItemxx = nlLinking.item(jxx);
<                   SPTBatch_.this.LINKING_MAX_DISTANCE = currentItemxx.getAttributes().getNamedItem("LINKING_MAX_DISTANCE").getNodeValue();
<                }
< 
<                for(jxx = 0; jxx < nlGapClosing.getLength(); ++jxx) {
<                   currentItemxx = nlGapClosing.item(jxx);
<                   SPTBatch_.this.MAX_FRAME_GAP = currentItemxx.getAttributes().getNamedItem("MAX_FRAME_GAP").getNodeValue();
<                   SPTBatch_.this.MAX_DISTANCE = currentItemxx.getAttributes().getNamedItem("GAP_CLOSING_MAX_DISTANCE").getNodeValue();
<                   SPTBatch_.this.ALLOW_GAP_CLOSING = currentItemxx.getAttributes().getNamedItem("ALLOW_GAP_CLOSING").getNodeValue();
<                }
< 
<                for(jxx = 0; jxx < nlSplitting.getLength(); ++jxx) {
<                   currentItemxx = nlSplitting.item(jxx);
<                   SPTBatch_.this.SPLITTING_MAX_DISTANCE = currentItemxx.getAttributes().getNamedItem("SPLITTING_MAX_DISTANCE").getNodeValue();
<                   SPTBatch_.this.ALLOW_TRACK_SPLITTING = currentItemxx.getAttributes().getNamedItem("ALLOW_TRACK_SPLITTING").getNodeValue();
<                }
< 
<                for(jxx = 0; jxx < nlMerging.getLength(); ++jxx) {
<                   currentItemxx = nlMerging.item(jxx);
<                   SPTBatch_.this.MERGING_MAX_DISTANCE = currentItemxx.getAttributes().getNamedItem("MERGING_MAX_DISTANCE").getNodeValue();
<                   SPTBatch_.this.ALLOW_TRACK_MERGING = currentItemxx.getAttributes().getNamedItem("ALLOW_TRACK_MERGING").getNodeValue();
<                }
< 
<                SPTBatch_.this.settings = new Settings(SPTBatch_.imps);
<                SPTBatch_.taskOutput.append(SPTBatch_.this.settings.toStringImageInfo());
<                if (SPTBatch_.this.DETECTOR_NAME.equals("LOG_DETECTOR")) {
<                   SPTBatch_.this.settings.detectorFactory = new LogDetectorFactory();
<                   SPTBatch_.this.settings.detectorSettings = SPTBatch_.this.settings.detectorFactory.getDefaultSettings();
<                   SPTBatch_.this.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", Boolean.parseBoolean(SPTBatch_.this.DO_SUBPIXEL_LOCALIZATION));
<                   SPTBatch_.this.settings.detectorSettings.put("RADIUS", Double.parseDouble(SPTBatch_.RADIUS));
<                   SPTBatch_.this.settings.detectorSettings.put("TARGET_CHANNEL", Integer.parseInt(SPTBatch_.this.TARGET_CHANNEL));
<                   SPTBatch_.this.settings.detectorSettings.put("THRESHOLD", Double.parseDouble(SPTBatch_.this.THRESHOLD));
<                   SPTBatch_.this.settings.detectorSettings.put("DO_MEDIAN_FILTERING", Boolean.parseBoolean(SPTBatch_.this.DO_MEDIAN_FILTERING));
<                   if (SPTBatch_.this.initialSpotFilter != null) {
<                      SPTBatch_.this.settings.initialSpotFilterValue = Double.parseDouble(SPTBatch_.this.initialSpotFilter);
<                   }
<                }
< 
<                if (SPTBatch_.this.DETECTOR_NAME.equals("DOG_DETECTOR")) {
<                   SPTBatch_.this.settings.detectorFactory = new DogDetectorFactory();
<                   SPTBatch_.this.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", Boolean.parseBoolean(SPTBatch_.this.DO_SUBPIXEL_LOCALIZATION));
<                   SPTBatch_.this.settings.detectorSettings.put("RADIUS", Double.parseDouble(SPTBatch_.RADIUS));
<                   SPTBatch_.this.settings.detectorSettings.put("TARGET_CHANNEL", Integer.parseInt(SPTBatch_.this.TARGET_CHANNEL));
<                   SPTBatch_.this.settings.detectorSettings.put("THRESHOLD", Double.parseDouble(SPTBatch_.this.THRESHOLD));
<                   SPTBatch_.this.settings.detectorSettings.put("DO_MEDIAN_FILTERING", Double.parseDouble(SPTBatch_.this.DO_MEDIAN_FILTERING));
<                   if (SPTBatch_.this.initialSpotFilter != null) {
<                      SPTBatch_.this.settings.initialSpotFilterValue = Double.parseDouble(SPTBatch_.this.initialSpotFilter);
<                   }
<                }
< 
<                List<FeatureFilter> spotFilters = new ArrayList();
< 
<                int jxxxxx;
<                for(jxxxxx = 0; jxxxxx < spotFilterFeature.size(); ++jxxxxx) {
<                   spotFilters.add(new FeatureFilter((String)spotFilterFeature.get(jxxxxx), Double.valueOf((String)spotFilterValue.get(jxxxxx)), Boolean.valueOf((String)spotFilterAbove.get(jxxxxx))));
<                }
< 
<                for(jxxxxx = 0; jxxxxx < spotFilters.size(); ++jxxxxx) {
<                   SPTBatch_.this.settings.addSpotFilter((FeatureFilter)spotFilters.get(jxxxxx));
<                }
< 
<                if (SPTBatch_.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
<                   SPTBatch_.this.settings.trackerFactory = new ManualTrackerFactory();
<                   SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                }
< 
<                if (SPTBatch_.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
<                   SPTBatch_.this.settings.trackerFactory = new ManualTrackerFactory();
<                   SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                }
< 
<                if (SPTBatch_.this.TRACKER_NAME.equals("KALMAN_TRACKER")) {
<                   SPTBatch_.this.settings.trackerFactory = new KalmanTrackerFactory();
<                   SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                   SPTBatch_.this.settings.trackerSettings.put("KALMAN_SEARCH_RADIUS", Double.parseDouble(SPTBatch_.RADIUS));
<                }
< 
<                if (SPTBatch_.this.TRACKER_NAME.equals("SIMPLE_SPARSE_LAP_TRACKER")) {
<                   SPTBatch_.this.settings.trackerFactory = new SimpleSparseLAPTrackerFactory();
<                   SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                   SPTBatch_.this.settings.trackerSettings.put("LINKING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.LINKING_MAX_DISTANCE));
<                   SPTBatch_.this.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.MAX_DISTANCE));
<                   SPTBatch_.this.settings.trackerSettings.put("MAX_FRAME_GAP", Double.parseDouble(SPTBatch_.this.MAX_FRAME_GAP));
<                }
< 
<                if (SPTBatch_.this.TRACKER_NAME.equals("SPARSE_LAP_TRACKER")) {
<                   SPTBatch_.this.settings.trackerFactory = new SparseLAPTrackerFactory();
<                   SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                   SPTBatch_.this.settings.trackerSettings.put("LINKING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.LINKING_MAX_DISTANCE));
<                   Map<String, Double> linkingPenalty = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((datax) -> {
<                      return (String)datax[0];
<                   }, (datax) -> {
<                      return (Double)datax[1];
<                   }));
<                   SPTBatch_.this.settings.trackerSettings.put("ALLOW_GAP_CLOSING", Boolean.parseBoolean(SPTBatch_.this.ALLOW_GAP_CLOSING));
<                   Map var50;
<                   if (Boolean.parseBoolean(SPTBatch_.this.ALLOW_GAP_CLOSING)) {
<                      SPTBatch_.this.settings.trackerSettings.put("MAX_FRAME_GAP", Integer.parseInt(SPTBatch_.this.MAX_FRAME_GAP));
<                      SPTBatch_.this.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.MAX_DISTANCE));
<                      var50 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((datax) -> {
<                         return (String)datax[0];
<                      }, (datax) -> {
<                         return (Double)datax[1];
<                      }));
<                   }
< 
<                   SPTBatch_.this.settings.trackerSettings.put("ALLOW_TRACK_SPLITTING", Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_SPLITTING));
<                   if (Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_SPLITTING)) {
<                      SPTBatch_.this.settings.trackerSettings.put("SPLITTING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.SPLITTING_MAX_DISTANCE));
<                      var50 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((datax) -> {
<                         return (String)datax[0];
<                      }, (datax) -> {
<                         return (Double)datax[1];
<                      }));
<                   }
< 
<                   SPTBatch_.this.settings.trackerSettings.put("ALLOW_TRACK_MERGING", Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_MERGING));
<                   if (Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_MERGING)) {
<                      SPTBatch_.this.settings.trackerSettings.put("MERGING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.MERGING_MAX_DISTANCE));
<                      var50 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((datax) -> {
<                         return (String)datax[0];
<                      }, (datax) -> {
<                         return (Double)datax[1];
<                      }));
<                   }
<                }
< 
<                List<FeatureFilter> trackFilters = new ArrayList();
< 
<                int jxxxxxx;
<                for(jxxxxxx = 0; jxxxxxx < trackFilterFeature.size(); ++jxxxxxx) {
<                   trackFilters.add(new FeatureFilter((String)trackFilterFeature.get(jxxxxxx), Double.valueOf((String)trackFilterValue.get(jxxxxxx)), Boolean.valueOf((String)trackFilterAbove.get(jxxxxxx))));
<                }
< 
<                for(jxxxxxx = 0; jxxxxxx < trackFilters.size(); ++jxxxxxx) {
<                   SPTBatch_.this.settings.addTrackFilter((FeatureFilter)trackFilters.get(jxxxxxx));
<                }
< 
<                boolean result;
<                if (SPTBatch_.checkboxSubBg.isSelected()) {
<                   SPTBatch_.slices = SPTBatch_.stack2images(SPTBatch_.impsSubBg);
<                   SPTBatch_.slicesIntensityBg = new double[SPTBatch_.slices.length];
<                   SPTBatch_.slicesIntensitySpot = new double[SPTBatch_.slices.length];
<                   if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 0) {
<                      SPTBatch_.impMaxProject = ZProjector.run(SPTBatch_.impsSubBg.duplicate(), "max");
<                      SPTBatch_.impMaxProject.show();
<                      SPTBatch_.roiManager = RoiManager.getInstance();
<                      if (SPTBatch_.roiManager == null) {
<                         SPTBatch_.roiManager = new RoiManager();
<                      }
< 
<                      SPTBatch_.roiManager.reset();
<                      SPTBatch_.impMaxProject.getCanvas().addMouseListener(new MouseAdapter() {
<                         public void mouseClicked(MouseEvent e) {
<                            if (e.getClickCount() == 2) {
<                               Roi roi = new Roi(SPTBatch_.impMaxProject.getCanvas().offScreenX(e.getX()), SPTBatch_.impMaxProject.getCanvas().offScreenY(e.getY()), 5, 5);
<                               SPTBatch_.impMaxProject.setRoi(roi);
<                               SPTBatch_.roiManager.runCommand(SPTBatch_.impMaxProject, "Show All with labels");
<                               SPTBatch_.roiManager.addRoi(roi);
<                            }
< 
<                         }
<                      });
<                      Dialog4BgSub0 userDialog = new Dialog4BgSub0("Action Required", "Please select manually areas to measure background.");
<                      userDialog.show();
<                   }
< 
<                   ImagePlus slicesCell;
<                   Roi roiCell;
<                   double meanInv;
<                   if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 2) {
<                      for(jxxxxxx = 0; jxxxxxx < SPTBatch_.slices.length; ++jxxxxxx) {
<                         slicesCell = SPTBatch_.slices[jxxxxxx].duplicate();
<                         IJ.run(slicesCell, "Auto Threshold", "method=Otsu ignore_black white");
<                         slicesCell = new ImagePlus(slicesCell.getTitle(), Morphology.dilation(slicesCell.getProcessor(), Shape.DISK.fromRadius(2)));
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Fill Holes", "");
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Create Selection", "");
<                         roiCell = slicesCell.getRoi();
<                         IJ.run(slicesCell, "Make Inverse", "");
<                         Roi roiToMeasureInvx = slicesCell.getRoi();
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiCell);
<                         double meanDirectx = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiToMeasureInvx);
<                         meanInv = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         if (meanDirectx > meanInv) {
<                            SPTBatch_.slicesIntensitySpot[jxxxxxx] = meanDirectx;
<                         } else {
<                            SPTBatch_.slicesIntensitySpot[jxxxxxx] = meanInv;
<                         }
<                      }
<                   }
< 
<                   if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 3) {
<                      for(jxxxxxx = 0; jxxxxxx < SPTBatch_.slices.length; ++jxxxxxx) {
<                         slicesCell = SPTBatch_.slices[jxxxxxx].duplicate();
<                         IJ.run(slicesCell, "Auto Threshold", "method=Otsu ignore_black white");
<                         slicesCell = new ImagePlus(slicesCell.getTitle(), Morphology.dilation(slicesCell.getProcessor(), Shape.DISK.fromRadius(2)));
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Fill Holes", "");
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Create Selection", "");
<                         roiCell = slicesCell.getRoi();
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiCell);
<                         double meanDirect = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         IJ.run(slicesCell, "Make Inverse", "");
<                         Roi roiCellInv = slicesCell.getRoi();
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiCellInv);
<                         meanInv = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         if (meanDirect > meanInv) {
<                            roiCell = roiCell;
<                         } else {
<                            roiCell = roiCellInv;
<                         }
< 
<                         ImagePlus slicesSpot = SPTBatch_.slices[jxxxxxx].duplicate();
<                         String value = String.valueOf(Double.valueOf(SPTBatch_.RADIUS) / SPTBatch_.imps.getCalibration().pixelWidth);
<                         if (value.contains(",")) {
<                            value = value.replaceAll(",", ".");
<                         }
< 
<                         IJ.run(slicesSpot, "Subtract Background...", String.format("rolling=%s", value));
<                         IJ.run(slicesSpot, "Auto Threshold", "method=Otsu ignore_black white");
<                         IJ.run(slicesSpot, "Create Selection", "");
<                         Roi roiSpots = slicesSpot.getRoi();
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiSpots);
<                         double meanDirectSpots = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         IJ.run(slicesSpot, "Make Inverse", "");
<                         Roi roiSpotInv = slicesCell.getRoi();
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiCellInv);
<                         double meanInvSpots = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         if (meanDirect > meanInv) {
<                            roiSpots = roiSpots;
<                         } else {
<                            roiSpots = roiSpotInv;
<                         }
< 
<                         Roi roiToMeasurex = (new ShapeRoi(roiCell)).xor(new ShapeRoi(roiSpots));
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiToMeasurex);
<                         SPTBatch_.slicesIntensitySpot[jxxxxxx] = SPTBatch_.slices[jxxxxxx].getStatistics().mean - SPTBatch_.slices[jxxxxxx].getStatistics().stdDev;
<                      }
<                   }
< 
<                   if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 4) {
<                      for(jxxxxxx = 0; jxxxxxx < SPTBatch_.slices.length; ++jxxxxxx) {
<                         slicesCell = SPTBatch_.slices[jxxxxxx].duplicate();
<                         IJ.run(slicesCell, "Auto Threshold", "method=Otsu ignore_black white");
<                         slicesCell = new ImagePlus(slicesCell.getTitle(), Morphology.dilation(slicesCell.getProcessor(), Shape.DISK.fromRadius(2)));
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Fill Holes", "");
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Create Selection", "");
<                         roiCell = slicesCell.getRoi();
<                         ImagePlus sliceDup2 = SPTBatch_.slices[jxxxxxx].duplicate();
<                         sliceDup2.setRoi(roiCell);
<                         IJ.run(sliceDup2, "Clear Outside", "");
<                         BackgroundSubtracter bgSubt = new BackgroundSubtracter();
<                         ImageProcessor ip = sliceDup2.getProcessor();
<                         sliceDup2.getProcessor().resetMinAndMax();
<                         boolean isRGB = sliceDup2.getProcessor() instanceof ColorProcessor;
<                         boolean calledAsPlugin = true;
<                         double radius = Double.valueOf(SPTBatch_.RADIUS) / SPTBatch_.imps.getCalibration().pixelWidth;
<                         boolean lightBackground = false;
<                         boolean separateColors = false;
<                         boolean createBackground = false;
<                         boolean useParaboloid = false;
<                         boolean doPresmooth = false;
<                         result = false;
<                         boolean correctCorners = true;
<                         SPTBatch_.slicesIntensitySpot[jxxxxxx] = bgSubt.rollingBallBackground(ip, radius, createBackground, lightBackground, useParaboloid, doPresmooth, correctCorners);
<                      }
<                   }
<                }
< 
<                SPTBatch_.this.settings.addAllAnalyzers();
<                SPTBatch_.model = new Model();
<                SPTBatch_.this.trackmate = new TrackMate(SPTBatch_.model, SPTBatch_.this.settings);
<                Boolean ok = SPTBatch_.this.trackmate.checkInput();
<                if (ok != Boolean.TRUE) {
<                   SPTBatch_.taskOutput.append(SPTBatch_.this.trackmate.getErrorMessage());
<                }
< 
<                ok = SPTBatch_.this.trackmate.process();
<                SPTBatch_.selectionModel = new SelectionModel(SPTBatch_.model);
<                SPTBatch_.model.setLogger(Logger.IJ_LOGGER);
<                SpotCollection spots = SPTBatch_.model.getSpots();
<                SPTBatch_.taskOutput.append(spots.toString());
<                FeatureModel fm = SPTBatch_.model.getFeatureModel();
<                SPTBatch_.this.tcg = new PerTrackFeatureColorGenerator(SPTBatch_.model, "TRACK_INDEX", (Color)null, (Color)null, Colormap.Turbo, 0.0D, 1.0D);
<                SPTBatch_.taskOutput.append("\n\nSETTINGS:");
<                SPTBatch_.taskOutput.append(SPTBatch_.this.settings.toString());
<                SPTBatch_.taskOutput.append(SPTBatch_.model.toString());
<                SPTBatch_.taskOutput.append("Found" + SPTBatch_.model.getTrackModel().nTracks(true) + " tracks.");
<                SPTBatch_.taskOutput.append(SPTBatch_.this.settings.toStringFeatureAnalyzersInfo());
<                Integer firstFrame = null;
<                Integer lastFrame = null;
<                SPTBatch_.this.ds = DisplaySettingsIO.readUserDefault();
<                SPTBatch_.this.ds.setSpotShowName(SPTBatch_.checkDispSpotName.isSelected());
<                SPTBatch_.this.ds.setSpotVisible(SPTBatch_.checkDispSpots.isSelected());
<                SPTBatch_.this.ds.setSpotColorBy(TrackMateObject.TRACKS, "TRACK_INDEX");
<                SPTBatch_.this.ds.setTrackVisible(SPTBatch_.checkDispTracks.isSelected());
<                SPTBatch_.this.ds.setTrackColorBy(TrackMateObject.TRACKS, "TRACK_INDEX");
<                if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 0) {
<                   SPTBatch_.this.ds.setTrackDisplayMode(TrackDisplayMode.FULL);
<                }
< 
<                if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 1) {
<                   SPTBatch_.this.ds.setTrackDisplayMode(TrackDisplayMode.LOCAL);
<                }
< 
<                if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 2) {
<                   SPTBatch_.this.ds.setTrackDisplayMode(TrackDisplayMode.LOCAL_BACKWARD);
<                }
< 
<                if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 3) {
<                   SPTBatch_.this.ds.setTrackDisplayMode(TrackDisplayMode.LOCAL_FORWARD);
<                }
< 
<                SPTBatch_.this.displayer = new HyperStackDisplayer(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.imps, SPTBatch_.this.ds);
<                SPTBatch_.this.displayer.render();
<                SPTBatch_.this.displayer.refresh();
<                if (SPTBatch_.imps.getNFrames() > 1) {
<                   firstFrame = Math.max(1, Math.min(SPTBatch_.imps.getNFrames(), 1));
<                   lastFrame = Math.min(SPTBatch_.imps.getNFrames(), Math.max(SPTBatch_.imps.getNFrames(), 1));
<                }
< 
<                if (SPTBatch_.imps.getNSlices() > 1) {
<                   firstFrame = Math.max(1, Math.min(SPTBatch_.imps.getNSlices(), 1));
<                   lastFrame = Math.min(SPTBatch_.imps.getNSlices(), Math.max(SPTBatch_.imps.getNSlices(), 1));
<                }
< 
<                SPTBatch_.taskOutput.append("Capturing TrackMate overlay from frame " + firstFrame + " to " + lastFrame + ".\n");
<                Rectangle bounds = SPTBatch_.this.displayer.getImp().getCanvas().getBounds();
<                Integer width = bounds.width;
<                Integer height = bounds.height;
<                Integer nCaptures = lastFrame - firstFrame + 1;
<                ImageStack stack = new ImageStack(width, height);
<                Integer channel = SPTBatch_.this.displayer.getImp().getChannel();
<                Integer slice = SPTBatch_.this.displayer.getImp().getSlice();
<                SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(true);
< 
<                BufferedImage bi;
<                ColorProcessor cp;
<                Integer index;
<                int frame;
<                for(frame = firstFrame; frame <= lastFrame; ++frame) {
<                   SPTBatch_.this.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
<                   bi = new BufferedImage(width, height, 2);
<                   SPTBatch_.this.displayer.getImp().getCanvas().paint(bi.getGraphics());
<                   cp = new ColorProcessor(bi);
<                   index = SPTBatch_.this.displayer.getImp().getStackIndex(channel, slice, frame);
<                   stack.addSlice(SPTBatch_.this.displayer.getImp().getImageStack().getSliceLabel(index), cp);
<                }
< 
<                SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(false);
<                SPTBatch_.this.capture = new ImagePlus("TrackMate capture of " + SPTBatch_.this.displayer.getImp().getShortTitle(), stack);
<                SPTBatch_.transferCalibration(SPTBatch_.this.displayer.getImp(), SPTBatch_.this.capture);
<                SPTBatch_.taskOutput.append(" done.\n");
<                RoiManager trackx;
<                ArrayList framesByTrack;
<                int n;
<                int y;
<                int counter10;
<                if (SPTBatch_.checkboxRoi.isSelected() == Boolean.TRUE) {
<                   double dx = SPTBatch_.imps.getCalibration().pixelWidth;
<                   double dy = SPTBatch_.imps.getCalibration().pixelHeight;
<                   double dz = SPTBatch_.imps.getCalibration().pixelDepth;
<                   trackx = RoiManager.getInstance();
<                   if (trackx == null) {
<                      trackx = new RoiManager();
<                   }
< 
<                   trackx.reset();
<                   framesByTrack = new ArrayList(SPTBatch_.this.trackmate.getModel().getSpots().getNSpots(true));
<                   Iterator var74 = SPTBatch_.this.trackmate.getModel().getTrackModel().trackIDs(true).iterator();
< 
<                   while(var74.hasNext()) {
<                      Integer trackIDxxx = (Integer)var74.next();
<                      framesByTrack.addAll(SPTBatch_.this.trackmate.getModel().getTrackModel().trackSpots(trackIDxxx));
<                   }
< 
<                   for(n = 0; n < framesByTrack.size(); ++n) {
<                      SpotRoi sroi = ((Spot)framesByTrack.get(n)).getRoi();
<                      Object roi;
<                      if (sroi != null) {
<                         double[] xs = sroi.toPolygonX(dx, 0.0D, ((Spot)framesByTrack.get(n)).getDoublePosition(0), 1.0D);
<                         double[] ys = sroi.toPolygonY(dy, 0.0D, ((Spot)framesByTrack.get(n)).getDoublePosition(1), 1.0D);
<                         float[] xp = SPTBatch_.toFloat(xs);
<                         float[] yp = SPTBatch_.toFloat(ys);
<                         roi = new PolygonRoi(xp, yp, 2);
<                      } else {
<                         double diameter = 2.0D * ((Spot)framesByTrack.get(n)).getFeature("RADIUS") / dx;
<                         double xsx = ((Spot)framesByTrack.get(n)).getDoublePosition(0) / dx - diameter / 2.0D + 0.5D;
<                         double ysx = ((Spot)framesByTrack.get(n)).getDoublePosition(1) / dy - diameter / 2.0D + 0.5D;
<                         roi = new OvalRoi(xsx, ysx, diameter, diameter);
<                      }
< 
<                      y = 1 + (int)Math.round(((Spot)framesByTrack.get(n)).getDoublePosition(2) / dz);
<                      counter10 = 1 + ((Spot)framesByTrack.get(n)).getFeature("FRAME").intValue();
<                      ((Roi)roi).setPosition(0, y, counter10);
<                      ((Roi)roi).setName(((Spot)framesByTrack.get(n)).getName());
<                      trackx.addRoi((Roi)roi);
<                   }
< 
<                   if (trackx.getRoisAsArray().length != 0) {
<                      trackx.runCommand("Save", SPTBatch_.directSPT + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "RoiSet.zip");
<                   }
< 
<                   trackx.close();
<                }
< 
<                if (SPTBatch_.checkbox2.isSelected() == Boolean.TRUE) {
<                   SPTBatch_.taskOutput.append(SPTBatch_.model.toString());
<                   ISBIChallengeExporterModified.exportToFile(SPTBatch_.model, SPTBatch_.this.settings, new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + "TrackMate_" + SPTBatch_.imps.getShortTitle() + ".xml"));
<                   SPTBatch_.taskOutput.append("\nDone.");
<                }
< 
<                int counter1;
<                int maxFrame;
<                SpotCollection chart;
<                int counter4;
<                String xAxisLabelx;
<                if (SPTBatch_.this.enableST == "ST") {
<                   Model model = SPTBatch_.this.trackmate.getModel();
<                   Settings settings = SPTBatch_.this.trackmate.getSettings();
<                   chart = model.getSpots();
<                   counter1 = chart.keySet().size();
<                   double[][] data = new double[2][counter1];
<                   maxFrame = 0;
< 
<                   for(Iterator var237 = chart.keySet().iterator(); var237.hasNext(); ++maxFrame) {
<                      counter4 = (Integer)var237.next();
<                      data[1][maxFrame] = (double)chart.getNSpots(counter4, true);
<                      if (data[1][maxFrame] > 0.0D) {
<                         data[0][maxFrame] = ((Spot)chart.iterable(counter4, false).iterator().next()).getFeature("POSITION_T");
<                      } else {
<                         data[0][maxFrame] = (double)counter4 * settings.dt;
<                      }
<                   }
< 
<                   String xAxisLabel = "Time (" + SPTBatch_.this.trackmate.getModel().getTimeUnits() + ")";
<                   xAxisLabelx = "N spots";
<                   String title = "Nspots vs Time for " + SPTBatch_.this.trackmate.getSettings().imp.getShortTitle();
<                   DefaultXYDataset dataset = new DefaultXYDataset();
<                   dataset.addSeries("Nspots", data);
<                   SPTBatch_.this.chart = ChartFactory.createXYLineChart(title, xAxisLabel, xAxisLabelx, dataset, PlotOrientation.VERTICAL, true, true, false);
<                   SPTBatch_.this.chart.getTitle().setFont(Fonts.FONT);
<                   SPTBatch_.this.chart.getLegend().setItemFont(Fonts.SMALL_FONT);
<                   new ExportableChartPanel(SPTBatch_.this.chart);
<                }
< 
<                TablePanel chartx;
<                Set chartxxx;
<                int counter;
<                ArrayList framesByTrackx;
<                int framex;
<                ArrayList framesByTrackSort;
<                int jxxxx;
<                if (SPTBatch_.checkbox1.isSelected() == Boolean.TRUE) {
<                   TablePanel branchTable;
<                   if (SPTBatch_.this.enableSpotTable.equals("spotTable")) {
<                      branchTable = SPTBatch_.this.createSpotTable(SPTBatch_.model, SPTBatch_.this.ds);
<                      JTable spotJTablex = branchTable.getTable();
<                      chartx = SPTBatch_.this.createTrackTable(SPTBatch_.model, SPTBatch_.this.ds);
<                      SPTBatch_.trackJTable = chartx.getTable();
<                      SPTBatch_.nOfTracks = new ArrayList();
< 
<                      for(maxFrame = 0; maxFrame < SPTBatch_.trackJTable.getModel().getRowCount(); ++maxFrame) {
<                         SPTBatch_.nOfTracks.add(Integer.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(maxFrame, 2).toString()));
<                      }
< 
<                      SPTBatch_.this.indexes = new ArrayList();
<                      chartxxx = SPTBatch_.model.getTrackModel().trackIDs(true);
<                      trackx = null;
<                      counter = 0;
< 
<                      for(n = 0; n < SPTBatch_.nOfTracks.size(); ++n) {
<                         framesByTrackx = new ArrayList();
<                         framesByTrackSort = new ArrayList();
< 
<                         for(y = 0; y < spotJTablex.getRowCount(); ++y) {
<                            if (spotJTablex.getModel().getValueAt(y, 2).toString().equals(String.valueOf((Integer)SPTBatch_.nOfTracks.get(n)))) {
<                               framesByTrackx.add(Float.valueOf(spotJTablex.getModel().getValueAt(y, 8).toString()));
<                               framesByTrackSort.add(Float.valueOf(spotJTablex.getModel().getValueAt(y, 8).toString()));
<                            }
<                         }
< 
<                         Collections.sort(framesByTrackSort);
< 
<                         for(y = 0; y < framesByTrackSort.size(); ++y) {
<                            ++counter;
<                            if (n == 0) {
<                               SPTBatch_.this.indexes.add(framesByTrackx.indexOf(framesByTrackSort.get(y)));
<                            }
< 
<                            if (n != 0) {
<                               SPTBatch_.this.indexes.add(counter - 1 + framesByTrackx.indexOf(framesByTrackSort.get(y)) - y);
<                            }
<                         }
<                      }
< 
<                      String[][] rowDataSpot;
<                      ResultsTable rtSpotPerImage;
<                      if (SPTBatch_.checkboxSubBg.isSelected()) {
<                         SPTBatch_.columnNamesSpot = new String[]{"LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1", "Intensity-Bg Subtract"};
<                         rowDataSpot = new String[SPTBatch_.this.indexes.size()][SPTBatch_.columnNamesSpot.length];
<                         framex = 0;
< 
<                         while(true) {
<                            if (framex >= SPTBatch_.this.indexes.size()) {
<                               if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 1) {
<                                  for(framex = 0; framex < rowDataSpot.length; ++framex) {
<                                     rowDataSpot[framex][SPTBatch_.columnNamesSpot.length - 1] = String.valueOf(Double.valueOf(rowDataSpot[framex][12].toString()) - Double.valueOf(rowDataSpot[framex][19].toString()) * Double.valueOf(rowDataSpot[framex][17].toString()));
<                                  }
< 
<                                  DefaultTableModel tableModel = new DefaultTableModel(rowDataSpot, SPTBatch_.columnNamesSpot);
<                                  SPTBatch_.tableSpot = new JTable(tableModel);
<                               }
< 
<                               if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 0 || SPTBatch_.this.comboSubBg.getSelectedIndex() == 2 || SPTBatch_.this.comboSubBg.getSelectedIndex() == 3 || SPTBatch_.this.comboSubBg.getSelectedIndex() == 4) {
<                                  for(framex = 0; framex < spotJTablex.getModel().getRowCount(); ++framex) {
<                                     for(jxxxx = 0; jxxxx < SPTBatch_.slicesIntensitySpot.length; ++jxxxx) {
<                                        if (Integer.valueOf(rowDataSpot[framex][8].toString()).equals(jxxxx) == Boolean.TRUE) {
<                                           rowDataSpot[framex][SPTBatch_.columnNamesSpot.length - 1] = String.valueOf(Double.valueOf(rowDataSpot[framex][12].toString()) - Double.valueOf(SPTBatch_.slicesIntensitySpot[jxxxx]));
<                                        }
<                                     }
<                                  }
< 
<                                  SPTBatch_.tableSpot = new JTable(rowDataSpot, SPTBatch_.columnNamesSpot);
<                               }
< 
<                               SPTBatch_.this.exportToCSV(rowDataSpot, SPTBatch_.columnNamesSpot, new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Spots in tracks statistics" + ".csv"));
<                               rtSpotPerImage = new ResultsTable();
< 
<                               for(jxxxx = 0; jxxxx < rowDataSpot.length; ++jxxxx) {
<                                  for(y = 0; y < rowDataSpot[jxxxx].length; ++y) {
<                                     rtSpotPerImage.setValue(SPTBatch_.columnNamesSpot[y], jxxxx, rowDataSpot[jxxxx][y]);
<                                  }
<                               }
< 
<                               SPTBatch_.this.rtSpots[SPTBatch_.i] = rtSpotPerImage;
<                               break;
<                            }
< 
<                            rowDataSpot[framex][SPTBatch_.columnNamesSpot.length - 1] = "";
< 
<                            for(jxxxx = 0; jxxxx < spotJTablex.getModel().getColumnCount(); ++jxxxx) {
<                               rowDataSpot[framex][jxxxx] = String.valueOf(spotJTablex.getModel().getValueAt((Integer)SPTBatch_.this.indexes.get(framex), jxxxx));
<                            }
< 
<                            ++framex;
<                         }
<                      }
< 
<                      if (!SPTBatch_.checkboxSubBg.isSelected()) {
<                         SPTBatch_.columnNamesSpot = new String[]{"LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1"};
<                         rowDataSpot = new String[SPTBatch_.this.indexes.size()][SPTBatch_.columnNamesSpot.length];
< 
<                         for(framex = 0; framex < SPTBatch_.this.indexes.size(); ++framex) {
<                            for(jxxxx = 0; jxxxx < spotJTablex.getModel().getColumnCount(); ++jxxxx) {
<                               rowDataSpot[framex][jxxxx] = String.valueOf(spotJTablex.getModel().getValueAt((Integer)SPTBatch_.this.indexes.get(framex), jxxxx));
<                            }
<                         }
< 
<                         SPTBatch_.tableSpot = new JTable(rowDataSpot, SPTBatch_.columnNamesSpot);
<                         SPTBatch_.this.exportToCSV(rowDataSpot, SPTBatch_.columnNamesSpot, new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Spots in tracks statistics" + ".csv"));
<                         rtSpotPerImage = new ResultsTable();
< 
<                         for(jxxxx = 0; jxxxx < rowDataSpot.length; ++jxxxx) {
<                            for(y = 0; y < rowDataSpot[jxxxx].length; ++y) {
<                               rtSpotPerImage.setValue(SPTBatch_.columnNamesSpot[y], jxxxx, rowDataSpot[jxxxx][y]);
<                            }
<                         }
< 
<                         SPTBatch_.this.rtSpots[SPTBatch_.i] = rtSpotPerImage;
<                      }
<                   }
< 
<                   if (SPTBatch_.this.enableLinkTable.equals("linkTable")) {
<                      branchTable = SPTBatch_.this.createEdgeTable(SPTBatch_.model, SPTBatch_.this.ds);
<                      SPTBatch_.linkJTable = branchTable.getTable();
< 
<                      try {
<                         branchTable.exportToCsv(new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Links in tracks statistics" + ".csv"));
<                      } catch (IOException var136) {
<                         var136.printStackTrace();
<                      }
<                   }
< 
<                   if (SPTBatch_.checkExcludeTracks.isSelected()) {
<                      SPTBatch_.this.excludeTrack = new ArrayList();
<                      SPTBatch_.impMainRoi = ZProjector.run(SPTBatch_.impsSubBg.duplicate(), "max");
<                      ImagePlus impToMeasure = SPTBatch_.impMainRoi.duplicate();
<                      IJ.run(SPTBatch_.impMainRoi, "Auto Threshold", "method=Otsu ignore_black white");
<                      SPTBatch_.impMainRoi = new ImagePlus(SPTBatch_.impMainRoi.getTitle(), Morphology.dilation(SPTBatch_.impMainRoi.getProcessor(), Shape.DISK.fromRadius(2)));
<                      IJ.run(SPTBatch_.impMainRoi, "Invert LUT", "");
<                      IJ.run(SPTBatch_.impMainRoi, "Fill Holes", "");
<                      IJ.run(SPTBatch_.impMainRoi, "Invert LUT", "");
<                      IJ.run(SPTBatch_.impMainRoi, "Create Selection", "");
<                      Roi roiToMeasure = SPTBatch_.impMainRoi.getRoi();
<                      IJ.run(SPTBatch_.impMainRoi, "Make Inverse", "");
<                      Roi roiToMeasureInv = SPTBatch_.impMainRoi.getRoi();
<                      impToMeasure.setRoi(roiToMeasure);
<                      double meanDirectxx = SPTBatch_.impMainRoi.getStatistics().mean;
<                      impToMeasure.setRoi(roiToMeasureInv);
<                      double meanInvx = SPTBatch_.impMainRoi.getStatistics().mean;
<                      Roi mainRoi;
<                      if (meanDirectxx > meanInvx) {
<                         mainRoi = roiToMeasure;
<                      } else {
<                         mainRoi = roiToMeasureInv;
<                      }
< 
<                      for(jxxxx = 0; jxxxx < SPTBatch_.trackJTable.getRowCount(); ++jxxxx) {
<                         if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(SPTBatch_.trackJTable.getModel().getValueAt(jxxxx, SPTBatch_.trackJTable.convertColumnIndexToModel(13)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(SPTBatch_.trackJTable.getModel().getValueAt(jxxxx, SPTBatch_.trackJTable.convertColumnIndexToModel(14)).toString()))) == Boolean.TRUE) {
<                            SPTBatch_.this.excludeTrack.add(true);
<                         } else {
<                            SPTBatch_.this.excludeTrack.add(false);
<                         }
<                      }
<                   }
< 
<                   if (SPTBatch_.this.enableTrackTable.equals("trackTable")) {
<                      Thread tracksThread = new Thread(new Runnable() {
<                         public void run() {
<                            TablePanel trackTable;
<                            int r;
<                            int t;
<                            int rxx;
<                            int j;
<                            String var10001;
<                            int rxxx;
<                            int y;
<                            if (SPTBatch_.checkboxSubBg.isSelected()) {
<                               trackTable = SPTBatch_.this.createTrackTable(SPTBatch_.model, SPTBatch_.this.ds);
<                               SPTBatch_.trackJTable = trackTable.getTable();
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                                  SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + ")", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                                  SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + ")", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement", "Track within Cell"};
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                                  SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                                  SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement", "Track within Cell"};
<                               }
< 
<                               String[][] rowDataTrack = new String[SPTBatch_.trackJTable.getRowCount()][SPTBatch_.columnNamesTrack.length];
< 
<                               for(r = 0; r < SPTBatch_.trackJTable.getRowCount(); ++r) {
<                                  rowDataTrack[r][SPTBatch_.columnNamesTrack.length - 1] = "";
< 
<                                  for(t = 0; t < SPTBatch_.trackJTable.getColumnCount(); ++t) {
<                                     rowDataTrack[r][t] = String.valueOf(SPTBatch_.trackJTable.getValueAt(r, t));
<                                  }
<                               }
< 
<                               List<Integer> nOfTracks = new ArrayList();
< 
<                               for(t = 0; t < SPTBatch_.trackJTable.getRowCount(); ++t) {
<                                  nOfTracks.add(Integer.valueOf(SPTBatch_.trackJTable.getValueAt(t, 2).toString()));
<                               }
< 
<                               List<Double> allTracks = new ArrayList();
<                               List<Double> allTracksDef = new ArrayList();
< 
<                               for(rxx = 0; rxx < nOfTracks.size(); ++rxx) {
<                                  int counter = false;
<                                  List<Double> perTrack = new ArrayList();
<                                  List<Double> perTrackDef = new ArrayList();
< 
<                                  for(j = 0; j < SPTBatch_.tableSpot.getRowCount(); ++j) {
<                                     if (Integer.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(j, 2).toString()).equals(nOfTracks.get(rxx)) == Boolean.TRUE) {
<                                        perTrack.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(j, SPTBatch_.tableSpot.getColumnCount() - 1).toString()));
<                                     }
<                                  }
< 
<                                  if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE) {
<                                     for(j = SPTBatch_.minTracksJTF; j < SPTBatch_.maxTracksJTF; ++j) {
<                                        perTrackDef.add((Double)perTrack.get(j));
<                                     }
<                                  }
< 
<                                  if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE && perTrackDef.size() != 0) {
<                                     allTracksDef.add(perTrackDef.stream().mapToDouble((a) -> {
<                                        return a;
<                                     }).average().getAsDouble());
<                                  }
< 
<                                  if (perTrack.size() != 0) {
<                                     allTracks.add(perTrack.stream().mapToDouble((a) -> {
<                                        return a;
<                                     }).average().getAsDouble());
<                                  }
<                               }
< 
<                               ComputeMSD values = new ComputeMSD();
<                               values.Compute(nOfTracks, SPTBatch_.this.rtSpots[SPTBatch_.i]);
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                                  for(rxxx = 0; rxxx < SPTBatch_.trackJTable.getRowCount(); ++rxxx) {
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 13] = String.valueOf(((Double)ComputeMSD.msd1Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 12] = String.valueOf(((Double)ComputeMSD.msd2Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)ComputeMSD.msd3Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 10] = String.valueOf(((Double)ComputeMSD.msdValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 9] = String.valueOf(((Double)allTracks.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 8] = String.valueOf(((Double)ComputeMSD.diffValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString());
<                                     if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(rxxx, 3).toString()) >= Double.valueOf((double)SPTBatch_.thLengthJTF)) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Long");
<                                     } else {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Short");
<                                     }
< 
<                                     if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "Diff") {
<                                        if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) <= SPTBatch_.this.thD14JTF) {
<                                           rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Immobile");
<                                        }
< 
<                                        if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) > SPTBatch_.this.thD14JTF) {
<                                           rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Mobile");
<                                        }
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString());
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.6D && Double.valueOf(ComputeMSD.alphaValues.toString()) >= 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Confined");
<                                     }
< 
<                                     if (Double.valueOf(ComputeMSD.alphaValues.toString()) < 0.9D && Double.valueOf(ComputeMSD.alphaValues.toString()) >= 0.6D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Anomalous");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 1.1D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.9D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Free");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 1.1D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Directed");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = String.valueOf(ComputeMSD.mssValues.get(rxxx));
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Unidirectional Ballistic";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Immobile";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) >= 0.45D && (Double)ComputeMSD.mssValues.get(rxxx) <= 0.55D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Free";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.0D && (Double)ComputeMSD.mssValues.get(rxxx) < 0.45D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Confined";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.55D && (Double)ComputeMSD.mssValues.get(rxxx) < 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Directed";
<                                     }
<                                  }
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                                  for(rxxx = 0; rxxx < SPTBatch_.trackJTable.getRowCount(); ++rxxx) {
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 14] = String.valueOf(((Double)ComputeMSD.msd1Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 13] = String.valueOf(((Double)ComputeMSD.msd2Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 12] = String.valueOf(((Double)ComputeMSD.msd3Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)ComputeMSD.msdValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 10] = String.valueOf(((Double)allTracks.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 9] = String.valueOf(((Double)ComputeMSD.diffValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 8] = String.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString());
<                                     if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(rxxx, 3).toString()) >= Double.valueOf((double)SPTBatch_.thLengthJTF)) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf("Long");
<                                     } else {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf("Short");
<                                     }
< 
<                                     if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "Diff") {
<                                        if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) <= SPTBatch_.this.thD14JTF) {
<                                           rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Immobile");
<                                        }
< 
<                                        if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) > SPTBatch_.this.thD14JTF) {
<                                           rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Mobile");
<                                        }
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString());
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.6D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Confined");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.9D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.6D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Anomalous");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 1.1D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.9D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Free");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 1.1D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Directed");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf(ComputeMSD.mssValues.get(rxxx));
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Unidirectional Ballistic";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Immobile";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) >= 0.45D && (Double)ComputeMSD.mssValues.get(rxxx) <= 0.55D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Free";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.0D && (Double)ComputeMSD.mssValues.get(rxxx) < 0.45D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Confined";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.55D && (Double)ComputeMSD.mssValues.get(rxxx) < 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Directed";
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = ((Boolean)SPTBatch_.this.excludeTrack.get(rxxx)).toString();
<                                  }
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                                  for(rxxx = 0; rxxx < SPTBatch_.trackJTable.getRowCount(); ++rxxx) {
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 14] = String.valueOf(((Double)ComputeMSD.msd1Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 13] = String.valueOf(((Double)ComputeMSD.msd2Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 12] = String.valueOf(((Double)ComputeMSD.msd3Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)ComputeMSD.msdValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)ComputeMSD.msdValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 10] = String.valueOf(((Double)allTracks.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 9] = String.valueOf(((Double)allTracksDef.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 8] = String.valueOf(((Double)ComputeMSD.diffValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString());
<                                     if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(rxxx, 3).toString()) >= Double.valueOf((double)SPTBatch_.thLengthJTF)) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Long");
<                                     } else {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Short");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) <= SPTBatch_.this.thD14JTF) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Immobile");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) > SPTBatch_.this.thD14JTF) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Mobile");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString());
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.6D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Confined");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.9D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.6D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Anomalous");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 1.1D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.9D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Free");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 1.1D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Directed");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = String.valueOf(ComputeMSD.mssValues.get(rxxx));
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Unidirectional Ballistic";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Immobile";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) >= 0.45D && (Double)ComputeMSD.mssValues.get(rxxx) <= 0.55D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Free";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.0D && (Double)ComputeMSD.mssValues.get(rxxx) < 0.45D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Confined";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.55D && (Double)ComputeMSD.mssValues.get(rxxx) < 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Directed";
<                                     }
<                                  }
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                                  SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + ")", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement", "Track within Cell"};
< 
<                                  for(rxxx = 0; rxxx < SPTBatch_.trackJTable.getRowCount(); ++rxxx) {
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 15] = String.valueOf(((Double)ComputeMSD.msd1Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 14] = String.valueOf(((Double)ComputeMSD.msd2Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 13] = String.valueOf(((Double)ComputeMSD.msd3Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 12] = String.valueOf(((Double)ComputeMSD.msdValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)allTracks.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 10] = String.valueOf(((Double)allTracksDef.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 9] = String.valueOf(((Double)ComputeMSD.diffValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 8] = String.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString());
<                                     if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(rxxx, 3).toString()) >= Double.valueOf((double)SPTBatch_.thLengthJTF)) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf("Long");
<                                     } else {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf("Short");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) <= SPTBatch_.this.thD14JTF) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Immobile");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) > SPTBatch_.this.thD14JTF) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Mobile");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString());
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.6D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Confined");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.9D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.6D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Anomalous");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 1.1D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.9D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Free");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 1.1D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Directed");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf(ComputeMSD.mssValues.get(rxxx));
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Unidirectional Ballistic";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Immobile";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) >= 0.45D && (Double)ComputeMSD.mssValues.get(rxxx) <= 0.55D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Free";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.0D && (Double)ComputeMSD.mssValues.get(rxxx) < 0.45D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Confined";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.55D && (Double)ComputeMSD.mssValues.get(rxxx) < 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Directed";
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = ((Boolean)SPTBatch_.this.excludeTrack.get(rxxx)).toString();
<                                  }
<                               }
< 
<                               SPTBatch_.this.rtTrackPerImage = new ResultsTable();
< 
<                               for(rxxx = 0; rxxx < rowDataTrack.length; ++rxxx) {
<                                  for(y = 0; y < rowDataTrack[rxxx].length; ++y) {
<                                     var10001 = SPTBatch_.columnNamesTrack[y];
<                                     SPTBatch_.this.rtTrackPerImage.setValue(var10001, rxxx, rowDataTrack[rxxx][y]);
<                                  }
<                               }
< 
<                               try {
<                                  SPTBatch_.this.rtTrackPerImage.saveAs(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Tracks statistics" + ".csv");
<                               } catch (IOException var19) {
<                                  var19.printStackTrace();
<                               }
< 
<                               SPTBatch_.this.rtTracks[SPTBatch_.i] = SPTBatch_.this.rtTrackPerImage;
<                            }
< 
<                            int rx;
<                            if (!SPTBatch_.checkboxSubBg.isSelected()) {
<                               trackTable = SPTBatch_.this.createTrackTable(SPTBatch_.model, SPTBatch_.this.ds);
<                               ComputeMSD valuesx = new ComputeMSD();
<                               valuesx.Compute(SPTBatch_.nOfTracks, SPTBatch_.this.rtSpots[SPTBatch_.i]);
<                               JTable trackJTable = trackTable.getTable();
<                               SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<                               String[][] rowDataTrackx = new String[trackJTable.getModel().getRowCount()][SPTBatch_.columnNamesTrack.length];
< 
<                               for(rx = 0; rx < trackJTable.getModel().getRowCount(); ++rx) {
<                                  for(rxx = 0; rxx < trackJTable.getModel().getColumnCount(); ++rxx) {
<                                     rowDataTrackx[rx][rxx] = String.valueOf(trackJTable.getModel().getValueAt(rx, rxx));
<                                  }
<                               }
< 
<                               for(rx = 0; rx < trackJTable.getModel().getRowCount(); ++rx) {
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 12] = String.valueOf(((Double)ComputeMSD.msd1Values.get(rx)).toString());
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)ComputeMSD.msd2Values.get(rx)).toString());
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 10] = String.valueOf(((Double)ComputeMSD.msd3Values.get(rx)).toString());
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 9] = String.valueOf(((Double)ComputeMSD.msdValues.get(rx)).toString());
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 8] = String.valueOf(((Double)ComputeMSD.diffValues.get(rx)).toString());
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf(((Double)ComputeMSD.d14Values.get(rx)).toString());
<                                  if (Double.valueOf(trackJTable.getModel().getValueAt(rx, 3).toString()) >= Double.valueOf((double)SPTBatch_.thLengthJTF)) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Long");
<                                  } else {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Short");
<                                  }
< 
<                                  if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rx)).toString()) <= SPTBatch_.this.thD14JTF) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Immobile");
<                                  }
< 
<                                  if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rx)).toString()) > SPTBatch_.this.thD14JTF) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Mobile");
<                                  }
< 
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString());
<                                  if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) < 0.6D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) >= 0.0D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Confined");
<                                  }
< 
<                                  if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) < 0.9D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) >= 0.6D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Anomalous");
<                                  }
< 
<                                  if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) < 1.1D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) >= 0.9D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Free");
<                                  }
< 
<                                  if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) >= 1.1D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Directed");
<                                  }
< 
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 2] = String.valueOf(ComputeMSD.mssValues.get(rx));
<                                  if ((Double)ComputeMSD.mssValues.get(rx) == 1.0D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 1] = "Unidirectional Ballistic";
<                                  }
< 
<                                  if ((Double)ComputeMSD.mssValues.get(rx) == 0.0D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 1] = "Immobile";
<                                  }
< 
<                                  if ((Double)ComputeMSD.mssValues.get(rx) >= 0.45D && (Double)ComputeMSD.mssValues.get(rx) <= 0.55D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 1] = "Free";
<                                  }
< 
<                                  if ((Double)ComputeMSD.mssValues.get(rx) > 0.0D && (Double)ComputeMSD.mssValues.get(rx) < 0.45D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 1] = "Confined";
<                                  }
< 
<                                  if ((Double)ComputeMSD.mssValues.get(rx) > 0.55D && (Double)ComputeMSD.mssValues.get(rx) < 1.0D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 1] = "Directed";
<                                  }
<                               }
< 
<                               SPTBatch_.this.rtTrackPerImage = new ResultsTable();
< 
<                               for(rx = 0; rx < rowDataTrackx.length; ++rx) {
<                                  for(rxx = 0; rxx < rowDataTrackx[rx].length; ++rxx) {
<                                     var10001 = SPTBatch_.columnNamesTrack[rxx];
<                                     SPTBatch_.this.rtTrackPerImage.setValue(var10001, rx, rowDataTrackx[rx][rxx]);
<                                  }
<                               }
< 
<                               try {
<                                  SPTBatch_.this.rtTrackPerImage.saveAs(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Tracks statistics" + ".csv");
<                               } catch (IOException var18) {
<                                  var18.printStackTrace();
<                               }
< 
<                               SPTBatch_.this.rtTracks[SPTBatch_.i] = SPTBatch_.this.rtTrackPerImage;
<                            }
< 
<                            String[][] rowData = new String[4][SPTBatch_.this.columnsMovements.length];
<                            int totalTracks = false;
<                            r = 0;
<                            t = 0;
<                            rx = 0;
<                            rxx = 0;
<                            rxxx = 0;
<                            y = 0;
<                            int shortTracks = 0;
<                            j = 0;
<                            int shortAnom = 0;
<                            int shortFree = 0;
<                            int shortDirect = 0;
< 
<                            for(int rxxxx = 0; rxxxx < SPTBatch_.this.rtTrackPerImage.size(); ++rxxxx) {
<                               if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Long")) {
<                                     ++r;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Short")) {
<                                     ++shortTracks;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx).equals("Confined") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Long")) {
<                                     ++t;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx).equals("Confined") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Short")) {
<                                     ++j;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx).equals("Unidirectional Ballistic") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Long")) {
<                                     ++rx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx).equals("Anomalous") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Short")) {
<                                     ++shortAnom;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx).equals("Free") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Long")) {
<                                     ++rxx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx).equals("Free") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Short")) {
<                                     ++shortFree;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx).equals("Directed") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Long")) {
<                                     ++rxxx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx).equals("Directed") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Short")) {
<                                     ++shortDirect;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 4, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 4, rxxxx).equals("Immobile")) {
<                                     ++y;
<                                  }
<                               }
< 
<                               if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Long")) {
<                                     ++r;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Short")) {
<                                     ++shortTracks;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx).equals("Confined") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Long")) {
<                                     ++t;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx).equals("Confined") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Short")) {
<                                     ++j;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx).equals("Unidirectional Ballistic") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Long")) {
<                                     ++rx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx).equals("Anomalous") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Short")) {
<                                     ++shortAnom;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx).equals("Free") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Long")) {
<                                     ++rxx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx).equals("Free") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Short")) {
<                                     ++shortFree;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx).equals("Directed") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Long")) {
<                                     ++rxxx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx).equals("Directed") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Short")) {
<                                     ++shortDirect;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Immobile")) {
<                                     ++y;
<                                  }
<                               }
<                            }
< 
<                            SPTBatch_ var10000 = SPTBatch_.this;
<                            var10000.totalTracksDef = var10000.totalTracksDef + SPTBatch_.this.rtTrackPerImage.size();
<                            var10000 = SPTBatch_.this;
<                            var10000.longTracksDef = var10000.longTracksDef + r;
<                            var10000 = SPTBatch_.this;
<                            var10000.longConfinedDef = var10000.longConfinedDef + t;
<                            var10000 = SPTBatch_.this;
<                            var10000.longUniBalDef = var10000.longUniBalDef + rx;
<                            var10000 = SPTBatch_.this;
<                            var10000.longFreeDef = var10000.longFreeDef + rxx;
<                            var10000 = SPTBatch_.this;
<                            var10000.longDirectDef = var10000.longDirectDef + rxxx;
<                            var10000 = SPTBatch_.this;
<                            var10000.shortTracksDef = var10000.shortTracksDef + shortTracks;
<                            var10000 = SPTBatch_.this;
<                            var10000.shortConfinedDef = var10000.shortConfinedDef + j;
<                            var10000 = SPTBatch_.this;
<                            var10000.shortAnomDef = var10000.shortAnomDef + shortAnom;
<                            var10000 = SPTBatch_.this;
<                            var10000.shortFreeDef = var10000.shortFreeDef + shortFree;
<                            var10000 = SPTBatch_.this;
<                            var10000.shortDirectDef = var10000.shortDirectDef + shortDirect;
<                            var10000 = SPTBatch_.this;
<                            var10000.immobDef = var10000.immobDef + y;
<                            rowData[0][0] = String.valueOf(SPTBatch_.this.rtTrackPerImage.size());
<                            rowData[1][0] = String.valueOf("");
<                            rowData[2][0] = String.valueOf("");
<                            rowData[3][0] = String.valueOf("");
<                            rowData[0][1] = String.valueOf(r);
<                            rowData[1][1] = String.valueOf(" ");
<                            rowData[2][1] = String.valueOf("Short Tracks");
<                            rowData[3][1] = String.valueOf(shortTracks);
<                            rowData[0][2] = String.valueOf(t);
<                            rowData[1][2] = String.valueOf(" ");
<                            rowData[2][2] = String.valueOf("Short Confined");
<                            rowData[3][2] = String.valueOf(j);
<                            rowData[0][3] = String.valueOf(rx);
<                            rowData[1][3] = String.valueOf(" ");
<                            rowData[2][3] = String.valueOf("Short Anomalous");
<                            rowData[3][3] = String.valueOf(shortAnom);
<                            rowData[0][4] = String.valueOf(rxx);
<                            rowData[1][4] = String.valueOf(" ");
<                            rowData[2][4] = String.valueOf("Short Free");
<                            rowData[3][4] = String.valueOf(shortFree);
<                            rowData[0][5] = String.valueOf(rxxx);
<                            rowData[1][5] = String.valueOf(" ");
<                            rowData[2][5] = String.valueOf("Short Direct");
<                            rowData[3][5] = String.valueOf(shortDirect);
<                            rowData[0][6] = String.valueOf(y);
<                            rowData[1][6] = String.valueOf("");
<                            rowData[2][6] = String.valueOf("");
<                            rowData[3][6] = String.valueOf("");
<                            ResultsTable rtTrackSum = new ResultsTable();
< 
<                            for(int rxxxxx = 0; rxxxxx < rowData.length; ++rxxxxx) {
<                               for(int c = 0; c < rowData[rxxxxx].length; ++c) {
<                                  rtTrackSum.setValue(SPTBatch_.this.columnsMovements[c], rxxxxx, rowData[rxxxxx][c]);
<                               }
<                            }
< 
<                            try {
<                               rtTrackSum.saveAs(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "SummaryTracks" + ".csv");
<                            } catch (IOException var17) {
<                               var17.printStackTrace();
<                            }
< 
<                            if (SPTBatch_.checkPBS.isSelected()) {
<                               (new PhotobleachingSpotPlot()).Compute();
<                            }
< 
<                         }
<                      });
<                      tracksThread.start();
<                   }
< 
<                   if (SPTBatch_.this.enableBranchTable.equals("branchTable")) {
<                      branchTable = SPTBatch_.createBranchTable(SPTBatch_.model, SPTBatch_.selectionModel);
< 
<                      try {
<                         branchTable.exportToCsv(new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Branch analysis" + ".csv"));
<                      } catch (IOException var135) {
<                         var135.printStackTrace();
<                      }
<                   }
<                }
< 
<                ArrayList edges;
<                if (SPTBatch_.checkboxSP.isSelected() == Boolean.TRUE) {
<                   SPTBatch_.directChemo = new File(SPTBatch_.directImages.getAbsolutePath() + File.separator + "Chemotaxis_Analysis");
<                   if (!SPTBatch_.directChemo.exists()) {
<                      SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directChemo.getName());
<                      result = false;
< 
<                      try {
<                         SPTBatch_.directChemo.mkdir();
<                         result = true;
<                      } catch (SecurityException var134) {
<                      }
< 
<                      if (result) {
<                         SPTBatch_.taskOutput.append("DIR created");
<                      }
<                   }
< 
<                   TablePanel<Spot> spotTable = SPTBatch_.this.createSpotTable(SPTBatch_.model, SPTBatch_.this.ds);
<                   JTable spotJTable = spotTable.getTable();
<                   edges = new ArrayList();
<                   Set<Integer> trackIDs = SPTBatch_.model.getTrackModel().trackIDs(true);
<                   chartx = null;
<                   Iterator var242 = trackIDs.iterator();
< 
<                   while(true) {
<                      if (!var242.hasNext()) {
<                         Chemotaxis_ToolModified chemotool = new Chemotaxis_ToolModified(edges);
<                         chemotool.run("");
<                         break;
<                      }
< 
<                      Integer id = (Integer)var242.next();
<                      Set<Spot> track = SPTBatch_.model.getTrackModel().trackSpots(id);
<                      framesByTrack = new ArrayList();
<                      ArrayList<Float> xByTrack = new ArrayList();
<                      framesByTrackx = new ArrayList();
<                      framesByTrackSort = new ArrayList();
<                      new ArrayList();
<                      new ArrayList();
<                      ArrayList<Float> trackIDxxxx = new ArrayList();
<                      ArrayList<Integer> indexes = new ArrayList();
<                      Iterator var81 = track.iterator();
< 
<                      while(var81.hasNext()) {
<                         Spot spot = (Spot)var81.next();
<                         trackIDxxxx.add(Float.valueOf((float)id) + Float.valueOf("1.0"));
<                         framesByTrack.add(Float.valueOf(spot.getFeature("FRAME").toString()));
<                         xByTrack.add(Float.valueOf(spot.getFeature("POSITION_X").toString()));
<                         framesByTrackx.add(Float.valueOf(spot.getFeature("POSITION_Y").toString()));
<                         framesByTrackSort.add(Float.valueOf(spot.getFeature("FRAME").toString()));
<                      }
< 
<                      Collections.sort(framesByTrackSort);
< 
<                      int yx;
<                      for(yx = 0; yx < framesByTrackSort.size(); ++yx) {
<                         indexes.add(framesByTrack.indexOf(framesByTrackSort.get(yx)));
<                      }
< 
<                      for(yx = 0; yx < indexes.size(); ++yx) {
<                         edges.add((Float)trackIDxxxx.get(yx));
<                         edges.add((Float)framesByTrackSort.get(yx) + Float.valueOf("1.0"));
<                         edges.add((Float)xByTrack.get((Integer)indexes.get(yx)));
<                         edges.add((Float)framesByTrackx.get((Integer)indexes.get(yx)));
<                      }
<                   }
<                }
< 
<                if (SPTBatch_.checkboxDiff.isSelected() == Boolean.TRUE) {
<                   SPTBatch_.directDiff = new File(SPTBatch_.directImages.getAbsolutePath() + File.separator + "Trajectory_Classifier");
<                   if (!SPTBatch_.directDiff.exists()) {
<                      SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directDiff.getName());
<                      result = false;
< 
<                      try {
<                         SPTBatch_.directDiff.mkdir();
<                         result = true;
<                      } catch (SecurityException var133) {
<                      }
< 
<                      if (result) {
<                         SPTBatch_.taskOutput.append("DIR created");
<                      }
<                   }
< 
<                   TraJClassifierTest_ tc = new TraJClassifierTest_();
<                   tc.run("");
<                }
< 
<                if (SPTBatch_.checkboxMSD.isSelected() == Boolean.TRUE) {
<                   TrackProcessorMSD_Modified msdPlot = new TrackProcessorMSD_Modified();
<                   msdPlot.Compute(SPTBatch_.nOfTracks, SPTBatch_.this.rtSpots[SPTBatch_.i]);
<                }
< 
<                if (SPTBatch_.checkCluster.isSelected() == Boolean.TRUE) {
<                   ClusterSizeAnalysis clusterAnal = new ClusterSizeAnalysis();
<                   DefaultCategoryDataset barDatasetCount = new DefaultCategoryDataset();
<                   DefaultCategoryDataset barDatasetPercet = new DefaultCategoryDataset();
<                   counter1 = 0;
<                   int counter2 = 0;
<                   maxFrame = 0;
<                   counter4 = 0;
<                   counter = 0;
<                   n = 0;
<                   framex = 0;
<                   jxxxx = 0;
<                   y = 0;
<                   counter10 = 0;
<                   int r = 0;
< 
<                   while(true) {
<                      if (r >= SPTBatch_.nOfTracks.size()) {
<                         barDatasetCount.setValue((double)counter1, "receptors/particle", "1");
<                         barDatasetCount.setValue((double)counter2, "receptors/particle", "2");
<                         barDatasetCount.setValue((double)maxFrame, "receptors/particle", "3");
<                         barDatasetCount.setValue((double)counter4, "receptors/particle", "4");
<                         barDatasetCount.setValue((double)counter, "receptors/particle", "5");
<                         barDatasetCount.setValue((double)n, "receptors/particle", "6");
<                         barDatasetCount.setValue((double)framex, "receptors/particle", "7");
<                         barDatasetCount.setValue((double)jxxxx, "receptors/particle", "8");
<                         barDatasetCount.setValue((double)y, "receptors/particle", "9");
<                         barDatasetCount.setValue((double)counter10, "receptors/particle", "10");
<                         JFreeChart chartCount = ChartFactory.createBarChart("Count of receptors/particle", "receptors/particle", "Count", barDatasetCount, PlotOrientation.VERTICAL, false, true, false);
<                         if (SPTBatch_.nOfTracks.size() != 0) {
<                            barDatasetPercet.setValue((double)(counter1 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "1");
<                            barDatasetPercet.setValue((double)(counter2 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "2");
<                            barDatasetPercet.setValue((double)(maxFrame * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "3");
<                            barDatasetPercet.setValue((double)(counter4 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "4");
<                            barDatasetPercet.setValue((double)(counter * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "5");
<                            barDatasetPercet.setValue((double)(n * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "6");
<                            barDatasetPercet.setValue((double)(framex * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "7");
<                            barDatasetPercet.setValue((double)(jxxxx * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "8");
<                            barDatasetPercet.setValue((double)(y * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "9");
<                            barDatasetPercet.setValue((double)(counter10 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "10");
<                         }
< 
<                         if (SPTBatch_.nOfTracks.size() != 0) {
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "1");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "2");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "3");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "4");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "5");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "6");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "7");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "8");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "9");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "10");
<                         }
< 
<                         JFreeChart chartPercet = ChartFactory.createBarChart("Percentage of receptors/particle", "receptors/particle", "Percentage-(%)", barDatasetPercet, PlotOrientation.VERTICAL, false, true, false);
<                         DecimalFormat pctFormat = new DecimalFormat("##.00%");
<                         pctFormat.setMultiplier(1);
<                         NumberFormat percent = NumberFormat.getPercentInstance();
<                         percent.setMaximumFractionDigits(2);
<                         CategoryItemLabelGenerator generatorCount = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getInstance(), percent);
<                         CategoryItemLabelGenerator generatorPercent = new StandardCategoryItemLabelGenerator("{2}", pctFormat);
<                         CategoryPlot plotCount = chartCount.getCategoryPlot();
<                         CategoryPlot plotPercent = chartPercet.getCategoryPlot();
<                         CategoryItemRenderer rendererCount = plotCount.getRenderer();
<                         CategoryItemRenderer rendererPercent = plotPercent.getRenderer();
<                         NumberAxis rangeAxisCount = (NumberAxis)plotCount.getRangeAxis();
<                         NumberAxis rangeAxisPercent = (NumberAxis)plotPercent.getRangeAxis();
<                         rangeAxisPercent.setNumberFormatOverride(pctFormat);
<                         rangeAxisCount.setAutoRangeIncludesZero(true);
<                         rangeAxisPercent.setAutoRangeIncludesZero(true);
<                         rendererCount.setDefaultItemLabelGenerator(generatorCount);
<                         rendererCount.setDefaultItemLabelFont(new Font("SansSerif", 0, 12));
<                         rendererCount.setDefaultItemLabelsVisible(true);
<                         rendererPercent.setDefaultItemLabelGenerator(generatorPercent);
<                         rendererPercent.setDefaultItemLabelFont(new Font("SansSerif", 0, 12));
<                         rendererPercent.setDefaultItemLabelsVisible(true);
< 
<                         try {
<                            ChartUtils.saveChartAsPNG(new File(SPTBatch_.directCluster.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_ReceptorsPerParticle_Count" + ".png"), chartCount, 500, 400);
<                         } catch (IOException var132) {
<                            var132.printStackTrace();
<                         }
< 
<                         try {
<                            ChartUtils.saveChartAsPNG(new File(SPTBatch_.directCluster.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_ReceptorsPerParticle_Percentage" + ".png"), chartPercet, 500, 400);
<                         } catch (IOException var131) {
<                            var131.printStackTrace();
<                         }
<                         break;
<                      }
< 
<                      int counterx = false;
<                      List<Double> perTrack = new ArrayList();
< 
<                      for(int t = 0; t < SPTBatch_.tableSpot.getRowCount(); ++t) {
<                         if (Integer.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t, 2).toString()).equals(SPTBatch_.nOfTracks.get(r)) == Boolean.TRUE) {
<                            perTrack.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t, SPTBatch_.tableSpot.getColumnCount() - 1).toString()));
<                         }
<                      }
< 
<                      clusterAnal.Compute(perTrack, (Integer)SPTBatch_.nOfTracks.get(r));
<                      double[] values = new double[perTrack.size()];
< 
<                      for(int jxxx = 0; jxxx < perTrack.size(); ++jxxx) {
<                         values[jxxx] = (Double)perTrack.get(jxxx);
<                      }
< 
<                      GaussianMixtureModified gm2 = GaussianMixtureModified.fit(values);
<                      if (gm2.components.length == 1) {
<                         ++counter1;
<                      }
< 
<                      if (gm2.components.length == 2) {
<                         ++counter2;
<                      }
< 
<                      if (gm2.components.length == 3) {
<                         ++maxFrame;
<                      }
< 
<                      if (gm2.components.length == 4) {
<                         ++counter4;
<                      }
< 
<                      if (gm2.components.length == 5) {
<                         ++counter;
<                      }
< 
<                      if (gm2.components.length == 6) {
<                         ++n;
<                      }
< 
<                      if (gm2.components.length == 7) {
<                         ++framex;
<                      }
< 
<                      if (gm2.components.length == 8) {
<                         ++jxxxx;
<                      }
< 
<                      if (gm2.components.length == 9) {
<                         ++y;
<                      }
< 
<                      if (gm2.components.length == 10) {
<                         ++counter10;
<                      }
< 
<                      ++r;
<                   }
<                }
< 
<                if (SPTBatch_.checkboxPlot.isSelected() == Boolean.TRUE) {
<                   List<Spot> spots1 = new ArrayList(SPTBatch_.this.trackmate.getModel().getSpots().getNSpots(true));
<                   Set<String> ySelectedSpotSet = new HashSet();
<                   ySelectedSpotSet.add(SPTBatch_.this.ySelectedSpot);
<                   Iterator var223 = SPTBatch_.this.trackmate.getModel().getTrackModel().trackIDs(true).iterator();
< 
<                   while(var223.hasNext()) {
<                      Integer trackIDx = (Integer)var223.next();
<                      spots1.addAll(SPTBatch_.this.trackmate.getModel().getTrackModel().trackSpots(trackIDx));
<                   }
< 
<                   String yAxisLabelx;
<                   if (SPTBatch_.ESP.isSelected() && SPTBatch_.this.xSelectedSpot != null && ySelectedSpotSet != null) {
<                      chart = null;
<                      XYPlot plot = null;
<                      Dimension xDimension = (Dimension)SPTBatch_.model.getFeatureModel().getSpotFeatureDimensions().get(SPTBatch_.this.xSelectedSpot);
<                      Map<String, Dimension> yDimensions = SPTBatch_.model.getFeatureModel().getSpotFeatureDimensions();
<                      Map<String, String> featureNames = SPTBatch_.model.getFeatureModel().getSpotFeatureNames();
<                      xAxisLabelx = (String)featureNames.get(SPTBatch_.this.xSelectedSpot) + " (" + TMUtils.getUnitsFor(xDimension, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits()) + ")";
<                      Set<Dimension> dimensions = SPTBatch_.this.getUniqueValues(ySelectedSpotSet, yDimensions);
<                      new ArrayList(dimensions.size());
<                      Iterator var288 = dimensions.iterator();
< 
<                      while(var288.hasNext()) {
<                         Dimension dimensionxx = (Dimension)var288.next();
<                         String yAxisLabel = TMUtils.getUnitsFor(dimensionxx, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits());
<                         List<String> featuresThisDimension = SPTBatch_.getCommonKeys(dimensionxx, ySelectedSpotSet, yDimensions);
<                         yAxisLabelx = SPTBatch_.this.buildPlotTitle(featuresThisDimension, featureNames, SPTBatch_.this.xSelectedSpot);
<                         ModelDataset datasetxx = new SpotCollectionDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, SPTBatch_.this.xSelectedSpot, featuresThisDimension, spots1, true);
<                         XYItemRenderer renderer = datasetxx.getRenderer();
<                         JFreeChart chartxx = ChartFactory.createXYLineChart(yAxisLabelx, xAxisLabelx, yAxisLabel, datasetxx, PlotOrientation.VERTICAL, true, true, false);
<                         chartxx.getTitle().setFont(Fonts.FONT);
<                         chartxx.getLegend().setItemFont(Fonts.SMALL_FONT);
<                         chartxx.setBackgroundPaint(new Color(220, 220, 220));
<                         chartxx.setBorderVisible(false);
<                         chartxx.getLegend().setBackgroundPaint(new Color(220, 220, 220));
<                         plot = chartxx.getXYPlot();
<                         plot.setRenderer(renderer);
<                         plot.getRangeAxis().setLabelFont(Fonts.FONT);
<                         plot.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plot.getDomainAxis().setLabelFont(Fonts.FONT);
<                         plot.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plot.setOutlineVisible(false);
<                         plot.setDomainCrosshairVisible(false);
<                         plot.setDomainGridlinesVisible(false);
<                         plot.setRangeCrosshairVisible(false);
<                         plot.setRangeGridlinesVisible(false);
<                         plot.setBackgroundAlpha(0.0F);
<                         ((NumberAxis)plot.getRangeAxis()).setAutoRangeIncludesZero(false);
<                         plot.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
<                         plot.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
<                      }
< 
<                      try {
<                         ChartUtils.saveChartAsPNG(new File(SPTBatch_.directSPT + File.separator + SPTBatch_.imps.getShortTitle() + "_" + SPTBatch_.this.xSelectedSpot + "-" + SPTBatch_.this.ySelectedSpot + ".png"), plot.getChart(), 500, 270);
<                      } catch (IOException var130) {
<                         var130.printStackTrace();
<                      }
<                   }
< 
<                   edges = new ArrayList();
<                   Set<String> ySelectedLinkSet = new HashSet();
<                   ySelectedLinkSet.add(SPTBatch_.this.ySelectedLink);
<                   Iterator var248 = SPTBatch_.this.trackmate.getModel().getTrackModel().trackIDs(true).iterator();
< 
<                   while(var248.hasNext()) {
<                      Integer trackIDxx = (Integer)var248.next();
<                      edges.addAll(SPTBatch_.this.trackmate.getModel().getTrackModel().trackEdges(trackIDxx));
<                   }
< 
<                   Map yDimensionsxx;
<                   if (SPTBatch_.ELP.isSelected() && SPTBatch_.this.xSelectedLink != null && ySelectedLinkSet != null) {
<                      chartx = null;
<                      XYPlot plotx = null;
<                      Dimension xDimensionx = (Dimension)SPTBatch_.model.getFeatureModel().getEdgeFeatureDimensions().get(SPTBatch_.this.xSelectedLink);
<                      Map<String, Dimension> yDimensionsx = SPTBatch_.model.getFeatureModel().getEdgeFeatureDimensions();
<                      yDimensionsxx = SPTBatch_.model.getFeatureModel().getEdgeFeatureNames();
<                      String xAxisLabelxx = (String)yDimensionsxx.get(SPTBatch_.this.xSelectedLink) + " (" + TMUtils.getUnitsFor(xDimensionx, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits()) + ")";
<                      Set<Dimension> dimensionsxxx = SPTBatch_.this.getUniqueValues(ySelectedLinkSet, yDimensionsx);
<                      new ArrayList(dimensionsxxx.size());
<                      Iterator var290 = dimensionsxxx.iterator();
< 
<                      while(var290.hasNext()) {
<                         Dimension dimension = (Dimension)var290.next();
<                         yAxisLabelx = TMUtils.getUnitsFor(dimension, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits());
<                         List<String> featuresThisDimensionx = SPTBatch_.getCommonKeys(dimension, ySelectedLinkSet, yDimensionsx);
<                         String titlex = SPTBatch_.this.buildPlotTitle(featuresThisDimensionx, yDimensionsxx, SPTBatch_.this.xSelectedLink);
<                         ModelDataset datasetxxx = new EdgeCollectionDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, SPTBatch_.this.xSelectedLink, featuresThisDimensionx, edges, true);
<                         XYItemRenderer rendererx = datasetxxx.getRenderer();
<                         JFreeChart chartxxxx = ChartFactory.createXYLineChart(titlex, xAxisLabelxx, yAxisLabelx, datasetxxx, PlotOrientation.VERTICAL, true, true, false);
<                         chartxxxx.getTitle().setFont(Fonts.FONT);
<                         chartxxxx.getLegend().setItemFont(Fonts.SMALL_FONT);
<                         chartxxxx.setBackgroundPaint(new Color(220, 220, 220));
<                         chartxxxx.setBorderVisible(false);
<                         chartxxxx.getLegend().setBackgroundPaint(new Color(220, 220, 220));
<                         plotx = chartxxxx.getXYPlot();
<                         plotx.setRenderer(rendererx);
<                         plotx.getRangeAxis().setLabelFont(Fonts.FONT);
<                         plotx.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plotx.getDomainAxis().setLabelFont(Fonts.FONT);
<                         plotx.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plotx.setOutlineVisible(false);
<                         plotx.setDomainCrosshairVisible(false);
<                         plotx.setDomainGridlinesVisible(false);
<                         plotx.setRangeCrosshairVisible(false);
<                         plotx.setRangeGridlinesVisible(false);
<                         plotx.setBackgroundAlpha(0.0F);
<                         ((NumberAxis)plotx.getRangeAxis()).setAutoRangeIncludesZero(false);
<                         plotx.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
<                         plotx.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
<                      }
< 
<                      try {
<                         ChartUtils.saveChartAsPNG(new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + SPTBatch_.this.xSelectedLink + "-" + SPTBatch_.this.ySelectedLink + ".png"), plotx.getChart(), 500, 270);
<                      } catch (IOException var129) {
<                         var129.printStackTrace();
<                      }
<                   }
< 
<                   Set<String> ySelectedTrackSet = new HashSet();
<                   ySelectedTrackSet.add(SPTBatch_.this.ySelectedTrack);
<                   String yFeature;
<                   if (SPTBatch_.ETP.isSelected() && SPTBatch_.this.xSelectedTrack != null && ySelectedTrackSet != null) {
<                      SPTBatch_.this.tracksID = new ArrayList(SPTBatch_.this.trackmate.getModel().getTrackModel().unsortedTrackIDs(true));
<                      chartxxx = null;
<                      XYPlot plotxx = null;
<                      Dimension xDimensionxx = (Dimension)SPTBatch_.model.getFeatureModel().getTrackFeatureDimensions().get(SPTBatch_.this.xSelectedTrack);
<                      yDimensionsxx = SPTBatch_.model.getFeatureModel().getTrackFeatureDimensions();
<                      Map<String, String> featureNamesx = SPTBatch_.model.getFeatureModel().getTrackFeatureNames();
<                      yFeature = (String)featureNamesx.get(SPTBatch_.this.xSelectedTrack) + " (" + TMUtils.getUnitsFor(xDimensionxx, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits()) + ")";
<                      Set<Dimension> dimensionsx = SPTBatch_.this.getUniqueValues(ySelectedTrackSet, yDimensionsxx);
<                      new ArrayList(dimensionsx.size());
<                      Iterator var295 = dimensionsx.iterator();
< 
<                      while(var295.hasNext()) {
<                         Dimension dimensionx = (Dimension)var295.next();
<                         String yAxisLabelxx = TMUtils.getUnitsFor(dimensionx, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits());
<                         List<String> featuresThisDimensionxx = SPTBatch_.getCommonKeys(dimensionx, ySelectedTrackSet, yDimensionsxx);
<                         String titlexx = SPTBatch_.this.buildPlotTitle(featuresThisDimensionxx, featureNamesx, SPTBatch_.this.xSelectedTrack);
<                         ModelDataset datasetxxxx = new TrackCollectionDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, SPTBatch_.this.xSelectedTrack, featuresThisDimensionxx, SPTBatch_.this.tracksID);
<                         XYItemRenderer rendererxx = datasetxxxx.getRenderer();
<                         JFreeChart chartxxxxx = ChartFactory.createXYLineChart(titlexx, yFeature, yAxisLabelxx, datasetxxxx, PlotOrientation.VERTICAL, true, true, false);
<                         chartxxxxx.getTitle().setFont(Fonts.FONT);
<                         chartxxxxx.getLegend().setItemFont(Fonts.SMALL_FONT);
<                         chartxxxxx.setBackgroundPaint(new Color(220, 220, 220));
<                         chartxxxxx.setBorderVisible(false);
<                         chartxxxxx.getLegend().setBackgroundPaint(new Color(220, 220, 220));
<                         plotxx = chartxxxxx.getXYPlot();
<                         plotxx.setRenderer(rendererxx);
<                         plotxx.getRangeAxis().setLabelFont(Fonts.FONT);
<                         plotxx.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plotxx.getDomainAxis().setLabelFont(Fonts.FONT);
<                         plotxx.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plotxx.setOutlineVisible(false);
<                         plotxx.setDomainCrosshairVisible(false);
<                         plotxx.setDomainGridlinesVisible(false);
<                         plotxx.setRangeCrosshairVisible(false);
<                         plotxx.setRangeGridlinesVisible(false);
<                         plotxx.setBackgroundAlpha(0.0F);
<                         ((NumberAxis)plotxx.getRangeAxis()).setAutoRangeIncludesZero(false);
<                         plotxx.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
<                         plotxx.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
<                      }
< 
<                      try {
<                         ChartUtils.saveChartAsPNG(new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + SPTBatch_.this.xSelectedTrack + "-" + SPTBatch_.this.ySelectedTrack + ".png"), plotxx.getChart(), 500, 270);
<                      } catch (IOException var128) {
<                         var128.printStackTrace();
<                      }
<                   }
< 
<                   maxFrame = spots.keySet().stream().mapToInt(Integer::intValue).max().getAsInt();
<                   int[] nSpots = new int[maxFrame + 1];
<                   double[] time = new double[maxFrame + 1];
<                   XYPlot plotxxx = null;
< 
<                   for(framex = 0; framex <= maxFrame; ++framex) {
<                      nSpots[framex] = spots.getNSpots(framex, true);
<                      time[framex] = (double)framex * SPTBatch_.this.settings.dt;
<                   }
< 
<                   SPTBatch_.NSpotPerFrameDataset datasetx = new SPTBatch_.NSpotPerFrameDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, time, nSpots);
<                   yFeature = "N spots";
<                   Map<String, Dimension> dimMap = new HashMap(2);
<                   dimMap.put("N spots", Dimension.NONE);
<                   dimMap.put("POSITION_T", Dimension.TIME);
<                   Map<String, String> nameMap = new HashMap(2);
<                   nameMap.put("N spots", "N spots");
<                   nameMap.put("POSITION_T", "T");
<                   String xAxisLabelxxx = (String)nameMap.get("POSITION_T") + " (" + TMUtils.getUnitsFor(Dimension.TIME, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits()) + ")";
<                   Set<Dimension> dimensionsxx = SPTBatch_.this.getUniqueValues(Collections.singletonList("N spots"), dimMap);
<                   new ArrayList(dimensionsxx.size());
<                   Iterator var322 = dimensionsxx.iterator();
< 
<                   while(var322.hasNext()) {
<                      Dimension dimensionxxx = (Dimension)var322.next();
<                      String yAxisLabelxxx = TMUtils.getUnitsFor(dimensionxxx, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits());
<                      List<String> featuresThisDimensionxxx = SPTBatch_.getCommonKeys(dimensionxxx, Collections.singletonList("N spots"), dimMap);
<                      String titlexxx = SPTBatch_.this.buildPlotTitle(featuresThisDimensionxxx, nameMap, "POSITION_T");
<                      XYItemRenderer rendererxxx = datasetx.getRenderer();
<                      JFreeChart chartxxxxxx = ChartFactory.createXYLineChart(titlexxx, xAxisLabelxxx, yAxisLabelxxx, datasetx, PlotOrientation.VERTICAL, true, true, false);
<                      chartxxxxxx.getTitle().setFont(Fonts.FONT);
<                      chartxxxxxx.getLegend().setItemFont(Fonts.SMALL_FONT);
<                      chartxxxxxx.setBackgroundPaint(new Color(220, 220, 220));
<                      chartxxxxxx.setBorderVisible(false);
<                      chartxxxxxx.getLegend().setBackgroundPaint(new Color(220, 220, 220));
<                      plotxxx = chartxxxxxx.getXYPlot();
<                      plotxxx.setRenderer(rendererxxx);
<                      plotxxx.getRangeAxis().setLabelFont(Fonts.FONT);
<                      plotxxx.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                      plotxxx.getDomainAxis().setLabelFont(Fonts.FONT);
<                      plotxxx.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                      plotxxx.setOutlineVisible(false);
<                      plotxxx.setDomainCrosshairVisible(false);
<                      plotxxx.setDomainGridlinesVisible(false);
<                      plotxxx.setRangeCrosshairVisible(false);
<                      plotxxx.setRangeGridlinesVisible(false);
<                      plotxxx.setBackgroundAlpha(0.0F);
<                      ((NumberAxis)plotxxx.getRangeAxis()).setAutoRangeIncludesZero(false);
<                      plotxxx.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
<                      plotxxx.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
<                   }
< 
<                   try {
<                      ChartUtils.saveChartAsPNG(new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Nspotsvs.Time" + ".png"), plotxxx.getChart(), 500, 270);
<                   } catch (IOException var127) {
<                      var127.printStackTrace();
<                   }
<                }
< 
<                if (SPTBatch_.checkbox4.isSelected() == Boolean.TRUE) {
<                   if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                      IJ.saveAs(SPTBatch_.this.capture, "Tiff", SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]);
<                   }
< 
<                   if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                      for(frame = 0; frame < SPTBatch_.this.excludeTrack.size(); ++frame) {
<                         int trackID = Integer.parseInt(SPTBatch_.trackJTable.getValueAt(frame, 2).toString());
<                         SPTBatch_.this.trackmate.getModel().beginUpdate();
< 
<                         try {
<                            SPTBatch_.this.trackmate.getModel().setTrackVisibility(trackID, (Boolean)SPTBatch_.this.excludeTrack.get(frame));
<                         } finally {
<                            SPTBatch_.this.trackmate.getModel().endUpdate();
<                         }
< 
<                         SPTBatch_.this.displayer.render();
<                         SPTBatch_.this.displayer.refresh();
<                      }
< 
<                      if (SPTBatch_.imps.getNFrames() > 1) {
<                         firstFrame = Math.max(1, Math.min(SPTBatch_.imps.getNFrames(), 1));
<                         lastFrame = Math.min(SPTBatch_.imps.getNFrames(), Math.max(SPTBatch_.imps.getNFrames(), 1));
<                      }
< 
<                      if (SPTBatch_.imps.getNSlices() > 1) {
<                         firstFrame = Math.max(1, Math.min(SPTBatch_.imps.getNSlices(), 1));
<                         lastFrame = Math.min(SPTBatch_.imps.getNSlices(), Math.max(SPTBatch_.imps.getNSlices(), 1));
<                      }
< 
<                      SPTBatch_.taskOutput.append("Capturing TrackMate overlay from frame " + firstFrame + " to " + lastFrame + ".\n");
<                      bounds = SPTBatch_.this.displayer.getImp().getCanvas().getBounds();
<                      width = bounds.width;
<                      height = bounds.height;
<                      nCaptures = lastFrame - firstFrame + 1;
<                      stack = new ImageStack(width, height);
<                      channel = SPTBatch_.this.displayer.getImp().getChannel();
<                      slice = SPTBatch_.this.displayer.getImp().getSlice();
<                      SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(true);
< 
<                      for(frame = firstFrame; frame <= lastFrame; ++frame) {
<                         SPTBatch_.this.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
<                         bi = new BufferedImage(width, height, 2);
<                         SPTBatch_.this.displayer.getImp().getCanvas().paint(bi.getGraphics());
<                         cp = new ColorProcessor(bi);
<                         index = SPTBatch_.this.displayer.getImp().getStackIndex(channel, slice, frame);
<                         stack.addSlice(SPTBatch_.this.displayer.getImp().getImageStack().getSliceLabel(index), cp);
<                      }
< 
<                      SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(false);
<                      SPTBatch_.this.capture = new ImagePlus("TrackMate capture of " + SPTBatch_.this.displayer.getImp().getShortTitle(), stack);
<                      SPTBatch_.transferCalibration(SPTBatch_.this.displayer.getImp(), SPTBatch_.this.capture);
<                      IJ.saveAs(SPTBatch_.this.capture, "Tiff", SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]);
<                   }
<                }
< 
<                if (SPTBatch_.checkbox3.isSelected() == Boolean.TRUE) {
<                   try {
<                      FileWriter writer = new FileWriter(SPTBatch_.directSPT.getAbsolutePath() + File.separator + "Log" + "_" + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", "") + ".txt");
<                      SPTBatch_.taskOutput.write(writer);
<                      writer.close();
<                   } catch (IOException var125) {
<                   }
<                }
< 
<                SPTBatch_.imps.hide();
<             }
< 
<             Thread trackSummaryCols;
<             if (SPTBatch_.this.enableTrackTable.equals("trackTable")) {
<                trackSummaryCols = new Thread(new Runnable() {
<                   public void run() {
<                      String[][] rowDataDef = new String[4][SPTBatch_.this.columnsMovements.length];
<                      rowDataDef[0][0] = String.valueOf(SPTBatch_.this.totalTracksDef);
<                      rowDataDef[1][0] = String.valueOf("");
<                      rowDataDef[2][0] = String.valueOf("");
<                      rowDataDef[3][0] = String.valueOf("");
<                      rowDataDef[0][1] = String.valueOf(SPTBatch_.this.longTracksDef);
<                      rowDataDef[1][1] = String.valueOf(" ");
<                      rowDataDef[2][1] = String.valueOf("Short Tracks");
<                      rowDataDef[3][1] = String.valueOf(SPTBatch_.this.shortTracksDef);
<                      rowDataDef[0][2] = String.valueOf(SPTBatch_.this.longConfinedDef);
<                      rowDataDef[1][2] = String.valueOf(" ");
<                      rowDataDef[2][2] = String.valueOf("Short Confined");
<                      rowDataDef[3][2] = String.valueOf(SPTBatch_.this.shortConfinedDef);
<                      rowDataDef[0][3] = String.valueOf(SPTBatch_.this.longUniBalDef);
<                      rowDataDef[1][3] = String.valueOf(" ");
<                      rowDataDef[2][3] = String.valueOf("Short Anomalous");
<                      rowDataDef[3][3] = String.valueOf(SPTBatch_.this.shortAnomDef);
<                      rowDataDef[0][4] = String.valueOf(SPTBatch_.this.longFreeDef);
<                      rowDataDef[1][4] = String.valueOf(" ");
<                      rowDataDef[2][4] = String.valueOf("Short Free");
<                      rowDataDef[3][4] = String.valueOf(SPTBatch_.this.shortFreeDef);
<                      rowDataDef[0][5] = String.valueOf(SPTBatch_.this.longDirectDef);
<                      rowDataDef[1][5] = String.valueOf(" ");
<                      rowDataDef[2][5] = String.valueOf("Short Direct");
<                      rowDataDef[3][5] = String.valueOf(SPTBatch_.this.shortDirectDef);
<                      rowDataDef[0][6] = String.valueOf(SPTBatch_.this.immobDef);
<                      rowDataDef[1][6] = String.valueOf("");
<                      rowDataDef[2][6] = String.valueOf("");
<                      rowDataDef[3][6] = String.valueOf("");
<                      ResultsTable rtTrackSummary = new ResultsTable();
< 
<                      for(int r = 0; r < rowDataDef.length; ++r) {
<                         for(int c = 0; c < rowDataDef[r].length; ++c) {
<                            rtTrackSummary.setValue(SPTBatch_.this.columnsMovements[c], r, rowDataDef[r][c]);
<                         }
<                      }
< 
<                      try {
<                         rtTrackSummary.saveAs(SPTBatch_.directSummary.getAbsolutePath() + File.separator + "SummaryTracks_Condition" + ".csv");
<                      } catch (IOException var5) {
<                         var5.printStackTrace();
<                      }
< 
<                   }
<                });
<                trackSummaryCols.start();
<             }
< 
<             if (SPTBatch_.checkSummary.isSelected()) {
<                trackSummaryCols = new Thread(new Runnable() {
<                   public void run() {
<                      for(int x = 0; x < SPTBatch_.this.selectedItems.size(); ++x) {
<                         ResultsTable rtTrackSum;
<                         int y;
<                         int z;
<                         if (summaryColsWindow.combo.getSelectedIndex() == 0) {
<                            rtTrackSum = new ResultsTable();
<                            y = 0;
< 
<                            while(true) {
<                               if (y >= SPTBatch_.this.rtSpots.length) {
<                                  try {
<                                     rtTrackSum.saveAs(SPTBatch_.directSummary.getAbsolutePath() + File.separator + (String)SPTBatch_.this.selectedItems.get(x) + "_" + "SummaryCols_Spots" + ".csv");
<                                  } catch (IOException var5) {
<                                     var5.printStackTrace();
<                                  }
<                                  break;
<                               }
< 
<                               for(z = 0; z < SPTBatch_.this.rtSpots[y].size(); ++z) {
<                                  rtTrackSum.setValue(listOfFiles[y].getName(), z, SPTBatch_.this.rtSpots[y].getStringValue(Arrays.asList(summaryColsWindow.columnNamesSpot).indexOf(SPTBatch_.this.selectedItems.get(x)), z));
<                               }
< 
<                               ++y;
<                            }
<                         }
< 
<                         if (summaryColsWindow.combo.getSelectedIndex() == 1) {
<                            rtTrackSum = new ResultsTable();
<                            y = 0;
< 
<                            while(true) {
<                               if (y >= SPTBatch_.this.rtLinks.length) {
<                                  try {
<                                     rtTrackSum.saveAs(SPTBatch_.directSummary.getAbsolutePath() + File.separator + (String)SPTBatch_.this.selectedItems.get(x) + "_" + "SummaryCols_Links" + ".csv");
<                                  } catch (IOException var7) {
<                                     var7.printStackTrace();
<                                  }
<                                  break;
<                               }
< 
<                               for(z = 0; z < SPTBatch_.this.rtLinks[y].size(); ++z) {
<                                  rtTrackSum.setValue(listOfFiles[y].getName(), z, SPTBatch_.this.rtLinks[y].getStringValue(Arrays.asList(summaryColsWindow.columnNamesLinks).indexOf(SPTBatch_.this.selectedItems.get(x)), z));
<                               }
< 
<                               ++y;
<                            }
<                         }
< 
<                         if (summaryColsWindow.combo.getSelectedIndex() == 2) {
<                            rtTrackSum = new ResultsTable();
< 
<                            for(y = 0; y < SPTBatch_.this.rtTracks.length; ++y) {
<                               for(z = 0; z < SPTBatch_.this.rtTracks[y].size(); ++z) {
<                                  rtTrackSum.setValue(listOfFiles[y].getName(), z, SPTBatch_.this.rtTracks[y].getStringValue(Arrays.asList(summaryColsWindow.columnNamesTracks).indexOf(SPTBatch_.this.selectedItems.get(x)), z));
<                               }
<                            }
< 
<                            try {
<                               rtTrackSum.saveAs(SPTBatch_.directSummary.getAbsolutePath() + File.separator + (String)SPTBatch_.this.selectedItems.get(x) + "_" + "SummaryCols_Tracks" + ".csv");
<                            } catch (IOException var6) {
<                               var6.printStackTrace();
<                            }
<                         }
<                      }
< 
<                   }
<                });
<                trackSummaryCols.start();
<             }
< 
<             SPTBatch_.this.enableSpotTable.equals("spotTable");
<             SPTBatch_.this.enableLinkTable.equals("linkTable");
<             SPTBatch_.this.enableTrackTable.equals("trackTable");
<             SPTBatch_.taskOutput.append("              FINISHED!!!");
<             frameAnalyzer.setVisible(false);
<          }
<       });
<       this.finishButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent event) {
<             if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE) {
<                SPTBatch_.minTracksJTF = Integer.valueOf(SPTBatch_.minTracks.getText());
<                SPTBatch_.maxTracksJTF = Integer.valueOf(SPTBatch_.maxTracks.getText());
<                SPTBatch_.thLengthJTF = Integer.valueOf(SPTBatch_.thLength.getText());
<                if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "DIff") {
<                   SPTBatch_.this.thD14JTF = Double.valueOf(SPTBatch_.thD14.getText());
<                }
<             }
< 
<             SPTBatch_.mainProcess.start();
<          }
<       });
<    }
< 
<    private static final void transferCalibration(ImagePlus from, ImagePlus to) {
<       Calibration fc = from.getCalibration();
<       Calibration tc = to.getCalibration();
<       tc.setUnit(fc.getUnit());
<       tc.setTimeUnit(fc.getTimeUnit());
<       tc.frameInterval = fc.frameInterval;
<       double mag = from.getCanvas().getMagnification();
<       tc.pixelWidth = fc.pixelWidth / mag;
<       tc.pixelHeight = fc.pixelHeight / mag;
<       tc.pixelDepth = fc.pixelDepth;
<    }
< 
<    protected ImageIcon createImageIcon(String path) {
<       URL imgURL = this.getClass().getResource(path);
<       if (imgURL != null) {
<          return new ImageIcon(imgURL);
<       } else {
<          System.err.println("Couldn't find file: " + path);
<          return null;
<       }
<    }
< 
<    private Image getScaledImage(Image srcImg, int w, int h) {
<       BufferedImage resizedImg = new BufferedImage(w, h, 1);
<       Graphics2D g2 = resizedImg.createGraphics();
<       g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
<       g2.drawImage(srcImg, 0, 0, w, h, (ImageObserver)null);
<       g2.dispose();
<       return resizedImg;
<    }
< 
<    protected JComponent makeTextPanel(String text) {
<       JPanel panel = new JPanel(false);
<       JLabel filler = new JLabel(text);
<       filler.setHorizontalAlignment(0);
<       panel.setLayout(new GridLayout(1, 1));
<       panel.add(filler);
<       return panel;
<    }
< 
<    public static ImagePlus[] openBF(String multiSeriesFileName, boolean splitC, boolean splitT, boolean splitZ, boolean autoScale, boolean crop, boolean allSeries) {
<       ImagePlus[] imps = null;
< 
<       try {
<          ImporterOptions options = new ImporterOptions();
<          options.setId(multiSeriesFileName);
<          options.setSplitChannels(splitC);
<          options.setSplitTimepoints(splitT);
<          options.setSplitFocalPlanes(splitZ);
<          options.setAutoscale(autoScale);
<          options.setStackFormat("Hyperstack");
<          options.setStackOrder("XYCZT");
<          options.setCrop(crop);
<          options.setOpenAllSeries(allSeries);
<          ImportProcess process = new ImportProcess(options);
<          if (!process.execute()) {
<             return null;
<          } else {
<             DisplayHandler displayHandler = new DisplayHandler(process);
<             if (options != null && options.isShowOMEXML()) {
<                displayHandler.displayOMEXML();
<             }
< 
<             List<ImagePlus> impsList = (new ImagePlusReaderModified(process)).readImages(false);
<             imps = (ImagePlus[])impsList.toArray(new ImagePlus[0]);
<             if (options != null && options.showROIs()) {
<                displayHandler.displayROIs(imps);
<             }
< 
<             if (!options.isVirtual()) {
<                process.getReader().close();
<             }
< 
<             return imps;
<          }
<       } catch (Exception var12) {
<          return null;
<       }
<    }
< 
<    private final TablePanel<Spot> createSpotTable(Model model, DisplaySettings ds) {
<       List<Spot> objects = new ArrayList();
<       Iterator var5 = model.getTrackModel().unsortedTrackIDs(true).iterator();
< 
<       while(var5.hasNext()) {
<          Integer trackID = (Integer)var5.next();
<          objects.addAll(model.getTrackModel().trackSpots(trackID));
<       }
< 
<       List<String> features = new ArrayList(model.getFeatureModel().getSpotFeatures());
<       Map<String, String> featureNames = model.getFeatureModel().getSpotFeatureNames();
<       Map<String, String> featureShortNames = model.getFeatureModel().getSpotFeatureShortNames();
<       Map<String, String> featureUnits = new HashMap();
<       Iterator var9 = features.iterator();
< 
<       while(var9.hasNext()) {
<          String feature = (String)var9.next();
<          Dimension dimension = (Dimension)model.getFeatureModel().getSpotFeatureDimensions().get(feature);
<          String units = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
<          featureUnits.put(feature, units);
<       }
< 
<       Map<String, Boolean> isInts = model.getFeatureModel().getSpotFeatureIsInt();
<       Map<String, String> infoTexts = new HashMap();
<       Function<Spot, String> labelGenerator = (spot) -> {
<          return spot.getName();
<       };
<       BiConsumer<Spot, String> labelSetter = (spot, label) -> {
<          spot.setName(label);
<       };
<       String SPOT_ID = "ID";
<       features.add(0, "ID");
<       featureNames.put("ID", "Spot ID");
<       featureShortNames.put("ID", "Spot ID");
<       featureUnits.put("ID", "");
<       isInts.put("ID", Boolean.TRUE);
<       infoTexts.put("ID", "The id of the spot.");
<       String TRACK_ID = "TRACK_ID";
<       features.add(1, "TRACK_ID");
<       featureNames.put("TRACK_ID", "Track ID");
<       featureShortNames.put("TRACK_ID", "Track ID");
<       featureUnits.put("TRACK_ID", "");
<       isInts.put("TRACK_ID", Boolean.TRUE);
<       infoTexts.put("TRACK_ID", "The id of the track this spot belongs to.");
<       BiFunction<Spot, String, Double> featureFun = (spot, featurex) -> {
<          if (featurex.equals("TRACK_ID")) {
<             Integer trackID = model.getTrackModel().trackIDOf(spot);
<             return trackID == null ? null : trackID.doubleValue();
<          } else {
<             return featurex.equals("ID") ? (double)spot.ID() : spot.getFeature(featurex);
<          }
<       };
<       BiConsumer<Spot, Color> colorSetter = (spot, color) -> {
<          spot.putFeature("MANUAL_SPOT_COLOR", (double)color.getRGB());
<       };
<       Supplier<FeatureColorGenerator<Spot>> coloring = () -> {
<          return FeatureUtils.createSpotColorGenerator(model, ds);
<       };
<       TablePanel<Spot> table = new TablePanel(objects, features, featureFun, featureNames, featureShortNames, featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter, "MANUAL_SPOT_COLOR", colorSetter);
<       return table;
<    }
< 
<    private final TablePanel<DefaultWeightedEdge> createEdgeTable(Model model, DisplaySettings ds) {
<       List<DefaultWeightedEdge> objects = new ArrayList();
<       Iterator var5 = model.getTrackModel().unsortedTrackIDs(true).iterator();
< 
<       while(var5.hasNext()) {
<          Integer trackID = (Integer)var5.next();
<          objects.addAll(model.getTrackModel().trackEdges(trackID));
<       }
< 
<       List<String> features = new ArrayList(model.getFeatureModel().getEdgeFeatures());
<       Map<String, String> featureNames = model.getFeatureModel().getEdgeFeatureNames();
<       Map<String, String> featureShortNames = model.getFeatureModel().getEdgeFeatureShortNames();
<       Map<String, String> featureUnits = new HashMap();
<       Iterator var9 = features.iterator();
< 
<       String labelSetter;
<       while(var9.hasNext()) {
<          String feature = (String)var9.next();
<          Dimension dimension = (Dimension)model.getFeatureModel().getEdgeFeatureDimensions().get(feature);
<          labelSetter = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
<          featureUnits.put(feature, labelSetter);
<       }
< 
<       Map<String, Boolean> isInts = model.getFeatureModel().getEdgeFeatureIsInt();
<       Map<String, String> infoTexts = new HashMap();
<       Function<DefaultWeightedEdge, String> labelGenerator = (edge) -> {
<          return String.format("%s  %s", model.getTrackModel().getEdgeSource(edge).getName(), model.getTrackModel().getEdgeTarget(edge).getName());
<       };
<       labelSetter = null;
<       String TRACK_ID = "TRACK_ID";
<       features.add(0, "TRACK_ID");
<       featureNames.put("TRACK_ID", "Track ID");
<       featureShortNames.put("TRACK_ID", "Track ID");
<       featureUnits.put("TRACK_ID", "");
<       isInts.put("TRACK_ID", Boolean.TRUE);
<       infoTexts.put("TRACK_ID", "The id of the track this spot belongs to.");
<       BiFunction<DefaultWeightedEdge, String, Double> featureFun = (edge, featurex) -> {
<          if (featurex.equals("TRACK_ID")) {
<             Integer trackID = model.getTrackModel().trackIDOf(edge);
<             return trackID == null ? null : trackID.doubleValue();
<          } else {
<             return model.getFeatureModel().getEdgeFeature(edge, featurex);
<          }
<       };
<       BiConsumer<DefaultWeightedEdge, Color> colorSetter = (edge, color) -> {
<          model.getFeatureModel().putEdgeFeature(edge, "MANUAL_EGE_COLOR", (double)color.getRGB());
<       };
<       Supplier<FeatureColorGenerator<DefaultWeightedEdge>> coloring = () -> {
<          return FeatureUtils.createTrackColorGenerator(model, ds);
<       };
<       TablePanel<DefaultWeightedEdge> table = new TablePanel(objects, features, featureFun, featureNames, featureShortNames, featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter, "MANUAL_EGE_COLOR", colorSetter);
<       return table;
<    }
< 
<    private final TablePanel<Integer> createTrackTable(Model model, DisplaySettings ds) {
<       List<Integer> objects = new ArrayList(model.getTrackModel().trackIDs(true));
<       List<String> features = new ArrayList(model.getFeatureModel().getTrackFeatures());
<       BiFunction<Integer, String, Double> featureFun = (trackID, featurex) -> {
<          return model.getFeatureModel().getTrackFeature(trackID, featurex);
<       };
<       Map<String, String> featureNames = model.getFeatureModel().getTrackFeatureNames();
<       Map<String, String> featureShortNames = model.getFeatureModel().getTrackFeatureShortNames();
<       Map<String, String> featureUnits = new HashMap();
<       Iterator var10 = features.iterator();
< 
<       while(var10.hasNext()) {
<          String feature = (String)var10.next();
<          Dimension dimension = (Dimension)model.getFeatureModel().getTrackFeatureDimensions().get(feature);
<          String units = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
<          featureUnits.put(feature, units);
<       }
< 
<       Map<String, Boolean> isInts = model.getFeatureModel().getTrackFeatureIsInt();
<       Map<String, String> infoTexts = new HashMap();
<       Function<Integer, String> labelGenerator = (id) -> {
<          return model.getTrackModel().name(id);
<       };
<       BiConsumer<Integer, String> labelSetter = (id, label) -> {
<          model.getTrackModel().setName(id, label);
<       };
<       Supplier<FeatureColorGenerator<Integer>> coloring = () -> {
<          return FeatureUtils.createWholeTrackColorGenerator(model, ds);
<       };
<       TablePanel<Integer> table = new TablePanel(objects, features, featureFun, featureNames, featureShortNames, featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter);
<       return table;
<    }
< 
<    public static final TablePanel<SPTBatch_.Branch> createBranchTable(Model model, SelectionModel selectionModel) {
<       Logger logger = model.getLogger();
<       taskOutput.append("Generating track branches analysis.\n");
<       int ntracks = model.getTrackModel().nTracks(true);
<       if (ntracks == 0) {
<          taskOutput.append("No visible track found. Aborting.\n");
<       }
< 
<       TimeDirectedNeighborIndex neighborIndex = model.getTrackModel().getDirectedNeighborIndex();
<       List<SPTBatch_.Branch> brs = new ArrayList();
<       Iterator var7 = model.getTrackModel().unsortedTrackIDs(true).iterator();
< 
<       HashMap predecessorMap;
<       while(var7.hasNext()) {
<          Integer trackID = (Integer)var7.next();
<          TrackBranchDecomposition branchDecomposition = ConvexBranchesDecomposition.processTrack(trackID, model.getTrackModel(), neighborIndex, true, false);
<          SimpleDirectedGraph<List<Spot>, DefaultEdge> branchGraph = ConvexBranchesDecomposition.buildBranchGraph(branchDecomposition);
<          Map<SPTBatch_.Branch, Set<List<Spot>>> successorMap = new HashMap();
<          predecessorMap = new HashMap();
<          Map<List<Spot>, SPTBatch_.Branch> branchMap = new HashMap();
<          Iterator var14 = branchGraph.vertexSet().iterator();
< 
<          while(var14.hasNext()) {
<             List<Spot> branch = (List)var14.next();
<             SPTBatch_.Branch br = new SPTBatch_.Branch();
<             branchMap.put(branch, br);
<             br.trackName = model.getTrackModel().name(trackID);
<             br.putFeature("TRACK_ID", (double)trackID);
<             Spot first = (Spot)branch.get(0);
<             br.first = first;
<             br.putFeature("FIRST", (double)first.ID());
<             Spot last = (Spot)branch.get(branch.size() - 1);
<             br.last = last;
<             br.putFeature("LAST", (double)last.ID());
<             br.putFeature("DELTA_T", br.dt());
<             double distanceTraveled = Math.sqrt(br.last.squareDistanceTo(br.first));
<             br.putFeature("DISTANCE", distanceTraveled);
<             double meanV;
<             if (branch.size() < 2) {
<                meanV = Double.NaN;
<             } else {
<                Iterator<Spot> it = branch.iterator();
<                Spot previous = (Spot)it.next();
< 
<                double sum;
<                Spot next;
<                for(sum = 0.0D; it.hasNext(); previous = next) {
<                   next = (Spot)it.next();
<                   double dr = Math.sqrt(next.squareDistanceTo(previous));
<                   sum += dr;
<                }
< 
<                meanV = sum / (double)(branch.size() - 1);
<             }
< 
<             br.putFeature("MEAN_VELOCITY", meanV);
<             Set<DefaultEdge> incomingEdges = branchGraph.incomingEdgesOf(branch);
<             Set<List<Spot>> predecessors = new HashSet(incomingEdges.size());
<             Iterator var25 = incomingEdges.iterator();
< 
<             while(var25.hasNext()) {
<                DefaultEdge edge = (DefaultEdge)var25.next();
<                List<Spot> predecessorBranch = (List)branchGraph.getEdgeSource(edge);
<                predecessors.add(predecessorBranch);
<             }
< 
<             Set<DefaultEdge> outgoingEdges = branchGraph.outgoingEdgesOf(branch);
<             Set<List<Spot>> successors = new HashSet(outgoingEdges.size());
<             Iterator var51 = outgoingEdges.iterator();
< 
<             while(var51.hasNext()) {
<                DefaultEdge edge = (DefaultEdge)var51.next();
<                List<Spot> successorBranch = (List)branchGraph.getEdgeTarget(edge);
<                successors.add(successorBranch);
<             }
< 
<             successorMap.put(br, successors);
<             predecessorMap.put(br, predecessors);
<          }
< 
<          var14 = successorMap.keySet().iterator();
< 
<          while(var14.hasNext()) {
<             SPTBatch_.Branch br = (SPTBatch_.Branch)var14.next();
<             Set<List<Spot>> succs = (Set)successorMap.get(br);
<             Set<SPTBatch_.Branch> succBrs = new HashSet(succs.size());
<             Iterator var40 = succs.iterator();
< 
<             while(var40.hasNext()) {
<                List<Spot> branch = (List)var40.next();
<                SPTBatch_.Branch succBr = (SPTBatch_.Branch)branchMap.get(branch);
<                succBrs.add(succBr);
<             }
< 
<             br.successors = succBrs;
<             br.putFeature("N_SUCCESSORS", (double)succBrs.size());
<             Set<List<Spot>> preds = (Set)predecessorMap.get(br);
<             Set<SPTBatch_.Branch> predBrs = new HashSet(preds.size());
<             Iterator var43 = preds.iterator();
< 
<             while(var43.hasNext()) {
<                List<Spot> branch = (List)var43.next();
<                SPTBatch_.Branch predBr = (SPTBatch_.Branch)branchMap.get(branch);
<                predBrs.add(predBr);
<             }
< 
<             br.predecessors = predBrs;
<             br.putFeature("N_PREDECESSORS", (double)predBrs.size());
<          }
< 
<          brs.addAll(successorMap.keySet());
<       }
< 
<       Collections.sort(brs);
<       BiFunction<SPTBatch_.Branch, String, Double> featureFun = (brx, feature) -> {
<          return brx.getFeature(feature);
<       };
<       Map<String, String> featureUnits = new HashMap();
<       BRANCH_FEATURES_DIMENSIONS.forEach((f, d) -> {
<          featureUnits.put(f, TMUtils.getUnitsFor(d, model.getSpaceUnits(), model.getTimeUnits()));
<       });
<       Map<String, String> infoTexts = new HashMap();
<       Function<SPTBatch_.Branch, String> labelGenerator = (b) -> {
<          return b.toString();
<       };
<       predecessorMap = null;
<       Supplier<FeatureColorGenerator<SPTBatch_.Branch>> colorSupplier = () -> {
<          return (b) -> {
<             return Color.WHITE;
<          };
<       };
<       TablePanel<SPTBatch_.Branch> table = new TablePanel(brs, BRANCH_FEATURES, featureFun, BRANCH_FEATURES_NAMES, BRANCH_FEATURES_SHORTNAMES, featureUnits, BRANCH_FEATURES_ISINTS, infoTexts, colorSupplier, labelGenerator, predecessorMap);
<       return table;
<    }
< 
<    private final <K, V> Set<V> getUniqueValues(Iterable<K> keys, Map<K, V> map) {
<       Set<V> mapping = new LinkedHashSet();
<       Iterator var5 = keys.iterator();
< 
<       while(var5.hasNext()) {
<          K key = (Object)var5.next();
<          mapping.add(map.get(key));
<       }
< 
<       return mapping;
<    }
< 
<    private static final <K, V> List<K> getCommonKeys(V targetValue, Iterable<K> keys, Map<K, V> map) {
<       ArrayList<K> foundKeys = new ArrayList();
<       Iterator var5 = keys.iterator();
< 
<       while(var5.hasNext()) {
<          K key = (Object)var5.next();
<          if (map.get(key).equals(targetValue)) {
<             foundKeys.add(key);
<          }
<       }
< 
<       return foundKeys;
<    }
< 
<    private final String buildPlotTitle(Iterable<String> lYFeatures, Map<String, String> featureNames, String xSelectedSpot) {
<       StringBuilder sb = new StringBuilder("Plot of ");
<       Iterator<String> it = lYFeatures.iterator();
<       sb.append((String)featureNames.get(it.next()));
< 
<       while(it.hasNext()) {
<          sb.append(", ");
<          sb.append((String)featureNames.get(it.next()));
<       }
< 
<       sb.append(" vs ");
<       sb.append((String)featureNames.get(xSelectedSpot));
<       sb.append(".");
<       return sb.toString();
<    }
< 
<    private static final float[] toFloat(double[] d) {
<       float[] f = new float[d.length];
< 
<       for(int i = 0; i < f.length; ++i) {
<          f[i] = (float)d[i];
<       }
< 
<       return f;
<    }
< 
<    public ImagePlus renderND(HyperStackDisplayer displayer, DisplaySettings ds) {
<       Roi initialROI = displayer.getImp().getRoi();
<       if (initialROI != null) {
<          displayer.getImp().killRoi();
<       }
< 
<       Overlay overlay = displayer.getImp().getOverlay();
<       if (overlay == null) {
<          overlay = new Overlay();
<          displayer.getImp().setOverlay(overlay);
<       }
< 
<       overlay.clear();
<       if (initialROI != null) {
<          displayer.getImp().getOverlay().add(initialROI);
<       }
< 
<       if (displayer != null) {
<          displayer.getImp().updateAndDraw();
<       }
< 
<       displayer.getImp().setOpenAsHyperStack(true);
<       displayer.getImp().getOverlay().add(new SpotOverlay(model, displayer.getImp(), ds));
<       displayer.getImp().getOverlay().add(new TrackOverlay(model, displayer.getImp(), ds));
<       displayer.getImp().updateAndDraw();
<       return displayer.getImp();
<    }
< 
<    public static ImagePlus[] stack2images(ImagePlus imp) {
<       String sLabel = imp.getTitle();
<       String sImLabel = "";
<       ImageStack stack = imp.getStack();
<       int sz = stack.getSize();
<       int currentSlice = imp.getCurrentSlice();
<       DecimalFormat df = new DecimalFormat("0000");
<       ImagePlus[] arrayOfImages = new ImagePlus[imp.getStack().getSize()];
< 
<       for(int n = 1; n <= sz; ++n) {
<          imp.setSlice(n);
<          ImageProcessor ip = imp.getProcessor();
<          ImageProcessor newip = ip.createProcessor(ip.getWidth(), ip.getHeight());
<          newip.setPixels(ip.getPixelsCopy());
<          sImLabel = imp.getStack().getSliceLabel(n);
<          if (sImLabel == null || sImLabel.length() < 1) {
<             sImLabel = "slice" + df.format((long)n) + "_" + sLabel;
<          }
< 
<          ImagePlus im = new ImagePlus(sImLabel, newip);
<          im.setCalibration(imp.getCalibration());
<          arrayOfImages[n - 1] = im;
<       }
< 
<       imp.setSlice(currentSlice);
<       if (imp.isProcessor()) {
<          ImageProcessor ip = imp.getProcessor();
<          ip.setPixels(ip.getPixels());
<       }
< 
<       imp.setSlice(currentSlice);
<       return arrayOfImages;
<    }
< 
<    public void exportToCSV(String[][] rowData, String[] titles, File file) {
<       try {
<          try {
<             FileWriter excel = new FileWriter(file);
< 
<             int i;
<             for(i = 0; i < titles.length; ++i) {
<                excel.write(titles[i] + ",");
<             }
< 
<             excel.write("\n");
< 
<             for(i = 0; i < rowData.length; ++i) {
<                for(int j = 0; j < rowData[i].length; ++j) {
<                   if (j == 11) {
<                      excel.write(" ,");
<                   }
< 
<                   if (j != 11) {
<                      if (rowData[i][j].toString() != null || rowData[i][j].toString() != " ") {
<                         excel.write(rowData[i][j].toString() + ",");
<                      }
< 
<                      if (rowData[i][j].toString() == null || rowData[i][j].toString() == " ") {
<                         excel.write(" ,");
<                      }
<                   }
<                }
< 
<                excel.write("\n");
<             }
< 
<             excel.close();
<          } catch (IOException var7) {
<          }
<       } catch (NullPointerException var8) {
<       }
< 
<    }
< 
<    public static class Branch implements Comparable<SPTBatch_.Branch> {
<       private final Map<String, Double> features = new HashMap();
<       private String trackName;
<       private Spot first;
<       private Spot last;
<       private Set<SPTBatch_.Branch> predecessors;
<       private Set<SPTBatch_.Branch> successors;
< 
<       public String toString() {
<          return this.trackName + ": " + this.first + "  " + this.last;
<       }
< 
<       double dt() {
<          return this.last.diffTo(this.first, "POSITION_T");
<       }
< 
<       public final Double getFeature(String feature) {
<          return (Double)this.features.get(feature);
<       }
< 
<       public final void putFeature(String feature, Double value) {
<          this.features.put(feature, value);
<       }
< 
<       public int compareTo(SPTBatch_.Branch o) {
<          if (this.predecessors.size() != o.predecessors.size()) {
<             return this.predecessors.size() - o.predecessors.size();
<          } else if (this.successors.size() != o.successors.size()) {
<             return this.successors.size() - o.successors.size();
<          } else {
<             return this.first.getName().compareTo(o.first.getName()) != 0 ? this.first.getName().compareTo(o.first.getName()) : this.last.getName().compareTo(o.last.getName());
<          }
<       }
<    }
< 
<    class ChooserWizardPanel extends JWizardPanel {
<       private ButtonGroup bg;
< 
<       public ChooserWizardPanel(JWizardComponents wizardComponents) {
<          super(wizardComponents, "");
<          this.init();
<       }
< 
<       private void init() {
<          this.setLayout(new GridBagLayout());
<          CheckableItem[] items = new CheckableItem[]{new CheckableItem("Spots", true), new CheckableItem("Links", true), new CheckableItem("Tracks", true), new CheckableItem("Branch Analysis", true)};
<          SPTBatch_.checkbox1 = new JCheckBox("  Analysis/Statistics Results. ");
<          SPTBatch_.checkbox1.setSelected(true);
<          SPTBatch_.checkboxDiff = new JCheckBox("  TraJ: Trajectory Classifier. ");
<          SPTBatch_.checkboxDiff.setSelected(true);
<          SPTBatch_.this.trajButton = new JButton("Tune Parameters");
<          SPTBatch_.checkboxSubBg = new JCheckBox(" Subtract Background :  ");
<          SPTBatch_.checkboxSubBg.setSelected(false);
<          SPTBatch_.checkExcludeTracks = new JCheckBox(" Exclude tracks outside cell  ");
<          SPTBatch_.checkExcludeTracks.setSelected(false);
<          SPTBatch_.checkPBS = new JCheckBox("Photobleaching step Analysis.");
<          SPTBatch_.checkPBS.setSelected(true);
<          SPTBatch_.checkSummary = new JCheckBox("");
<          SPTBatch_.checkSummary.setSelected(true);
<          SPTBatch_.this.summaryButton = new JButton("Summary Outputs");
<          JPanel summPanel = new JPanel(new FlowLayout(0));
<          summPanel.add(SPTBatch_.checkSummary);
<          summPanel.add(SPTBatch_.this.summaryButton);
<          JPanel panelPBS = new JPanel(new FlowLayout(0));
<          panelPBS.add(SPTBatch_.checkPBS);
<          SPTBatch_.this.comboSubBg = new JComboBox();
<          SPTBatch_.this.comboSubBg = new JComboBox();
<          SPTBatch_.this.comboSubBg.addItem("Subtract Bg 1");
<          SPTBatch_.this.comboSubBg.addItem("Subtract Bg 2");
<          SPTBatch_.this.comboSubBg.addItem("Subtract Bg 3");
<          SPTBatch_.this.comboSubBg.addItem("Subtract Bg 4");
<          SPTBatch_.this.comboSubBg.addItem("Subtract Bg 5");
<          SPTBatch_.this.comboSubBg.setEnabled(false);
<          SPTBatch_.checkboxMSD = new JCheckBox("  MSD and MSS Plots ");
<          SPTBatch_.checkboxMSD.setSelected(true);
<          SPTBatch_.checkCluster = new JCheckBox(" Cluster Size Analysis ");
<          SPTBatch_.checkCluster.setSelected(true);
<          SPTBatch_.checkMonomer = new JCheckBox(" Monomeric Protein Intensity ");
<          SPTBatch_.checkMonomer.setSelected(true);
<          SPTBatch_.checkbox2 = new JCheckBox();
<          SPTBatch_.checkbox2.setText(" Tracks to .XML file ");
<          SPTBatch_.checkbox2.setSelected(true);
<          SPTBatch_.checkbox3 = new JCheckBox();
<          SPTBatch_.checkbox3.setText("  Log to .TXT file ");
<          SPTBatch_.checkbox3.setSelected(true);
<          SPTBatch_.checkbox4 = new JCheckBox();
<          SPTBatch_.checkbox4.setText("  Track-Overlays as .TIF images");
<          SPTBatch_.checkbox4.setSelected(true);
<          SPTBatch_.checkboxRoi = new JCheckBox();
<          SPTBatch_.checkboxRoi.setText("  Track-Rois as RoiSet.zip");
<          SPTBatch_.checkboxRoi.setSelected(true);
<          SPTBatch_.checkboxPlot = new JCheckBox();
<          SPTBatch_.checkboxPlot.setText("  Plots as .PNG file");
<          SPTBatch_.checkboxPlot.setSelected(true);
<          SPTBatch_.checkboxSP = new JCheckBox();
<          SPTBatch_.checkboxSP.setText("  Chemotaxis Analysis Data");
<          SPTBatch_.checkboxSP.setSelected(true);
<          SPTBatch_.chemoScaling = new JTextField("Set Axis Scaling...");
<          SPTBatch_.chemoScaling.setEnabled(true);
<          SPTBatch_.monomerField = new JTextField("value...");
<          SPTBatch_.monomerField.setEnabled(true);
<          SPTBatch_.this.comboP = new CheckedComboBox(new DefaultComboBoxModel(items));
<          SPTBatch_.this.comboP.setOpaque(true);
<          SPTBatch_.this.comboP.setToolTipText("Select an analysis for export csv file");
<          SPTBatch_.this.comboP.setSelectedItem(items[0]);
<          if (items[0].isSelected()) {
<             SPTBatch_.this.enableSpotTable = "spotTable";
<          }
< 
<          if (items[1].isSelected()) {
<             SPTBatch_.this.enableLinkTable = "linkTable";
<          }
< 
<          if (items[2].isSelected()) {
<             SPTBatch_.this.enableTrackTable = "trackTable";
<          }
< 
<          if (items[3].isSelected()) {
<             SPTBatch_.this.enableBranchTable = "branchTable";
<          }
< 
<          this.removeAll();
<          final TextField textCsv = new TextField(20);
<          textCsv.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_CSV_PATH, ""));
<          SPTBatch_.csvPath = textCsv.getText();
<          GridBagLayout layoutCsv = (GridBagLayout)this.getLayout();
<          GridBagConstraints constraintsCsv = layoutCsv.getConstraints(textCsv);
<          SPTBatch_.this.buttonCsv = new JButton("");
<          ImageIcon iconCsv = SPTBatch_.this.createImageIcon("browse.png");
<          Icon iconCsvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(15, 15, 4));
<          SPTBatch_.this.buttonCsv.setIcon(iconCsvCell);
<          DirectoryListener listenerCsv = new DirectoryListener("Browse for ", textCsv, 2);
<          SPTBatch_.this.buttonCsv.addActionListener(listenerCsv);
<          final Panel panelCsv = new Panel();
<          panelCsv.setLayout(new FlowLayout(0, 0, 0));
<          layoutCsv.setConstraints(panelCsv, constraintsCsv);
<          panelCsv.add(SPTBatch_.checkbox1);
<          panelCsv.add(SPTBatch_.this.comboP);
<          JPanel panelBox = new JPanel();
<          JPanel panelOptions = new JPanel(new FlowLayout(0));
<          JPanel panelOptions1 = new JPanel(new FlowLayout(0));
<          panelOptions.add(Box.createHorizontalStrut(35));
<          panelOptions1.add(Box.createHorizontalStrut(35));
<          panelBox.setLayout(new BoxLayout(panelBox, 1));
<          SPTBatch_.checkTracks = new JCheckBox("Spot Range in Track: ");
<          SPTBatch_.checkTracks.setSelected(false);
<          SPTBatch_.minTracks = new JTextField("Min", 3);
<          SPTBatch_.minTracks.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_MIN_SPOT, ""));
<          SPTBatch_.minTracks.setEnabled(false);
<          SPTBatch_.maxTracks = new JTextField("Max", 3);
<          SPTBatch_.maxTracks.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_MAX_SPOT, ""));
<          SPTBatch_.maxTracks.setEnabled(false);
<          panelOptions1.add(SPTBatch_.checkTracks);
<          panelOptions1.add(SPTBatch_.minTracks);
<          panelOptions1.add(new JLabel("-"));
<          panelOptions1.add(SPTBatch_.maxTracks);
<          SPTBatch_.checkDispSpots = new JCheckBox("Spots Visible ");
<          SPTBatch_.checkDispSpots.setSelected(true);
<          SPTBatch_.checkDispSpotName = new JCheckBox("Spots Name Visible ");
<          SPTBatch_.checkDispSpotName.setSelected(true);
<          SPTBatch_.checkDispTracks = new JCheckBox("Tracks Visible: ");
<          SPTBatch_.checkDispTracks.setSelected(true);
<          SPTBatch_.this.comboDispTracks = new JComboBox();
<          SPTBatch_.this.comboDispTracks.addItem("FULL");
<          SPTBatch_.this.comboDispTracks.addItem("LOCAL");
<          SPTBatch_.this.comboDispTracks.addItem("LOCAL_BACKWARD");
<          SPTBatch_.this.comboDispTracks.addItem("LOCAL_FORWARD");
<          SPTBatch_.this.comboDispTracks.setSelectedIndex(0);
<          JPanel panelSpotTrackDisp = new JPanel(new FlowLayout(0));
<          panelSpotTrackDisp.add(SPTBatch_.checkDispSpots);
<          panelSpotTrackDisp.add(SPTBatch_.checkDispSpotName);
<          panelSpotTrackDisp.add(SPTBatch_.checkDispTracks);
<          panelSpotTrackDisp.add(SPTBatch_.this.comboDispTracks);
<          JLabel thLengthLabel = new JLabel("-Length Threshold: ");
<          SPTBatch_.thLength = new JTextField("Length", 3);
<          SPTBatch_.thLength.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_LENGTH_TH, ""));
<          JLabel thD14Label = new JLabel("-Diff.Threshold: ");
<          SPTBatch_.thD14 = new JTextField("Diff", 3);
<          SPTBatch_.thD14.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_DIFF_TH, ""));
<          JPanel panelLengthD14 = new JPanel(new FlowLayout(0));
<          panelLengthD14.add(thLengthLabel);
<          panelLengthD14.add(SPTBatch_.thLength);
<          panelLengthD14.add(thD14Label);
<          panelLengthD14.add(SPTBatch_.thD14);
<          JPanel panelSubBg = new JPanel(new FlowLayout(0, 0, 0));
<          panelSubBg.add(SPTBatch_.checkboxSubBg);
<          panelSubBg.add(SPTBatch_.this.comboSubBg);
<          panelSubBg.add(SPTBatch_.checkExcludeTracks);
<          panelBox.add(panelOptions);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(panelOptions1);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(panelLengthD14);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(panelSpotTrackDisp);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(panelPBS);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(panelSubBg);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(summPanel);
<          Panel panelOut = new Panel();
<          panelOut.setLayout(new FlowLayout(0, 0, 0));
<          panelOut.add(SPTBatch_.checkbox4);
<          GridBagLayout layoutXMLL = (GridBagLayout)this.getLayout();
<          Panel panelXMLL = new Panel();
<          panelXMLL.setLayout(new FlowLayout(0, 0, 0));
<          panelXMLL.add(SPTBatch_.checkbox2);
<          GridBagLayout layoutTxt = (GridBagLayout)this.getLayout();
<          Panel panelTxt = new Panel();
<          panelTxt.setLayout(new FlowLayout(0, 0, 0));
<          panelTxt.add(SPTBatch_.checkbox3);
<          final JPanel panelExport = new JPanel();
<          JLabel labelExport = new JLabel();
<          labelExport.setText(" Choose a directory to export files:    ");
<          labelExport.setFont(new Font("Verdana", 1, 12));
<          panelExport.setLayout(new FlowLayout(0, 0, 0));
<          panelExport.add(labelExport);
<          panelExport.add(textCsv);
<          panelExport.add(SPTBatch_.this.buttonCsv);
<          JPanel panelDiff = new JPanel(new FlowLayout(0, 0, 0));
<          panelDiff.add(SPTBatch_.checkboxDiff);
<          panelDiff.add(SPTBatch_.this.trajButton);
<          JPanel panelMSD = new JPanel(new FlowLayout(0, 0, 0));
<          panelMSD.add(SPTBatch_.checkboxMSD);
<          JPanel panelCluster = new JPanel(new FlowLayout(0, 0, 0));
<          panelCluster.add(SPTBatch_.checkCluster);
<          panelCluster.add(SPTBatch_.checkMonomer);
<          panelCluster.add(SPTBatch_.monomerField);
<          JPanel panelExport2 = new JPanel(new BorderLayout());
<          panelExport2.add(panelExport, "East");
<          Panel panelRoi = new Panel();
<          panelRoi.setLayout(new FlowLayout(0, 0, 0));
<          panelRoi.add(SPTBatch_.checkboxRoi);
<          Panel panelPlot = new Panel();
<          panelPlot.setLayout(new FlowLayout(0, 0, 0));
<          panelPlot.add(SPTBatch_.checkboxPlot);
<          Panel panelSP = new Panel();
<          panelSP.setLayout(new FlowLayout(0, 0, 0));
<          panelSP.add(SPTBatch_.checkboxSP);
<          panelSP.add(SPTBatch_.chemoScaling);
<          JLabel labelExport1 = new JLabel("   Tuneable Options: ");
<          labelExport1.setFont(new Font("Verdana", 1, 12));
<          JPanel panelExport1 = new JPanel(new FlowLayout(0));
<          panelExport1.add(labelExport1);
<          JPanel mainPanel2 = new JPanel();
<          mainPanel2.setBorder(BorderFactory.createTitledBorder(""));
<          mainPanel2.setLayout(new BoxLayout(mainPanel2, 1));
<          mainPanel2.add(Box.createVerticalStrut(3));
<          mainPanel2.add(new JSeparator(0));
<          mainPanel2.add(panelExport1);
<          mainPanel2.add(new JSeparator(0));
<          mainPanel2.add(Box.createVerticalStrut(8));
<          mainPanel2.add(panelCsv);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(Box.createHorizontalStrut(15));
<          mainPanel2.add(panelBox);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelDiff);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelMSD);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelCluster);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelXMLL);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelTxt);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelOut);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelRoi);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelPlot);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelSP);
<          mainPanel2.add(Box.createVerticalStrut(15));
<          mainPanel2.add(new JSeparator(0));
<          mainPanel2.add(Box.createVerticalStrut(3));
<          mainPanel2.add(panelExport2);
<          mainPanel2.setBorder(BorderFactory.createTitledBorder(""));
<          SPTBatch_.this.comboP.setEnabled(true);
<          textCsv.setEnabled(true);
<          SPTBatch_.this.buttonCsv.setEnabled(true);
<          panelExport2.setEnabled(true);
<          SPTBatch_.checkbox4.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.checkExcludeTracks.setSelected(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.checkExcludeTracks.setSelected(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkDispSpots.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.checkDispSpotName.setSelected(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.checkDispSpotName.setSelected(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkSummary.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.this.summaryButton.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.this.summaryButton.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkboxDiff.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.this.trajButton.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.this.trajButton.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkDispTracks.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.this.comboDispTracks.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.this.comboDispTracks.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkTracks.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.minTracks.setEnabled(true);
<                   SPTBatch_.maxTracks.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.minTracks.setEnabled(false);
<                   SPTBatch_.maxTracks.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkMonomer.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.monomerField.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.monomerField.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkboxSubBg.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.this.comboSubBg.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.this.comboSubBg.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkbox1.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                Component[] com = panelCsv.getComponents();
<                Component[] comExport = panelExport.getComponents();
<                int a;
<                if (e.getStateChange() == 1) {
<                   for(a = 1; a < com.length; ++a) {
<                      com[a].setEnabled(true);
<                   }
< 
<                   for(a = 0; a < comExport.length; ++a) {
<                      comExport[a].setEnabled(true);
<                   }
<                }
< 
<                if (e.getStateChange() == 2) {
<                   for(a = 1; a < com.length; ++a) {
<                      com[a].setEnabled(false);
<                   }
<                }
< 
<             }
<          });
<          SPTBatch_.checkboxSP.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.chemoScaling.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.chemoScaling.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.this.summaryButton.addActionListener(new ActionListener() {
<             public void actionPerformed(ActionEvent event) {
<                if (SPTBatch_.checkSummary.isSelected()) {
<                   if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE) {
<                      SPTBatch_.minTracksJTF = Integer.valueOf(SPTBatch_.minTracks.getText());
<                      SPTBatch_.maxTracksJTF = Integer.valueOf(SPTBatch_.maxTracks.getText());
<                      SPTBatch_.thLengthJTF = Integer.valueOf(SPTBatch_.thLength.getText());
<                      if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "DIff") {
<                         SPTBatch_.this.thD14JTF = Double.valueOf(SPTBatch_.thD14.getText());
<                      }
<                   }
< 
<                   (new summaryColsWindow()).run("");
<                }
< 
<             }
<          });
<          SPTBatch_.this.trajButton.addActionListener(new ActionListener() {
<             public void actionPerformed(ActionEvent event) {
<                if (SPTBatch_.checkboxDiff.isSelected()) {
<                   (new traJParametersWindow()).run("");
<                }
< 
<             }
<          });
<          SPTBatch_.this.finishButton.addActionListener(new ActionListener() {
<             public void actionPerformed(ActionEvent event) {
<                SPTBatch_.csvPath = textCsv.getText();
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_CSV_PATH, textCsv.getText());
<             }
<          });
<          this.add(mainPanel2);
<       }
< 
<       public void update() {
<          if (SPTBatch_.checkboxPlot.isSelected() == Boolean.FALSE) {
<             this.setNextButtonEnabled(false);
<          }
< 
<          if (SPTBatch_.checkboxPlot.isSelected() == Boolean.TRUE) {
<             this.setNextButtonEnabled(true);
<          }
< 
<          this.setFinishButtonEnabled(true);
<          this.setBackButtonEnabled(false);
<       }
< 
<       public void next() {
<          this.switchPanel(3);
<       }
< 
<       public void back() {
<          this.switchPanel(4);
<       }
<    }
< 
<    private static final class EdgeSourceSpotFrameComparator implements Comparator<DefaultWeightedEdge> {
<       private final Model model;
< 
<       public EdgeSourceSpotFrameComparator(Model model) {
<          this.model = model;
<       }
< 
<       public int compare(DefaultWeightedEdge e1, DefaultWeightedEdge e2) {
<          double t1 = this.model.getTrackModel().getEdgeSource(e1).getFeature("FRAME");
<          double t2 = this.model.getTrackModel().getEdgeSource(e2).getFeature("FRAME");
<          if (t1 < t2) {
<             return -1;
<          } else {
<             return t1 > t2 ? 1 : 0;
<          }
<       }
<    }
< 
<    class FirstWizardPanel extends SPTBatch_.LabelWizardPanel {
<       public FirstWizardPanel(JWizardComponents wizardComponents) {
<          super(wizardComponents, "");
<       }
<    }
< 
<    class LabelWizardPanel extends JWizardPanel {
<       public LabelWizardPanel(JWizardComponents wizardComponents, String label) {
<          super(wizardComponents);
<          SPTBatch_.this.backButton = wizardComponents.getBackButton();
<          SPTBatch_.this.backButton.setText("");
<          ImageIcon iconBack = SPTBatch_.this.createImageIcon("img_71224.png");
<          Icon iconBackCell = new ImageIcon(iconBack.getImage().getScaledInstance(12, 12, 4));
<          SPTBatch_.this.backButton.setIcon(iconBackCell);
<          SPTBatch_.this.backButton.setToolTipText("Click chemotool button to back the previous wizard.");
<          SPTBatch_.this.nextButton = wizardComponents.getNextButton();
<          SPTBatch_.this.nextButton.setText("");
<          ImageIcon iconNext = SPTBatch_.this.createImageIcon("img_174455.png");
<          Icon iconNextCell = new ImageIcon(iconNext.getImage().getScaledInstance(12, 12, 4));
<          SPTBatch_.this.nextButton.setIcon(iconNextCell);
<          SPTBatch_.this.nextButton.setToolTipText("Click chemotool button to go to the next wizard.");
<          SPTBatch_.this.finishButton = wizardComponents.getFinishButton();
<          SPTBatch_.this.finishButton.setText("");
<          ImageIcon iconFinish = SPTBatch_.this.createImageIcon("ojala.png");
<          Icon iconFinishCell = new ImageIcon(iconFinish.getImage().getScaledInstance(12, 12, 4));
<          SPTBatch_.this.finishButton.setIcon(iconFinishCell);
<          SPTBatch_.this.finishButton.setToolTipText("Click chemotool button to finish your settings selection.");
<          JButton cancelButton = wizardComponents.getCancelButton();
<          cancelButton.setText("");
<          ImageIcon iconCancel = SPTBatch_.this.createImageIcon("delete.png");
<          Icon iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(12, 12, 4));
<          cancelButton.setIcon(iconCancelCell);
<          cancelButton.setToolTipText("Click chemotool button to cancel chemotool process.");
<          this.setLayout(new GridBagLayout());
<          this.add(new JLabel(label), new GridBagConstraints(0, 0, 1, 1, 0.0D, 0.0D, 10, 1, new Insets(0, 0, 0, 0), 0, 0));
<          final TextField textXML = new TextField(20);
<          textXML.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_TRANSF_PATH, ""));
<          GridBagLayout layoutXML = (GridBagLayout)this.getLayout();
<          GridBagConstraints constraintsXML = layoutXML.getConstraints(textXML);
<          JButton buttonXML = new JButton("");
<          ImageIcon iconXML = SPTBatch_.this.createImageIcon("browse.png");
<          Icon iconXMLCell = new ImageIcon(iconXML.getImage().getScaledInstance(15, 15, 4));
<          buttonXML.setIcon(iconXMLCell);
<          ImageIcon iconBrowse = SPTBatch_.this.createImageIcon("browse.png");
<          Icon iconBrowseCell = new ImageIcon(iconBrowse.getImage().getScaledInstance(15, 15, 4));
<          buttonXML.setIcon(iconBrowseCell);
<          DirectoryListener listenerXML = new DirectoryListener("Browse for " + label, textXML, 2);
<          buttonXML.addActionListener(listenerXML);
<          Panel panelXML = new Panel();
<          panelXML.setLayout(new FlowLayout(0));
<          JLabel loadLabel = new JLabel("  Load TrackMate .XML file: ");
<          loadLabel.setFont(new Font("Verdana", 1, 12));
<          panelXML.add(loadLabel);
<          panelXML.add(textXML);
<          panelXML.add(buttonXML);
<          layoutXML.setConstraints(panelXML, constraintsXML);
<          final TextField textImg = new TextField(20);
<          textImg.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_IMAGES_PATH, ""));
<          GridBagLayout layoutImg = (GridBagLayout)this.getLayout();
<          GridBagConstraints constraintsImg = layoutImg.getConstraints(textImg);
<          JButton buttonImg = new JButton("");
<          ImageIcon iconIM = SPTBatch_.this.createImageIcon("browse.png");
<          Icon iconIMCell = new ImageIcon(iconIM.getImage().getScaledInstance(15, 15, 4));
<          buttonImg.setIcon(iconIMCell);
<          ImageIcon iconB = SPTBatch_.this.createImageIcon("browse.png");
<          Icon iconBCell = new ImageIcon(iconB.getImage().getScaledInstance(15, 15, 4));
<          buttonImg.setIcon(iconBCell);
<          DirectoryListener listenerImg = new DirectoryListener("Browse for " + label, textImg, 2);
<          buttonImg.addActionListener(listenerImg);
<          Panel panelImg = new Panel();
<          panelImg.setLayout(new FlowLayout(0));
<          JLabel directLabel = new JLabel("  Movie Files Directory:   ");
<          directLabel.setFont(new Font("Verdana", 1, 12));
<          panelImg.add(directLabel);
<          panelImg.add(textImg);
<          panelImg.add(buttonImg);
<          layoutImg.setConstraints(panelImg, constraintsImg);
<          JPanel mainPanel = new JPanel();
<          mainPanel.setLayout(new BoxLayout(mainPanel, 1));
<          mainPanel.add(Box.createVerticalStrut(15));
<          mainPanel.add(panelXML);
<          mainPanel.add(Box.createVerticalStrut(20));
<          mainPanel.add(panelImg);
<          mainPanel.add(Box.createVerticalStrut(15));
<          mainPanel.setBorder(BorderFactory.createTitledBorder(""));
<          this.add(mainPanel);
<          this.setPanelTitle("");
<          SPTBatch_.this.nextButton.addActionListener(new ActionListener() {
<             public void actionPerformed(ActionEvent event) {
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_TRANSF_PATH, textXML.getText());
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_IMAGES_PATH, textImg.getText());
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_MIN_SPOT, SPTBatch_.minTracks.getText());
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_MAX_SPOT, SPTBatch_.maxTracks.getText());
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_LENGTH_TH, SPTBatch_.thLength.getText());
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_DIFF_TH, SPTBatch_.thD14.getText());
<                if (SPTBatch_.checkboxDiff.isSelected()) {
<                   SPTBatch_.pref1.put(SPTBatch_.TRACKMATE_MIN_TRACK, traJParametersWindow.minLengthText.getText());
<                   SPTBatch_.pref1.put(SPTBatch_.TRACKMATE_WINDOW, traJParametersWindow.windowText.getText());
<                   SPTBatch_.pref1.put(SPTBatch_.TRACKMATE_MIN_SEGMENT, traJParametersWindow.minSegText.getText());
<                }
< 
<             }
<          });
<       }
<    }
< 
<    class LastWizardPanel extends SPTBatch_.LabelWizardPanel {
<       public LastWizardPanel(JWizardComponents wizardComponents) {
<          super(wizardComponents, "");
<          this.setPanelTitle("");
<          this.update();
<          this.removeAll();
<          JTabbedPane tabbedPane = new JTabbedPane();
<          ImageIcon iconSpot = SPTBatch_.this.createImageIcon("5441165-point-of-light-png-104-images-in-collection-page-1-point-of-light-png-320_320_preview.png");
<          Icon iconSpotCell = new ImageIcon(iconSpot.getImage().getScaledInstance(12, 12, 4));
<          ImageIcon iconLink = SPTBatch_.this.createImageIcon("link.png");
<          Icon iconLinkCell = new ImageIcon(iconLink.getImage().getScaledInstance(16, 16, 4));
<          ImageIcon iconTrack = SPTBatch_.this.createImageIcon("track.jpg");
<          Icon iconTrackCell = new ImageIcon(iconTrack.getImage().getScaledInstance(16, 16, 4));
<          JComponent panel1 = SPTBatch_.this.makeTextPanel("");
<          JComponent panelX = SPTBatch_.this.makeTextPanel("");
<          JComponent panelY = SPTBatch_.this.makeTextPanel("");
<          panelY.setLayout(new FlowLayout(0));
<          JLabel xSpot = new JLabel();
<          xSpot.setText(" Spot-Feature for X axis:   ");
<          xSpot.setFont(new Font("Verdana", 1, 12));
<          JLabel ySpot = new JLabel();
<          ySpot.setText(" Spot-Feature for Y axis:   ");
<          ySpot.setFont(new Font("Verdana", 1, 12));
<          SPTBatch_.this.comboSpotsX = new JComboBox();
<          SPTBatch_.this.comboSpotsY = new JComboBox();
<          Object[] spotItems = null;
<          spotItems = new Object[]{"QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T\tFRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1"};
< 
<          for(int ixx = 0; ixx < spotItems.length; ++ixx) {
<             SPTBatch_.this.comboSpotsX.addItem(spotItems[ixx]);
<             SPTBatch_.this.comboSpotsY.addItem(spotItems[ixx]);
<          }
< 
<          panelX.setLayout(new FlowLayout(0));
<          panelX.add(Box.createVerticalStrut(10));
<          panelX.add(xSpot);
<          panelX.add(Box.createVerticalStrut(5));
<          panelX.add(SPTBatch_.this.comboSpotsX);
<          panelY.add(ySpot);
<          panelY.add(Box.createVerticalStrut(5));
<          panelY.add(SPTBatch_.this.comboSpotsY);
<          panel1.setLayout(new BoxLayout(panel1, 1));
<          panel1.add(panelX);
<          panel1.add(panelY);
<          JPanel panelESP = new JPanel(new FlowLayout(1));
<          panelESP.setBorder(BorderFactory.createLoweredBevelBorder());
<          SPTBatch_.ESP = new JCheckBox("  Export User-Defined Spot Plot.");
<          panelESP.add(SPTBatch_.ESP);
<          panel1.add(Box.createVerticalStrut(15));
<          panel1.add(panelESP);
<          panel1.setBorder(BorderFactory.createTitledBorder(""));
<          tabbedPane.addTab("Spots", iconSpotCell, panel1, "Select the X-Y Spot features to plot.");
<          tabbedPane.setMnemonicAt(0, 49);
<          JComponent panel2 = SPTBatch_.this.makeTextPanel("");
<          JComponent panelLinkX = SPTBatch_.this.makeTextPanel("");
<          JComponent panelLinkY = SPTBatch_.this.makeTextPanel("");
<          panelLinkX.setLayout(new FlowLayout(0));
<          panelLinkY.setLayout(new FlowLayout(0));
<          JLabel xLink = new JLabel();
<          xLink.setText(" Link-Feature for X axis:   ");
<          xLink.setFont(new Font("Verdana", 1, 12));
<          JLabel yLink = new JLabel();
<          yLink.setText(" Link-Feature for Y axis:   ");
<          yLink.setFont(new Font("Verdana", 1, 12));
<          SPTBatch_.this.comboLinkX = new JComboBox();
<          SPTBatch_.this.comboLinkY = new JComboBox();
<          Object[] edgeItems = new Object[]{"SPOT_SOURCE_ID", "SPOT_TARGET_ID", "LINK_COST", "DIRECTIONAL_CHANGE_RATE", "SPEED", "DISPLACEMENT", "EDGE_TIME", "EDGE_X_LOCATION", "EDGE_Y_LOCATION", "EDGE_Z_LOCATION"};
< 
<          for(int i = 0; i < edgeItems.length; ++i) {
<             SPTBatch_.this.comboLinkX.addItem(edgeItems[i]);
<             SPTBatch_.this.comboLinkY.addItem(edgeItems[i]);
<          }
< 
<          panelLinkX.setLayout(new FlowLayout(0));
<          panelLinkX.add(Box.createVerticalStrut(10));
<          panelLinkX.add(xLink);
<          panelLinkX.add(Box.createVerticalStrut(5));
<          panelLinkX.add(SPTBatch_.this.comboLinkX);
<          panelLinkY.add(yLink);
<          panelLinkY.add(Box.createVerticalStrut(5));
<          panelLinkY.add(SPTBatch_.this.comboLinkY);
<          panel2.setLayout(new BoxLayout(panel2, 1));
<          panel2.add(panelLinkX);
<          panel2.add(panelLinkY);
<          JPanel panelELP = new JPanel(new FlowLayout(1));
<          panelELP.setBorder(BorderFactory.createLoweredBevelBorder());
<          SPTBatch_.ELP = new JCheckBox("  Export User-Defined Links Plot.");
<          panelELP.add(SPTBatch_.ELP);
<          panel2.add(Box.createVerticalStrut(15));
<          panel2.add(panelELP);
<          panel2.setBorder(BorderFactory.createTitledBorder(""));
<          tabbedPane.addTab("Links", iconLinkCell, panel2, "Select the  X-Y Link features to plot.");
<          tabbedPane.setMnemonicAt(1, 50);
<          JComponent panel3 = SPTBatch_.this.makeTextPanel("");
<          JComponent panelTrackX = SPTBatch_.this.makeTextPanel("");
<          JComponent panelTrackY = SPTBatch_.this.makeTextPanel("");
<          panelTrackX.setLayout(new FlowLayout(0));
<          panelTrackY.setLayout(new FlowLayout(0));
<          JLabel xTrack = new JLabel();
<          xTrack.setText(" Track-Feature for X axis:   ");
<          xTrack.setFont(new Font("Verdana", 1, 12));
<          JLabel yTrack = new JLabel();
<          yTrack.setText(" Track-Feature for Y axis:   ");
<          yTrack.setFont(new Font("Verdana", 1, 12));
<          SPTBatch_.this.comboTrackX = new JComboBox();
<          SPTBatch_.this.comboTrackY = new JComboBox();
<          Object[] trackItems = null;
<          trackItems = new Object[]{"TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE"};
< 
<          for(int ix = 0; ix < trackItems.length; ++ix) {
<             SPTBatch_.this.comboTrackX.addItem(trackItems[ix]);
<             SPTBatch_.this.comboTrackY.addItem(trackItems[ix]);
<          }
< 
<          panelTrackX.setLayout(new FlowLayout(0));
<          panelTrackX.add(Box.createVerticalStrut(10));
<          panelTrackX.add(xTrack);
<          panelTrackX.add(Box.createVerticalStrut(5));
<          panelTrackX.add(SPTBatch_.this.comboTrackX);
<          panelTrackY.add(yTrack);
<          panelTrackY.add(Box.createVerticalStrut(5));
<          panelTrackY.add(SPTBatch_.this.comboTrackY);
<          panel3.setLayout(new BoxLayout(panel3, 1));
<          panel3.add(panelTrackX);
<          panel3.add(panelTrackY);
<          JPanel panelETP = new JPanel(new FlowLayout(1));
<          panelETP.setBorder(BorderFactory.createLoweredBevelBorder());
<          SPTBatch_.ETP = new JCheckBox("  Export User-Defined Tracks Plot.");
<          panelETP.add(SPTBatch_.ETP);
<          panel3.add(Box.createVerticalStrut(15));
<          panel3.add(panelETP);
<          panel3.setBorder(BorderFactory.createTitledBorder(""));
<          tabbedPane.addTab("Tracks", iconTrackCell, panel3, "Select the  X-Y Track features to plot.");
<          tabbedPane.setMnemonicAt(2, 51);
<          tabbedPane.setPreferredSize(new java.awt.Dimension(450, 250));
<          this.add(tabbedPane);
<          tabbedPane.setTabLayoutPolicy(1);
<       }
< 
<       public void update() {
<          this.setNextButtonEnabled(false);
<          if (SPTBatch_.this.itemCheckPlot == 1) {
<             this.setNextButtonEnabled(false);
<          }
< 
<          this.setFinishButtonEnabled(true);
<          this.setBackButtonEnabled(true);
<       }
< 
<       public void next() {
<       }
< 
<       public void back() {
<          this.switchPanel(0);
<       }
< 
<       public void finish() {
<          this.switchPanel(2);
<       }
<    }
< 
<    private static class NSpotPerFrameDataset extends ModelDataset {
<       private static final long serialVersionUID = 1L;
<       private final double[] time;
<       private final int[] nspots;
< 
<       public NSpotPerFrameDataset(Model model, SelectionModel selectionModel, DisplaySettings ds, double[] time, int[] nspots) {
<          super(model, selectionModel, ds, "POSITION_T", Collections.singletonList("N spots"));
<          this.time = time;
<          this.nspots = nspots;
<       }
< 
<       public int getItemCount(int series) {
<          return this.nspots.length;
<       }
< 
<       public Number getX(int series, int item) {
<          return this.time[item];
<       }
< 
<       public Number getY(int series, int item) {
<          return (double)this.nspots[item];
<       }
< 
<       public String getSeriesKey(int series) {
<          return (String)this.yFeatures.get(series);
<       }
< 
<       public String getItemLabel(int item) {
<          return "" + item;
<       }
< 
<       public void setItemLabel(int item, String label) {
<       }
< 
<       public XYItemRenderer getRenderer() {
<          return new XYLineAndShapeRenderer(true, true);
<       }
<    }
< 
<    class OptionWizardPanel extends SPTBatch_.LabelWizardPanel {
<       public OptionWizardPanel(JWizardComponents wizardComponents, String option) {
<          super(wizardComponents, "");
<          this.setPanelTitle("  Check options to export Tracking results");
<       }
< 
<       public void update1() {
<          this.setNextButtonEnabled(false);
<          this.setFinishButtonEnabled(true);
<          this.setBackButtonEnabled(true);
<       }
< 
<       public void next() {
<          this.switchPanel(4);
<       }
< 
<       public void back() {
<          this.switchPanel(1);
<          if (SPTBatch_.this.itemCheckPlot == 1) {
<             this.switchPanel(4);
<          }
< 
<          if (SPTBatch_.this.itemPlot2 == 1) {
<             this.switchPanel(4);
<          }
< 
<          if (SPTBatch_.this.itemPlot2 == 1 && SPTBatch_.this.itemCheckPlot == 1) {
<             this.switchPanel(4);
<          }
< 
<       }
< 
<       public void finish() {
<          this.switchPanel(2);
<       }
<    }
< }
diff -r TrackAnalyzer_/STScatterPlot.java procyon/STScatterPlot.java
1,13c1,2
< import java.awt.BasicStroke;
< import java.awt.Color;
< import java.awt.Dimension;
< import java.awt.Font;
< import java.awt.Paint;
< import java.awt.Shape;
< import java.util.ArrayList;
< import java.util.Collections;
< import java.util.List;
< import javax.swing.JLabel;
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.JFreeChart;
---
> import org.jfree.chart.annotations.XYAnnotation;
> import org.jfree.chart.title.Title;
15,23d3
< import org.jfree.chart.axis.NumberAxis;
< import org.jfree.chart.block.BlockBorder;
< import org.jfree.chart.plot.DefaultDrawingSupplier;
< import org.jfree.chart.plot.IntervalMarker;
< import org.jfree.chart.plot.PlotOrientation;
< import org.jfree.chart.plot.XYPlot;
< import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
< import org.jfree.chart.title.TextTitle;
< import org.jfree.chart.ui.HorizontalAlignment;
26,27c6,9
< import org.jfree.data.function.Function2D;
< import org.jfree.data.function.LineFunction2D;
---
> import org.jfree.chart.block.BlockFrame;
> import org.jfree.chart.block.BlockBorder;
> import org.jfree.chart.ui.HorizontalAlignment;
> import org.jfree.chart.title.TextTitle;
28a11,20
> import java.awt.Shape;
> import org.jfree.data.function.Function2D;
> import org.jfree.chart.axis.NumberAxis;
> import java.awt.Stroke;
> import java.awt.BasicStroke;
> import javax.swing.JLabel;
> import java.util.ArrayList;
> import java.awt.geom.Ellipse2D;
> import org.jfree.chart.renderer.xy.XYItemRenderer;
> import org.jfree.chart.plot.PlotOrientation;
29a22
> import org.jfree.data.function.LineFunction2D;
31c24,34
< import org.jfree.data.xy.XYDataset;
---
> import java.util.Collection;
> import java.util.Collections;
> import org.jfree.chart.JFreeChart;
> import java.awt.Font;
> import org.jfree.chart.plot.Marker;
> import java.awt.Dimension;
> import org.jfree.chart.plot.DrawingSupplier;
> import org.jfree.chart.plot.DefaultDrawingSupplier;
> import java.awt.Paint;
> import org.jfree.chart.ChartFactory;
> import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
32a36,37
> import org.jfree.chart.ChartPanel;
> import org.jfree.chart.plot.XYPlot;
33a39,42
> import java.awt.Color;
> import org.jfree.chart.plot.IntervalMarker;
> import java.util.List;
> import org.jfree.data.xy.XYDataset;
36,145c45,154
< public class STScatterPlot extends ApplicationFrame {
<    private XYDataset data1;
<    List<Double> valuesDomain;
<    List<Double> valuesRange;
<    IntervalMarker markerRange;
<    IntervalMarker markerDomain;
<    String domainName;
<    String rangeName;
<    Object[][] data;
<    Color[] classColor;
<    String label1;
<    String label2;
<    XYSeriesCollection dataset;
<    static XYPlot plot;
<    ChartPanel panel;
<    XYSeries series1;
<    XYLineAndShapeRenderer renderer;
<    double maxDomain;
<    int filterOrder;
< 
<    public STScatterPlot(String title) {
<       super(title);
<    }
< 
<    public ChartPanel createChartPanelPolynomial() {
<       return null;
<    }
< 
<    public ChartPanel createScatterChartPanelInitial(String label1, String label2, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] dataCh2, Double[][] dataCh3) {
<       this.label1 = label1;
<       this.label2 = label2;
<       this.valuesDomain = valuesDomain;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.dataset = new XYSeriesCollection();
<       XYSeries series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(series1);
<       JFreeChart chart = ChartFactory.createScatterPlot("", "", "", this.dataset);
<       plot = (XYPlot)chart.getPlot();
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       this.panel = new ChartPanel(chart, false);
<       this.panel.setMaximumDrawWidth(4000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setVisible(false);
<       this.panel.setMouseWheelEnabled(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       Font font3 = new Font("Dialog", 2, 9);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       return this.panel;
<    }
< 
<    public void addScatterPlotSeriesLinear(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
<       this.valuesDomain = valuesDomain;
<       this.rangeName = rangeName;
<       this.domainName = domainName;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.classColor = classColor;
<       this.panel.removeAll();
<       this.dataset = new XYSeriesCollection();
<       this.series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(this.series1);
<       double minDomain = (Double)Collections.min(valuesDomain);
<       double maxDomain = (Double)Collections.max(valuesDomain);
<       double[] coefficients = Regression.getOLSRegression(this.dataset, 0);
<       Function2D curve = new LineFunction2D(coefficients[0], coefficients[1]);
<       XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), "Fitted Regression Line");
<       JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       plot = (XYPlot)chart.getPlot();
<       XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
<       plot.setRenderer(renderer1);
<       plot.setBackgroundPaint(new Color(255, 228, 196));
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       plot.setDataset(1, regressionData);
<       XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
<       renderer2.setSeriesPaint(0, Color.RED);
<       plot.setRenderer(1, renderer2);
<       Shape cross = new java.awt.geom.Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
<       List<String[]> featureLists = new ArrayList();
< 
<       for(int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
<          featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(i, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
<       }
< 
<       this.renderer = new XYLineAndShapeRenderer() {
<          public Paint getItemPaint(int row, int col) {
<             Paint cpaint = this.getItemColor(row, col);
<             if (cpaint == null) {
<                cpaint = super.getItemPaint(row, col);
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class STScatterPlot extends ApplicationFrame
> {
>     private XYDataset data1;
>     List<Double> valuesDomain;
>     List<Double> valuesRange;
>     IntervalMarker markerRange;
>     IntervalMarker markerDomain;
>     String domainName;
>     String rangeName;
>     Object[][] data;
>     Color[] classColor;
>     String label1;
>     String label2;
>     XYSeriesCollection dataset;
>     static XYPlot plot;
>     ChartPanel panel;
>     XYSeries series1;
>     XYLineAndShapeRenderer renderer;
>     double maxDomain;
>     int filterOrder;
>     
>     public STScatterPlot(final String title) {
>         super(title);
>     }
>     
>     public ChartPanel createChartPanelPolynomial() {
>         return null;
>     }
>     
>     public ChartPanel createScatterChartPanelInitial(final String label1, final String label2, final List<Double> valuesDomain, final List<Double> valuesRange, final IntervalMarker markerRange, final IntervalMarker markerDomain, final Object[][] dataCh2, final Double[][] dataCh3) {
>         this.label1 = label1;
>         this.label2 = label2;
>         this.valuesDomain = valuesDomain;
>         this.valuesRange = valuesRange;
>         this.markerRange = markerRange;
>         this.markerDomain = markerDomain;
>         this.dataset = new XYSeriesCollection();
>         final XYSeries series1 = new XYSeries((Comparable)"");
>         for (int i = 0; i < valuesDomain.size(); ++i) {
>             series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
>         }
>         this.dataset.addSeries(series1);
>         final JFreeChart chart = ChartFactory.createScatterPlot("", "", "", (XYDataset)this.dataset);
>         STScatterPlot.plot = (XYPlot)chart.getPlot();
>         final Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
>         STScatterPlot.plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
>         (this.panel = new ChartPanel(chart, false)).setMaximumDrawWidth(4000);
>         this.panel.setPreferredSize(new Dimension(450, 300));
>         chart.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         STScatterPlot.plot.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         chart.getLegend().setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         chart.getLegend().setVisible(false);
>         this.panel.setMouseWheelEnabled(true);
>         STScatterPlot.plot.addRangeMarker((Marker)markerRange);
>         STScatterPlot.plot.addDomainMarker((Marker)markerDomain);
>         final Font font3 = new Font("Dialog", 2, 9);
>         STScatterPlot.plot.getDomainAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setTickLabelFont(font3);
>         STScatterPlot.plot.getDomainAxis().setTickLabelFont(font3);
>         return this.panel;
>     }
>     
>     public void addScatterPlotSeriesLinear(final String domainName, final String rangeName, final List<Double> valuesDomain, final List<Double> valuesRange, final IntervalMarker markerRange, final IntervalMarker markerDomain, final Object[][] data, final Color[] classColor) {
>         this.valuesDomain = valuesDomain;
>         this.rangeName = rangeName;
>         this.domainName = domainName;
>         this.valuesRange = valuesRange;
>         this.markerRange = markerRange;
>         this.markerDomain = markerDomain;
>         this.classColor = classColor;
>         this.panel.removeAll();
>         this.dataset = new XYSeriesCollection();
>         this.series1 = new XYSeries((Comparable)"");
>         for (int i = 0; i < valuesDomain.size(); ++i) {
>             this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
>         }
>         this.dataset.addSeries(this.series1);
>         final double minDomain = Collections.<Double>min((Collection<? extends Double>)valuesDomain);
>         final double maxDomain = Collections.<Double>max((Collection<? extends Double>)valuesDomain);
>         final double[] coefficients = Regression.getOLSRegression((XYDataset)this.dataset, 0);
>         final Function2D curve = (Function2D)new LineFunction2D(coefficients[0], coefficients[1]);
>         final XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), (Comparable)"Fitted Regression Line");
>         final JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, (XYDataset)this.dataset, PlotOrientation.VERTICAL, true, true, false);
>         STScatterPlot.plot = (XYPlot)chart.getPlot();
>         final XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
>         STScatterPlot.plot.setRenderer((XYItemRenderer)renderer1);
>         STScatterPlot.plot.setBackgroundPaint((Paint)new Color(255, 228, 196));
>         final Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
>         STScatterPlot.plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
>         STScatterPlot.plot.setDataset(1, regressionData);
>         final XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
>         renderer2.setSeriesPaint(0, (Paint)Color.RED);
>         STScatterPlot.plot.setRenderer(1, (XYItemRenderer)renderer2);
>         final Shape cross = new Ellipse2D.Double(0.0, 0.0, 5.0, 5.0);
>         final List<String[]> featureLists = new ArrayList<String[]>();
>         for (int j = 0; j < ColorEditorSpot.tableC.getModel().getRowCount(); ++j) {
>             featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(j, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
>         }
>         this.renderer = new XYLineAndShapeRenderer() {
>             public Paint getItemPaint(final int row, final int col) {
>                 Paint cpaint = this.getItemColor(row, col);
>                 if (cpaint == null) {
>                     cpaint = super.getItemPaint(row, col);
>                 }
>                 return cpaint;
147,241c156,165
< 
<             return (Paint)cpaint;
<          }
< 
<          public Color getItemColor(int row, int col) {
<             STScatterPlot.this.dataset.getXValue(row, col);
<             STScatterPlot.this.dataset.getYValue(row, col);
< 
<             try {
<                return classColor[col];
<             } catch (Exception var8) {
<                return null;
<             }
<          }
<       };
<       plot.setRenderer(this.renderer);
<       this.renderer.setUseOutlinePaint(true);
<       this.renderer.setSeriesShape(0, cross);
<       this.renderer.setSeriesOutlinePaint(0, Color.black);
<       this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
<       this.renderer.setSeriesLinesVisible(0, false);
<       this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
<       plot.getRangeCrosshairValue();
<       plot.getDomainCrosshairValue();
<       this.panel.setChart(chart);
<       this.panel.setMaximumDrawWidth(6000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       this.panel.setMouseWheelEnabled(true);
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       markerRange.setLabel("Low-High");
<       markerRange.setLabelFont(new Font("SansSerif", 0, 15));
<       markerRange.setLabelPaint(new Color(0, 102, 0));
<       Font font3 = new Font("Dialog", 1, 12);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       NumberAxis domain = (NumberAxis)plot.getDomainAxis();
<       NumberAxis range = (NumberAxis)plot.getRangeAxis();
<       domain.setAutoRange(true);
<       range.setAutoRange(true);
<       this.computeLinearCoefficients(chart, plot, this.dataset);
<    }
< 
<    public void addScatterPlotSeriesPower(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
<       this.valuesDomain = valuesDomain;
<       this.rangeName = rangeName;
<       this.domainName = domainName;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.classColor = classColor;
<       this.panel.removeAll();
<       this.dataset = new XYSeriesCollection();
<       this.series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(this.series1);
<       double minDomain = (Double)Collections.min(valuesDomain);
<       double maxDomain = (Double)Collections.max(valuesDomain);
<       double[] coefficients = Regression.getPowerRegression(this.dataset, 0);
<       Function2D curve = new PowerFunction2D(coefficients[0], coefficients[1]);
<       XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), "Fitted Regression Line");
<       JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       plot = (XYPlot)chart.getPlot();
<       XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
<       plot.setRenderer(renderer1);
<       plot.setBackgroundPaint(new Color(255, 228, 196));
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       plot.setDataset(1, regressionData);
<       XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
<       renderer2.setSeriesPaint(0, Color.RED);
<       plot.setRenderer(1, renderer2);
<       Shape cross = new java.awt.geom.Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
<       List<String[]> featureLists = new ArrayList();
< 
<       for(int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
<          featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(i, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
<       }
< 
<       this.renderer = new XYLineAndShapeRenderer() {
<          public Paint getItemPaint(int row, int col) {
<             Paint cpaint = this.getItemColor(row, col);
<             if (cpaint == null) {
<                cpaint = super.getItemPaint(row, col);
---
>             
>             public Color getItemColor(final int row, final int col) {
>                 final double x = STScatterPlot.this.dataset.getXValue(row, col);
>                 final double y = STScatterPlot.this.dataset.getYValue(row, col);
>                 try {
>                     return classColor[col];
>                 }
>                 catch (Exception ex) {
>                     return null;
>                 }
243,337c167,245
< 
<             return (Paint)cpaint;
<          }
< 
<          public Color getItemColor(int row, int col) {
<             STScatterPlot.this.dataset.getXValue(row, col);
<             STScatterPlot.this.dataset.getYValue(row, col);
< 
<             try {
<                return classColor[col];
<             } catch (Exception var8) {
<                return null;
<             }
<          }
<       };
<       plot.setRenderer(this.renderer);
<       this.renderer.setUseOutlinePaint(true);
<       this.renderer.setSeriesShape(0, cross);
<       this.renderer.setSeriesOutlinePaint(0, Color.black);
<       this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
<       this.renderer.setSeriesLinesVisible(0, false);
<       this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
<       plot.getRangeCrosshairValue();
<       plot.getDomainCrosshairValue();
<       this.panel.setChart(chart);
<       this.panel.setMaximumDrawWidth(6000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       markerRange.setLabel("Low-High");
<       markerRange.setLabelFont(new Font("SansSerif", 0, 15));
<       markerRange.setLabelPaint(new Color(0, 102, 0));
<       Font font3 = new Font("Dialog", 1, 12);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       NumberAxis domain = (NumberAxis)plot.getDomainAxis();
<       NumberAxis range = (NumberAxis)plot.getRangeAxis();
<       domain.setAutoRange(true);
<       range.setAutoRange(true);
<       this.computePowerCoefficients(chart, plot, this.dataset);
<    }
< 
<    public void addScatterPlotSeriesPolynomial(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor, int filterOrder) {
<       this.valuesDomain = valuesDomain;
<       this.rangeName = rangeName;
<       this.domainName = domainName;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.classColor = classColor;
<       this.filterOrder = filterOrder;
<       this.panel.removeAll();
<       this.dataset = new XYSeriesCollection();
<       this.series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(this.series1);
<       double minDomain = (Double)Collections.min(valuesDomain);
<       double maxDomain = (Double)Collections.max(valuesDomain);
<       double[] coefficients = Regression.getPolynomialRegression(this.dataset, 0, filterOrder);
<       Function2D curve = new PowerFunction2D(coefficients[0], coefficients[1]);
<       XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), "Fitted Regression Line");
<       JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       plot = (XYPlot)chart.getPlot();
<       XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
<       plot.setRenderer(renderer1);
<       plot.setBackgroundPaint(new Color(255, 228, 196));
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       plot.setDataset(1, regressionData);
<       XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
<       renderer2.setSeriesPaint(0, Color.RED);
<       plot.setRenderer(1, renderer2);
<       Shape cross = new java.awt.geom.Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
<       List<String[]> featureLists = new ArrayList();
< 
<       for(int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
<          featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(i, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
<       }
< 
<       this.renderer = new XYLineAndShapeRenderer() {
<          public Paint getItemPaint(int row, int col) {
<             Paint cpaint = this.getItemColor(row, col);
<             if (cpaint == null) {
<                cpaint = super.getItemPaint(row, col);
---
>         };
>         STScatterPlot.plot.setRenderer((XYItemRenderer)this.renderer);
>         this.renderer.setUseOutlinePaint(true);
>         this.renderer.setSeriesShape(0, cross);
>         this.renderer.setSeriesOutlinePaint(0, (Paint)Color.black);
>         this.renderer.setSeriesOutlineStroke(0, (Stroke)new BasicStroke(1.0f));
>         this.renderer.setSeriesLinesVisible(0, false);
>         this.renderer.setSeriesPaint(0, (Paint)Color.LIGHT_GRAY);
>         STScatterPlot.plot.getRangeCrosshairValue();
>         STScatterPlot.plot.getDomainCrosshairValue();
>         this.panel.setChart(chart);
>         this.panel.setMaximumDrawWidth(6000);
>         this.panel.setPreferredSize(new Dimension(450, 300));
>         this.panel.setMouseWheelEnabled(true);
>         chart.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         STScatterPlot.plot.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         chart.getLegend().setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         this.panel.setMouseWheelEnabled(true);
>         chart.getLegend().setVisible(true);
>         STScatterPlot.plot.addRangeMarker((Marker)markerRange);
>         STScatterPlot.plot.addDomainMarker((Marker)markerDomain);
>         markerRange.setLabel("Low-High");
>         markerRange.setLabelFont(new Font("SansSerif", 0, 15));
>         markerRange.setLabelPaint((Paint)new Color(0, 102, 0));
>         final Font font3 = new Font("Dialog", 1, 12);
>         STScatterPlot.plot.getDomainAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setTickLabelFont(font3);
>         STScatterPlot.plot.getDomainAxis().setTickLabelFont(font3);
>         final NumberAxis domain = (NumberAxis)STScatterPlot.plot.getDomainAxis();
>         final NumberAxis range = (NumberAxis)STScatterPlot.plot.getRangeAxis();
>         domain.setAutoRange(true);
>         range.setAutoRange(true);
>         this.computeLinearCoefficients(chart, STScatterPlot.plot, this.dataset);
>     }
>     
>     public void addScatterPlotSeriesPower(final String domainName, final String rangeName, final List<Double> valuesDomain, final List<Double> valuesRange, final IntervalMarker markerRange, final IntervalMarker markerDomain, final Object[][] data, final Color[] classColor) {
>         this.valuesDomain = valuesDomain;
>         this.rangeName = rangeName;
>         this.domainName = domainName;
>         this.valuesRange = valuesRange;
>         this.markerRange = markerRange;
>         this.markerDomain = markerDomain;
>         this.classColor = classColor;
>         this.panel.removeAll();
>         this.dataset = new XYSeriesCollection();
>         this.series1 = new XYSeries((Comparable)"");
>         for (int i = 0; i < valuesDomain.size(); ++i) {
>             this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
>         }
>         this.dataset.addSeries(this.series1);
>         final double minDomain = Collections.<Double>min((Collection<? extends Double>)valuesDomain);
>         final double maxDomain = Collections.<Double>max((Collection<? extends Double>)valuesDomain);
>         final double[] coefficients = Regression.getPowerRegression((XYDataset)this.dataset, 0);
>         final Function2D curve = (Function2D)new PowerFunction2D(coefficients[0], coefficients[1]);
>         final XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), (Comparable)"Fitted Regression Line");
>         final JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, (XYDataset)this.dataset, PlotOrientation.VERTICAL, true, true, false);
>         STScatterPlot.plot = (XYPlot)chart.getPlot();
>         final XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
>         STScatterPlot.plot.setRenderer((XYItemRenderer)renderer1);
>         STScatterPlot.plot.setBackgroundPaint((Paint)new Color(255, 228, 196));
>         final Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
>         STScatterPlot.plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
>         STScatterPlot.plot.setDataset(1, regressionData);
>         final XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
>         renderer2.setSeriesPaint(0, (Paint)Color.RED);
>         STScatterPlot.plot.setRenderer(1, (XYItemRenderer)renderer2);
>         final Shape cross = new Ellipse2D.Double(0.0, 0.0, 5.0, 5.0);
>         final List<String[]> featureLists = new ArrayList<String[]>();
>         for (int j = 0; j < ColorEditorSpot.tableC.getModel().getRowCount(); ++j) {
>             featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(j, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
>         }
>         this.renderer = new XYLineAndShapeRenderer() {
>             public Paint getItemPaint(final int row, final int col) {
>                 Paint cpaint = this.getItemColor(row, col);
>                 if (cpaint == null) {
>                     cpaint = super.getItemPaint(row, col);
>                 }
>                 return cpaint;
339,433c247,256
< 
<             return (Paint)cpaint;
<          }
< 
<          public Color getItemColor(int row, int col) {
<             STScatterPlot.this.dataset.getXValue(row, col);
<             STScatterPlot.this.dataset.getYValue(row, col);
< 
<             try {
<                return classColor[col];
<             } catch (Exception var8) {
<                return null;
<             }
<          }
<       };
<       plot.setRenderer(this.renderer);
<       this.renderer.setUseOutlinePaint(true);
<       this.renderer.setSeriesShape(0, cross);
<       this.renderer.setSeriesOutlinePaint(0, Color.black);
<       this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
<       this.renderer.setSeriesLinesVisible(0, false);
<       this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
<       plot.getRangeCrosshairValue();
<       plot.getDomainCrosshairValue();
<       this.panel.setChart(chart);
<       this.panel.setMaximumDrawWidth(6000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       markerRange.setLabel("Low-High");
<       markerRange.setLabelFont(new Font("SansSerif", 0, 15));
<       markerRange.setLabelPaint(new Color(0, 102, 0));
<       Font font3 = new Font("Dialog", 1, 12);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       NumberAxis domain = (NumberAxis)plot.getDomainAxis();
<       NumberAxis range = (NumberAxis)plot.getRangeAxis();
<       domain.setAutoRange(true);
<       range.setAutoRange(true);
<       this.computePolynomialCoefficients(chart, plot, this.dataset, filterOrder);
<    }
< 
<    public void addScatterPlotSeriesLogarithmic(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
<       this.valuesDomain = valuesDomain;
<       this.rangeName = rangeName;
<       this.domainName = domainName;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.classColor = classColor;
<       this.filterOrder = this.filterOrder;
<       this.panel.removeAll();
<       this.dataset = new XYSeriesCollection();
<       this.series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(this.series1);
<       double minDomain = (Double)Collections.min(valuesDomain);
<       double maxDomain = (Double)Collections.max(valuesDomain);
<       double[] coefficients = RegressionLE_.getLogarithmicRegression(this.dataset, 0);
<       Function2D curve = new LogarithmicFunction2D(coefficients[0], coefficients[1]);
<       XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), "Fitted Regression Line");
<       JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       plot = (XYPlot)chart.getPlot();
<       XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
<       plot.setRenderer(renderer1);
<       plot.setBackgroundPaint(new Color(255, 228, 196));
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       plot.setDataset(1, regressionData);
<       XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
<       renderer2.setSeriesPaint(0, Color.RED);
<       plot.setRenderer(1, renderer2);
<       Shape cross = new java.awt.geom.Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
<       List<String[]> featureLists = new ArrayList();
< 
<       for(int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
<          featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(i, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
<       }
< 
<       this.renderer = new XYLineAndShapeRenderer() {
<          public Paint getItemPaint(int row, int col) {
<             Paint cpaint = this.getItemColor(row, col);
<             if (cpaint == null) {
<                cpaint = super.getItemPaint(row, col);
---
>             
>             public Color getItemColor(final int row, final int col) {
>                 final double x = STScatterPlot.this.dataset.getXValue(row, col);
>                 final double y = STScatterPlot.this.dataset.getYValue(row, col);
>                 try {
>                     return classColor[col];
>                 }
>                 catch (Exception ex) {
>                     return null;
>                 }
435,529c258,336
< 
<             return (Paint)cpaint;
<          }
< 
<          public Color getItemColor(int row, int col) {
<             STScatterPlot.this.dataset.getXValue(row, col);
<             STScatterPlot.this.dataset.getYValue(row, col);
< 
<             try {
<                return classColor[col];
<             } catch (Exception var8) {
<                return null;
<             }
<          }
<       };
<       plot.setRenderer(this.renderer);
<       this.renderer.setUseOutlinePaint(true);
<       this.renderer.setSeriesShape(0, cross);
<       this.renderer.setSeriesOutlinePaint(0, Color.black);
<       this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
<       this.renderer.setSeriesLinesVisible(0, false);
<       this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
<       plot.getRangeCrosshairValue();
<       plot.getDomainCrosshairValue();
<       this.panel.setChart(chart);
<       this.panel.setMaximumDrawWidth(6000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       markerRange.setLabel("Low-High");
<       markerRange.setLabelFont(new Font("SansSerif", 0, 15));
<       markerRange.setLabelPaint(new Color(0, 102, 0));
<       Font font3 = new Font("Dialog", 1, 12);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       NumberAxis domain = (NumberAxis)plot.getDomainAxis();
<       NumberAxis range = (NumberAxis)plot.getRangeAxis();
<       domain.setAutoRange(true);
<       range.setAutoRange(true);
<       this.computeLogarithmicCoefficients(chart, plot, this.dataset, this.filterOrder);
<    }
< 
<    public void addScatterPlotSeriesExponential(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
<       this.valuesDomain = valuesDomain;
<       this.rangeName = rangeName;
<       this.domainName = domainName;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.classColor = classColor;
<       this.filterOrder = this.filterOrder;
<       this.panel.removeAll();
<       this.dataset = new XYSeriesCollection();
<       this.series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(this.series1);
<       double minDomain = (Double)Collections.min(valuesDomain);
<       double maxDomain = (Double)Collections.max(valuesDomain);
<       double[] coefficients = RegressionLE_.getExponentialRegression(this.dataset, 0);
<       Function2D curve = new ExponentialFunction2D(coefficients[0], coefficients[1]);
<       XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), "Fitted Regression Line");
<       JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       plot = (XYPlot)chart.getPlot();
<       XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
<       plot.setRenderer(renderer1);
<       plot.setBackgroundPaint(new Color(255, 228, 196));
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       plot.setDataset(1, regressionData);
<       XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
<       renderer2.setSeriesPaint(0, Color.RED);
<       plot.setRenderer(1, renderer2);
<       Shape cross = new java.awt.geom.Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
<       List<String[]> featureLists = new ArrayList();
< 
<       for(int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
<          featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(i, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
<       }
< 
<       this.renderer = new XYLineAndShapeRenderer() {
<          public Paint getItemPaint(int row, int col) {
<             Paint cpaint = this.getItemColor(row, col);
<             if (cpaint == null) {
<                cpaint = super.getItemPaint(row, col);
---
>         };
>         STScatterPlot.plot.setRenderer((XYItemRenderer)this.renderer);
>         this.renderer.setUseOutlinePaint(true);
>         this.renderer.setSeriesShape(0, cross);
>         this.renderer.setSeriesOutlinePaint(0, (Paint)Color.black);
>         this.renderer.setSeriesOutlineStroke(0, (Stroke)new BasicStroke(1.0f));
>         this.renderer.setSeriesLinesVisible(0, false);
>         this.renderer.setSeriesPaint(0, (Paint)Color.LIGHT_GRAY);
>         STScatterPlot.plot.getRangeCrosshairValue();
>         STScatterPlot.plot.getDomainCrosshairValue();
>         this.panel.setChart(chart);
>         this.panel.setMaximumDrawWidth(6000);
>         this.panel.setPreferredSize(new Dimension(450, 300));
>         chart.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         STScatterPlot.plot.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         chart.getLegend().setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         this.panel.setMouseWheelEnabled(true);
>         chart.getLegend().setVisible(true);
>         STScatterPlot.plot.addRangeMarker((Marker)markerRange);
>         STScatterPlot.plot.addDomainMarker((Marker)markerDomain);
>         markerRange.setLabel("Low-High");
>         markerRange.setLabelFont(new Font("SansSerif", 0, 15));
>         markerRange.setLabelPaint((Paint)new Color(0, 102, 0));
>         final Font font3 = new Font("Dialog", 1, 12);
>         STScatterPlot.plot.getDomainAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setTickLabelFont(font3);
>         STScatterPlot.plot.getDomainAxis().setTickLabelFont(font3);
>         final NumberAxis domain = (NumberAxis)STScatterPlot.plot.getDomainAxis();
>         final NumberAxis range = (NumberAxis)STScatterPlot.plot.getRangeAxis();
>         domain.setAutoRange(true);
>         range.setAutoRange(true);
>         this.computePowerCoefficients(chart, STScatterPlot.plot, this.dataset);
>     }
>     
>     public void addScatterPlotSeriesPolynomial(final String domainName, final String rangeName, final List<Double> valuesDomain, final List<Double> valuesRange, final IntervalMarker markerRange, final IntervalMarker markerDomain, final Object[][] data, final Color[] classColor, final int filterOrder) {
>         this.valuesDomain = valuesDomain;
>         this.rangeName = rangeName;
>         this.domainName = domainName;
>         this.valuesRange = valuesRange;
>         this.markerRange = markerRange;
>         this.markerDomain = markerDomain;
>         this.classColor = classColor;
>         this.filterOrder = filterOrder;
>         this.panel.removeAll();
>         this.dataset = new XYSeriesCollection();
>         this.series1 = new XYSeries((Comparable)"");
>         for (int i = 0; i < valuesDomain.size(); ++i) {
>             this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
>         }
>         this.dataset.addSeries(this.series1);
>         final double minDomain = Collections.<Double>min((Collection<? extends Double>)valuesDomain);
>         final double maxDomain = Collections.<Double>max((Collection<? extends Double>)valuesDomain);
>         final double[] coefficients = Regression.getPolynomialRegression((XYDataset)this.dataset, 0, filterOrder);
>         final Function2D curve = (Function2D)new PowerFunction2D(coefficients[0], coefficients[1]);
>         final XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), (Comparable)"Fitted Regression Line");
>         final JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, (XYDataset)this.dataset, PlotOrientation.VERTICAL, true, true, false);
>         STScatterPlot.plot = (XYPlot)chart.getPlot();
>         final XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
>         STScatterPlot.plot.setRenderer((XYItemRenderer)renderer1);
>         STScatterPlot.plot.setBackgroundPaint((Paint)new Color(255, 228, 196));
>         final Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
>         STScatterPlot.plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
>         STScatterPlot.plot.setDataset(1, regressionData);
>         final XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
>         renderer2.setSeriesPaint(0, (Paint)Color.RED);
>         STScatterPlot.plot.setRenderer(1, (XYItemRenderer)renderer2);
>         final Shape cross = new Ellipse2D.Double(0.0, 0.0, 5.0, 5.0);
>         final List<String[]> featureLists = new ArrayList<String[]>();
>         for (int j = 0; j < ColorEditorSpot.tableC.getModel().getRowCount(); ++j) {
>             featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(j, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
>         }
>         this.renderer = new XYLineAndShapeRenderer() {
>             public Paint getItemPaint(final int row, final int col) {
>                 Paint cpaint = this.getItemColor(row, col);
>                 if (cpaint == null) {
>                     cpaint = super.getItemPaint(row, col);
>                 }
>                 return cpaint;
531,709c338,572
< 
<             return (Paint)cpaint;
<          }
< 
<          public Color getItemColor(int row, int col) {
<             STScatterPlot.this.dataset.getXValue(row, col);
<             STScatterPlot.this.dataset.getYValue(row, col);
< 
<             try {
<                return classColor[col];
<             } catch (Exception var8) {
<                return null;
<             }
<          }
<       };
<       plot.setRenderer(this.renderer);
<       this.renderer.setUseOutlinePaint(true);
<       this.renderer.setSeriesShape(0, cross);
<       this.renderer.setSeriesOutlinePaint(0, Color.black);
<       this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
<       this.renderer.setSeriesLinesVisible(0, false);
<       this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
<       plot.getRangeCrosshairValue();
<       plot.getDomainCrosshairValue();
<       this.panel.setChart(chart);
<       this.panel.setMaximumDrawWidth(6000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       markerRange.setLabel("Low-High");
<       markerRange.setLabelFont(new Font("SansSerif", 0, 15));
<       markerRange.setLabelPaint(new Color(0, 102, 0));
<       Font font3 = new Font("Dialog", 1, 12);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       NumberAxis domain = (NumberAxis)plot.getDomainAxis();
<       NumberAxis range = (NumberAxis)plot.getRangeAxis();
<       domain.setAutoRange(true);
<       range.setAutoRange(true);
<       this.computeExponentialCoefficients(chart, plot, this.dataset, this.filterOrder);
<    }
< 
<    private void computeLinearCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset) {
<       Function2D retVal = null;
<       double r2 = 0.0D;
<       double[] coefficients = null;
< 
<       try {
<          coefficients = RegressionLE_.getOLSRegression(dataset, 0);
<          new LineFunction2D(coefficients[0], coefficients[1]);
<          r2 = coefficients[2];
<       } catch (Exception var15) {
<          System.err.println(var15.getMessage());
<       }
< 
<       double intercept = coefficients[0];
<       double slope = coefficients[1];
<       String linearEquation;
<       if (intercept >= 0.0D) {
<          linearEquation = "y = " + String.format("%.2f", slope) + "x + " + String.format("%.2f", intercept);
<       } else {
<          linearEquation = "y = " + String.format("%.2f", slope) + "x - " + Math.abs(intercept);
<       }
< 
<       TextTitle tt = new TextTitle(linearEquation + "\nR = " + String.format("%.2f", r2));
<       tt.setTextAlignment(HorizontalAlignment.RIGHT);
<       tt.setFont(chart.getLegend().getItemFont());
<       tt.setBackgroundPaint(new Color(200, 200, 255, 100));
<       tt.setFrame(new BlockBorder(Color.white));
<       tt.setPosition(RectangleEdge.BOTTOM);
<       XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, tt, RectangleAnchor.BOTTOM_RIGHT);
<       r2Annotation.setMaxWidth(0.48D);
<       plot.addAnnotation(r2Annotation);
<    }
< 
<    private void computePowerCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset) {
<       Function2D retVal = null;
<       double r2 = 0.0D;
<       double[] coefficients = null;
< 
<       try {
<          coefficients = RegressionLE_.getPowerRegression(dataset, 0);
<          if (coefficients[2] > r2) {
<             new PowerFunction2D(coefficients[0], coefficients[1]);
<             r2 = coefficients[2];
<          }
<       } catch (Exception var15) {
<          System.err.println(var15.getMessage());
<       }
< 
<       double intercept = coefficients[0];
<       double slope = coefficients[1];
<       String linearEquation;
<       if (intercept >= 0.0D) {
<          linearEquation = "y = " + String.format("%.2f", slope) + "x^ " + String.format("%.2f", intercept);
<       } else {
<          linearEquation = "y = " + String.format("%.2f", slope) + "x^ -" + Math.abs(intercept);
<       }
< 
<       TextTitle tt = new TextTitle(linearEquation + "\nR = " + String.format("%.2f", r2));
<       tt.setTextAlignment(HorizontalAlignment.RIGHT);
<       tt.setFont(chart.getLegend().getItemFont());
<       tt.setBackgroundPaint(new Color(200, 200, 255, 100));
<       tt.setFrame(new BlockBorder(Color.white));
<       tt.setPosition(RectangleEdge.BOTTOM);
<       XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, tt, RectangleAnchor.BOTTOM_RIGHT);
<       r2Annotation.setMaxWidth(0.48D);
<       plot.addAnnotation(r2Annotation);
<    }
< 
<    private void computePolynomialCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset, int filterOrder) {
<       double[] coefficients = Regression.getPolynomialRegression(dataset, 0, filterOrder);
<       double r2 = coefficients[coefficients.length - 1];
<       String polynomialEquation = "";
< 
<       for(int i = coefficients.length - 1; i >= 0; --i) {
<          if (i == 0) {
<             polynomialEquation = polynomialEquation + String.format("%.2f", coefficients[i]);
<          } else if (i == 1) {
<             polynomialEquation = polynomialEquation + String.format("%.2f", coefficients[i]) + "*x+";
<          } else if (i > 1) {
<             polynomialEquation = polynomialEquation + String.format("%.2f", coefficients[i]) + "*x^" + i + "+";
<          }
<       }
< 
<       TextTitle tt = new TextTitle("y = " + polynomialEquation + "\nR = " + String.format("%.2f", r2));
<       tt.setTextAlignment(HorizontalAlignment.RIGHT);
<       tt.setFont(chart.getLegend().getItemFont());
<       tt.setBackgroundPaint(new Color(200, 200, 255, 100));
<       tt.setFrame(new BlockBorder(Color.white));
<       tt.setPosition(RectangleEdge.BOTTOM);
<       XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, tt, RectangleAnchor.BOTTOM_RIGHT);
<       r2Annotation.setMaxWidth(0.48D);
<       plot.addAnnotation(r2Annotation);
<    }
< 
<    private void computeLogarithmicCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset, int filterOrder) {
<       Function2D retVal = null;
<       double r2 = 0.0D;
<       double[] coefficients = null;
< 
<       try {
<          coefficients = RegressionLE_.getLogarithmicRegression(dataset, 0);
<          if (coefficients[2] > r2) {
<             new LogarithmicFunction2D(coefficients[0], coefficients[1]);
<             r2 = coefficients[2];
<          }
<       } catch (Exception var12) {
<          System.err.println(var12.getMessage());
<       }
< 
<       String logarithmicEquation = "y = " + String.format("%.2f", coefficients[0]) + " + " + "( " + String.format("%.2f", coefficients[1]) + " * ln(x) ) ";
<       TextTitle tt = new TextTitle("y = " + logarithmicEquation + "\nR = " + String.format("%.2f", r2));
<       tt.setTextAlignment(HorizontalAlignment.RIGHT);
<       tt.setFont(chart.getLegend().getItemFont());
<       tt.setBackgroundPaint(new Color(200, 200, 255, 100));
<       tt.setFrame(new BlockBorder(Color.white));
<       tt.setPosition(RectangleEdge.BOTTOM);
<       XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, tt, RectangleAnchor.BOTTOM_RIGHT);
<       r2Annotation.setMaxWidth(0.48D);
<       plot.addAnnotation(r2Annotation);
<    }
< 
<    private void computeExponentialCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset, int filterOrder) {
<       Function2D retVal = null;
<       double r2 = 0.0D;
<       double[] coefficients = null;
< 
<       try {
<          coefficients = RegressionLE_.getExponentialRegression(dataset, 0);
<          if (coefficients[2] > r2) {
<             new LogarithmicFunction2D(coefficients[0], coefficients[1]);
---
>             
>             public Color getItemColor(final int row, final int col) {
>                 final double x = STScatterPlot.this.dataset.getXValue(row, col);
>                 final double y = STScatterPlot.this.dataset.getYValue(row, col);
>                 try {
>                     return classColor[col];
>                 }
>                 catch (Exception ex) {
>                     return null;
>                 }
>             }
>         };
>         STScatterPlot.plot.setRenderer((XYItemRenderer)this.renderer);
>         this.renderer.setUseOutlinePaint(true);
>         this.renderer.setSeriesShape(0, cross);
>         this.renderer.setSeriesOutlinePaint(0, (Paint)Color.black);
>         this.renderer.setSeriesOutlineStroke(0, (Stroke)new BasicStroke(1.0f));
>         this.renderer.setSeriesLinesVisible(0, false);
>         this.renderer.setSeriesPaint(0, (Paint)Color.LIGHT_GRAY);
>         STScatterPlot.plot.getRangeCrosshairValue();
>         STScatterPlot.plot.getDomainCrosshairValue();
>         this.panel.setChart(chart);
>         this.panel.setMaximumDrawWidth(6000);
>         this.panel.setPreferredSize(new Dimension(450, 300));
>         chart.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         STScatterPlot.plot.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         chart.getLegend().setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         this.panel.setMouseWheelEnabled(true);
>         chart.getLegend().setVisible(true);
>         STScatterPlot.plot.addRangeMarker((Marker)markerRange);
>         STScatterPlot.plot.addDomainMarker((Marker)markerDomain);
>         markerRange.setLabel("Low-High");
>         markerRange.setLabelFont(new Font("SansSerif", 0, 15));
>         markerRange.setLabelPaint((Paint)new Color(0, 102, 0));
>         final Font font3 = new Font("Dialog", 1, 12);
>         STScatterPlot.plot.getDomainAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setTickLabelFont(font3);
>         STScatterPlot.plot.getDomainAxis().setTickLabelFont(font3);
>         final NumberAxis domain = (NumberAxis)STScatterPlot.plot.getDomainAxis();
>         final NumberAxis range = (NumberAxis)STScatterPlot.plot.getRangeAxis();
>         domain.setAutoRange(true);
>         range.setAutoRange(true);
>         this.computePolynomialCoefficients(chart, STScatterPlot.plot, this.dataset, filterOrder);
>     }
>     
>     public void addScatterPlotSeriesLogarithmic(final String domainName, final String rangeName, final List<Double> valuesDomain, final List<Double> valuesRange, final IntervalMarker markerRange, final IntervalMarker markerDomain, final Object[][] data, final Color[] classColor) {
>         this.valuesDomain = valuesDomain;
>         this.rangeName = rangeName;
>         this.domainName = domainName;
>         this.valuesRange = valuesRange;
>         this.markerRange = markerRange;
>         this.markerDomain = markerDomain;
>         this.classColor = classColor;
>         this.filterOrder = this.filterOrder;
>         this.panel.removeAll();
>         this.dataset = new XYSeriesCollection();
>         this.series1 = new XYSeries((Comparable)"");
>         for (int i = 0; i < valuesDomain.size(); ++i) {
>             this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
>         }
>         this.dataset.addSeries(this.series1);
>         final double minDomain = Collections.<Double>min((Collection<? extends Double>)valuesDomain);
>         final double maxDomain = Collections.<Double>max((Collection<? extends Double>)valuesDomain);
>         final double[] coefficients = RegressionLE_.getLogarithmicRegression((XYDataset)this.dataset, 0);
>         final Function2D curve = (Function2D)new LogarithmicFunction2D(coefficients[0], coefficients[1]);
>         final XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), (Comparable)"Fitted Regression Line");
>         final JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, (XYDataset)this.dataset, PlotOrientation.VERTICAL, true, true, false);
>         STScatterPlot.plot = (XYPlot)chart.getPlot();
>         final XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
>         STScatterPlot.plot.setRenderer((XYItemRenderer)renderer1);
>         STScatterPlot.plot.setBackgroundPaint((Paint)new Color(255, 228, 196));
>         final Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
>         STScatterPlot.plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
>         STScatterPlot.plot.setDataset(1, regressionData);
>         final XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
>         renderer2.setSeriesPaint(0, (Paint)Color.RED);
>         STScatterPlot.plot.setRenderer(1, (XYItemRenderer)renderer2);
>         final Shape cross = new Ellipse2D.Double(0.0, 0.0, 5.0, 5.0);
>         final List<String[]> featureLists = new ArrayList<String[]>();
>         for (int j = 0; j < ColorEditorSpot.tableC.getModel().getRowCount(); ++j) {
>             featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(j, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
>         }
>         this.renderer = new XYLineAndShapeRenderer() {
>             public Paint getItemPaint(final int row, final int col) {
>                 Paint cpaint = this.getItemColor(row, col);
>                 if (cpaint == null) {
>                     cpaint = super.getItemPaint(row, col);
>                 }
>                 return cpaint;
>             }
>             
>             public Color getItemColor(final int row, final int col) {
>                 final double x = STScatterPlot.this.dataset.getXValue(row, col);
>                 final double y = STScatterPlot.this.dataset.getYValue(row, col);
>                 try {
>                     return classColor[col];
>                 }
>                 catch (Exception ex) {
>                     return null;
>                 }
>             }
>         };
>         STScatterPlot.plot.setRenderer((XYItemRenderer)this.renderer);
>         this.renderer.setUseOutlinePaint(true);
>         this.renderer.setSeriesShape(0, cross);
>         this.renderer.setSeriesOutlinePaint(0, (Paint)Color.black);
>         this.renderer.setSeriesOutlineStroke(0, (Stroke)new BasicStroke(1.0f));
>         this.renderer.setSeriesLinesVisible(0, false);
>         this.renderer.setSeriesPaint(0, (Paint)Color.LIGHT_GRAY);
>         STScatterPlot.plot.getRangeCrosshairValue();
>         STScatterPlot.plot.getDomainCrosshairValue();
>         this.panel.setChart(chart);
>         this.panel.setMaximumDrawWidth(6000);
>         this.panel.setPreferredSize(new Dimension(450, 300));
>         chart.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         STScatterPlot.plot.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         chart.getLegend().setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         this.panel.setMouseWheelEnabled(true);
>         chart.getLegend().setVisible(true);
>         STScatterPlot.plot.addRangeMarker((Marker)markerRange);
>         STScatterPlot.plot.addDomainMarker((Marker)markerDomain);
>         markerRange.setLabel("Low-High");
>         markerRange.setLabelFont(new Font("SansSerif", 0, 15));
>         markerRange.setLabelPaint((Paint)new Color(0, 102, 0));
>         final Font font3 = new Font("Dialog", 1, 12);
>         STScatterPlot.plot.getDomainAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setTickLabelFont(font3);
>         STScatterPlot.plot.getDomainAxis().setTickLabelFont(font3);
>         final NumberAxis domain = (NumberAxis)STScatterPlot.plot.getDomainAxis();
>         final NumberAxis range = (NumberAxis)STScatterPlot.plot.getRangeAxis();
>         domain.setAutoRange(true);
>         range.setAutoRange(true);
>         this.computeLogarithmicCoefficients(chart, STScatterPlot.plot, this.dataset, this.filterOrder);
>     }
>     
>     public void addScatterPlotSeriesExponential(final String domainName, final String rangeName, final List<Double> valuesDomain, final List<Double> valuesRange, final IntervalMarker markerRange, final IntervalMarker markerDomain, final Object[][] data, final Color[] classColor) {
>         this.valuesDomain = valuesDomain;
>         this.rangeName = rangeName;
>         this.domainName = domainName;
>         this.valuesRange = valuesRange;
>         this.markerRange = markerRange;
>         this.markerDomain = markerDomain;
>         this.classColor = classColor;
>         this.filterOrder = this.filterOrder;
>         this.panel.removeAll();
>         this.dataset = new XYSeriesCollection();
>         this.series1 = new XYSeries((Comparable)"");
>         for (int i = 0; i < valuesDomain.size(); ++i) {
>             this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
>         }
>         this.dataset.addSeries(this.series1);
>         final double minDomain = Collections.<Double>min((Collection<? extends Double>)valuesDomain);
>         final double maxDomain = Collections.<Double>max((Collection<? extends Double>)valuesDomain);
>         final double[] coefficients = RegressionLE_.getExponentialRegression((XYDataset)this.dataset, 0);
>         final Function2D curve = (Function2D)new ExponentialFunction2D(coefficients[0], coefficients[1]);
>         final XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), (Comparable)"Fitted Regression Line");
>         final JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, (XYDataset)this.dataset, PlotOrientation.VERTICAL, true, true, false);
>         STScatterPlot.plot = (XYPlot)chart.getPlot();
>         final XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
>         STScatterPlot.plot.setRenderer((XYItemRenderer)renderer1);
>         STScatterPlot.plot.setBackgroundPaint((Paint)new Color(255, 228, 196));
>         final Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
>         STScatterPlot.plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
>         STScatterPlot.plot.setDataset(1, regressionData);
>         final XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
>         renderer2.setSeriesPaint(0, (Paint)Color.RED);
>         STScatterPlot.plot.setRenderer(1, (XYItemRenderer)renderer2);
>         final Shape cross = new Ellipse2D.Double(0.0, 0.0, 5.0, 5.0);
>         final List<String[]> featureLists = new ArrayList<String[]>();
>         for (int j = 0; j < ColorEditorSpot.tableC.getModel().getRowCount(); ++j) {
>             featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(j, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
>         }
>         this.renderer = new XYLineAndShapeRenderer() {
>             public Paint getItemPaint(final int row, final int col) {
>                 Paint cpaint = this.getItemColor(row, col);
>                 if (cpaint == null) {
>                     cpaint = super.getItemPaint(row, col);
>                 }
>                 return cpaint;
>             }
>             
>             public Color getItemColor(final int row, final int col) {
>                 final double x = STScatterPlot.this.dataset.getXValue(row, col);
>                 final double y = STScatterPlot.this.dataset.getYValue(row, col);
>                 try {
>                     return classColor[col];
>                 }
>                 catch (Exception ex) {
>                     return null;
>                 }
>             }
>         };
>         STScatterPlot.plot.setRenderer((XYItemRenderer)this.renderer);
>         this.renderer.setUseOutlinePaint(true);
>         this.renderer.setSeriesShape(0, cross);
>         this.renderer.setSeriesOutlinePaint(0, (Paint)Color.black);
>         this.renderer.setSeriesOutlineStroke(0, (Stroke)new BasicStroke(1.0f));
>         this.renderer.setSeriesLinesVisible(0, false);
>         this.renderer.setSeriesPaint(0, (Paint)Color.LIGHT_GRAY);
>         STScatterPlot.plot.getRangeCrosshairValue();
>         STScatterPlot.plot.getDomainCrosshairValue();
>         this.panel.setChart(chart);
>         this.panel.setMaximumDrawWidth(6000);
>         this.panel.setPreferredSize(new Dimension(450, 300));
>         chart.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         STScatterPlot.plot.setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         chart.getLegend().setBackgroundPaint((Paint)new Color(255, 255, 255, 0));
>         this.panel.setMouseWheelEnabled(true);
>         chart.getLegend().setVisible(true);
>         STScatterPlot.plot.addRangeMarker((Marker)markerRange);
>         STScatterPlot.plot.addDomainMarker((Marker)markerDomain);
>         markerRange.setLabel("Low-High");
>         markerRange.setLabelFont(new Font("SansSerif", 0, 15));
>         markerRange.setLabelPaint((Paint)new Color(0, 102, 0));
>         final Font font3 = new Font("Dialog", 1, 12);
>         STScatterPlot.plot.getDomainAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setLabelFont(font3);
>         STScatterPlot.plot.getRangeAxis().setTickLabelFont(font3);
>         STScatterPlot.plot.getDomainAxis().setTickLabelFont(font3);
>         final NumberAxis domain = (NumberAxis)STScatterPlot.plot.getDomainAxis();
>         final NumberAxis range = (NumberAxis)STScatterPlot.plot.getRangeAxis();
>         domain.setAutoRange(true);
>         range.setAutoRange(true);
>         this.computeExponentialCoefficients(chart, STScatterPlot.plot, this.dataset, this.filterOrder);
>     }
>     
>     private void computeLinearCoefficients(final JFreeChart chart, final XYPlot plot, final XYSeriesCollection dataset) {
>         Function2D retVal = null;
>         double r2 = 0.0;
>         double[] coefficients = null;
>         try {
>             coefficients = RegressionLE_.getOLSRegression((XYDataset)dataset, 0);
>             retVal = (Function2D)new LineFunction2D(coefficients[0], coefficients[1]);
711,726c574,708
<          }
<       } catch (Exception var12) {
<          System.err.println(var12.getMessage());
<       }
< 
<       String exponentialEquation = "y = " + String.format("%.2f", coefficients[0]) + " * " + "( e^(" + String.format("%.2f", coefficients[1]) + " * x) ) ";
<       TextTitle tt = new TextTitle("y = " + exponentialEquation + "\nR = " + String.format("%.2f", r2));
<       tt.setTextAlignment(HorizontalAlignment.RIGHT);
<       tt.setFont(chart.getLegend().getItemFont());
<       tt.setBackgroundPaint(new Color(200, 200, 255, 100));
<       tt.setFrame(new BlockBorder(Color.white));
<       tt.setPosition(RectangleEdge.BOTTOM);
<       XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, tt, RectangleAnchor.BOTTOM_RIGHT);
<       r2Annotation.setMaxWidth(0.48D);
<       plot.addAnnotation(r2Annotation);
<    }
---
>         }
>         catch (Exception e) {
>             System.err.println(e.getMessage());
>         }
>         final double intercept = coefficients[0];
>         final double slope = coefficients[1];
>         String linearEquation;
>         if (intercept >= 0.0) {
>             linearEquation = "y = " + String.format("%.2f", slope) + "x + " + String.format("%.2f", intercept);
>         }
>         else {
>             linearEquation = "y = " + String.format("%.2f", slope) + "x - " + Math.abs(intercept);
>         }
>         final TextTitle tt = new TextTitle(String.valueOf(linearEquation) + "\nR = " + String.format("%.2f", r2));
>         tt.setTextAlignment(HorizontalAlignment.RIGHT);
>         tt.setFont(chart.getLegend().getItemFont());
>         tt.setBackgroundPaint((Paint)new Color(200, 200, 255, 100));
>         tt.setFrame((BlockFrame)new BlockBorder((Paint)Color.white));
>         tt.setPosition(RectangleEdge.BOTTOM);
>         final XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98, 0.02, (Title)tt, RectangleAnchor.BOTTOM_RIGHT);
>         r2Annotation.setMaxWidth(0.48);
>         plot.addAnnotation((XYAnnotation)r2Annotation);
>     }
>     
>     private void computePowerCoefficients(final JFreeChart chart, final XYPlot plot, final XYSeriesCollection dataset) {
>         Function2D retVal = null;
>         double r2 = 0.0;
>         double[] coefficients = null;
>         try {
>             coefficients = RegressionLE_.getPowerRegression((XYDataset)dataset, 0);
>             if (coefficients[2] > r2) {
>                 retVal = (Function2D)new PowerFunction2D(coefficients[0], coefficients[1]);
>                 r2 = coefficients[2];
>             }
>         }
>         catch (Exception e) {
>             System.err.println(e.getMessage());
>         }
>         final double intercept = coefficients[0];
>         final double slope = coefficients[1];
>         String linearEquation;
>         if (intercept >= 0.0) {
>             linearEquation = "y = " + String.format("%.2f", slope) + "x^ " + String.format("%.2f", intercept);
>         }
>         else {
>             linearEquation = "y = " + String.format("%.2f", slope) + "x^ -" + Math.abs(intercept);
>         }
>         final TextTitle tt = new TextTitle(String.valueOf(linearEquation) + "\nR = " + String.format("%.2f", r2));
>         tt.setTextAlignment(HorizontalAlignment.RIGHT);
>         tt.setFont(chart.getLegend().getItemFont());
>         tt.setBackgroundPaint((Paint)new Color(200, 200, 255, 100));
>         tt.setFrame((BlockFrame)new BlockBorder((Paint)Color.white));
>         tt.setPosition(RectangleEdge.BOTTOM);
>         final XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98, 0.02, (Title)tt, RectangleAnchor.BOTTOM_RIGHT);
>         r2Annotation.setMaxWidth(0.48);
>         plot.addAnnotation((XYAnnotation)r2Annotation);
>     }
>     
>     private void computePolynomialCoefficients(final JFreeChart chart, final XYPlot plot, final XYSeriesCollection dataset, final int filterOrder) {
>         final double[] coefficients = Regression.getPolynomialRegression((XYDataset)dataset, 0, filterOrder);
>         final double r2 = coefficients[coefficients.length - 1];
>         String polynomialEquation = "";
>         for (int i = coefficients.length - 1; i >= 0; --i) {
>             if (i == 0) {
>                 polynomialEquation = String.valueOf(polynomialEquation) + String.format("%.2f", coefficients[i]);
>             }
>             else if (i == 1) {
>                 polynomialEquation = String.valueOf(polynomialEquation) + String.format("%.2f", coefficients[i]) + "*x+";
>             }
>             else if (i > 1) {
>                 polynomialEquation = String.valueOf(polynomialEquation) + String.format("%.2f", coefficients[i]) + "*x^" + i + "+";
>             }
>         }
>         final TextTitle tt = new TextTitle("y = " + polynomialEquation + "\nR = " + String.format("%.2f", r2));
>         tt.setTextAlignment(HorizontalAlignment.RIGHT);
>         tt.setFont(chart.getLegend().getItemFont());
>         tt.setBackgroundPaint((Paint)new Color(200, 200, 255, 100));
>         tt.setFrame((BlockFrame)new BlockBorder((Paint)Color.white));
>         tt.setPosition(RectangleEdge.BOTTOM);
>         final XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98, 0.02, (Title)tt, RectangleAnchor.BOTTOM_RIGHT);
>         r2Annotation.setMaxWidth(0.48);
>         plot.addAnnotation((XYAnnotation)r2Annotation);
>     }
>     
>     private void computeLogarithmicCoefficients(final JFreeChart chart, final XYPlot plot, final XYSeriesCollection dataset, final int filterOrder) {
>         Function2D retVal = null;
>         double r2 = 0.0;
>         double[] coefficients = null;
>         try {
>             coefficients = RegressionLE_.getLogarithmicRegression((XYDataset)dataset, 0);
>             if (coefficients[2] > r2) {
>                 retVal = (Function2D)new LogarithmicFunction2D(coefficients[0], coefficients[1]);
>                 r2 = coefficients[2];
>             }
>         }
>         catch (Exception e) {
>             System.err.println(e.getMessage());
>         }
>         final String logarithmicEquation = "y = " + String.format("%.2f", coefficients[0]) + " + " + "( " + String.format("%.2f", coefficients[1]) + " * ln(x) ) ";
>         final TextTitle tt = new TextTitle("y = " + logarithmicEquation + "\nR = " + String.format("%.2f", r2));
>         tt.setTextAlignment(HorizontalAlignment.RIGHT);
>         tt.setFont(chart.getLegend().getItemFont());
>         tt.setBackgroundPaint((Paint)new Color(200, 200, 255, 100));
>         tt.setFrame((BlockFrame)new BlockBorder((Paint)Color.white));
>         tt.setPosition(RectangleEdge.BOTTOM);
>         final XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98, 0.02, (Title)tt, RectangleAnchor.BOTTOM_RIGHT);
>         r2Annotation.setMaxWidth(0.48);
>         plot.addAnnotation((XYAnnotation)r2Annotation);
>     }
>     
>     private void computeExponentialCoefficients(final JFreeChart chart, final XYPlot plot, final XYSeriesCollection dataset, final int filterOrder) {
>         Function2D retVal = null;
>         double r2 = 0.0;
>         double[] coefficients = null;
>         try {
>             coefficients = RegressionLE_.getExponentialRegression((XYDataset)dataset, 0);
>             if (coefficients[2] > r2) {
>                 retVal = (Function2D)new LogarithmicFunction2D(coefficients[0], coefficients[1]);
>                 r2 = coefficients[2];
>             }
>         }
>         catch (Exception e) {
>             System.err.println(e.getMessage());
>         }
>         final String exponentialEquation = "y = " + String.format("%.2f", coefficients[0]) + " * " + "( e^(" + String.format("%.2f", coefficients[1]) + " * x) ) ";
>         final TextTitle tt = new TextTitle("y = " + exponentialEquation + "\nR = " + String.format("%.2f", r2));
>         tt.setTextAlignment(HorizontalAlignment.RIGHT);
>         tt.setFont(chart.getLegend().getItemFont());
>         tt.setBackgroundPaint((Paint)new Color(200, 200, 255, 100));
>         tt.setFrame((BlockFrame)new BlockBorder((Paint)Color.white));
>         tt.setPosition(RectangleEdge.BOTTOM);
>         final XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98, 0.02, (Title)tt, RectangleAnchor.BOTTOM_RIGHT);
>         r2Annotation.setMaxWidth(0.48);
>         plot.addAnnotation((XYAnnotation)r2Annotation);
>     }
diff -r TrackAnalyzer_/summaryColsWindow.java procyon/summaryColsWindow.java
1,2d0
< import checkable.CheckableItem;
< import checkable.CheckedComboBox;
5c3
< import javax.swing.BoxLayout;
---
> import javax.swing.ComboBoxModel;
7,9d4
< import javax.swing.JButton;
< import javax.swing.JComboBox;
< import javax.swing.JFrame;
10a6,9
> import java.awt.LayoutManager;
> import java.awt.Container;
> import javax.swing.BoxLayout;
> import java.awt.Component;
11a11,15
> import javax.swing.JComboBox;
> import checkable.CheckableItem;
> import checkable.CheckedComboBox;
> import javax.swing.JFrame;
> import javax.swing.JButton;
13,115c17,72
< public class summaryColsWindow {
<    static JButton okButton;
<    static JFrame frame;
<    public static CheckedComboBox comboSpots;
<    public static CheckedComboBox comboLinks;
<    public static CheckedComboBox comboTracks;
<    static String[] columnNamesSpot = null;
<    static String[] columnNamesLinks = null;
<    static String[] columnNamesTracks = null;
<    public static CheckableItem[] itemsSpots;
<    public static CheckableItem[] itemsLinks;
<    public static CheckableItem[] itemsTracks;
<    static int indexSLT;
<    static JComboBox combo;
< 
<    public void run(String args) {
<       frame = new JFrame("Configure Summary Outputs");
<       frame.setSize(200, 150);
<       frame.setDefaultCloseOperation(2);
<       JPanel panel = new JPanel();
<       frame.add(panel);
<       placeComponents(panel);
<       frame.setVisible(true);
<    }
< 
<    private static void placeComponents(final JPanel panel) {
<       panel.setLayout(new BoxLayout(panel, 1));
<       JLabel paramLabel = new JLabel("Parameters: ");
<       panel.add(paramLabel);
<       combo = new JComboBox();
<       combo.addItem("Spots");
<       combo.addItem("Links");
<       combo.addItem("Tracks");
<       combo.setSelectedIndex(2);
<       combo.setBounds(50, 50, 90, 20);
<       if (SPTBatch_.checkboxSubBg.isSelected()) {
<          columnNamesSpot = new String[]{"LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1", "Intensity-Bg Subtract"};
<       }
< 
<       if (!SPTBatch_.checkboxSubBg.isSelected()) {
<          columnNamesSpot = new String[]{"LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1"};
<       }
< 
<       itemsSpots = new CheckableItem[columnNamesSpot.length];
<       columnNamesLinks = new String[]{"TRACK_ID", "SPOT_SOURCE_ID", "SPOT_TARGET_ID", "LINK_COST", "DIRECTIONAL_CHANGE_RATE", "SPEED", "DISPLACEMENT", "EDGE_TIME", "EDGE_X_LOCATION", "EDGE_Y_LOCATION", "EDGE_Z_LOCATION", "MANUAL_EGE_COLOR"};
<       itemsLinks = new CheckableItem[columnNamesLinks.length];
<       if (SPTBatch_.checkboxSubBg.isSelected()) {
<          if (SPTBatch_.checkTracks.isSelected()) {
<             columnNamesTracks = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + ")", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<          }
< 
<          if (!SPTBatch_.checkTracks.isSelected()) {
<             columnNamesTracks = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<          }
<       }
< 
<       if (!SPTBatch_.checkboxSubBg.isSelected()) {
<          columnNamesTracks = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<       }
< 
<       itemsTracks = new CheckableItem[columnNamesTracks.length];
< 
<       int i;
<       for(i = 0; i < columnNamesSpot.length; ++i) {
<          itemsSpots[i] = new CheckableItem(columnNamesSpot[i], false);
<       }
< 
<       for(i = 0; i < columnNamesLinks.length; ++i) {
<          itemsLinks[i] = new CheckableItem(columnNamesLinks[i], false);
<       }
< 
<       for(i = 0; i < columnNamesTracks.length; ++i) {
<          itemsTracks[i] = new CheckableItem(columnNamesTracks[i], false);
<       }
< 
<       comboSpots = new CheckedComboBox(new DefaultComboBoxModel(itemsSpots));
<       comboSpots.setOpaque(true);
<       comboSpots.setToolTipText("Select parameter to build the summary for links.");
<       comboSpots.setSelectedItem(itemsSpots[0]);
<       comboLinks = new CheckedComboBox(new DefaultComboBoxModel(itemsLinks));
<       comboLinks.setOpaque(true);
<       comboLinks.setToolTipText("Select parameter to build the summary for links.");
<       comboLinks.setSelectedItem(itemsLinks[0]);
<       comboTracks = new CheckedComboBox(new DefaultComboBoxModel(itemsTracks));
<       comboTracks.setOpaque(true);
<       comboTracks.setToolTipText("Select parameter to build the summary for tracks.");
<       comboTracks.setSelectedItem(itemsTracks[0]);
<       panel.add(combo);
<       JLabel columnParamLabel = new JLabel("Column Parameter: ");
<       panel.add(columnParamLabel);
<       okButton = new JButton("OK");
<       okButton.setBounds(10, 80, 80, 25);
<       panel.add(okButton);
<       okButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent event) {
<             summaryColsWindow.indexSLT = summaryColsWindow.combo.getSelectedIndex();
<             summaryColsWindow.frame.setVisible(false);
<          }
<       });
<       combo.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             if (panel.getComponents().length == 5) {
<                panel.remove(3);
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class summaryColsWindow
> {
>     static JButton okButton;
>     static JFrame frame;
>     public static CheckedComboBox comboSpots;
>     public static CheckedComboBox comboLinks;
>     public static CheckedComboBox comboTracks;
>     static String[] columnNamesSpot;
>     static String[] columnNamesLinks;
>     static String[] columnNamesTracks;
>     public static CheckableItem[] itemsSpots;
>     public static CheckableItem[] itemsLinks;
>     public static CheckableItem[] itemsTracks;
>     static int indexSLT;
>     static JComboBox combo;
>     
>     static {
>         summaryColsWindow.columnNamesSpot = null;
>         summaryColsWindow.columnNamesLinks = null;
>         summaryColsWindow.columnNamesTracks = null;
>     }
>     
>     public void run(final String args) {
>         (summaryColsWindow.frame = new JFrame("Configure Summary Outputs")).setSize(200, 150);
>         summaryColsWindow.frame.setDefaultCloseOperation(2);
>         final JPanel panel = new JPanel();
>         summaryColsWindow.frame.add(panel);
>         placeComponents(panel);
>         summaryColsWindow.frame.setVisible(true);
>     }
>     
>     private static void placeComponents(final JPanel panel) {
>         panel.setLayout(new BoxLayout(panel, 1));
>         final JLabel paramLabel = new JLabel("Parameters: ");
>         panel.add(paramLabel);
>         (summaryColsWindow.combo = new JComboBox()).addItem("Spots");
>         summaryColsWindow.combo.addItem("Links");
>         summaryColsWindow.combo.addItem("Tracks");
>         summaryColsWindow.combo.setSelectedIndex(2);
>         summaryColsWindow.combo.setBounds(50, 50, 90, 20);
>         if (SPTBatch_.checkboxSubBg.isSelected()) {
>             summaryColsWindow.columnNamesSpot = new String[] { "LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1", "Intensity-Bg Subtract" };
>         }
>         if (!SPTBatch_.checkboxSubBg.isSelected()) {
>             summaryColsWindow.columnNamesSpot = new String[] { "LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1" };
>         }
>         summaryColsWindow.itemsSpots = new CheckableItem[summaryColsWindow.columnNamesSpot.length];
>         summaryColsWindow.columnNamesLinks = new String[] { "TRACK_ID", "SPOT_SOURCE_ID", "SPOT_TARGET_ID", "LINK_COST", "DIRECTIONAL_CHANGE_RATE", "SPEED", "DISPLACEMENT", "EDGE_TIME", "EDGE_X_LOCATION", "EDGE_Y_LOCATION", "EDGE_Z_LOCATION", "MANUAL_EGE_COLOR" };
>         summaryColsWindow.itemsLinks = new CheckableItem[summaryColsWindow.columnNamesLinks.length];
>         if (SPTBatch_.checkboxSubBg.isSelected()) {
>             if (SPTBatch_.checkTracks.isSelected()) {
>                 summaryColsWindow.columnNamesTracks = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + ")", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement" };
117,119c74,75
< 
<             if (summaryColsWindow.combo.getSelectedIndex() == 0) {
<                panel.add(summaryColsWindow.comboSpots, 3);
---
>             if (!SPTBatch_.checkTracks.isSelected()) {
>                 summaryColsWindow.columnNamesTracks = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement" };
121,123c77,109
< 
<             if (summaryColsWindow.combo.getSelectedIndex() == 1) {
<                panel.add(summaryColsWindow.comboLinks, 3);
---
>         }
>         if (!SPTBatch_.checkboxSubBg.isSelected()) {
>             summaryColsWindow.columnNamesTracks = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement" };
>         }
>         summaryColsWindow.itemsTracks = new CheckableItem[summaryColsWindow.columnNamesTracks.length];
>         for (int i = 0; i < summaryColsWindow.columnNamesSpot.length; ++i) {
>             summaryColsWindow.itemsSpots[i] = new CheckableItem(summaryColsWindow.columnNamesSpot[i], false);
>         }
>         for (int i = 0; i < summaryColsWindow.columnNamesLinks.length; ++i) {
>             summaryColsWindow.itemsLinks[i] = new CheckableItem(summaryColsWindow.columnNamesLinks[i], false);
>         }
>         for (int i = 0; i < summaryColsWindow.columnNamesTracks.length; ++i) {
>             summaryColsWindow.itemsTracks[i] = new CheckableItem(summaryColsWindow.columnNamesTracks[i], false);
>         }
>         (summaryColsWindow.comboSpots = new CheckedComboBox((ComboBoxModel<E>)new DefaultComboBoxModel<CheckableItem>((E[])summaryColsWindow.itemsSpots))).setOpaque(true);
>         summaryColsWindow.comboSpots.setToolTipText("Select parameter to build the summary for links.");
>         summaryColsWindow.comboSpots.setSelectedItem(summaryColsWindow.itemsSpots[0]);
>         (summaryColsWindow.comboLinks = new CheckedComboBox((ComboBoxModel<E>)new DefaultComboBoxModel<CheckableItem>((E[])summaryColsWindow.itemsLinks))).setOpaque(true);
>         summaryColsWindow.comboLinks.setToolTipText("Select parameter to build the summary for links.");
>         summaryColsWindow.comboLinks.setSelectedItem(summaryColsWindow.itemsLinks[0]);
>         (summaryColsWindow.comboTracks = new CheckedComboBox((ComboBoxModel<E>)new DefaultComboBoxModel<CheckableItem>((E[])summaryColsWindow.itemsTracks))).setOpaque(true);
>         summaryColsWindow.comboTracks.setToolTipText("Select parameter to build the summary for tracks.");
>         summaryColsWindow.comboTracks.setSelectedItem(summaryColsWindow.itemsTracks[0]);
>         panel.add(summaryColsWindow.combo);
>         final JLabel columnParamLabel = new JLabel("Column Parameter: ");
>         panel.add(columnParamLabel);
>         (summaryColsWindow.okButton = new JButton("OK")).setBounds(10, 80, 80, 25);
>         panel.add(summaryColsWindow.okButton);
>         summaryColsWindow.okButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent event) {
>                 summaryColsWindow.indexSLT = summaryColsWindow.combo.getSelectedIndex();
>                 summaryColsWindow.frame.setVisible(false);
125,127c111,126
< 
<             if (summaryColsWindow.combo.getSelectedIndex() == 2) {
<                panel.add(summaryColsWindow.comboTracks, 3);
---
>         });
>         summaryColsWindow.combo.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent e) {
>                 if (panel.getComponents().length == 5) {
>                     panel.remove(3);
>                 }
>                 if (summaryColsWindow.combo.getSelectedIndex() == 0) {
>                     panel.add(summaryColsWindow.comboSpots, 3);
>                 }
>                 if (summaryColsWindow.combo.getSelectedIndex() == 1) {
>                     panel.add(summaryColsWindow.comboLinks, 3);
>                 }
>                 if (summaryColsWindow.combo.getSelectedIndex() == 2) {
>                     panel.add(summaryColsWindow.comboTracks, 3);
>                 }
129,132c128,129
< 
<          }
<       });
<    }
---
>         });
>     }
diff -r TrackAnalyzer_/TrackAnalyzer_.java procyon/TrackAnalyzer_.java
1,2c1,7
< import ij.measure.Measurements;
< import ij.plugin.PlugIn;
---
> import java.net.URL;
> import javax.swing.Icon;
> import jwizardcomponent.Utilities;
> import java.awt.AWTEvent;
> import java.awt.Window;
> import java.awt.event.WindowEvent;
> import java.awt.event.ActionEvent;
5d9
< import java.awt.Font;
7,8d10
< import java.awt.TextField;
< import java.awt.event.ActionEvent;
10,12c12,15
< import java.awt.event.WindowEvent;
< import java.net.URL;
< import java.util.prefs.Preferences;
---
> import java.awt.Font;
> import javax.swing.JLabel;
> import java.awt.LayoutManager;
> import java.awt.Container;
14d16
< import javax.swing.Icon;
17,20d18
< import javax.swing.JFrame;
< import javax.swing.JLabel;
< import javax.swing.JPanel;
< import javax.swing.UIManager;
22c20,21
< import javax.swing.UIManager.LookAndFeelInfo;
---
> import javax.swing.UIManager;
> import java.awt.TextField;
24d22
< import jwizardcomponent.Utilities;
25a24,28
> import javax.swing.JFrame;
> import javax.swing.JPanel;
> import java.util.prefs.Preferences;
> import ij.measure.Measurements;
> import ij.plugin.PlugIn;
27,59c30,65
< public class TrackAnalyzer_ implements PlugIn, Measurements {
<    static String SLTDISPLAYER_XML_PATH;
<    static String SLTDISPLAYER_IMAGES_PATH;
<    static String xmlPath;
<    static String imagesPath;
<    Preferences prefXml;
<    Preferences prefImages;
<    JPanel panelInitial;
<    JFrame frame;
<    JWizardFrame wizard;
<    JWizardPanel panel;
<    public static final int PANEL_FIRST = 0;
<    public static final int PANEL_CHOOSER = 1;
<    public static final int PANEL_OPTION_A = 2;
<    public static final int PANEL_OPTION_B = 3;
<    public static final int PANEL_LAST = 4;
<    public static TextField textXml;
<    public static TextField textImages;
<    Thread sptViewer;
<    Thread sptBatch;
< 
<    public void run(String arg0) {
<       JFrame.setDefaultLookAndFeelDecorated(true);
< 
<       try {
<          LookAndFeelInfo[] var5;
<          int var4 = (var5 = UIManager.getInstalledLookAndFeels()).length;
< 
<          for(int var3 = 0; var3 < var4; ++var3) {
<             LookAndFeelInfo info = var5[var3];
<             if ("Nimbus".equals(info.getName())) {
<                UIManager.setLookAndFeel(info.getClassName());
<                break;
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class TrackAnalyzer_ implements PlugIn, Measurements
> {
>     static String SLTDISPLAYER_XML_PATH;
>     static String SLTDISPLAYER_IMAGES_PATH;
>     static String xmlPath;
>     static String imagesPath;
>     Preferences prefXml;
>     Preferences prefImages;
>     JPanel panelInitial;
>     JFrame frame;
>     JWizardFrame wizard;
>     JWizardPanel panel;
>     public static final int PANEL_FIRST = 0;
>     public static final int PANEL_CHOOSER = 1;
>     public static final int PANEL_OPTION_A = 2;
>     public static final int PANEL_OPTION_B = 3;
>     public static final int PANEL_LAST = 4;
>     public static TextField textXml;
>     public static TextField textImages;
>     Thread sptViewer;
>     Thread sptBatch;
>     
>     public void run(final String arg0) {
>         JFrame.setDefaultLookAndFeelDecorated(true);
>         try {
>             UIManager.LookAndFeelInfo[] installedLookAndFeels;
>             for (int length = (installedLookAndFeels = UIManager.getInstalledLookAndFeels()).length, i = 0; i < length; ++i) {
>                 final UIManager.LookAndFeelInfo info = installedLookAndFeels[i];
>                 if ("Nimbus".equals(info.getName())) {
>                     UIManager.setLookAndFeel(info.getClassName());
>                     break;
>                 }
61,210c67,209
<          }
<       } catch (UnsupportedLookAndFeelException var19) {
<       } catch (ClassNotFoundException var20) {
<       } catch (InstantiationException var21) {
<       } catch (IllegalAccessException var22) {
<       }
< 
<       this.prefXml = Preferences.userRoot();
<       this.prefImages = Preferences.userRoot();
<       SLTDISPLAYER_XML_PATH = "xml_path";
<       SLTDISPLAYER_IMAGES_PATH = "images_path";
<       JButton buttonBrowse1 = new JButton("");
<       JButton buttonBrowse2 = new JButton("");
<       ImageIcon iconBrowse = this.createImageIcon("images/browse.png");
<       Icon iconBrowseCell = new ImageIcon(iconBrowse.getImage().getScaledInstance(15, 15, 4));
<       buttonBrowse1.setIcon(iconBrowseCell);
<       this.panelInitial = new JPanel();
<       this.panelInitial.setLayout(new BoxLayout(this.panelInitial, 1));
<       textXml = new TextField(20);
<       textXml.setText(this.prefXml.get(SLTDISPLAYER_XML_PATH, ""));
<       textImages = new TextField(20);
<       textImages.setText(this.prefImages.get(SLTDISPLAYER_IMAGES_PATH, ""));
<       JLabel labelXml = new JLabel("  Load TrackMate .XML file: ");
<       labelXml.setFont(new Font("Verdana", 1, 12));
<       JLabel labelImages = new JLabel("  Load movies to be analyzed:   ");
<       labelImages.setFont(new Font("Verdana", 1, 12));
<       DirectoryListener listenerXml = new DirectoryListener("Browse for TrackMate XML file...  ", textXml, 2);
<       DirectoryListener listenerImages = new DirectoryListener("Browse for movies...  ", textImages, 2);
<       buttonBrowse2.setIcon(iconBrowseCell);
<       buttonBrowse1.addActionListener(listenerXml);
<       buttonBrowse2.addActionListener(listenerImages);
<       Panel panelXml = new Panel();
<       panelXml.setLayout(new FlowLayout(0));
<       panelXml.add(labelXml);
<       panelXml.add(textXml);
<       panelXml.add(buttonBrowse1);
<       Panel panelImages = new Panel();
<       panelImages.setLayout(new FlowLayout(0));
<       panelImages.add(labelImages);
<       panelImages.add(textImages);
<       panelImages.add(buttonBrowse2);
<       JButton okButton = new JButton("SPT-Viewer");
<       ImageIcon iconOk = this.createImageIcon("images/viewer.png");
<       Icon iconOkCell = new ImageIcon(iconOk.getImage().getScaledInstance(15, 15, 4));
<       okButton.setIcon(iconOkCell);
<       JButton cancelButton = new JButton("SPT-Batch");
<       ImageIcon iconCancel = this.createImageIcon("images/batch.png");
<       Icon iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(15, 15, 4));
<       cancelButton.setIcon(iconCancelCell);
<       Panel panelOkCancel = new Panel();
<       panelOkCancel.setLayout(new FlowLayout(1));
<       panelOkCancel.add(okButton);
<       panelOkCancel.add(cancelButton);
<       this.panelInitial.add(panelXml);
<       this.panelInitial.add(panelImages);
<       this.panelInitial.add(panelOkCancel);
<       this.createFrame();
<       okButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent event) {
<             TrackAnalyzer_.this.sptViewer = new Thread(new Runnable() {
<                public void run() {
<                   TrackAnalyzer_.xmlPath = TrackAnalyzer_.textXml.getText();
<                   TrackAnalyzer_.imagesPath = TrackAnalyzer_.textImages.getText();
<                   TrackAnalyzer_.this.prefXml.put(TrackAnalyzer_.SLTDISPLAYER_XML_PATH, TrackAnalyzer_.textXml.getText());
<                   TrackAnalyzer_.this.prefImages.put(TrackAnalyzer_.SLTDISPLAYER_IMAGES_PATH, TrackAnalyzer_.textImages.getText());
<                   TrackAnalyzer_.this.frame.dispatchEvent(new WindowEvent(TrackAnalyzer_.this.frame, 201));
<                   TrackAnalyzer_.this.wizard = new JWizardFrame();
<                   TrackAnalyzer_.this.wizard.setTitle("SLT Viewer: ANALYSIS");
<                   TrackAnalyzer_.this.panel = new FirstWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents());
<                   TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(0, TrackAnalyzer_.this.panel);
<                   TrackAnalyzer_.this.panel = new ChooserWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents());
<                   TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(1, TrackAnalyzer_.this.panel);
<                   TrackAnalyzer_.this.panel = new OptionWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents(), "A");
<                   TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(2, TrackAnalyzer_.this.panel);
<                   TrackAnalyzer_.this.panel = new OptionWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents(), "B");
<                   TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(3, TrackAnalyzer_.this.panel);
<                   TrackAnalyzer_.this.panel = new LastWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents());
<                   TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(4, TrackAnalyzer_.this.panel);
<                   Component[] components = null;
< 
<                   try {
<                      components = TrackAnalyzer_.this.wizard.getWizardComponents().getFinishButton().getParent().getComponents();
<                   } catch (Exception var11) {
<                      var11.printStackTrace();
<                   }
< 
<                   TrackAnalyzer_.this.wizard.getWizardComponents().getFinishButton().getParent().remove(components[2]);
<                   JButton backButton = TrackAnalyzer_.this.wizard.getWizardComponents().getBackButton();
<                   backButton.setText("");
<                   ImageIcon iconBack = TrackAnalyzer_.this.createImageIcon("images/next.png");
<                   Icon backCell = new ImageIcon(iconBack.getImage().getScaledInstance(20, 22, 4));
<                   backButton.setIcon(backCell);
<                   backButton.setToolTipText("Click this button to back on wizard.");
<                   JButton nextButton = TrackAnalyzer_.this.wizard.getWizardComponents().getNextButton();
<                   nextButton.setText("");
<                   ImageIcon iconNext = TrackAnalyzer_.this.createImageIcon("images/back.png");
<                   Icon nextCell = new ImageIcon(iconNext.getImage().getScaledInstance(20, 22, 4));
<                   nextButton.setIcon(nextCell);
<                   nextButton.setToolTipText("Click this button to switch wizard.");
<                   JButton cancelButton = TrackAnalyzer_.this.wizard.getWizardComponents().getCancelButton();
<                   cancelButton.setText("");
<                   ImageIcon iconCancel = TrackAnalyzer_.this.createImageIcon("images/cancel.png");
<                   Icon cancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(20, 22, 4));
<                   cancelButton.setIcon(cancelCell);
<                   cancelButton.setToolTipText("Click this button to cancel the process.");
<                   TrackAnalyzer_.this.wizard.setSize(630, 1000);
<                   Utilities.centerComponentOnScreen(TrackAnalyzer_.this.wizard);
<                   TrackAnalyzer_.this.wizard.setVisible(true);
<                }
<             });
<             TrackAnalyzer_.this.sptViewer.start();
<          }
<       });
<       cancelButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent event) {
<             TrackAnalyzer_.this.sptBatch = new Thread(new Runnable() {
<                public void run() {
<                   TrackAnalyzer_.xmlPath = TrackAnalyzer_.textXml.getText();
<                   TrackAnalyzer_.imagesPath = TrackAnalyzer_.textImages.getText();
<                   TrackAnalyzer_.this.prefXml.put(TrackAnalyzer_.SLTDISPLAYER_XML_PATH, TrackAnalyzer_.textXml.getText());
<                   TrackAnalyzer_.this.prefImages.put(TrackAnalyzer_.SLTDISPLAYER_IMAGES_PATH, TrackAnalyzer_.textImages.getText());
<                   SPTBatch_ sptBatch = new SPTBatch_(TrackAnalyzer_.xmlPath, TrackAnalyzer_.imagesPath);
<                   sptBatch.run("");
<                   TrackAnalyzer_.this.frame.dispatchEvent(new WindowEvent(TrackAnalyzer_.this.frame, 201));
<                }
<             });
<             TrackAnalyzer_.this.sptBatch.start();
<          }
<       });
<    }
< 
<    public void createFrame() {
<       this.frame = new JFrame("TrackAnalyzer");
<       this.frame.setDefaultCloseOperation(2);
<       this.frame.setSize(400, 500);
<       this.frame.setResizable(false);
<       this.frame.getContentPane().add(this.panelInitial);
<       this.frame.pack();
<       this.frame.setVisible(true);
<    }
< 
<    protected ImageIcon createImageIcon(String path) {
<       URL img = TrackAnalyzer_.class.getResource(path);
<       if (img != null) {
<          return new ImageIcon(img);
<       } else {
<          System.err.println("Couldn't find file: " + path);
<          return null;
<       }
<    }
---
>         }
>         catch (UnsupportedLookAndFeelException ex) {}
>         catch (ClassNotFoundException ex2) {}
>         catch (InstantiationException ex3) {}
>         catch (IllegalAccessException ex4) {}
>         this.prefXml = Preferences.userRoot();
>         this.prefImages = Preferences.userRoot();
>         TrackAnalyzer_.SLTDISPLAYER_XML_PATH = "xml_path";
>         TrackAnalyzer_.SLTDISPLAYER_IMAGES_PATH = "images_path";
>         final JButton buttonBrowse1 = new JButton("");
>         final JButton buttonBrowse2 = new JButton("");
>         final ImageIcon iconBrowse = this.createImageIcon("images/browse.png");
>         final Icon iconBrowseCell = new ImageIcon(iconBrowse.getImage().getScaledInstance(15, 15, 4));
>         buttonBrowse1.setIcon(iconBrowseCell);
>         (this.panelInitial = new JPanel()).setLayout(new BoxLayout(this.panelInitial, 1));
>         (TrackAnalyzer_.textXml = new TextField(20)).setText(this.prefXml.get(TrackAnalyzer_.SLTDISPLAYER_XML_PATH, ""));
>         (TrackAnalyzer_.textImages = new TextField(20)).setText(this.prefImages.get(TrackAnalyzer_.SLTDISPLAYER_IMAGES_PATH, ""));
>         final JLabel labelXml = new JLabel("  Load TrackMate .XML file: ");
>         labelXml.setFont(new Font("Verdana", 1, 12));
>         final JLabel labelImages = new JLabel("  Load movies to be analyzed:   ");
>         labelImages.setFont(new Font("Verdana", 1, 12));
>         final DirectoryListener listenerXml = new DirectoryListener("Browse for TrackMate XML file...  ", TrackAnalyzer_.textXml, 2);
>         final DirectoryListener listenerImages = new DirectoryListener("Browse for movies...  ", TrackAnalyzer_.textImages, 2);
>         buttonBrowse2.setIcon(iconBrowseCell);
>         buttonBrowse1.addActionListener(listenerXml);
>         buttonBrowse2.addActionListener(listenerImages);
>         final Panel panelXml = new Panel();
>         panelXml.setLayout(new FlowLayout(0));
>         panelXml.add(labelXml);
>         panelXml.add(TrackAnalyzer_.textXml);
>         panelXml.add(buttonBrowse1);
>         final Panel panelImages = new Panel();
>         panelImages.setLayout(new FlowLayout(0));
>         panelImages.add(labelImages);
>         panelImages.add(TrackAnalyzer_.textImages);
>         panelImages.add(buttonBrowse2);
>         final JButton okButton = new JButton("SPT-Viewer");
>         final ImageIcon iconOk = this.createImageIcon("images/viewer.png");
>         final Icon iconOkCell = new ImageIcon(iconOk.getImage().getScaledInstance(15, 15, 4));
>         okButton.setIcon(iconOkCell);
>         final JButton cancelButton = new JButton("SPT-Batch");
>         final ImageIcon iconCancel = this.createImageIcon("images/batch.png");
>         final Icon iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(15, 15, 4));
>         cancelButton.setIcon(iconCancelCell);
>         final Panel panelOkCancel = new Panel();
>         panelOkCancel.setLayout(new FlowLayout(1));
>         panelOkCancel.add(okButton);
>         panelOkCancel.add(cancelButton);
>         this.panelInitial.add(panelXml);
>         this.panelInitial.add(panelImages);
>         this.panelInitial.add(panelOkCancel);
>         this.createFrame();
>         okButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent event) {
>                 (TrackAnalyzer_.this.sptViewer = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         TrackAnalyzer_.xmlPath = TrackAnalyzer_.textXml.getText();
>                         TrackAnalyzer_.imagesPath = TrackAnalyzer_.textImages.getText();
>                         TrackAnalyzer_.this.prefXml.put(TrackAnalyzer_.SLTDISPLAYER_XML_PATH, TrackAnalyzer_.textXml.getText());
>                         TrackAnalyzer_.this.prefImages.put(TrackAnalyzer_.SLTDISPLAYER_IMAGES_PATH, TrackAnalyzer_.textImages.getText());
>                         TrackAnalyzer_.this.frame.dispatchEvent(new WindowEvent(TrackAnalyzer_.this.frame, 201));
>                         (TrackAnalyzer_.this.wizard = new JWizardFrame()).setTitle("SLT Viewer: ANALYSIS");
>                         TrackAnalyzer_.this.panel = new FirstWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents());
>                         TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(0, TrackAnalyzer_.this.panel);
>                         TrackAnalyzer_.this.panel = new ChooserWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents());
>                         TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(1, TrackAnalyzer_.this.panel);
>                         TrackAnalyzer_.this.panel = new OptionWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents(), "A");
>                         TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(2, TrackAnalyzer_.this.panel);
>                         TrackAnalyzer_.this.panel = new OptionWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents(), "B");
>                         TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(3, TrackAnalyzer_.this.panel);
>                         TrackAnalyzer_.this.panel = new LastWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents());
>                         TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(4, TrackAnalyzer_.this.panel);
>                         Component[] components = null;
>                         try {
>                             components = TrackAnalyzer_.this.wizard.getWizardComponents().getFinishButton().getParent().getComponents();
>                         }
>                         catch (Exception e) {
>                             e.printStackTrace();
>                         }
>                         TrackAnalyzer_.this.wizard.getWizardComponents().getFinishButton().getParent().remove(components[2]);
>                         final JButton backButton = TrackAnalyzer_.this.wizard.getWizardComponents().getBackButton();
>                         backButton.setText("");
>                         final ImageIcon iconBack = TrackAnalyzer_.this.createImageIcon("images/next.png");
>                         final Icon backCell = new ImageIcon(iconBack.getImage().getScaledInstance(20, 22, 4));
>                         backButton.setIcon(backCell);
>                         backButton.setToolTipText("Click this button to back on wizard.");
>                         final JButton nextButton = TrackAnalyzer_.this.wizard.getWizardComponents().getNextButton();
>                         nextButton.setText("");
>                         final ImageIcon iconNext = TrackAnalyzer_.this.createImageIcon("images/back.png");
>                         final Icon nextCell = new ImageIcon(iconNext.getImage().getScaledInstance(20, 22, 4));
>                         nextButton.setIcon(nextCell);
>                         nextButton.setToolTipText("Click this button to switch wizard.");
>                         final JButton cancelButton = TrackAnalyzer_.this.wizard.getWizardComponents().getCancelButton();
>                         cancelButton.setText("");
>                         final ImageIcon iconCancel = TrackAnalyzer_.this.createImageIcon("images/cancel.png");
>                         final Icon cancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(20, 22, 4));
>                         cancelButton.setIcon(cancelCell);
>                         cancelButton.setToolTipText("Click this button to cancel the process.");
>                         TrackAnalyzer_.this.wizard.setSize(630, 1000);
>                         Utilities.centerComponentOnScreen((Component)TrackAnalyzer_.this.wizard);
>                         TrackAnalyzer_.this.wizard.setVisible(true);
>                     }
>                 })).start();
>             }
>         });
>         cancelButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent event) {
>                 (TrackAnalyzer_.this.sptBatch = new Thread(new Runnable() {
>                     @Override
>                     public void run() {
>                         TrackAnalyzer_.xmlPath = TrackAnalyzer_.textXml.getText();
>                         TrackAnalyzer_.imagesPath = TrackAnalyzer_.textImages.getText();
>                         TrackAnalyzer_.this.prefXml.put(TrackAnalyzer_.SLTDISPLAYER_XML_PATH, TrackAnalyzer_.textXml.getText());
>                         TrackAnalyzer_.this.prefImages.put(TrackAnalyzer_.SLTDISPLAYER_IMAGES_PATH, TrackAnalyzer_.textImages.getText());
>                         final SPTBatch_ sptBatch = new SPTBatch_(TrackAnalyzer_.xmlPath, TrackAnalyzer_.imagesPath);
>                         sptBatch.run("");
>                         TrackAnalyzer_.this.frame.dispatchEvent(new WindowEvent(TrackAnalyzer_.this.frame, 201));
>                     }
>                 })).start();
>             }
>         });
>     }
>     
>     public void createFrame() {
>         (this.frame = new JFrame("TrackAnalyzer")).setDefaultCloseOperation(2);
>         this.frame.setSize(400, 500);
>         this.frame.setResizable(false);
>         this.frame.getContentPane().add(this.panelInitial);
>         this.frame.pack();
>         this.frame.setVisible(true);
>     }
>     
>     protected ImageIcon createImageIcon(final String path) {
>         final URL img = TrackAnalyzer_.class.getResource(path);
>         if (img != null) {
>             return new ImageIcon(img);
>         }
>         System.err.println("Couldn't find file: " + path);
>         return null;
>     }
diff -r TrackAnalyzer_/TrackProcessorMSD_Modified.java procyon/TrackProcessorMSD_Modified.java
0a1,3
> import java.awt.event.MouseEvent;
> import java.awt.event.KeyEvent;
> import java.awt.Point;
2c5,9
< import fiji.plugin.trackmate.gui.displaysettings.Colormap;
---
> import java.util.Iterator;
> import org.jfree.chart.renderer.xy.XYItemRenderer;
> import java.io.IOException;
> import org.jfree.chart.ChartUtils;
> import java.io.File;
4c11,12
< import ij.measure.ResultsTable;
---
> import fiji.plugin.trackmate.gui.displaysettings.Colormap;
> import java.awt.Paint;
6,12c14,18
< import java.awt.Point;
< import java.awt.event.KeyEvent;
< import java.awt.event.MouseEvent;
< import java.awt.geom.Rectangle2D;
< import java.awt.geom.Rectangle2D.Float;
< import java.io.File;
< import java.io.IOException;
---
> import org.jfree.chart.plot.XYPlot;
> import org.jfree.data.xy.XYDataset;
> import org.jfree.chart.ChartFactory;
> import org.jfree.chart.plot.PlotOrientation;
> import org.jfree.data.xy.XYSeries;
14c20,21
< import java.util.Iterator;
---
> import org.jfree.data.xy.XYSeriesCollection;
> import ij.measure.ResultsTable;
16,17c23,24
< import javax.swing.JButton;
< import javax.swing.JCheckBox;
---
> import java.awt.Component;
> import org.jfree.chart.ChartPanel;
19c26
< import javax.swing.JPanel;
---
> import java.awt.geom.Rectangle2D;
21,23c28,30
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.ChartUtils;
---
> import javax.swing.JPanel;
> import javax.swing.JButton;
> import javax.swing.JCheckBox;
25,47d31
< import org.jfree.chart.plot.PlotOrientation;
< import org.jfree.chart.plot.XYPlot;
< import org.jfree.chart.renderer.xy.XYItemRenderer;
< import org.jfree.data.xy.XYSeries;
< import org.jfree.data.xy.XYSeriesCollection;
< 
< public class TrackProcessorMSD_Modified {
<    JFreeChart chart;
<    JCheckBox displayLegendCheckBox = new JCheckBox("Display legend.", false);
<    JCheckBox displayGraphInSequenceCheckBox = new JCheckBox("Display graph on sequence.", false);
<    JButton useRoiAsBoundsForChartButton = new JButton("place graph in ROI #1");
<    JCheckBox forceAllSequenceGraphWidthCheckBox = new JCheckBox("Force graph width.", false);
<    JCheckBox useRealScalesBox = new JCheckBox("use real scales", false);
<    JPanel chartpanel = new JPanel();
<    JTextField scaleTextField = new JTextField("1.0");
<    JButton exportButton = new JButton("export to console");
<    JButton exportExcelButton = new JButton("export to excel");
<    Rectangle2D chartRectangleInSequence = new Float(250.0F, 20.0F, 490.0F, 240.0F);
<    JLabel outLabel = new JLabel();
< 
<    public TrackProcessorMSD_Modified() {
<       this.chartpanel.add(new ChartPanel(this.chart, 500, 300, 500, 300, 500, 300, false, false, true, true, true, true));
<    }
49,67c33,84
<    public void Compute(List<Integer> nOfTracks, ResultsTable rtSpots) {
<       XYSeriesCollection xyDataset = new XYSeriesCollection();
<       XYSeries series = null;
<       List<List<Double>> imported2SpotX = new ArrayList();
<       List<List<Double>> imported2SpotY = new ArrayList();
<       List<List<Double>> imported2SpotT = new ArrayList();
<       List<Integer> trackName = new ArrayList();
< 
<       for(int id = 0; id < nOfTracks.size(); ++id) {
<          trackName.add((Integer)nOfTracks.get(id));
<          List<Double> imported1SpotX = new ArrayList();
<          List<Double> imported1SpotY = new ArrayList();
<          List<Double> imported1SpotT = new ArrayList();
< 
<          for(int i = 0; i < rtSpots.size(); ++i) {
<             if (rtSpots.getStringValue(2, i).equals(String.valueOf((Integer)nOfTracks.get(id))) == Boolean.TRUE) {
<                imported1SpotX.add(Double.valueOf(rtSpots.getStringValue(4, i)));
<                imported1SpotY.add(Double.valueOf(rtSpots.getStringValue(5, i)));
<                imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(7, i)));
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class TrackProcessorMSD_Modified
> {
>     JFreeChart chart;
>     JCheckBox displayLegendCheckBox;
>     JCheckBox displayGraphInSequenceCheckBox;
>     JButton useRoiAsBoundsForChartButton;
>     JCheckBox forceAllSequenceGraphWidthCheckBox;
>     JCheckBox useRealScalesBox;
>     JPanel chartpanel;
>     JTextField scaleTextField;
>     JButton exportButton;
>     JButton exportExcelButton;
>     Rectangle2D chartRectangleInSequence;
>     JLabel outLabel;
>     
>     public TrackProcessorMSD_Modified() {
>         this.displayLegendCheckBox = new JCheckBox("Display legend.", false);
>         this.displayGraphInSequenceCheckBox = new JCheckBox("Display graph on sequence.", false);
>         this.useRoiAsBoundsForChartButton = new JButton("place graph in ROI #1");
>         this.forceAllSequenceGraphWidthCheckBox = new JCheckBox("Force graph width.", false);
>         this.useRealScalesBox = new JCheckBox("use real scales", false);
>         this.chartpanel = new JPanel();
>         this.scaleTextField = new JTextField("1.0");
>         this.exportButton = new JButton("export to console");
>         this.exportExcelButton = new JButton("export to excel");
>         this.chartRectangleInSequence = new Rectangle2D.Float(250.0f, 20.0f, 490.0f, 240.0f);
>         this.outLabel = new JLabel();
>         this.chartpanel.add((Component)new ChartPanel(this.chart, 500, 300, 500, 300, 500, 300, false, false, true, true, true, true));
>     }
>     
>     public void Compute(final List<Integer> nOfTracks, final ResultsTable rtSpots) {
>         final XYSeriesCollection xyDataset = new XYSeriesCollection();
>         XYSeries series = null;
>         final List<List<Double>> imported2SpotX = new ArrayList<List<Double>>();
>         final List<List<Double>> imported2SpotY = new ArrayList<List<Double>>();
>         final List<List<Double>> imported2SpotT = new ArrayList<List<Double>>();
>         final List<Integer> trackName = new ArrayList<Integer>();
>         for (int id = 0; id < nOfTracks.size(); ++id) {
>             trackName.add(nOfTracks.get(id));
>             final List<Double> imported1SpotX = new ArrayList<Double>();
>             final List<Double> imported1SpotY = new ArrayList<Double>();
>             final List<Double> imported1SpotT = new ArrayList<Double>();
>             for (int i = 0; i < rtSpots.size(); ++i) {
>                 if (rtSpots.getStringValue(2, i).equals(String.valueOf((int)nOfTracks.get(id))) == Boolean.TRUE) {
>                     imported1SpotX.add(Double.valueOf(rtSpots.getStringValue(4, i)));
>                     imported1SpotY.add(Double.valueOf(rtSpots.getStringValue(5, i)));
>                     imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(7, i)));
>                 }
69,111c86,98
<          }
< 
<          imported2SpotX.add(imported1SpotX);
<          imported2SpotY.add(imported1SpotY);
<          imported2SpotT.add(imported1SpotT);
<       }
< 
<       String TitleString = "";
<       String TitleString2 = "";
<       String TitleString3 = "";
< 
<       for(int i = 0; i < imported2SpotX.size(); ++i) {
<          series = new XYSeries("Track " + i);
<          if (SPTBatch_.imps.getCalibration().getXUnit() != "pixel") {
<             TitleString = "Mean Square Displacement";
<             TitleString2 = "Delta (s)";
<             TitleString3 = "MSD (" + SPTBatch_.imps.getCalibration().getXUnit() + "^2)";
<          }
< 
<          if (SPTBatch_.imps.getCalibration().getXUnit() == "pixel") {
<             TitleString = "Mean Square Displacement";
<             TitleString2 = "Delta (frame)";
<             TitleString3 = "MSD (pixel^2)";
<          }
< 
<          double frameInterval = (Double)((List)imported2SpotT.get(i)).get(2) - (Double)((List)imported2SpotT.get(i)).get(1);
<          int nMSD = ((List)imported2SpotX.get(i)).size();
<          int[] tau = new int[nMSD - 1];
<          double[] msdArray = new double[tau.length];
< 
<          for(int z = 0; z < nMSD - 1 - 1 + 1; ++z) {
<             tau[z] = 1 + z;
<          }
< 
<          double msd = -1.0D;
< 
<          for(int dt = 0; dt < tau.length; ++dt) {
<             double N = 0.0D;
<             msd = 0.0D;
< 
<             for(int j = tau[dt]; j < ((List)imported2SpotX.get(i)).size(); ++j) {
<                msd = msd + Math.pow((Double)((List)imported2SpotX.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotX.get(i)).get(j), 2.0D) + Math.pow((Double)((List)imported2SpotY.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotY.get(i)).get(j), 2.0D);
<                ++N;
---
>             imported2SpotX.add(imported1SpotX);
>             imported2SpotY.add(imported1SpotY);
>             imported2SpotT.add(imported1SpotT);
>         }
>         String TitleString = "";
>         String TitleString2 = "";
>         String TitleString3 = "";
>         for (int j = 0; j < imported2SpotX.size(); ++j) {
>             series = new XYSeries((Comparable)("Track " + j));
>             if (SPTBatch_.imps.getCalibration().getXUnit() != "pixel") {
>                 TitleString = "Mean Square Displacement";
>                 TitleString2 = "Delta (s)";
>                 TitleString3 = "MSD (" + SPTBatch_.imps.getCalibration().getXUnit() + "^2)";
113,177c100,177
< 
<             msd /= N;
<             msdArray[dt] = msd;
<             series.add((double)tau[dt] * frameInterval, msd);
<          }
< 
<          xyDataset.addSeries(series);
<       }
< 
<       this.chart = ChartFactory.createXYLineChart(TitleString, TitleString2, TitleString3, xyDataset, PlotOrientation.VERTICAL, this.displayLegendCheckBox.isSelected(), true, false);
<       XYPlot plot = (XYPlot)this.chart.getPlot();
<       plot.setBackgroundPaint(Color.white);
<       plot.setDomainGridlinesVisible(true);
<       plot.setRangeGridlinesVisible(true);
<       plot.setDomainMinorGridlinePaint(Color.GRAY);
<       plot.setDomainGridlinePaint(Color.DARK_GRAY);
<       plot.setRangeMinorGridlinePaint(Color.GRAY);
<       plot.setRangeGridlinePaint(Color.DARK_GRAY);
<       this.chartpanel.removeAll();
<       if (this.chart != null) {
<          XYItemRenderer renderer = ((XYPlot)this.chart.getPlot()).getRenderer();
<          Iterator var33 = nOfTracks.iterator();
< 
<          while(var33.hasNext()) {
<             Integer id = (Integer)var33.next();
<             PerTrackFeatureColorGenerator tcg = new PerTrackFeatureColorGenerator(SPTBatch_.model, "TRACK_INDEX", (Color)null, (Color)null, Colormap.Turbo, 0.0D, 1.0D);
<             renderer.setSeriesPaint(id, tcg.colorOf(id));
<          }
<       }
< 
<       this.chartpanel.add(new ChartPanel(this.chart, 400, 300, 400, 300, 400, 300, false, false, true, true, true, true));
<       this.chartpanel.updateUI();
<       if (SPTBatch_.checkboxDiff.isSelected() == Boolean.TRUE) {
<          try {
<             ChartUtils.saveChartAsPNG(new File(SPTBatch_.directDiff.getAbsolutePath() + File.separator + "MSD_curve_" + SPTBatch_.imps.getShortTitle() + ".png"), this.chart, 500, 400);
<          } catch (IOException var25) {
<             var25.printStackTrace();
<          }
<       }
< 
<       if (SPTBatch_.checkboxDiff.isSelected() == Boolean.FALSE) {
<          try {
<             ChartUtils.saveChartAsPNG(new File(SPTBatch_.directImages.getAbsolutePath() + File.separator + "MSD_curve_" + SPTBatch_.imps.getShortTitle() + ".png"), this.chart, 500, 400);
<          } catch (IOException var24) {
<             var24.printStackTrace();
<          }
<       }
< 
<    }
< 
<    private static double scaledSquaredDistance(Spot spotSource, Spot spotTarget, double sx, double sy, double sz) {
<       return Math.pow((spotSource.getFeature("POSITION_X") - spotTarget.getFeature("POSITION_X")) * sx, 2.0D) + Math.pow((spotSource.getFeature("POSITION_Y") - spotTarget.getFeature("POSITION_Y")) * sy, 2.0D);
<    }
< 
<    public void keyPressed(Point p, KeyEvent e) {
<    }
< 
<    public void mouseClick(Point p, MouseEvent e) {
<    }
< 
<    public void mouseDrag(Point p, MouseEvent e) {
<    }
< 
<    public void mouseMove(Point p, MouseEvent e) {
<    }
---
>             if (SPTBatch_.imps.getCalibration().getXUnit() == "pixel") {
>                 TitleString = "Mean Square Displacement";
>                 TitleString2 = "Delta (frame)";
>                 TitleString3 = "MSD (pixel^2)";
>             }
>             final double frameInterval = imported2SpotT.get(j).get(2) - imported2SpotT.get(j).get(1);
>             final int nMSD = imported2SpotX.get(j).size();
>             final int[] tau = new int[nMSD - 1];
>             final double[] msdArray = new double[tau.length];
>             for (int z = 0; z < nMSD - 1 - 1 + 1; ++z) {
>                 tau[z] = 1 + z;
>             }
>             double msd = -1.0;
>             for (int dt = 0; dt < tau.length; ++dt) {
>                 double N = 0.0;
>                 msd = 0.0;
>                 for (int k = tau[dt]; k < imported2SpotX.get(j).size(); ++k) {
>                     msd = msd + Math.pow(imported2SpotX.get(j).get(k - tau[dt]) - imported2SpotX.get(j).get(k), 2.0) + Math.pow(imported2SpotY.get(j).get(k - tau[dt]) - imported2SpotY.get(j).get(k), 2.0);
>                     ++N;
>                 }
>                 msd /= N;
>                 msdArray[dt] = msd;
>                 series.add(tau[dt] * frameInterval, msd);
>             }
>             xyDataset.addSeries(series);
>         }
>         this.chart = ChartFactory.createXYLineChart(TitleString, TitleString2, TitleString3, (XYDataset)xyDataset, PlotOrientation.VERTICAL, this.displayLegendCheckBox.isSelected(), true, false);
>         final XYPlot plot = (XYPlot)this.chart.getPlot();
>         plot.setBackgroundPaint((Paint)Color.white);
>         plot.setDomainGridlinesVisible(true);
>         plot.setRangeGridlinesVisible(true);
>         plot.setDomainMinorGridlinePaint((Paint)Color.GRAY);
>         plot.setDomainGridlinePaint((Paint)Color.DARK_GRAY);
>         plot.setRangeMinorGridlinePaint((Paint)Color.GRAY);
>         plot.setRangeGridlinePaint((Paint)Color.DARK_GRAY);
>         this.chartpanel.removeAll();
>         if (this.chart != null) {
>             final XYItemRenderer renderer = ((XYPlot)this.chart.getPlot()).getRenderer();
>             for (final Integer id2 : nOfTracks) {
>                 final PerTrackFeatureColorGenerator tcg = new PerTrackFeatureColorGenerator(SPTBatch_.model, "TRACK_INDEX", (Color)null, (Color)null, Colormap.Turbo, 0.0, 1.0);
>                 renderer.setSeriesPaint((int)id2, (Paint)tcg.colorOf(id2));
>             }
>         }
>         this.chartpanel.add((Component)new ChartPanel(this.chart, 400, 300, 400, 300, 400, 300, false, false, true, true, true, true));
>         this.chartpanel.updateUI();
>         if (SPTBatch_.checkboxDiff.isSelected() == Boolean.TRUE) {
>             try {
>                 ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directDiff.getAbsolutePath()) + File.separator + "MSD_curve_" + SPTBatch_.imps.getShortTitle() + ".png"), this.chart, 500, 400);
>             }
>             catch (IOException e) {
>                 e.printStackTrace();
>             }
>         }
>         if (SPTBatch_.checkboxDiff.isSelected() == Boolean.FALSE) {
>             try {
>                 ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directImages.getAbsolutePath()) + File.separator + "MSD_curve_" + SPTBatch_.imps.getShortTitle() + ".png"), this.chart, 500, 400);
>             }
>             catch (IOException e) {
>                 e.printStackTrace();
>             }
>         }
>     }
>     
>     private static double scaledSquaredDistance(final Spot spotSource, final Spot spotTarget, final double sx, final double sy, final double sz) {
>         return Math.pow((spotSource.getFeature("POSITION_X") - spotTarget.getFeature("POSITION_X")) * sx, 2.0) + Math.pow((spotSource.getFeature("POSITION_Y") - spotTarget.getFeature("POSITION_Y")) * sy, 2.0);
>     }
>     
>     public void keyPressed(final Point p, final KeyEvent e) {
>     }
>     
>     public void mouseClick(final Point p, final MouseEvent e) {
>     }
>     
>     public void mouseDrag(final Point p, final MouseEvent e) {
>     }
>     
>     public void mouseMove(final Point p, final MouseEvent e) {
>     }
diff -r TrackAnalyzer_/traJ/TrajectoryModified.java procyon/traJ/TrajectoryModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
2a7,8
> import java.util.List;
> import vecmath.Tuple3dModified;
4d9
< import java.util.ArrayList;
5a11
> import java.util.ArrayList;
7,145c13,153
< public class TrajectoryModified extends ArrayList<Point3dModified> {
<    private static final long serialVersionUID = 1L;
<    private int dimension;
<    private int relativeStartTimepoint;
<    private long id;
<    private static long idCounter = 1L;
<    private String type = "";
<    private ArrayList<AbstractTrajectoryFeatureModified> features;
< 
<    public TrajectoryModified(int dimension) {
<       this.dimension = dimension;
<       this.relativeStartTimepoint = 0;
<       this.id = (long)(idCounter++);
<       this.features = new ArrayList();
<    }
< 
<    public TrajectoryModified(int dimension, int relativeStartTimepoint) {
<       this.dimension = dimension;
<       this.relativeStartTimepoint = relativeStartTimepoint;
<       this.id = (long)(idCounter++);
<       this.features = new ArrayList();
<    }
< 
<    public TrajectoryModified() {
<       this.relativeStartTimepoint = 0;
<       this.features = new ArrayList();
<    }
< 
<    public TrajectoryModified subList(int fromIndex, int toIndex) {
<       TrajectoryModified t = new TrajectoryModified(this.dimension);
< 
<       for(int i = fromIndex; i < toIndex; ++i) {
<          t.add((Point3dModified)this.get(i));
<       }
< 
<       return t;
<    }
< 
<    public ArrayList<AbstractTrajectoryFeatureModified> getFeatures() {
<       return this.features;
<    }
< 
<    public void addFeature(AbstractTrajectoryFeatureModified feature) {
<       this.features.add(feature);
<    }
< 
<    public TrajectoryModified getCopy() {
<       TrajectoryModified t = new TrajectoryModified(this.dimension);
< 
<       for(int i = 0; i < this.size(); ++i) {
<          t.add((Point3dModified)t.get(i));
<       }
< 
<       return t;
<    }
< 
<    public double[][] getPositionsAsArray() {
<       double[][] posAsArr = new double[this.size()][3];
< 
<       for(int i = 0; i < this.size(); ++i) {
<          if (this.get(i) != null) {
<             posAsArr[i][0] = ((Point3dModified)this.get(i)).x;
<             posAsArr[i][1] = ((Point3dModified)this.get(i)).y;
<             posAsArr[i][2] = ((Point3dModified)this.get(i)).z;
<          } else {
<             posAsArr[i] = null;
<          }
<       }
< 
<       return posAsArr;
<    }
< 
<    public String toString() {
<       String result = "";
< 
<       for(int i = 0; i < this.size(); ++i) {
<          result = result + " x: " + ((Point3dModified)this.get(i)).x + " y: " + ((Point3dModified)this.get(i)).y + " z: " + ((Point3dModified)this.get(i)).z + "\n";
<       }
< 
<       return result;
<    }
< 
<    public boolean add(Point3dModified e) {
<       return super.add(e);
<    }
< 
<    public void scale(double v) {
<       for(int i = 0; i < this.size(); ++i) {
<          ((Point3dModified)this.get(i)).scale(v);
<       }
< 
<    }
< 
<    public void offset(double x, double y, double z) {
<       for(int i = 0; i < this.size(); ++i) {
<          ((Point3dModified)this.get(i)).add(new Point3dModified(x, y, z));
<       }
< 
<    }
< 
<    public boolean add(double x, double y, double z) {
<       return super.add(new Point3dModified(x, y, z));
<    }
< 
<    public int getDimension() {
<       return this.dimension;
<    }
< 
<    public void setDimension(int dimension) {
<       this.dimension = dimension;
<    }
< 
<    public long getID() {
<       return this.id;
<    }
< 
<    public void setID(int id) {
<       this.id = (long)id;
<    }
< 
<    public int getRelativeStartTimepoint() {
<       return this.relativeStartTimepoint;
<    }
< 
<    public void setRelativStartTimepoint(int timepoint) {
<       this.relativeStartTimepoint = timepoint;
<    }
< 
<    public void setType(String type) {
<       this.type = type;
<    }
< 
<    public String getType() {
<       return this.type;
<    }
< 
<    public static void restIDCounter() {
<       idCounter = 1L;
<    }
---
> public class TrajectoryModified extends ArrayList<Point3dModified>
> {
>     private static final long serialVersionUID = 1L;
>     private int dimension;
>     private int relativeStartTimepoint;
>     private long id;
>     private static long idCounter;
>     private String type;
>     private ArrayList<AbstractTrajectoryFeatureModified> features;
>     
>     static {
>         TrajectoryModified.idCounter = 1L;
>     }
>     
>     public TrajectoryModified(final int dimension) {
>         this.type = "";
>         this.dimension = dimension;
>         this.relativeStartTimepoint = 0;
>         this.id = TrajectoryModified.idCounter++;
>         this.features = new ArrayList<AbstractTrajectoryFeatureModified>();
>     }
>     
>     public TrajectoryModified(final int dimension, final int relativeStartTimepoint) {
>         this.type = "";
>         this.dimension = dimension;
>         this.relativeStartTimepoint = relativeStartTimepoint;
>         this.id = TrajectoryModified.idCounter++;
>         this.features = new ArrayList<AbstractTrajectoryFeatureModified>();
>     }
>     
>     public TrajectoryModified() {
>         this.type = "";
>         this.relativeStartTimepoint = 0;
>         this.features = new ArrayList<AbstractTrajectoryFeatureModified>();
>     }
>     
>     @Override
>     public TrajectoryModified subList(final int fromIndex, final int toIndex) {
>         final TrajectoryModified t = new TrajectoryModified(this.dimension);
>         for (int i = fromIndex; i < toIndex; ++i) {
>             t.add(this.get(i));
>         }
>         return t;
>     }
>     
>     public ArrayList<AbstractTrajectoryFeatureModified> getFeatures() {
>         return this.features;
>     }
>     
>     public void addFeature(final AbstractTrajectoryFeatureModified feature) {
>         this.features.add(feature);
>     }
>     
>     public TrajectoryModified getCopy() {
>         final TrajectoryModified t = new TrajectoryModified(this.dimension);
>         for (int i = 0; i < this.size(); ++i) {
>             t.add(t.get(i));
>         }
>         return t;
>     }
>     
>     public double[][] getPositionsAsArray() {
>         final double[][] posAsArr = new double[this.size()][3];
>         for (int i = 0; i < this.size(); ++i) {
>             if (this.get(i) != null) {
>                 posAsArr[i][0] = this.get(i).x;
>                 posAsArr[i][1] = this.get(i).y;
>                 posAsArr[i][2] = this.get(i).z;
>             }
>             else {
>                 posAsArr[i] = null;
>             }
>         }
>         return posAsArr;
>     }
>     
>     @Override
>     public String toString() {
>         String result = "";
>         for (int i = 0; i < this.size(); ++i) {
>             result = String.valueOf(result) + " x: " + this.get(i).x + " y: " + this.get(i).y + " z: " + this.get(i).z + "\n";
>         }
>         return result;
>     }
>     
>     @Override
>     public boolean add(final Point3dModified e) {
>         return super.add(e);
>     }
>     
>     public void scale(final double v) {
>         for (int i = 0; i < this.size(); ++i) {
>             this.get(i).scale(v);
>         }
>     }
>     
>     public void offset(final double x, final double y, final double z) {
>         for (int i = 0; i < this.size(); ++i) {
>             this.get(i).add(new Point3dModified(x, y, z));
>         }
>     }
>     
>     public boolean add(final double x, final double y, final double z) {
>         return super.add(new Point3dModified(x, y, z));
>     }
>     
>     public int getDimension() {
>         return this.dimension;
>     }
>     
>     public void setDimension(final int dimension) {
>         this.dimension = dimension;
>     }
>     
>     public long getID() {
>         return this.id;
>     }
>     
>     public void setID(final int id) {
>         this.id = id;
>     }
>     
>     public int getRelativeStartTimepoint() {
>         return this.relativeStartTimepoint;
>     }
>     
>     public void setRelativStartTimepoint(final int timepoint) {
>         this.relativeStartTimepoint = timepoint;
>     }
>     
>     public void setType(final String type) {
>         this.type = type;
>     }
>     
>     public String getType() {
>         return this.type;
>     }
>     
>     public static void restIDCounter() {
>         TrajectoryModified.idCounter = 1L;
>     }
diff -r TrackAnalyzer_/traJ/TrajectoryUtilModified.java procyon/traJ/TrajectoryUtilModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
6,32c10,33
< public class TrajectoryUtilModified {
<    public static TrajectoryModified resample(TrajectoryModified t, int n) {
<       TrajectoryModified t1 = new TrajectoryModified(2);
< 
<       for(int i = 0; i < t.size(); i += n) {
<          t1.add((Point3dModified)t.get(i));
<       }
< 
<       return t1;
<    }
< 
<    public static boolean isZero(double v) {
<       return Math.abs(v) < Math.pow(10.0D, -14.0D);
<    }
< 
<    public static TrajectoryModified getTrajectoryByID(List<? extends TrajectoryModified> t, int id) {
<       TrajectoryModified track = null;
< 
<       for(int i = 0; i < t.size(); ++i) {
<          if (((TrajectoryModified)t.get(i)).getID() == (long)id) {
<             track = (TrajectoryModified)t.get(i);
<             break;
<          }
<       }
< 
<       return track;
<    }
---
> public class TrajectoryUtilModified
> {
>     public static TrajectoryModified resample(final TrajectoryModified t, final int n) {
>         final TrajectoryModified t2 = new TrajectoryModified(2);
>         for (int i = 0; i < t.size(); i += n) {
>             t2.add(t.get(i));
>         }
>         return t2;
>     }
>     
>     public static boolean isZero(final double v) {
>         return Math.abs(v) < Math.pow(10.0, -14.0);
>     }
>     
>     public static TrajectoryModified getTrajectoryByID(final List<? extends TrajectoryModified> t, final int id) {
>         TrajectoryModified track = null;
>         for (int i = 0; i < t.size(); ++i) {
>             if (((TrajectoryModified)t.get(i)).getID() == id) {
>                 track = (TrajectoryModified)t.get(i);
>                 break;
>             }
>         }
>         return track;
>     }
diff -r TrackAnalyzer_/traJ/TrajectoryValidIndexTimelagIteratorModified.java procyon/traJ/TrajectoryValidIndexTimelagIteratorModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,49c9,36
< public class TrajectoryValidIndexTimelagIteratorModified implements Iterator<Integer> {
<    private TrajectoryModified t;
<    private int timelag;
<    boolean overlap = true;
<    int currentIndex;
< 
<    public TrajectoryValidIndexTimelagIteratorModified(TrajectoryModified t, int timelag) {
<       this.t = t;
<       this.timelag = timelag;
<       this.overlap = true;
<       this.currentIndex = 0;
<    }
< 
<    public TrajectoryValidIndexTimelagIteratorModified(TrajectoryModified t, int timelag, boolean overlap) {
<       this.t = t;
<       this.timelag = timelag;
<       this.overlap = overlap;
<       this.currentIndex = 0;
<    }
< 
<    public boolean hasNext() {
<       for(int i = this.currentIndex; i < this.t.size(); ++i) {
<          if (i + this.timelag >= this.t.size()) {
<             return false;
<          }
< 
<          if (this.t.get(i) != null && this.t.get(i + this.timelag) != null) {
<             return true;
<          }
<       }
< 
<       return false;
<    }
< 
<    public Integer next() {
<       for(int i = this.currentIndex; i < this.t.size(); ++i) {
<          if (i + this.timelag >= this.t.size()) {
<             return null;
<          }
< 
<          if (this.t.get(i) != null && this.t.get(i + this.timelag) != null) {
<             if (this.overlap) {
<                this.currentIndex = i + 1;
<             } else {
<                this.currentIndex = i + this.timelag;
---
> public class TrajectoryValidIndexTimelagIteratorModified implements Iterator<Integer>
> {
>     private TrajectoryModified t;
>     private int timelag;
>     boolean overlap;
>     int currentIndex;
>     
>     public TrajectoryValidIndexTimelagIteratorModified(final TrajectoryModified t, final int timelag) {
>         this.overlap = true;
>         this.t = t;
>         this.timelag = timelag;
>         this.overlap = true;
>         this.currentIndex = 0;
>     }
>     
>     public TrajectoryValidIndexTimelagIteratorModified(final TrajectoryModified t, final int timelag, final boolean overlap) {
>         this.overlap = true;
>         this.t = t;
>         this.timelag = timelag;
>         this.overlap = overlap;
>         this.currentIndex = 0;
>     }
>     
>     @Override
>     public boolean hasNext() {
>         for (int i = this.currentIndex; i < this.t.size(); ++i) {
>             if (i + this.timelag >= this.t.size()) {
>                 return false;
51,60c38,66
< 
<             return i;
<          }
<       }
< 
<       return null;
<    }
< 
<    public void remove() {
<    }
---
>             if (this.t.get(i) != null && this.t.get(i + this.timelag) != null) {
>                 return true;
>             }
>         }
>         return false;
>     }
>     
>     @Override
>     public Integer next() {
>         for (int i = this.currentIndex; i < this.t.size(); ++i) {
>             if (i + this.timelag >= this.t.size()) {
>                 return null;
>             }
>             if (this.t.get(i) != null && this.t.get(i + this.timelag) != null) {
>                 if (this.overlap) {
>                     this.currentIndex = i + 1;
>                 }
>                 else {
>                     this.currentIndex = i + this.timelag;
>                 }
>                 return i;
>             }
>         }
>         return null;
>     }
>     
>     @Override
>     public void remove() {
>     }
diff -r TrackAnalyzer_/TraJClassifierTest_.java procyon/TraJClassifierTest_.java
0a1,9
> import java.io.OutputStream;
> import java.io.InputStream;
> import java.io.FileOutputStream;
> import org.apache.commons.math3.stat.StatUtils;
> import java.util.Collection;
> import java.util.HashSet;
> import trajectory_classifier.AbstractClassifierModified;
> import trajectory_classifier.WeightedWindowedClassificationProcessModified;
> import trajectory_classifier.RRFClassifierRenjinModified;
2,5c11
< import DiffusionCoefficientEstimator.CovarianceDiffusionCoefficientEstimatorModified;
< import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
< import de.biomedical_imaging.ij.trajectory_classifier.TraJResultsTable;
< import drift.StaticDriftCalculatorModified;
---
> import java.text.NumberFormat;
7c13,18
< import features.ActiveTransportParametersFeatureModified;
---
> import java.awt.Font;
> import java.util.Iterator;
> import java.util.Set;
> import ij.measure.ResultsTable;
> import DiffusionCoefficientEstimator.CovarianceDiffusionCoefficientEstimatorModified;
> import features.MSDRatioFeatureModified;
9,12d19
< import features.CenterOfGravityFeatureModified;
< import features.ConfinedDiffusionParametersFeatureModified;
< import features.EfficiencyFeatureModified;
< import features.FractalDimensionFeatureModified;
15d21
< import features.MSDRatioFeatureModified;
17d22
< import features.PowerLawFeatureModified;
18a24
> import features.EfficiencyFeatureModified;
20,23c26,37
< import fiji.plugin.trackmate.Spot;
< import ij.IJ;
< import ij.gui.Overlay;
< import ij.gui.Roi;
---
> import features.FractalDimensionFeatureModified;
> import features.CenterOfGravityFeatureModified;
> import features.ConfinedDiffusionParametersFeatureModified;
> import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
> import features.PowerLawFeatureModified;
> import features.ActiveTransportParametersFeatureModified;
> import java.text.DecimalFormat;
> import java.text.DecimalFormatSymbols;
> import java.util.Locale;
> import java.io.File;
> import trajectory_classifier.ExportImportToolsModified;
> import de.biomedical_imaging.ij.trajectory_classifier.TraJResultsTable;
25,28d38
< import ij.measure.ResultsTable;
< import ij.plugin.PlugIn;
< import java.awt.Color;
< import java.awt.Font;
31,38c41,46
< import java.io.File;
< import java.io.FileOutputStream;
< import java.io.InputStream;
< import java.text.DecimalFormat;
< import java.text.DecimalFormatSymbols;
< import java.text.NumberFormat;
< import java.util.ArrayList;
< import java.util.Collections;
---
> import ij.gui.Roi;
> import ij.IJ;
> import trajectory_classifier.VisualizationUtilsModified;
> import ij.gui.Overlay;
> import drift.StaticDriftCalculatorModified;
> import java.awt.Color;
40,41c48,50
< import java.util.HashSet;
< import java.util.Iterator;
---
> import vecmath.Point3dModified;
> import java.util.Collections;
> import fiji.plugin.trackmate.Spot;
43,45d51
< import java.util.Locale;
< import java.util.Set;
< import org.apache.commons.math3.stat.StatUtils;
47,48d52
< import trajectory_classifier.ExportImportToolsModified;
< import trajectory_classifier.RRFClassifierRenjinModified;
50,249c54,55
< import trajectory_classifier.VisualizationUtilsModified;
< import trajectory_classifier.WeightedWindowedClassificationProcessModified;
< import vecmath.Point3dModified;
< 
< public class TraJClassifierTest_ implements PlugIn {
<    static double timelag;
<    double minTrackLength;
<    int windowSizeClassification;
<    int minSegmentLength;
<    double pixelsize;
<    int resampleRate;
<    boolean showID;
<    boolean showOverviewClasses;
<    boolean removeGlobalDrift;
<    boolean useReducedModelConfinedMotion;
<    int ommittedTrajectories;
<    public static TraJClassifierTest_ instance;
<    ArrayList<SubtrajectoryModified> classifiedSegments;
<    ArrayList<TrajectoryModified> tracksToClassify;
<    ArrayList<TrajectoryModified> parentTrajectories;
< 
<    public TraJClassifierTest_() {
<       instance = this;
<    }
< 
<    public static TraJClassifierTest_ getInstance() {
<       if (instance == null) {
<          instance = new TraJClassifierTest_();
<       }
< 
<       return instance;
<    }
< 
<    public void run(String arg) {
<       String modelpath = "";
< 
<       try {
<          modelpath = this.ExportResource("/randomForestModel.RData");
<       } catch (Exception var47) {
<          var47.printStackTrace();
<       }
< 
<       List<Integer> trackSize = null;
<       Set classes;
<       ArrayList prois;
<       ArrayList dcEstim;
<       int i;
<       TrajectoryModified track;
<       int i;
<       int subPosCount;
<       if (!arg.contains("DEBUG")) {
<          this.tracksToClassify = new ArrayList();
<          TrajectoryModified.restIDCounter();
<          List<List<Spot>> imported2Spot = new ArrayList();
<          Set<Integer> trackIDs = SPTBatch_.model.getTrackModel().trackIDs(true);
<          trackSize = new ArrayList();
<          Iterator var7 = trackIDs.iterator();
< 
<          while(var7.hasNext()) {
<             Integer id = (Integer)var7.next();
<             List<Spot> imported1Spot = new ArrayList();
<             classes = SPTBatch_.model.getTrackModel().trackSpots(id);
<             trackSize.add(classes.size());
<             ArrayList<Float> framesByTrack = new ArrayList();
<             prois = new ArrayList();
<             ArrayList<Float> trackID = new ArrayList();
<             ArrayList<Integer> indexes = new ArrayList();
<             dcEstim = new ArrayList();
<             Iterator var16 = classes.iterator();
< 
<             while(var16.hasNext()) {
<                Spot spot = (Spot)var16.next();
<                trackID.add((float)id);
<                framesByTrack.add(Float.valueOf(spot.getFeature("FRAME").toString()));
<                prois.add(Float.valueOf(spot.getFeature("FRAME").toString()));
<                dcEstim.add(spot);
<             }
< 
<             Collections.sort(prois);
< 
<             for(subPosCount = 0; subPosCount < prois.size(); ++subPosCount) {
<                indexes.add(framesByTrack.indexOf(prois.get(subPosCount)));
<             }
< 
<             for(subPosCount = 0; subPosCount < indexes.size(); ++subPosCount) {
<                imported1Spot.add((Spot)dcEstim.get((Integer)indexes.get(subPosCount)));
<             }
< 
<             imported2Spot.add(imported1Spot);
<          }
< 
<          for(i = 0; i < imported2Spot.size(); ++i) {
<             track = new TrajectoryModified(2);
<             boolean firstPosition = true;
< 
<             for(i = 0; i < ((List)imported2Spot.get(i)).size(); ++i) {
<                double x = ((Spot)((List)imported2Spot.get(i)).get(i)).getFeature("POSITION_X");
<                double y = ((Spot)((List)imported2Spot.get(i)).get(i)).getFeature("POSITION_Y");
<                int time = ((Spot)((List)imported2Spot.get(i)).get(i)).getFeature("FRAME").intValue();
<                if (firstPosition) {
<                   track.setRelativStartTimepoint(time);
<                   firstPosition = false;
<                }
< 
<                track.add(x, y, 0.0D);
<             }
< 
<             this.tracksToClassify.add(track);
<          }
<       }
< 
<       int maxNumberOfPositions = 0;
< 
<       for(int i = 0; i < this.tracksToClassify.size(); ++i) {
<          if (((TrajectoryModified)this.tracksToClassify.get(i)).size() > maxNumberOfPositions) {
<             maxNumberOfPositions = ((TrajectoryModified)this.tracksToClassify.get(i)).size();
<          }
<       }
< 
<       boolean visualize = true;
<       if (traJParametersWindow.keyWord == "keyword") {
<          this.minTrackLength = (double)Integer.valueOf(traJParametersWindow.minLengthTextS);
<          this.windowSizeClassification = Integer.valueOf(traJParametersWindow.windowTextS);
<          this.minSegmentLength = Integer.valueOf(traJParametersWindow.minSegTextS);
<       } else {
<          this.minTrackLength = 10.0D;
<          this.windowSizeClassification = 5;
<          this.minSegmentLength = 5;
<       }
< 
<       this.resampleRate = 1;
<       if (SPTBatch_.imps.getCalibration().getXUnit() == "pixel") {
<          this.pixelsize = SPTBatch_.imps.getCalibration().pixelWidth;
<       }
< 
<       if (SPTBatch_.imps.getCalibration().getXUnit() != "pixel") {
<          this.pixelsize = 0.0D;
<       }
< 
<       timelag = SPTBatch_.fps;
<       this.useReducedModelConfinedMotion = false;
<       this.showID = true;
<       this.showOverviewClasses = true;
<       this.removeGlobalDrift = false;
<       if (this.pixelsize > 1.0E-6D) {
<          for(i = 0; i < this.tracksToClassify.size(); ++i) {
<             ((TrajectoryModified)this.tracksToClassify.get(i)).scale(this.pixelsize);
<          }
<       }
< 
<       for(i = 0; i < this.tracksToClassify.size(); ++i) {
<          track = (TrajectoryModified)this.tracksToClassify.get(i);
<          int changesCounter = 0;
< 
<          for(i = 1; i < track.size(); ++i) {
<             if (((Point3dModified)track.get(i)).distance((Point3dModified)track.get(i - 1)) > Math.pow(10.0D, -12.0D)) {
<                ++changesCounter;
<             }
<          }
< 
<          if (1.0D * (double)changesCounter / (double)track.size() < 0.5D) {
<             this.tracksToClassify.remove(i);
<             ++this.ommittedTrajectories;
<             --i;
<          }
<       }
< 
<       HashMap<String, Color> mapTypeToColor = new HashMap();
<       mapTypeToColor.put("DIRECTED/ACTIVE", Color.MAGENTA);
<       mapTypeToColor.put("NORM. DIFFUSION", Color.RED);
<       mapTypeToColor.put("CONFINED", Color.YELLOW);
<       mapTypeToColor.put("SUBDIFFUSION", Color.GREEN);
<       this.parentTrajectories = new ArrayList();
<       Iterator var58 = this.tracksToClassify.iterator();
< 
<       while(var58.hasNext()) {
<          track = (TrajectoryModified)var58.next();
<          if ((double)track.size() > this.minTrackLength) {
<             this.parentTrajectories.add(track);
<          }
<       }
< 
<       StaticDriftCalculatorModified<TrajectoryModified> dcalc = new StaticDriftCalculatorModified();
<       if (this.parentTrajectories.isEmpty() == Boolean.FALSE) {
<          this.classifiedSegments = this.classifyAndSegment((ArrayList)this.parentTrajectories, modelpath, this.windowSizeClassification, this.minSegmentLength, 10, this.resampleRate);
<          int y;
<          if (visualize) {
<             Overlay ov = new Overlay();
<             i = 0;
< 
<             while(true) {
<                if (i >= this.classifiedSegments.size()) {
<                   if (this.showOverviewClasses) {
<                      classes = mapTypeToColor.keySet();
<                      Iterator<String> it = classes.iterator();
<                      y = 5;
<                      float fsize = 20.0F;
<                      AffineTransform affinetransform = new AffineTransform();
<                      FontRenderContext frc = new FontRenderContext(affinetransform, true, true);
<                      subPosCount = (int)IJ.getImage().getProcessor().getFont().getStringBounds("Norm. Diffusion", frc).getWidth();
---
> import java.util.ArrayList;
> import ij.plugin.PlugIn;
251c57,230
<                      for(Font f = IJ.getImage().getProcessor().getFont(); 1.0D * (double)subPosCount / (double)IJ.getImage().getWidth() > 0.08D; subPosCount = (int)f.getStringBounds("Norm. Diffusion", frc).getWidth()) {
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
> public class TraJClassifierTest_ implements PlugIn
> {
>     static double timelag;
>     double minTrackLength;
>     int windowSizeClassification;
>     int minSegmentLength;
>     double pixelsize;
>     int resampleRate;
>     boolean showID;
>     boolean showOverviewClasses;
>     boolean removeGlobalDrift;
>     boolean useReducedModelConfinedMotion;
>     int ommittedTrajectories;
>     public static TraJClassifierTest_ instance;
>     ArrayList<SubtrajectoryModified> classifiedSegments;
>     ArrayList<TrajectoryModified> tracksToClassify;
>     ArrayList<TrajectoryModified> parentTrajectories;
>     
>     public TraJClassifierTest_() {
>         TraJClassifierTest_.instance = this;
>     }
>     
>     public static TraJClassifierTest_ getInstance() {
>         if (TraJClassifierTest_.instance == null) {
>             TraJClassifierTest_.instance = new TraJClassifierTest_();
>         }
>         return TraJClassifierTest_.instance;
>     }
>     
>     public void run(final String arg) {
>         String modelpath = "";
>         try {
>             modelpath = this.ExportResource("/randomForestModel.RData");
>         }
>         catch (Exception e) {
>             e.printStackTrace();
>         }
>         List<Integer> trackSize = null;
>         if (!arg.contains("DEBUG")) {
>             this.tracksToClassify = new ArrayList<TrajectoryModified>();
>             TrajectoryModified.restIDCounter();
>             final List<List<Spot>> imported2Spot = new ArrayList<List<Spot>>();
>             final Set<Integer> trackIDs = (Set<Integer>)SPTBatch_.model.getTrackModel().trackIDs(true);
>             trackSize = new ArrayList<Integer>();
>             for (final Integer id : trackIDs) {
>                 final List<Spot> imported1Spot = new ArrayList<Spot>();
>                 final Set<Spot> track = (Set<Spot>)SPTBatch_.model.getTrackModel().trackSpots(id);
>                 trackSize.add(track.size());
>                 final ArrayList<Float> framesByTrack = new ArrayList<Float>();
>                 final ArrayList<Float> framesByTrackSort = new ArrayList<Float>();
>                 final ArrayList<Float> trackID = new ArrayList<Float>();
>                 final ArrayList<Integer> indexes = new ArrayList<Integer>();
>                 final List<Spot> spots = new ArrayList<Spot>();
>                 for (final Spot spot : track) {
>                     trackID.add((float)id);
>                     framesByTrack.add(Float.valueOf(spot.getFeature("FRAME").toString()));
>                     framesByTrackSort.add(Float.valueOf(spot.getFeature("FRAME").toString()));
>                     spots.add(spot);
>                 }
>                 Collections.<Float>sort(framesByTrackSort);
>                 for (int z = 0; z < framesByTrackSort.size(); ++z) {
>                     indexes.add(framesByTrack.indexOf(framesByTrackSort.get(z)));
>                 }
>                 for (int y = 0; y < indexes.size(); ++y) {
>                     imported1Spot.add(spots.get(indexes.get(y)));
>                 }
>                 imported2Spot.add(imported1Spot);
>             }
>             for (int i = 0; i < imported2Spot.size(); ++i) {
>                 final TrajectoryModified t = new TrajectoryModified(2);
>                 boolean firstPosition = true;
>                 for (int j = 0; j < imported2Spot.get(i).size(); ++j) {
>                     final double x = imported2Spot.get(i).get(j).getFeature("POSITION_X");
>                     final double y2 = imported2Spot.get(i).get(j).getFeature("POSITION_Y");
>                     final int time = imported2Spot.get(i).get(j).getFeature("FRAME").intValue();
>                     if (firstPosition) {
>                         t.setRelativStartTimepoint(time);
>                         firstPosition = false;
>                     }
>                     t.add(x, y2, 0.0);
>                 }
>                 this.tracksToClassify.add(t);
>             }
>         }
>         int maxNumberOfPositions = 0;
>         for (int k = 0; k < this.tracksToClassify.size(); ++k) {
>             if (this.tracksToClassify.get(k).size() > maxNumberOfPositions) {
>                 maxNumberOfPositions = this.tracksToClassify.get(k).size();
>             }
>         }
>         final boolean visualize = true;
>         if (traJParametersWindow.keyWord == "keyword") {
>             this.minTrackLength = Integer.valueOf(traJParametersWindow.minLengthTextS);
>             this.windowSizeClassification = Integer.valueOf(traJParametersWindow.windowTextS);
>             this.minSegmentLength = Integer.valueOf(traJParametersWindow.minSegTextS);
>         }
>         else {
>             this.minTrackLength = 10.0;
>             this.windowSizeClassification = 5;
>             this.minSegmentLength = 5;
>         }
>         this.resampleRate = 1;
>         if (SPTBatch_.imps.getCalibration().getXUnit() == "pixel") {
>             this.pixelsize = SPTBatch_.imps.getCalibration().pixelWidth;
>         }
>         if (SPTBatch_.imps.getCalibration().getXUnit() != "pixel") {
>             this.pixelsize = 0.0;
>         }
>         TraJClassifierTest_.timelag = SPTBatch_.fps;
>         this.useReducedModelConfinedMotion = false;
>         this.showID = true;
>         this.showOverviewClasses = true;
>         this.removeGlobalDrift = false;
>         if (this.pixelsize > 1.0E-6) {
>             for (int i = 0; i < this.tracksToClassify.size(); ++i) {
>                 this.tracksToClassify.get(i).scale(this.pixelsize);
>             }
>         }
>         for (int i = 0; i < this.tracksToClassify.size(); ++i) {
>             final TrajectoryModified t = this.tracksToClassify.get(i);
>             int changesCounter = 0;
>             for (int j = 1; j < t.size(); ++j) {
>                 if (t.get(j).distance(t.get(j - 1)) > Math.pow(10.0, -12.0)) {
>                     ++changesCounter;
>                 }
>             }
>             if (1.0 * changesCounter / t.size() < 0.5) {
>                 this.tracksToClassify.remove(i);
>                 ++this.ommittedTrajectories;
>                 --i;
>             }
>         }
>         final HashMap<String, Color> mapTypeToColor = new HashMap<String, Color>();
>         mapTypeToColor.put("DIRECTED/ACTIVE", Color.MAGENTA);
>         mapTypeToColor.put("NORM. DIFFUSION", Color.RED);
>         mapTypeToColor.put("CONFINED", Color.YELLOW);
>         mapTypeToColor.put("SUBDIFFUSION", Color.GREEN);
>         this.parentTrajectories = new ArrayList<TrajectoryModified>();
>         for (final TrajectoryModified track2 : this.tracksToClassify) {
>             if (track2.size() > this.minTrackLength) {
>                 this.parentTrajectories.add(track2);
>             }
>         }
>         final StaticDriftCalculatorModified<TrajectoryModified> dcalc = new StaticDriftCalculatorModified<TrajectoryModified>();
>         if (this.parentTrajectories.isEmpty() == Boolean.FALSE) {
>             this.classifiedSegments = this.classifyAndSegment(this.parentTrajectories, modelpath, this.windowSizeClassification, this.minSegmentLength, 10, this.resampleRate);
>             if (visualize) {
>                 final Overlay ov = new Overlay();
>                 for (int l = 0; l < this.classifiedSegments.size(); ++l) {
>                     final SubtrajectoryModified tr = this.classifiedSegments.get(l);
>                     ArrayList<Roi> prois = null;
>                     if (this.pixelsize > 1.0E-6) {
>                         prois = VisualizationUtilsModified.generateVisualizationRoisFromTrack(tr, mapTypeToColor.get(tr.getType()), this.showID, this.pixelsize);
>                     }
>                     else {
>                         prois = VisualizationUtilsModified.generateVisualizationRoisFromTrack(tr, mapTypeToColor.get(tr.getType()), this.showID, IJ.getImage().getCalibration().pixelWidth);
>                     }
>                     for (final Roi r : prois) {
>                         ov.add(r);
>                     }
>                 }
>                 if (this.showOverviewClasses) {
>                     final Set<String> classes = mapTypeToColor.keySet();
>                     final Iterator<String> it = classes.iterator();
>                     int y3 = 5;
>                     float fsize = 20.0f;
>                     final AffineTransform affinetransform = new AffineTransform();
>                     final FontRenderContext frc = new FontRenderContext(affinetransform, true, true);
>                     int width = (int)IJ.getImage().getProcessor().getFont().getStringBounds("Norm. Diffusion", frc).getWidth();
>                     for (Font f = IJ.getImage().getProcessor().getFont(); 1.0 * width / IJ.getImage().getWidth() > 0.08; width = (int)f.getStringBounds("Norm. Diffusion", frc).getWidth()) {
254,260c233,237
<                      }
< 
<                      TextRoi.setFont("TimesRoman", (int)fsize, 0);
< 
<                      while(it.hasNext()) {
<                         String type = (String)it.next();
<                         TextRoi troi = new TextRoi(5, y, type);
---
>                     }
>                     TextRoi.setFont("TimesRoman", (int)fsize, 0);
>                     while (it.hasNext()) {
>                         final String type = it.next();
>                         final TextRoi troi = new TextRoi(5, y3, type);
263,728c240,666
<                         ov.add(troi);
<                         y += 20;
<                      }
<                   }
< 
<                   IJ.getImage().setOverlay(ov);
<                   IJ.getImage().updateAndRepaintWindow();
<                   break;
<                }
< 
<                SubtrajectoryModified tr = (SubtrajectoryModified)this.classifiedSegments.get(i);
<                prois = null;
<                if (this.pixelsize > 1.0E-6D) {
<                   prois = VisualizationUtilsModified.generateVisualizationRoisFromTrack(tr, (Color)mapTypeToColor.get(tr.getType()), this.showID, this.pixelsize);
<                } else {
<                   prois = VisualizationUtilsModified.generateVisualizationRoisFromTrack(tr, (Color)mapTypeToColor.get(tr.getType()), this.showID, IJ.getImage().getCalibration().pixelWidth);
<                }
< 
<                Iterator var69 = prois.iterator();
< 
<                while(var69.hasNext()) {
<                   Roi r = (Roi)var69.next();
<                   ov.add(r);
<                }
< 
<                ++i;
<             }
<          }
< 
<          HashMap<String, TraJResultsTable> rtables = new HashMap();
<          rtables.put("DIRECTED/ACTIVE", new TraJResultsTable());
<          rtables.put("NORM. DIFFUSION", new TraJResultsTable());
<          rtables.put("SUBDIFFUSION", new TraJResultsTable());
<          rtables.put("CONFINED", new TraJResultsTable());
<          double sumConf = 0.0D;
< 
<          for(y = 0; y < this.classifiedSegments.size(); ++y) {
<             IJ.showProgress(y, this.classifiedSegments.size());
<             SubtrajectoryModified t = (SubtrajectoryModified)this.classifiedSegments.get(y);
<             TraJResultsTable rt = (TraJResultsTable)rtables.get(t.getType());
<             if (rt == null) {
<                SPTBatch_.taskOutput.append("Type: " + t.getType());
<                ExportImportToolsModified eit = new ExportImportToolsModified();
<                ArrayList<TrajectoryModified> hlp = new ArrayList();
<                eit.exportTrajectoryDataAsCSV(hlp, SPTBatch_.csvPath + File.separator + "bad" + ".csv");
<                SPTBatch_.taskOutput.append(t.toString());
<             }
< 
<             rt.incrementCounter();
<             rt.addValue("PARENT-ID", (double)t.getParent().getID());
<             rt.addValue("ID", (double)t.getID());
<             rt.addValue("LENGTH", (double)t.size());
<             rt.addValue("START", (double)t.getRelativeStartTimepoint());
<             rt.addValue("END", (double)(t.getRelativeStartTimepoint() + t.size() - 1));
<             rt.addValue("CLASS", t.getType());
<             dcEstim = null;
<             double dc = 0.0D;
<             DecimalFormatSymbols otherSymbols = new DecimalFormatSymbols(Locale.ENGLISH);
<             NumberFormat formatter = new DecimalFormat("0.###E0", otherSymbols);
<             double goodness = 0.0D;
<             double alphaGoodness = 0.0D;
<             double[] res;
<             String var24;
<             switch((var24 = t.getType()).hashCode()) {
<             case -1768066899:
<                if (var24.equals("DIRECTED/ACTIVE")) {
<                   ActiveTransportParametersFeatureModified apf = new ActiveTransportParametersFeatureModified(t, timelag);
<                   res = apf.evaluate();
<                   rt.addValue("(FIT) D", formatter.format(res[0]));
<                   rt.addValue("(FIT) Velocity", res[1]);
<                   goodness = res[2];
<                }
<                break;
<             case -568951419:
<                if (var24.equals("SUBDIFFUSION")) {
<                   PowerLawFeatureModified pwf = new PowerLawFeatureModified(t, 1.0D / timelag, 1, t.size() / 3);
<                   res = pwf.evaluate();
<                   dc = res[1];
<                   rt.addValue("(FIT) D", formatter.format(dc));
<                   goodness = res[2];
<                }
<                break;
<             case 160958711:
<                if (var24.equals("NORM. DIFFUSION")) {
<                   AbstractTrajectoryFeatureModified dcEstim = new RegressionDiffusionCoefficientEstimatorModified(t, 1.0D / timelag, 1, t.size() / 3);
<                   res = dcEstim.evaluate();
<                   dc = res[0];
<                   rt.addValue("(FIT) D", formatter.format(dc));
<                   goodness = res[3];
<                }
<                break;
<             case 202494376:
<                if (var24.equals("CONFINED")) {
<                   AbstractDiffusionCoefficientEstimatorModified dcEst = new RegressionDiffusionCoefficientEstimatorModified(t, 1.0D / timelag, 1, 3);
<                   ConfinedDiffusionParametersFeatureModified confp = new ConfinedDiffusionParametersFeatureModified(t, timelag, this.useReducedModelConfinedMotion, dcEst);
<                   double[] p = confp.evaluate();
<                   dc = p[1];
<                   if (this.useReducedModelConfinedMotion) {
<                      rt.addValue("(FIT) CONF. RADIUS", Math.sqrt(p[0]));
<                      rt.addValue("(FIT) D", formatter.format(p[1]));
<                      goodness = p[2];
<                   } else {
<                      rt.addValue("(FIT) CONF. RADIUS", Math.sqrt(p[0]));
<                      rt.addValue("(FIT) A [CONF. SHAPE]", p[2]);
<                      rt.addValue("(FIT) B (CONF SHAPE)", p[3]);
<                      rt.addValue("(FIT) D", formatter.format(p[1]));
<                      goodness = p[4];
<                   }
<                }
<             }
< 
<             AbstractTrajectoryFeatureModified pwf = new PowerLawFeatureModified(t, 1.0D / timelag, 1, t.size() / 3);
<             res = pwf.evaluate();
<             double alpha = res[0];
<             alphaGoodness = res[2];
<             AbstractTrajectoryFeatureModified f = new CenterOfGravityFeatureModified(t);
<             double cog_x = f.evaluate()[0];
<             double cog_y = f.evaluate()[1];
<             rt.addValue("X (COG)", cog_x);
<             rt.addValue("Y (COG)", cog_y);
<             if (!t.getType().equals("NONE")) {
<                FractalDimensionFeatureModified fdf = new FractalDimensionFeatureModified(t);
<                double v = fdf.evaluate()[0];
<                rt.addValue("FRACT. DIM.", v);
<                TrappedProbabilityFeatureModified trapped = new TrappedProbabilityFeatureModified(t);
<                v = trapped.evaluate()[0];
<                rt.addValue("TRAPPEDNESS", v);
<                EfficiencyFeatureModified eff = new EfficiencyFeatureModified(t);
<                v = eff.evaluate()[0];
<                rt.addValue("EFFICENCY", v);
<                StraightnessFeatureModified straight = new StraightnessFeatureModified(t);
<                v = straight.evaluate()[0];
<                rt.addValue("STRAIGHTNESS", v);
<                MeanSpeedFeatureModified msfeature = new MeanSpeedFeatureModified(t, timelag);
<                v = msfeature.evaluate()[1];
<                rt.addValue("SPEED", v);
<                KurtosisFeatureModified kurt = new KurtosisFeatureModified(t);
<                v = kurt.evaluate()[0];
<                rt.addValue("KURTOSIS", v);
<                rt.addValue("(FIT) ALPHA", alpha);
<                GaussianityFeautureModified gauss = new GaussianityFeautureModified(t, 1);
<                v = gauss.evaluate()[0];
<                rt.addValue("GAUSSIANITY", v);
<                Asymmetry3FeatureModified asym3 = new Asymmetry3FeatureModified(t);
<                v = asym3.evaluate()[0];
<                rt.addValue("Asymmetry", v);
<                MSDRatioFeatureModified msdratio = new MSDRatioFeatureModified(t, 1, 5);
<                v = msdratio.evaluate()[0];
<                rt.addValue("MSDRatio", v);
<                CovarianceDiffusionCoefficientEstimatorModified cest = new CovarianceDiffusionCoefficientEstimatorModified(t, 1.0D / timelag);
<                res = cest.evaluate();
<                rt.addValue("Loc. noise_sigma", (res[1] + res[2]) / 2.0D);
<                rt.addValue("Fit Goodness", goodness);
<                rt.addValue("Alpha Fit Goodness", alphaGoodness);
<                double conf = t.getConfidence();
<                sumConf += conf;
<                rt.addValue("Confidence", conf);
<             }
<          }
< 
<          Iterator<String> rtIt = rtables.keySet().iterator();
<          ResultsTable parents = new TraJResultsTable(true);
< 
<          for(int i = 0; i < this.parentTrajectories.size(); ++i) {
<             parents.incrementCounter();
<             TrajectoryModified t = (TrajectoryModified)this.parentTrajectories.get(i);
<             parents.addValue("ID", (double)t.getID());
<             parents.addValue("LENGTH", (double)t.size());
<             parents.addValue("START", (double)t.getRelativeStartTimepoint());
<             parents.addValue("END", (double)(t.getRelativeStartTimepoint() + t.size() - 1));
<             subPosCount = 0;
<             int subSegCount = 0;
<             int normPosCount = 0;
<             int normSegCount = 0;
<             int directedPosCount = 0;
<             int directSegCount = 0;
<             int confPosCount = 0;
<             int confSegCount = 0;
<             ArrayList<SubtrajectoryModified> sameParent = SubtrajectoryModified.getTracksWithSameParant(this.classifiedSegments, t.getID());
<             Iterator var99 = sameParent.iterator();
< 
<             while(var99.hasNext()) {
<                SubtrajectoryModified sub = (SubtrajectoryModified)var99.next();
<                String var101;
<                switch((var101 = sub.getType()).hashCode()) {
<                case -1768066899:
<                   if (var101.equals("DIRECTED/ACTIVE")) {
<                      directedPosCount += sub.size();
<                      ++directSegCount;
<                   }
<                   break;
<                case -568951419:
<                   if (var101.equals("SUBDIFFUSION")) {
<                      subPosCount += sub.size();
<                      ++subSegCount;
<                   }
<                   break;
<                case 160958711:
<                   if (var101.equals("NORM. DIFFUSION")) {
<                      normPosCount += sub.size();
<                      ++normSegCount;
<                   }
<                   break;
<                case 202494376:
<                   if (var101.equals("CONFINED")) {
<                      confPosCount += sub.size();
<                      ++confSegCount;
<                   }
<                }
<             }
< 
<             parents.addValue("#SEG_NORM", (double)normSegCount);
<             parents.addValue("#POS_NORM", (double)normPosCount);
<             parents.addValue("#SEG_SUB", (double)subSegCount);
<             parents.addValue("#POS_SUB", (double)subPosCount);
<             parents.addValue("#SEG_CONF", (double)confSegCount);
<             parents.addValue("#POS_CONF", (double)confPosCount);
<             parents.addValue("#SEG_DIRECTED", (double)directSegCount);
<             parents.addValue("#POS_DIRECTED", (double)directedPosCount);
<          }
< 
<          String trajVersion = TrajectoryModified.class.getPackage().getImplementationVersion();
<          double[] drift = dcalc.calculateDrift(this.parentTrajectories);
<          ResultsTable overall = new ResultsTable();
<          overall.incrementCounter();
<          overall.addValue("Mean confindence", sumConf / (double)this.classifiedSegments.size());
<          overall.addValue("Drift x", drift[0]);
<          overall.addValue("Drift y", drift[1]);
<          overall.addValue("Omitted segments", (double)this.ommittedTrajectories);
<          overall.addValue("Min. track length", this.minTrackLength);
<          overall.addValue("Window size", (double)(this.windowSizeClassification * 2));
<          overall.addValue("Min. segment length", (double)this.minSegmentLength);
<          overall.addValue("Resamplerate", (double)this.resampleRate);
<          overall.addValue("Pixelsize", this.pixelsize);
<          overall.addValue("Framerate", 1.0D / timelag);
<          overall.addValue("Reduced conf. model", Boolean.toString(this.useReducedModelConfinedMotion));
<          overall.addValue("Remove global drift", Boolean.toString(this.removeGlobalDrift));
<          overall.addValue("TraJ library version", trajVersion);
<          overall.save(SPTBatch_.directDiff + File.separator + "Settings & Miscellaneous" + SPTBatch_.imps.getShortTitle() + ".xls");
<          parents.save(SPTBatch_.directDiff + File.separator + "Parents_" + SPTBatch_.imps.getShortTitle() + ".xls");
<          rtIt = rtables.keySet().iterator();
< 
<          while(rtIt.hasNext()) {
<             String rt = (String)rtIt.next();
<             if (rt.equals("DIRECTED/ACTIVE") == Boolean.TRUE) {
<                ((TraJResultsTable)rtables.get(rt)).save(SPTBatch_.directDiff + File.separator + "DIRECTED_ACTIVE" + "_trajectories_" + SPTBatch_.imps.getShortTitle() + ".xls");
<             } else {
<                ((TraJResultsTable)rtables.get(rt)).save(SPTBatch_.directDiff + File.separator + rt + "_trajectories_" + SPTBatch_.imps.getShortTitle() + ".xls");
<             }
<          }
<       }
< 
<    }
< 
<    public ArrayList<SubtrajectoryModified> classifyAndSegment(TrajectoryModified trackToClassify, String modelpath, int windowSizeClassification, int minSegmentLength, int modeFilterLength, int resampleRate) {
<       ArrayList<TrajectoryModified> help = new ArrayList();
<       help.add(trackToClassify);
<       return this.classifyAndSegment(help, modelpath, windowSizeClassification, minSegmentLength, modeFilterLength, resampleRate);
<    }
< 
<    public ArrayList<SubtrajectoryModified> classifyAndSegment(ArrayList<TrajectoryModified> tracksToClassify, String modelpath, int windowSizeClassification, int minSegmentLength, int modeFilterLength, int resampleRate) {
<       ArrayList<SubtrajectoryModified> classified = new ArrayList();
<       int j = 0;
<       RRFClassifierRenjinModified rrf = new RRFClassifierRenjinModified(modelpath, (double)resampleRate * timelag);
<       rrf.start();
<       WeightedWindowedClassificationProcessModified wcp = new WeightedWindowedClassificationProcessModified();
<       int subidcounter = 1;
< 
<       boolean var26;
<       for(Iterator var13 = tracksToClassify.iterator(); var13.hasNext(); var26 = false) {
<          TrajectoryModified track = (TrajectoryModified)var13.next();
<          ++j;
<          IJ.showProgress(j, tracksToClassify.size());
<          String[] classes = wcp.windowedClassification(track, rrf, windowSizeClassification, resampleRate);
<          double[] classConfidence = wcp.getPositionConfidence();
<          classes = movingMode(classes, modeFilterLength);
<          double sumConf = 0.0D;
<          int Nconf = 0;
<          SubtrajectoryModified tr = new SubtrajectoryModified(track, 2);
<          tr.setID(subidcounter);
<          ++subidcounter;
<          tr.add(((Point3dModified)track.get(0)).x, ((Point3dModified)track.get(0)).y, 0.0D);
<          sumConf += classConfidence[0];
<          int Nconf = Nconf + 1;
<          String prevCls = classes[0];
<          int start = track.getRelativeStartTimepoint();
<          tr.setRelativStartTimepoint(start);
<          tr.setType(prevCls);
< 
<          for(int i = 1; i < classes.length; ++i) {
<             if (prevCls == classes[i]) {
<                tr.add(((Point3dModified)track.get(i)).x, ((Point3dModified)track.get(i)).y, 0.0D);
<                sumConf += classConfidence[i];
<                ++Nconf;
<             } else {
<                tr.setConfidence(sumConf / (double)Nconf);
<                classified.add(tr);
<                tr = new SubtrajectoryModified(track, 2);
<                tr.setID(subidcounter);
<                ++subidcounter;
<                tr.setRelativStartTimepoint(start + i);
<                tr.add(((Point3dModified)track.get(i)).x, ((Point3dModified)track.get(i)).y, 0.0D);
<                sumConf = classConfidence[i];
<                Nconf = 1;
<                prevCls = classes[i];
<                tr.setType(prevCls);
<             }
<          }
< 
<          tr.setConfidence(sumConf / (double)Nconf);
<          classified.add(tr);
<          sumConf = 0.0D;
<       }
< 
<       rrf.stop();
< 
<       for(int i = 0; i < classified.size(); ++i) {
<          if (((SubtrajectoryModified)classified.get(i)).size() < minSegmentLength) {
<             classified.remove(i);
<             --i;
<          }
<       }
< 
<       return classified;
<    }
< 
<    public double getTimelag() {
<       return timelag;
<    }
< 
<    public static String[] movingMode(String[] types, int n) {
<       ArrayList<String> ltypes = new ArrayList();
< 
<       for(int i = 0; i < types.length; ++i) {
<          ltypes.add(types[i]);
<       }
< 
<       return movingMode(ltypes, n);
<    }
< 
<    public static String[] movingMode(ArrayList<String> types, int n) {
<       int windowsize = 2 * n + 1;
<       HashSet<String> uniqueTypes = new HashSet();
<       uniqueTypes.addAll(types);
<       HashMap<String, Integer> mapTypeToInt = new HashMap();
<       HashMap<Integer, String> mapIntToType = new HashMap();
<       Iterator<String> it = uniqueTypes.iterator();
< 
<       for(int key = 0; it.hasNext(); ++key) {
<          String type = (String)it.next();
<          mapTypeToInt.put(type, key);
<          mapIntToType.put(key, type);
<       }
< 
<       String[] medTypes = new String[types.size()];
< 
<       int i;
<       for(i = 0; i < n; ++i) {
<          medTypes[i] = (String)types.get(i);
<       }
< 
<       for(i = types.size() - n; i < types.size(); ++i) {
<          medTypes[i] = (String)types.get(i);
<       }
< 
<       for(i = 0; i < types.size() - windowsize + 1; ++i) {
<          List<String> sub = types.subList(i, i + windowsize - 1);
<          double[] values = new double[sub.size()];
< 
<          for(int j = 0; j < sub.size(); ++j) {
<             values[j] = (double)(Integer)mapTypeToInt.get(sub.get(j));
<          }
< 
<          medTypes[i + n] = (String)mapIntToType.get((int)StatUtils.mode(values)[0]);
<       }
< 
<       return medTypes;
<    }
< 
<    public ArrayList<SubtrajectoryModified> getClassifiedTrajectories() {
<       return this.classifiedSegments;
<    }
< 
<    public ArrayList<TrajectoryModified> getParentTrajectories() {
<       return this.parentTrajectories;
<    }
< 
<    public String ExportResource(String resourceName) throws Exception {
<       InputStream stream = null;
<       FileOutputStream resStreamOut = null;
< 
<       String tmpFolder;
<       try {
<          stream = this.getClass().getResourceAsStream(resourceName);
<          if (stream == null) {
<             IJ.error("Cannot get resource \"" + resourceName + "\" from Jar file.");
<             throw new Exception("Cannot get resource \"" + resourceName + "\" from Jar file.");
<          }
< 
<          byte[] buffer = new byte[4096];
<          File folderDir = new File(IJ.getDirectory("temp") + "/.trajclassifier");
<          if (!folderDir.exists()) {
<             folderDir.mkdir();
<          }
< 
<          tmpFolder = folderDir.getPath().replace('\\', '/');
<          resStreamOut = new FileOutputStream(tmpFolder + resourceName);
< 
<          int readBytes;
<          while((readBytes = stream.read(buffer)) > 0) {
<             resStreamOut.write(buffer, 0, readBytes);
<          }
<       } catch (Exception var11) {
<          IJ.error(var11.getMessage());
<          throw var11;
<       } finally {
<          stream.close();
<          resStreamOut.close();
<       }
< 
<       return tmpFolder + resourceName;
<    }
< 
<    public void setTracksToClassify(ArrayList<TrajectoryModified> t) {
<       this.tracksToClassify = t;
<    }
< 
<    public double getMinTrackLength() {
<       return this.minTrackLength;
<    }
< 
<    public void setMinTrackLength(double minTrackLength) {
<       this.minTrackLength = minTrackLength;
<    }
< 
<    public double getPixelsize() {
<       return this.pixelsize;
<    }
< 
<    public void setPixelsize(double pixelsize) {
<       this.pixelsize = pixelsize;
<    }
< 
<    public boolean isShowID() {
<       return this.showID;
<    }
< 
<    public void setShowID(boolean showID) {
<       this.showID = showID;
<    }
< 
<    public int getWindowSizeClassification() {
<       return this.windowSizeClassification;
<    }
< 
<    public boolean isUseReducedModelConfinedMotion() {
<       return this.useReducedModelConfinedMotion;
<    }
< 
<    public void setTimelag(double timelag) {
<       TraJClassifierTest_.timelag = timelag;
<    }
< 
<    public void setWindowSizeClassification(int windowSizeClassification) {
<       this.windowSizeClassification = windowSizeClassification;
<    }
---
>                         ov.add((Roi)troi);
>                         y3 += 20;
>                     }
>                 }
>                 IJ.getImage().setOverlay(ov);
>                 IJ.getImage().updateAndRepaintWindow();
>             }
>             final HashMap<String, TraJResultsTable> rtables = new HashMap<String, TraJResultsTable>();
>             rtables.put("DIRECTED/ACTIVE", new TraJResultsTable());
>             rtables.put("NORM. DIFFUSION", new TraJResultsTable());
>             rtables.put("SUBDIFFUSION", new TraJResultsTable());
>             rtables.put("CONFINED", new TraJResultsTable());
>             double sumConf = 0.0;
>             for (int m = 0; m < this.classifiedSegments.size(); ++m) {
>                 IJ.showProgress(m, this.classifiedSegments.size());
>                 final SubtrajectoryModified t2 = this.classifiedSegments.get(m);
>                 final TraJResultsTable rt = rtables.get(t2.getType());
>                 if (rt == null) {
>                     SPTBatch_.taskOutput.append("Type: " + t2.getType());
>                     final ExportImportToolsModified eit = new ExportImportToolsModified();
>                     final ArrayList<TrajectoryModified> hlp = new ArrayList<TrajectoryModified>();
>                     eit.exportTrajectoryDataAsCSV(hlp, String.valueOf(SPTBatch_.csvPath) + File.separator + "bad" + ".csv");
>                     SPTBatch_.taskOutput.append(t2.toString());
>                 }
>                 rt.incrementCounter();
>                 rt.addValue("PARENT-ID", (double)t2.getParent().getID());
>                 rt.addValue("ID", (double)t2.getID());
>                 rt.addValue("LENGTH", (double)t2.size());
>                 rt.addValue("START", (double)t2.getRelativeStartTimepoint());
>                 rt.addValue("END", (double)(t2.getRelativeStartTimepoint() + t2.size() - 1));
>                 rt.addValue("CLASS", t2.getType());
>                 AbstractTrajectoryFeatureModified dcEstim = null;
>                 double dc = 0.0;
>                 final DecimalFormatSymbols otherSymbols = new DecimalFormatSymbols(Locale.ENGLISH);
>                 final NumberFormat formatter = new DecimalFormat("0.###E0", otherSymbols);
>                 double goodness = 0.0;
>                 double alphaGoodness = 0.0;
>                 final String type2;
>                 switch (type2 = t2.getType()) {
>                     case "DIRECTED/ACTIVE": {
>                         final ActiveTransportParametersFeatureModified apf = new ActiveTransportParametersFeatureModified(t2, TraJClassifierTest_.timelag);
>                         final double[] res = apf.evaluate();
>                         rt.addValue("(FIT) D", formatter.format(res[0]));
>                         rt.addValue("(FIT) Velocity", res[1]);
>                         goodness = res[2];
>                         break;
>                     }
>                     case "SUBDIFFUSION": {
>                         final PowerLawFeatureModified pwf = new PowerLawFeatureModified(t2, 1.0 / TraJClassifierTest_.timelag, 1, t2.size() / 3);
>                         final double[] res = pwf.evaluate();
>                         dc = res[1];
>                         rt.addValue("(FIT) D", formatter.format(dc));
>                         goodness = res[2];
>                         break;
>                     }
>                     case "NORM. DIFFUSION": {
>                         dcEstim = new RegressionDiffusionCoefficientEstimatorModified(t2, 1.0 / TraJClassifierTest_.timelag, 1, t2.size() / 3);
>                         final double[] res = dcEstim.evaluate();
>                         dc = res[0];
>                         rt.addValue("(FIT) D", formatter.format(dc));
>                         goodness = res[3];
>                         break;
>                     }
>                     case "CONFINED": {
>                         final AbstractDiffusionCoefficientEstimatorModified dcEst = new RegressionDiffusionCoefficientEstimatorModified(t2, 1.0 / TraJClassifierTest_.timelag, 1, 3);
>                         final ConfinedDiffusionParametersFeatureModified confp = new ConfinedDiffusionParametersFeatureModified(t2, TraJClassifierTest_.timelag, this.useReducedModelConfinedMotion, dcEst);
>                         final double[] p = confp.evaluate();
>                         dc = p[1];
>                         if (this.useReducedModelConfinedMotion) {
>                             rt.addValue("(FIT) CONF. RADIUS", Math.sqrt(p[0]));
>                             rt.addValue("(FIT) D", formatter.format(p[1]));
>                             goodness = p[2];
>                             break;
>                         }
>                         rt.addValue("(FIT) CONF. RADIUS", Math.sqrt(p[0]));
>                         rt.addValue("(FIT) A [CONF. SHAPE]", p[2]);
>                         rt.addValue("(FIT) B (CONF SHAPE)", p[3]);
>                         rt.addValue("(FIT) D", formatter.format(p[1]));
>                         goodness = p[4];
>                         break;
>                     }
>                     default:
>                         break;
>                 }
>                 final AbstractTrajectoryFeatureModified pwf2 = new PowerLawFeatureModified(t2, 1.0 / TraJClassifierTest_.timelag, 1, t2.size() / 3);
>                 double[] res = pwf2.evaluate();
>                 final double alpha = res[0];
>                 alphaGoodness = res[2];
>                 final AbstractTrajectoryFeatureModified f2 = new CenterOfGravityFeatureModified(t2);
>                 final double cog_x = f2.evaluate()[0];
>                 final double cog_y = f2.evaluate()[1];
>                 rt.addValue("X (COG)", cog_x);
>                 rt.addValue("Y (COG)", cog_y);
>                 if (!t2.getType().equals("NONE")) {
>                     final FractalDimensionFeatureModified fdf = new FractalDimensionFeatureModified(t2);
>                     double v = fdf.evaluate()[0];
>                     rt.addValue("FRACT. DIM.", v);
>                     final TrappedProbabilityFeatureModified trapped = new TrappedProbabilityFeatureModified(t2);
>                     v = trapped.evaluate()[0];
>                     rt.addValue("TRAPPEDNESS", v);
>                     final EfficiencyFeatureModified eff = new EfficiencyFeatureModified(t2);
>                     v = eff.evaluate()[0];
>                     rt.addValue("EFFICENCY", v);
>                     final StraightnessFeatureModified straight = new StraightnessFeatureModified(t2);
>                     v = straight.evaluate()[0];
>                     rt.addValue("STRAIGHTNESS", v);
>                     final MeanSpeedFeatureModified msfeature = new MeanSpeedFeatureModified(t2, TraJClassifierTest_.timelag);
>                     v = msfeature.evaluate()[1];
>                     rt.addValue("SPEED", v);
>                     final KurtosisFeatureModified kurt = new KurtosisFeatureModified(t2);
>                     v = kurt.evaluate()[0];
>                     rt.addValue("KURTOSIS", v);
>                     rt.addValue("(FIT) ALPHA", alpha);
>                     final GaussianityFeautureModified gauss = new GaussianityFeautureModified(t2, 1);
>                     v = gauss.evaluate()[0];
>                     rt.addValue("GAUSSIANITY", v);
>                     final Asymmetry3FeatureModified asym3 = new Asymmetry3FeatureModified(t2);
>                     v = asym3.evaluate()[0];
>                     rt.addValue("Asymmetry", v);
>                     final MSDRatioFeatureModified msdratio = new MSDRatioFeatureModified(t2, 1, 5);
>                     v = msdratio.evaluate()[0];
>                     rt.addValue("MSDRatio", v);
>                     final CovarianceDiffusionCoefficientEstimatorModified cest = new CovarianceDiffusionCoefficientEstimatorModified(t2, 1.0 / TraJClassifierTest_.timelag);
>                     res = cest.evaluate();
>                     rt.addValue("Loc. noise_sigma", (res[1] + res[2]) / 2.0);
>                     rt.addValue("Fit Goodness", goodness);
>                     rt.addValue("Alpha Fit Goodness", alphaGoodness);
>                     final double conf = t2.getConfidence();
>                     sumConf += conf;
>                     rt.addValue("Confidence", conf);
>                 }
>             }
>             Iterator<String> rtIt = rtables.keySet().iterator();
>             final ResultsTable parents = (ResultsTable)new TraJResultsTable(true);
>             for (int i2 = 0; i2 < this.parentTrajectories.size(); ++i2) {
>                 parents.incrementCounter();
>                 final TrajectoryModified t3 = this.parentTrajectories.get(i2);
>                 parents.addValue("ID", (double)t3.getID());
>                 parents.addValue("LENGTH", (double)t3.size());
>                 parents.addValue("START", (double)t3.getRelativeStartTimepoint());
>                 parents.addValue("END", (double)(t3.getRelativeStartTimepoint() + t3.size() - 1));
>                 int subPosCount = 0;
>                 int subSegCount = 0;
>                 int normPosCount = 0;
>                 int normSegCount = 0;
>                 int directedPosCount = 0;
>                 int directSegCount = 0;
>                 int confPosCount = 0;
>                 int confSegCount = 0;
>                 final ArrayList<SubtrajectoryModified> sameParent = SubtrajectoryModified.getTracksWithSameParant(this.classifiedSegments, t3.getID());
>                 for (final SubtrajectoryModified sub : sameParent) {
>                     final String type3;
>                     switch ((type3 = sub.getType()).hashCode()) {
>                         case -1768066899: {
>                             if (!type3.equals("DIRECTED/ACTIVE")) {
>                                 continue;
>                             }
>                             directedPosCount += sub.size();
>                             ++directSegCount;
>                             continue;
>                         }
>                         case -568951419: {
>                             if (!type3.equals("SUBDIFFUSION")) {
>                                 continue;
>                             }
>                             subPosCount += sub.size();
>                             ++subSegCount;
>                             continue;
>                         }
>                         case 160958711: {
>                             if (!type3.equals("NORM. DIFFUSION")) {
>                                 continue;
>                             }
>                             normPosCount += sub.size();
>                             ++normSegCount;
>                             continue;
>                         }
>                         case 202494376: {
>                             if (!type3.equals("CONFINED")) {
>                                 continue;
>                             }
>                             confPosCount += sub.size();
>                             ++confSegCount;
>                             continue;
>                         }
>                         default: {
>                             continue;
>                         }
>                     }
>                 }
>                 parents.addValue("#SEG_NORM", (double)normSegCount);
>                 parents.addValue("#POS_NORM", (double)normPosCount);
>                 parents.addValue("#SEG_SUB", (double)subSegCount);
>                 parents.addValue("#POS_SUB", (double)subPosCount);
>                 parents.addValue("#SEG_CONF", (double)confSegCount);
>                 parents.addValue("#POS_CONF", (double)confPosCount);
>                 parents.addValue("#SEG_DIRECTED", (double)directSegCount);
>                 parents.addValue("#POS_DIRECTED", (double)directedPosCount);
>             }
>             final String trajVersion = TrajectoryModified.class.getPackage().getImplementationVersion();
>             final double[] drift = dcalc.calculateDrift(this.parentTrajectories);
>             final ResultsTable overall = new ResultsTable();
>             overall.incrementCounter();
>             overall.addValue("Mean confindence", sumConf / this.classifiedSegments.size());
>             overall.addValue("Drift x", drift[0]);
>             overall.addValue("Drift y", drift[1]);
>             overall.addValue("Omitted segments", (double)this.ommittedTrajectories);
>             overall.addValue("Min. track length", this.minTrackLength);
>             overall.addValue("Window size", (double)(this.windowSizeClassification * 2));
>             overall.addValue("Min. segment length", (double)this.minSegmentLength);
>             overall.addValue("Resamplerate", (double)this.resampleRate);
>             overall.addValue("Pixelsize", this.pixelsize);
>             overall.addValue("Framerate", 1.0 / TraJClassifierTest_.timelag);
>             overall.addValue("Reduced conf. model", Boolean.toString(this.useReducedModelConfinedMotion));
>             overall.addValue("Remove global drift", Boolean.toString(this.removeGlobalDrift));
>             overall.addValue("TraJ library version", trajVersion);
>             overall.save(SPTBatch_.directDiff + File.separator + "Settings & Miscellaneous" + SPTBatch_.imps.getShortTitle() + ".xls");
>             parents.save(SPTBatch_.directDiff + File.separator + "Parents_" + SPTBatch_.imps.getShortTitle() + ".xls");
>             rtIt = rtables.keySet().iterator();
>             while (rtIt.hasNext()) {
>                 final String rt2 = rtIt.next();
>                 if (rt2.equals("DIRECTED/ACTIVE") == Boolean.TRUE) {
>                     rtables.get(rt2).save(SPTBatch_.directDiff + File.separator + "DIRECTED_ACTIVE" + "_trajectories_" + SPTBatch_.imps.getShortTitle() + ".xls");
>                 }
>                 else {
>                     rtables.get(rt2).save(SPTBatch_.directDiff + File.separator + rt2 + "_trajectories_" + SPTBatch_.imps.getShortTitle() + ".xls");
>                 }
>             }
>         }
>     }
>     
>     public ArrayList<SubtrajectoryModified> classifyAndSegment(final TrajectoryModified trackToClassify, final String modelpath, final int windowSizeClassification, final int minSegmentLength, final int modeFilterLength, final int resampleRate) {
>         final ArrayList<TrajectoryModified> help = new ArrayList<TrajectoryModified>();
>         help.add(trackToClassify);
>         return this.classifyAndSegment(help, modelpath, windowSizeClassification, minSegmentLength, modeFilterLength, resampleRate);
>     }
>     
>     public ArrayList<SubtrajectoryModified> classifyAndSegment(final ArrayList<TrajectoryModified> tracksToClassify, final String modelpath, final int windowSizeClassification, final int minSegmentLength, final int modeFilterLength, final int resampleRate) {
>         final ArrayList<SubtrajectoryModified> classified = new ArrayList<SubtrajectoryModified>();
>         int j = 0;
>         final RRFClassifierRenjinModified rrf = new RRFClassifierRenjinModified(modelpath, resampleRate * TraJClassifierTest_.timelag);
>         rrf.start();
>         final WeightedWindowedClassificationProcessModified wcp = new WeightedWindowedClassificationProcessModified();
>         int subidcounter = 1;
>         for (final TrajectoryModified track : tracksToClassify) {
>             IJ.showProgress(++j, tracksToClassify.size());
>             final TrajectoryModified mTrack = track;
>             String[] classes = wcp.windowedClassification(mTrack, rrf, windowSizeClassification, resampleRate);
>             final double[] classConfidence = wcp.getPositionConfidence();
>             classes = movingMode(classes, modeFilterLength);
>             double sumConf = 0.0;
>             int Nconf = 0;
>             SubtrajectoryModified tr = new SubtrajectoryModified(track, 2);
>             tr.setID(subidcounter);
>             ++subidcounter;
>             tr.add(track.get(0).x, track.get(0).y, 0.0);
>             sumConf += classConfidence[0];
>             ++Nconf;
>             String prevCls = classes[0];
>             final int start = track.getRelativeStartTimepoint();
>             tr.setRelativStartTimepoint(start);
>             tr.setType(prevCls);
>             for (int i = 1; i < classes.length; ++i) {
>                 if (prevCls == classes[i]) {
>                     tr.add(track.get(i).x, track.get(i).y, 0.0);
>                     sumConf += classConfidence[i];
>                     ++Nconf;
>                 }
>                 else {
>                     tr.setConfidence(sumConf / Nconf);
>                     classified.add(tr);
>                     tr = new SubtrajectoryModified(track, 2);
>                     tr.setID(subidcounter);
>                     ++subidcounter;
>                     tr.setRelativStartTimepoint(start + i);
>                     tr.add(track.get(i).x, track.get(i).y, 0.0);
>                     sumConf = classConfidence[i];
>                     Nconf = 1;
>                     prevCls = classes[i];
>                     tr.setType(prevCls);
>                 }
>             }
>             tr.setConfidence(sumConf / Nconf);
>             classified.add(tr);
>             sumConf = 0.0;
>             Nconf = 0;
>         }
>         rrf.stop();
>         for (int k = 0; k < classified.size(); ++k) {
>             if (classified.get(k).size() < minSegmentLength) {
>                 classified.remove(k);
>                 --k;
>             }
>         }
>         return classified;
>     }
>     
>     public double getTimelag() {
>         return TraJClassifierTest_.timelag;
>     }
>     
>     public static String[] movingMode(final String[] types, final int n) {
>         final ArrayList<String> ltypes = new ArrayList<String>();
>         for (int i = 0; i < types.length; ++i) {
>             ltypes.add(types[i]);
>         }
>         return movingMode(ltypes, n);
>     }
>     
>     public static String[] movingMode(final ArrayList<String> types, final int n) {
>         final int windowsize = 2 * n + 1;
>         final HashSet<String> uniqueTypes = new HashSet<String>();
>         uniqueTypes.addAll((Collection<?>)types);
>         final HashMap<String, Integer> mapTypeToInt = new HashMap<String, Integer>();
>         final HashMap<Integer, String> mapIntToType = new HashMap<Integer, String>();
>         final Iterator<String> it = uniqueTypes.iterator();
>         int key = 0;
>         while (it.hasNext()) {
>             final String type = it.next();
>             mapTypeToInt.put(type, key);
>             mapIntToType.put(key, type);
>             ++key;
>         }
>         final String[] medTypes = new String[types.size()];
>         for (int i = 0; i < n; ++i) {
>             medTypes[i] = types.get(i);
>         }
>         for (int i = types.size() - n; i < types.size(); ++i) {
>             medTypes[i] = types.get(i);
>         }
>         for (int i = 0; i < types.size() - windowsize + 1; ++i) {
>             final List<String> sub = types.subList(i, i + windowsize - 1);
>             final double[] values = new double[sub.size()];
>             for (int j = 0; j < sub.size(); ++j) {
>                 values[j] = mapTypeToInt.get(sub.get(j));
>             }
>             medTypes[i + n] = mapIntToType.get((int)StatUtils.mode(values)[0]);
>         }
>         return medTypes;
>     }
>     
>     public ArrayList<SubtrajectoryModified> getClassifiedTrajectories() {
>         return this.classifiedSegments;
>     }
>     
>     public ArrayList<TrajectoryModified> getParentTrajectories() {
>         return this.parentTrajectories;
>     }
>     
>     public String ExportResource(final String resourceName) throws Exception {
>         InputStream stream = null;
>         OutputStream resStreamOut = null;
>         String tmpFolder;
>         try {
>             stream = this.getClass().getResourceAsStream(resourceName);
>             if (stream == null) {
>                 IJ.error("Cannot get resource \"" + resourceName + "\" from Jar file.");
>                 throw new Exception("Cannot get resource \"" + resourceName + "\" from Jar file.");
>             }
>             final byte[] buffer = new byte[4096];
>             final File folderDir = new File(String.valueOf(IJ.getDirectory("temp")) + "/.trajclassifier");
>             if (!folderDir.exists()) {
>                 folderDir.mkdir();
>             }
>             tmpFolder = folderDir.getPath().replace('\\', '/');
>             resStreamOut = new FileOutputStream(String.valueOf(tmpFolder) + resourceName);
>             int readBytes;
>             while ((readBytes = stream.read(buffer)) > 0) {
>                 resStreamOut.write(buffer, 0, readBytes);
>             }
>         }
>         catch (Exception ex) {
>             IJ.error(ex.getMessage());
>             throw ex;
>         }
>         finally {
>             stream.close();
>             resStreamOut.close();
>         }
>         stream.close();
>         resStreamOut.close();
>         return String.valueOf(tmpFolder) + resourceName;
>     }
>     
>     public void setTracksToClassify(final ArrayList<TrajectoryModified> t) {
>         this.tracksToClassify = t;
>     }
>     
>     public double getMinTrackLength() {
>         return this.minTrackLength;
>     }
>     
>     public void setMinTrackLength(final double minTrackLength) {
>         this.minTrackLength = minTrackLength;
>     }
>     
>     public double getPixelsize() {
>         return this.pixelsize;
>     }
>     
>     public void setPixelsize(final double pixelsize) {
>         this.pixelsize = pixelsize;
>     }
>     
>     public boolean isShowID() {
>         return this.showID;
>     }
>     
>     public void setShowID(final boolean showID) {
>         this.showID = showID;
>     }
>     
>     public int getWindowSizeClassification() {
>         return this.windowSizeClassification;
>     }
>     
>     public boolean isUseReducedModelConfinedMotion() {
>         return this.useReducedModelConfinedMotion;
>     }
>     
>     public void setTimelag(final double timelag) {
>         TraJClassifierTest_.timelag = timelag;
>     }
>     
>     public void setWindowSizeClassification(final int windowSizeClassification) {
>         this.windowSizeClassification = windowSizeClassification;
>     }
diff -r TrackAnalyzer_/trajectory_classifier/AbstractClassifierModified.java procyon/trajectory_classifier/AbstractClassifierModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
6,15c10,20
< public abstract class AbstractClassifierModified {
<    public abstract String classify(TrajectoryModified var1);
< 
<    public abstract void start();
< 
<    public abstract void stop();
< 
<    public abstract String[] classify(ArrayList<TrajectoryModified> var1);
< 
<    public abstract double[] getConfindence();
---
> public abstract class AbstractClassifierModified
> {
>     public abstract String classify(final TrajectoryModified p0);
>     
>     public abstract void start();
>     
>     public abstract void stop();
>     
>     public abstract String[] classify(final ArrayList<TrajectoryModified> p0);
>     
>     public abstract double[] getConfindence();
diff -r TrackAnalyzer_/trajectory_classifier/ExportImportToolsModified.java procyon/trajectory_classifier/ExportImportToolsModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
2a7
> import java.io.Reader;
4d8
< import com.opencsv.CSVWriter;
6d9
< import java.io.FileWriter;
8,9d10
< import java.util.ArrayList;
< import traJ.TrajectoryModified;
10a12,16
> import java.io.Writer;
> import com.opencsv.CSVWriter;
> import java.io.FileWriter;
> import traJ.TrajectoryModified;
> import java.util.ArrayList;
12,26c18,31
< public class ExportImportToolsModified {
<    public void exportTrajectoryDataAsCSV(ArrayList<? extends TrajectoryModified> tracks, String path) {
<       String[] nextLine = null;
< 
<       try {
<          CSVWriter writer = new CSVWriter(new FileWriter(path, false));
<          nextLine = new String[]{"ID", "X", "Y", "CLASS"};
<          writer.writeNext(nextLine);
< 
<          for(int i = 0; i < tracks.size(); ++i) {
<             TrajectoryModified t = (TrajectoryModified)tracks.get(i);
< 
<             for(int j = 0; j < t.size(); ++j) {
<                nextLine = new String[]{"" + t.getID(), "" + ((Point3dModified)t.get(j)).x, "" + ((Point3dModified)t.get(j)).y, t.getType()};
<                writer.writeNext(nextLine);
---
> public class ExportImportToolsModified
> {
>     public void exportTrajectoryDataAsCSV(final ArrayList<? extends TrajectoryModified> tracks, final String path) {
>         String[] nextLine = null;
>         try {
>             final CSVWriter writer = new CSVWriter((Writer)new FileWriter(path, false));
>             nextLine = new String[] { "ID", "X", "Y", "CLASS" };
>             writer.writeNext(nextLine);
>             for (int i = 0; i < tracks.size(); ++i) {
>                 final TrajectoryModified t = (TrajectoryModified)tracks.get(i);
>                 for (int j = 0; j < t.size(); ++j) {
>                     nextLine = new String[] { new StringBuilder().append(t.getID()).toString(), new StringBuilder().append(t.get(j).x).toString(), new StringBuilder().append(t.get(j).y).toString(), t.getType() };
>                     writer.writeNext(nextLine);
>                 }
28,65c33,67
<          }
< 
<          writer.close();
<       } catch (IOException var8) {
<          var8.printStackTrace();
<       }
< 
<    }
< 
<    public ArrayList<TrajectoryModified> importTrajectoryDataFromCSV(String path) {
<       ArrayList tracks = new ArrayList();
< 
<       try {
<          CSVReader reader = new CSVReader(new FileReader(path));
<          reader.readNext();
<          TrajectoryModified t = null;
<          int lastID = -1;
< 
<          String[] nextLine;
<          while((nextLine = reader.readNext()) != null) {
<             int nextID = Integer.parseInt(nextLine[0]);
<             double nextX = Double.parseDouble(nextLine[1]);
<             double nextY = Double.parseDouble(nextLine[2]);
<             String nextClass = nextLine[3];
<             if (nextID == lastID) {
<                System.out.println();
<                t.add(nextX, nextY, 0.0D);
<                lastID = nextID;
<             } else {
<                if (t != null) {
<                   tracks.add(t);
<                }
< 
<                t = new TrajectoryModified(2);
<                t.setID(nextID);
<                t.setType(nextClass);
<                t.add(nextX, nextY, 0.0D);
<                lastID = nextID;
---
>             writer.close();
>         }
>         catch (IOException e) {
>             e.printStackTrace();
>         }
>     }
>     
>     public ArrayList<TrajectoryModified> importTrajectoryDataFromCSV(final String path) {
>         final ArrayList<TrajectoryModified> tracks = new ArrayList<TrajectoryModified>();
>         try {
>             final CSVReader reader = new CSVReader((Reader)new FileReader(path));
>             reader.readNext();
>             TrajectoryModified t = null;
>             int lastID = -1;
>             String[] nextLine;
>             while ((nextLine = reader.readNext()) != null) {
>                 final int nextID = Integer.parseInt(nextLine[0]);
>                 final double nextX = Double.parseDouble(nextLine[1]);
>                 final double nextY = Double.parseDouble(nextLine[2]);
>                 final String nextClass = nextLine[3];
>                 if (nextID == lastID) {
>                     System.out.println();
>                     t.add(nextX, nextY, 0.0);
>                     lastID = nextID;
>                 }
>                 else {
>                     if (t != null) {
>                         tracks.add(t);
>                     }
>                     t = new TrajectoryModified(2);
>                     t.setID(nextID);
>                     t.setType(nextClass);
>                     t.add(nextX, nextY, 0.0);
>                     lastID = nextID;
>                 }
67,76c69,76
<          }
< 
<          tracks.add(t);
<          reader.close();
<       } catch (IOException var13) {
<          var13.printStackTrace();
<       }
< 
<       return tracks;
<    }
---
>             tracks.add(t);
>             reader.close();
>         }
>         catch (IOException e) {
>             e.printStackTrace();
>         }
>         return tracks;
>     }
diff -r TrackAnalyzer_/trajectory_classifier/FeatureWorkerModified.java procyon/trajectory_classifier/FeatureWorkerModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,90c9,64
< public class FeatureWorkerModified extends Thread {
<    double[] result;
<    AbstractTrajectoryFeatureModified c;
<    FeatureWorkerModified.EVALTYPE ev;
<    int resIndex;
<    // $FF: synthetic field
<    private static int[] $SWITCH_TABLE$trajectory_classifier$FeatureWorkerModified$EVALTYPE;
< 
<    public FeatureWorkerModified(double[] result, int resIndex, AbstractTrajectoryFeatureModified c, FeatureWorkerModified.EVALTYPE ev) {
<       this.result = result;
<       this.c = c;
<       this.ev = ev;
<       this.resIndex = resIndex;
<    }
< 
<    public void run() {
<       double[] res;
<       switch($SWITCH_TABLE$trajectory_classifier$FeatureWorkerModified$EVALTYPE()[this.ev.ordinal()]) {
<       case 1:
<          res = this.c.getValue();
<          this.result[this.resIndex] = res[0];
<          break;
<       case 2:
<          res = this.c.getValue();
<          this.result[this.resIndex] = res[1];
<          break;
<       case 3:
<          res = this.c.getValue();
<          this.result[this.resIndex] = res[0] / res[1];
<          break;
<       case 4:
<          res = this.c.getValue();
<          this.result[this.resIndex] = res[1] / res[0];
<          break;
<       case 5:
<          res = this.c.getValue();
<          this.result[this.resIndex] = res[1] / res[2];
<       }
< 
<    }
< 
<    // $FF: synthetic method
<    static int[] $SWITCH_TABLE$trajectory_classifier$FeatureWorkerModified$EVALTYPE() {
<       int[] var10000 = $SWITCH_TABLE$trajectory_classifier$FeatureWorkerModified$EVALTYPE;
<       if (var10000 != null) {
<          return var10000;
<       } else {
<          int[] var0 = new int[FeatureWorkerModified.EVALTYPE.values().length];
< 
<          try {
<             var0[FeatureWorkerModified.EVALTYPE.FIRST.ordinal()] = 1;
<          } catch (NoSuchFieldError var5) {
<          }
< 
<          try {
<             var0[FeatureWorkerModified.EVALTYPE.RATIO_01.ordinal()] = 3;
<          } catch (NoSuchFieldError var4) {
<          }
< 
<          try {
<             var0[FeatureWorkerModified.EVALTYPE.RATIO_10.ordinal()] = 4;
<          } catch (NoSuchFieldError var3) {
<          }
< 
<          try {
<             var0[FeatureWorkerModified.EVALTYPE.RATIO_12.ordinal()] = 5;
<          } catch (NoSuchFieldError var2) {
<          }
< 
<          try {
<             var0[FeatureWorkerModified.EVALTYPE.SECOND.ordinal()] = 2;
<          } catch (NoSuchFieldError var1) {
<          }
< 
<          $SWITCH_TABLE$trajectory_classifier$FeatureWorkerModified$EVALTYPE = var0;
<          return var0;
<       }
<    }
< 
<    static enum EVALTYPE {
<       FIRST,
<       SECOND,
<       RATIO_01,
<       RATIO_10,
<       RATIO_12;
<    }
---
> public class FeatureWorkerModified extends Thread
> {
>     double[] result;
>     AbstractTrajectoryFeatureModified c;
>     EVALTYPE ev;
>     int resIndex;
>     
>     public FeatureWorkerModified(final double[] result, final int resIndex, final AbstractTrajectoryFeatureModified c, final EVALTYPE ev) {
>         this.result = result;
>         this.c = c;
>         this.ev = ev;
>         this.resIndex = resIndex;
>     }
>     
>     @Override
>     public void run() {
>         switch (this.ev) {
>             case FIRST: {
>                 final double[] res = this.c.getValue();
>                 this.result[this.resIndex] = res[0];
>                 break;
>             }
>             case SECOND: {
>                 final double[] res = this.c.getValue();
>                 this.result[this.resIndex] = res[1];
>                 break;
>             }
>             case RATIO_01: {
>                 final double[] res = this.c.getValue();
>                 this.result[this.resIndex] = res[0] / res[1];
>                 break;
>             }
>             case RATIO_10: {
>                 final double[] res = this.c.getValue();
>                 this.result[this.resIndex] = res[1] / res[0];
>                 break;
>             }
>             case RATIO_12: {
>                 final double[] res = this.c.getValue();
>                 this.result[this.resIndex] = res[1] / res[2];
>                 break;
>             }
>         }
>     }
>     
>     enum EVALTYPE
>     {
>         FIRST("FIRST", 0), 
>         SECOND("SECOND", 1), 
>         RATIO_01("RATIO_01", 2), 
>         RATIO_10("RATIO_10", 3), 
>         RATIO_12("RATIO_12", 4);
>         
>         private EVALTYPE(final String name, final int ordinal) {
>         }
>     }
diff -r TrackAnalyzer_/trajectory_classifier/RRFClassifierRenjinModified.java procyon/trajectory_classifier/RRFClassifierRenjinModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3,14d6
< import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
< import features.Asymmetry3FeatureModified;
< import features.EfficiencyFeatureModified;
< import features.FractalDimensionFeatureModified;
< import features.GaussianityFeautureModified;
< import features.KurtosisFeatureModified;
< import features.MSDRatioFeatureModified;
< import features.PowerLawFeatureModified;
< import features.StraightnessFeatureModified;
< import features.TrappedProbabilityFeatureModified;
< import java.util.ArrayList;
< import java.util.Arrays;
16,20d7
< import java.util.concurrent.Executors;
< import java.util.concurrent.TimeUnit;
< import javax.script.ScriptEngine;
< import javax.script.ScriptEngineManager;
< import javax.script.ScriptException;
24a12,28
> import java.util.concurrent.TimeUnit;
> import features.GaussianityFeautureModified;
> import features.TrappedProbabilityFeatureModified;
> import features.StraightnessFeatureModified;
> import features.MSDRatioFeatureModified;
> import features.KurtosisFeatureModified;
> import features.EfficiencyFeatureModified;
> import features.Asymmetry3FeatureModified;
> import features.PowerLawFeatureModified;
> import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
> import features.AbstractTrajectoryFeatureModified;
> import features.FractalDimensionFeatureModified;
> import java.util.concurrent.Executors;
> import java.util.Arrays;
> import javax.script.ScriptException;
> import javax.script.ScriptEngineManager;
> import java.util.ArrayList;
25a30
> import javax.script.ScriptEngine;
27,169c32,179
< public class RRFClassifierRenjinModified extends AbstractClassifierModified {
<    ScriptEngine engine = null;
<    private String pathToModel;
<    private double[] confindence;
<    private double timelag;
< 
<    public RRFClassifierRenjinModified(String pathToModel, double timelag) {
<       this.pathToModel = pathToModel;
<       this.timelag = timelag;
<    }
< 
<    public void setTimelag(double timelag) {
<       this.timelag = timelag;
<    }
< 
<    public String classify(TrajectoryModified t) {
<       ArrayList<TrajectoryModified> tracks = new ArrayList();
<       tracks.add(t);
<       return this.classify(tracks)[0];
<    }
< 
<    public void start() {
<       ScriptEngineManager manager = new ScriptEngineManager();
<       this.engine = manager.getEngineByName("Renjin");
< 
<       try {
<          this.engine.eval("library(randomForest)");
<          this.engine.eval("library(plyr)");
<          this.engine.eval("load(\"" + this.pathToModel + "\")");
<       } catch (ScriptException var3) {
<          var3.printStackTrace();
<       }
< 
<       if (this.engine == null) {
<          throw new RuntimeException("Renjin Script Engine not found on the classpath.");
<       }
<    }
< 
<    public void stop() {
<       this.engine = null;
<    }
< 
<    public String[] classify(ArrayList<TrajectoryModified> tracks) {
<       int N = tracks.size();
<       String[] result = new String[N];
<       double[] fd = new double[N];
<       double[] power = new double[N];
<       Arrays.fill(power, -1.0D);
<       double[] asym3 = new double[N];
<       double[] efficiency = new double[N];
<       double[] kurtosis = new double[N];
<       double[] msdratio = new double[N];
<       double[] straightness = new double[N];
<       double[] trappedness = new double[N];
<       double[] gaussianity = new double[N];
<       double[] pwrDCs = new double[N];
<       Arrays.fill(power, -1.0D);
<       int cores = Runtime.getRuntime().availableProcessors();
<       ExecutorService pool = Executors.newFixedThreadPool(cores);
< 
<       for(int i = 0; i < tracks.size(); ++i) {
<          TrajectoryModified t = (TrajectoryModified)tracks.get(i);
<          FractalDimensionFeatureModified fdF = new FractalDimensionFeatureModified(t);
<          pool.submit(new FeatureWorkerModified(fd, i, fdF, FeatureWorkerModified.EVALTYPE.FIRST));
<          double initDC = 0.0D;
<          double initAlpha = 0.0D;
<          if (i - 1 > 0 && power[i - 1] > 0.0D && pwrDCs[i - 1] > 0.0D) {
<             initDC = pwrDCs[i - 1];
<             initAlpha = power[i - 1];
<          } else {
<             RegressionDiffusionCoefficientEstimatorModified regest = new RegressionDiffusionCoefficientEstimatorModified(t, 1.0D / this.timelag, 1, 3);
<             initDC = regest.evaluate()[0];
<             initAlpha = 0.5D;
<          }
< 
<          PowerLawFeatureModified pwf = new PowerLawFeatureModified(t, 1.0D / this.timelag, 1, t.size() / 3, initAlpha, initDC);
<          pool.submit(new FeatureWorkerModified(power, i, pwf, FeatureWorkerModified.EVALTYPE.FIRST));
<          pool.submit(new FeatureWorkerModified(pwrDCs, i, pwf, FeatureWorkerModified.EVALTYPE.SECOND));
<          Asymmetry3FeatureModified asymf3 = new Asymmetry3FeatureModified(t);
<          pool.submit(new FeatureWorkerModified(asym3, i, asymf3, FeatureWorkerModified.EVALTYPE.FIRST));
<          EfficiencyFeatureModified eff = new EfficiencyFeatureModified(t);
<          pool.submit(new FeatureWorkerModified(efficiency, i, eff, FeatureWorkerModified.EVALTYPE.FIRST));
<          KurtosisFeatureModified kurtf = new KurtosisFeatureModified(t);
<          pool.submit(new FeatureWorkerModified(kurtosis, i, kurtf, FeatureWorkerModified.EVALTYPE.FIRST));
<          MSDRatioFeatureModified msdr = new MSDRatioFeatureModified(t, 1, 5);
<          pool.submit(new FeatureWorkerModified(msdratio, i, msdr, FeatureWorkerModified.EVALTYPE.FIRST));
<          StraightnessFeatureModified straight = new StraightnessFeatureModified(t);
<          pool.submit(new FeatureWorkerModified(straightness, i, straight, FeatureWorkerModified.EVALTYPE.FIRST));
<          TrappedProbabilityFeatureModified trappf = new TrappedProbabilityFeatureModified(t);
<          pool.submit(new FeatureWorkerModified(trappedness, i, trappf, FeatureWorkerModified.EVALTYPE.FIRST));
<          GaussianityFeautureModified gaussf = new GaussianityFeautureModified(t, 1);
<          pool.submit(new FeatureWorkerModified(gaussianity, i, gaussf, FeatureWorkerModified.EVALTYPE.FIRST));
<       }
< 
<       pool.shutdown();
< 
<       try {
<          pool.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
<       } catch (InterruptedException var34) {
<          var34.printStackTrace();
<       }
< 
<       try {
<          this.engine.put("fd", fd);
<          this.engine.put("power", power);
<          this.engine.put("asymmetry3", asym3);
<          this.engine.put("efficiency", efficiency);
<          this.engine.put("kurtosis", kurtosis);
<          this.engine.put("msdratio", msdratio);
<          this.engine.put("straightness", straightness);
<          this.engine.put("trappedness", trappedness);
<          this.engine.put("gaussianity", gaussianity);
<          this.engine.eval("data<-data.frame(FD=fd,POWER=power,MSD.R=msdratio,ASYM3=asymmetry3,EFFICENCY=efficiency, KURT=kurtosis,STRAIGHTNESS=straightness,TRAPPED=trappedness,GAUSS=gaussianity)");
<          this.engine.eval("features.predict <- predict(model,data,type=\"prob\")");
<          this.engine.eval("fprob<-features.predict");
<          if (tracks.size() > 1) {
<             this.engine.eval("probs <- as.vector(apply(fprob[1:nrow(fprob),],1,max))");
<             this.engine.eval("indexmax <- as.vector(apply(fprob[1:nrow(fprob),],1,which.max))");
<          } else {
<             this.engine.eval("probs <- max(fprob)");
<             this.engine.eval("indexmax <- which.max(fprob)");
<          }
< 
<          this.engine.eval("mynames <- colnames(fprob)");
<          this.engine.eval("maxclass <- mynames[indexmax]");
<          StringVector res = (StringVector)this.engine.eval("maxclass");
<          result = res.toArray();
<          DoubleVector confi = (DoubleVector)this.engine.eval("probs");
<          this.confindence = confi.toDoubleArray();
<       } catch (ParseException var31) {
<          System.out.println("R script parse error: " + var31.getMessage());
<       } catch (ScriptException var32) {
<          var32.printStackTrace();
<       } catch (EvalException var33) {
<          var33.printStackTrace();
<       }
< 
<       return result;
<    }
< 
<    public double[] getConfindence() {
<       return this.confindence;
<    }
---
> public class RRFClassifierRenjinModified extends AbstractClassifierModified
> {
>     ScriptEngine engine;
>     private String pathToModel;
>     private double[] confindence;
>     private double timelag;
>     
>     public RRFClassifierRenjinModified(final String pathToModel, final double timelag) {
>         this.engine = null;
>         this.pathToModel = pathToModel;
>         this.timelag = timelag;
>     }
>     
>     public void setTimelag(final double timelag) {
>         this.timelag = timelag;
>     }
>     
>     @Override
>     public String classify(final TrajectoryModified t) {
>         final ArrayList<TrajectoryModified> tracks = new ArrayList<TrajectoryModified>();
>         tracks.add(t);
>         return this.classify(tracks)[0];
>     }
>     
>     @Override
>     public void start() {
>         final ScriptEngineManager manager = new ScriptEngineManager();
>         this.engine = manager.getEngineByName("Renjin");
>         try {
>             this.engine.eval("library(randomForest)");
>             this.engine.eval("library(plyr)");
>             this.engine.eval("load(\"" + this.pathToModel + "\")");
>         }
>         catch (ScriptException e) {
>             e.printStackTrace();
>         }
>         if (this.engine == null) {
>             throw new RuntimeException("Renjin Script Engine not found on the classpath.");
>         }
>     }
>     
>     @Override
>     public void stop() {
>         this.engine = null;
>     }
>     
>     @Override
>     public String[] classify(final ArrayList<TrajectoryModified> tracks) {
>         final int N = tracks.size();
>         String[] result = new String[N];
>         final double[] fd = new double[N];
>         final double[] power = new double[N];
>         Arrays.fill(power, -1.0);
>         final double[] asym3 = new double[N];
>         final double[] efficiency = new double[N];
>         final double[] kurtosis = new double[N];
>         final double[] msdratio = new double[N];
>         final double[] straightness = new double[N];
>         final double[] trappedness = new double[N];
>         final double[] gaussianity = new double[N];
>         final double[] pwrDCs = new double[N];
>         Arrays.fill(power, -1.0);
>         final int cores = Runtime.getRuntime().availableProcessors();
>         final ExecutorService pool = Executors.newFixedThreadPool(cores);
>         for (int i = 0; i < tracks.size(); ++i) {
>             final TrajectoryModified t = tracks.get(i);
>             final FractalDimensionFeatureModified fdF = new FractalDimensionFeatureModified(t);
>             pool.submit(new FeatureWorkerModified(fd, i, fdF, FeatureWorkerModified.EVALTYPE.FIRST));
>             double initDC = 0.0;
>             double initAlpha = 0.0;
>             if (i - 1 > 0 && power[i - 1] > 0.0 && pwrDCs[i - 1] > 0.0) {
>                 initDC = pwrDCs[i - 1];
>                 initAlpha = power[i - 1];
>             }
>             else {
>                 final RegressionDiffusionCoefficientEstimatorModified regest = new RegressionDiffusionCoefficientEstimatorModified(t, 1.0 / this.timelag, 1, 3);
>                 initDC = regest.evaluate()[0];
>                 initAlpha = 0.5;
>             }
>             final PowerLawFeatureModified pwf = new PowerLawFeatureModified(t, 1.0 / this.timelag, 1, t.size() / 3, initAlpha, initDC);
>             pool.submit(new FeatureWorkerModified(power, i, pwf, FeatureWorkerModified.EVALTYPE.FIRST));
>             pool.submit(new FeatureWorkerModified(pwrDCs, i, pwf, FeatureWorkerModified.EVALTYPE.SECOND));
>             final Asymmetry3FeatureModified asymf3 = new Asymmetry3FeatureModified(t);
>             pool.submit(new FeatureWorkerModified(asym3, i, asymf3, FeatureWorkerModified.EVALTYPE.FIRST));
>             final EfficiencyFeatureModified eff = new EfficiencyFeatureModified(t);
>             pool.submit(new FeatureWorkerModified(efficiency, i, eff, FeatureWorkerModified.EVALTYPE.FIRST));
>             final KurtosisFeatureModified kurtf = new KurtosisFeatureModified(t);
>             pool.submit(new FeatureWorkerModified(kurtosis, i, kurtf, FeatureWorkerModified.EVALTYPE.FIRST));
>             final MSDRatioFeatureModified msdr = new MSDRatioFeatureModified(t, 1, 5);
>             pool.submit(new FeatureWorkerModified(msdratio, i, msdr, FeatureWorkerModified.EVALTYPE.FIRST));
>             final StraightnessFeatureModified straight = new StraightnessFeatureModified(t);
>             pool.submit(new FeatureWorkerModified(straightness, i, straight, FeatureWorkerModified.EVALTYPE.FIRST));
>             final TrappedProbabilityFeatureModified trappf = new TrappedProbabilityFeatureModified(t);
>             pool.submit(new FeatureWorkerModified(trappedness, i, trappf, FeatureWorkerModified.EVALTYPE.FIRST));
>             final GaussianityFeautureModified gaussf = new GaussianityFeautureModified(t, 1);
>             pool.submit(new FeatureWorkerModified(gaussianity, i, gaussf, FeatureWorkerModified.EVALTYPE.FIRST));
>         }
>         pool.shutdown();
>         try {
>             pool.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
>         }
>         catch (InterruptedException e) {
>             e.printStackTrace();
>         }
>         try {
>             this.engine.put("fd", fd);
>             this.engine.put("power", power);
>             this.engine.put("asymmetry3", asym3);
>             this.engine.put("efficiency", efficiency);
>             this.engine.put("kurtosis", kurtosis);
>             this.engine.put("msdratio", msdratio);
>             this.engine.put("straightness", straightness);
>             this.engine.put("trappedness", trappedness);
>             this.engine.put("gaussianity", gaussianity);
>             this.engine.eval("data<-data.frame(FD=fd,POWER=power,MSD.R=msdratio,ASYM3=asymmetry3,EFFICENCY=efficiency, KURT=kurtosis,STRAIGHTNESS=straightness,TRAPPED=trappedness,GAUSS=gaussianity)");
>             this.engine.eval("features.predict <- predict(model,data,type=\"prob\")");
>             this.engine.eval("fprob<-features.predict");
>             if (tracks.size() > 1) {
>                 this.engine.eval("probs <- as.vector(apply(fprob[1:nrow(fprob),],1,max))");
>                 this.engine.eval("indexmax <- as.vector(apply(fprob[1:nrow(fprob),],1,which.max))");
>             }
>             else {
>                 this.engine.eval("probs <- max(fprob)");
>                 this.engine.eval("indexmax <- which.max(fprob)");
>             }
>             this.engine.eval("mynames <- colnames(fprob)");
>             this.engine.eval("maxclass <- mynames[indexmax]");
>             final StringVector res = (StringVector)this.engine.eval("maxclass");
>             result = res.toArray();
>             final DoubleVector confi = (DoubleVector)this.engine.eval("probs");
>             this.confindence = confi.toDoubleArray();
>         }
>         catch (ParseException e2) {
>             System.out.println("R script parse error: " + e2.getMessage());
>         }
>         catch (ScriptException e3) {
>             e3.printStackTrace();
>         }
>         catch (EvalException e4) {
>             e4.printStackTrace();
>         }
>         return result;
>     }
>     
>     @Override
>     public double[] getConfindence() {
>         return this.confindence;
>     }
diff -r TrackAnalyzer_/trajectory_classifier/SubtrajectoryModified.java procyon/trajectory_classifier/SubtrajectoryModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
3d6
< import java.util.ArrayList;
4a8
> import java.util.ArrayList;
7,46c11,47
< public class SubtrajectoryModified extends TrajectoryModified {
<    private static final long serialVersionUID = 3846588503781023924L;
<    private TrajectoryModified parent;
<    private double confidence;
< 
<    public SubtrajectoryModified(TrajectoryModified parent, int dimension) {
<       super(dimension);
<       this.parent = parent;
<    }
< 
<    public SubtrajectoryModified(TrajectoryModified parent, int dimension, int relativeStartPoint) {
<       super(dimension, relativeStartPoint);
<       this.parent = parent;
<    }
< 
<    public TrajectoryModified getParent() {
<       return this.parent;
<    }
< 
<    public static ArrayList<SubtrajectoryModified> getTracksWithSameParant(ArrayList<SubtrajectoryModified> tracks, long parentid) {
<       ArrayList<SubtrajectoryModified> res = new ArrayList();
<       Iterator var5 = tracks.iterator();
< 
<       while(var5.hasNext()) {
<          SubtrajectoryModified sub = (SubtrajectoryModified)var5.next();
<          if (sub.getParent().getID() == parentid) {
<             res.add(sub);
<          }
<       }
< 
<       return res;
<    }
< 
<    public void setConfidence(double confidence) {
<       this.confidence = confidence;
<    }
< 
<    public double getConfidence() {
<       return this.confidence;
<    }
---
> public class SubtrajectoryModified extends TrajectoryModified
> {
>     private static final long serialVersionUID = 3846588503781023924L;
>     private TrajectoryModified parent;
>     private double confidence;
>     
>     public SubtrajectoryModified(final TrajectoryModified parent, final int dimension) {
>         super(dimension);
>         this.parent = parent;
>     }
>     
>     public SubtrajectoryModified(final TrajectoryModified parent, final int dimension, final int relativeStartPoint) {
>         super(dimension, relativeStartPoint);
>         this.parent = parent;
>     }
>     
>     public TrajectoryModified getParent() {
>         return this.parent;
>     }
>     
>     public static ArrayList<SubtrajectoryModified> getTracksWithSameParant(final ArrayList<SubtrajectoryModified> tracks, final long parentid) {
>         final ArrayList<SubtrajectoryModified> res = new ArrayList<SubtrajectoryModified>();
>         for (final SubtrajectoryModified sub : tracks) {
>             if (sub.getParent().getID() == parentid) {
>                 res.add(sub);
>             }
>         }
>         return res;
>     }
>     
>     public void setConfidence(final double confidence) {
>         this.confidence = confidence;
>     }
>     
>     public double getConfidence() {
>         return this.confidence;
>     }
diff -r TrackAnalyzer_/trajectory_classifier/VisualizationUtilsModified.java procyon/trajectory_classifier/VisualizationUtilsModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
4c8
< import ij.gui.Roi;
---
> import vecmath.Point3dModified;
7c11
< import java.awt.Color;
---
> import ij.gui.Roi;
9,45c13
< import vecmath.Point3dModified;
< 
< public class VisualizationUtilsModified {
<    public static ArrayList<Roi> generateVisualizationRoisFromTrack(SubtrajectoryModified t, Color c, boolean showID) {
<       return generateVisualizationRoisFromTrack(t, c, showID, 1.0D);
<    }
< 
<    public static ArrayList<Roi> generateVisualizationRoisFromTrack(SubtrajectoryModified t, Color c, boolean showID, double pixelsize) {
<       ArrayList<Roi> proi = new ArrayList();
<       FloatPolygon p = new FloatPolygon();
<       double sumx = 0.0D;
<       double sumy = 0.0D;
<       TextRoi.setFont("TimesRoman", 5, 0);
< 
<       for(int i = 0; i < t.getParent().size(); ++i) {
<          int to = t.size();
<          if (i < t.size()) {
<             sumx += ((Point3dModified)t.get(i)).x / pixelsize;
<             sumy += ((Point3dModified)t.get(i)).y / pixelsize;
<             p.addPoint(((Point3dModified)t.get(i)).x / pixelsize, ((Point3dModified)t.get(i)).y / pixelsize);
<             to = i + 1;
<          }
< 
<          PolygonRoi pr = new PolygonRoi(new FloatPolygon(p.xpoints, p.ypoints, to), 6);
<          pr.setStrokeColor(c);
<          pr.setPosition(t.getRelativeStartTimepoint() + i + 1);
<          proi.add(pr);
<          if (showID) {
<             long parentID = t.getParent().getID();
<             TextRoi troi = new TextRoi(sumx / (double)to, sumy / (double)to, " " + parentID + ":" + t.getID() + " ");
<             troi.setPosition(t.getRelativeStartTimepoint() + i + 1);
<             troi.setFillColor(Color.BLACK);
<             troi.setStrokeColor(c);
<             troi.setAntialiased(true);
<             proi.add(troi);
<          }
<       }
---
> import java.awt.Color;
47,48c15,50
<       return proi;
<    }
---
> public class VisualizationUtilsModified
> {
>     public static ArrayList<Roi> generateVisualizationRoisFromTrack(final SubtrajectoryModified t, final Color c, final boolean showID) {
>         return generateVisualizationRoisFromTrack(t, c, showID, 1.0);
>     }
>     
>     public static ArrayList<Roi> generateVisualizationRoisFromTrack(final SubtrajectoryModified t, final Color c, final boolean showID, final double pixelsize) {
>         final ArrayList<Roi> proi = new ArrayList<Roi>();
>         final FloatPolygon p = new FloatPolygon();
>         double sumx = 0.0;
>         double sumy = 0.0;
>         TextRoi.setFont("TimesRoman", 5, 0);
>         for (int i = 0; i < t.getParent().size(); ++i) {
>             int to = t.size();
>             if (i < t.size()) {
>                 sumx += t.get(i).x / pixelsize;
>                 sumy += t.get(i).y / pixelsize;
>                 p.addPoint(t.get(i).x / pixelsize, t.get(i).y / pixelsize);
>                 to = i + 1;
>             }
>             final PolygonRoi pr = new PolygonRoi(new FloatPolygon(p.xpoints, p.ypoints, to), 6);
>             pr.setStrokeColor(c);
>             pr.setPosition(t.getRelativeStartTimepoint() + i + 1);
>             proi.add((Roi)pr);
>             if (showID) {
>                 final long parentID = t.getParent().getID();
>                 final TextRoi troi = new TextRoi(sumx / to, sumy / to, " " + parentID + ":" + t.getID() + " ");
>                 troi.setPosition(t.getRelativeStartTimepoint() + i + 1);
>                 troi.setFillColor(Color.BLACK);
>                 troi.setStrokeColor(c);
>                 troi.setAntialiased(true);
>                 proi.add((Roi)troi);
>             }
>         }
>         return proi;
>     }
diff -r TrackAnalyzer_/trajectory_classifier/WeightedWindowedClassificationProcessModified.java procyon/trajectory_classifier/WeightedWindowedClassificationProcessModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
2a7
> import java.util.Iterator;
4d8
< import java.util.ArrayList;
6a11
> import java.util.Collection;
8,9d12
< import java.util.Iterator;
< import traJ.TrajectoryModified;
10a14,15
> import java.util.ArrayList;
> import traJ.TrajectoryModified;
12,91c17,34
< public class WeightedWindowedClassificationProcessModified {
<    private double[] posConfidence = null;
<    private double numberOmittedSegments = 0.0D;
< 
<    public String[] windowedClassification(TrajectoryModified t, AbstractClassifierModified c, int n, int rate) {
<       int windowsize = 2 * n + 1;
<       int increment = 1;
<       ArrayList<TrajectoryModified> tracks = new ArrayList();
< 
<       for(int i = 0; i < t.size() - windowsize + increment; i += increment) {
<          TrajectoryModified sub = t.subList(i, i + windowsize - 1);
<          if (rate > 1) {
<             sub = TrajectoryUtilModified.resample(sub, rate);
<          }
< 
<          tracks.add(sub);
<       }
< 
<       String[] res = c.classify(tracks);
<       double[] confidence = c.getConfindence();
< 
<       for(int i = 0; i < res.length; ++i) {
<          if (res[i] == null) {
<             return null;
<          }
<       }
< 
<       String[] types = this.applyWeightening(res, confidence, n, t.size());
<       return types;
<    }
< 
<    public double[] getPositionConfidence() {
<       return this.posConfidence;
<    }
< 
<    protected String[] applyWeightening(String[] res, double[] confidence, int n, int tracklength) {
<       String[] types = new String[tracklength];
<       this.posConfidence = new double[tracklength];
<       ArrayList<String> restypes = new ArrayList();
< 
<       for(int i = 0; i < res.length; ++i) {
<          restypes.add(res[i]);
<       }
< 
<       HashSet<String> uniqueTypes = new HashSet();
<       uniqueTypes.addAll(restypes);
<       HashMap<String, Integer> mapTypeToInt = new HashMap();
<       HashMap<Integer, String> mapIntToType = new HashMap();
<       Iterator<String> it = uniqueTypes.iterator();
< 
<       int key;
<       for(key = 0; it.hasNext(); ++key) {
<          String type = (String)it.next();
<          mapTypeToInt.put(type, key);
<          mapIntToType.put(key, type);
<       }
< 
<       ArrayList<Double[]> weightes = new ArrayList();
<       ArrayList<Integer[]> Nvotes = new ArrayList();
< 
<       int i;
<       for(i = 0; i < tracklength; ++i) {
<          Double[] h = new Double[key];
<          Arrays.fill(h, new Double(0.0D));
<          weightes.add(h);
<          Integer[] h1 = new Integer[key];
<          Arrays.fill(h1, new Integer(0));
<          Nvotes.add(h1);
<       }
< 
<       int mode1;
<       for(i = 0; i < res.length; ++i) {
<          for(int j = i; j < i + 2 * n + 1; ++j) {
<             mode1 = (Integer)mapTypeToInt.get(res[i]);
< 
<             try {
<                ((Double[])weightes.get(j))[mode1] = ((Double[])weightes.get(j))[mode1] + confidence[i];
<                ((Integer[])Nvotes.get(j))[mode1] = ((Integer[])Nvotes.get(j))[mode1] + 1;
<             } catch (Exception var22) {
<                IJ.log("Res: " + res[i] + " j: " + j + " i: " + i + " weigthes size " + weightes.size());
---
> public class WeightedWindowedClassificationProcessModified
> {
>     private double[] posConfidence;
>     private double numberOmittedSegments;
>     
>     public WeightedWindowedClassificationProcessModified() {
>         this.posConfidence = null;
>         this.numberOmittedSegments = 0.0;
>     }
>     
>     public String[] windowedClassification(final TrajectoryModified t, final AbstractClassifierModified c, final int n, final int rate) {
>         final int windowsize = 2 * n + 1;
>         final int increment = 1;
>         final ArrayList<TrajectoryModified> tracks = new ArrayList<TrajectoryModified>();
>         for (int i = 0; i < t.size() - windowsize + increment; i += increment) {
>             TrajectoryModified sub = t.subList(i, i + windowsize - 1);
>             if (rate > 1) {
>                 sub = TrajectoryUtilModified.resample(sub, rate);
93,143c36,134
<          }
<       }
< 
<       for(i = 0; i < types.length; ++i) {
<          if (((Double[])weightes.get(i)).length > 0) {
<             double[] result = this.getHighest((Double[])weightes.get(i));
<             mode1 = (int)result[0];
<             double maxv = result[1];
<             double wConf = maxv / (double)((Integer[])Nvotes.get(i))[mode1];
<             String mode = (String)mapIntToType.get(mode1);
<             types[i] = mode;
<             this.posConfidence[i] = wConf;
<          }
<       }
< 
<       return types;
<    }
< 
<    private double[] getHighest(Double[] weightes) {
<       double max = 0.0D;
<       int maxindex = 0;
< 
<       for(int i = 0; i < weightes.length; ++i) {
<          if (weightes[i] > max) {
<             max = weightes[i];
<             maxindex = i;
<          }
<       }
< 
<       return new double[]{(double)maxindex, max};
<    }
< 
<    public double[] arrListToArray(ArrayList<Integer> l) {
<       double[] a = new double[l.size()];
< 
<       for(int i = 0; i < l.size(); ++i) {
<          a[i] = (double)(Integer)l.get(i);
<       }
< 
<       return a;
<    }
< 
<    public int[] arrListToArrayInt(ArrayList<Integer> l) {
<       int[] a = new int[l.size()];
< 
<       for(int i = 0; i < l.size(); ++i) {
<          a[i] = (Integer)l.get(i);
<       }
< 
<       return a;
<    }
---
>             tracks.add(sub);
>         }
>         final String[] res = c.classify(tracks);
>         final double[] confidence = c.getConfindence();
>         for (int j = 0; j < res.length; ++j) {
>             if (res[j] == null) {
>                 return null;
>             }
>         }
>         final String[] types = this.applyWeightening(res, confidence, n, t.size());
>         return types;
>     }
>     
>     public double[] getPositionConfidence() {
>         return this.posConfidence;
>     }
>     
>     protected String[] applyWeightening(final String[] res, final double[] confidence, final int n, final int tracklength) {
>         final String[] types = new String[tracklength];
>         this.posConfidence = new double[tracklength];
>         final ArrayList<String> restypes = new ArrayList<String>();
>         for (int i = 0; i < res.length; ++i) {
>             restypes.add(res[i]);
>         }
>         final HashSet<String> uniqueTypes = new HashSet<String>();
>         uniqueTypes.addAll((Collection<?>)restypes);
>         final HashMap<String, Integer> mapTypeToInt = new HashMap<String, Integer>();
>         final HashMap<Integer, String> mapIntToType = new HashMap<Integer, String>();
>         final Iterator<String> it = uniqueTypes.iterator();
>         int key = 0;
>         while (it.hasNext()) {
>             final String type = it.next();
>             mapTypeToInt.put(type, key);
>             mapIntToType.put(key, type);
>             ++key;
>         }
>         final ArrayList<Double[]> weightes = new ArrayList<Double[]>();
>         final ArrayList<Integer[]> Nvotes = new ArrayList<Integer[]>();
>         for (int j = 0; j < tracklength; ++j) {
>             final Double[] h = new Double[key];
>             Arrays.fill(h, new Double(0.0));
>             weightes.add(h);
>             final Integer[] h2 = new Integer[key];
>             Arrays.fill(h2, new Integer(0));
>             Nvotes.add(h2);
>         }
>         for (int j = 0; j < res.length; ++j) {
>             for (int k = j; k < j + 2 * n + 1; ++k) {
>                 final int typ = mapTypeToInt.get(res[j]);
>                 try {
>                     weightes.get(k)[typ] += confidence[j];
>                     ++Nvotes.get(k)[typ];
>                 }
>                 catch (Exception e) {
>                     IJ.log("Res: " + res[j] + " j: " + k + " i: " + j + " weigthes size " + weightes.size());
>                 }
>             }
>         }
>         for (int j = 0; j < types.length; ++j) {
>             if (weightes.get(j).length > 0) {
>                 final double[] result = this.getHighest(weightes.get(j));
>                 final int mode1 = (int)result[0];
>                 final double maxv = result[1];
>                 final double wConf = maxv / Nvotes.get(j)[mode1];
>                 final String mode2 = mapIntToType.get(mode1);
>                 types[j] = mode2;
>                 this.posConfidence[j] = wConf;
>             }
>         }
>         return types;
>     }
>     
>     private double[] getHighest(final Double[] weightes) {
>         double max = 0.0;
>         int maxindex = 0;
>         for (int i = 0; i < weightes.length; ++i) {
>             if (weightes[i] > max) {
>                 max = weightes[i];
>                 maxindex = i;
>             }
>         }
>         return new double[] { maxindex, max };
>     }
>     
>     public double[] arrListToArray(final ArrayList<Integer> l) {
>         final double[] a = new double[l.size()];
>         for (int i = 0; i < l.size(); ++i) {
>             a[i] = l.get(i);
>         }
>         return a;
>     }
>     
>     public int[] arrListToArrayInt(final ArrayList<Integer> l) {
>         final int[] a = new int[l.size()];
>         for (int i = 0; i < l.size(); ++i) {
>             a[i] = l.get(i);
>         }
>         return a;
>     }
diff -r TrackAnalyzer_/traJParametersWindow.java procyon/traJParametersWindow.java
3,5d2
< import javax.swing.BoxLayout;
< import javax.swing.JButton;
< import javax.swing.JFrame;
6a4,7
> import java.awt.LayoutManager;
> import java.awt.Container;
> import javax.swing.BoxLayout;
> import java.awt.Component;
8a10,11
> import javax.swing.JFrame;
> import javax.swing.JButton;
10,29c13,15
< public class traJParametersWindow {
<    static JButton okButton;
<    static String minLengthTextS;
<    static String windowTextS;
<    static String minSegTextS;
<    static String keyWord;
<    static JFrame frame;
<    static JTextField minLengthText;
<    static JTextField windowText;
<    static JTextField minSegText;
< 
<    public void run(String args) {
<       frame = new JFrame("TraJ Classifier Parameters");
<       frame.setSize(200, 200);
<       frame.setDefaultCloseOperation(2);
<       JPanel panel = new JPanel();
<       frame.add(panel);
<       placeComponents(panel);
<       frame.setVisible(true);
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
31,60c17,64
<    private static void placeComponents(JPanel panel) {
<       panel.setLayout(new BoxLayout(panel, 1));
<       JLabel minLengthLabel = new JLabel("Min. Tracklength: ");
<       panel.add(minLengthLabel);
<       minLengthText = new JTextField("10", 5);
<       minLengthText.setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_MIN_TRACK, ""));
<       panel.add(minLengthText);
<       JLabel windowLabel = new JLabel("Windowsize (SPOT positions): ");
<       panel.add(windowLabel);
<       windowText = new JTextField("5", 5);
<       windowText.setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_WINDOW, ""));
<       panel.add(windowText);
<       JLabel minSegLabel = new JLabel("Min.Segment Length: ");
<       panel.add(minSegLabel);
<       minSegText = new JTextField("5", 5);
<       minSegText.setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_MIN_SEGMENT, ""));
<       panel.add(minSegText);
<       okButton = new JButton("OK");
<       okButton.setBounds(10, 80, 80, 25);
<       panel.add(okButton);
<       okButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent event) {
<             traJParametersWindow.keyWord = "keyword";
<             traJParametersWindow.minLengthTextS = traJParametersWindow.minLengthText.getText();
<             traJParametersWindow.windowTextS = traJParametersWindow.windowText.getText();
<             traJParametersWindow.minSegTextS = traJParametersWindow.minSegText.getText();
<             traJParametersWindow.frame.setVisible(false);
<          }
<       });
<    }
---
> public class traJParametersWindow
> {
>     static JButton okButton;
>     static String minLengthTextS;
>     static String windowTextS;
>     static String minSegTextS;
>     static String keyWord;
>     static JFrame frame;
>     static JTextField minLengthText;
>     static JTextField windowText;
>     static JTextField minSegText;
>     
>     public void run(final String args) {
>         (traJParametersWindow.frame = new JFrame("TraJ Classifier Parameters")).setSize(200, 200);
>         traJParametersWindow.frame.setDefaultCloseOperation(2);
>         final JPanel panel = new JPanel();
>         traJParametersWindow.frame.add(panel);
>         placeComponents(panel);
>         traJParametersWindow.frame.setVisible(true);
>     }
>     
>     private static void placeComponents(final JPanel panel) {
>         panel.setLayout(new BoxLayout(panel, 1));
>         final JLabel minLengthLabel = new JLabel("Min. Tracklength: ");
>         panel.add(minLengthLabel);
>         (traJParametersWindow.minLengthText = new JTextField("10", 5)).setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_MIN_TRACK, ""));
>         panel.add(traJParametersWindow.minLengthText);
>         final JLabel windowLabel = new JLabel("Windowsize (SPOT positions): ");
>         panel.add(windowLabel);
>         (traJParametersWindow.windowText = new JTextField("5", 5)).setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_WINDOW, ""));
>         panel.add(traJParametersWindow.windowText);
>         final JLabel minSegLabel = new JLabel("Min.Segment Length: ");
>         panel.add(minSegLabel);
>         (traJParametersWindow.minSegText = new JTextField("5", 5)).setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_MIN_SEGMENT, ""));
>         panel.add(traJParametersWindow.minSegText);
>         (traJParametersWindow.okButton = new JButton("OK")).setBounds(10, 80, 80, 25);
>         panel.add(traJParametersWindow.okButton);
>         traJParametersWindow.okButton.addActionListener(new ActionListener() {
>             @Override
>             public void actionPerformed(final ActionEvent event) {
>                 traJParametersWindow.keyWord = "keyword";
>                 traJParametersWindow.minLengthTextS = traJParametersWindow.minLengthText.getText();
>                 traJParametersWindow.windowTextS = traJParametersWindow.windowText.getText();
>                 traJParametersWindow.minSegTextS = traJParametersWindow.minSegText.getText();
>                 traJParametersWindow.frame.setVisible(false);
>             }
>         });
>     }
diff -r TrackAnalyzer_/vecmath/Color3b.java procyon/vecmath/Color3b.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
6,43c10,48
< public class Color3b extends Tuple3b implements Serializable {
<    static final long serialVersionUID = 6632576088353444794L;
< 
<    public Color3b(byte c1, byte c2, byte c3) {
<       super(c1, c2, c3);
<    }
< 
<    public Color3b(byte[] c) {
<       super(c);
<    }
< 
<    public Color3b(Color3b c1) {
<       super((Tuple3b)c1);
<    }
< 
<    public Color3b(Tuple3b t1) {
<       super(t1);
<    }
< 
<    public Color3b(Color color) {
<       super((byte)color.getRed(), (byte)color.getGreen(), (byte)color.getBlue());
<    }
< 
<    public Color3b() {
<    }
< 
<    public final void set(Color color) {
<       this.x = (byte)color.getRed();
<       this.y = (byte)color.getGreen();
<       this.z = (byte)color.getBlue();
<    }
< 
<    public final Color get() {
<       int r = this.x & 255;
<       int g = this.y & 255;
<       int b = this.z & 255;
<       return new Color(r, g, b);
<    }
---
> public class Color3b extends Tuple3b implements Serializable
> {
>     static final long serialVersionUID = 6632576088353444794L;
>     
>     public Color3b(final byte c1, final byte c2, final byte c3) {
>         super(c1, c2, c3);
>     }
>     
>     public Color3b(final byte[] c) {
>         super(c);
>     }
>     
>     public Color3b(final Color3b c1) {
>         super(c1);
>     }
>     
>     public Color3b(final Tuple3b t1) {
>         super(t1);
>     }
>     
>     public Color3b(final Color color) {
>         super((byte)color.getRed(), (byte)color.getGreen(), (byte)color.getBlue());
>     }
>     
>     public Color3b() {
>     }
>     
>     public final void set(final Color color) {
>         this.x = (byte)color.getRed();
>         this.y = (byte)color.getGreen();
>         this.z = (byte)color.getBlue();
>     }
>     
>     public final Color get() {
>         final int r = this.x & 0xFF;
>         final int g = this.y & 0xFF;
>         final int b = this.z & 0xFF;
>         return new Color(r, g, b);
>     }
diff -r TrackAnalyzer_/vecmath/Color3f.java procyon/vecmath/Color3f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
6,47c10,52
< public class Color3f extends Tuple3f implements Serializable {
<    static final long serialVersionUID = -1861792981817493659L;
< 
<    public Color3f(float x, float y, float z) {
<       super(x, y, z);
<    }
< 
<    public Color3f(float[] v) {
<       super(v);
<    }
< 
<    public Color3f(Color3f v1) {
<       super((Tuple3f)v1);
<    }
< 
<    public Color3f(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public Color3f(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public Color3f(Color color) {
<       super((float)color.getRed() / 255.0F, (float)color.getGreen() / 255.0F, (float)color.getBlue() / 255.0F);
<    }
< 
<    public Color3f() {
<    }
< 
<    public final void set(Color color) {
<       this.x = (float)color.getRed() / 255.0F;
<       this.y = (float)color.getGreen() / 255.0F;
<       this.z = (float)color.getBlue() / 255.0F;
<    }
< 
<    public final Color get() {
<       int r = Math.round(this.x * 255.0F);
<       int g = Math.round(this.y * 255.0F);
<       int b = Math.round(this.z * 255.0F);
<       return new Color(r, g, b);
<    }
---
> public class Color3f extends Tuple3f implements Serializable
> {
>     static final long serialVersionUID = -1861792981817493659L;
>     
>     public Color3f(final float x, final float y, final float z) {
>         super(x, y, z);
>     }
>     
>     public Color3f(final float[] v) {
>         super(v);
>     }
>     
>     public Color3f(final Color3f v1) {
>         super(v1);
>     }
>     
>     public Color3f(final Tuple3f t1) {
>         super(t1);
>     }
>     
>     public Color3f(final Tuple3dModified t1) {
>         super(t1);
>     }
>     
>     public Color3f(final Color color) {
>         super(color.getRed() / 255.0f, color.getGreen() / 255.0f, color.getBlue() / 255.0f);
>     }
>     
>     public Color3f() {
>     }
>     
>     public final void set(final Color color) {
>         this.x = color.getRed() / 255.0f;
>         this.y = color.getGreen() / 255.0f;
>         this.z = color.getBlue() / 255.0f;
>     }
>     
>     public final Color get() {
>         final int r = Math.round(this.x * 255.0f);
>         final int g = Math.round(this.y * 255.0f);
>         final int b = Math.round(this.z * 255.0f);
>         return new Color(r, g, b);
>     }
diff -r TrackAnalyzer_/vecmath/Color4b.java procyon/vecmath/Color4b.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
6,45c10,50
< public class Color4b extends Tuple4b implements Serializable {
<    static final long serialVersionUID = -105080578052502155L;
< 
<    public Color4b(byte b1, byte b2, byte b3, byte b4) {
<       super(b1, b2, b3, b4);
<    }
< 
<    public Color4b(byte[] c) {
<       super(c);
<    }
< 
<    public Color4b(Color4b c1) {
<       super((Tuple4b)c1);
<    }
< 
<    public Color4b(Tuple4b t1) {
<       super(t1);
<    }
< 
<    public Color4b(Color color) {
<       super((byte)color.getRed(), (byte)color.getGreen(), (byte)color.getBlue(), (byte)color.getAlpha());
<    }
< 
<    public Color4b() {
<    }
< 
<    public final void set(Color color) {
<       this.x = (byte)color.getRed();
<       this.y = (byte)color.getGreen();
<       this.z = (byte)color.getBlue();
<       this.w = (byte)color.getAlpha();
<    }
< 
<    public final Color get() {
<       int r = this.x & 255;
<       int g = this.y & 255;
<       int b = this.z & 255;
<       int a = this.w & 255;
<       return new Color(r, g, b, a);
<    }
---
> public class Color4b extends Tuple4b implements Serializable
> {
>     static final long serialVersionUID = -105080578052502155L;
>     
>     public Color4b(final byte b1, final byte b2, final byte b3, final byte b4) {
>         super(b1, b2, b3, b4);
>     }
>     
>     public Color4b(final byte[] c) {
>         super(c);
>     }
>     
>     public Color4b(final Color4b c1) {
>         super(c1);
>     }
>     
>     public Color4b(final Tuple4b t1) {
>         super(t1);
>     }
>     
>     public Color4b(final Color color) {
>         super((byte)color.getRed(), (byte)color.getGreen(), (byte)color.getBlue(), (byte)color.getAlpha());
>     }
>     
>     public Color4b() {
>     }
>     
>     public final void set(final Color color) {
>         this.x = (byte)color.getRed();
>         this.y = (byte)color.getGreen();
>         this.z = (byte)color.getBlue();
>         this.w = (byte)color.getAlpha();
>     }
>     
>     public final Color get() {
>         final int r = this.x & 0xFF;
>         final int g = this.y & 0xFF;
>         final int b = this.z & 0xFF;
>         final int a = this.w & 0xFF;
>         return new Color(r, g, b, a);
>     }
diff -r TrackAnalyzer_/vecmath/Color4f.java procyon/vecmath/Color4f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
6,49c10,54
< public class Color4f extends Tuple4f implements Serializable {
<    static final long serialVersionUID = 8577680141580006740L;
< 
<    public Color4f(float x, float y, float z, float w) {
<       super(x, y, z, w);
<    }
< 
<    public Color4f(float[] c) {
<       super(c);
<    }
< 
<    public Color4f(Color4f c1) {
<       super((Tuple4f)c1);
<    }
< 
<    public Color4f(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public Color4f(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public Color4f(Color color) {
<       super((float)color.getRed() / 255.0F, (float)color.getGreen() / 255.0F, (float)color.getBlue() / 255.0F, (float)color.getAlpha() / 255.0F);
<    }
< 
<    public Color4f() {
<    }
< 
<    public final void set(Color color) {
<       this.x = (float)color.getRed() / 255.0F;
<       this.y = (float)color.getGreen() / 255.0F;
<       this.z = (float)color.getBlue() / 255.0F;
<       this.w = (float)color.getAlpha() / 255.0F;
<    }
< 
<    public final Color get() {
<       int r = Math.round(this.x * 255.0F);
<       int g = Math.round(this.y * 255.0F);
<       int b = Math.round(this.z * 255.0F);
<       int a = Math.round(this.w * 255.0F);
<       return new Color(r, g, b, a);
<    }
---
> public class Color4f extends Tuple4f implements Serializable
> {
>     static final long serialVersionUID = 8577680141580006740L;
>     
>     public Color4f(final float x, final float y, final float z, final float w) {
>         super(x, y, z, w);
>     }
>     
>     public Color4f(final float[] c) {
>         super(c);
>     }
>     
>     public Color4f(final Color4f c1) {
>         super(c1);
>     }
>     
>     public Color4f(final Tuple4f t1) {
>         super(t1);
>     }
>     
>     public Color4f(final Tuple4d t1) {
>         super(t1);
>     }
>     
>     public Color4f(final Color color) {
>         super(color.getRed() / 255.0f, color.getGreen() / 255.0f, color.getBlue() / 255.0f, color.getAlpha() / 255.0f);
>     }
>     
>     public Color4f() {
>     }
>     
>     public final void set(final Color color) {
>         this.x = color.getRed() / 255.0f;
>         this.y = color.getGreen() / 255.0f;
>         this.z = color.getBlue() / 255.0f;
>         this.w = color.getAlpha() / 255.0f;
>     }
>     
>     public final Color get() {
>         final int r = Math.round(this.x * 255.0f);
>         final int g = Math.round(this.y * 255.0f);
>         final int b = Math.round(this.z * 255.0f);
>         final int a = Math.round(this.w * 255.0f);
>         return new Color(r, g, b, a);
>     }
Only in TrackAnalyzer_/vecmath: ExceptionStrings.properties
diff -r TrackAnalyzer_/vecmath/MismatchedSizeException.java procyon/vecmath/MismatchedSizeException.java
1c1,3
< package vecmath;
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
3,5c5
< public class MismatchedSizeException extends RuntimeException {
<    public MismatchedSizeException() {
<    }
---
> package vecmath;
7,9c7,14
<    public MismatchedSizeException(String str) {
<       super(str);
<    }
---
> public class MismatchedSizeException extends RuntimeException
> {
>     public MismatchedSizeException() {
>     }
>     
>     public MismatchedSizeException(final String str) {
>         super(str);
>     }
Only in TrackAnalyzer_/vecmath: package-info.java
diff -r TrackAnalyzer_/vecmath/Point2d.java procyon/vecmath/Point2d.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,53c9,58
< public class Point2d extends Tuple2d implements Serializable {
<    static final long serialVersionUID = 1133748791492571954L;
< 
<    public Point2d(double x, double y) {
<       super(x, y);
<    }
< 
<    public Point2d(double[] p) {
<       super(p);
<    }
< 
<    public Point2d(Point2d p1) {
<       super((Tuple2d)p1);
<    }
< 
<    public Point2d(Point2f p1) {
<       super((Tuple2f)p1);
<    }
< 
<    public Point2d(Tuple2d t1) {
<       super(t1);
<    }
< 
<    public Point2d(Tuple2f t1) {
<       super(t1);
<    }
< 
<    public Point2d() {
<    }
< 
<    public final double distanceSquared(Point2d p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       return dx * dx + dy * dy;
<    }
< 
<    public final double distance(Point2d p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       return Math.sqrt(dx * dx + dy * dy);
<    }
< 
<    public final double distanceL1(Point2d p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y);
<    }
< 
<    public final double distanceLinf(Point2d p1) {
<       return Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<    }
---
> public class Point2d extends Tuple2d implements Serializable
> {
>     static final long serialVersionUID = 1133748791492571954L;
>     
>     public Point2d(final double x, final double y) {
>         super(x, y);
>     }
>     
>     public Point2d(final double[] p) {
>         super(p);
>     }
>     
>     public Point2d(final Point2d p1) {
>         super(p1);
>     }
>     
>     public Point2d(final Point2f p1) {
>         super(p1);
>     }
>     
>     public Point2d(final Tuple2d t1) {
>         super(t1);
>     }
>     
>     public Point2d(final Tuple2f t1) {
>         super(t1);
>     }
>     
>     public Point2d() {
>     }
>     
>     public final double distanceSquared(final Point2d p1) {
>         final double dx = this.x - p1.x;
>         final double dy = this.y - p1.y;
>         return dx * dx + dy * dy;
>     }
>     
>     public final double distance(final Point2d p1) {
>         final double dx = this.x - p1.x;
>         final double dy = this.y - p1.y;
>         return Math.sqrt(dx * dx + dy * dy);
>     }
>     
>     public final double distanceL1(final Point2d p1) {
>         return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y);
>     }
>     
>     public final double distanceLinf(final Point2d p1) {
>         return Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
>     }
diff -r TrackAnalyzer_/vecmath/Point2f.java procyon/vecmath/Point2f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,53c9,58
< public class Point2f extends Tuple2f implements Serializable {
<    static final long serialVersionUID = -4801347926528714435L;
< 
<    public Point2f(float x, float y) {
<       super(x, y);
<    }
< 
<    public Point2f(float[] p) {
<       super(p);
<    }
< 
<    public Point2f(Point2f p1) {
<       super((Tuple2f)p1);
<    }
< 
<    public Point2f(Point2d p1) {
<       super((Tuple2d)p1);
<    }
< 
<    public Point2f(Tuple2d t1) {
<       super(t1);
<    }
< 
<    public Point2f(Tuple2f t1) {
<       super(t1);
<    }
< 
<    public Point2f() {
<    }
< 
<    public final float distanceSquared(Point2f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       return dx * dx + dy * dy;
<    }
< 
<    public final float distance(Point2f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       return (float)Math.sqrt((double)(dx * dx + dy * dy));
<    }
< 
<    public final float distanceL1(Point2f p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y);
<    }
< 
<    public final float distanceLinf(Point2f p1) {
<       return Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<    }
---
> public class Point2f extends Tuple2f implements Serializable
> {
>     static final long serialVersionUID = -4801347926528714435L;
>     
>     public Point2f(final float x, final float y) {
>         super(x, y);
>     }
>     
>     public Point2f(final float[] p) {
>         super(p);
>     }
>     
>     public Point2f(final Point2f p1) {
>         super(p1);
>     }
>     
>     public Point2f(final Point2d p1) {
>         super(p1);
>     }
>     
>     public Point2f(final Tuple2d t1) {
>         super(t1);
>     }
>     
>     public Point2f(final Tuple2f t1) {
>         super(t1);
>     }
>     
>     public Point2f() {
>     }
>     
>     public final float distanceSquared(final Point2f p1) {
>         final float dx = this.x - p1.x;
>         final float dy = this.y - p1.y;
>         return dx * dx + dy * dy;
>     }
>     
>     public final float distance(final Point2f p1) {
>         final float dx = this.x - p1.x;
>         final float dy = this.y - p1.y;
>         return (float)Math.sqrt(dx * dx + dy * dy);
>     }
>     
>     public final float distanceL1(final Point2f p1) {
>         return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y);
>     }
>     
>     public final float distanceLinf(final Point2f p1) {
>         return Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
>     }
diff -r TrackAnalyzer_/vecmath/Point2i.java procyon/vecmath/Point2i.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,21c9,26
< public class Point2i extends Tuple2i implements Serializable {
<    static final long serialVersionUID = 9208072376494084954L;
< 
<    public Point2i(int x, int y) {
<       super(x, y);
<    }
< 
<    public Point2i(int[] t) {
<       super(t);
<    }
< 
<    public Point2i(Tuple2i t1) {
<       super(t1);
<    }
< 
<    public Point2i() {
<    }
---
> public class Point2i extends Tuple2i implements Serializable
> {
>     static final long serialVersionUID = 9208072376494084954L;
>     
>     public Point2i(final int x, final int y) {
>         super(x, y);
>     }
>     
>     public Point2i(final int[] t) {
>         super(t);
>     }
>     
>     public Point2i(final Tuple2i t1) {
>         super(t1);
>     }
>     
>     public Point2i() {
>     }
diff -r TrackAnalyzer_/vecmath/Point3dModified.java procyon/vecmath/Point3dModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,63c9,68
< public class Point3dModified extends Tuple3dModified implements Serializable {
<    static final long serialVersionUID = 5718062286069042927L;
< 
<    public Point3dModified(double x, double y, double z) {
<       super(x, y, z);
<    }
< 
<    public Point3dModified(double[] p) {
<       super(p);
<    }
< 
<    public Point3dModified(Point3dModified p1) {
<       super((Tuple3dModified)p1);
<    }
< 
<    public Point3dModified(Point3f p1) {
<       super((Tuple3f)p1);
<    }
< 
<    public Point3dModified(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public Point3dModified(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public Point3dModified() {
<    }
< 
<    public final double distanceSquared(Point3dModified p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       double dz = this.z - p1.z;
<       return dx * dx + dy * dy + dz * dz;
<    }
< 
<    public double distance(Point3dModified p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       double dz = this.z - p1.z;
<       return Math.sqrt(dx * dx + dy * dy + dz * dz);
<    }
< 
<    public final double distanceL1(Point3dModified p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z);
<    }
< 
<    public final double distanceLinf(Point3dModified p1) {
<       double tmp = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<       return Math.max(tmp, Math.abs(this.z - p1.z));
<    }
< 
<    public final void project(Point4d p1) {
<       double oneOw = 1.0D / p1.w;
<       this.x = p1.x * oneOw;
<       this.y = p1.y * oneOw;
<       this.z = p1.z * oneOw;
<    }
---
> public class Point3dModified extends Tuple3dModified implements Serializable
> {
>     static final long serialVersionUID = 5718062286069042927L;
>     
>     public Point3dModified(final double x, final double y, final double z) {
>         super(x, y, z);
>     }
>     
>     public Point3dModified(final double[] p) {
>         super(p);
>     }
>     
>     public Point3dModified(final Point3dModified p1) {
>         super(p1);
>     }
>     
>     public Point3dModified(final Point3f p1) {
>         super(p1);
>     }
>     
>     public Point3dModified(final Tuple3f t1) {
>         super(t1);
>     }
>     
>     public Point3dModified(final Tuple3dModified t1) {
>         super(t1);
>     }
>     
>     public Point3dModified() {
>     }
>     
>     public final double distanceSquared(final Point3dModified p1) {
>         final double dx = this.x - p1.x;
>         final double dy = this.y - p1.y;
>         final double dz = this.z - p1.z;
>         return dx * dx + dy * dy + dz * dz;
>     }
>     
>     public double distance(final Point3dModified p1) {
>         final double dx = this.x - p1.x;
>         final double dy = this.y - p1.y;
>         final double dz = this.z - p1.z;
>         return Math.sqrt(dx * dx + dy * dy + dz * dz);
>     }
>     
>     public final double distanceL1(final Point3dModified p1) {
>         return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z);
>     }
>     
>     public final double distanceLinf(final Point3dModified p1) {
>         final double tmp = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
>         return Math.max(tmp, Math.abs(this.z - p1.z));
>     }
>     
>     public final void project(final Point4d p1) {
>         final double oneOw = 1.0 / p1.w;
>         this.x = p1.x * oneOw;
>         this.y = p1.y * oneOw;
>         this.z = p1.z * oneOw;
>     }
diff -r TrackAnalyzer_/vecmath/Point3f.java procyon/vecmath/Point3f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,63c9,68
< public class Point3f extends Tuple3f implements Serializable {
<    static final long serialVersionUID = -8689337816398030143L;
< 
<    public Point3f(float x, float y, float z) {
<       super(x, y, z);
<    }
< 
<    public Point3f(float[] p) {
<       super(p);
<    }
< 
<    public Point3f(Point3f p1) {
<       super((Tuple3f)p1);
<    }
< 
<    public Point3f(Point3dModified p1) {
<       super((Tuple3dModified)p1);
<    }
< 
<    public Point3f(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public Point3f(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public Point3f() {
<    }
< 
<    public final float distanceSquared(Point3f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       float dz = this.z - p1.z;
<       return dx * dx + dy * dy + dz * dz;
<    }
< 
<    public final float distance(Point3f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       float dz = this.z - p1.z;
<       return (float)Math.sqrt((double)(dx * dx + dy * dy + dz * dz));
<    }
< 
<    public final float distanceL1(Point3f p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z);
<    }
< 
<    public final float distanceLinf(Point3f p1) {
<       float tmp = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<       return Math.max(tmp, Math.abs(this.z - p1.z));
<    }
< 
<    public final void project(Point4f p1) {
<       float oneOw = 1.0F / p1.w;
<       this.x = p1.x * oneOw;
<       this.y = p1.y * oneOw;
<       this.z = p1.z * oneOw;
<    }
---
> public class Point3f extends Tuple3f implements Serializable
> {
>     static final long serialVersionUID = -8689337816398030143L;
>     
>     public Point3f(final float x, final float y, final float z) {
>         super(x, y, z);
>     }
>     
>     public Point3f(final float[] p) {
>         super(p);
>     }
>     
>     public Point3f(final Point3f p1) {
>         super(p1);
>     }
>     
>     public Point3f(final Point3dModified p1) {
>         super(p1);
>     }
>     
>     public Point3f(final Tuple3f t1) {
>         super(t1);
>     }
>     
>     public Point3f(final Tuple3dModified t1) {
>         super(t1);
>     }
>     
>     public Point3f() {
>     }
>     
>     public final float distanceSquared(final Point3f p1) {
>         final float dx = this.x - p1.x;
>         final float dy = this.y - p1.y;
>         final float dz = this.z - p1.z;
>         return dx * dx + dy * dy + dz * dz;
>     }
>     
>     public final float distance(final Point3f p1) {
>         final float dx = this.x - p1.x;
>         final float dy = this.y - p1.y;
>         final float dz = this.z - p1.z;
>         return (float)Math.sqrt(dx * dx + dy * dy + dz * dz);
>     }
>     
>     public final float distanceL1(final Point3f p1) {
>         return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z);
>     }
>     
>     public final float distanceLinf(final Point3f p1) {
>         final float tmp = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
>         return Math.max(tmp, Math.abs(this.z - p1.z));
>     }
>     
>     public final void project(final Point4f p1) {
>         final float oneOw = 1.0f / p1.w;
>         this.x = p1.x * oneOw;
>         this.y = p1.y * oneOw;
>         this.z = p1.z * oneOw;
>     }
diff -r TrackAnalyzer_/vecmath/Point3i.java procyon/vecmath/Point3i.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,21c9,26
< public class Point3i extends Tuple3i implements Serializable {
<    static final long serialVersionUID = 6149289077348153921L;
< 
<    public Point3i(int x, int y, int z) {
<       super(x, y, z);
<    }
< 
<    public Point3i(int[] t) {
<       super(t);
<    }
< 
<    public Point3i(Tuple3i t1) {
<       super(t1);
<    }
< 
<    public Point3i() {
<    }
---
> public class Point3i extends Tuple3i implements Serializable
> {
>     static final long serialVersionUID = 6149289077348153921L;
>     
>     public Point3i(final int x, final int y, final int z) {
>         super(x, y, z);
>     }
>     
>     public Point3i(final int[] t) {
>         super(t);
>     }
>     
>     public Point3i(final Tuple3i t1) {
>         super(t1);
>     }
>     
>     public Point3i() {
>     }
diff -r TrackAnalyzer_/vecmath/Point4d.java procyon/vecmath/Point4d.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,78c9,83
< public class Point4d extends Tuple4d implements Serializable {
<    static final long serialVersionUID = 1733471895962736949L;
< 
<    public Point4d(double x, double y, double z, double w) {
<       super(x, y, z, w);
<    }
< 
<    public Point4d(double[] p) {
<       super(p);
<    }
< 
<    public Point4d(Point4d p1) {
<       super((Tuple4d)p1);
<    }
< 
<    public Point4d(Point4f p1) {
<       super((Tuple4f)p1);
<    }
< 
<    public Point4d(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public Point4d(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public Point4d(Tuple3dModified t1) {
<       super(t1.x, t1.y, t1.z, 1.0D);
<    }
< 
<    public Point4d() {
<    }
< 
<    public final void set(Tuple3dModified t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = 1.0D;
<    }
< 
<    public final double distanceSquared(Point4d p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       double dz = this.z - p1.z;
<       double dw = this.w - p1.w;
<       return dx * dx + dy * dy + dz * dz + dw * dw;
<    }
< 
<    public final double distance(Point4d p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       double dz = this.z - p1.z;
<       double dw = this.w - p1.w;
<       return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
<    }
< 
<    public final double distanceL1(Point4d p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z) + Math.abs(this.w - p1.w);
<    }
< 
<    public final double distanceLinf(Point4d p1) {
<       double t1 = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<       double t2 = Math.max(Math.abs(this.z - p1.z), Math.abs(this.w - p1.w));
<       return Math.max(t1, t2);
<    }
< 
<    public final void project(Point4d p1) {
<       double oneOw = 1.0D / p1.w;
<       this.x = p1.x * oneOw;
<       this.y = p1.y * oneOw;
<       this.z = p1.z * oneOw;
<       this.w = 1.0D;
<    }
---
> public class Point4d extends Tuple4d implements Serializable
> {
>     static final long serialVersionUID = 1733471895962736949L;
>     
>     public Point4d(final double x, final double y, final double z, final double w) {
>         super(x, y, z, w);
>     }
>     
>     public Point4d(final double[] p) {
>         super(p);
>     }
>     
>     public Point4d(final Point4d p1) {
>         super(p1);
>     }
>     
>     public Point4d(final Point4f p1) {
>         super(p1);
>     }
>     
>     public Point4d(final Tuple4f t1) {
>         super(t1);
>     }
>     
>     public Point4d(final Tuple4d t1) {
>         super(t1);
>     }
>     
>     public Point4d(final Tuple3dModified t1) {
>         super(t1.x, t1.y, t1.z, 1.0);
>     }
>     
>     public Point4d() {
>     }
>     
>     public final void set(final Tuple3dModified t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = 1.0;
>     }
>     
>     public final double distanceSquared(final Point4d p1) {
>         final double dx = this.x - p1.x;
>         final double dy = this.y - p1.y;
>         final double dz = this.z - p1.z;
>         final double dw = this.w - p1.w;
>         return dx * dx + dy * dy + dz * dz + dw * dw;
>     }
>     
>     public final double distance(final Point4d p1) {
>         final double dx = this.x - p1.x;
>         final double dy = this.y - p1.y;
>         final double dz = this.z - p1.z;
>         final double dw = this.w - p1.w;
>         return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
>     }
>     
>     public final double distanceL1(final Point4d p1) {
>         return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z) + Math.abs(this.w - p1.w);
>     }
>     
>     public final double distanceLinf(final Point4d p1) {
>         final double t1 = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
>         final double t2 = Math.max(Math.abs(this.z - p1.z), Math.abs(this.w - p1.w));
>         return Math.max(t1, t2);
>     }
>     
>     public final void project(final Point4d p1) {
>         final double oneOw = 1.0 / p1.w;
>         this.x = p1.x * oneOw;
>         this.y = p1.y * oneOw;
>         this.z = p1.z * oneOw;
>         this.w = 1.0;
>     }
diff -r TrackAnalyzer_/vecmath/Point4f.java procyon/vecmath/Point4f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,78c9,83
< public class Point4f extends Tuple4f implements Serializable {
<    static final long serialVersionUID = 4643134103185764459L;
< 
<    public Point4f(float x, float y, float z, float w) {
<       super(x, y, z, w);
<    }
< 
<    public Point4f(float[] p) {
<       super(p);
<    }
< 
<    public Point4f(Point4f p1) {
<       super((Tuple4f)p1);
<    }
< 
<    public Point4f(Point4d p1) {
<       super((Tuple4d)p1);
<    }
< 
<    public Point4f(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public Point4f(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public Point4f(Tuple3f t1) {
<       super(t1.x, t1.y, t1.z, 1.0F);
<    }
< 
<    public Point4f() {
<    }
< 
<    public final void set(Tuple3f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = 1.0F;
<    }
< 
<    public final float distanceSquared(Point4f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       float dz = this.z - p1.z;
<       float dw = this.w - p1.w;
<       return dx * dx + dy * dy + dz * dz + dw * dw;
<    }
< 
<    public final float distance(Point4f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       float dz = this.z - p1.z;
<       float dw = this.w - p1.w;
<       return (float)Math.sqrt((double)(dx * dx + dy * dy + dz * dz + dw * dw));
<    }
< 
<    public final float distanceL1(Point4f p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z) + Math.abs(this.w - p1.w);
<    }
< 
<    public final float distanceLinf(Point4f p1) {
<       float t1 = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<       float t2 = Math.max(Math.abs(this.z - p1.z), Math.abs(this.w - p1.w));
<       return Math.max(t1, t2);
<    }
< 
<    public final void project(Point4f p1) {
<       float oneOw = 1.0F / p1.w;
<       this.x = p1.x * oneOw;
<       this.y = p1.y * oneOw;
<       this.z = p1.z * oneOw;
<       this.w = 1.0F;
<    }
---
> public class Point4f extends Tuple4f implements Serializable
> {
>     static final long serialVersionUID = 4643134103185764459L;
>     
>     public Point4f(final float x, final float y, final float z, final float w) {
>         super(x, y, z, w);
>     }
>     
>     public Point4f(final float[] p) {
>         super(p);
>     }
>     
>     public Point4f(final Point4f p1) {
>         super(p1);
>     }
>     
>     public Point4f(final Point4d p1) {
>         super(p1);
>     }
>     
>     public Point4f(final Tuple4f t1) {
>         super(t1);
>     }
>     
>     public Point4f(final Tuple4d t1) {
>         super(t1);
>     }
>     
>     public Point4f(final Tuple3f t1) {
>         super(t1.x, t1.y, t1.z, 1.0f);
>     }
>     
>     public Point4f() {
>     }
>     
>     public final void set(final Tuple3f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = 1.0f;
>     }
>     
>     public final float distanceSquared(final Point4f p1) {
>         final float dx = this.x - p1.x;
>         final float dy = this.y - p1.y;
>         final float dz = this.z - p1.z;
>         final float dw = this.w - p1.w;
>         return dx * dx + dy * dy + dz * dz + dw * dw;
>     }
>     
>     public final float distance(final Point4f p1) {
>         final float dx = this.x - p1.x;
>         final float dy = this.y - p1.y;
>         final float dz = this.z - p1.z;
>         final float dw = this.w - p1.w;
>         return (float)Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
>     }
>     
>     public final float distanceL1(final Point4f p1) {
>         return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z) + Math.abs(this.w - p1.w);
>     }
>     
>     public final float distanceLinf(final Point4f p1) {
>         final float t1 = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
>         final float t2 = Math.max(Math.abs(this.z - p1.z), Math.abs(this.w - p1.w));
>         return Math.max(t1, t2);
>     }
>     
>     public final void project(final Point4f p1) {
>         final float oneOw = 1.0f / p1.w;
>         this.x = p1.x * oneOw;
>         this.y = p1.y * oneOw;
>         this.z = p1.z * oneOw;
>         this.w = 1.0f;
>     }
diff -r TrackAnalyzer_/vecmath/Point4i.java procyon/vecmath/Point4i.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,21c9,26
< public class Point4i extends Tuple4i implements Serializable {
<    static final long serialVersionUID = 620124780244617983L;
< 
<    public Point4i(int x, int y, int z, int w) {
<       super(x, y, z, w);
<    }
< 
<    public Point4i(int[] t) {
<       super(t);
<    }
< 
<    public Point4i(Tuple4i t1) {
<       super(t1);
<    }
< 
<    public Point4i() {
<    }
---
> public class Point4i extends Tuple4i implements Serializable
> {
>     static final long serialVersionUID = 620124780244617983L;
>     
>     public Point4i(final int x, final int y, final int z, final int w) {
>         super(x, y, z, w);
>     }
>     
>     public Point4i(final int[] t) {
>         super(t);
>     }
>     
>     public Point4i(final Tuple4i t1) {
>         super(t1);
>     }
>     
>     public Point4i() {
>     }
diff -r TrackAnalyzer_/vecmath/SingularMatrixException.java procyon/vecmath/SingularMatrixException.java
1c1,3
< package vecmath;
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
3,5c5
< public class SingularMatrixException extends RuntimeException {
<    public SingularMatrixException() {
<    }
---
> package vecmath;
7,9c7,14
<    public SingularMatrixException(String str) {
<       super(str);
<    }
---
> public class SingularMatrixException extends RuntimeException
> {
>     public SingularMatrixException() {
>     }
>     
>     public SingularMatrixException(final String str) {
>         super(str);
>     }
diff -r TrackAnalyzer_/vecmath/TexCoord2f.java procyon/vecmath/TexCoord2f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,25c9,30
< public class TexCoord2f extends Tuple2f implements Serializable {
<    static final long serialVersionUID = 7998248474800032487L;
< 
<    public TexCoord2f(float x, float y) {
<       super(x, y);
<    }
< 
<    public TexCoord2f(float[] v) {
<       super(v);
<    }
< 
<    public TexCoord2f(TexCoord2f v1) {
<       super((Tuple2f)v1);
<    }
< 
<    public TexCoord2f(Tuple2f t1) {
<       super(t1);
<    }
< 
<    public TexCoord2f() {
<    }
---
> public class TexCoord2f extends Tuple2f implements Serializable
> {
>     static final long serialVersionUID = 7998248474800032487L;
>     
>     public TexCoord2f(final float x, final float y) {
>         super(x, y);
>     }
>     
>     public TexCoord2f(final float[] v) {
>         super(v);
>     }
>     
>     public TexCoord2f(final TexCoord2f v1) {
>         super(v1);
>     }
>     
>     public TexCoord2f(final Tuple2f t1) {
>         super(t1);
>     }
>     
>     public TexCoord2f() {
>     }
diff -r TrackAnalyzer_/vecmath/TexCoord3f.java procyon/vecmath/TexCoord3f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,29c9,34
< public class TexCoord3f extends Tuple3f implements Serializable {
<    static final long serialVersionUID = -3517736544731446513L;
< 
<    public TexCoord3f(float x, float y, float z) {
<       super(x, y, z);
<    }
< 
<    public TexCoord3f(float[] v) {
<       super(v);
<    }
< 
<    public TexCoord3f(TexCoord3f v1) {
<       super((Tuple3f)v1);
<    }
< 
<    public TexCoord3f(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public TexCoord3f(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public TexCoord3f() {
<    }
---
> public class TexCoord3f extends Tuple3f implements Serializable
> {
>     static final long serialVersionUID = -3517736544731446513L;
>     
>     public TexCoord3f(final float x, final float y, final float z) {
>         super(x, y, z);
>     }
>     
>     public TexCoord3f(final float[] v) {
>         super(v);
>     }
>     
>     public TexCoord3f(final TexCoord3f v1) {
>         super(v1);
>     }
>     
>     public TexCoord3f(final Tuple3f t1) {
>         super(t1);
>     }
>     
>     public TexCoord3f(final Tuple3dModified t1) {
>         super(t1);
>     }
>     
>     public TexCoord3f() {
>     }
diff -r TrackAnalyzer_/vecmath/TexCoord4f.java procyon/vecmath/TexCoord4f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,29c9,34
< public class TexCoord4f extends Tuple4f implements Serializable {
<    static final long serialVersionUID = -3517736544731446513L;
< 
<    public TexCoord4f(float x, float y, float z, float w) {
<       super(x, y, z, w);
<    }
< 
<    public TexCoord4f(float[] v) {
<       super(v);
<    }
< 
<    public TexCoord4f(TexCoord4f v1) {
<       super((Tuple4f)v1);
<    }
< 
<    public TexCoord4f(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public TexCoord4f(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public TexCoord4f() {
<    }
---
> public class TexCoord4f extends Tuple4f implements Serializable
> {
>     static final long serialVersionUID = -3517736544731446513L;
>     
>     public TexCoord4f(final float x, final float y, final float z, final float w) {
>         super(x, y, z, w);
>     }
>     
>     public TexCoord4f(final float[] v) {
>         super(v);
>     }
>     
>     public TexCoord4f(final TexCoord4f v1) {
>         super(v1);
>     }
>     
>     public TexCoord4f(final Tuple4f t1) {
>         super(t1);
>     }
>     
>     public TexCoord4f(final Tuple4d t1) {
>         super(t1);
>     }
>     
>     public TexCoord4f() {
>     }
diff -r TrackAnalyzer_/vecmath/Tuple2d.java procyon/vecmath/Tuple2d.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,144c9,127
< public abstract class Tuple2d implements Serializable, Cloneable {
<    static final long serialVersionUID = 6205762482756093838L;
<    public double x;
<    public double y;
< 
<    public Tuple2d(double x, double y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public Tuple2d(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public Tuple2d(Tuple2d t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public Tuple2d(Tuple2f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<    }
< 
<    public Tuple2d() {
<       this.x = 0.0D;
<       this.y = 0.0D;
<    }
< 
<    public final void set(double x, double y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public final void set(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public final void set(Tuple2d t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public final void set(Tuple2f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<    }
< 
<    public final void get(double[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<    }
< 
<    public final void add(Tuple2d t1, Tuple2d t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<    }
< 
<    public final void add(Tuple2d t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<    }
< 
<    public final void sub(Tuple2d t1, Tuple2d t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<    }
< 
<    public final void sub(Tuple2d t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<    }
< 
<    public final void negate(Tuple2d t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<    }
< 
<    public final void scale(double s, Tuple2d t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<    }
< 
<    public final void scale(double s) {
<       this.x *= s;
<       this.y *= s;
<    }
< 
<    public final void scaleAdd(double s, Tuple2d t1, Tuple2d t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<    }
< 
<    public final void scaleAdd(double s, Tuple2d t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashDoubleBits(bits, this.x);
<       bits = VecMathUtil.hashDoubleBits(bits, this.y);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    public boolean equals(Tuple2d t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple2d t2 = (Tuple2d)t1;
<          return this.x == t2.x && this.y == t2.y;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple2d t1, double epsilon) {
<       double diff = this.x - t1.x;
<       if (Double.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Double.isNaN(diff)) {
---
> public abstract class Tuple2d implements Serializable, Cloneable
> {
>     static final long serialVersionUID = 6205762482756093838L;
>     public double x;
>     public double y;
>     
>     public Tuple2d(final double x, final double y) {
>         this.x = x;
>         this.y = y;
>     }
>     
>     public Tuple2d(final double[] t) {
>         this.x = t[0];
>         this.y = t[1];
>     }
>     
>     public Tuple2d(final Tuple2d t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>     }
>     
>     public Tuple2d(final Tuple2f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>     }
>     
>     public Tuple2d() {
>         this.x = 0.0;
>         this.y = 0.0;
>     }
>     
>     public final void set(final double x, final double y) {
>         this.x = x;
>         this.y = y;
>     }
>     
>     public final void set(final double[] t) {
>         this.x = t[0];
>         this.y = t[1];
>     }
>     
>     public final void set(final Tuple2d t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>     }
>     
>     public final void set(final Tuple2f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>     }
>     
>     public final void get(final double[] t) {
>         t[0] = this.x;
>         t[1] = this.y;
>     }
>     
>     public final void add(final Tuple2d t1, final Tuple2d t2) {
>         this.x = t1.x + t2.x;
>         this.y = t1.y + t2.y;
>     }
>     
>     public final void add(final Tuple2d t1) {
>         this.x += t1.x;
>         this.y += t1.y;
>     }
>     
>     public final void sub(final Tuple2d t1, final Tuple2d t2) {
>         this.x = t1.x - t2.x;
>         this.y = t1.y - t2.y;
>     }
>     
>     public final void sub(final Tuple2d t1) {
>         this.x -= t1.x;
>         this.y -= t1.y;
>     }
>     
>     public final void negate(final Tuple2d t1) {
>         this.x = -t1.x;
>         this.y = -t1.y;
>     }
>     
>     public final void negate() {
>         this.x = -this.x;
>         this.y = -this.y;
>     }
>     
>     public final void scale(final double s, final Tuple2d t1) {
>         this.x = s * t1.x;
>         this.y = s * t1.y;
>     }
>     
>     public final void scale(final double s) {
>         this.x *= s;
>         this.y *= s;
>     }
>     
>     public final void scaleAdd(final double s, final Tuple2d t1, final Tuple2d t2) {
>         this.x = s * t1.x + t2.x;
>         this.y = s * t1.y + t2.y;
>     }
>     
>     public final void scaleAdd(final double s, final Tuple2d t1) {
>         this.x = s * this.x + t1.x;
>         this.y = s * this.y + t1.y;
>     }
>     
>     @Override
>     public int hashCode() {
>         long bits = 1L;
>         bits = VecMathUtil.hashDoubleBits(bits, this.x);
>         bits = VecMathUtil.hashDoubleBits(bits, this.y);
>         return VecMathUtil.hashFinish(bits);
>     }
>     
>     public boolean equals(final Tuple2d t1) {
>         try {
>             return this.x == t1.x && this.y == t1.y;
>         }
>         catch (NullPointerException e2) {
146,284c129,290
<          } else {
<             return !((diff < 0.0D ? -diff : diff) > epsilon);
<          }
<       }
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ")";
<    }
< 
<    public final void clamp(double min, double max, Tuple2d t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMin(double min, Tuple2d t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMax(double max, Tuple2d t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void absolute(Tuple2d t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<    }
< 
<    public final void clamp(double min, double max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMin(double min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMax(double max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<    }
< 
<    public final void interpolate(Tuple2d t1, Tuple2d t2, double alpha) {
<       this.x = (1.0D - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0D - alpha) * t1.y + alpha * t2.y;
<    }
< 
<    public final void interpolate(Tuple2d t1, double alpha) {
<       this.x = (1.0D - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0D - alpha) * this.y + alpha * t1.y;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final double getX() {
<       return this.x;
<    }
< 
<    public final void setX(double x) {
<       this.x = x;
<    }
< 
<    public final double getY() {
<       return this.y;
<    }
< 
<    public final void setY(double y) {
<       this.y = y;
<    }
---
>         }
>     }
>     
>     @Override
>     public boolean equals(final Object t1) {
>         try {
>             final Tuple2d t2 = (Tuple2d)t1;
>             return this.x == t2.x && this.y == t2.y;
>         }
>         catch (NullPointerException e2) {
>             return false;
>         }
>         catch (ClassCastException e3) {
>             return false;
>         }
>     }
>     
>     public boolean epsilonEquals(final Tuple2d t1, final double epsilon) {
>         double diff = this.x - t1.x;
>         if (Double.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.y - t1.y;
>         return !Double.isNaN(diff) && ((diff < 0.0) ? (-diff) : diff) <= epsilon;
>     }
>     
>     @Override
>     public String toString() {
>         return "(" + this.x + ", " + this.y + ")";
>     }
>     
>     public final void clamp(final double min, final double max, final Tuple2d t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>     }
>     
>     public final void clampMin(final double min, final Tuple2d t) {
>         if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>     }
>     
>     public final void clampMax(final double max, final Tuple2d t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else {
>             this.y = t.y;
>         }
>     }
>     
>     public final void absolute(final Tuple2d t) {
>         this.x = Math.abs(t.x);
>         this.y = Math.abs(t.y);
>     }
>     
>     public final void clamp(final double min, final double max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         else if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         else if (this.y < min) {
>             this.y = min;
>         }
>     }
>     
>     public final void clampMin(final double min) {
>         if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y < min) {
>             this.y = min;
>         }
>     }
>     
>     public final void clampMax(final double max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>     }
>     
>     public final void absolute() {
>         this.x = Math.abs(this.x);
>         this.y = Math.abs(this.y);
>     }
>     
>     public final void interpolate(final Tuple2d t1, final Tuple2d t2, final double alpha) {
>         this.x = (1.0 - alpha) * t1.x + alpha * t2.x;
>         this.y = (1.0 - alpha) * t1.y + alpha * t2.y;
>     }
>     
>     public final void interpolate(final Tuple2d t1, final double alpha) {
>         this.x = (1.0 - alpha) * this.x + alpha * t1.x;
>         this.y = (1.0 - alpha) * this.y + alpha * t1.y;
>     }
>     
>     public Object clone() {
>         try {
>             return super.clone();
>         }
>         catch (CloneNotSupportedException e) {
>             throw new InternalError();
>         }
>     }
>     
>     public final double getX() {
>         return this.x;
>     }
>     
>     public final void setX(final double x) {
>         this.x = x;
>     }
>     
>     public final double getY() {
>         return this.y;
>     }
>     
>     public final void setY(final double y) {
>         this.y = y;
>     }
diff -r TrackAnalyzer_/vecmath/Tuple2f.java procyon/vecmath/Tuple2f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,144c9,127
< public abstract class Tuple2f implements Serializable, Cloneable {
<    static final long serialVersionUID = 9011180388985266884L;
<    public float x;
<    public float y;
< 
<    public Tuple2f(float x, float y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public Tuple2f(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public Tuple2f(Tuple2f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public Tuple2f(Tuple2d t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<    }
< 
<    public Tuple2f() {
<       this.x = 0.0F;
<       this.y = 0.0F;
<    }
< 
<    public final void set(float x, float y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public final void set(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public final void set(Tuple2f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public final void set(Tuple2d t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<    }
< 
<    public final void get(float[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<    }
< 
<    public final void add(Tuple2f t1, Tuple2f t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<    }
< 
<    public final void add(Tuple2f t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<    }
< 
<    public final void sub(Tuple2f t1, Tuple2f t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<    }
< 
<    public final void sub(Tuple2f t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<    }
< 
<    public final void negate(Tuple2f t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<    }
< 
<    public final void scale(float s, Tuple2f t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<    }
< 
<    public final void scale(float s) {
<       this.x *= s;
<       this.y *= s;
<    }
< 
<    public final void scaleAdd(float s, Tuple2f t1, Tuple2f t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<    }
< 
<    public final void scaleAdd(float s, Tuple2f t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashFloatBits(bits, this.x);
<       bits = VecMathUtil.hashFloatBits(bits, this.y);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    public boolean equals(Tuple2f t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple2f t2 = (Tuple2f)t1;
<          return this.x == t2.x && this.y == t2.y;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple2f t1, float epsilon) {
<       float diff = this.x - t1.x;
<       if (Float.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Float.isNaN(diff)) {
---
> public abstract class Tuple2f implements Serializable, Cloneable
> {
>     static final long serialVersionUID = 9011180388985266884L;
>     public float x;
>     public float y;
>     
>     public Tuple2f(final float x, final float y) {
>         this.x = x;
>         this.y = y;
>     }
>     
>     public Tuple2f(final float[] t) {
>         this.x = t[0];
>         this.y = t[1];
>     }
>     
>     public Tuple2f(final Tuple2f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>     }
>     
>     public Tuple2f(final Tuple2d t1) {
>         this.x = (float)t1.x;
>         this.y = (float)t1.y;
>     }
>     
>     public Tuple2f() {
>         this.x = 0.0f;
>         this.y = 0.0f;
>     }
>     
>     public final void set(final float x, final float y) {
>         this.x = x;
>         this.y = y;
>     }
>     
>     public final void set(final float[] t) {
>         this.x = t[0];
>         this.y = t[1];
>     }
>     
>     public final void set(final Tuple2f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>     }
>     
>     public final void set(final Tuple2d t1) {
>         this.x = (float)t1.x;
>         this.y = (float)t1.y;
>     }
>     
>     public final void get(final float[] t) {
>         t[0] = this.x;
>         t[1] = this.y;
>     }
>     
>     public final void add(final Tuple2f t1, final Tuple2f t2) {
>         this.x = t1.x + t2.x;
>         this.y = t1.y + t2.y;
>     }
>     
>     public final void add(final Tuple2f t1) {
>         this.x += t1.x;
>         this.y += t1.y;
>     }
>     
>     public final void sub(final Tuple2f t1, final Tuple2f t2) {
>         this.x = t1.x - t2.x;
>         this.y = t1.y - t2.y;
>     }
>     
>     public final void sub(final Tuple2f t1) {
>         this.x -= t1.x;
>         this.y -= t1.y;
>     }
>     
>     public final void negate(final Tuple2f t1) {
>         this.x = -t1.x;
>         this.y = -t1.y;
>     }
>     
>     public final void negate() {
>         this.x = -this.x;
>         this.y = -this.y;
>     }
>     
>     public final void scale(final float s, final Tuple2f t1) {
>         this.x = s * t1.x;
>         this.y = s * t1.y;
>     }
>     
>     public final void scale(final float s) {
>         this.x *= s;
>         this.y *= s;
>     }
>     
>     public final void scaleAdd(final float s, final Tuple2f t1, final Tuple2f t2) {
>         this.x = s * t1.x + t2.x;
>         this.y = s * t1.y + t2.y;
>     }
>     
>     public final void scaleAdd(final float s, final Tuple2f t1) {
>         this.x = s * this.x + t1.x;
>         this.y = s * this.y + t1.y;
>     }
>     
>     @Override
>     public int hashCode() {
>         long bits = 1L;
>         bits = VecMathUtil.hashFloatBits(bits, this.x);
>         bits = VecMathUtil.hashFloatBits(bits, this.y);
>         return VecMathUtil.hashFinish(bits);
>     }
>     
>     public boolean equals(final Tuple2f t1) {
>         try {
>             return this.x == t1.x && this.y == t1.y;
>         }
>         catch (NullPointerException e2) {
146,284c129,290
<          } else {
<             return !((diff < 0.0F ? -diff : diff) > epsilon);
<          }
<       }
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ")";
<    }
< 
<    public final void clamp(float min, float max, Tuple2f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMin(float min, Tuple2f t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMax(float max, Tuple2f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void absolute(Tuple2f t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<    }
< 
<    public final void clamp(float min, float max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMin(float min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMax(float max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<    }
< 
<    public final void interpolate(Tuple2f t1, Tuple2f t2, float alpha) {
<       this.x = (1.0F - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0F - alpha) * t1.y + alpha * t2.y;
<    }
< 
<    public final void interpolate(Tuple2f t1, float alpha) {
<       this.x = (1.0F - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0F - alpha) * this.y + alpha * t1.y;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final float getX() {
<       return this.x;
<    }
< 
<    public final void setX(float x) {
<       this.x = x;
<    }
< 
<    public final float getY() {
<       return this.y;
<    }
< 
<    public final void setY(float y) {
<       this.y = y;
<    }
---
>         }
>     }
>     
>     @Override
>     public boolean equals(final Object t1) {
>         try {
>             final Tuple2f t2 = (Tuple2f)t1;
>             return this.x == t2.x && this.y == t2.y;
>         }
>         catch (NullPointerException e2) {
>             return false;
>         }
>         catch (ClassCastException e3) {
>             return false;
>         }
>     }
>     
>     public boolean epsilonEquals(final Tuple2f t1, final float epsilon) {
>         float diff = this.x - t1.x;
>         if (Float.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0f) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.y - t1.y;
>         return !Float.isNaN(diff) && ((diff < 0.0f) ? (-diff) : diff) <= epsilon;
>     }
>     
>     @Override
>     public String toString() {
>         return "(" + this.x + ", " + this.y + ")";
>     }
>     
>     public final void clamp(final float min, final float max, final Tuple2f t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>     }
>     
>     public final void clampMin(final float min, final Tuple2f t) {
>         if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>     }
>     
>     public final void clampMax(final float max, final Tuple2f t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else {
>             this.y = t.y;
>         }
>     }
>     
>     public final void absolute(final Tuple2f t) {
>         this.x = Math.abs(t.x);
>         this.y = Math.abs(t.y);
>     }
>     
>     public final void clamp(final float min, final float max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         else if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         else if (this.y < min) {
>             this.y = min;
>         }
>     }
>     
>     public final void clampMin(final float min) {
>         if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y < min) {
>             this.y = min;
>         }
>     }
>     
>     public final void clampMax(final float max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>     }
>     
>     public final void absolute() {
>         this.x = Math.abs(this.x);
>         this.y = Math.abs(this.y);
>     }
>     
>     public final void interpolate(final Tuple2f t1, final Tuple2f t2, final float alpha) {
>         this.x = (1.0f - alpha) * t1.x + alpha * t2.x;
>         this.y = (1.0f - alpha) * t1.y + alpha * t2.y;
>     }
>     
>     public final void interpolate(final Tuple2f t1, final float alpha) {
>         this.x = (1.0f - alpha) * this.x + alpha * t1.x;
>         this.y = (1.0f - alpha) * this.y + alpha * t1.y;
>     }
>     
>     public Object clone() {
>         try {
>             return super.clone();
>         }
>         catch (CloneNotSupportedException e) {
>             throw new InternalError();
>         }
>     }
>     
>     public final float getX() {
>         return this.x;
>     }
>     
>     public final void setX(final float x) {
>         this.x = x;
>     }
>     
>     public final float getY() {
>         return this.y;
>     }
>     
>     public final void setY(final float y) {
>         this.y = y;
>     }
diff -r TrackAnalyzer_/vecmath/Tuple2i.java procyon/vecmath/Tuple2i.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,245c9,254
< public abstract class Tuple2i implements Serializable, Cloneable {
<    static final long serialVersionUID = -3555701650170169638L;
<    public int x;
<    public int y;
< 
<    public Tuple2i(int x, int y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public Tuple2i(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public Tuple2i(Tuple2i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public Tuple2i() {
<       this.x = 0;
<       this.y = 0;
<    }
< 
<    public final void set(int x, int y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public final void set(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public final void set(Tuple2i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public final void get(int[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<    }
< 
<    public final void get(Tuple2i t) {
<       t.x = this.x;
<       t.y = this.y;
<    }
< 
<    public final void add(Tuple2i t1, Tuple2i t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<    }
< 
<    public final void add(Tuple2i t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<    }
< 
<    public final void sub(Tuple2i t1, Tuple2i t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<    }
< 
<    public final void sub(Tuple2i t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<    }
< 
<    public final void negate(Tuple2i t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<    }
< 
<    public final void scale(int s, Tuple2i t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<    }
< 
<    public final void scale(int s) {
<       this.x *= s;
<       this.y *= s;
<    }
< 
<    public final void scaleAdd(int s, Tuple2i t1, Tuple2i t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<    }
< 
<    public final void scaleAdd(int s, Tuple2i t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ")";
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple2i t2 = (Tuple2i)t1;
<          return this.x == t2.x && this.y == t2.y;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = 31L * bits + (long)this.x;
<       bits = 31L * bits + (long)this.y;
<       return (int)(bits ^ bits >> 32);
<    }
< 
<    public final void clamp(int min, int max, Tuple2i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMin(int min, Tuple2i t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMax(int max, Tuple2i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void absolute(Tuple2i t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<    }
< 
<    public final void clamp(int min, int max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMin(int min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMax(int max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final int getX() {
<       return this.x;
<    }
< 
<    public final void setX(int x) {
<       this.x = x;
<    }
< 
<    public final int getY() {
<       return this.y;
<    }
< 
<    public final void setY(int y) {
<       this.y = y;
<    }
---
> public abstract class Tuple2i implements Serializable, Cloneable
> {
>     static final long serialVersionUID = -3555701650170169638L;
>     public int x;
>     public int y;
>     
>     public Tuple2i(final int x, final int y) {
>         this.x = x;
>         this.y = y;
>     }
>     
>     public Tuple2i(final int[] t) {
>         this.x = t[0];
>         this.y = t[1];
>     }
>     
>     public Tuple2i(final Tuple2i t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>     }
>     
>     public Tuple2i() {
>         this.x = 0;
>         this.y = 0;
>     }
>     
>     public final void set(final int x, final int y) {
>         this.x = x;
>         this.y = y;
>     }
>     
>     public final void set(final int[] t) {
>         this.x = t[0];
>         this.y = t[1];
>     }
>     
>     public final void set(final Tuple2i t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>     }
>     
>     public final void get(final int[] t) {
>         t[0] = this.x;
>         t[1] = this.y;
>     }
>     
>     public final void get(final Tuple2i t) {
>         t.x = this.x;
>         t.y = this.y;
>     }
>     
>     public final void add(final Tuple2i t1, final Tuple2i t2) {
>         this.x = t1.x + t2.x;
>         this.y = t1.y + t2.y;
>     }
>     
>     public final void add(final Tuple2i t1) {
>         this.x += t1.x;
>         this.y += t1.y;
>     }
>     
>     public final void sub(final Tuple2i t1, final Tuple2i t2) {
>         this.x = t1.x - t2.x;
>         this.y = t1.y - t2.y;
>     }
>     
>     public final void sub(final Tuple2i t1) {
>         this.x -= t1.x;
>         this.y -= t1.y;
>     }
>     
>     public final void negate(final Tuple2i t1) {
>         this.x = -t1.x;
>         this.y = -t1.y;
>     }
>     
>     public final void negate() {
>         this.x = -this.x;
>         this.y = -this.y;
>     }
>     
>     public final void scale(final int s, final Tuple2i t1) {
>         this.x = s * t1.x;
>         this.y = s * t1.y;
>     }
>     
>     public final void scale(final int s) {
>         this.x *= s;
>         this.y *= s;
>     }
>     
>     public final void scaleAdd(final int s, final Tuple2i t1, final Tuple2i t2) {
>         this.x = s * t1.x + t2.x;
>         this.y = s * t1.y + t2.y;
>     }
>     
>     public final void scaleAdd(final int s, final Tuple2i t1) {
>         this.x = s * this.x + t1.x;
>         this.y = s * this.y + t1.y;
>     }
>     
>     @Override
>     public String toString() {
>         return "(" + this.x + ", " + this.y + ")";
>     }
>     
>     @Override
>     public boolean equals(final Object t1) {
>         try {
>             final Tuple2i t2 = (Tuple2i)t1;
>             return this.x == t2.x && this.y == t2.y;
>         }
>         catch (NullPointerException e2) {
>             return false;
>         }
>         catch (ClassCastException e3) {
>             return false;
>         }
>     }
>     
>     @Override
>     public int hashCode() {
>         long bits = 1L;
>         bits = 31L * bits + this.x;
>         bits = 31L * bits + this.y;
>         return (int)(bits ^ bits >> 32);
>     }
>     
>     public final void clamp(final int min, final int max, final Tuple2i t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>     }
>     
>     public final void clampMin(final int min, final Tuple2i t) {
>         if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>     }
>     
>     public final void clampMax(final int max, final Tuple2i t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else {
>             this.y = t.y;
>         }
>     }
>     
>     public final void absolute(final Tuple2i t) {
>         this.x = Math.abs(t.x);
>         this.y = Math.abs(t.y);
>     }
>     
>     public final void clamp(final int min, final int max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         else if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         else if (this.y < min) {
>             this.y = min;
>         }
>     }
>     
>     public final void clampMin(final int min) {
>         if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y < min) {
>             this.y = min;
>         }
>     }
>     
>     public final void clampMax(final int max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>     }
>     
>     public final void absolute() {
>         this.x = Math.abs(this.x);
>         this.y = Math.abs(this.y);
>     }
>     
>     public Object clone() {
>         try {
>             return super.clone();
>         }
>         catch (CloneNotSupportedException e) {
>             throw new InternalError();
>         }
>     }
>     
>     public final int getX() {
>         return this.x;
>     }
>     
>     public final void setX(final int x) {
>         this.x = x;
>     }
>     
>     public final int getY() {
>         return this.y;
>     }
>     
>     public final void setY(final int y) {
>         this.y = y;
>     }
diff -r TrackAnalyzer_/vecmath/Tuple3b.java procyon/vecmath/Tuple3b.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,116c9,128
< public abstract class Tuple3b implements Serializable, Cloneable {
<    static final long serialVersionUID = -483782685323607044L;
<    public byte x;
<    public byte y;
<    public byte z;
< 
<    public Tuple3b(byte b1, byte b2, byte b3) {
<       this.x = b1;
<       this.y = b2;
<       this.z = b3;
<    }
< 
<    public Tuple3b(byte[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public Tuple3b(Tuple3b t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public Tuple3b() {
<       this.x = 0;
<       this.y = 0;
<       this.z = 0;
<    }
< 
<    public String toString() {
<       return "(" + (this.x & 255) + ", " + (this.y & 255) + ", " + (this.z & 255) + ")";
<    }
< 
<    public final void get(byte[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<    }
< 
<    public final void get(Tuple3b t1) {
<       t1.x = this.x;
<       t1.y = this.y;
<       t1.z = this.z;
<    }
< 
<    public final void set(Tuple3b t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public final void set(byte[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public boolean equals(Tuple3b t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple3b t2 = (Tuple3b)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public int hashCode() {
<       return (this.x & 255) << 0 | (this.y & 255) << 8 | (this.z & 255) << 16;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final byte getX() {
<       return this.x;
<    }
< 
<    public final void setX(byte x) {
<       this.x = x;
<    }
< 
<    public final byte getY() {
<       return this.y;
<    }
< 
<    public final void setY(byte y) {
<       this.y = y;
<    }
< 
<    public final byte getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(byte z) {
<       this.z = z;
<    }
---
> public abstract class Tuple3b implements Serializable, Cloneable
> {
>     static final long serialVersionUID = -483782685323607044L;
>     public byte x;
>     public byte y;
>     public byte z;
>     
>     public Tuple3b(final byte b1, final byte b2, final byte b3) {
>         this.x = b1;
>         this.y = b2;
>         this.z = b3;
>     }
>     
>     public Tuple3b(final byte[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>     }
>     
>     public Tuple3b(final Tuple3b t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>     }
>     
>     public Tuple3b() {
>         this.x = 0;
>         this.y = 0;
>         this.z = 0;
>     }
>     
>     @Override
>     public String toString() {
>         return "(" + (this.x & 0xFF) + ", " + (this.y & 0xFF) + ", " + (this.z & 0xFF) + ")";
>     }
>     
>     public final void get(final byte[] t) {
>         t[0] = this.x;
>         t[1] = this.y;
>         t[2] = this.z;
>     }
>     
>     public final void get(final Tuple3b t1) {
>         t1.x = this.x;
>         t1.y = this.y;
>         t1.z = this.z;
>     }
>     
>     public final void set(final Tuple3b t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>     }
>     
>     public final void set(final byte[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>     }
>     
>     public boolean equals(final Tuple3b t1) {
>         try {
>             return this.x == t1.x && this.y == t1.y && this.z == t1.z;
>         }
>         catch (NullPointerException e2) {
>             return false;
>         }
>     }
>     
>     @Override
>     public boolean equals(final Object t1) {
>         try {
>             final Tuple3b t2 = (Tuple3b)t1;
>             return this.x == t2.x && this.y == t2.y && this.z == t2.z;
>         }
>         catch (NullPointerException e2) {
>             return false;
>         }
>         catch (ClassCastException e3) {
>             return false;
>         }
>     }
>     
>     @Override
>     public int hashCode() {
>         return (this.x & 0xFF) << 0 | (this.y & 0xFF) << 8 | (this.z & 0xFF) << 16;
>     }
>     
>     public Object clone() {
>         try {
>             return super.clone();
>         }
>         catch (CloneNotSupportedException e) {
>             throw new InternalError();
>         }
>     }
>     
>     public final byte getX() {
>         return this.x;
>     }
>     
>     public final void setX(final byte x) {
>         this.x = x;
>     }
>     
>     public final byte getY() {
>         return this.y;
>     }
>     
>     public final void setY(final byte y) {
>         this.y = y;
>     }
>     
>     public final byte getZ() {
>         return this.z;
>     }
>     
>     public final void setZ(final byte z) {
>         this.z = z;
>     }
diff -r TrackAnalyzer_/vecmath/Tuple3dModified.java procyon/vecmath/Tuple3dModified.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,181c9,165
< public class Tuple3dModified implements Serializable, Cloneable {
<    static final long serialVersionUID = 5542096614926168415L;
<    public double x;
<    public double y;
<    public double z;
< 
<    public Tuple3dModified(double x, double y, double z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public Tuple3dModified(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public Tuple3dModified(Tuple3dModified t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public Tuple3dModified(Tuple3f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<       this.z = (double)t1.z;
<    }
< 
<    public Tuple3dModified() {
<       this.x = 0.0D;
<       this.y = 0.0D;
<       this.z = 0.0D;
<    }
< 
<    public final void set(double x, double y, double z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public final void set(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public final void set(Tuple3dModified t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public final void set(Tuple3f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<       this.z = (double)t1.z;
<    }
< 
<    public final void get(double[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<    }
< 
<    public final void get(Tuple3dModified t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<    }
< 
<    public final void add(Tuple3dModified t1, Tuple3dModified t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<    }
< 
<    public final void add(Tuple3dModified t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<    }
< 
<    public final void sub(Tuple3dModified t1, Tuple3dModified t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<    }
< 
<    public final void sub(Tuple3dModified t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<    }
< 
<    public final void negate(Tuple3dModified t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<    }
< 
<    public final void scale(double s, Tuple3dModified t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<    }
< 
<    public final void scale(double s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<    }
< 
<    public final void scaleAdd(double s, Tuple3dModified t1, Tuple3dModified t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<    }
< 
<    /** @deprecated */
<    public final void scaleAdd(double s, Tuple3f t1) {
<       this.scaleAdd(s, (Tuple3dModified)(new Point3dModified(t1)));
<    }
< 
<    public final void scaleAdd(double s, Tuple3dModified t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ")";
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashDoubleBits(bits, this.x);
<       bits = VecMathUtil.hashDoubleBits(bits, this.y);
<       bits = VecMathUtil.hashDoubleBits(bits, this.z);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    public boolean equals(Tuple3dModified t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple3dModified t2 = (Tuple3dModified)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z;
<       } catch (ClassCastException var3) {
<          return false;
<       } catch (NullPointerException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple3dModified t1, double epsilon) {
<       double diff = this.x - t1.x;
<       if (Double.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Double.isNaN(diff)) {
---
> public class Tuple3dModified implements Serializable, Cloneable
> {
>     static final long serialVersionUID = 5542096614926168415L;
>     public double x;
>     public double y;
>     public double z;
>     
>     public Tuple3dModified(final double x, final double y, final double z) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>     }
>     
>     public Tuple3dModified(final double[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>     }
>     
>     public Tuple3dModified(final Tuple3dModified t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>     }
>     
>     public Tuple3dModified(final Tuple3f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>     }
>     
>     public Tuple3dModified() {
>         this.x = 0.0;
>         this.y = 0.0;
>         this.z = 0.0;
>     }
>     
>     public final void set(final double x, final double y, final double z) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>     }
>     
>     public final void set(final double[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>     }
>     
>     public final void set(final Tuple3dModified t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>     }
>     
>     public final void set(final Tuple3f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>     }
>     
>     public final void get(final double[] t) {
>         t[0] = this.x;
>         t[1] = this.y;
>         t[2] = this.z;
>     }
>     
>     public final void get(final Tuple3dModified t) {
>         t.x = this.x;
>         t.y = this.y;
>         t.z = this.z;
>     }
>     
>     public final void add(final Tuple3dModified t1, final Tuple3dModified t2) {
>         this.x = t1.x + t2.x;
>         this.y = t1.y + t2.y;
>         this.z = t1.z + t2.z;
>     }
>     
>     public final void add(final Tuple3dModified t1) {
>         this.x += t1.x;
>         this.y += t1.y;
>         this.z += t1.z;
>     }
>     
>     public final void sub(final Tuple3dModified t1, final Tuple3dModified t2) {
>         this.x = t1.x - t2.x;
>         this.y = t1.y - t2.y;
>         this.z = t1.z - t2.z;
>     }
>     
>     public final void sub(final Tuple3dModified t1) {
>         this.x -= t1.x;
>         this.y -= t1.y;
>         this.z -= t1.z;
>     }
>     
>     public final void negate(final Tuple3dModified t1) {
>         this.x = -t1.x;
>         this.y = -t1.y;
>         this.z = -t1.z;
>     }
>     
>     public final void negate() {
>         this.x = -this.x;
>         this.y = -this.y;
>         this.z = -this.z;
>     }
>     
>     public final void scale(final double s, final Tuple3dModified t1) {
>         this.x = s * t1.x;
>         this.y = s * t1.y;
>         this.z = s * t1.z;
>     }
>     
>     public final void scale(final double s) {
>         this.x *= s;
>         this.y *= s;
>         this.z *= s;
>     }
>     
>     public final void scaleAdd(final double s, final Tuple3dModified t1, final Tuple3dModified t2) {
>         this.x = s * t1.x + t2.x;
>         this.y = s * t1.y + t2.y;
>         this.z = s * t1.z + t2.z;
>     }
>     
>     @Deprecated
>     public final void scaleAdd(final double s, final Tuple3f t1) {
>         this.scaleAdd(s, new Point3dModified(t1));
>     }
>     
>     public final void scaleAdd(final double s, final Tuple3dModified t1) {
>         this.x = s * this.x + t1.x;
>         this.y = s * this.y + t1.y;
>         this.z = s * this.z + t1.z;
>     }
>     
>     @Override
>     public String toString() {
>         return "(" + this.x + ", " + this.y + ", " + this.z + ")";
>     }
>     
>     @Override
>     public int hashCode() {
>         long bits = 1L;
>         bits = VecMathUtil.hashDoubleBits(bits, this.x);
>         bits = VecMathUtil.hashDoubleBits(bits, this.y);
>         bits = VecMathUtil.hashDoubleBits(bits, this.z);
>         return VecMathUtil.hashFinish(bits);
>     }
>     
>     public boolean equals(final Tuple3dModified t1) {
>         try {
>             return this.x == t1.x && this.y == t1.y && this.z == t1.z;
>         }
>         catch (NullPointerException e2) {
183c167,176
<          } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
---
>         }
>     }
>     
>     @Override
>     public boolean equals(final Object t1) {
>         try {
>             final Tuple3dModified t2 = (Tuple3dModified)t1;
>             return this.x == t2.x && this.y == t2.y && this.z == t2.z;
>         }
>         catch (ClassCastException e1) {
185,410c178,415
<          } else {
<             diff = this.z - t1.z;
<             if (Double.isNaN(diff)) {
<                return false;
<             } else {
<                return !((diff < 0.0D ? -diff : diff) > epsilon);
<             }
<          }
<       }
<    }
< 
<    /** @deprecated */
<    public final void clamp(float min, float max, Tuple3dModified t) {
<       this.clamp((double)min, (double)max, t);
<    }
< 
<    public final void clamp(double min, double max, Tuple3dModified t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMin(float min, Tuple3dModified t) {
<       this.clampMin((double)min, t);
<    }
< 
<    public final void clampMin(double min, Tuple3dModified t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMax(float max, Tuple3dModified t) {
<       this.clampMax((double)max, t);
<    }
< 
<    public final void clampMax(double max, Tuple3dModified t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple3dModified t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<    }
< 
<    /** @deprecated */
<    public final void clamp(float min, float max) {
<       this.clamp((double)min, (double)max);
<    }
< 
<    public final void clamp(double min, double max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMin(float min) {
<       this.clampMin((double)min);
<    }
< 
<    public final void clampMin(double min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMax(float max) {
<       this.clampMax((double)max);
<    }
< 
<    public final void clampMax(double max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<    }
< 
<    /** @deprecated */
<    public final void interpolate(Tuple3dModified t1, Tuple3dModified t2, float alpha) {
<       this.interpolate(t1, t2, (double)alpha);
<    }
< 
<    public final void interpolate(Tuple3dModified t1, Tuple3dModified t2, double alpha) {
<       this.x = (1.0D - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0D - alpha) * t1.y + alpha * t2.y;
<       this.z = (1.0D - alpha) * t1.z + alpha * t2.z;
<    }
< 
<    /** @deprecated */
<    public final void interpolate(Tuple3dModified t1, float alpha) {
<       this.interpolate(t1, (double)alpha);
<    }
< 
<    public final void interpolate(Tuple3dModified t1, double alpha) {
<       this.x = (1.0D - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0D - alpha) * this.y + alpha * t1.y;
<       this.z = (1.0D - alpha) * this.z + alpha * t1.z;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final double getX() {
<       return this.x;
<    }
< 
<    public final void setX(double x) {
<       this.x = x;
<    }
< 
<    public final double getY() {
<       return this.y;
<    }
< 
<    public final void setY(double y) {
<       this.y = y;
<    }
< 
<    public final double getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(double z) {
<       this.z = z;
<    }
---
>         }
>         catch (NullPointerException e2) {
>             return false;
>         }
>     }
>     
>     public boolean epsilonEquals(final Tuple3dModified t1, final double epsilon) {
>         double diff = this.x - t1.x;
>         if (Double.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.y - t1.y;
>         if (Double.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.z - t1.z;
>         return !Double.isNaN(diff) && ((diff < 0.0) ? (-diff) : diff) <= epsilon;
>     }
>     
>     @Deprecated
>     public final void clamp(final float min, final float max, final Tuple3dModified t) {
>         this.clamp(min, (double)max, t);
>     }
>     
>     public final void clamp(final double min, final double max, final Tuple3dModified t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>     }
>     
>     @Deprecated
>     public final void clampMin(final float min, final Tuple3dModified t) {
>         this.clampMin((double)min, t);
>     }
>     
>     public final void clampMin(final double min, final Tuple3dModified t) {
>         if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>     }
>     
>     @Deprecated
>     public final void clampMax(final float max, final Tuple3dModified t) {
>         this.clampMax((double)max, t);
>     }
>     
>     public final void clampMax(final double max, final Tuple3dModified t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else {
>             this.z = t.z;
>         }
>     }
>     
>     public final void absolute(final Tuple3dModified t) {
>         this.x = Math.abs(t.x);
>         this.y = Math.abs(t.y);
>         this.z = Math.abs(t.z);
>     }
>     
>     @Deprecated
>     public final void clamp(final float min, final float max) {
>         this.clamp(min, (double)max);
>     }
>     
>     public final void clamp(final double min, final double max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         else if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         else if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>         else if (this.z < min) {
>             this.z = min;
>         }
>     }
>     
>     @Deprecated
>     public final void clampMin(final float min) {
>         this.clampMin((double)min);
>     }
>     
>     public final void clampMin(final double min) {
>         if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z < min) {
>             this.z = min;
>         }
>     }
>     
>     @Deprecated
>     public final void clampMax(final float max) {
>         this.clampMax((double)max);
>     }
>     
>     public final void clampMax(final double max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>     }
>     
>     public final void absolute() {
>         this.x = Math.abs(this.x);
>         this.y = Math.abs(this.y);
>         this.z = Math.abs(this.z);
>     }
>     
>     @Deprecated
>     public final void interpolate(final Tuple3dModified t1, final Tuple3dModified t2, final float alpha) {
>         this.interpolate(t1, t2, (double)alpha);
>     }
>     
>     public final void interpolate(final Tuple3dModified t1, final Tuple3dModified t2, final double alpha) {
>         this.x = (1.0 - alpha) * t1.x + alpha * t2.x;
>         this.y = (1.0 - alpha) * t1.y + alpha * t2.y;
>         this.z = (1.0 - alpha) * t1.z + alpha * t2.z;
>     }
>     
>     @Deprecated
>     public final void interpolate(final Tuple3dModified t1, final float alpha) {
>         this.interpolate(t1, (double)alpha);
>     }
>     
>     public final void interpolate(final Tuple3dModified t1, final double alpha) {
>         this.x = (1.0 - alpha) * this.x + alpha * t1.x;
>         this.y = (1.0 - alpha) * this.y + alpha * t1.y;
>         this.z = (1.0 - alpha) * this.z + alpha * t1.z;
>     }
>     
>     public Object clone() {
>         try {
>             return super.clone();
>         }
>         catch (CloneNotSupportedException e) {
>             throw new InternalError();
>         }
>     }
>     
>     public final double getX() {
>         return this.x;
>     }
>     
>     public final void setX(final double x) {
>         this.x = x;
>     }
>     
>     public final double getY() {
>         return this.y;
>     }
>     
>     public final void setY(final double y) {
>         this.y = y;
>     }
>     
>     public final double getZ() {
>         return this.z;
>     }
>     
>     public final void setZ(final double z) {
>         this.z = z;
>     }
diff -r TrackAnalyzer_/vecmath/Tuple3f.java procyon/vecmath/Tuple3f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,168c9,151
< public abstract class Tuple3f implements Serializable, Cloneable {
<    static final long serialVersionUID = 5019834619484343712L;
<    public float x;
<    public float y;
<    public float z;
< 
<    public Tuple3f(float x, float y, float z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public Tuple3f(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public Tuple3f(Tuple3f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public Tuple3f(Tuple3dModified t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<       this.z = (float)t1.z;
<    }
< 
<    public Tuple3f() {
<       this.x = 0.0F;
<       this.y = 0.0F;
<       this.z = 0.0F;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ")";
<    }
< 
<    public final void set(float x, float y, float z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public final void set(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public final void set(Tuple3f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public final void set(Tuple3dModified t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<       this.z = (float)t1.z;
<    }
< 
<    public final void get(float[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<    }
< 
<    public final void get(Tuple3f t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<    }
< 
<    public final void add(Tuple3f t1, Tuple3f t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<    }
< 
<    public final void add(Tuple3f t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<    }
< 
<    public final void sub(Tuple3f t1, Tuple3f t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<    }
< 
<    public final void sub(Tuple3f t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<    }
< 
<    public final void negate(Tuple3f t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<    }
< 
<    public final void scale(float s, Tuple3f t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<    }
< 
<    public final void scale(float s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<    }
< 
<    public final void scaleAdd(float s, Tuple3f t1, Tuple3f t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<    }
< 
<    public final void scaleAdd(float s, Tuple3f t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<    }
< 
<    public boolean equals(Tuple3f t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple3f t2 = (Tuple3f)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple3f t1, float epsilon) {
<       float diff = this.x - t1.x;
<       if (Float.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Float.isNaN(diff)) {
---
> public abstract class Tuple3f implements Serializable, Cloneable
> {
>     static final long serialVersionUID = 5019834619484343712L;
>     public float x;
>     public float y;
>     public float z;
>     
>     public Tuple3f(final float x, final float y, final float z) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>     }
>     
>     public Tuple3f(final float[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>     }
>     
>     public Tuple3f(final Tuple3f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>     }
>     
>     public Tuple3f(final Tuple3dModified t1) {
>         this.x = (float)t1.x;
>         this.y = (float)t1.y;
>         this.z = (float)t1.z;
>     }
>     
>     public Tuple3f() {
>         this.x = 0.0f;
>         this.y = 0.0f;
>         this.z = 0.0f;
>     }
>     
>     @Override
>     public String toString() {
>         return "(" + this.x + ", " + this.y + ", " + this.z + ")";
>     }
>     
>     public final void set(final float x, final float y, final float z) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>     }
>     
>     public final void set(final float[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>     }
>     
>     public final void set(final Tuple3f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>     }
>     
>     public final void set(final Tuple3dModified t1) {
>         this.x = (float)t1.x;
>         this.y = (float)t1.y;
>         this.z = (float)t1.z;
>     }
>     
>     public final void get(final float[] t) {
>         t[0] = this.x;
>         t[1] = this.y;
>         t[2] = this.z;
>     }
>     
>     public final void get(final Tuple3f t) {
>         t.x = this.x;
>         t.y = this.y;
>         t.z = this.z;
>     }
>     
>     public final void add(final Tuple3f t1, final Tuple3f t2) {
>         this.x = t1.x + t2.x;
>         this.y = t1.y + t2.y;
>         this.z = t1.z + t2.z;
>     }
>     
>     public final void add(final Tuple3f t1) {
>         this.x += t1.x;
>         this.y += t1.y;
>         this.z += t1.z;
>     }
>     
>     public final void sub(final Tuple3f t1, final Tuple3f t2) {
>         this.x = t1.x - t2.x;
>         this.y = t1.y - t2.y;
>         this.z = t1.z - t2.z;
>     }
>     
>     public final void sub(final Tuple3f t1) {
>         this.x -= t1.x;
>         this.y -= t1.y;
>         this.z -= t1.z;
>     }
>     
>     public final void negate(final Tuple3f t1) {
>         this.x = -t1.x;
>         this.y = -t1.y;
>         this.z = -t1.z;
>     }
>     
>     public final void negate() {
>         this.x = -this.x;
>         this.y = -this.y;
>         this.z = -this.z;
>     }
>     
>     public final void scale(final float s, final Tuple3f t1) {
>         this.x = s * t1.x;
>         this.y = s * t1.y;
>         this.z = s * t1.z;
>     }
>     
>     public final void scale(final float s) {
>         this.x *= s;
>         this.y *= s;
>         this.z *= s;
>     }
>     
>     public final void scaleAdd(final float s, final Tuple3f t1, final Tuple3f t2) {
>         this.x = s * t1.x + t2.x;
>         this.y = s * t1.y + t2.y;
>         this.z = s * t1.z + t2.z;
>     }
>     
>     public final void scaleAdd(final float s, final Tuple3f t1) {
>         this.x = s * this.x + t1.x;
>         this.y = s * this.y + t1.y;
>         this.z = s * this.z + t1.z;
>     }
>     
>     public boolean equals(final Tuple3f t1) {
>         try {
>             return this.x == t1.x && this.y == t1.y && this.z == t1.z;
>         }
>         catch (NullPointerException e2) {
170c153,162
<          } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
---
>         }
>     }
>     
>     @Override
>     public boolean equals(final Object t1) {
>         try {
>             final Tuple3f t2 = (Tuple3f)t1;
>             return this.x == t2.x && this.y == t2.y && this.z == t2.z;
>         }
>         catch (NullPointerException e2) {
172,365c164,370
<          } else {
<             diff = this.z - t1.z;
<             if (Float.isNaN(diff)) {
<                return false;
<             } else {
<                return !((diff < 0.0F ? -diff : diff) > epsilon);
<             }
<          }
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashFloatBits(bits, this.x);
<       bits = VecMathUtil.hashFloatBits(bits, this.y);
<       bits = VecMathUtil.hashFloatBits(bits, this.z);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    public final void clamp(float min, float max, Tuple3f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void clampMin(float min, Tuple3f t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void clampMax(float max, Tuple3f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple3f t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<    }
< 
<    public final void clamp(float min, float max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    public final void clampMin(float min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    public final void clampMax(float max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<    }
< 
<    public final void interpolate(Tuple3f t1, Tuple3f t2, float alpha) {
<       this.x = (1.0F - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0F - alpha) * t1.y + alpha * t2.y;
<       this.z = (1.0F - alpha) * t1.z + alpha * t2.z;
<    }
< 
<    public final void interpolate(Tuple3f t1, float alpha) {
<       this.x = (1.0F - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0F - alpha) * this.y + alpha * t1.y;
<       this.z = (1.0F - alpha) * this.z + alpha * t1.z;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final float getX() {
<       return this.x;
<    }
< 
<    public final void setX(float x) {
<       this.x = x;
<    }
< 
<    public final float getY() {
<       return this.y;
<    }
< 
<    public final void setY(float y) {
<       this.y = y;
<    }
< 
<    public final float getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(float z) {
<       this.z = z;
<    }
---
>         }
>         catch (ClassCastException e3) {
>             return false;
>         }
>     }
>     
>     public boolean epsilonEquals(final Tuple3f t1, final float epsilon) {
>         float diff = this.x - t1.x;
>         if (Float.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0f) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.y - t1.y;
>         if (Float.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0f) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.z - t1.z;
>         return !Float.isNaN(diff) && ((diff < 0.0f) ? (-diff) : diff) <= epsilon;
>     }
>     
>     @Override
>     public int hashCode() {
>         long bits = 1L;
>         bits = VecMathUtil.hashFloatBits(bits, this.x);
>         bits = VecMathUtil.hashFloatBits(bits, this.y);
>         bits = VecMathUtil.hashFloatBits(bits, this.z);
>         return VecMathUtil.hashFinish(bits);
>     }
>     
>     public final void clamp(final float min, final float max, final Tuple3f t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>     }
>     
>     public final void clampMin(final float min, final Tuple3f t) {
>         if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>     }
>     
>     public final void clampMax(final float max, final Tuple3f t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else {
>             this.z = t.z;
>         }
>     }
>     
>     public final void absolute(final Tuple3f t) {
>         this.x = Math.abs(t.x);
>         this.y = Math.abs(t.y);
>         this.z = Math.abs(t.z);
>     }
>     
>     public final void clamp(final float min, final float max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         else if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         else if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>         else if (this.z < min) {
>             this.z = min;
>         }
>     }
>     
>     public final void clampMin(final float min) {
>         if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z < min) {
>             this.z = min;
>         }
>     }
>     
>     public final void clampMax(final float max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>     }
>     
>     public final void absolute() {
>         this.x = Math.abs(this.x);
>         this.y = Math.abs(this.y);
>         this.z = Math.abs(this.z);
>     }
>     
>     public final void interpolate(final Tuple3f t1, final Tuple3f t2, final float alpha) {
>         this.x = (1.0f - alpha) * t1.x + alpha * t2.x;
>         this.y = (1.0f - alpha) * t1.y + alpha * t2.y;
>         this.z = (1.0f - alpha) * t1.z + alpha * t2.z;
>     }
>     
>     public final void interpolate(final Tuple3f t1, final float alpha) {
>         this.x = (1.0f - alpha) * this.x + alpha * t1.x;
>         this.y = (1.0f - alpha) * this.y + alpha * t1.y;
>         this.z = (1.0f - alpha) * this.z + alpha * t1.z;
>     }
>     
>     public Object clone() {
>         try {
>             return super.clone();
>         }
>         catch (CloneNotSupportedException e) {
>             throw new InternalError();
>         }
>     }
>     
>     public final float getX() {
>         return this.x;
>     }
>     
>     public final void setX(final float x) {
>         this.x = x;
>     }
>     
>     public final float getY() {
>         return this.y;
>     }
>     
>     public final void setY(final float y) {
>         this.y = y;
>     }
>     
>     public final float getZ() {
>         return this.z;
>     }
>     
>     public final void setZ(final float z) {
>         this.z = z;
>     }
diff -r TrackAnalyzer_/vecmath/Tuple3i.java procyon/vecmath/Tuple3i.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,310c9,318
< public abstract class Tuple3i implements Serializable, Cloneable {
<    static final long serialVersionUID = -732740491767276200L;
<    public int x;
<    public int y;
<    public int z;
< 
<    public Tuple3i(int x, int y, int z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public Tuple3i(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public Tuple3i(Tuple3i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public Tuple3i() {
<       this.x = 0;
<       this.y = 0;
<       this.z = 0;
<    }
< 
<    public final void set(int x, int y, int z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public final void set(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public final void set(Tuple3i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public final void get(int[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<    }
< 
<    public final void get(Tuple3i t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<    }
< 
<    public final void add(Tuple3i t1, Tuple3i t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<    }
< 
<    public final void add(Tuple3i t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<    }
< 
<    public final void sub(Tuple3i t1, Tuple3i t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<    }
< 
<    public final void sub(Tuple3i t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<    }
< 
<    public final void negate(Tuple3i t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<    }
< 
<    public final void scale(int s, Tuple3i t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<    }
< 
<    public final void scale(int s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<    }
< 
<    public final void scaleAdd(int s, Tuple3i t1, Tuple3i t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<    }
< 
<    public final void scaleAdd(int s, Tuple3i t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ")";
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple3i t2 = (Tuple3i)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = 31L * bits + (long)this.x;
<       bits = 31L * bits + (long)this.y;
<       bits = 31L * bits + (long)this.z;
<       return (int)(bits ^ bits >> 32);
<    }
< 
<    public final void clamp(int min, int max, Tuple3i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void clampMin(int min, Tuple3i t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void clampMax(int max, Tuple3i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple3i t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<    }
< 
<    public final void clamp(int min, int max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    public final void clampMin(int min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    public final void clampMax(int max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final int getX() {
<       return this.x;
<    }
< 
<    public final void setX(int x) {
<       this.x = x;
<    }
< 
<    public final int getY() {
<       return this.y;
<    }
< 
<    public final void setY(int y) {
<       this.y = y;
<    }
< 
<    public final int getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(int z) {
<       this.z = z;
<    }
---
> public abstract class Tuple3i implements Serializable, Cloneable
> {
>     static final long serialVersionUID = -732740491767276200L;
>     public int x;
>     public int y;
>     public int z;
>     
>     public Tuple3i(final int x, final int y, final int z) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>     }
>     
>     public Tuple3i(final int[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>     }
>     
>     public Tuple3i(final Tuple3i t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>     }
>     
>     public Tuple3i() {
>         this.x = 0;
>         this.y = 0;
>         this.z = 0;
>     }
>     
>     public final void set(final int x, final int y, final int z) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>     }
>     
>     public final void set(final int[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>     }
>     
>     public final void set(final Tuple3i t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>     }
>     
>     public final void get(final int[] t) {
>         t[0] = this.x;
>         t[1] = this.y;
>         t[2] = this.z;
>     }
>     
>     public final void get(final Tuple3i t) {
>         t.x = this.x;
>         t.y = this.y;
>         t.z = this.z;
>     }
>     
>     public final void add(final Tuple3i t1, final Tuple3i t2) {
>         this.x = t1.x + t2.x;
>         this.y = t1.y + t2.y;
>         this.z = t1.z + t2.z;
>     }
>     
>     public final void add(final Tuple3i t1) {
>         this.x += t1.x;
>         this.y += t1.y;
>         this.z += t1.z;
>     }
>     
>     public final void sub(final Tuple3i t1, final Tuple3i t2) {
>         this.x = t1.x - t2.x;
>         this.y = t1.y - t2.y;
>         this.z = t1.z - t2.z;
>     }
>     
>     public final void sub(final Tuple3i t1) {
>         this.x -= t1.x;
>         this.y -= t1.y;
>         this.z -= t1.z;
>     }
>     
>     public final void negate(final Tuple3i t1) {
>         this.x = -t1.x;
>         this.y = -t1.y;
>         this.z = -t1.z;
>     }
>     
>     public final void negate() {
>         this.x = -this.x;
>         this.y = -this.y;
>         this.z = -this.z;
>     }
>     
>     public final void scale(final int s, final Tuple3i t1) {
>         this.x = s * t1.x;
>         this.y = s * t1.y;
>         this.z = s * t1.z;
>     }
>     
>     public final void scale(final int s) {
>         this.x *= s;
>         this.y *= s;
>         this.z *= s;
>     }
>     
>     public final void scaleAdd(final int s, final Tuple3i t1, final Tuple3i t2) {
>         this.x = s * t1.x + t2.x;
>         this.y = s * t1.y + t2.y;
>         this.z = s * t1.z + t2.z;
>     }
>     
>     public final void scaleAdd(final int s, final Tuple3i t1) {
>         this.x = s * this.x + t1.x;
>         this.y = s * this.y + t1.y;
>         this.z = s * this.z + t1.z;
>     }
>     
>     @Override
>     public String toString() {
>         return "(" + this.x + ", " + this.y + ", " + this.z + ")";
>     }
>     
>     @Override
>     public boolean equals(final Object t1) {
>         try {
>             final Tuple3i t2 = (Tuple3i)t1;
>             return this.x == t2.x && this.y == t2.y && this.z == t2.z;
>         }
>         catch (NullPointerException e2) {
>             return false;
>         }
>         catch (ClassCastException e3) {
>             return false;
>         }
>     }
>     
>     @Override
>     public int hashCode() {
>         long bits = 1L;
>         bits = 31L * bits + this.x;
>         bits = 31L * bits + this.y;
>         bits = 31L * bits + this.z;
>         return (int)(bits ^ bits >> 32);
>     }
>     
>     public final void clamp(final int min, final int max, final Tuple3i t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>     }
>     
>     public final void clampMin(final int min, final Tuple3i t) {
>         if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>     }
>     
>     public final void clampMax(final int max, final Tuple3i t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else {
>             this.z = t.z;
>         }
>     }
>     
>     public final void absolute(final Tuple3i t) {
>         this.x = Math.abs(t.x);
>         this.y = Math.abs(t.y);
>         this.z = Math.abs(t.z);
>     }
>     
>     public final void clamp(final int min, final int max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         else if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         else if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>         else if (this.z < min) {
>             this.z = min;
>         }
>     }
>     
>     public final void clampMin(final int min) {
>         if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z < min) {
>             this.z = min;
>         }
>     }
>     
>     public final void clampMax(final int max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>     }
>     
>     public final void absolute() {
>         this.x = Math.abs(this.x);
>         this.y = Math.abs(this.y);
>         this.z = Math.abs(this.z);
>     }
>     
>     public Object clone() {
>         try {
>             return super.clone();
>         }
>         catch (CloneNotSupportedException e) {
>             throw new InternalError();
>         }
>     }
>     
>     public final int getX() {
>         return this.x;
>     }
>     
>     public final void setX(final int x) {
>         this.x = x;
>     }
>     
>     public final int getY() {
>         return this.y;
>     }
>     
>     public final void setY(final int y) {
>         this.y = y;
>     }
>     
>     public final int getZ() {
>         return this.z;
>     }
>     
>     public final void setZ(final int z) {
>         this.z = z;
>     }
diff -r TrackAnalyzer_/vecmath/Tuple4b.java procyon/vecmath/Tuple4b.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,133c9,145
< public abstract class Tuple4b implements Serializable, Cloneable {
<    static final long serialVersionUID = -8226727741811898211L;
<    public byte x;
<    public byte y;
<    public byte z;
<    public byte w;
< 
<    public Tuple4b(byte b1, byte b2, byte b3, byte b4) {
<       this.x = b1;
<       this.y = b2;
<       this.z = b3;
<       this.w = b4;
<    }
< 
<    public Tuple4b(byte[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public Tuple4b(Tuple4b t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public Tuple4b() {
<       this.x = 0;
<       this.y = 0;
<       this.z = 0;
<       this.w = 0;
<    }
< 
<    public String toString() {
<       return "(" + (this.x & 255) + ", " + (this.y & 255) + ", " + (this.z & 255) + ", " + (this.w & 255) + ")";
<    }
< 
<    public final void get(byte[] b) {
<       b[0] = this.x;
<       b[1] = this.y;
<       b[2] = this.z;
<       b[3] = this.w;
<    }
< 
<    public final void get(Tuple4b t1) {
<       t1.x = this.x;
<       t1.y = this.y;
<       t1.z = this.z;
<       t1.w = this.w;
<    }
< 
<    public final void set(Tuple4b t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public final void set(byte[] b) {
<       this.x = b[0];
<       this.y = b[1];
<       this.z = b[2];
<       this.w = b[3];
<    }
< 
<    public boolean equals(Tuple4b t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z && this.w == t1.w;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple4b t2 = (Tuple4b)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public int hashCode() {
<       return (this.x & 255) << 0 | (this.y & 255) << 8 | (this.z & 255) << 16 | (this.w & 255) << 24;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final byte getX() {
<       return this.x;
<    }
< 
<    public final void setX(byte x) {
<       this.x = x;
<    }
< 
<    public final byte getY() {
<       return this.y;
<    }
< 
<    public final void setY(byte y) {
<       this.y = y;
<    }
< 
<    public final byte getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(byte z) {
<       this.z = z;
<    }
< 
<    public final byte getW() {
<       return this.w;
<    }
< 
<    public final void setW(byte w) {
<       this.w = w;
<    }
---
> public abstract class Tuple4b implements Serializable, Cloneable
> {
>     static final long serialVersionUID = -8226727741811898211L;
>     public byte x;
>     public byte y;
>     public byte z;
>     public byte w;
>     
>     public Tuple4b(final byte b1, final byte b2, final byte b3, final byte b4) {
>         this.x = b1;
>         this.y = b2;
>         this.z = b3;
>         this.w = b4;
>     }
>     
>     public Tuple4b(final byte[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>         this.w = t[3];
>     }
>     
>     public Tuple4b(final Tuple4b t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = t1.w;
>     }
>     
>     public Tuple4b() {
>         this.x = 0;
>         this.y = 0;
>         this.z = 0;
>         this.w = 0;
>     }
>     
>     @Override
>     public String toString() {
>         return "(" + (this.x & 0xFF) + ", " + (this.y & 0xFF) + ", " + (this.z & 0xFF) + ", " + (this.w & 0xFF) + ")";
>     }
>     
>     public final void get(final byte[] b) {
>         b[0] = this.x;
>         b[1] = this.y;
>         b[2] = this.z;
>         b[3] = this.w;
>     }
>     
>     public final void get(final Tuple4b t1) {
>         t1.x = this.x;
>         t1.y = this.y;
>         t1.z = this.z;
>         t1.w = this.w;
>     }
>     
>     public final void set(final Tuple4b t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = t1.w;
>     }
>     
>     public final void set(final byte[] b) {
>         this.x = b[0];
>         this.y = b[1];
>         this.z = b[2];
>         this.w = b[3];
>     }
>     
>     public boolean equals(final Tuple4b t1) {
>         try {
>             return this.x == t1.x && this.y == t1.y && this.z == t1.z && this.w == t1.w;
>         }
>         catch (NullPointerException e2) {
>             return false;
>         }
>     }
>     
>     @Override
>     public boolean equals(final Object t1) {
>         try {
>             final Tuple4b t2 = (Tuple4b)t1;
>             return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
>         }
>         catch (NullPointerException e2) {
>             return false;
>         }
>         catch (ClassCastException e3) {
>             return false;
>         }
>     }
>     
>     @Override
>     public int hashCode() {
>         return (this.x & 0xFF) << 0 | (this.y & 0xFF) << 8 | (this.z & 0xFF) << 16 | (this.w & 0xFF) << 24;
>     }
>     
>     public Object clone() {
>         try {
>             return super.clone();
>         }
>         catch (CloneNotSupportedException e) {
>             throw new InternalError();
>         }
>     }
>     
>     public final byte getX() {
>         return this.x;
>     }
>     
>     public final void setX(final byte x) {
>         this.x = x;
>     }
>     
>     public final byte getY() {
>         return this.y;
>     }
>     
>     public final void setY(final byte y) {
>         this.y = y;
>     }
>     
>     public final byte getZ() {
>         return this.z;
>     }
>     
>     public final void setZ(final byte z) {
>         this.z = z;
>     }
>     
>     public final byte getW() {
>         return this.w;
>     }
>     
>     public final void setW(final byte w) {
>         this.w = w;
>     }
diff -r TrackAnalyzer_/vecmath/Tuple4d.java procyon/vecmath/Tuple4d.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,195c9,178
< public abstract class Tuple4d implements Serializable, Cloneable {
<    static final long serialVersionUID = -4748953690425311052L;
<    public double x;
<    public double y;
<    public double z;
<    public double w;
< 
<    public Tuple4d(double x, double y, double z, double w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public Tuple4d(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public Tuple4d(Tuple4d t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public Tuple4d(Tuple4f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<       this.z = (double)t1.z;
<       this.w = (double)t1.w;
<    }
< 
<    public Tuple4d() {
<       this.x = 0.0D;
<       this.y = 0.0D;
<       this.z = 0.0D;
<       this.w = 0.0D;
<    }
< 
<    public final void set(double x, double y, double z, double w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public final void set(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public final void set(Tuple4d t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public final void set(Tuple4f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<       this.z = (double)t1.z;
<       this.w = (double)t1.w;
<    }
< 
<    public final void get(double[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<       t[3] = this.w;
<    }
< 
<    public final void get(Tuple4d t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<       t.w = this.w;
<    }
< 
<    public final void add(Tuple4d t1, Tuple4d t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<       this.w = t1.w + t2.w;
<    }
< 
<    public final void add(Tuple4d t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<       this.w += t1.w;
<    }
< 
<    public final void sub(Tuple4d t1, Tuple4d t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<       this.w = t1.w - t2.w;
<    }
< 
<    public final void sub(Tuple4d t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<       this.w -= t1.w;
<    }
< 
<    public final void negate(Tuple4d t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<       this.w = -t1.w;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<       this.w = -this.w;
<    }
< 
<    public final void scale(double s, Tuple4d t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<       this.w = s * t1.w;
<    }
< 
<    public final void scale(double s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<       this.w *= s;
<    }
< 
<    public final void scaleAdd(double s, Tuple4d t1, Tuple4d t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<       this.w = s * t1.w + t2.w;
<    }
< 
<    /** @deprecated */
<    public final void scaleAdd(float s, Tuple4d t1) {
<       this.scaleAdd((double)s, t1);
<    }
< 
<    public final void scaleAdd(double s, Tuple4d t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<       this.w = s * this.w + t1.w;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
<    }
< 
<    public boolean equals(Tuple4d t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z && this.w == t1.w;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple4d t2 = (Tuple4d)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple4d t1, double epsilon) {
<       double diff = this.x - t1.x;
<       if (Double.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Double.isNaN(diff)) {
---
> public abstract class Tuple4d implements Serializable, Cloneable
> {
>     static final long serialVersionUID = -4748953690425311052L;
>     public double x;
>     public double y;
>     public double z;
>     public double w;
>     
>     public Tuple4d(final double x, final double y, final double z, final double w) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>         this.w = w;
>     }
>     
>     public Tuple4d(final double[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>         this.w = t[3];
>     }
>     
>     public Tuple4d(final Tuple4d t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = t1.w;
>     }
>     
>     public Tuple4d(final Tuple4f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = t1.w;
>     }
>     
>     public Tuple4d() {
>         this.x = 0.0;
>         this.y = 0.0;
>         this.z = 0.0;
>         this.w = 0.0;
>     }
>     
>     public final void set(final double x, final double y, final double z, final double w) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>         this.w = w;
>     }
>     
>     public final void set(final double[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>         this.w = t[3];
>     }
>     
>     public final void set(final Tuple4d t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = t1.w;
>     }
>     
>     public final void set(final Tuple4f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = t1.w;
>     }
>     
>     public final void get(final double[] t) {
>         t[0] = this.x;
>         t[1] = this.y;
>         t[2] = this.z;
>         t[3] = this.w;
>     }
>     
>     public final void get(final Tuple4d t) {
>         t.x = this.x;
>         t.y = this.y;
>         t.z = this.z;
>         t.w = this.w;
>     }
>     
>     public final void add(final Tuple4d t1, final Tuple4d t2) {
>         this.x = t1.x + t2.x;
>         this.y = t1.y + t2.y;
>         this.z = t1.z + t2.z;
>         this.w = t1.w + t2.w;
>     }
>     
>     public final void add(final Tuple4d t1) {
>         this.x += t1.x;
>         this.y += t1.y;
>         this.z += t1.z;
>         this.w += t1.w;
>     }
>     
>     public final void sub(final Tuple4d t1, final Tuple4d t2) {
>         this.x = t1.x - t2.x;
>         this.y = t1.y - t2.y;
>         this.z = t1.z - t2.z;
>         this.w = t1.w - t2.w;
>     }
>     
>     public final void sub(final Tuple4d t1) {
>         this.x -= t1.x;
>         this.y -= t1.y;
>         this.z -= t1.z;
>         this.w -= t1.w;
>     }
>     
>     public final void negate(final Tuple4d t1) {
>         this.x = -t1.x;
>         this.y = -t1.y;
>         this.z = -t1.z;
>         this.w = -t1.w;
>     }
>     
>     public final void negate() {
>         this.x = -this.x;
>         this.y = -this.y;
>         this.z = -this.z;
>         this.w = -this.w;
>     }
>     
>     public final void scale(final double s, final Tuple4d t1) {
>         this.x = s * t1.x;
>         this.y = s * t1.y;
>         this.z = s * t1.z;
>         this.w = s * t1.w;
>     }
>     
>     public final void scale(final double s) {
>         this.x *= s;
>         this.y *= s;
>         this.z *= s;
>         this.w *= s;
>     }
>     
>     public final void scaleAdd(final double s, final Tuple4d t1, final Tuple4d t2) {
>         this.x = s * t1.x + t2.x;
>         this.y = s * t1.y + t2.y;
>         this.z = s * t1.z + t2.z;
>         this.w = s * t1.w + t2.w;
>     }
>     
>     @Deprecated
>     public final void scaleAdd(final float s, final Tuple4d t1) {
>         this.scaleAdd((double)s, t1);
>     }
>     
>     public final void scaleAdd(final double s, final Tuple4d t1) {
>         this.x = s * this.x + t1.x;
>         this.y = s * this.y + t1.y;
>         this.z = s * this.z + t1.z;
>         this.w = s * this.w + t1.w;
>     }
>     
>     @Override
>     public String toString() {
>         return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
>     }
>     
>     public boolean equals(final Tuple4d t1) {
>         try {
>             return this.x == t1.x && this.y == t1.y && this.z == t1.z && this.w == t1.w;
>         }
>         catch (NullPointerException e2) {
197c180,189
<          } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
---
>         }
>     }
>     
>     @Override
>     public boolean equals(final Object t1) {
>         try {
>             final Tuple4d t2 = (Tuple4d)t1;
>             return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
>         }
>         catch (NullPointerException e2) {
199,486c191,490
<          } else {
<             diff = this.z - t1.z;
<             if (Double.isNaN(diff)) {
<                return false;
<             } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
<                return false;
<             } else {
<                diff = this.w - t1.w;
<                if (Double.isNaN(diff)) {
<                   return false;
<                } else {
<                   return !((diff < 0.0D ? -diff : diff) > epsilon);
<                }
<             }
<          }
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashDoubleBits(bits, this.x);
<       bits = VecMathUtil.hashDoubleBits(bits, this.y);
<       bits = VecMathUtil.hashDoubleBits(bits, this.z);
<       bits = VecMathUtil.hashDoubleBits(bits, this.w);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    /** @deprecated */
<    public final void clamp(float min, float max, Tuple4d t) {
<       this.clamp((double)min, (double)max, t);
<    }
< 
<    public final void clamp(double min, double max, Tuple4d t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMin(float min, Tuple4d t) {
<       this.clampMin((double)min, t);
<    }
< 
<    public final void clampMin(double min, Tuple4d t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMax(float max, Tuple4d t) {
<       this.clampMax((double)max, t);
<    }
< 
<    public final void clampMax(double max, Tuple4d t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else {
<          this.w = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple4d t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<       this.w = Math.abs(t.w);
<    }
< 
<    /** @deprecated */
<    public final void clamp(float min, float max) {
<       this.clamp((double)min, (double)max);
<    }
< 
<    public final void clamp(double min, double max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       } else if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMin(float min) {
<       this.clampMin((double)min);
<    }
< 
<    public final void clampMin(double min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMax(float max) {
<       this.clampMax((double)max);
<    }
< 
<    public final void clampMax(double max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<       this.w = Math.abs(this.w);
<    }
< 
<    /** @deprecated */
<    public void interpolate(Tuple4d t1, Tuple4d t2, float alpha) {
<       this.interpolate(t1, t2, (double)alpha);
<    }
< 
<    public void interpolate(Tuple4d t1, Tuple4d t2, double alpha) {
<       this.x = (1.0D - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0D - alpha) * t1.y + alpha * t2.y;
<       this.z = (1.0D - alpha) * t1.z + alpha * t2.z;
<       this.w = (1.0D - alpha) * t1.w + alpha * t2.w;
<    }
< 
<    /** @deprecated */
<    public void interpolate(Tuple4d t1, float alpha) {
<       this.interpolate(t1, (double)alpha);
<    }
< 
<    public void interpolate(Tuple4d t1, double alpha) {
<       this.x = (1.0D - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0D - alpha) * this.y + alpha * t1.y;
<       this.z = (1.0D - alpha) * this.z + alpha * t1.z;
<       this.w = (1.0D - alpha) * this.w + alpha * t1.w;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final double getX() {
<       return this.x;
<    }
< 
<    public final void setX(double x) {
<       this.x = x;
<    }
< 
<    public final double getY() {
<       return this.y;
<    }
< 
<    public final void setY(double y) {
<       this.y = y;
<    }
< 
<    public final double getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(double z) {
<       this.z = z;
<    }
< 
<    public final double getW() {
<       return this.w;
<    }
< 
<    public final void setW(double w) {
<       this.w = w;
<    }
---
>         }
>         catch (ClassCastException e3) {
>             return false;
>         }
>     }
>     
>     public boolean epsilonEquals(final Tuple4d t1, final double epsilon) {
>         double diff = this.x - t1.x;
>         if (Double.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.y - t1.y;
>         if (Double.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.z - t1.z;
>         if (Double.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.w - t1.w;
>         return !Double.isNaN(diff) && ((diff < 0.0) ? (-diff) : diff) <= epsilon;
>     }
>     
>     @Override
>     public int hashCode() {
>         long bits = 1L;
>         bits = VecMathUtil.hashDoubleBits(bits, this.x);
>         bits = VecMathUtil.hashDoubleBits(bits, this.y);
>         bits = VecMathUtil.hashDoubleBits(bits, this.z);
>         bits = VecMathUtil.hashDoubleBits(bits, this.w);
>         return VecMathUtil.hashFinish(bits);
>     }
>     
>     @Deprecated
>     public final void clamp(final float min, final float max, final Tuple4d t) {
>         this.clamp(min, (double)max, t);
>     }
>     
>     public final void clamp(final double min, final double max, final Tuple4d t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>         if (t.w > max) {
>             this.w = max;
>         }
>         else if (t.w < min) {
>             this.w = min;
>         }
>         else {
>             this.w = t.w;
>         }
>     }
>     
>     @Deprecated
>     public final void clampMin(final float min, final Tuple4d t) {
>         this.clampMin((double)min, t);
>     }
>     
>     public final void clampMin(final double min, final Tuple4d t) {
>         if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>         if (t.w < min) {
>             this.w = min;
>         }
>         else {
>             this.w = t.w;
>         }
>     }
>     
>     @Deprecated
>     public final void clampMax(final float max, final Tuple4d t) {
>         this.clampMax((double)max, t);
>     }
>     
>     public final void clampMax(final double max, final Tuple4d t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else {
>             this.z = t.z;
>         }
>         if (t.w > max) {
>             this.w = max;
>         }
>         else {
>             this.w = t.z;
>         }
>     }
>     
>     public final void absolute(final Tuple4d t) {
>         this.x = Math.abs(t.x);
>         this.y = Math.abs(t.y);
>         this.z = Math.abs(t.z);
>         this.w = Math.abs(t.w);
>     }
>     
>     @Deprecated
>     public final void clamp(final float min, final float max) {
>         this.clamp(min, (double)max);
>     }
>     
>     public final void clamp(final double min, final double max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         else if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         else if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>         else if (this.z < min) {
>             this.z = min;
>         }
>         if (this.w > max) {
>             this.w = max;
>         }
>         else if (this.w < min) {
>             this.w = min;
>         }
>     }
>     
>     @Deprecated
>     public final void clampMin(final float min) {
>         this.clampMin((double)min);
>     }
>     
>     public final void clampMin(final double min) {
>         if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z < min) {
>             this.z = min;
>         }
>         if (this.w < min) {
>             this.w = min;
>         }
>     }
>     
>     @Deprecated
>     public final void clampMax(final float max) {
>         this.clampMax((double)max);
>     }
>     
>     public final void clampMax(final double max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>         if (this.w > max) {
>             this.w = max;
>         }
>     }
>     
>     public final void absolute() {
>         this.x = Math.abs(this.x);
>         this.y = Math.abs(this.y);
>         this.z = Math.abs(this.z);
>         this.w = Math.abs(this.w);
>     }
>     
>     @Deprecated
>     public void interpolate(final Tuple4d t1, final Tuple4d t2, final float alpha) {
>         this.interpolate(t1, t2, (double)alpha);
>     }
>     
>     public void interpolate(final Tuple4d t1, final Tuple4d t2, final double alpha) {
>         this.x = (1.0 - alpha) * t1.x + alpha * t2.x;
>         this.y = (1.0 - alpha) * t1.y + alpha * t2.y;
>         this.z = (1.0 - alpha) * t1.z + alpha * t2.z;
>         this.w = (1.0 - alpha) * t1.w + alpha * t2.w;
>     }
>     
>     @Deprecated
>     public void interpolate(final Tuple4d t1, final float alpha) {
>         this.interpolate(t1, (double)alpha);
>     }
>     
>     public void interpolate(final Tuple4d t1, final double alpha) {
>         this.x = (1.0 - alpha) * this.x + alpha * t1.x;
>         this.y = (1.0 - alpha) * this.y + alpha * t1.y;
>         this.z = (1.0 - alpha) * this.z + alpha * t1.z;
>         this.w = (1.0 - alpha) * this.w + alpha * t1.w;
>     }
>     
>     public Object clone() {
>         try {
>             return super.clone();
>         }
>         catch (CloneNotSupportedException e) {
>             throw new InternalError();
>         }
>     }
>     
>     public final double getX() {
>         return this.x;
>     }
>     
>     public final void setX(final double x) {
>         this.x = x;
>     }
>     
>     public final double getY() {
>         return this.y;
>     }
>     
>     public final void setY(final double y) {
>         this.y = y;
>     }
>     
>     public final double getZ() {
>         return this.z;
>     }
>     
>     public final void setZ(final double z) {
>         this.z = z;
>     }
>     
>     public final double getW() {
>         return this.w;
>     }
>     
>     public final void setW(final double w) {
>         this.w = w;
>     }
diff -r TrackAnalyzer_/vecmath/Tuple4f.java procyon/vecmath/Tuple4f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,190c9,173
< public abstract class Tuple4f implements Serializable, Cloneable {
<    static final long serialVersionUID = 7068460319248845763L;
<    public float x;
<    public float y;
<    public float z;
<    public float w;
< 
<    public Tuple4f(float x, float y, float z, float w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public Tuple4f(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public Tuple4f(Tuple4f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public Tuple4f(Tuple4d t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<       this.z = (float)t1.z;
<       this.w = (float)t1.w;
<    }
< 
<    public Tuple4f() {
<       this.x = 0.0F;
<       this.y = 0.0F;
<       this.z = 0.0F;
<       this.w = 0.0F;
<    }
< 
<    public final void set(float x, float y, float z, float w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public final void set(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public final void set(Tuple4f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public final void set(Tuple4d t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<       this.z = (float)t1.z;
<       this.w = (float)t1.w;
<    }
< 
<    public final void get(float[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<       t[3] = this.w;
<    }
< 
<    public final void get(Tuple4f t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<       t.w = this.w;
<    }
< 
<    public final void add(Tuple4f t1, Tuple4f t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<       this.w = t1.w + t2.w;
<    }
< 
<    public final void add(Tuple4f t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<       this.w += t1.w;
<    }
< 
<    public final void sub(Tuple4f t1, Tuple4f t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<       this.w = t1.w - t2.w;
<    }
< 
<    public final void sub(Tuple4f t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<       this.w -= t1.w;
<    }
< 
<    public final void negate(Tuple4f t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<       this.w = -t1.w;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<       this.w = -this.w;
<    }
< 
<    public final void scale(float s, Tuple4f t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<       this.w = s * t1.w;
<    }
< 
<    public final void scale(float s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<       this.w *= s;
<    }
< 
<    public final void scaleAdd(float s, Tuple4f t1, Tuple4f t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<       this.w = s * t1.w + t2.w;
<    }
< 
<    public final void scaleAdd(float s, Tuple4f t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<       this.w = s * this.w + t1.w;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
<    }
< 
<    public boolean equals(Tuple4f t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z && this.w == t1.w;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple4f t2 = (Tuple4f)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple4f t1, float epsilon) {
<       float diff = this.x - t1.x;
<       if (Float.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Float.isNaN(diff)) {
---
> public abstract class Tuple4f implements Serializable, Cloneable
> {
>     static final long serialVersionUID = 7068460319248845763L;
>     public float x;
>     public float y;
>     public float z;
>     public float w;
>     
>     public Tuple4f(final float x, final float y, final float z, final float w) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>         this.w = w;
>     }
>     
>     public Tuple4f(final float[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>         this.w = t[3];
>     }
>     
>     public Tuple4f(final Tuple4f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = t1.w;
>     }
>     
>     public Tuple4f(final Tuple4d t1) {
>         this.x = (float)t1.x;
>         this.y = (float)t1.y;
>         this.z = (float)t1.z;
>         this.w = (float)t1.w;
>     }
>     
>     public Tuple4f() {
>         this.x = 0.0f;
>         this.y = 0.0f;
>         this.z = 0.0f;
>         this.w = 0.0f;
>     }
>     
>     public final void set(final float x, final float y, final float z, final float w) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>         this.w = w;
>     }
>     
>     public final void set(final float[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>         this.w = t[3];
>     }
>     
>     public final void set(final Tuple4f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = t1.w;
>     }
>     
>     public final void set(final Tuple4d t1) {
>         this.x = (float)t1.x;
>         this.y = (float)t1.y;
>         this.z = (float)t1.z;
>         this.w = (float)t1.w;
>     }
>     
>     public final void get(final float[] t) {
>         t[0] = this.x;
>         t[1] = this.y;
>         t[2] = this.z;
>         t[3] = this.w;
>     }
>     
>     public final void get(final Tuple4f t) {
>         t.x = this.x;
>         t.y = this.y;
>         t.z = this.z;
>         t.w = this.w;
>     }
>     
>     public final void add(final Tuple4f t1, final Tuple4f t2) {
>         this.x = t1.x + t2.x;
>         this.y = t1.y + t2.y;
>         this.z = t1.z + t2.z;
>         this.w = t1.w + t2.w;
>     }
>     
>     public final void add(final Tuple4f t1) {
>         this.x += t1.x;
>         this.y += t1.y;
>         this.z += t1.z;
>         this.w += t1.w;
>     }
>     
>     public final void sub(final Tuple4f t1, final Tuple4f t2) {
>         this.x = t1.x - t2.x;
>         this.y = t1.y - t2.y;
>         this.z = t1.z - t2.z;
>         this.w = t1.w - t2.w;
>     }
>     
>     public final void sub(final Tuple4f t1) {
>         this.x -= t1.x;
>         this.y -= t1.y;
>         this.z -= t1.z;
>         this.w -= t1.w;
>     }
>     
>     public final void negate(final Tuple4f t1) {
>         this.x = -t1.x;
>         this.y = -t1.y;
>         this.z = -t1.z;
>         this.w = -t1.w;
>     }
>     
>     public final void negate() {
>         this.x = -this.x;
>         this.y = -this.y;
>         this.z = -this.z;
>         this.w = -this.w;
>     }
>     
>     public final void scale(final float s, final Tuple4f t1) {
>         this.x = s * t1.x;
>         this.y = s * t1.y;
>         this.z = s * t1.z;
>         this.w = s * t1.w;
>     }
>     
>     public final void scale(final float s) {
>         this.x *= s;
>         this.y *= s;
>         this.z *= s;
>         this.w *= s;
>     }
>     
>     public final void scaleAdd(final float s, final Tuple4f t1, final Tuple4f t2) {
>         this.x = s * t1.x + t2.x;
>         this.y = s * t1.y + t2.y;
>         this.z = s * t1.z + t2.z;
>         this.w = s * t1.w + t2.w;
>     }
>     
>     public final void scaleAdd(final float s, final Tuple4f t1) {
>         this.x = s * this.x + t1.x;
>         this.y = s * this.y + t1.y;
>         this.z = s * this.z + t1.z;
>         this.w = s * this.w + t1.w;
>     }
>     
>     @Override
>     public String toString() {
>         return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
>     }
>     
>     public boolean equals(final Tuple4f t1) {
>         try {
>             return this.x == t1.x && this.y == t1.y && this.z == t1.z && this.w == t1.w;
>         }
>         catch (NullPointerException e2) {
192c175,184
<          } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
---
>         }
>     }
>     
>     @Override
>     public boolean equals(final Object t1) {
>         try {
>             final Tuple4f t2 = (Tuple4f)t1;
>             return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
>         }
>         catch (NullPointerException e2) {
194,441c186,445
<          } else {
<             diff = this.z - t1.z;
<             if (Float.isNaN(diff)) {
<                return false;
<             } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
<                return false;
<             } else {
<                diff = this.w - t1.w;
<                if (Float.isNaN(diff)) {
<                   return false;
<                } else {
<                   return !((diff < 0.0F ? -diff : diff) > epsilon);
<                }
<             }
<          }
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashFloatBits(bits, this.x);
<       bits = VecMathUtil.hashFloatBits(bits, this.y);
<       bits = VecMathUtil.hashFloatBits(bits, this.z);
<       bits = VecMathUtil.hashFloatBits(bits, this.w);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    public final void clamp(float min, float max, Tuple4f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    public final void clampMin(float min, Tuple4f t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    public final void clampMax(float max, Tuple4f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else {
<          this.w = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple4f t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<       this.w = Math.abs(t.w);
<    }
< 
<    public final void clamp(float min, float max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       } else if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    public final void clampMin(float min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    public final void clampMax(float max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<       this.w = Math.abs(this.w);
<    }
< 
<    public void interpolate(Tuple4f t1, Tuple4f t2, float alpha) {
<       this.x = (1.0F - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0F - alpha) * t1.y + alpha * t2.y;
<       this.z = (1.0F - alpha) * t1.z + alpha * t2.z;
<       this.w = (1.0F - alpha) * t1.w + alpha * t2.w;
<    }
< 
<    public void interpolate(Tuple4f t1, float alpha) {
<       this.x = (1.0F - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0F - alpha) * this.y + alpha * t1.y;
<       this.z = (1.0F - alpha) * this.z + alpha * t1.z;
<       this.w = (1.0F - alpha) * this.w + alpha * t1.w;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final float getX() {
<       return this.x;
<    }
< 
<    public final void setX(float x) {
<       this.x = x;
<    }
< 
<    public final float getY() {
<       return this.y;
<    }
< 
<    public final void setY(float y) {
<       this.y = y;
<    }
< 
<    public final float getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(float z) {
<       this.z = z;
<    }
< 
<    public final float getW() {
<       return this.w;
<    }
< 
<    public final void setW(float w) {
<       this.w = w;
<    }
---
>         }
>         catch (ClassCastException e3) {
>             return false;
>         }
>     }
>     
>     public boolean epsilonEquals(final Tuple4f t1, final float epsilon) {
>         float diff = this.x - t1.x;
>         if (Float.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0f) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.y - t1.y;
>         if (Float.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0f) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.z - t1.z;
>         if (Float.isNaN(diff)) {
>             return false;
>         }
>         if (((diff < 0.0f) ? (-diff) : diff) > epsilon) {
>             return false;
>         }
>         diff = this.w - t1.w;
>         return !Float.isNaN(diff) && ((diff < 0.0f) ? (-diff) : diff) <= epsilon;
>     }
>     
>     @Override
>     public int hashCode() {
>         long bits = 1L;
>         bits = VecMathUtil.hashFloatBits(bits, this.x);
>         bits = VecMathUtil.hashFloatBits(bits, this.y);
>         bits = VecMathUtil.hashFloatBits(bits, this.z);
>         bits = VecMathUtil.hashFloatBits(bits, this.w);
>         return VecMathUtil.hashFinish(bits);
>     }
>     
>     public final void clamp(final float min, final float max, final Tuple4f t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>         if (t.w > max) {
>             this.w = max;
>         }
>         else if (t.w < min) {
>             this.w = min;
>         }
>         else {
>             this.w = t.w;
>         }
>     }
>     
>     public final void clampMin(final float min, final Tuple4f t) {
>         if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>         if (t.w < min) {
>             this.w = min;
>         }
>         else {
>             this.w = t.w;
>         }
>     }
>     
>     public final void clampMax(final float max, final Tuple4f t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else {
>             this.z = t.z;
>         }
>         if (t.w > max) {
>             this.w = max;
>         }
>         else {
>             this.w = t.z;
>         }
>     }
>     
>     public final void absolute(final Tuple4f t) {
>         this.x = Math.abs(t.x);
>         this.y = Math.abs(t.y);
>         this.z = Math.abs(t.z);
>         this.w = Math.abs(t.w);
>     }
>     
>     public final void clamp(final float min, final float max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         else if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         else if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>         else if (this.z < min) {
>             this.z = min;
>         }
>         if (this.w > max) {
>             this.w = max;
>         }
>         else if (this.w < min) {
>             this.w = min;
>         }
>     }
>     
>     public final void clampMin(final float min) {
>         if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z < min) {
>             this.z = min;
>         }
>         if (this.w < min) {
>             this.w = min;
>         }
>     }
>     
>     public final void clampMax(final float max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>         if (this.w > max) {
>             this.w = max;
>         }
>     }
>     
>     public final void absolute() {
>         this.x = Math.abs(this.x);
>         this.y = Math.abs(this.y);
>         this.z = Math.abs(this.z);
>         this.w = Math.abs(this.w);
>     }
>     
>     public void interpolate(final Tuple4f t1, final Tuple4f t2, final float alpha) {
>         this.x = (1.0f - alpha) * t1.x + alpha * t2.x;
>         this.y = (1.0f - alpha) * t1.y + alpha * t2.y;
>         this.z = (1.0f - alpha) * t1.z + alpha * t2.z;
>         this.w = (1.0f - alpha) * t1.w + alpha * t2.w;
>     }
>     
>     public void interpolate(final Tuple4f t1, final float alpha) {
>         this.x = (1.0f - alpha) * this.x + alpha * t1.x;
>         this.y = (1.0f - alpha) * this.y + alpha * t1.y;
>         this.z = (1.0f - alpha) * this.z + alpha * t1.z;
>         this.w = (1.0f - alpha) * this.w + alpha * t1.w;
>     }
>     
>     public Object clone() {
>         try {
>             return super.clone();
>         }
>         catch (CloneNotSupportedException e) {
>             throw new InternalError();
>         }
>     }
>     
>     public final float getX() {
>         return this.x;
>     }
>     
>     public final void setX(final float x) {
>         this.x = x;
>     }
>     
>     public final float getY() {
>         return this.y;
>     }
>     
>     public final void setY(final float y) {
>         this.y = y;
>     }
>     
>     public final float getZ() {
>         return this.z;
>     }
>     
>     public final void setZ(final float z) {
>         this.z = z;
>     }
>     
>     public final float getW() {
>         return this.w;
>     }
>     
>     public final void setW(final float w) {
>         this.w = w;
>     }
diff -r TrackAnalyzer_/vecmath/Tuple4i.java procyon/vecmath/Tuple4i.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,375c9,382
< public abstract class Tuple4i implements Serializable, Cloneable {
<    static final long serialVersionUID = 8064614250942616720L;
<    public int x;
<    public int y;
<    public int z;
<    public int w;
< 
<    public Tuple4i(int x, int y, int z, int w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public Tuple4i(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public Tuple4i(Tuple4i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public Tuple4i() {
<       this.x = 0;
<       this.y = 0;
<       this.z = 0;
<       this.w = 0;
<    }
< 
<    public final void set(int x, int y, int z, int w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public final void set(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public final void set(Tuple4i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public final void get(int[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<       t[3] = this.w;
<    }
< 
<    public final void get(Tuple4i t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<       t.w = this.w;
<    }
< 
<    public final void add(Tuple4i t1, Tuple4i t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<       this.w = t1.w + t2.w;
<    }
< 
<    public final void add(Tuple4i t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<       this.w += t1.w;
<    }
< 
<    public final void sub(Tuple4i t1, Tuple4i t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<       this.w = t1.w - t2.w;
<    }
< 
<    public final void sub(Tuple4i t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<       this.w -= t1.w;
<    }
< 
<    public final void negate(Tuple4i t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<       this.w = -t1.w;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<       this.w = -this.w;
<    }
< 
<    public final void scale(int s, Tuple4i t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<       this.w = s * t1.w;
<    }
< 
<    public final void scale(int s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<       this.w *= s;
<    }
< 
<    public final void scaleAdd(int s, Tuple4i t1, Tuple4i t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<       this.w = s * t1.w + t2.w;
<    }
< 
<    public final void scaleAdd(int s, Tuple4i t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<       this.w = s * this.w + t1.w;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple4i t2 = (Tuple4i)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = 31L * bits + (long)this.x;
<       bits = 31L * bits + (long)this.y;
<       bits = 31L * bits + (long)this.z;
<       bits = 31L * bits + (long)this.w;
<       return (int)(bits ^ bits >> 32);
<    }
< 
<    public final void clamp(int min, int max, Tuple4i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    public final void clampMin(int min, Tuple4i t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    public final void clampMax(int max, Tuple4i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else {
<          this.w = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple4i t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<       this.w = Math.abs(t.w);
<    }
< 
<    public final void clamp(int min, int max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       } else if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    public final void clampMin(int min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    public final void clampMax(int max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<       this.w = Math.abs(this.w);
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final int getX() {
<       return this.x;
<    }
< 
<    public final void setX(int x) {
<       this.x = x;
<    }
< 
<    public final int getY() {
<       return this.y;
<    }
< 
<    public final void setY(int y) {
<       this.y = y;
<    }
< 
<    public final int getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(int z) {
<       this.z = z;
<    }
< 
<    public final int getW() {
<       return this.w;
<    }
< 
<    public final void setW(int w) {
<       this.w = w;
<    }
---
> public abstract class Tuple4i implements Serializable, Cloneable
> {
>     static final long serialVersionUID = 8064614250942616720L;
>     public int x;
>     public int y;
>     public int z;
>     public int w;
>     
>     public Tuple4i(final int x, final int y, final int z, final int w) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>         this.w = w;
>     }
>     
>     public Tuple4i(final int[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>         this.w = t[3];
>     }
>     
>     public Tuple4i(final Tuple4i t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = t1.w;
>     }
>     
>     public Tuple4i() {
>         this.x = 0;
>         this.y = 0;
>         this.z = 0;
>         this.w = 0;
>     }
>     
>     public final void set(final int x, final int y, final int z, final int w) {
>         this.x = x;
>         this.y = y;
>         this.z = z;
>         this.w = w;
>     }
>     
>     public final void set(final int[] t) {
>         this.x = t[0];
>         this.y = t[1];
>         this.z = t[2];
>         this.w = t[3];
>     }
>     
>     public final void set(final Tuple4i t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = t1.w;
>     }
>     
>     public final void get(final int[] t) {
>         t[0] = this.x;
>         t[1] = this.y;
>         t[2] = this.z;
>         t[3] = this.w;
>     }
>     
>     public final void get(final Tuple4i t) {
>         t.x = this.x;
>         t.y = this.y;
>         t.z = this.z;
>         t.w = this.w;
>     }
>     
>     public final void add(final Tuple4i t1, final Tuple4i t2) {
>         this.x = t1.x + t2.x;
>         this.y = t1.y + t2.y;
>         this.z = t1.z + t2.z;
>         this.w = t1.w + t2.w;
>     }
>     
>     public final void add(final Tuple4i t1) {
>         this.x += t1.x;
>         this.y += t1.y;
>         this.z += t1.z;
>         this.w += t1.w;
>     }
>     
>     public final void sub(final Tuple4i t1, final Tuple4i t2) {
>         this.x = t1.x - t2.x;
>         this.y = t1.y - t2.y;
>         this.z = t1.z - t2.z;
>         this.w = t1.w - t2.w;
>     }
>     
>     public final void sub(final Tuple4i t1) {
>         this.x -= t1.x;
>         this.y -= t1.y;
>         this.z -= t1.z;
>         this.w -= t1.w;
>     }
>     
>     public final void negate(final Tuple4i t1) {
>         this.x = -t1.x;
>         this.y = -t1.y;
>         this.z = -t1.z;
>         this.w = -t1.w;
>     }
>     
>     public final void negate() {
>         this.x = -this.x;
>         this.y = -this.y;
>         this.z = -this.z;
>         this.w = -this.w;
>     }
>     
>     public final void scale(final int s, final Tuple4i t1) {
>         this.x = s * t1.x;
>         this.y = s * t1.y;
>         this.z = s * t1.z;
>         this.w = s * t1.w;
>     }
>     
>     public final void scale(final int s) {
>         this.x *= s;
>         this.y *= s;
>         this.z *= s;
>         this.w *= s;
>     }
>     
>     public final void scaleAdd(final int s, final Tuple4i t1, final Tuple4i t2) {
>         this.x = s * t1.x + t2.x;
>         this.y = s * t1.y + t2.y;
>         this.z = s * t1.z + t2.z;
>         this.w = s * t1.w + t2.w;
>     }
>     
>     public final void scaleAdd(final int s, final Tuple4i t1) {
>         this.x = s * this.x + t1.x;
>         this.y = s * this.y + t1.y;
>         this.z = s * this.z + t1.z;
>         this.w = s * this.w + t1.w;
>     }
>     
>     @Override
>     public String toString() {
>         return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
>     }
>     
>     @Override
>     public boolean equals(final Object t1) {
>         try {
>             final Tuple4i t2 = (Tuple4i)t1;
>             return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
>         }
>         catch (NullPointerException e2) {
>             return false;
>         }
>         catch (ClassCastException e3) {
>             return false;
>         }
>     }
>     
>     @Override
>     public int hashCode() {
>         long bits = 1L;
>         bits = 31L * bits + this.x;
>         bits = 31L * bits + this.y;
>         bits = 31L * bits + this.z;
>         bits = 31L * bits + this.w;
>         return (int)(bits ^ bits >> 32);
>     }
>     
>     public final void clamp(final int min, final int max, final Tuple4i t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>         if (t.w > max) {
>             this.w = max;
>         }
>         else if (t.w < min) {
>             this.w = min;
>         }
>         else {
>             this.w = t.w;
>         }
>     }
>     
>     public final void clampMin(final int min, final Tuple4i t) {
>         if (t.x < min) {
>             this.x = min;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y < min) {
>             this.y = min;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z < min) {
>             this.z = min;
>         }
>         else {
>             this.z = t.z;
>         }
>         if (t.w < min) {
>             this.w = min;
>         }
>         else {
>             this.w = t.w;
>         }
>     }
>     
>     public final void clampMax(final int max, final Tuple4i t) {
>         if (t.x > max) {
>             this.x = max;
>         }
>         else {
>             this.x = t.x;
>         }
>         if (t.y > max) {
>             this.y = max;
>         }
>         else {
>             this.y = t.y;
>         }
>         if (t.z > max) {
>             this.z = max;
>         }
>         else {
>             this.z = t.z;
>         }
>         if (t.w > max) {
>             this.w = max;
>         }
>         else {
>             this.w = t.z;
>         }
>     }
>     
>     public final void absolute(final Tuple4i t) {
>         this.x = Math.abs(t.x);
>         this.y = Math.abs(t.y);
>         this.z = Math.abs(t.z);
>         this.w = Math.abs(t.w);
>     }
>     
>     public final void clamp(final int min, final int max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         else if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         else if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>         else if (this.z < min) {
>             this.z = min;
>         }
>         if (this.w > max) {
>             this.w = max;
>         }
>         else if (this.w < min) {
>             this.w = min;
>         }
>     }
>     
>     public final void clampMin(final int min) {
>         if (this.x < min) {
>             this.x = min;
>         }
>         if (this.y < min) {
>             this.y = min;
>         }
>         if (this.z < min) {
>             this.z = min;
>         }
>         if (this.w < min) {
>             this.w = min;
>         }
>     }
>     
>     public final void clampMax(final int max) {
>         if (this.x > max) {
>             this.x = max;
>         }
>         if (this.y > max) {
>             this.y = max;
>         }
>         if (this.z > max) {
>             this.z = max;
>         }
>         if (this.w > max) {
>             this.w = max;
>         }
>     }
>     
>     public final void absolute() {
>         this.x = Math.abs(this.x);
>         this.y = Math.abs(this.y);
>         this.z = Math.abs(this.z);
>         this.w = Math.abs(this.w);
>     }
>     
>     public Object clone() {
>         try {
>             return super.clone();
>         }
>         catch (CloneNotSupportedException e) {
>             throw new InternalError();
>         }
>     }
>     
>     public final int getX() {
>         return this.x;
>     }
>     
>     public final void setX(final int x) {
>         this.x = x;
>     }
>     
>     public final int getY() {
>         return this.y;
>     }
>     
>     public final void setY(final int y) {
>         this.y = y;
>     }
>     
>     public final int getZ() {
>         return this.z;
>     }
>     
>     public final void setZ(final int z) {
>         this.z = z;
>     }
>     
>     public final int getW() {
>         return this.w;
>     }
>     
>     public final void setW(final int w) {
>         this.w = w;
>     }
diff -r TrackAnalyzer_/vecmath/VecMathI18N.java procyon/vecmath/VecMathI18N.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
6,17c10,22
< class VecMathI18N {
<    static String getString(String key) {
<       String s;
<       try {
<          s = ResourceBundle.getBundle("org.scijava.vecmath.ExceptionStrings").getString(key);
<       } catch (MissingResourceException var3) {
<          System.err.println("VecMathI18N: Error looking up: " + key);
<          s = key;
<       }
< 
<       return s;
<    }
---
> class VecMathI18N
> {
>     static String getString(final String key) {
>         String s;
>         try {
>             s = ResourceBundle.getBundle("org.scijava.vecmath.ExceptionStrings").getString(key);
>         }
>         catch (MissingResourceException e) {
>             System.err.println("VecMathI18N: Error looking up: " + key);
>             s = key;
>         }
>         return s;
>     }
diff -r TrackAnalyzer_/vecmath/VecMathUtil.java procyon/vecmath/VecMathUtil.java
1,10c1,3
< package vecmath;
< 
< class VecMathUtil {
<    private VecMathUtil() {
<    }
< 
<    static final long hashLongBits(long hash, long l) {
<       hash *= 31L;
<       return hash + l;
<    }
---
> // 
> // Decompiled by Procyon v0.5.36
> // 
12,20c5
<    static final long hashFloatBits(long hash, float f) {
<       hash *= 31L;
<       return f == 0.0F ? hash : hash + (long)Float.floatToIntBits(f);
<    }
< 
<    static final long hashDoubleBits(long hash, double d) {
<       hash *= 31L;
<       return d == 0.0D ? hash : hash + Double.doubleToLongBits(d);
<    }
---
> package vecmath;
22,24c7,35
<    static final int hashFinish(long hash) {
<       return (int)(hash ^ hash >> 32);
<    }
---
> class VecMathUtil
> {
>     private VecMathUtil() {
>     }
>     
>     static final long hashLongBits(long hash, final long l) {
>         hash *= 31L;
>         return hash + l;
>     }
>     
>     static final long hashFloatBits(long hash, final float f) {
>         hash *= 31L;
>         if (f == 0.0f) {
>             return hash;
>         }
>         return hash + Float.floatToIntBits(f);
>     }
>     
>     static final long hashDoubleBits(long hash, final double d) {
>         hash *= 31L;
>         if (d == 0.0) {
>             return hash;
>         }
>         return hash + Double.doubleToLongBits(d);
>     }
>     
>     static final int hashFinish(final long hash) {
>         return (int)(hash ^ hash >> 32);
>     }
diff -r TrackAnalyzer_/vecmath/Vector2d.java procyon/vecmath/Vector2d.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,70c9,73
< public class Vector2d extends Tuple2d implements Serializable {
<    static final long serialVersionUID = 8572646365302599857L;
< 
<    public Vector2d(double x, double y) {
<       super(x, y);
<    }
< 
<    public Vector2d(double[] v) {
<       super(v);
<    }
< 
<    public Vector2d(Vector2d v1) {
<       super((Tuple2d)v1);
<    }
< 
<    public Vector2d(Vector2f v1) {
<       super((Tuple2f)v1);
<    }
< 
<    public Vector2d(Tuple2d t1) {
<       super(t1);
<    }
< 
<    public Vector2d(Tuple2f t1) {
<       super(t1);
<    }
< 
<    public Vector2d() {
<    }
< 
<    public final double dot(Vector2d v1) {
<       return this.x * v1.x + this.y * v1.y;
<    }
< 
<    public final double length() {
<       return Math.sqrt(this.x * this.x + this.y * this.y);
<    }
< 
<    public final double lengthSquared() {
<       return this.x * this.x + this.y * this.y;
<    }
< 
<    public final void normalize(Vector2d v1) {
<       double norm = 1.0D / Math.sqrt(v1.x * v1.x + v1.y * v1.y);
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<    }
< 
<    public final void normalize() {
<       double norm = 1.0D / Math.sqrt(this.x * this.x + this.y * this.y);
<       this.x *= norm;
<       this.y *= norm;
<    }
< 
<    public final double angle(Vector2d v1) {
<       double vDot = this.dot(v1) / (this.length() * v1.length());
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return Math.acos(vDot);
<    }
---
> public class Vector2d extends Tuple2d implements Serializable
> {
>     static final long serialVersionUID = 8572646365302599857L;
>     
>     public Vector2d(final double x, final double y) {
>         super(x, y);
>     }
>     
>     public Vector2d(final double[] v) {
>         super(v);
>     }
>     
>     public Vector2d(final Vector2d v1) {
>         super(v1);
>     }
>     
>     public Vector2d(final Vector2f v1) {
>         super(v1);
>     }
>     
>     public Vector2d(final Tuple2d t1) {
>         super(t1);
>     }
>     
>     public Vector2d(final Tuple2f t1) {
>         super(t1);
>     }
>     
>     public Vector2d() {
>     }
>     
>     public final double dot(final Vector2d v1) {
>         return this.x * v1.x + this.y * v1.y;
>     }
>     
>     public final double length() {
>         return Math.sqrt(this.x * this.x + this.y * this.y);
>     }
>     
>     public final double lengthSquared() {
>         return this.x * this.x + this.y * this.y;
>     }
>     
>     public final void normalize(final Vector2d v1) {
>         final double norm = 1.0 / Math.sqrt(v1.x * v1.x + v1.y * v1.y);
>         this.x = v1.x * norm;
>         this.y = v1.y * norm;
>     }
>     
>     public final void normalize() {
>         final double norm = 1.0 / Math.sqrt(this.x * this.x + this.y * this.y);
>         this.x *= norm;
>         this.y *= norm;
>     }
>     
>     public final double angle(final Vector2d v1) {
>         double vDot = this.dot(v1) / (this.length() * v1.length());
>         if (vDot < -1.0) {
>             vDot = -1.0;
>         }
>         if (vDot > 1.0) {
>             vDot = 1.0;
>         }
>         return Math.acos(vDot);
>     }
diff -r TrackAnalyzer_/vecmath/Vector2f.java procyon/vecmath/Vector2f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,70c9,73
< public class Vector2f extends Tuple2f implements Serializable {
<    static final long serialVersionUID = -2168194326883512320L;
< 
<    public Vector2f(float x, float y) {
<       super(x, y);
<    }
< 
<    public Vector2f(float[] v) {
<       super(v);
<    }
< 
<    public Vector2f(Vector2f v1) {
<       super((Tuple2f)v1);
<    }
< 
<    public Vector2f(Vector2d v1) {
<       super((Tuple2d)v1);
<    }
< 
<    public Vector2f(Tuple2f t1) {
<       super(t1);
<    }
< 
<    public Vector2f(Tuple2d t1) {
<       super(t1);
<    }
< 
<    public Vector2f() {
<    }
< 
<    public final float dot(Vector2f v1) {
<       return this.x * v1.x + this.y * v1.y;
<    }
< 
<    public final float length() {
<       return (float)Math.sqrt((double)(this.x * this.x + this.y * this.y));
<    }
< 
<    public final float lengthSquared() {
<       return this.x * this.x + this.y * this.y;
<    }
< 
<    public final void normalize(Vector2f v1) {
<       float norm = (float)(1.0D / Math.sqrt((double)(v1.x * v1.x + v1.y * v1.y)));
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<    }
< 
<    public final void normalize() {
<       float norm = (float)(1.0D / Math.sqrt((double)(this.x * this.x + this.y * this.y)));
<       this.x *= norm;
<       this.y *= norm;
<    }
< 
<    public final float angle(Vector2f v1) {
<       double vDot = (double)(this.dot(v1) / (this.length() * v1.length()));
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return (float)Math.acos(vDot);
<    }
---
> public class Vector2f extends Tuple2f implements Serializable
> {
>     static final long serialVersionUID = -2168194326883512320L;
>     
>     public Vector2f(final float x, final float y) {
>         super(x, y);
>     }
>     
>     public Vector2f(final float[] v) {
>         super(v);
>     }
>     
>     public Vector2f(final Vector2f v1) {
>         super(v1);
>     }
>     
>     public Vector2f(final Vector2d v1) {
>         super(v1);
>     }
>     
>     public Vector2f(final Tuple2f t1) {
>         super(t1);
>     }
>     
>     public Vector2f(final Tuple2d t1) {
>         super(t1);
>     }
>     
>     public Vector2f() {
>     }
>     
>     public final float dot(final Vector2f v1) {
>         return this.x * v1.x + this.y * v1.y;
>     }
>     
>     public final float length() {
>         return (float)Math.sqrt(this.x * this.x + this.y * this.y);
>     }
>     
>     public final float lengthSquared() {
>         return this.x * this.x + this.y * this.y;
>     }
>     
>     public final void normalize(final Vector2f v1) {
>         final float norm = (float)(1.0 / Math.sqrt(v1.x * v1.x + v1.y * v1.y));
>         this.x = v1.x * norm;
>         this.y = v1.y * norm;
>     }
>     
>     public final void normalize() {
>         final float norm = (float)(1.0 / Math.sqrt(this.x * this.x + this.y * this.y));
>         this.x *= norm;
>         this.y *= norm;
>     }
>     
>     public final float angle(final Vector2f v1) {
>         double vDot = this.dot(v1) / (this.length() * v1.length());
>         if (vDot < -1.0) {
>             vDot = -1.0;
>         }
>         if (vDot > 1.0) {
>             vDot = 1.0;
>         }
>         return (float)Math.acos(vDot);
>     }
diff -r TrackAnalyzer_/vecmath/Vector3d.java procyon/vecmath/Vector3d.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,80c9,83
< public class Vector3d extends Tuple3dModified implements Serializable {
<    static final long serialVersionUID = 3761969948420550442L;
< 
<    public Vector3d(double x, double y, double z) {
<       super(x, y, z);
<    }
< 
<    public Vector3d(double[] v) {
<       super(v);
<    }
< 
<    public Vector3d(Vector3d v1) {
<       super((Tuple3dModified)v1);
<    }
< 
<    public Vector3d(Vector3f v1) {
<       super((Tuple3f)v1);
<    }
< 
<    public Vector3d(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public Vector3d(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public Vector3d() {
<    }
< 
<    public final void cross(Vector3d v1, Vector3d v2) {
<       double x = v1.y * v2.z - v1.z * v2.y;
<       double y = v2.x * v1.z - v2.z * v1.x;
<       this.z = v1.x * v2.y - v1.y * v2.x;
<       this.x = x;
<       this.y = y;
<    }
< 
<    public final void normalize(Vector3d v1) {
<       double norm = 1.0D / Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<       this.z = v1.z * norm;
<    }
< 
<    public final void normalize() {
<       double norm = 1.0D / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
<       this.x *= norm;
<       this.y *= norm;
<       this.z *= norm;
<    }
< 
<    public final double dot(Vector3d v1) {
<       return this.x * v1.x + this.y * v1.y + this.z * v1.z;
<    }
< 
<    public final double lengthSquared() {
<       return this.x * this.x + this.y * this.y + this.z * this.z;
<    }
< 
<    public final double length() {
<       return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
<    }
< 
<    public final double angle(Vector3d v1) {
<       double vDot = this.dot(v1) / (this.length() * v1.length());
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return Math.acos(vDot);
<    }
---
> public class Vector3d extends Tuple3dModified implements Serializable
> {
>     static final long serialVersionUID = 3761969948420550442L;
>     
>     public Vector3d(final double x, final double y, final double z) {
>         super(x, y, z);
>     }
>     
>     public Vector3d(final double[] v) {
>         super(v);
>     }
>     
>     public Vector3d(final Vector3d v1) {
>         super(v1);
>     }
>     
>     public Vector3d(final Vector3f v1) {
>         super(v1);
>     }
>     
>     public Vector3d(final Tuple3f t1) {
>         super(t1);
>     }
>     
>     public Vector3d(final Tuple3dModified t1) {
>         super(t1);
>     }
>     
>     public Vector3d() {
>     }
>     
>     public final void cross(final Vector3d v1, final Vector3d v2) {
>         final double x = v1.y * v2.z - v1.z * v2.y;
>         final double y = v2.x * v1.z - v2.z * v1.x;
>         this.z = v1.x * v2.y - v1.y * v2.x;
>         this.x = x;
>         this.y = y;
>     }
>     
>     public final void normalize(final Vector3d v1) {
>         final double norm = 1.0 / Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
>         this.x = v1.x * norm;
>         this.y = v1.y * norm;
>         this.z = v1.z * norm;
>     }
>     
>     public final void normalize() {
>         final double norm = 1.0 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
>         this.x *= norm;
>         this.y *= norm;
>         this.z *= norm;
>     }
>     
>     public final double dot(final Vector3d v1) {
>         return this.x * v1.x + this.y * v1.y + this.z * v1.z;
>     }
>     
>     public final double lengthSquared() {
>         return this.x * this.x + this.y * this.y + this.z * this.z;
>     }
>     
>     public final double length() {
>         return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
>     }
>     
>     public final double angle(final Vector3d v1) {
>         double vDot = this.dot(v1) / (this.length() * v1.length());
>         if (vDot < -1.0) {
>             vDot = -1.0;
>         }
>         if (vDot > 1.0) {
>             vDot = 1.0;
>         }
>         return Math.acos(vDot);
>     }
diff -r TrackAnalyzer_/vecmath/Vector3f.java procyon/vecmath/Vector3f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,80c9,83
< public class Vector3f extends Tuple3f implements Serializable {
<    static final long serialVersionUID = -7031930069184524614L;
< 
<    public Vector3f(float x, float y, float z) {
<       super(x, y, z);
<    }
< 
<    public Vector3f(float[] v) {
<       super(v);
<    }
< 
<    public Vector3f(Vector3f v1) {
<       super((Tuple3f)v1);
<    }
< 
<    public Vector3f(Vector3d v1) {
<       super((Tuple3dModified)v1);
<    }
< 
<    public Vector3f(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public Vector3f(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public Vector3f() {
<    }
< 
<    public final float lengthSquared() {
<       return this.x * this.x + this.y * this.y + this.z * this.z;
<    }
< 
<    public final float length() {
<       return (float)Math.sqrt((double)(this.x * this.x + this.y * this.y + this.z * this.z));
<    }
< 
<    public final void cross(Vector3f v1, Vector3f v2) {
<       float x = v1.y * v2.z - v1.z * v2.y;
<       float y = v2.x * v1.z - v2.z * v1.x;
<       this.z = v1.x * v2.y - v1.y * v2.x;
<       this.x = x;
<       this.y = y;
<    }
< 
<    public final float dot(Vector3f v1) {
<       return this.x * v1.x + this.y * v1.y + this.z * v1.z;
<    }
< 
<    public final void normalize(Vector3f v1) {
<       float norm = (float)(1.0D / Math.sqrt((double)(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z)));
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<       this.z = v1.z * norm;
<    }
< 
<    public final void normalize() {
<       float norm = (float)(1.0D / Math.sqrt((double)(this.x * this.x + this.y * this.y + this.z * this.z)));
<       this.x *= norm;
<       this.y *= norm;
<       this.z *= norm;
<    }
< 
<    public final float angle(Vector3f v1) {
<       double vDot = (double)(this.dot(v1) / (this.length() * v1.length()));
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return (float)Math.acos(vDot);
<    }
---
> public class Vector3f extends Tuple3f implements Serializable
> {
>     static final long serialVersionUID = -7031930069184524614L;
>     
>     public Vector3f(final float x, final float y, final float z) {
>         super(x, y, z);
>     }
>     
>     public Vector3f(final float[] v) {
>         super(v);
>     }
>     
>     public Vector3f(final Vector3f v1) {
>         super(v1);
>     }
>     
>     public Vector3f(final Vector3d v1) {
>         super(v1);
>     }
>     
>     public Vector3f(final Tuple3f t1) {
>         super(t1);
>     }
>     
>     public Vector3f(final Tuple3dModified t1) {
>         super(t1);
>     }
>     
>     public Vector3f() {
>     }
>     
>     public final float lengthSquared() {
>         return this.x * this.x + this.y * this.y + this.z * this.z;
>     }
>     
>     public final float length() {
>         return (float)Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
>     }
>     
>     public final void cross(final Vector3f v1, final Vector3f v2) {
>         final float x = v1.y * v2.z - v1.z * v2.y;
>         final float y = v2.x * v1.z - v2.z * v1.x;
>         this.z = v1.x * v2.y - v1.y * v2.x;
>         this.x = x;
>         this.y = y;
>     }
>     
>     public final float dot(final Vector3f v1) {
>         return this.x * v1.x + this.y * v1.y + this.z * v1.z;
>     }
>     
>     public final void normalize(final Vector3f v1) {
>         final float norm = (float)(1.0 / Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z));
>         this.x = v1.x * norm;
>         this.y = v1.y * norm;
>         this.z = v1.z * norm;
>     }
>     
>     public final void normalize() {
>         final float norm = (float)(1.0 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z));
>         this.x *= norm;
>         this.y *= norm;
>         this.z *= norm;
>     }
>     
>     public final float angle(final Vector3f v1) {
>         double vDot = this.dot(v1) / (this.length() * v1.length());
>         if (vDot < -1.0) {
>             vDot = -1.0;
>         }
>         if (vDot > 1.0) {
>             vDot = 1.0;
>         }
>         return (float)Math.acos(vDot);
>     }
diff -r TrackAnalyzer_/vecmath/Vector4d.java procyon/vecmath/Vector4d.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,85c9,88
< public class Vector4d extends Tuple4d implements Serializable {
<    static final long serialVersionUID = 3938123424117448700L;
< 
<    public Vector4d(double x, double y, double z, double w) {
<       super(x, y, z, w);
<    }
< 
<    public Vector4d(double[] v) {
<       super(v);
<    }
< 
<    public Vector4d(Vector4d v1) {
<       super((Tuple4d)v1);
<    }
< 
<    public Vector4d(Vector4f v1) {
<       super((Tuple4f)v1);
<    }
< 
<    public Vector4d(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public Vector4d(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public Vector4d(Tuple3dModified t1) {
<       super(t1.x, t1.y, t1.z, 0.0D);
<    }
< 
<    public Vector4d() {
<    }
< 
<    public final void set(Tuple3dModified t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = 0.0D;
<    }
< 
<    public final double length() {
<       return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
<    }
< 
<    public final double lengthSquared() {
<       return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
<    }
< 
<    public final double dot(Vector4d v1) {
<       return this.x * v1.x + this.y * v1.y + this.z * v1.z + this.w * v1.w;
<    }
< 
<    public final void normalize(Vector4d v1) {
<       double norm = 1.0D / Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z + v1.w * v1.w);
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<       this.z = v1.z * norm;
<       this.w = v1.w * norm;
<    }
< 
<    public final void normalize() {
<       double norm = 1.0D / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
<       this.x *= norm;
<       this.y *= norm;
<       this.z *= norm;
<       this.w *= norm;
<    }
< 
<    public final double angle(Vector4d v1) {
<       double vDot = this.dot(v1) / (this.length() * v1.length());
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return Math.acos(vDot);
<    }
---
> public class Vector4d extends Tuple4d implements Serializable
> {
>     static final long serialVersionUID = 3938123424117448700L;
>     
>     public Vector4d(final double x, final double y, final double z, final double w) {
>         super(x, y, z, w);
>     }
>     
>     public Vector4d(final double[] v) {
>         super(v);
>     }
>     
>     public Vector4d(final Vector4d v1) {
>         super(v1);
>     }
>     
>     public Vector4d(final Vector4f v1) {
>         super(v1);
>     }
>     
>     public Vector4d(final Tuple4f t1) {
>         super(t1);
>     }
>     
>     public Vector4d(final Tuple4d t1) {
>         super(t1);
>     }
>     
>     public Vector4d(final Tuple3dModified t1) {
>         super(t1.x, t1.y, t1.z, 0.0);
>     }
>     
>     public Vector4d() {
>     }
>     
>     public final void set(final Tuple3dModified t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = 0.0;
>     }
>     
>     public final double length() {
>         return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
>     }
>     
>     public final double lengthSquared() {
>         return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
>     }
>     
>     public final double dot(final Vector4d v1) {
>         return this.x * v1.x + this.y * v1.y + this.z * v1.z + this.w * v1.w;
>     }
>     
>     public final void normalize(final Vector4d v1) {
>         final double norm = 1.0 / Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z + v1.w * v1.w);
>         this.x = v1.x * norm;
>         this.y = v1.y * norm;
>         this.z = v1.z * norm;
>         this.w = v1.w * norm;
>     }
>     
>     public final void normalize() {
>         final double norm = 1.0 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
>         this.x *= norm;
>         this.y *= norm;
>         this.z *= norm;
>         this.w *= norm;
>     }
>     
>     public final double angle(final Vector4d v1) {
>         double vDot = this.dot(v1) / (this.length() * v1.length());
>         if (vDot < -1.0) {
>             vDot = -1.0;
>         }
>         if (vDot > 1.0) {
>             vDot = 1.0;
>         }
>         return Math.acos(vDot);
>     }
diff -r TrackAnalyzer_/vecmath/Vector4f.java procyon/vecmath/Vector4f.java
0a1,4
> // 
> // Decompiled by Procyon v0.5.36
> // 
> 
5,85c9,88
< public class Vector4f extends Tuple4f implements Serializable {
<    static final long serialVersionUID = 8749319902347760659L;
< 
<    public Vector4f(float x, float y, float z, float w) {
<       super(x, y, z, w);
<    }
< 
<    public Vector4f(float[] v) {
<       super(v);
<    }
< 
<    public Vector4f(Vector4f v1) {
<       super((Tuple4f)v1);
<    }
< 
<    public Vector4f(Vector4d v1) {
<       super((Tuple4d)v1);
<    }
< 
<    public Vector4f(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public Vector4f(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public Vector4f(Tuple3f t1) {
<       super(t1.x, t1.y, t1.z, 0.0F);
<    }
< 
<    public Vector4f() {
<    }
< 
<    public final void set(Tuple3f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = 0.0F;
<    }
< 
<    public final float length() {
<       return (float)Math.sqrt((double)(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w));
<    }
< 
<    public final float lengthSquared() {
<       return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
<    }
< 
<    public final float dot(Vector4f v1) {
<       return this.x * v1.x + this.y * v1.y + this.z * v1.z + this.w * v1.w;
<    }
< 
<    public final void normalize(Vector4f v1) {
<       float norm = (float)(1.0D / Math.sqrt((double)(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z + v1.w * v1.w)));
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<       this.z = v1.z * norm;
<       this.w = v1.w * norm;
<    }
< 
<    public final void normalize() {
<       float norm = (float)(1.0D / Math.sqrt((double)(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)));
<       this.x *= norm;
<       this.y *= norm;
<       this.z *= norm;
<       this.w *= norm;
<    }
< 
<    public final float angle(Vector4f v1) {
<       double vDot = (double)(this.dot(v1) / (this.length() * v1.length()));
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return (float)Math.acos(vDot);
<    }
---
> public class Vector4f extends Tuple4f implements Serializable
> {
>     static final long serialVersionUID = 8749319902347760659L;
>     
>     public Vector4f(final float x, final float y, final float z, final float w) {
>         super(x, y, z, w);
>     }
>     
>     public Vector4f(final float[] v) {
>         super(v);
>     }
>     
>     public Vector4f(final Vector4f v1) {
>         super(v1);
>     }
>     
>     public Vector4f(final Vector4d v1) {
>         super(v1);
>     }
>     
>     public Vector4f(final Tuple4f t1) {
>         super(t1);
>     }
>     
>     public Vector4f(final Tuple4d t1) {
>         super(t1);
>     }
>     
>     public Vector4f(final Tuple3f t1) {
>         super(t1.x, t1.y, t1.z, 0.0f);
>     }
>     
>     public Vector4f() {
>     }
>     
>     public final void set(final Tuple3f t1) {
>         this.x = t1.x;
>         this.y = t1.y;
>         this.z = t1.z;
>         this.w = 0.0f;
>     }
>     
>     public final float length() {
>         return (float)Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
>     }
>     
>     public final float lengthSquared() {
>         return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
>     }
>     
>     public final float dot(final Vector4f v1) {
>         return this.x * v1.x + this.y * v1.y + this.z * v1.z + this.w * v1.w;
>     }
>     
>     public final void normalize(final Vector4f v1) {
>         final float norm = (float)(1.0 / Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z + v1.w * v1.w));
>         this.x = v1.x * norm;
>         this.y = v1.y * norm;
>         this.z = v1.z * norm;
>         this.w = v1.w * norm;
>     }
>     
>     public final void normalize() {
>         final float norm = (float)(1.0 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w));
>         this.x *= norm;
>         this.y *= norm;
>         this.z *= norm;
>         this.w *= norm;
>     }
>     
>     public final float angle(final Vector4f v1) {
>         double vDot = this.dot(v1) / (this.length() * v1.length());
>         if (vDot < -1.0) {
>             vDot = -1.0;
>         }
>         if (vDot > 1.0) {
>             vDot = 1.0;
>         }
>         return (float)Math.acos(vDot);
>     }
