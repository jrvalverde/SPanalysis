diff -r TrackAnalyzer_/BackgroundSubtracter.java jd-gui/BackgroundSubtracter.java
1,685c1,584
< import ij.IJ;
< import ij.process.ByteProcessor;
< import ij.process.ColorProcessor;
< import ij.process.FloatProcessor;
< import ij.process.ImageProcessor;
< import ij.process.ShortProcessor;
< import ij.util.Tools;
< import java.awt.image.ColorModel;
< 
< public class BackgroundSubtracter {
<    private static double staticRadius = 50.0D;
<    private static boolean staticLightBackground = false;
<    private static boolean staticSeparateColors;
<    private static boolean staticCreateBackground;
<    private static boolean staticUseParaboloid;
<    private static boolean staticDoPresmooth = false;
<    private double radius;
<    private boolean lightBackground;
<    private boolean separateColors;
<    private boolean createBackground;
<    private boolean useParaboloid;
<    private boolean doPresmooth;
<    private boolean isRGB;
<    private boolean previewing;
<    private static final int MAXIMUM = 0;
<    private static final int MEAN = 1;
<    private static final int X_DIRECTION = 0;
<    private static final int Y_DIRECTION = 1;
<    private static final int DIAGONAL_1A = 2;
<    private static final int DIAGONAL_1B = 3;
<    private static final int DIAGONAL_2A = 4;
<    private static final int DIAGONAL_2B = 5;
<    private static final int DIRECTION_PASSES = 9;
<    private int nPasses;
<    private int pass;
<    private boolean calledAsPlugin;
<    double meanValue;
< 
<    public BackgroundSubtracter() {
<       this.radius = staticRadius;
<       this.lightBackground = staticLightBackground;
<       this.separateColors = staticSeparateColors;
<       this.createBackground = staticCreateBackground;
<       this.useParaboloid = staticUseParaboloid;
<       this.doPresmooth = staticDoPresmooth;
<       this.nPasses = 9;
<    }
< 
<    public void rollingBallBrightnessBackground(ColorProcessor ip, double radius, boolean createBackground, boolean lightBackground, boolean useParaboloid, boolean doPresmooth, boolean correctCorners) {
<       int width = ip.getWidth();
<       int height = ip.getHeight();
<       byte[] H = new byte[width * height];
<       byte[] S = new byte[width * height];
<       byte[] B = new byte[width * height];
<       ip.getHSB(H, S, B);
<       ByteProcessor bp = new ByteProcessor(width, height, B, (ColorModel)null);
<       this.rollingBallBackground(bp, radius, createBackground, lightBackground, useParaboloid, doPresmooth, correctCorners);
<       ip.setHSB(H, S, (byte[])bp.getPixels());
<    }
< 
<    public double rollingBallBackground(ImageProcessor ip, double radius, boolean createBackground, boolean lightBackground, boolean useParaboloid, boolean doPresmooth, boolean correctCorners) {
<       boolean invertedLut = ip.isInvertedLut();
<       boolean invert = invertedLut && !lightBackground || !invertedLut && lightBackground;
<       RollingBall ball = null;
<       if (!useParaboloid) {
<          ball = new RollingBall(radius);
<       }
< 
<       FloatProcessor fp = null;
< 
<       for(int channelNumber = 0; channelNumber < ip.getNChannels(); ++channelNumber) {
<          fp = ip.toFloat(channelNumber, fp);
<          if (ip instanceof FloatProcessor && !this.calledAsPlugin && !createBackground) {
<             fp.snapshot();
<          }
< 
<          this.rollingBallFloatBackground(fp, (float)radius, invert, doPresmooth, ball);
<          if (createBackground) {
<             ip.setPixels(channelNumber, fp);
<          } else {
<             float[] bgPixels = (float[])fp.getPixels();
<             if (ip instanceof FloatProcessor) {
<                float[] snapshotPixels = (float[])fp.getSnapshotPixels();
< 
<                for(int p = 0; p < bgPixels.length; ++p) {
<                   bgPixels[p] = snapshotPixels[p] - bgPixels[p];
<                }
<             } else {
<                float offset;
<                int shift;
<                int resetMask;
<                double total;
<                float value;
<                float valueToSubtract;
<                if (ip instanceof ShortProcessor) {
<                   offset = invert ? 65535.5F : 0.5F;
<                   short[] pixels = (short[])ip.getPixels();
<                   short[] pixelsToSubtract = (short[])ip.getPixels();
< 
<                   for(shift = 0; shift < bgPixels.length; ++shift) {
<                      value = (float)(pixels[shift] & '\uffff') - bgPixels[shift] + offset;
<                      valueToSubtract = bgPixels[shift] + offset;
<                      if (value < 0.0F) {
<                         value = 0.0F;
<                      }
< 
<                      if (valueToSubtract < 0.0F) {
<                         valueToSubtract = 0.0F;
<                      }
< 
<                      if (value > 65535.0F) {
<                         value = 65535.0F;
<                      }
< 
<                      if (valueToSubtract > 65535.0F) {
<                         valueToSubtract = 65535.0F;
<                      }
< 
<                      pixels[shift] = (short)((int)value);
<                      pixelsToSubtract[shift] = (short)((int)valueToSubtract);
<                   }
< 
<                   total = 0.0D;
< 
<                   for(resetMask = 0; resetMask < pixelsToSubtract.length; ++resetMask) {
<                      total += (double)pixelsToSubtract[resetMask];
<                   }
< 
<                   this.meanValue = total / (double)pixelsToSubtract.length;
<                } else if (ip instanceof ByteProcessor) {
<                   offset = invert ? 255.5F : 0.5F;
<                   byte[] pixels = (byte[])ip.getPixels();
<                   byte[] pixelsToSubtract = (byte[])ip.getPixels();
< 
<                   for(shift = 0; shift < bgPixels.length; ++shift) {
<                      value = (float)(pixels[shift] & 255) - bgPixels[shift] + offset;
<                      valueToSubtract = bgPixels[shift] + offset;
<                      if (value < 0.0F) {
<                         value = 0.0F;
<                      }
< 
<                      if (valueToSubtract < 0.0F) {
<                         valueToSubtract = 0.0F;
<                      }
< 
<                      if (value > 255.0F) {
<                         value = 255.0F;
<                      }
< 
<                      if (valueToSubtract > 255.0F) {
<                         valueToSubtract = 255.0F;
<                      }
< 
<                      pixels[shift] = (byte)((int)value);
<                      pixelsToSubtract[shift] = (byte)((int)valueToSubtract);
<                   }
< 
<                   total = 0.0D;
< 
<                   for(resetMask = 0; resetMask < pixelsToSubtract.length; ++resetMask) {
<                      total += (double)pixelsToSubtract[resetMask];
<                   }
< 
<                   this.meanValue = total / (double)pixelsToSubtract.length;
<                } else if (ip instanceof ColorProcessor) {
<                   offset = invert ? 255.5F : 0.5F;
<                   int[] pixels = (int[])ip.getPixels();
<                   int[] pixelsToSubtract = (int[])ip.getPixels();
<                   shift = 16 - 8 * channelNumber;
<                   int byteMask = 255 << shift;
<                   resetMask = ~(255 << shift);
< 
<                   for(int p = 0; p < bgPixels.length; ++p) {
<                      int pxl = pixels[p];
<                      float value = (float)((pxl & byteMask) >> shift) - bgPixels[p] + offset;
<                      float valueToSubtract = bgPixels[p] + offset;
<                      if (value < 0.0F) {
<                         value = 0.0F;
<                      }
< 
<                      if (valueToSubtract < 0.0F) {
<                         valueToSubtract = 0.0F;
<                      }
< 
<                      if (value > 255.0F) {
<                         value = 255.0F;
<                      }
< 
<                      if (valueToSubtract > 255.0F) {
<                         valueToSubtract = 255.0F;
<                      }
< 
<                      pixels[p] = pxl & resetMask | (int)value << shift;
<                      pixelsToSubtract[p] = pxl & resetMask | (int)valueToSubtract << shift;
<                   }
< 
<                   double total = 0.0D;
< 
<                   for(int i = 0; i < pixelsToSubtract.length; ++i) {
<                      total += (double)pixelsToSubtract[i];
<                   }
< 
<                   this.meanValue = total / (double)pixelsToSubtract.length;
<                }
<             }
<          }
<       }
< 
<       return this.meanValue;
<    }
< 
<    static float[] lineSlideParabola(float[] pixels, int start, int inc, int length, float coeff2, float[] cache, int[] nextPoint, float[] correctedEdges) {
<       float minValue = Float.MAX_VALUE;
<       int lastpoint = 0;
<       int firstCorner = length - 1;
<       int lastCorner = 0;
<       float vPrevious1 = 0.0F;
<       float vPrevious2 = 0.0F;
<       float curvatureTest = 1.999F * coeff2;
<       int i1 = 0;
< 
<       float minSlope;
<       for(int p = start; i1 < length; p += inc) {
<          minSlope = pixels[p];
<          cache[i1] = minSlope;
<          if (minSlope < minValue) {
<             minValue = minSlope;
<          }
< 
<          if (i1 >= 2 && vPrevious1 + vPrevious1 - vPrevious2 - minSlope < curvatureTest) {
<             nextPoint[lastpoint] = i1 - 1;
<             lastpoint = i1 - 1;
<          }
< 
<          vPrevious2 = vPrevious1;
<          vPrevious1 = minSlope;
<          ++i1;
<       }
< 
<       nextPoint[lastpoint] = length - 1;
<       nextPoint[length - 1] = Integer.MAX_VALUE;
< 
<       int i2;
<       float dx;
<       float dx;
<       float v1;
<       int i;
<       for(i1 = 0; i1 < length - 1; i1 = i2) {
<          v1 = cache[i1];
<          minSlope = Float.MAX_VALUE;
<          i2 = 0;
<          int searchTo = length;
<          int recalculateLimitNow = 0;
< 
<          int j;
<          for(j = nextPoint[i1]; j < searchTo; ++recalculateLimitNow) {
<             dx = cache[j];
<             dx = (dx - v1) / (float)(j - i1) + coeff2 * (float)(j - i1);
<             if (dx < minSlope) {
<                minSlope = dx;
<                i2 = j;
<                recalculateLimitNow = -3;
<             }
< 
<             if (recalculateLimitNow == 0) {
<                double b = (double)(0.5F * minSlope / coeff2);
<                int maxSearch = i1 + (int)(b + Math.sqrt(b * b + (double)((v1 - minValue) / coeff2)) + 1.0D);
<                if (maxSearch < searchTo && maxSearch > 0) {
<                   searchTo = maxSearch;
<                }
<             }
< 
<             j = nextPoint[j];
<          }
< 
<          if (i1 == 0) {
<             firstCorner = i2;
<          }
< 
<          if (i2 == length - 1) {
<             lastCorner = i1;
<          }
< 
<          j = i1 + 1;
< 
<          for(i = start + j * inc; j < i2; i += inc) {
<             pixels[i] = v1 + (float)(j - i1) * (minSlope - (float)(j - i1) * coeff2);
<             ++j;
<          }
<       }
< 
<       if (correctedEdges != null) {
<          if (4 * firstCorner >= length) {
<             firstCorner = 0;
<          }
< 
<          if (4 * (length - 1 - lastCorner) >= length) {
<             lastCorner = length - 1;
<          }
< 
<          v1 = cache[firstCorner];
<          minSlope = cache[lastCorner];
<          float slope = (minSlope - v1) / (float)(lastCorner - firstCorner);
<          float value0 = v1 - slope * (float)firstCorner;
<          float coeff6 = 0.0F;
<          float mid = 0.5F * (float)(lastCorner + firstCorner);
< 
<          for(i = (length + 2) / 3; i <= 2 * length / 3; ++i) {
<             dx = ((float)i - mid) * 2.0F / (float)(lastCorner - firstCorner);
<             float poly6 = dx * dx * dx * dx * dx * dx - 1.0F;
<             if (cache[i] < value0 + slope * (float)i + coeff6 * poly6) {
<                coeff6 = -(value0 + slope * (float)i - cache[i]) / poly6;
<             }
<          }
< 
<          dx = ((float)firstCorner - mid) * 2.0F / (float)(lastCorner - firstCorner);
<          correctedEdges[0] = value0 + coeff6 * (dx * dx * dx * dx * dx * dx - 1.0F) + coeff2 * (float)firstCorner * (float)firstCorner;
<          dx = ((float)lastCorner - mid) * 2.0F / (float)(lastCorner - firstCorner);
<          correctedEdges[1] = value0 + (float)(length - 1) * slope + coeff6 * (dx * dx * dx * dx * dx * dx - 1.0F) + coeff2 * (float)(length - 1 - lastCorner) * (float)(length - 1 - lastCorner);
<       }
< 
<       return correctedEdges;
<    }
< 
<    void correctCorners(FloatProcessor fp, float coeff2, float[] cache, int[] nextPoint) {
<       int width = fp.getWidth();
<       int height = fp.getHeight();
<       float[] pixels = (float[])fp.getPixels();
<       float[] corners = new float[4];
<       float[] correctedEdges = new float[2];
<       correctedEdges = lineSlideParabola(pixels, 0, 1, width, coeff2, cache, nextPoint, correctedEdges);
<       corners[0] = correctedEdges[0];
<       corners[1] = correctedEdges[1];
<       correctedEdges = lineSlideParabola(pixels, (height - 1) * width, 1, width, coeff2, cache, nextPoint, correctedEdges);
<       corners[2] = correctedEdges[0];
<       corners[3] = correctedEdges[1];
<       correctedEdges = lineSlideParabola(pixels, 0, width, height, coeff2, cache, nextPoint, correctedEdges);
<       corners[0] += correctedEdges[0];
<       corners[2] += correctedEdges[1];
<       correctedEdges = lineSlideParabola(pixels, width - 1, width, height, coeff2, cache, nextPoint, correctedEdges);
<       corners[1] += correctedEdges[0];
<       corners[3] += correctedEdges[1];
<       int diagLength = Math.min(width, height);
<       float coeff2diag = 2.0F * coeff2;
<       correctedEdges = lineSlideParabola(pixels, 0, 1 + width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
<       corners[0] += correctedEdges[0];
<       correctedEdges = lineSlideParabola(pixels, width - 1, -1 + width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
<       corners[1] += correctedEdges[0];
<       correctedEdges = lineSlideParabola(pixels, (height - 1) * width, 1 - width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
<       corners[2] += correctedEdges[0];
<       correctedEdges = lineSlideParabola(pixels, width * height - 1, -1 - width, diagLength, coeff2diag, cache, nextPoint, correctedEdges);
<       corners[3] += correctedEdges[0];
<       if (pixels[0] > corners[0] / 3.0F) {
<          pixels[0] = corners[0] / 3.0F;
<       }
< 
<       if (pixels[width - 1] > corners[1] / 3.0F) {
<          pixels[width - 1] = corners[1] / 3.0F;
<       }
< 
<       if (pixels[(height - 1) * width] > corners[2] / 3.0F) {
<          pixels[(height - 1) * width] = corners[2] / 3.0F;
<       }
< 
<       if (pixels[width * height - 1] > corners[3] / 3.0F) {
<          pixels[width * height - 1] = corners[3] / 3.0F;
<       }
< 
<    }
< 
<    void rollingBallFloatBackground(FloatProcessor fp, float radius, boolean invert, boolean doPresmooth, RollingBall ball) {
<       float[] pixels = (float[])fp.getPixels();
<       boolean shrink = ball.shrinkFactor > 1;
<       this.showProgress(0.0D);
<       if (invert) {
<          for(int i = 0; i < pixels.length; ++i) {
<             pixels[i] = -pixels[i];
<          }
<       }
< 
<       if (doPresmooth) {
<          this.filter3x3(fp, 1);
<       }
< 
<       double[] minmax = Tools.getMinMax(pixels);
<       if (!Thread.currentThread().isInterrupted()) {
<          FloatProcessor smallImage = shrink ? this.shrinkImage(fp, ball.shrinkFactor) : fp;
<          if (!Thread.currentThread().isInterrupted()) {
<             this.rollBall(ball, smallImage);
<             if (!Thread.currentThread().isInterrupted()) {
<                this.showProgress(0.9D);
<                if (shrink) {
<                   this.enlargeImage(smallImage, fp, ball.shrinkFactor);
<                }
< 
<                if (!Thread.currentThread().isInterrupted()) {
<                   if (invert) {
<                      for(int i = 0; i < pixels.length; ++i) {
<                         pixels[i] = -pixels[i];
<                      }
<                   }
< 
<                   ++this.pass;
<                }
<             }
<          }
<       }
<    }
< 
<    FloatProcessor shrinkImage(FloatProcessor ip, int shrinkFactor) {
<       int width = ip.getWidth();
<       int height = ip.getHeight();
<       float[] pixels = (float[])ip.getPixels();
<       int sWidth = (width + shrinkFactor - 1) / shrinkFactor;
<       int sHeight = (height + shrinkFactor - 1) / shrinkFactor;
<       this.showProgress(0.1D);
<       FloatProcessor smallImage = new FloatProcessor(sWidth, sHeight);
<       float[] sPixels = (float[])smallImage.getPixels();
< 
<       for(int ySmall = 0; ySmall < sHeight; ++ySmall) {
<          for(int xSmall = 0; xSmall < sWidth; ++xSmall) {
<             float min = Float.MAX_VALUE;
<             int j = 0;
< 
<             for(int y = shrinkFactor * ySmall; j < shrinkFactor && y < height; ++y) {
<                int k = 0;
< 
<                for(int x = shrinkFactor * xSmall; k < shrinkFactor && x < width; ++x) {
<                   float thispixel = pixels[x + y * width];
<                   if (thispixel < min) {
<                      min = thispixel;
<                   }
< 
<                   ++k;
<                }
< 
<                ++j;
<             }
< 
<             sPixels[xSmall + ySmall * sWidth] = min;
<          }
<       }
< 
<       return smallImage;
<    }
< 
<    void rollBall(RollingBall ball, FloatProcessor fp) {
<       float[] pixels = (float[])fp.getPixels();
<       int width = fp.getWidth();
<       int height = fp.getHeight();
<       float[] zBall = ball.data;
<       int ballWidth = ball.width;
<       int radius = ballWidth / 2;
<       float[] cache = new float[width * ballWidth];
<       Thread thread = Thread.currentThread();
<       long lastTime = System.currentTimeMillis();
< 
<       for(int y = -radius; y < height + radius; ++y) {
<          long time = System.currentTimeMillis();
<          if (time - lastTime > 100L) {
<             lastTime = time;
<             if (thread.isInterrupted()) {
<                return;
<             }
< 
<             this.showProgress(0.1D + 0.8D * (double)y / (double)(height + ballWidth));
<          }
< 
<          int nextLineToWriteInCache = (y + radius) % ballWidth;
<          int nextLineToRead = y + radius;
<          int y0;
<          int yBall0;
<          if (nextLineToRead < height) {
<             System.arraycopy(pixels, nextLineToRead * width, cache, nextLineToWriteInCache * width, width);
<             y0 = 0;
< 
<             for(yBall0 = nextLineToRead * width; y0 < width; ++yBall0) {
<                pixels[yBall0] = -3.4028235E38F;
<                ++y0;
<             }
<          }
< 
<          y0 = y - radius;
<          if (y0 < 0) {
<             y0 = 0;
<          }
< 
<          yBall0 = y0 - y + radius;
<          int yend = y + radius;
<          if (yend >= height) {
<             yend = height - 1;
<          }
< 
<          for(int x = -radius; x < width + radius; ++x) {
<             float z = Float.MAX_VALUE;
<             int x0 = x - radius;
<             if (x0 < 0) {
<                x0 = 0;
<             }
< 
<             int xBall0 = x0 - x + radius;
<             int xend = x + radius;
<             if (xend >= width) {
<                xend = width - 1;
<             }
< 
<             int yp = y0;
< 
<             int yBall;
<             int xp;
<             int p;
<             int bp;
<             float zMin;
<             for(yBall = yBall0; yp <= yend; ++yBall) {
<                xp = yp % ballWidth * width + x0;
<                p = x0;
< 
<                for(bp = xBall0 + yBall * ballWidth; p <= xend; ++bp) {
<                   zMin = cache[xp] - zBall[bp];
<                   if (z > zMin) {
<                      z = zMin;
<                   }
< 
<                   ++p;
<                   ++xp;
<                }
< 
<                ++yp;
<             }
< 
<             yp = y0;
< 
<             for(yBall = yBall0; yp <= yend; ++yBall) {
<                xp = x0;
<                p = x0 + yp * width;
< 
<                for(bp = xBall0 + yBall * ballWidth; xp <= xend; ++bp) {
<                   zMin = z + zBall[bp];
<                   if (pixels[p] < zMin) {
<                      pixels[p] = zMin;
<                   }
< 
<                   ++xp;
<                   ++p;
<                }
< 
<                ++yp;
<             }
<          }
<       }
< 
<    }
< 
<    void enlargeImage(FloatProcessor smallImage, FloatProcessor fp, int shrinkFactor) {
<       int width = fp.getWidth();
<       int height = fp.getHeight();
<       int smallWidth = smallImage.getWidth();
<       int smallHeight = smallImage.getHeight();
<       float[] pixels = (float[])fp.getPixels();
<       float[] sPixels = (float[])smallImage.getPixels();
<       int[] xSmallIndices = new int[width];
<       float[] xWeights = new float[width];
<       this.makeInterpolationArrays(xSmallIndices, xWeights, width, smallWidth, shrinkFactor);
<       int[] ySmallIndices = new int[height];
<       float[] yWeights = new float[height];
<       this.makeInterpolationArrays(ySmallIndices, yWeights, height, smallHeight, shrinkFactor);
<       float[] line0 = new float[width];
<       float[] line1 = new float[width];
< 
<       int ySmallLine0;
<       for(ySmallLine0 = 0; ySmallLine0 < width; ++ySmallLine0) {
<          line1[ySmallLine0] = sPixels[xSmallIndices[ySmallLine0]] * xWeights[ySmallLine0] + sPixels[xSmallIndices[ySmallLine0] + 1] * (1.0F - xWeights[ySmallLine0]);
<       }
< 
<       ySmallLine0 = -1;
< 
<       for(int y = 0; y < height; ++y) {
<          int x;
<          int p;
<          if (ySmallLine0 < ySmallIndices[y]) {
<             float[] swap = line0;
<             line0 = line1;
<             line1 = swap;
<             ++ySmallLine0;
<             x = (ySmallIndices[y] + 1) * smallWidth;
< 
<             for(p = 0; p < width; ++p) {
<                line1[p] = sPixels[x + xSmallIndices[p]] * xWeights[p] + sPixels[x + xSmallIndices[p] + 1] * (1.0F - xWeights[p]);
<             }
<          }
< 
<          float weight = yWeights[y];
<          x = 0;
< 
<          for(p = y * width; x < width; ++p) {
<             pixels[p] = line0[x] * weight + line1[x] * (1.0F - weight);
<             ++x;
<          }
<       }
< 
<    }
< 
<    void makeInterpolationArrays(int[] smallIndices, float[] weights, int length, int smallLength, int shrinkFactor) {
<       for(int i = 0; i < length; ++i) {
<          int smallIndex = (i - shrinkFactor / 2) / shrinkFactor;
<          if (smallIndex >= smallLength - 1) {
<             smallIndex = smallLength - 2;
<          }
< 
<          smallIndices[i] = smallIndex;
<          float distance = ((float)i + 0.5F) / (float)shrinkFactor - ((float)smallIndex + 0.5F);
<          weights[i] = 1.0F - distance;
<       }
< 
<    }
< 
<    double filter3x3(FloatProcessor fp, int type) {
<       int width = fp.getWidth();
<       int height = fp.getHeight();
<       double shiftBy = 0.0D;
<       float[] pixels = (float[])fp.getPixels();
< 
<       int x;
<       for(x = 0; x < height; ++x) {
<          shiftBy += this.filter3(pixels, width, x * width, 1, type);
<       }
< 
<       for(x = 0; x < width; ++x) {
<          shiftBy += this.filter3(pixels, height, x, width, type);
<       }
< 
<       return shiftBy / (double)width / (double)height;
<    }
< 
<    double filter3(float[] pixels, int length, int pixel0, int inc, int type) {
<       double shiftBy = 0.0D;
<       float v3 = pixels[pixel0];
<       float v2 = v3;
<       int i = 0;
< 
<       for(int p = pixel0; i < length; p += inc) {
<          float v1 = v2;
<          v2 = v3;
<          if (i < length - 1) {
<             v3 = pixels[p + inc];
<          }
< 
<          if (type == 0) {
<             float max = v1 > v3 ? v1 : v3;
<             if (v2 > max) {
<                max = v2;
<             }
< 
<             shiftBy += (double)(max - v2);
<             pixels[p] = max;
<          } else {
<             pixels[p] = (v1 + v3 + v3) * 0.33333334F;
<          }
< 
<          ++i;
<       }
< 
<       return shiftBy;
<    }
< 
<    public void setNPasses(int nPasses) {
<       if (this.isRGB && this.separateColors) {
<          nPasses *= 3;
<       }
< 
<       if (this.useParaboloid) {
<          nPasses *= this.doPresmooth ? 11 : 9;
<       }
< 
<       this.nPasses = nPasses;
<       this.pass = 0;
<    }
< 
<    private void showProgress(double percent) {
<       if (this.nPasses > 0) {
<          percent = (double)this.pass / (double)this.nPasses + percent / (double)this.nPasses;
<          IJ.showProgress(percent);
<       }
<    }
< }
---
> /*     */ import ij.IJ;
> /*     */ import ij.process.ByteProcessor;
> /*     */ import ij.process.ColorProcessor;
> /*     */ import ij.process.FloatProcessor;
> /*     */ import ij.process.ImageProcessor;
> /*     */ import ij.util.Tools;
> /*     */ 
> /*     */ 
> /*     */ public class BackgroundSubtracter
> /*     */ {
> /*  11 */   private static double staticRadius = 50.0D;
> /*     */   
> /*     */   private static boolean staticLightBackground = false;
> /*     */   private static boolean staticSeparateColors;
> /*     */   private static boolean staticCreateBackground;
> /*     */   private static boolean staticUseParaboloid;
> /*     */   private static boolean staticDoPresmooth = false;
> /*  18 */   private double radius = staticRadius;
> /*  19 */   private boolean lightBackground = staticLightBackground;
> /*  20 */   private boolean separateColors = staticSeparateColors;
> /*  21 */   private boolean createBackground = staticCreateBackground;
> /*  22 */   private boolean useParaboloid = staticUseParaboloid;
> /*  23 */   private boolean doPresmooth = staticDoPresmooth;
> /*     */   
> /*     */   private boolean isRGB;
> /*     */   
> /*     */   private boolean previewing;
> /*     */   private static final int MAXIMUM = 0;
> /*     */   private static final int MEAN = 1;
> /*     */   private static final int X_DIRECTION = 0;
> /*  31 */   private int nPasses = 9; private static final int Y_DIRECTION = 1; private static final int DIAGONAL_1A = 2; private static final int DIAGONAL_1B = 3; private static final int DIAGONAL_2A = 4; private static final int DIAGONAL_2B = 5;
> /*     */   private static final int DIRECTION_PASSES = 9;
> /*     */   private int pass;
> /*     */   private boolean calledAsPlugin;
> /*     */   double meanValue;
> /*     */   
> /*     */   public void rollingBallBrightnessBackground(ColorProcessor ip, double radius, boolean createBackground, boolean lightBackground, boolean useParaboloid, boolean doPresmooth, boolean correctCorners) {
> /*  38 */     int width = ip.getWidth();
> /*  39 */     int height = ip.getHeight();
> /*  40 */     byte[] H = new byte[width * height];
> /*  41 */     byte[] S = new byte[width * height];
> /*  42 */     byte[] B = new byte[width * height];
> /*  43 */     ip.getHSB(H, S, B);
> /*  44 */     ByteProcessor bp = new ByteProcessor(width, height, B, null);
> /*  45 */     rollingBallBackground((ImageProcessor)bp, radius, createBackground, lightBackground, useParaboloid, doPresmooth, 
> /*  46 */         correctCorners);
> /*  47 */     ip.setHSB(H, S, (byte[])bp.getPixels());
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double rollingBallBackground(ImageProcessor ip, double radius, boolean createBackground, boolean lightBackground, boolean useParaboloid, boolean doPresmooth, boolean correctCorners) {
> /*  52 */     boolean invertedLut = ip.isInvertedLut();
> /*  53 */     boolean invert = !((!invertedLut || lightBackground) && (invertedLut || !lightBackground));
> /*  54 */     RollingBall ball = null;
> /*  55 */     if (!useParaboloid)
> /*  56 */       ball = new RollingBall(radius); 
> /*  57 */     FloatProcessor fp = null;
> /*  58 */     for (int channelNumber = 0; channelNumber < ip.getNChannels(); channelNumber++) {
> /*  59 */       fp = ip.toFloat(channelNumber, fp);
> /*  60 */       if (ip instanceof FloatProcessor && !this.calledAsPlugin && !createBackground) {
> /*  61 */         fp.snapshot();
> /*     */       }
> /*  63 */       rollingBallFloatBackground(fp, (float)radius, invert, doPresmooth, ball);
> /*     */       
> /*  65 */       if (createBackground) {
> /*  66 */         ip.setPixels(channelNumber, fp);
> /*     */       } else {
> /*  68 */         float[] bgPixels = (float[])fp.getPixels();
> /*  69 */         if (ip instanceof FloatProcessor) {
> /*  70 */           float[] snapshotPixels = (float[])fp.getSnapshotPixels();
> /*  71 */           for (int p = 0; p < bgPixels.length; p++) {
> /*  72 */             bgPixels[p] = snapshotPixels[p] - bgPixels[p];
> /*     */           }
> /*     */         }
> /*  75 */         else if (ip instanceof ij.process.ShortProcessor) {
> /*  76 */           float offset = invert ? 65535.5F : 0.5F;
> /*  77 */           short[] pixels = (short[])ip.getPixels();
> /*  78 */           short[] pixelsToSubtract = (short[])ip.getPixels();
> /*  79 */           for (int p = 0; p < bgPixels.length; p++) {
> /*  80 */             float value = (pixels[p] & 0xFFFF) - bgPixels[p] + offset;
> /*  81 */             float valueToSubtract = bgPixels[p] + offset;
> /*  82 */             if (value < 0.0F)
> /*  83 */               value = 0.0F; 
> /*  84 */             if (valueToSubtract < 0.0F)
> /*  85 */               valueToSubtract = 0.0F; 
> /*  86 */             if (value > 65535.0F)
> /*  87 */               value = 65535.0F; 
> /*  88 */             if (valueToSubtract > 65535.0F) {
> /*  89 */               valueToSubtract = 65535.0F;
> /*     */             }
> /*  91 */             pixels[p] = (short)(int)value;
> /*  92 */             pixelsToSubtract[p] = (short)(int)valueToSubtract;
> /*     */           } 
> /*     */           
> /*  95 */           double total = 0.0D;
> /*  96 */           for (int i = 0; i < pixelsToSubtract.length; i++) {
> /*  97 */             total += pixelsToSubtract[i];
> /*     */           }
> /*  99 */           this.meanValue = total / pixelsToSubtract.length;
> /*     */         }
> /* 101 */         else if (ip instanceof ByteProcessor) {
> /* 102 */           float offset = invert ? 255.5F : 0.5F;
> /* 103 */           byte[] pixels = (byte[])ip.getPixels();
> /* 104 */           byte[] pixelsToSubtract = (byte[])ip.getPixels();
> /* 105 */           for (int p = 0; p < bgPixels.length; p++) {
> /* 106 */             float value = (pixels[p] & 0xFF) - bgPixels[p] + offset;
> /* 107 */             float valueToSubtract = bgPixels[p] + offset;
> /* 108 */             if (value < 0.0F)
> /* 109 */               value = 0.0F; 
> /* 110 */             if (valueToSubtract < 0.0F) {
> /* 111 */               valueToSubtract = 0.0F;
> /*     */             }
> /* 113 */             if (value > 255.0F)
> /* 114 */               value = 255.0F; 
> /* 115 */             if (valueToSubtract > 255.0F)
> /* 116 */               valueToSubtract = 255.0F; 
> /* 117 */             pixels[p] = (byte)(int)value;
> /* 118 */             pixelsToSubtract[p] = (byte)(int)valueToSubtract;
> /*     */           } 
> /*     */           
> /* 121 */           double total = 0.0D;
> /* 122 */           for (int i = 0; i < pixelsToSubtract.length; i++) {
> /* 123 */             total += pixelsToSubtract[i];
> /*     */           }
> /* 125 */           this.meanValue = total / pixelsToSubtract.length;
> /* 126 */         } else if (ip instanceof ColorProcessor) {
> /* 127 */           float offset = invert ? 255.5F : 0.5F;
> /* 128 */           int[] pixels = (int[])ip.getPixels();
> /* 129 */           int[] pixelsToSubtract = (int[])ip.getPixels();
> /* 130 */           int shift = 16 - 8 * channelNumber;
> /*     */           
> /* 132 */           int byteMask = 255 << shift;
> /* 133 */           int resetMask = 0xFFFFFFFF ^ 255 << shift;
> /*     */           
> /* 135 */           for (int p = 0; p < bgPixels.length; p++) {
> /* 136 */             int pxl = pixels[p];
> /* 137 */             float value = ((pxl & byteMask) >> shift) - bgPixels[p] + offset;
> /* 138 */             float valueToSubtract = bgPixels[p] + offset;
> /* 139 */             if (value < 0.0F)
> /* 140 */               value = 0.0F; 
> /* 141 */             if (valueToSubtract < 0.0F) {
> /* 142 */               valueToSubtract = 0.0F;
> /*     */             }
> /* 144 */             if (value > 255.0F)
> /* 145 */               value = 255.0F; 
> /* 146 */             if (valueToSubtract > 255.0F)
> /* 147 */               valueToSubtract = 255.0F; 
> /* 148 */             pixels[p] = pxl & resetMask | (int)value << shift;
> /* 149 */             pixelsToSubtract[p] = pxl & resetMask | (int)valueToSubtract << shift;
> /*     */           } 
> /*     */           
> /* 152 */           double total = 0.0D;
> /* 153 */           for (int i = 0; i < pixelsToSubtract.length; i++) {
> /* 154 */             total += pixelsToSubtract[i];
> /*     */           }
> /* 156 */           this.meanValue = total / pixelsToSubtract.length;
> /*     */         } 
> /*     */       } 
> /*     */     } 
> /*     */ 
> /*     */     
> /* 162 */     return this.meanValue;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   static float[] lineSlideParabola(float[] pixels, int start, int inc, int length, float coeff2, float[] cache, int[] nextPoint, float[] correctedEdges) {
> /* 167 */     float minValue = Float.MAX_VALUE;
> /* 168 */     int lastpoint = 0;
> /* 169 */     int firstCorner = length - 1;
> /* 170 */     int lastCorner = 0;
> /* 171 */     float vPrevious1 = 0.0F;
> /* 172 */     float vPrevious2 = 0.0F;
> /* 173 */     float curvatureTest = 1.999F * coeff2;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 179 */     for (int i = 0, p = start; i < length; i++, p += inc) {
> /* 180 */       float v = pixels[p];
> /* 181 */       cache[i] = v;
> /* 182 */       if (v < minValue)
> /* 183 */         minValue = v; 
> /* 184 */       if (i >= 2 && vPrevious1 + vPrevious1 - vPrevious2 - v < curvatureTest) {
> /* 185 */         nextPoint[lastpoint] = i - 1;
> /* 186 */         lastpoint = i - 1;
> /*     */       } 
> /* 188 */       vPrevious2 = vPrevious1;
> /* 189 */       vPrevious1 = v;
> /*     */     } 
> /* 191 */     nextPoint[lastpoint] = length - 1;
> /* 192 */     nextPoint[length - 1] = Integer.MAX_VALUE;
> /*     */     
> /* 194 */     int i1 = 0;
> /* 195 */     while (i1 < length - 1) {
> /* 196 */       float v1 = cache[i1];
> /* 197 */       float minSlope = Float.MAX_VALUE;
> /* 198 */       int i2 = 0;
> /* 199 */       int searchTo = length;
> /* 200 */       int recalculateLimitNow = 0;
> /*     */       int j;
> /* 202 */       for (j = nextPoint[i1]; j < searchTo; j = nextPoint[j], recalculateLimitNow++) {
> /* 203 */         float v2 = cache[j];
> /* 204 */         float slope = (v2 - v1) / (j - i1) + coeff2 * (j - i1);
> /* 205 */         if (slope < minSlope) {
> /* 206 */           minSlope = slope;
> /* 207 */           i2 = j;
> /* 208 */           recalculateLimitNow = -3;
> /*     */         } 
> /* 210 */         if (recalculateLimitNow == 0) {
> /*     */           
> /* 212 */           double b = (0.5F * minSlope / coeff2);
> /* 213 */           int maxSearch = i1 + (int)(b + Math.sqrt(b * b + ((v1 - minValue) / coeff2)) + 1.0D);
> /*     */ 
> /*     */ 
> /*     */           
> /* 217 */           if (maxSearch < searchTo && maxSearch > 0)
> /* 218 */             searchTo = maxSearch; 
> /*     */         } 
> /*     */       } 
> /* 221 */       if (i1 == 0)
> /* 222 */         firstCorner = i2; 
> /* 223 */       if (i2 == length - 1)
> /* 224 */         lastCorner = i1; 
> /*     */       int k;
> /* 226 */       for (j = i1 + 1, k = start + j * inc; j < i2; j++, k += inc)
> /* 227 */         pixels[k] = v1 + (j - i1) * (minSlope - (j - i1) * coeff2); 
> /* 228 */       i1 = i2;
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 234 */     if (correctedEdges != null) {
> /* 235 */       if (4 * firstCorner >= length)
> /* 236 */         firstCorner = 0; 
> /* 237 */       if (4 * (length - 1 - lastCorner) >= length)
> /* 238 */         lastCorner = length - 1; 
> /* 239 */       float v1 = cache[firstCorner];
> /* 240 */       float v2 = cache[lastCorner];
> /* 241 */       float slope = (v2 - v1) / (lastCorner - firstCorner);
> /*     */       
> /* 243 */       float value0 = v1 - slope * firstCorner;
> /* 244 */       float coeff6 = 0.0F;
> /* 245 */       float mid = 0.5F * (lastCorner + firstCorner);
> /* 246 */       for (int j = (length + 2) / 3; j <= 2 * length / 3; j++) {
> /*     */         
> /* 248 */         float f1 = (j - mid) * 2.0F / (lastCorner - firstCorner);
> /* 249 */         float poly6 = f1 * f1 * f1 * f1 * f1 * f1 - 1.0F;
> /*     */         
> /* 251 */         if (cache[j] < value0 + slope * j + coeff6 * poly6) {
> /* 252 */           coeff6 = -(value0 + slope * j - cache[j]) / poly6;
> /*     */         }
> /*     */       } 
> /* 255 */       float dx = (firstCorner - mid) * 2.0F / (lastCorner - firstCorner);
> /* 256 */       correctedEdges[0] = value0 + coeff6 * (dx * dx * dx * dx * dx * dx - 1.0F) + 
> /* 257 */         coeff2 * firstCorner * firstCorner;
> /* 258 */       dx = (lastCorner - mid) * 2.0F / (lastCorner - firstCorner);
> /* 259 */       correctedEdges[1] = value0 + (length - 1) * slope + coeff6 * (dx * dx * dx * dx * dx * dx - 1.0F) + 
> /* 260 */         coeff2 * (length - 1 - lastCorner) * (length - 1 - lastCorner);
> /*     */     } 
> /* 262 */     return correctedEdges;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void correctCorners(FloatProcessor fp, float coeff2, float[] cache, int[] nextPoint) {
> /* 271 */     int width = fp.getWidth();
> /* 272 */     int height = fp.getHeight();
> /* 273 */     float[] pixels = (float[])fp.getPixels();
> /* 274 */     float[] corners = new float[4];
> /* 275 */     float[] correctedEdges = new float[2];
> /* 276 */     correctedEdges = lineSlideParabola(pixels, 0, 1, width, coeff2, cache, nextPoint, correctedEdges);
> /* 277 */     corners[0] = correctedEdges[0];
> /* 278 */     corners[1] = correctedEdges[1];
> /* 279 */     correctedEdges = lineSlideParabola(pixels, (height - 1) * width, 1, width, coeff2, cache, nextPoint, 
> /* 280 */         correctedEdges);
> /* 281 */     corners[2] = correctedEdges[0];
> /* 282 */     corners[3] = correctedEdges[1];
> /* 283 */     correctedEdges = lineSlideParabola(pixels, 0, width, height, coeff2, cache, nextPoint, correctedEdges);
> /* 284 */     corners[0] = corners[0] + correctedEdges[0];
> /* 285 */     corners[2] = corners[2] + correctedEdges[1];
> /* 286 */     correctedEdges = lineSlideParabola(pixels, width - 1, width, height, coeff2, cache, nextPoint, correctedEdges);
> /* 287 */     corners[1] = corners[1] + correctedEdges[0];
> /* 288 */     corners[3] = corners[3] + correctedEdges[1];
> /* 289 */     int diagLength = Math.min(width, height);
> /* 290 */     float coeff2diag = 2.0F * coeff2;
> /* 291 */     correctedEdges = lineSlideParabola(pixels, 0, 1 + width, diagLength, coeff2diag, cache, nextPoint, 
> /* 292 */         correctedEdges);
> /* 293 */     corners[0] = corners[0] + correctedEdges[0];
> /* 294 */     correctedEdges = lineSlideParabola(pixels, width - 1, -1 + width, diagLength, coeff2diag, cache, nextPoint, 
> /* 295 */         correctedEdges);
> /* 296 */     corners[1] = corners[1] + correctedEdges[0];
> /* 297 */     correctedEdges = lineSlideParabola(pixels, (height - 1) * width, 1 - width, diagLength, coeff2diag, cache, 
> /* 298 */         nextPoint, correctedEdges);
> /* 299 */     corners[2] = corners[2] + correctedEdges[0];
> /* 300 */     correctedEdges = lineSlideParabola(pixels, width * height - 1, -1 - width, diagLength, coeff2diag, cache, 
> /* 301 */         nextPoint, correctedEdges);
> /* 302 */     corners[3] = corners[3] + correctedEdges[0];
> /* 303 */     if (pixels[0] > corners[0] / 3.0F)
> /* 304 */       pixels[0] = corners[0] / 3.0F; 
> /* 305 */     if (pixels[width - 1] > corners[1] / 3.0F)
> /* 306 */       pixels[width - 1] = corners[1] / 3.0F; 
> /* 307 */     if (pixels[(height - 1) * width] > corners[2] / 3.0F)
> /* 308 */       pixels[(height - 1) * width] = corners[2] / 3.0F; 
> /* 309 */     if (pixels[width * height - 1] > corners[3] / 3.0F) {
> /* 310 */       pixels[width * height - 1] = corners[3] / 3.0F;
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void rollingBallFloatBackground(FloatProcessor fp, float radius, boolean invert, boolean doPresmooth, RollingBall ball) {
> /* 321 */     float[] pixels = (float[])fp.getPixels();
> /* 322 */     boolean shrink = (ball.shrinkFactor > 1);
> /*     */     
> /* 324 */     showProgress(0.0D);
> /* 325 */     if (invert)
> /* 326 */       for (int i = 0; i < pixels.length; i++)
> /* 327 */         pixels[i] = -pixels[i];  
> /* 328 */     if (doPresmooth)
> /* 329 */       filter3x3(fp, 1); 
> /* 330 */     double[] minmax = Tools.getMinMax(pixels);
> /* 331 */     if (Thread.currentThread().isInterrupted())
> /*     */       return; 
> /* 333 */     FloatProcessor smallImage = shrink ? shrinkImage(fp, ball.shrinkFactor) : fp;
> /* 334 */     if (Thread.currentThread().isInterrupted())
> /*     */       return; 
> /* 336 */     rollBall(ball, smallImage);
> /* 337 */     if (Thread.currentThread().isInterrupted())
> /*     */       return; 
> /* 339 */     showProgress(0.9D);
> /* 340 */     if (shrink)
> /* 341 */       enlargeImage(smallImage, fp, ball.shrinkFactor); 
> /* 342 */     if (Thread.currentThread().isInterrupted()) {
> /*     */       return;
> /*     */     }
> /* 345 */     if (invert)
> /* 346 */       for (int i = 0; i < pixels.length; i++)
> /* 347 */         pixels[i] = -pixels[i];  
> /* 348 */     this.pass++;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   FloatProcessor shrinkImage(FloatProcessor ip, int shrinkFactor) {
> /* 353 */     int width = ip.getWidth();
> /* 354 */     int height = ip.getHeight();
> /* 355 */     float[] pixels = (float[])ip.getPixels();
> /* 356 */     int sWidth = (width + shrinkFactor - 1) / shrinkFactor;
> /* 357 */     int sHeight = (height + shrinkFactor - 1) / shrinkFactor;
> /* 358 */     showProgress(0.1D);
> /* 359 */     FloatProcessor smallImage = new FloatProcessor(sWidth, sHeight);
> /* 360 */     float[] sPixels = (float[])smallImage.getPixels();
> /*     */     
> /* 362 */     for (int ySmall = 0; ySmall < sHeight; ySmall++) {
> /* 363 */       for (int xSmall = 0; xSmall < sWidth; xSmall++) {
> /* 364 */         float min = Float.MAX_VALUE;
> /* 365 */         for (int j = 0, y = shrinkFactor * ySmall; j < shrinkFactor && y < height; j++, y++) {
> /* 366 */           for (int k = 0, x = shrinkFactor * xSmall; k < shrinkFactor && x < width; k++, x++) {
> /* 367 */             float thispixel = pixels[x + y * width];
> /* 368 */             if (thispixel < min)
> /* 369 */               min = thispixel; 
> /*     */           } 
> /*     */         } 
> /* 372 */         sPixels[xSmall + ySmall * sWidth] = min;
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 376 */     return smallImage;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void rollBall(RollingBall ball, FloatProcessor fp) {
> /* 393 */     float[] pixels = (float[])fp.getPixels();
> /* 394 */     int width = fp.getWidth();
> /* 395 */     int height = fp.getHeight();
> /* 396 */     float[] zBall = ball.data;
> /* 397 */     int ballWidth = ball.width;
> /* 398 */     int radius = ballWidth / 2;
> /* 399 */     float[] cache = new float[width * ballWidth];
> /*     */     
> /* 401 */     Thread thread = Thread.currentThread();
> /* 402 */     long lastTime = System.currentTimeMillis();
> /* 403 */     for (int y = -radius; y < height + radius; y++) {
> /* 404 */       long time = System.currentTimeMillis();
> /* 405 */       if (time - lastTime > 100L) {
> /* 406 */         lastTime = time;
> /* 407 */         if (thread.isInterrupted())
> /*     */           return; 
> /* 409 */         showProgress(0.1D + 0.8D * y / (height + ballWidth));
> /*     */       } 
> /* 411 */       int nextLineToWriteInCache = (y + radius) % ballWidth;
> /* 412 */       int nextLineToRead = y + radius;
> /* 413 */       if (nextLineToRead < height) {
> /* 414 */         System.arraycopy(pixels, nextLineToRead * width, cache, nextLineToWriteInCache * width, width);
> /* 415 */         for (int i = 0, p = nextLineToRead * width; i < width; i++, p++)
> /* 416 */           pixels[p] = -3.4028235E38F; 
> /*     */       } 
> /* 418 */       int y0 = y - radius;
> /* 419 */       if (y0 < 0)
> /* 420 */         y0 = 0; 
> /* 421 */       int yBall0 = y0 - y + radius;
> /* 422 */       int yend = y + radius;
> /* 423 */       if (yend >= height)
> /* 424 */         yend = height - 1; 
> /* 425 */       for (int x = -radius; x < width + radius; x++) {
> /* 426 */         float z = Float.MAX_VALUE;
> /* 427 */         int x0 = x - radius;
> /* 428 */         if (x0 < 0)
> /* 429 */           x0 = 0; 
> /* 430 */         int xBall0 = x0 - x + radius;
> /* 431 */         int xend = x + radius;
> /* 432 */         if (xend >= width)
> /* 433 */           xend = width - 1;  int yp, yBall;
> /* 434 */         for (yp = y0, yBall = yBall0; yp <= yend; yp++, yBall++) {
> /* 435 */           int cachePointer = yp % ballWidth * width + x0;
> /* 436 */           for (int xp = x0, bp = xBall0 + yBall * ballWidth; xp <= xend; xp++, cachePointer++, bp++) {
> /* 437 */             float zReduced = cache[cachePointer] - zBall[bp];
> /* 438 */             if (z > zReduced)
> /* 439 */               z = zReduced; 
> /*     */           } 
> /*     */         } 
> /* 442 */         for (yp = y0, yBall = yBall0; yp <= yend; yp++, yBall++) {
> /* 443 */           int xp = x0, p = xp + yp * width;
> /* 444 */           int bp = xBall0 + yBall * ballWidth; for (; xp <= xend; xp++, p++, bp++) {
> /* 445 */             float zMin = z + zBall[bp];
> /* 446 */             if (pixels[p] < zMin) {
> /* 447 */               pixels[p] = zMin;
> /*     */             }
> /*     */           } 
> /*     */         } 
> /*     */       } 
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void enlargeImage(FloatProcessor smallImage, FloatProcessor fp, int shrinkFactor) {
> /* 463 */     int width = fp.getWidth();
> /* 464 */     int height = fp.getHeight();
> /* 465 */     int smallWidth = smallImage.getWidth();
> /* 466 */     int smallHeight = smallImage.getHeight();
> /* 467 */     float[] pixels = (float[])fp.getPixels();
> /* 468 */     float[] sPixels = (float[])smallImage.getPixels();
> /* 469 */     int[] xSmallIndices = new int[width];
> /* 470 */     float[] xWeights = new float[width];
> /* 471 */     makeInterpolationArrays(xSmallIndices, xWeights, width, smallWidth, shrinkFactor);
> /* 472 */     int[] ySmallIndices = new int[height];
> /* 473 */     float[] yWeights = new float[height];
> /* 474 */     makeInterpolationArrays(ySmallIndices, yWeights, height, smallHeight, shrinkFactor);
> /* 475 */     float[] line0 = new float[width];
> /* 476 */     float[] line1 = new float[width];
> /* 477 */     for (int x = 0; x < width; x++)
> /* 478 */       line1[x] = sPixels[xSmallIndices[x]] * xWeights[x] + sPixels[xSmallIndices[x] + 1] * (1.0F - xWeights[x]); 
> /* 479 */     int ySmallLine0 = -1;
> /* 480 */     for (int y = 0; y < height; y++) {
> /* 481 */       if (ySmallLine0 < ySmallIndices[y]) {
> /* 482 */         float[] swap = line0;
> /* 483 */         line0 = line1;
> /* 484 */         line1 = swap;
> /* 485 */         ySmallLine0++;
> /* 486 */         int sYPointer = (ySmallIndices[y] + 1) * smallWidth;
> /* 487 */         for (int j = 0; j < width; j++)
> /* 488 */           line1[j] = sPixels[sYPointer + xSmallIndices[j]] * xWeights[j] + 
> /* 489 */             sPixels[sYPointer + xSmallIndices[j] + 1] * (1.0F - xWeights[j]); 
> /*     */       } 
> /* 491 */       float weight = yWeights[y];
> /* 492 */       for (int i = 0, p = y * width; i < width; i++, p++) {
> /* 493 */         pixels[p] = line0[i] * weight + line1[i] * (1.0F - weight);
> /*     */       }
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void makeInterpolationArrays(int[] smallIndices, float[] weights, int length, int smallLength, int shrinkFactor) {
> /* 510 */     for (int i = 0; i < length; i++) {
> /* 511 */       int smallIndex = (i - shrinkFactor / 2) / shrinkFactor;
> /* 512 */       if (smallIndex >= smallLength - 1)
> /* 513 */         smallIndex = smallLength - 2; 
> /* 514 */       smallIndices[i] = smallIndex;
> /* 515 */       float distance = (i + 0.5F) / shrinkFactor - smallIndex + 0.5F;
> /*     */       
> /* 517 */       weights[i] = 1.0F - distance;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   double filter3x3(FloatProcessor fp, int type) {
> /* 529 */     int width = fp.getWidth();
> /* 530 */     int height = fp.getHeight();
> /* 531 */     double shiftBy = 0.0D;
> /* 532 */     float[] pixels = (float[])fp.getPixels();
> /* 533 */     for (int y = 0; y < height; y++)
> /* 534 */       shiftBy += filter3(pixels, width, y * width, 1, type); 
> /* 535 */     for (int x = 0; x < width; x++)
> /* 536 */       shiftBy += filter3(pixels, height, x, width, type); 
> /* 537 */     return shiftBy / width / height;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   double filter3(float[] pixels, int length, int pixel0, int inc, int type) {
> /* 542 */     double shiftBy = 0.0D;
> /* 543 */     float v3 = pixels[pixel0];
> /* 544 */     float v2 = v3;
> /*     */     
> /* 546 */     for (int i = 0, p = pixel0; i < length; i++, p += inc) {
> /* 547 */       float v1 = v2;
> /* 548 */       v2 = v3;
> /* 549 */       if (i < length - 1)
> /* 550 */         v3 = pixels[p + inc]; 
> /* 551 */       if (type == 0) {
> /* 552 */         float max = (v1 > v3) ? v1 : v3;
> /* 553 */         if (v2 > max)
> /* 554 */           max = v2; 
> /* 555 */         shiftBy += (max - v2);
> /* 556 */         pixels[p] = max;
> /*     */       } else {
> /* 558 */         pixels[p] = (v1 + v2 + v3) * 0.33333334F;
> /*     */       } 
> /* 560 */     }  return shiftBy;
> /*     */   }
> /*     */   
> /*     */   public void setNPasses(int nPasses) {
> /* 564 */     if (this.isRGB && this.separateColors)
> /* 565 */       nPasses *= 3; 
> /* 566 */     if (this.useParaboloid)
> /* 567 */       nPasses *= this.doPresmooth ? 11 : 9; 
> /* 568 */     this.nPasses = nPasses;
> /* 569 */     this.pass = 0;
> /*     */   }
> /*     */   
> /*     */   private void showProgress(double percent) {
> /* 573 */     if (this.nPasses <= 0)
> /*     */       return; 
> /* 575 */     percent = this.pass / this.nPasses + percent / this.nPasses;
> /* 576 */     IJ.showProgress(percent);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/BackgroundSubtracter.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/checkable/CheckableItem.java jd-gui/checkable/CheckableItem.java
1c1,24
< package checkable;
---
> /*    */ package checkable;
> /*    */ 
> /*    */ public class CheckableItem {
> /*    */   public final String text;
> /*    */   private boolean selected;
> /*    */   
> /*    */   public CheckableItem(String text, boolean selected) {
> /*  8 */     this.text = text;
> /*  9 */     this.selected = selected;
> /*    */   }
> /*    */   
> /*    */   public boolean isSelected() {
> /* 13 */     return this.selected;
> /*    */   }
> /*    */   
> /*    */   public void setSelected(boolean selected) {
> /* 17 */     this.selected = selected;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String toString() {
> /* 22 */     return this.text;
> /*    */   }
> /*    */ }
3,5d25
< public class CheckableItem {
<    public final String text;
<    private boolean selected;
7,23c27,30
<    public CheckableItem(String text, boolean selected) {
<       this.text = text;
<       this.selected = selected;
<    }
< 
<    public boolean isSelected() {
<       return this.selected;
<    }
< 
<    public void setSelected(boolean selected) {
<       this.selected = selected;
<    }
< 
<    public String toString() {
<       return this.text;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/checkable/CheckableItem.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/checkable/CheckBoxCellRenderer.java jd-gui/checkable/CheckBoxCellRenderer.java
1c1,43
< package checkable;
---
> /*    */ package checkable;
> /*    */ 
> /*    */ import java.awt.Component;
> /*    */ import java.util.Objects;
> /*    */ import java.util.stream.Collectors;
> /*    */ import java.util.stream.IntStream;
> /*    */ import javax.swing.JCheckBox;
> /*    */ import javax.swing.JLabel;
> /*    */ import javax.swing.JList;
> /*    */ import javax.swing.ListCellRenderer;
> /*    */ import javax.swing.ListModel;
> /*    */ 
> /*    */ class CheckBoxCellRenderer<E extends CheckableItem>
> /*    */   implements ListCellRenderer<E> {
> /* 15 */   private final JLabel label = new JLabel(" ");
> /* 16 */   private final JCheckBox check = new JCheckBox(" ");
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public Component getListCellRendererComponent(JList<? extends E> list, E value, int index, boolean isSelected, boolean cellHasFocus) {
> /* 21 */     if (index < 0) {
> /* 22 */       String txt = getCheckedItemString((ListModel)list.getModel());
> /* 23 */       this.label.setText(txt.isEmpty() ? " " : txt);
> /* 24 */       return this.label;
> /*    */     } 
> /* 26 */     this.check.setText(Objects.toString(value, ""));
> /* 27 */     this.check.setSelected(value.isSelected());
> /* 28 */     if (isSelected) {
> /* 29 */       this.check.setBackground(list.getSelectionBackground());
> /* 30 */       this.check.setForeground(list.getSelectionForeground());
> /*    */     } else {
> /* 32 */       this.check.setBackground(list.getBackground());
> /* 33 */       this.check.setForeground(list.getForeground());
> /*    */     } 
> /* 35 */     return this.check;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   private <E extends CheckableItem> String getCheckedItemString(ListModel<E> model) {
> /* 40 */     return IntStream.range(0, model.getSize()).mapToObj(model::getElementAt).filter(CheckableItem::isSelected)
> /* 41 */       .map(Objects::toString).sorted().collect(Collectors.joining(", "));
> /*    */   }
> /*    */ }
3,11d44
< import java.awt.Component;
< import java.util.Objects;
< import java.util.stream.Collectors;
< import java.util.stream.IntStream;
< import javax.swing.JCheckBox;
< import javax.swing.JLabel;
< import javax.swing.JList;
< import javax.swing.ListCellRenderer;
< import javax.swing.ListModel;
13,42c46,49
< class CheckBoxCellRenderer<E extends CheckableItem> implements ListCellRenderer<E> {
<    private final JLabel label = new JLabel(" ");
<    private final JCheckBox check = new JCheckBox(" ");
< 
<    public Component getListCellRendererComponent(JList<? extends E> list, E value, int index, boolean isSelected, boolean cellHasFocus) {
<       if (index < 0) {
<          String txt = this.getCheckedItemString(list.getModel());
<          this.label.setText(txt.isEmpty() ? " " : txt);
<          return this.label;
<       } else {
<          this.check.setText(Objects.toString(value, ""));
<          this.check.setSelected(value.isSelected());
<          if (isSelected) {
<             this.check.setBackground(list.getSelectionBackground());
<             this.check.setForeground(list.getSelectionForeground());
<          } else {
<             this.check.setBackground(list.getBackground());
<             this.check.setForeground(list.getForeground());
<          }
< 
<          return this.check;
<       }
<    }
< 
<    private <E extends CheckableItem> String getCheckedItemString(ListModel<E> model) {
<       IntStream var10000 = IntStream.range(0, model.getSize());
<       model.getClass();
<       return (String)var10000.mapToObj(model::getElementAt).filter(CheckableItem::isSelected).map(Objects::toString).sorted().collect(Collectors.joining(", "));
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/checkable/CheckBoxCellRenderer.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/checkable/CheckedComboBox.java jd-gui/checkable/CheckedComboBox.java
1,72c1,83
< package checkable;
< 
< import java.awt.Dimension;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import javax.accessibility.Accessible;
< import javax.swing.AbstractAction;
< import javax.swing.ComboBoxModel;
< import javax.swing.JComboBox;
< import javax.swing.KeyStroke;
< import javax.swing.ListCellRenderer;
< import javax.swing.plaf.basic.ComboPopup;
< 
< public class CheckedComboBox<E extends CheckableItem> extends JComboBox<E> {
<    private boolean keepOpen;
<    private transient ActionListener listener;
< 
<    public CheckedComboBox() {
<    }
< 
<    public CheckedComboBox(ComboBoxModel<E> model) {
<       super(model);
<    }
< 
<    public Dimension getPreferredSize() {
<       return new Dimension(200, 20);
<    }
< 
<    public void updateUI() {
<       this.setRenderer((ListCellRenderer)null);
<       this.removeActionListener(this.listener);
<       super.updateUI();
<       this.listener = (e) -> {
<          if (((long)e.getModifiers() & 16L) != 0L) {
<             this.updateItem(this.getSelectedIndex());
<             this.keepOpen = true;
<          }
< 
<       };
<       this.setRenderer(new CheckBoxCellRenderer());
<       this.addActionListener(this.listener);
<       this.getInputMap(0).put(KeyStroke.getKeyStroke(32, 0), "checkbox-select");
<       this.getActionMap().put("checkbox-select", new AbstractAction() {
<          public void actionPerformed(ActionEvent e) {
<             Accessible a = CheckedComboBox.this.getAccessibleContext().getAccessibleChild(0);
<             if (a instanceof ComboPopup) {
<                CheckedComboBox.this.updateItem(((ComboPopup)a).getList().getSelectedIndex());
<             }
< 
<          }
<       });
<    }
< 
<    public void updateItem(int index) {
<       if (this.isPopupVisible()) {
<          E item = (CheckableItem)this.getItemAt(index);
<          item.setSelected(!item.isSelected());
<          this.setSelectedIndex(-1);
<          this.setSelectedItem(item);
<       }
< 
<    }
< 
<    public void setPopupVisible(boolean v) {
<       if (this.keepOpen) {
<          this.keepOpen = false;
<       } else {
<          super.setPopupVisible(v);
<       }
< 
<    }
< }
---
> /*    */ package checkable;
> /*    */ 
> /*    */ import java.awt.Dimension;
> /*    */ import java.awt.event.ActionEvent;
> /*    */ import java.awt.event.ActionListener;
> /*    */ import javax.accessibility.Accessible;
> /*    */ import javax.swing.AbstractAction;
> /*    */ import javax.swing.ComboBoxModel;
> /*    */ import javax.swing.JComboBox;
> /*    */ import javax.swing.KeyStroke;
> /*    */ import javax.swing.ListCellRenderer;
> /*    */ import javax.swing.plaf.basic.ComboPopup;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class CheckedComboBox<E extends CheckableItem>
> /*    */   extends JComboBox<E>
> /*    */ {
> /*    */   private boolean keepOpen;
> /*    */   private transient ActionListener listener;
> /*    */   
> /*    */   public CheckedComboBox() {}
> /*    */   
> /*    */   public CheckedComboBox(ComboBoxModel<E> model) {
> /* 27 */     super(model);
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public Dimension getPreferredSize() {
> /* 32 */     return new Dimension(200, 20);
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void updateUI() {
> /* 37 */     setRenderer((ListCellRenderer<? super E>)null);
> /* 38 */     removeActionListener(this.listener);
> /* 39 */     super.updateUI();
> /* 40 */     this.listener = (e -> {
> /*    */         if ((e.getModifiers() & 0x10L) != 0L) {
> /*    */           updateItem(getSelectedIndex());
> /*    */           this.keepOpen = true;
> /*    */         } 
> /*    */       });
> /* 46 */     setRenderer(new CheckBoxCellRenderer<>());
> /* 47 */     addActionListener(this.listener);
> /* 48 */     getInputMap(0).put(KeyStroke.getKeyStroke(32, 0), "checkbox-select");
> /* 49 */     getActionMap().put("checkbox-select", new AbstractAction()
> /*    */         {
> /*    */           public void actionPerformed(ActionEvent e) {
> /* 52 */             Accessible a = CheckedComboBox.this.getAccessibleContext().getAccessibleChild(0);
> /* 53 */             if (a instanceof ComboPopup) {
> /* 54 */               CheckedComboBox.this.updateItem(((ComboPopup)a).getList().getSelectedIndex());
> /*    */             }
> /*    */           }
> /*    */         });
> /*    */   }
> /*    */   
> /*    */   public void updateItem(int index) {
> /* 61 */     if (isPopupVisible()) {
> /* 62 */       CheckableItem checkableItem = (CheckableItem)getItemAt(index);
> /* 63 */       checkableItem.setSelected(!checkableItem.isSelected());
> /* 64 */       setSelectedIndex(-1);
> /* 65 */       setSelectedItem(checkableItem);
> /*    */     } 
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setPopupVisible(boolean v) {
> /* 71 */     if (this.keepOpen) {
> /* 72 */       this.keepOpen = false;
> /*    */     } else {
> /* 74 */       super.setPopupVisible(v);
> /*    */     } 
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/checkable/CheckedComboBox.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/Chemotaxis_ToolModified.java jd-gui/Chemotaxis_ToolModified.java
1,1004c1,1032
< import ij.IJ;
< import ij.WindowManager;
< import ij.gui.Plot;
< import ij.gui.PlotWindow;
< import ij.measure.ResultsTable;
< import ij.plugin.PlugIn;
< import java.awt.Color;
< import java.awt.Window;
< import java.awt.event.WindowEvent;
< import java.awt.geom.Point2D;
< import java.io.File;
< import java.io.FileNotFoundException;
< import java.io.IOException;
< import java.util.ArrayList;
< import java.util.Collections;
< import java.util.Hashtable;
< import java.util.LinkedList;
< import java.util.Vector;
< import javax.swing.JFrame;
< import javax.swing.JOptionPane;
< import javax.swing.JTabbedPane;
< import javax.swing.event.ChangeEvent;
< 
< public class Chemotaxis_ToolModified implements PlugIn {
<    ChemotaxisGUI gui;
<    ScalingDialog _dialog;
<    float[][] x_values;
<    float[][] y_values;
<    float _angleBetweenCircle;
<    float _angleBetweenDiagram;
<    ArrayList _openInfoWindows;
<    ArrayList _selectedDatasets;
<    ArrayList _currentOpenWindows;
<    ArrayList _currentOpenDiagrams;
<    Vector _maxVector;
<    int _maxPosition;
<    float _anglePosition;
<    int _currentSelectedDataset;
<    ArrayList _variableSliceNumber;
<    ArrayList _importedData;
<    Hashtable _hashSliceNumber;
<    LinkedList _listArrayList;
<    Hashtable _hashImportedDataset;
<    Hashtable _hashSlicesImported;
<    Hashtable _hashTracks;
<    Hashtable _hashCurrentDataset;
<    Hashtable _hashCurrentPosition;
<    Hashtable _hashPlot;
<    Hashtable _hashWindow;
<    float _coordSize;
<    float _calxy;
<    double _timeInterval;
<    String _unitsPath;
<    String _unitsTime;
<    int _plotHeight;
<    int _plotWidth;
<    ArrayList arrayToImport;
< 
<    public Chemotaxis_ToolModified(ArrayList arrayToImport) {
<       this.arrayToImport = arrayToImport;
<       this.gui = null;
<       this._dialog = null;
<       this._angleBetweenCircle = 66.0F;
<       this._angleBetweenDiagram = 66.0F;
<       this._maxVector = null;
<       this._maxPosition = 0;
<       this._anglePosition = 0.0F;
<       this._variableSliceNumber = null;
<       this._coordSize = 0.0F;
<       this._calxy = 1.0F;
<       this._timeInterval = 2.0D;
<    }
< 
<    public void run(String var1) {
<       PlotWindow.plotHeight = 500;
<       PlotWindow.plotWidth = 500;
<       this._plotHeight = 500;
<       this._plotWidth = 500;
<       (this._dialog = new ScalingDialog(this.gui)).setHeight(this._plotHeight);
<       this._dialog.setWidth(this._plotWidth);
<       this._openInfoWindows = new ArrayList();
<       this._hashImportedDataset = new Hashtable();
<       this._hashSlicesImported = new Hashtable();
<       this._hashTracks = new Hashtable();
<       this._hashCurrentDataset = new Hashtable();
<       this._hashCurrentPosition = new Hashtable();
<       this._hashPlot = new Hashtable();
<       this._hashWindow = new Hashtable();
<       this._currentOpenWindows = new ArrayList();
<       this._currentOpenDiagrams = new ArrayList();
<       this._importedData = new ArrayList();
<       this._hashSliceNumber = new Hashtable();
<       this._selectedDatasets = new ArrayList();
<       this._listArrayList = new LinkedList();
<       this._maxVector = new Vector();
<       this._selectedDatasets.clear();
<       this._hashSlicesImported.clear();
<       this._hashImportedDataset.clear();
<       this._importedData.clear();
<       this._hashSliceNumber.clear();
<       this._listArrayList.clear();
<       this._hashTracks.clear();
<       this._hashCurrentDataset.clear();
<       this._hashCurrentPosition.clear();
<       this._hashPlot.clear();
<       this._hashWindow.clear();
< 
<       try {
<          this.readData("prueba2.xls");
<       } catch (IOException var42) {
<          JOptionPane.showMessageDialog(this.gui, "Error reading from file");
<       }
< 
<       boolean b4 = true;
<       String item = "1: prueba2.xls";
<       ArrayList list16;
<       ArrayList value7;
<       if (this._hashSlicesImported.containsKey("1: prueba2.xls")) {
<          list16 = (ArrayList)this._hashSlicesImported.get("1: prueba2.xls");
<          if (list16.size() == 1) {
<             try {
<                list16 = new ArrayList();
<                this._hashSlicesImported.remove("1: prueba2.xls");
<                list16.add(1);
<                list16.add(SPTBatch_.imps.getStackSize());
<                if (Integer.valueOf(SPTBatch_.imps.getStackSize()) < Integer.valueOf("1")) {
<                   JOptionPane.showMessageDialog(this.gui, "Second value can`t be smaller than the first");
<                } else {
<                   this._hashSlicesImported.put("1: prueba2.xls", list16);
<                }
<             } catch (NumberFormatException var41) {
<                this.gui.firstSlicesField.setText("0");
<                this.gui.secondSlicesField.setText("0");
<                list16.add(new Integer(0));
<                list16.add(new Integer(0));
<                this._hashSlicesImported.put("1: prueba2.xls", list16);
<                JOptionPane.showMessageDialog(this.gui, "Please enter correct value for number of slices!");
<             }
<          }
< 
<          if (list16.size() == 2) {
<             try {
<                if (1 != list16.get(0) || SPTBatch_.imps.getStackSize() != list16.get(1)) {
<                   this._hashSlicesImported.remove("1: prueba2.xls");
<                   value7 = new ArrayList();
<                   value7.add(Integer.valueOf("1"));
<                   value7.add(SPTBatch_.imps.getStackSize());
<                   if (Integer.valueOf(SPTBatch_.imps.getStackSize()) < Integer.valueOf("1.0")) {
<                      JOptionPane.showMessageDialog(this.gui, "Second value can`t be smaller than the first");
<                   } else {
<                      this._hashSlicesImported.put("1: prueba2.xls", value7);
<                   }
<                }
<             } catch (NumberFormatException var43) {
<                ArrayList<Integer> list17 = (ArrayList)this._hashSlicesImported.get("1: prueba2.xls");
<                JOptionPane.showMessageDialog(this.gui, "Setting old values!");
<             }
<          }
<       } else {
<          try {
<             list16 = new ArrayList();
<             list16.add(Integer.valueOf("1"));
<             list16.add(SPTBatch_.imps.getStackSize());
<             if (Integer.valueOf(SPTBatch_.imps.getStackSize()) < Integer.valueOf("1")) {
<                b4 = false;
<                JOptionPane.showMessageDialog(this.gui, "Second value can`t be smaller than the first");
<             } else {
<                this._hashSlicesImported.put("1: prueba2.xls", list16);
<             }
<          } catch (NumberFormatException var40) {
<             b4 = false;
<             JOptionPane.showMessageDialog(this.gui, "Please enter correct value for number of slices!");
<          }
<       }
< 
<       boolean b5 = true;
<       this._maxVector.clear();
<       value7 = new ArrayList();
<       String s20 = "1: prueba2.xls";
<       if (!value7.contains("1: prueba2.xls")) {
<          value7.add("1: prueba2.xls");
<       }
< 
<       this._unitsPath = "m";
<       this._unitsTime = "min";
<       int intValue31 = false;
<       int intValue32 = false;
<       int n68 = false;
<       double n69 = 0.0D;
<       double doubleValue = 0.0D;
<       int n70 = false;
<       double n71 = 0.0D;
<       double doubleValue2 = 0.0D;
<       this._calxy = new Float(1.0D);
<       this._timeInterval = new Double(1.0D);
<       b5 = true;
<       int n72;
<       String s10;
<       ArrayList list20;
<       int intValue16;
<       ArrayList list14;
<       ArrayList list23;
<       ArrayList list15;
<       int n94;
<       int n13;
<       int index27;
<       int index21;
<       int intValue30;
<       int index28;
<       int intValue44;
<       int n93;
<       if (b5) {
<          this._listArrayList.clear();
<          this._hashCurrentDataset.clear();
<          this._hashSliceNumber.clear();
< 
<          for(n72 = 0; n72 < value7.size(); ++n72) {
<             this._variableSliceNumber = new ArrayList();
<             s10 = (String)value7.get(n72);
<             this._hashCurrentDataset.put(new Integer(n72), s10);
<             this._hashCurrentPosition.put(s10, new Integer(n72));
<             list20 = (ArrayList)this._hashSlicesImported.get(s10);
<             intValue16 = (Integer)this._hashImportedDataset.get(s10);
<             list14 = new ArrayList();
<             ArrayList<Float> list22 = new ArrayList();
<             list23 = new ArrayList();
<             list15 = (ArrayList)this._importedData.get(intValue16 - 1);
< 
<             for(n94 = 0; n94 < list15.size(); n94 += 4) {
<                list14.add(list15.get(n94));
<                list22.add((Float)list15.get(n94 + 2));
<                list23.add((Float)list15.get(n94 + 3));
<             }
< 
<             n94 = Math.round((Float)list14.get(list14.size() - 1));
<             int[] array70 = new int[3 * n94];
<             n13 = 1;
< 
<             for(index27 = 0; index27 <= 3 * n94 - 3; index27 += 3) {
<                array70[index27] = list14.indexOf(new Float((float)n13));
<                array70[index27 + 1] = list14.lastIndexOf(new Float((float)n13));
<                array70[index27 + 2] = n13++;
<             }
< 
<             ArrayList<Float> list25 = new ArrayList();
<             ArrayList<Float> list26 = new ArrayList();
<             int n75 = 0;
<             if (list20.size() == 1) {
<                index21 = (Integer)list20.get(0);
< 
<                for(intValue30 = 0; intValue30 <= array70.length - 3; intValue30 += 3) {
<                   if (array70[intValue30 + 1] != -1 && array70[intValue30] != -1 && array70[intValue30 + 1] - array70[intValue30] == index21 - 1) {
<                      ++n75;
<                      this._variableSliceNumber.add(new Integer(array70[intValue30 + 1] - array70[intValue30] + 1));
< 
<                      for(index28 = array70[intValue30]; index28 <= array70[intValue30 + 1]; ++index28) {
<                         list25.add(new Float((Float)list22.get(index28) * this._calxy));
<                         list26.add(new Float((Float)list23.get(index28) * this._calxy));
<                      }
<                   }
<                }
<             }
< 
<             if (list20.size() == 2) {
<                index21 = (Integer)list20.get(0);
<                intValue30 = (Integer)list20.get(1);
< 
<                for(index28 = 0; index28 <= array70.length - 3; index28 += 3) {
<                   if (array70[index28 + 1] != -1 && array70[index28] != -1 && array70[index28 + 1] - array70[index28] >= index21 - 1 && array70[index28 + 1] - array70[index28] <= intValue30 - 1) {
<                      ++n75;
<                      this._variableSliceNumber.add(new Integer(array70[index28 + 1] - array70[index28] + 1));
< 
<                      for(intValue44 = array70[index28]; intValue44 <= array70[index28 + 1]; ++intValue44) {
<                         list25.add(new Float((Float)list22.get(intValue44) * this._calxy));
<                         list26.add(new Float((Float)list23.get(intValue44) * this._calxy));
<                      }
<                   }
<                }
<             }
< 
<             this.updateNumberofTracks(s10, n75);
<             if (this._variableSliceNumber.isEmpty()) {
<                if (list20.size() == 1) {
<                   JOptionPane.showMessageDialog(this.gui, "No tracks available for current number of slices");
<                }
< 
<                if (list20.size() == 2) {
<                   JOptionPane.showMessageDialog(this.gui, "No tracks available for current range of used number of slices");
<                }
<             } else {
<                index21 = (Integer)Collections.max(this._variableSliceNumber);
<                intValue30 = 0;
<                this.x_values = new float[n75][index21];
<                this.y_values = new float[n75][index21];
< 
<                for(index28 = 0; index28 < n75; ++index28) {
<                   this.x_values[index28][0] = 0.0F;
<                   this.y_values[index28][0] = 0.0F;
<                   intValue44 = 1;
< 
<                   for(n93 = (Integer)this._variableSliceNumber.get(index28); intValue44 < n93; ++intValue44) {
<                      float n90 = (Float)list25.get(intValue44 + intValue30) - (Float)list25.get(intValue30);
<                      float n91 = -((Float)list26.get(intValue44 + intValue30) - (Float)list26.get(intValue30));
<                      this.x_values[index28][intValue44] = n90;
<                      this.y_values[index28][intValue44] = n91;
<                   }
< 
<                   intValue30 += n93;
<                }
< 
<                this._listArrayList.add(this.x_values);
<                this._listArrayList.add(this.y_values);
<                this._hashSliceNumber.put(new Integer(n72), this._variableSliceNumber);
<             }
<          }
<       }
< 
<       int n65;
<       float[][] array16;
<       float[][] array13;
<       ResultsTable resultsTable3;
<       String[] array11;
<       int intValue29;
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          n65 = (Integer)Collections.max(list20);
<          array16 = (float[][])this._listArrayList.get(n72);
<          array13 = (float[][])this._listArrayList.get(n72 + 1);
<          resultsTable3 = new ResultsTable();
<          array11 = new String[]{"Slice", "Center of mass x [" + this._unitsPath + "]", "Center of mass y [" + this._unitsPath + "]", "Center of mass length [" + this._unitsPath + "]"};
< 
<          for(intValue29 = 0; intValue29 < array11.length; ++intValue29) {
<             resultsTable3.setHeading(intValue29, array11[intValue29]);
<          }
< 
<          for(intValue29 = 1; intValue29 <= n65; ++intValue29) {
<             double[] centerofMassSeries = ChemotaxisStatistic.centerofMassSeries(intValue29, array16, array13, intValue16, list20);
<             resultsTable3.incrementCounter();
<             resultsTable3.addValue(0, (double)intValue29);
<             resultsTable3.addValue(1, centerofMassSeries[0]);
<             resultsTable3.addValue(2, centerofMassSeries[1]);
<             resultsTable3.addValue(3, centerofMassSeries[2]);
<          }
< 
<          resultsTable3.save(SPTBatch_.directChemo + File.separator + "Center of mass series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       double n9;
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)Collections.max(list20);
<          n65 = (Integer)this._hashTracks.get(s10);
<          array16 = (float[][])this._listArrayList.get(n72);
<          array13 = (float[][])this._listArrayList.get(n72 + 1);
<          resultsTable3 = new ResultsTable();
<          array11 = new String[]{"Slice", "Directionality"};
< 
<          for(intValue29 = 0; intValue29 < array11.length; ++intValue29) {
<             resultsTable3.setHeading(intValue29, array11[intValue29]);
<          }
< 
<          for(intValue29 = 1; intValue29 <= intValue16; ++intValue29) {
<             n9 = ChemotaxisStatistic.computeChemotaxisIndex(array16, array13, intValue29, n65, list20);
<             resultsTable3.incrementCounter();
<             resultsTable3.addValue(0, (double)intValue29);
<             resultsTable3.addValue(1, n9);
<          }
< 
<          resultsTable3.save(SPTBatch_.directChemo + File.separator + "Directionality series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          n65 = (Integer)Collections.max(list20);
<          array16 = (float[][])this._listArrayList.get(n72);
<          array13 = (float[][])this._listArrayList.get(n72 + 1);
<          resultsTable3 = new ResultsTable();
<          array11 = new String[]{"Slice", "x FMI", "y FMI"};
< 
<          for(intValue29 = 0; intValue29 < array11.length; ++intValue29) {
<             resultsTable3.setHeading(intValue29, array11[intValue29]);
<          }
< 
<          for(intValue29 = 1; intValue29 <= n65; ++intValue29) {
<             n9 = ChemotaxisStatistic.computeFMIIndex(array16, array13, intValue29, intValue16, 1, list20);
<             double computeFMIIndex2 = ChemotaxisStatistic.computeFMIIndex(array16, array13, intValue29, intValue16, 2, list20);
<             resultsTable3.incrementCounter();
<             resultsTable3.addValue(0, (double)intValue29);
<             resultsTable3.addValue(1, computeFMIIndex2);
<             resultsTable3.addValue(2, n9);
<          }
< 
<          resultsTable3.save(SPTBatch_.directChemo + File.separator + "FMI index series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       float[][] array15;
<       float roundFloatNumbers2;
<       float roundFloatNumbers3;
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          array15 = (float[][])this._listArrayList.get(n72);
<          array16 = (float[][])this._listArrayList.get(n72 + 1);
<          list23 = ChemotaxisStatistic.computeDirectionality(array15, array16, list20, intValue16);
<          resultsTable3 = new ResultsTable();
<          array11 = new String[]{"Track Number", "Directionality", "Endpoint X Value", "Endpoint Y Value"};
< 
<          for(intValue29 = 0; intValue29 < array11.length; ++intValue29) {
<             resultsTable3.setHeading(intValue29, array11[intValue29]);
<          }
< 
<          for(intValue29 = 0; intValue29 < intValue16; ++intValue29) {
<             n13 = (Integer)list20.get(intValue29);
<             roundFloatNumbers2 = array15[intValue29][n13 - 1];
<             roundFloatNumbers3 = array16[intValue29][n13 - 1];
<             resultsTable3.incrementCounter();
<             resultsTable3.addValue(0, (double)(intValue29 + 1));
<             resultsTable3.addValue(1, (Double)list23.get(intValue29));
<             resultsTable3.addValue(2, (double)new Float(roundFloatNumbers2));
<             resultsTable3.addValue(3, (double)new Float(roundFloatNumbers3));
<          }
< 
<          resultsTable3.save(SPTBatch_.directChemo + File.separator + "Directionality track series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       int intValue43;
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          array15 = (float[][])this._listArrayList.get(n72);
<          array16 = (float[][])this._listArrayList.get(n72 + 1);
<          ResultsTable resultsTable5 = new ResultsTable();
<          String[] array17 = new String[]{"Track Number", "x FMI", "y FMI", "Endpoint X Value", "Endpoint Y Value"};
< 
<          for(n94 = 0; n94 < array17.length; ++n94) {
<             resultsTable5.setHeading(n94, array17[n94]);
<          }
< 
<          for(n94 = 0; n94 < intValue16; ++n94) {
<             intValue29 = (Integer)list20.get(n94);
<             n9 = 0.0D;
< 
<             for(intValue43 = 0; intValue43 < intValue29 - 1; ++intValue43) {
<                n9 += Point2D.distance((double)new Float(array15[n94][intValue43]), (double)new Float(array16[n94][intValue43]), (double)new Float(array15[n94][intValue43 + 1]), (double)new Float(array16[n94][intValue43 + 1]));
<             }
< 
<             roundFloatNumbers3 = array16[n94][intValue29 - 1];
<             float value4 = array15[n94][intValue29 - 1];
<             double roundDoubleNumbers = this.roundDoubleNumbers((double)value4 / n9);
<             double roundDoubleNumbers2 = this.roundDoubleNumbers((double)roundFloatNumbers3 / n9);
<             resultsTable5.incrementCounter();
<             resultsTable5.addValue(0, (double)(n94 + 1));
<             resultsTable5.addValue(1, roundDoubleNumbers);
<             resultsTable5.addValue(2, roundDoubleNumbers2);
<             resultsTable5.addValue(3, (double)new Float(value4));
<             resultsTable5.addValue(4, (double)new Float(roundFloatNumbers3));
<          }
< 
<          resultsTable5.save(SPTBatch_.directChemo + File.separator + "FMI track series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       float abs;
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          list14 = ChemotaxisStatistic.computeDistandVelocity("velocity", (float[][])this._listArrayList.get(n72), (float[][])this._listArrayList.get(n72 + 1), list20, intValue16, this._timeInterval);
<          ResultsTable resultsTable6 = new ResultsTable();
<          String[] array18 = new String[]{"Track Number", "Velocity [" + this._unitsPath + "/" + this._unitsTime + "]"};
< 
<          int index9;
<          for(index9 = 0; index9 < array18.length; ++index9) {
<             resultsTable6.setHeading(index9, array18[index9]);
<          }
< 
<          for(index9 = 0; index9 < intValue16; ++index9) {
<             abs = this.roundFloatNumbers(Float.valueOf(list14.get(index9).toString()));
<             resultsTable6.incrementCounter();
<             resultsTable6.addValue(0, (double)(index9 + 1));
<             resultsTable6.addValue(1, (double)abs);
<          }
< 
<          resultsTable6.save(SPTBatch_.directChemo + File.separator + "Velocity series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       for(n72 = 0; n72 < this._listArrayList.size(); n72 += 2) {
<          s10 = (String)this._hashCurrentDataset.get(new Integer(n72 / 2));
<          list20 = (ArrayList)this._hashSliceNumber.get(new Integer(n72 / 2));
<          intValue16 = (Integer)this._hashTracks.get(s10);
<          array15 = (float[][])this._listArrayList.get(n72);
<          array16 = (float[][])this._listArrayList.get(n72 + 1);
<          list23 = ChemotaxisStatistic.computeDistandVelocity("accumulated distance", array15, array16, list20, intValue16, this._timeInterval);
<          list15 = ChemotaxisStatistic.computeDistandVelocity("euclid distance", array15, array16, list20, intValue16, this._timeInterval);
<          ResultsTable resultsTable7 = new ResultsTable();
<          String[] array21 = new String[]{"Track Number", "Accumulated distance [" + this._unitsPath + "]", "Euclidean distance [" + this._unitsPath + "]"};
< 
<          for(n13 = 0; n13 < array21.length; ++n13) {
<             resultsTable7.setHeading(n13, array21[n13]);
<          }
< 
<          for(n13 = 0; n13 < intValue16; ++n13) {
<             roundFloatNumbers2 = this.roundFloatNumbers(Float.valueOf(list23.get(n13).toString()));
<             roundFloatNumbers3 = this.roundFloatNumbers(Float.valueOf(list15.get(n13).toString()));
<             resultsTable7.incrementCounter();
<             resultsTable7.addValue(0, (double)(n13 + 1));
<             resultsTable7.addValue(1, (double)roundFloatNumbers2);
<             resultsTable7.addValue(2, (double)roundFloatNumbers3);
<          }
< 
<          resultsTable7.save(SPTBatch_.directChemo + File.separator + "Distance series for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       }
< 
<       String s18 = "1: prueba2.xls";
<       int intValue27 = (Integer)this._hashImportedDataset.get("1: prueba2.xls");
<       ResultsTable resultsTable13 = new ResultsTable();
<       String[] array66 = new String[]{"Track n", "Slice n", "X", "Y"};
< 
<       for(n65 = 0; n65 < array66.length; ++n65) {
<          resultsTable13.setHeading(n65, array66[n65]);
<       }
< 
<       list14 = (ArrayList)this._importedData.get(intValue27 - 1);
< 
<       for(int index19 = 0; index19 < list14.size(); index19 += 4) {
<          resultsTable13.incrementCounter();
<          resultsTable13.addValue(0, (double)(Float)list14.get(index19));
<          resultsTable13.addValue(1, (double)(Float)list14.get(index19 + 1));
<          resultsTable13.addValue(2, (double)(Float)list14.get(index19 + 2));
<          resultsTable13.addValue(3, (double)(Float)list14.get(index19 + 3));
<       }
< 
<       resultsTable13.save(SPTBatch_.directChemo + File.separator + "Original data for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       String s19 = "1: prueba2.xls";
<       if (this._hashCurrentDataset.contains("1: prueba2.xls")) {
<          int intValue28 = (Integer)this._hashCurrentPosition.get("1: prueba2.xls");
<          list15 = (ArrayList)this._hashSliceNumber.get(new Integer(intValue28));
<          n94 = intValue28 * 2;
<          intValue29 = (Integer)this._hashTracks.get("1: prueba2.xls");
<          float[][] array67 = (float[][])this._listArrayList.get(n94);
<          float[][] array68 = (float[][])this._listArrayList.get(n94 + 1);
<          ResultsTable resultsTable14 = new ResultsTable();
<          String[] array69 = new String[]{"Track n", "Slice n", "X [" + this._unitsPath + "]", "Y [" + this._unitsPath + "]"};
< 
<          for(index21 = 0; index21 < array69.length; ++index21) {
<             resultsTable14.setHeading(index21, array69[index21]);
<          }
< 
<          for(index21 = 0; index21 < intValue29; ++index21) {
<             intValue30 = (Integer)list15.get(index21);
< 
<             for(index28 = 0; index28 < intValue30; ++index28) {
<                resultsTable14.incrementCounter();
<                resultsTable14.addValue(0, (double)new Integer(index21 + 1));
<                resultsTable14.addValue(1, (double)new Integer(index28 + 1));
<                resultsTable14.addValue(2, (double)new Float(array67[index21][index28]));
<                resultsTable14.addValue(3, (double)new Float(array68[index21][index28]));
<             }
<          }
< 
<          resultsTable14.save(SPTBatch_.directChemo + File.separator + "Current used data for " + SPTBatch_.imps.getShortTitle() + ".xls");
<       } else {
<          JOptionPane.showMessageDialog(this.gui, "No current data available!");
<       }
< 
<       this._hashPlot.clear();
<       int n92 = 0;
<       String s27 = "Mark up/down";
<       if ("Mark up/down".equals("Mark up/down")) {
<          n92 = 3;
<       }
< 
<       if (this._dialog.auto) {
<          abs = 0.0F;
<          float abs2 = 0.0F;
<          if (this._listArrayList.size() > 1) {
<             ArrayList coll4 = new ArrayList();
< 
<             for(index27 = 0; index27 < this._listArrayList.size(); index27 += 2) {
<                intValue43 = (Integer)this._hashTracks.get(this._hashCurrentDataset.get(new Integer(index27 / 2)));
<                ArrayList<Integer> list27 = (ArrayList)this._hashSliceNumber.get(new Integer(index27 / 2));
<                float[][] array71 = (float[][])this._listArrayList.get(index27);
<                float[][] array72 = (float[][])this._listArrayList.get(index27 + 1);
< 
<                for(index28 = 0; index28 < intValue43; ++index28) {
<                   intValue44 = (Integer)list27.get(index28);
< 
<                   for(n93 = 1; n93 < intValue44; ++n93) {
<                      if (abs < Math.abs(array71[index28][n93])) {
<                         abs = Math.abs(array71[index28][n93]);
<                      }
< 
<                      if (abs2 < Math.abs(array72[index28][n93])) {
<                         abs2 = Math.abs(array72[index28][n93]);
<                      }
<                   }
<                }
< 
<                if (abs > abs2) {
<                   coll4.add(new Float(abs));
<                } else {
<                   coll4.add(new Float(abs2));
<                }
<             }
< 
<             this._coordSize = (Float)Collections.max(coll4) + 5.0F;
<          }
<       }
< 
<       for(n94 = 0; n94 < this._listArrayList.size(); n94 += 2) {
<          this.plotGraph(n92, n94);
<       }
< 
<    }
< 
<    float angleCorrection(float n) {
<       float n2 = n;
<       if (n < 0.0F) {
<          n2 = n % 360.0F + 360.0F;
<       }
< 
<       if (n2 > 360.0F) {
<          n2 %= 360.0F;
<       }
< 
<       return n2;
<    }
< 
<    float[] calculatePoints(float n) {
<       float n2 = this._coordSize * 2.0F;
<       return new float[]{this.roundNumber(new Float((double)n2 * Math.cos(Math.toRadians((double)n)))), this.roundNumber(new Float((double)n2 * Math.sin(Math.toRadians((double)n))))};
<    }
< 
<    int countCells(float n, int index) {
<       String key = (String)this._hashCurrentDataset.get(new Integer(index / 2));
<       ArrayList<Integer> list = (ArrayList)this._hashSliceNumber.get(new Integer(index / 2));
<       int intValue = (Integer)this._hashTracks.get(key);
<       float[][] array = (float[][])this._listArrayList.get(index);
<       float[][] array2 = (float[][])this._listArrayList.get(index + 1);
<       int n2 = 0;
<       float angleCorrection = this.angleCorrection(this._anglePosition + n / 2.0F);
<       float angleCorrection2 = this.angleCorrection(this._anglePosition - n / 2.0F);
<       float roundNumber = this.roundNumber(new Float(Math.tan(Math.toRadians((double)angleCorrection))));
<       float roundNumber2 = this.roundNumber(new Float(Math.tan(Math.toRadians((double)angleCorrection2))));
< 
<       for(int i = 0; i < intValue; ++i) {
<          int intValue2 = (Integer)list.get(i);
<          float n3 = array[i][intValue2 - 1];
<          float n4 = array2[i][intValue2 - 1];
<          if ((angleCorrection > 0.0F && angleCorrection < 90.0F && angleCorrection2 > 0.0F && angleCorrection2 < 90.0F || angleCorrection > 270.0F && angleCorrection < 360.0F && angleCorrection2 > 270.0F && angleCorrection2 < 360.0F) && n4 <= roundNumber * n3 && n4 >= roundNumber2 * n3) {
<             ++n2;
<          }
< 
<          if ((angleCorrection > 90.0F && angleCorrection < 180.0F && angleCorrection2 > 90.0F && angleCorrection2 < 180.0F || angleCorrection > 180.0F && angleCorrection < 270.0F && angleCorrection2 > 180.0F && angleCorrection2 < 270.0F) && n4 >= roundNumber * n3 && n4 <= roundNumber2 * n3) {
<             ++n2;
<          }
< 
<          if (angleCorrection > 0.0F && angleCorrection < 90.0F) {
<             if (angleCorrection2 > 180.0F && angleCorrection2 < 270.0F && n4 <= roundNumber * n3 && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 > 270.0F && angleCorrection2 < 360.0F && n4 <= roundNumber * n3 && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 270.0F && n3 >= 0.0F && n4 <= roundNumber * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 0.0F && n4 >= 0.0F && n4 <= roundNumber * n3) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection > 90.0F && angleCorrection < 180.0F) {
<             if (angleCorrection2 > 0.0F && angleCorrection2 < 90.0F && n4 >= roundNumber * n3 && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 > 270.0F && angleCorrection2 < 360.0F && n4 >= roundNumber * n3 && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 90.0F && n3 <= 0.0F && n4 >= roundNumber * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 0.0F && n4 >= 0.0F && n4 >= roundNumber * n3) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection > 180.0F && angleCorrection < 270.0F) {
<             if (angleCorrection2 > 90.0F && angleCorrection2 < 180.0F && n4 >= roundNumber * n3 && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 > 0.0F && angleCorrection2 < 90.0F && n4 >= roundNumber * n3 && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 90.0F && n3 <= 0.0F && n4 >= roundNumber * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 180.0F && n4 <= 0.0F && n4 >= roundNumber * n3) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection > 270.0F && angleCorrection < 360.0F) {
<             if (angleCorrection2 > 180.0F && angleCorrection2 < 270.0F && n4 <= roundNumber * n3 && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 > 90.0F && angleCorrection2 < 180.0F && n4 <= roundNumber * n3 && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 180.0F && n4 <= 0.0F && n4 <= roundNumber * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 270.0F && n3 >= 0.0F && n4 <= roundNumber * n3) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection == 90.0F) {
<             if ((angleCorrection2 > 0.0F && angleCorrection2 < 90.0F || angleCorrection2 > 270.0F && angleCorrection2 < 360.0F) && n3 >= 0.0F && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 0.0F && n3 >= 0.0F && n4 >= 0.0F) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 270.0F && n3 >= 0.0F) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection == 180.0F) {
<             if ((angleCorrection2 > 0.0F && angleCorrection2 < 90.0F || angleCorrection2 > 90.0F && angleCorrection2 < 180.0F) && n4 >= 0.0F && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 0.0F && n4 >= 0.0F) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 90.0F && n3 <= 0.0F && n4 >= 0.0F) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection == 270.0F) {
<             if ((angleCorrection2 > 90.0F && angleCorrection2 < 180.0F || angleCorrection2 > 180.0F && angleCorrection2 < 270.0F) && n3 <= 0.0F && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 90.0F && n3 <= 0.0F) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 180.0F && n3 <= 0.0F && n4 <= 0.0F) {
<                ++n2;
<             }
<          }
< 
<          if (angleCorrection == 360.0F) {
<             if (angleCorrection2 > 180.0F && angleCorrection2 < 270.0F && n4 <= 0.0F && n4 <= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 > 270.0F && angleCorrection2 < 360.0F && n4 <= 0.0F && n4 >= roundNumber2 * n3) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 180.0F && n4 <= 0.0F) {
<                ++n2;
<             }
< 
<             if (angleCorrection2 == 270.0F && n3 >= 0.0F && n4 <= 0.0F) {
<                ++n2;
<             }
<          }
<       }
< 
<       return n2;
<    }
< 
<    void plotGraph(int value, int n) {
<       String s = (String)this._hashCurrentDataset.get(new Integer(n / 2));
<       ArrayList<Integer> list = (ArrayList)this._hashSliceNumber.get(new Integer(n / 2));
<       int intValue = (Integer)this._hashTracks.get(s);
<       float[][] array = (float[][])this._listArrayList.get(n);
<       float[][] array2 = (float[][])this._listArrayList.get(n + 1);
<       double roundDoubleNumbers = 0.0D;
<       double roundDoubleNumbers2 = 0.0D;
<       int i = 0;
<       int j = 0;
<       ArrayList<Double> list2 = null;
< 
<       for(int k = 0; k < intValue; ++k) {
<          int intValue2 = (Integer)list.get(k);
<          roundDoubleNumbers += (double)array[k][intValue2 - 1];
<          roundDoubleNumbers2 += (double)array2[k][intValue2 - 1];
<       }
< 
<       if (intValue != 0) {
<          roundDoubleNumbers /= (double)intValue;
<          roundDoubleNumbers2 /= (double)intValue;
<       }
< 
<       roundDoubleNumbers = this.roundDoubleNumbers(roundDoubleNumbers);
<       roundDoubleNumbers2 = this.roundDoubleNumbers(roundDoubleNumbers2);
<       float[] array3 = new float[]{0.0F};
<       Plot plot = new Plot(s, "x axis [" + this._unitsPath + "]", "y axis  [" + this._unitsPath + "]", array3, array3);
<       float[] array9;
<       float[] array10;
<       if (SPTBatch_.chemoScaling.getText().contains("...") == Boolean.TRUE) {
<          array9 = new float[]{this._coordSize, -this._coordSize};
<          array10 = new float[2];
<          plot.setLimits((double)(-this._coordSize), (double)this._coordSize, (double)(-this._coordSize), (double)this._coordSize);
<          plot.addPoints(array9, array10, 2);
<          plot.addPoints(array10, array9, 2);
<       }
< 
<       float[] array19;
<       if (SPTBatch_.chemoScaling.getText().contains("...") == Boolean.FALSE) {
<          array9 = new float[]{(float)(-Integer.valueOf(SPTBatch_.chemoScaling.getText())), (float)Integer.valueOf(SPTBatch_.chemoScaling.getText())};
<          array10 = new float[2];
<          array19 = new float[]{(float)(-Integer.valueOf(SPTBatch_.chemoScaling.getText())), (float)Integer.valueOf(SPTBatch_.chemoScaling.getText())};
<          plot.setLimits(-Double.valueOf(SPTBatch_.chemoScaling.getText()), Double.valueOf(SPTBatch_.chemoScaling.getText()), -Double.valueOf(SPTBatch_.chemoScaling.getText()), Double.valueOf(SPTBatch_.chemoScaling.getText()));
<          plot.addPoints(array9, array10, 2);
<          plot.addPoints(array10, array19, 2);
<       }
< 
<       plot.draw();
<       plot.setLineWidth(1);
<       array9 = new float[]{0.0F};
<       array10 = new float[]{0.0F};
<       if (value == 3) {
<          for(int index = 0; index < intValue; ++index) {
<             int intValue4 = (Integer)list.get(index);
<             float[] array13 = new float[intValue4];
<             float[] array14 = new float[intValue4];
<             array9[0] = array[index][intValue4 - 1];
<             array10[0] = array2[index][intValue4 - 1];
<             if (array10[0] >= 0.0F) {
<                plot.setColor(Color.black);
<                ++i;
<             } else {
<                plot.setColor(Color.red);
<                ++j;
<             }
< 
<             for(int n3 = 0; n3 < intValue4; ++n3) {
<                array13[n3] = array[index][n3];
<                array14[n3] = array2[index][n3];
<             }
< 
<             plot.setLineWidth(1);
<             plot.addPoints(array13, array14, 2);
<             plot.setLineWidth(3);
<             plot.addPoints(array9, array10, 0);
<          }
< 
<          plot.setColor(Color.black);
<          plot.addLabel(0.0D, 0.0D, "Number of tracks: " + intValue + "  Counts up: " + i + "  Counts down: " + j);
<          plot.addLabel(0.0D, 0.04D, "Center of mass [" + this._unitsPath + "]: x=" + roundDoubleNumbers + " y=" + roundDoubleNumbers2);
<       }
< 
<       array19 = new float[]{new Float(roundDoubleNumbers)};
<       float[] array20 = new float[]{new Float(roundDoubleNumbers2)};
<       plot.setColor(Color.blue);
<       plot.setLineWidth(3);
<       plot.addPoints(array19, array20, 5);
<       this._currentOpenWindows.size();
<       int var10000 = this._listArrayList.size() / 2;
<       ArrayList<Integer> value2 = new ArrayList();
<       value2.add(new Integer(value));
<       value2.add(new Integer(n));
<       value2.add(new Integer(intValue));
<       this._hashPlot.put(s, value2);
<       IJ.save(plot.getImagePlus(), SPTBatch_.directChemo + File.separator + "Chemotaxis Plot for " + SPTBatch_.imps.getShortTitle() + ".png");
<    }
< 
<    void readData(String string) throws FileNotFoundException, IOException {
<       this._importedData.add(this.arrayToImport);
<       IJ.showStatus("Dataset imported");
<       string = this._importedData.size() + ": " + string;
<       this._hashImportedDataset.put(string, new Integer(this._importedData.size()));
<    }
< 
<    double roundDoubleNumbers(double n) {
<       return (double)Math.round(n * 100.0D) / 100.0D;
<    }
< 
<    float roundFloatNumbers(float n) {
<       return (float)Math.round(n * 100.0F) / 100.0F;
<    }
< 
<    float roundNumber(float n) {
<       return (float)Math.round(n * 10000.0F) / 10000.0F;
<    }
< 
<    public void stateChanged(ChangeEvent changeEvent) {
<       int selectedIndex = ((JTabbedPane)changeEvent.getSource()).getSelectedIndex();
<       if (selectedIndex == 1) {
<          if (this._dialog.auto) {
<             PlotWindow.plotHeight = this._plotHeight;
<             PlotWindow.plotWidth = this._plotWidth;
<          } else {
<             PlotWindow.plotHeight = (int)(this._dialog.fraction * (double)(Math.abs(this._dialog.minimumY) + Math.abs(this._dialog.maximumY)));
<             PlotWindow.plotWidth = (int)(this._dialog.fraction * (double)(Math.abs(this._dialog.minimumX) + Math.abs(this._dialog.maximumX)));
<          }
<       }
< 
<       if (selectedIndex == 3) {
<          PlotWindow.plotHeight = this._plotHeight;
<          PlotWindow.plotWidth = this._plotWidth;
<       }
< 
<    }
< 
<    void updateNumberofTracks(String s, int n) {
<       if (this._hashTracks.containsKey(s)) {
<          this._hashTracks.remove(s);
<          this._hashTracks.put(s, new Integer(n));
<       } else {
<          this._hashTracks.put(s, new Integer(n));
<       }
< 
<    }
< 
<    public void windowActivated(WindowEvent windowEvent) {
<    }
< 
<    public void windowClosed(WindowEvent windowEvent) {
<    }
< 
<    public void windowClosing(WindowEvent windowEvent) {
<       int k;
<       if (windowEvent.getSource() == this.gui) {
<          if (this._openInfoWindows != null) {
<             for(k = 0; k < this._openInfoWindows.size(); ++k) {
<                ((JFrame)this._openInfoWindows.get(k)).dispose();
<             }
< 
<             this._openInfoWindows.clear();
<          }
< 
<          this._currentOpenWindows.clear();
<          this._currentOpenDiagrams.clear();
<          WindowManager.closeAllWindows();
<          this.gui.dispose();
<       } else {
<          if (windowEvent.getSource() instanceof JFrame && this._openInfoWindows.contains(windowEvent.getSource())) {
<             this._openInfoWindows.remove(windowEvent.getSource());
<          }
< 
<          if (windowEvent.getSource() instanceof PlotWindow) {
<             if (this._currentOpenWindows.contains(windowEvent.getSource())) {
<                for(k = 0; k < this._currentOpenWindows.size(); ++k) {
<                   ((Window)this._currentOpenWindows.get(k)).dispose();
<                }
< 
<                this._currentOpenWindows.clear();
<                this.gui.plotClosed();
<             }
< 
<             if (this._currentOpenDiagrams.contains(windowEvent.getSource())) {
<                for(k = 0; k < this._currentOpenDiagrams.size(); ++k) {
<                   ((Window)this._currentOpenDiagrams.get(k)).dispose();
<                }
< 
<                this._currentOpenDiagrams.clear();
<             }
<          }
<       }
< 
<    }
< 
<    public void windowDeactivated(WindowEvent windowEvent) {
<    }
< 
<    public void windowDeiconified(WindowEvent windowEvent) {
<    }
< 
<    public void windowIconified(WindowEvent windowEvent) {
<    }
< 
<    public void windowOpened(WindowEvent windowEvent) {
<    }
< }
---
> /*      */ import ij.IJ;
> /*      */ import ij.WindowManager;
> /*      */ import ij.gui.Plot;
> /*      */ import ij.gui.PlotWindow;
> /*      */ import ij.measure.ResultsTable;
> /*      */ import ij.plugin.PlugIn;
> /*      */ import java.awt.Color;
> /*      */ import java.awt.Component;
> /*      */ import java.awt.Window;
> /*      */ import java.awt.event.WindowEvent;
> /*      */ import java.awt.geom.Point2D;
> /*      */ import java.io.File;
> /*      */ import java.io.FileNotFoundException;
> /*      */ import java.io.IOException;
> /*      */ import java.util.ArrayList;
> /*      */ import java.util.Collections;
> /*      */ import java.util.Hashtable;
> /*      */ import java.util.LinkedList;
> /*      */ import java.util.Vector;
> /*      */ import javax.swing.JFrame;
> /*      */ import javax.swing.JOptionPane;
> /*      */ import javax.swing.JTabbedPane;
> /*      */ import javax.swing.event.ChangeEvent;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ public class Chemotaxis_ToolModified
> /*      */   implements PlugIn
> /*      */ {
> /*      */   ChemotaxisGUI gui;
> /*      */   ScalingDialog _dialog;
> /*      */   float[][] x_values;
> /*      */   float[][] y_values;
> /*      */   float _angleBetweenCircle;
> /*      */   float _angleBetweenDiagram;
> /*      */   ArrayList _openInfoWindows;
> /*      */   ArrayList _selectedDatasets;
> /*      */   ArrayList _currentOpenWindows;
> /*      */   ArrayList _currentOpenDiagrams;
> /*      */   Vector _maxVector;
> /*      */   int _maxPosition;
> /*      */   float _anglePosition;
> /*      */   int _currentSelectedDataset;
> /*      */   ArrayList _variableSliceNumber;
> /*      */   ArrayList _importedData;
> /*      */   Hashtable _hashSliceNumber;
> /*      */   LinkedList _listArrayList;
> /*      */   Hashtable _hashImportedDataset;
> /*      */   Hashtable _hashSlicesImported;
> /*      */   Hashtable _hashTracks;
> /*      */   Hashtable _hashCurrentDataset;
> /*      */   Hashtable _hashCurrentPosition;
> /*      */   Hashtable _hashPlot;
> /*      */   Hashtable _hashWindow;
> /*      */   float _coordSize;
> /*      */   float _calxy;
> /*      */   double _timeInterval;
> /*      */   String _unitsPath;
> /*      */   String _unitsTime;
> /*      */   int _plotHeight;
> /*      */   int _plotWidth;
> /*      */   ArrayList arrayToImport;
> /*      */   
> /*      */   public Chemotaxis_ToolModified(ArrayList arrayToImport) {
> /*   90 */     this.arrayToImport = arrayToImport;
> /*   91 */     this.gui = null;
> /*   92 */     this._dialog = null;
> /*   93 */     this._angleBetweenCircle = 66.0F;
> /*   94 */     this._angleBetweenDiagram = 66.0F;
> /*   95 */     this._maxVector = null;
> /*   96 */     this._maxPosition = 0;
> /*   97 */     this._anglePosition = 0.0F;
> /*   98 */     this._variableSliceNumber = null;
> /*   99 */     this._coordSize = 0.0F;
> /*  100 */     this._calxy = 1.0F;
> /*  101 */     this._timeInterval = 2.0D;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void run(String var1) {
> /*  106 */     PlotWindow.plotHeight = 500;
> /*  107 */     PlotWindow.plotWidth = 500;
> /*  108 */     this._plotHeight = 500;
> /*  109 */     this._plotWidth = 500;
> /*  110 */     (this._dialog = new ScalingDialog(this.gui)).setHeight(this._plotHeight);
> /*  111 */     this._dialog.setWidth(this._plotWidth);
> /*  112 */     this._openInfoWindows = new ArrayList();
> /*  113 */     this._hashImportedDataset = new Hashtable<>();
> /*  114 */     this._hashSlicesImported = new Hashtable<>();
> /*  115 */     this._hashTracks = new Hashtable<>();
> /*  116 */     this._hashCurrentDataset = new Hashtable<>();
> /*  117 */     this._hashCurrentPosition = new Hashtable<>();
> /*  118 */     this._hashPlot = new Hashtable<>();
> /*  119 */     this._hashWindow = new Hashtable<>();
> /*  120 */     this._currentOpenWindows = new ArrayList();
> /*  121 */     this._currentOpenDiagrams = new ArrayList();
> /*  122 */     this._importedData = new ArrayList();
> /*  123 */     this._hashSliceNumber = new Hashtable<>();
> /*  124 */     this._selectedDatasets = new ArrayList();
> /*  125 */     this._listArrayList = new LinkedList();
> /*  126 */     this._maxVector = new Vector();
> /*  127 */     this._selectedDatasets.clear();
> /*  128 */     this._hashSlicesImported.clear();
> /*  129 */     this._hashImportedDataset.clear();
> /*  130 */     this._importedData.clear();
> /*  131 */     this._hashSliceNumber.clear();
> /*  132 */     this._listArrayList.clear();
> /*  133 */     this._hashTracks.clear();
> /*  134 */     this._hashCurrentDataset.clear();
> /*  135 */     this._hashCurrentPosition.clear();
> /*  136 */     this._hashPlot.clear();
> /*  137 */     this._hashWindow.clear();
> /*      */     
> /*      */     try {
> /*  140 */       readData("prueba2.xls");
> /*  141 */     } catch (IOException ex5) {
> /*  142 */       JOptionPane.showMessageDialog((Component)this.gui, "Error reading from file");
> /*      */     } 
> /*      */     
> /*  145 */     boolean b4 = true;
> /*  146 */     String item = "1: prueba2.xls";
> /*      */     
> /*  148 */     if (this._hashSlicesImported.containsKey("1: prueba2.xls")) {
> /*      */       
> /*  150 */       ArrayList<Integer> list16 = (ArrayList)this._hashSlicesImported.get("1: prueba2.xls");
> /*  151 */       if (list16.size() == 1) {
> /*      */         
> /*      */         try {
> /*  154 */           list16 = new ArrayList();
> /*  155 */           this._hashSlicesImported.remove("1: prueba2.xls");
> /*  156 */           list16.add(Integer.valueOf(1));
> /*  157 */           list16.add(Integer.valueOf(SPTBatch_.imps.getStackSize()));
> /*  158 */           if (Integer.valueOf(SPTBatch_.imps.getStackSize()).intValue() < Integer.valueOf("1").intValue()) {
> /*  159 */             JOptionPane.showMessageDialog((Component)this.gui, "Second value can`t be smaller than the first");
> /*      */           } else {
> /*  161 */             this._hashSlicesImported.put("1: prueba2.xls", list16);
> /*      */           } 
> /*  163 */         } catch (NumberFormatException ex12) {
> /*  164 */           this.gui.firstSlicesField.setText("0");
> /*  165 */           this.gui.secondSlicesField.setText("0");
> /*  166 */           list16.add(new Integer(0));
> /*  167 */           list16.add(new Integer(0));
> /*  168 */           this._hashSlicesImported.put("1: prueba2.xls", list16);
> /*  169 */           JOptionPane.showMessageDialog((Component)this.gui, "Please enter correct value for number of slices!");
> /*      */         } 
> /*      */       }
> /*  172 */       if (list16.size() == 2) {
> /*      */         
> /*      */         try {
> /*  175 */           if (Integer.valueOf(1) != list16.get(0) || 
> /*  176 */             Integer.valueOf(SPTBatch_.imps.getStackSize()) != list16.get(1)) {
> /*  177 */             this._hashSlicesImported.remove("1: prueba2.xls");
> /*  178 */             ArrayList<Integer> value7 = new ArrayList<>();
> /*  179 */             value7.add(Integer.valueOf("1"));
> /*  180 */             value7.add(Integer.valueOf(SPTBatch_.imps.getStackSize()));
> /*  181 */             if (Integer.valueOf(SPTBatch_.imps.getStackSize()).intValue() < Integer.valueOf("1.0").intValue()) {
> /*  182 */               JOptionPane.showMessageDialog((Component)this.gui, "Second value can`t be smaller than the first");
> /*      */             } else {
> /*  184 */               this._hashSlicesImported.put("1: prueba2.xls", value7);
> /*      */             } 
> /*      */           } 
> /*  187 */         } catch (NumberFormatException ex13) {
> /*  188 */           ArrayList<Integer> list17 = (ArrayList<Integer>)this._hashSlicesImported.get("1: prueba2.xls");
> /*  189 */           JOptionPane.showMessageDialog((Component)this.gui, "Setting old values!");
> /*      */         } 
> /*      */       }
> /*      */     } else {
> /*      */ 
> /*      */       
> /*      */       try {
> /*      */         
> /*  197 */         ArrayList<Integer> value9 = new ArrayList<>();
> /*  198 */         value9.add(Integer.valueOf("1"));
> /*  199 */         value9.add(Integer.valueOf(SPTBatch_.imps.getStackSize()));
> /*  200 */         if (Integer.valueOf(SPTBatch_.imps.getStackSize()).intValue() < Integer.valueOf("1").intValue()) {
> /*  201 */           b4 = false;
> /*  202 */           JOptionPane.showMessageDialog((Component)this.gui, "Second value can`t be smaller than the first");
> /*      */         } else {
> /*  204 */           this._hashSlicesImported.put("1: prueba2.xls", value9);
> /*      */         }
> /*      */       
> /*  207 */       } catch (NumberFormatException ex14) {
> /*  208 */         b4 = false;
> /*  209 */         JOptionPane.showMessageDialog((Component)this.gui, "Please enter correct value for number of slices!");
> /*      */       } 
> /*      */     } 
> /*      */ 
> /*      */ 
> /*      */     
> /*  215 */     boolean b5 = true;
> /*  216 */     this._maxVector.clear();
> /*  217 */     ArrayList<String> list18 = new ArrayList<>();
> /*      */     
> /*  219 */     String s20 = "1: prueba2.xls";
> /*  220 */     if (!list18.contains("1: prueba2.xls")) {
> /*  221 */       list18.add("1: prueba2.xls");
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*  229 */     this._unitsPath = "m";
> /*  230 */     this._unitsTime = "min";
> /*  231 */     int intValue31 = 0;
> /*  232 */     int intValue32 = 0;
> /*  233 */     int n68 = 0;
> /*  234 */     double n69 = 0.0D;
> /*  235 */     double doubleValue = 0.0D;
> /*      */     
> /*  237 */     int n70 = 0;
> /*  238 */     double n71 = 0.0D;
> /*  239 */     double doubleValue2 = 0.0D;
> /*      */     
> /*  241 */     this._calxy = (new Float(1.0D)).floatValue();
> /*  242 */     this._timeInterval = (new Double(1.0D)).doubleValue();
> /*      */     
> /*  244 */     b5 = true;
> /*  245 */     if (b5) {
> /*      */       
> /*  247 */       this._listArrayList.clear();
> /*  248 */       this._hashCurrentDataset.clear();
> /*  249 */       this._hashSliceNumber.clear();
> /*      */       
> /*  251 */       for (int n72 = 0; n72 < list18.size(); n72++) {
> /*  252 */         this._variableSliceNumber = new ArrayList();
> /*  253 */         String s26 = list18.get(n72);
> /*  254 */         this._hashCurrentDataset.put(new Integer(n72), s26);
> /*  255 */         this._hashCurrentPosition.put(s26, new Integer(n72));
> /*  256 */         ArrayList<Integer> list20 = (ArrayList<Integer>)this._hashSlicesImported.get(s26);
> /*  257 */         int intValue35 = ((Integer)this._hashImportedDataset.get(s26)).intValue();
> /*  258 */         ArrayList<Float> list21 = new ArrayList();
> /*  259 */         ArrayList<Float> list22 = new ArrayList<>();
> /*  260 */         ArrayList<Float> list23 = new ArrayList<>();
> /*  261 */         ArrayList<Object> list24 = this._importedData.get(intValue35 - 1);
> /*  262 */         for (int index24 = 0; index24 < list24.size(); index24 += 4) {
> /*  263 */           list21.add(list24.get(index24));
> /*  264 */           list22.add((Float)list24.get(index24 + 2));
> /*  265 */           list23.add((Float)list24.get(index24 + 3));
> /*      */         } 
> /*  267 */         int intValue36 = Math.round(((Float)list21.get(list21.size() - 1)).floatValue());
> /*  268 */         int[] array70 = new int[3 * intValue36];
> /*  269 */         int n73 = 1;
> /*  270 */         for (int n74 = 0; n74 <= 3 * intValue36 - 3; n74 += 3) {
> /*  271 */           array70[n74] = list21.indexOf(new Float(n73));
> /*  272 */           array70[n74 + 1] = list21.lastIndexOf(new Float(n73));
> /*  273 */           array70[n74 + 2] = n73;
> /*  274 */           n73++;
> /*      */         } 
> /*  276 */         ArrayList<Float> list25 = new ArrayList<>();
> /*  277 */         ArrayList<Float> list26 = new ArrayList<>();
> /*  278 */         int n75 = 0;
> /*  279 */         if (list20.size() == 1) {
> /*  280 */           int intValue37 = ((Integer)list20.get(0)).intValue();
> /*  281 */           for (int n76 = 0; n76 <= array70.length - 3; n76 += 3) {
> /*  282 */             if (array70[n76 + 1] != -1 && array70[n76] != -1 && 
> /*  283 */               array70[n76 + 1] - array70[n76] == intValue37 - 1) {
> /*  284 */               n75++;
> /*  285 */               this._variableSliceNumber.add(new Integer(array70[n76 + 1] - array70[n76] + 1));
> /*  286 */               for (int n77 = array70[n76]; n77 <= array70[n76 + 1]; n77++) {
> /*  287 */                 list25.add(new Float(((Float)list22.get(n77)).floatValue() * this._calxy));
> /*  288 */                 list26.add(new Float(((Float)list23.get(n77)).floatValue() * this._calxy));
> /*      */               } 
> /*      */             } 
> /*      */           } 
> /*      */         } 
> /*  293 */         if (list20.size() == 2) {
> /*  294 */           int intValue38 = ((Integer)list20.get(0)).intValue();
> /*  295 */           int intValue39 = ((Integer)list20.get(1)).intValue();
> /*  296 */           for (int n78 = 0; n78 <= array70.length - 3; n78 += 3) {
> /*  297 */             if (array70[n78 + 1] != -1 && array70[n78] != -1 && 
> /*  298 */               array70[n78 + 1] - array70[n78] >= intValue38 - 1 && 
> /*  299 */               array70[n78 + 1] - array70[n78] <= intValue39 - 1) {
> /*  300 */               n75++;
> /*  301 */               this._variableSliceNumber.add(new Integer(array70[n78 + 1] - array70[n78] + 1));
> /*  302 */               for (int n79 = array70[n78]; n79 <= array70[n78 + 1]; n79++) {
> /*  303 */                 list25.add(new Float(((Float)list22.get(n79)).floatValue() * this._calxy));
> /*  304 */                 list26.add(new Float(((Float)list23.get(n79)).floatValue() * this._calxy));
> /*      */               } 
> /*      */             } 
> /*      */           } 
> /*      */         } 
> /*  309 */         updateNumberofTracks(s26, n75);
> /*  310 */         if (this._variableSliceNumber.isEmpty()) {
> /*  311 */           if (list20.size() == 1) {
> /*  312 */             JOptionPane.showMessageDialog((Component)this.gui, "No tracks available for current number of slices");
> /*      */           }
> /*  314 */           if (list20.size() == 2) {
> /*  315 */             JOptionPane.showMessageDialog((Component)this.gui, 
> /*  316 */                 "No tracks available for current range of used number of slices");
> /*      */           }
> /*      */         } else {
> /*  319 */           int intValue40 = ((Integer)Collections.<Integer>max(this._variableSliceNumber)).intValue();
> /*      */           
> /*  321 */           int n88 = 0;
> /*  322 */           this.x_values = new float[n75][intValue40];
> /*  323 */           this.y_values = new float[n75][intValue40];
> /*  324 */           for (int index26 = 0; index26 < n75; index26++) {
> /*  325 */             this.x_values[index26][0] = 0.0F;
> /*  326 */             this.y_values[index26][0] = 0.0F;
> /*      */ 
> /*      */             
> /*  329 */             int n89 = 1;
> /*  330 */             int intValue42 = ((Integer)this._variableSliceNumber.get(index26)).intValue(); for (; n89 < intValue42; n89++) {
> /*  331 */               float n90 = ((Float)list25.get(n89 + n88)).floatValue() - ((Float)list25.get(n88)).floatValue();
> /*  332 */               float n91 = -(((Float)list26.get(n89 + n88)).floatValue() - ((Float)list26.get(n88)).floatValue());
> /*  333 */               this.x_values[index26][n89] = n90;
> /*  334 */               this.y_values[index26][n89] = n91;
> /*      */             } 
> /*  336 */             n88 += intValue42;
> /*      */           } 
> /*      */           
> /*  339 */           this._listArrayList.add(this.x_values);
> /*  340 */           this._listArrayList.add(this.y_values);
> /*  341 */           this._hashSliceNumber.put(new Integer(n72), this._variableSliceNumber);
> /*      */         } 
> /*      */       } 
> /*      */     } 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*  349 */     for (int j = 0; j < this._listArrayList.size(); j += 2) {
> /*  350 */       String s4 = (String)this._hashCurrentDataset.get(new Integer(j / 2));
> /*  351 */       ArrayList<? extends Integer> coll = (ArrayList)this._hashSliceNumber.get(new Integer(j / 2));
> /*  352 */       int intValue5 = ((Integer)this._hashTracks.get(s4)).intValue();
> /*  353 */       int intValue6 = ((Integer)Collections.<Integer>max(coll)).intValue();
> /*  354 */       float[][] array3 = this._listArrayList.get(j);
> /*  355 */       float[][] array4 = this._listArrayList.get(j + 1);
> /*  356 */       ResultsTable resultsTable = new ResultsTable();
> /*  357 */       String[] array5 = { "Slice", "Center of mass x [" + this._unitsPath + "]", 
> /*  358 */           "Center of mass y [" + this._unitsPath + "]", "Center of mass length [" + this._unitsPath + "]" };
> /*  359 */       for (int k = 0; k < array5.length; k++) {
> /*  360 */         resultsTable.setHeading(k, array5[k]);
> /*      */       }
> /*  362 */       for (int l = 1; l <= intValue6; l++) {
> /*  363 */         double[] centerofMassSeries = ChemotaxisStatistic.centerofMassSeries(l, array3, array4, intValue5, 
> /*  364 */             coll);
> /*  365 */         resultsTable.incrementCounter();
> /*  366 */         resultsTable.addValue(0, l);
> /*  367 */         resultsTable.addValue(1, centerofMassSeries[0]);
> /*  368 */         resultsTable.addValue(2, centerofMassSeries[1]);
> /*  369 */         resultsTable.addValue(3, centerofMassSeries[2]);
> /*      */       } 
> /*      */       
> /*  372 */       resultsTable.save(SPTBatch_.directChemo + File.separator + "Center of mass series for " + 
> /*  373 */           SPTBatch_.imps.getShortTitle() + ".xls");
> /*      */     } 
> /*      */ 
> /*      */     
> /*  377 */     for (int index3 = 0; index3 < this._listArrayList.size(); index3 += 2) {
> /*  378 */       String s5 = (String)this._hashCurrentDataset.get(new Integer(index3 / 2));
> /*  379 */       ArrayList<? extends Integer> coll2 = (ArrayList)this._hashSliceNumber.get(new Integer(index3 / 2));
> /*  380 */       int intValue7 = ((Integer)Collections.<Integer>max(coll2)).intValue();
> /*  381 */       int intValue8 = ((Integer)this._hashTracks.get(s5)).intValue();
> /*  382 */       float[][] array6 = this._listArrayList.get(index3);
> /*  383 */       float[][] array7 = this._listArrayList.get(index3 + 1);
> /*  384 */       ResultsTable resultsTable2 = new ResultsTable();
> /*  385 */       String[] array8 = { "Slice", "Directionality" };
> /*  386 */       for (int n2 = 0; n2 < array8.length; n2++) {
> /*  387 */         resultsTable2.setHeading(n2, array8[n2]);
> /*      */       }
> /*  389 */       for (int n3 = 1; n3 <= intValue7; n3++) {
> /*  390 */         double computeChemotaxisIndex = ChemotaxisStatistic.computeChemotaxisIndex(array6, array7, n3, 
> /*  391 */             intValue8, coll2);
> /*  392 */         resultsTable2.incrementCounter();
> /*  393 */         resultsTable2.addValue(0, n3);
> /*  394 */         resultsTable2.addValue(1, computeChemotaxisIndex);
> /*      */       } 
> /*      */       
> /*  397 */       resultsTable2.save(SPTBatch_.directChemo + File.separator + "Directionality series for " + 
> /*  398 */           SPTBatch_.imps.getShortTitle() + ".xls");
> /*      */     } 
> /*      */     
> /*  401 */     for (int index5 = 0; index5 < this._listArrayList.size(); index5 += 2) {
> /*  402 */       String s7 = (String)this._hashCurrentDataset.get(new Integer(index5 / 2));
> /*  403 */       ArrayList<? extends Integer> coll3 = (ArrayList)this._hashSliceNumber.get(new Integer(index5 / 2));
> /*  404 */       int intValue11 = ((Integer)this._hashTracks.get(s7)).intValue();
> /*  405 */       int intValue12 = ((Integer)Collections.<Integer>max(coll3)).intValue();
> /*  406 */       float[][] array12 = this._listArrayList.get(index5);
> /*  407 */       float[][] array13 = this._listArrayList.get(index5 + 1);
> /*  408 */       ResultsTable resultsTable4 = new ResultsTable();
> /*  409 */       String[] array14 = { "Slice", "x FMI", "y FMI" };
> /*  410 */       for (int n6 = 0; n6 < array14.length; n6++) {
> /*  411 */         resultsTable4.setHeading(n6, array14[n6]);
> /*      */       }
> /*  413 */       for (int n7 = 1; n7 <= intValue12; n7++) {
> /*  414 */         double computeFMIIndex = ChemotaxisStatistic.computeFMIIndex(array12, array13, n7, intValue11, 1, 
> /*  415 */             coll3);
> /*  416 */         double computeFMIIndex2 = ChemotaxisStatistic.computeFMIIndex(array12, array13, n7, intValue11, 2, 
> /*  417 */             coll3);
> /*  418 */         resultsTable4.incrementCounter();
> /*  419 */         resultsTable4.addValue(0, n7);
> /*  420 */         resultsTable4.addValue(1, computeFMIIndex2);
> /*  421 */         resultsTable4.addValue(2, computeFMIIndex);
> /*      */       } 
> /*      */       
> /*  424 */       resultsTable4.save(SPTBatch_.directChemo + File.separator + "FMI index series for " + 
> /*  425 */           SPTBatch_.imps.getShortTitle() + ".xls");
> /*      */     } 
> /*      */ 
> /*      */ 
> /*      */     
> /*  430 */     for (int index4 = 0; index4 < this._listArrayList.size(); index4 += 2) {
> /*  431 */       String s6 = (String)this._hashCurrentDataset.get(new Integer(index4 / 2));
> /*  432 */       ArrayList<Integer> list3 = (ArrayList<Integer>)this._hashSliceNumber.get(new Integer(index4 / 2));
> /*  433 */       int intValue9 = ((Integer)this._hashTracks.get(s6)).intValue();
> /*  434 */       float[][] array9 = this._listArrayList.get(index4);
> /*  435 */       float[][] array10 = this._listArrayList.get(index4 + 1);
> /*  436 */       ArrayList<Double> computeDirectionality = ChemotaxisStatistic.computeDirectionality(array9, array10, list3, 
> /*  437 */           intValue9);
> /*  438 */       ResultsTable resultsTable3 = new ResultsTable();
> /*  439 */       String[] array11 = { "Track Number", "Directionality", "Endpoint X Value", "Endpoint Y Value" };
> /*  440 */       for (int n4 = 0; n4 < array11.length; n4++) {
> /*  441 */         resultsTable3.setHeading(n4, array11[n4]);
> /*      */       }
> /*  443 */       for (int n5 = 0; n5 < intValue9; n5++) {
> /*  444 */         int intValue10 = ((Integer)list3.get(n5)).intValue();
> /*  445 */         float value = array9[n5][intValue10 - 1];
> /*  446 */         float value2 = array10[n5][intValue10 - 1];
> /*  447 */         resultsTable3.incrementCounter();
> /*  448 */         resultsTable3.addValue(0, (n5 + 1));
> /*  449 */         resultsTable3.addValue(1, ((Double)computeDirectionality.get(n5)).doubleValue());
> /*  450 */         resultsTable3.addValue(2, (new Float(value)).floatValue());
> /*  451 */         resultsTable3.addValue(3, (new Float(value2)).floatValue());
> /*      */       } 
> /*      */       
> /*  454 */       resultsTable3.save(SPTBatch_.directChemo + File.separator + "Directionality track series for " + 
> /*  455 */           SPTBatch_.imps.getShortTitle() + ".xls");
> /*      */     } 
> /*      */ 
> /*      */     
> /*  459 */     for (int index6 = 0; index6 < this._listArrayList.size(); index6 += 2) {
> /*  460 */       String s8 = (String)this._hashCurrentDataset.get(new Integer(index6 / 2));
> /*  461 */       ArrayList<Integer> list4 = (ArrayList<Integer>)this._hashSliceNumber.get(new Integer(index6 / 2));
> /*  462 */       int intValue13 = ((Integer)this._hashTracks.get(s8)).intValue();
> /*  463 */       float[][] array15 = this._listArrayList.get(index6);
> /*  464 */       float[][] array16 = this._listArrayList.get(index6 + 1);
> /*  465 */       ResultsTable resultsTable5 = new ResultsTable();
> /*  466 */       String[] array17 = { "Track Number", "x FMI", "y FMI", "Endpoint X Value", "Endpoint Y Value" };
> /*  467 */       for (int n8 = 0; n8 < array17.length; n8++) {
> /*  468 */         resultsTable5.setHeading(n8, array17[n8]);
> /*      */       }
> /*  470 */       for (int index7 = 0; index7 < intValue13; index7++) {
> /*  471 */         int intValue14 = ((Integer)list4.get(index7)).intValue();
> /*  472 */         double n9 = 0.0D;
> /*  473 */         for (int n10 = 0; n10 < intValue14 - 1; n10++) {
> /*  474 */           n9 += Point2D.distance((new Float(array15[index7][n10])).floatValue(), (new Float(array16[index7][n10])).floatValue(), (
> /*  475 */               new Float(array15[index7][n10 + 1])).floatValue(), (new Float(array16[index7][n10 + 1])).floatValue());
> /*      */         }
> /*  477 */         float value3 = array16[index7][intValue14 - 1];
> /*  478 */         float value4 = array15[index7][intValue14 - 1];
> /*  479 */         double roundDoubleNumbers = roundDoubleNumbers(value4 / n9);
> /*  480 */         double roundDoubleNumbers2 = roundDoubleNumbers(value3 / n9);
> /*  481 */         resultsTable5.incrementCounter();
> /*  482 */         resultsTable5.addValue(0, (index7 + 1));
> /*  483 */         resultsTable5.addValue(1, roundDoubleNumbers);
> /*  484 */         resultsTable5.addValue(2, roundDoubleNumbers2);
> /*  485 */         resultsTable5.addValue(3, (new Float(value4)).floatValue());
> /*  486 */         resultsTable5.addValue(4, (new Float(value3)).floatValue());
> /*      */       } 
> /*      */       
> /*  489 */       resultsTable5.save(SPTBatch_.directChemo + File.separator + "FMI track series for " + 
> /*  490 */           SPTBatch_.imps.getShortTitle() + ".xls");
> /*      */     } 
> /*      */ 
> /*      */     
> /*  494 */     for (int index8 = 0; index8 < this._listArrayList.size(); index8 += 2) {
> /*  495 */       String s9 = (String)this._hashCurrentDataset.get(new Integer(index8 / 2));
> /*  496 */       ArrayList list5 = (ArrayList)this._hashSliceNumber.get(new Integer(index8 / 2));
> /*  497 */       int intValue15 = ((Integer)this._hashTracks.get(s9)).intValue();
> /*  498 */       ArrayList<E> computeDistandVelocity = ChemotaxisStatistic.computeDistandVelocity("velocity", 
> /*  499 */           this._listArrayList.get(index8), this._listArrayList.get(index8 + 1), list5, 
> /*  500 */           intValue15, this._timeInterval);
> /*  501 */       ResultsTable resultsTable6 = new ResultsTable();
> /*  502 */       String[] array18 = { "Track Number", "Velocity [" + this._unitsPath + "/" + this._unitsTime + "]" };
> /*  503 */       for (int n11 = 0; n11 < array18.length; n11++) {
> /*  504 */         resultsTable6.setHeading(n11, array18[n11]);
> /*      */       }
> /*  506 */       for (int index9 = 0; index9 < intValue15; index9++) {
> /*  507 */         float roundFloatNumbers = 
> /*  508 */           roundFloatNumbers(Float.valueOf(computeDistandVelocity.get(index9).toString()).floatValue());
> /*  509 */         resultsTable6.incrementCounter();
> /*  510 */         resultsTable6.addValue(0, (index9 + 1));
> /*  511 */         resultsTable6.addValue(1, roundFloatNumbers);
> /*      */       } 
> /*      */       
> /*  514 */       resultsTable6.save(SPTBatch_.directChemo + File.separator + "Velocity series for " + 
> /*  515 */           SPTBatch_.imps.getShortTitle() + ".xls");
> /*      */     } 
> /*      */ 
> /*      */     
> /*  519 */     for (int index10 = 0; index10 < this._listArrayList.size(); index10 += 2) {
> /*  520 */       String s10 = (String)this._hashCurrentDataset.get(new Integer(index10 / 2));
> /*  521 */       ArrayList list6 = (ArrayList)this._hashSliceNumber.get(new Integer(index10 / 2));
> /*  522 */       int intValue16 = ((Integer)this._hashTracks.get(s10)).intValue();
> /*  523 */       float[][] array19 = this._listArrayList.get(index10);
> /*  524 */       float[][] array20 = this._listArrayList.get(index10 + 1);
> /*  525 */       ArrayList<E> computeDistandVelocity2 = ChemotaxisStatistic.computeDistandVelocity("accumulated distance", 
> /*  526 */           array19, array20, list6, intValue16, this._timeInterval);
> /*  527 */       ArrayList<E> computeDistandVelocity3 = ChemotaxisStatistic.computeDistandVelocity("euclid distance", 
> /*  528 */           array19, array20, list6, intValue16, this._timeInterval);
> /*  529 */       ResultsTable resultsTable7 = new ResultsTable();
> /*  530 */       String[] array21 = { "Track Number", "Accumulated distance [" + this._unitsPath + "]", 
> /*  531 */           "Euclidean distance [" + this._unitsPath + "]" };
> /*  532 */       for (int n12 = 0; n12 < array21.length; n12++) {
> /*  533 */         resultsTable7.setHeading(n12, array21[n12]);
> /*      */       }
> /*  535 */       for (int n13 = 0; n13 < intValue16; n13++) {
> /*  536 */         float roundFloatNumbers2 = 
> /*  537 */           roundFloatNumbers(Float.valueOf(computeDistandVelocity2.get(n13).toString()).floatValue());
> /*  538 */         float roundFloatNumbers3 = 
> /*  539 */           roundFloatNumbers(Float.valueOf(computeDistandVelocity3.get(n13).toString()).floatValue());
> /*  540 */         resultsTable7.incrementCounter();
> /*  541 */         resultsTable7.addValue(0, (n13 + 1));
> /*  542 */         resultsTable7.addValue(1, roundFloatNumbers2);
> /*  543 */         resultsTable7.addValue(2, roundFloatNumbers3);
> /*      */       } 
> /*      */       
> /*  546 */       resultsTable7.save(SPTBatch_.directChemo + File.separator + "Distance series for " + 
> /*  547 */           SPTBatch_.imps.getShortTitle() + ".xls");
> /*      */     } 
> /*      */ 
> /*      */     
> /*  551 */     String s18 = "1: prueba2.xls";
> /*  552 */     int intValue27 = ((Integer)this._hashImportedDataset.get("1: prueba2.xls")).intValue();
> /*  553 */     ResultsTable resultsTable13 = new ResultsTable();
> /*  554 */     String[] array66 = { "Track n", "Slice n", "X", "Y" };
> /*  555 */     for (int n65 = 0; n65 < array66.length; n65++) {
> /*  556 */       resultsTable13.setHeading(n65, array66[n65]);
> /*      */     }
> /*  558 */     ArrayList<Float> list14 = this._importedData.get(intValue27 - 1);
> /*  559 */     for (int index19 = 0; index19 < list14.size(); index19 += 4) {
> /*  560 */       resultsTable13.incrementCounter();
> /*  561 */       resultsTable13.addValue(0, ((Float)list14.get(index19)).floatValue());
> /*  562 */       resultsTable13.addValue(1, ((Float)list14.get(index19 + 1)).floatValue());
> /*  563 */       resultsTable13.addValue(2, ((Float)list14.get(index19 + 2)).floatValue());
> /*  564 */       resultsTable13.addValue(3, ((Float)list14.get(index19 + 3)).floatValue());
> /*      */     } 
> /*      */     
> /*  567 */     resultsTable13.save(SPTBatch_.directChemo + File.separator + "Original data for " + 
> /*  568 */         SPTBatch_.imps.getShortTitle() + ".xls");
> /*      */ 
> /*      */     
> /*  571 */     String s19 = "1: prueba2.xls";
> /*  572 */     if (this._hashCurrentDataset.contains("1: prueba2.xls")) {
> /*  573 */       int intValue28 = ((Integer)this._hashCurrentPosition.get("1: prueba2.xls")).intValue();
> /*  574 */       ArrayList<Integer> list15 = (ArrayList<Integer>)this._hashSliceNumber.get(new Integer(intValue28));
> /*  575 */       int index20 = intValue28 * 2;
> /*  576 */       int intValue29 = ((Integer)this._hashTracks.get("1: prueba2.xls")).intValue();
> /*  577 */       float[][] array67 = this._listArrayList.get(index20);
> /*  578 */       float[][] array68 = this._listArrayList.get(index20 + 1);
> /*  579 */       ResultsTable resultsTable14 = new ResultsTable();
> /*  580 */       String[] array69 = { "Track n", "Slice n", "X [" + this._unitsPath + "]", 
> /*  581 */           "Y [" + this._unitsPath + "]" };
> /*  582 */       for (int n66 = 0; n66 < array69.length; n66++) {
> /*  583 */         resultsTable14.setHeading(n66, array69[n66]);
> /*      */       }
> /*  585 */       for (int index21 = 0; index21 < intValue29; index21++) {
> /*  586 */         for (int intValue30 = ((Integer)list15.get(index21)).intValue(), n67 = 0; n67 < intValue30; n67++) {
> /*  587 */           resultsTable14.incrementCounter();
> /*  588 */           resultsTable14.addValue(0, (new Integer(index21 + 1)).intValue());
> /*  589 */           resultsTable14.addValue(1, (new Integer(n67 + 1)).intValue());
> /*  590 */           resultsTable14.addValue(2, (new Float(array67[index21][n67])).floatValue());
> /*  591 */           resultsTable14.addValue(3, (new Float(array68[index21][n67])).floatValue());
> /*      */         } 
> /*      */       } 
> /*      */       
> /*  595 */       resultsTable14.save(SPTBatch_.directChemo + File.separator + "Current used data for " + 
> /*  596 */           SPTBatch_.imps.getShortTitle() + ".xls");
> /*      */     } else {
> /*  598 */       JOptionPane.showMessageDialog((Component)this.gui, "No current data available!");
> /*      */     } 
> /*      */     
> /*  601 */     this._hashPlot.clear();
> /*  602 */     int n92 = 0;
> /*  603 */     String s27 = "Mark up/down";
> /*      */     
> /*  605 */     if ("Mark up/down".equals("Mark up/down")) {
> /*  606 */       n92 = 3;
> /*      */     }
> /*      */     
> /*  609 */     if (this._dialog.auto) {
> /*  610 */       float abs = 0.0F;
> /*  611 */       float abs2 = 0.0F;
> /*  612 */       if (this._listArrayList.size() > 1) {
> /*  613 */         ArrayList<Float> coll4 = new ArrayList();
> /*  614 */         for (int index27 = 0; index27 < this._listArrayList.size(); index27 += 2) {
> /*  615 */           int intValue43 = ((Integer)this._hashTracks
> /*  616 */             .get(this._hashCurrentDataset.get(new Integer(index27 / 2)))).intValue();
> /*  617 */           ArrayList<Integer> list27 = (ArrayList<Integer>)this._hashSliceNumber
> /*  618 */             .get(new Integer(index27 / 2));
> /*  619 */           float[][] array71 = this._listArrayList.get(index27);
> /*  620 */           float[][] array72 = this._listArrayList.get(index27 + 1);
> /*  621 */           for (int index28 = 0; index28 < intValue43; index28++) {
> /*  622 */             for (int intValue44 = ((Integer)list27.get(index28)).intValue(), n93 = 1; n93 < intValue44; n93++) {
> /*  623 */               if (abs < Math.abs(array71[index28][n93])) {
> /*  624 */                 abs = Math.abs(array71[index28][n93]);
> /*      */               }
> /*  626 */               if (abs2 < Math.abs(array72[index28][n93])) {
> /*  627 */                 abs2 = Math.abs(array72[index28][n93]);
> /*      */               }
> /*      */             } 
> /*      */           } 
> /*  631 */           if (abs > abs2) {
> /*  632 */             coll4.add(new Float(abs));
> /*      */           } else {
> /*  634 */             coll4.add(new Float(abs2));
> /*      */           } 
> /*      */         } 
> /*  637 */         this._coordSize = ((Float)Collections.<Float>max(coll4)).floatValue() + 5.0F;
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  641 */     for (int n94 = 0; n94 < this._listArrayList.size(); n94 += 2) {
> /*  642 */       plotGraph(n92, n94);
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   float angleCorrection(float n) {
> /*  648 */     float n2 = n;
> /*  649 */     if (n2 < 0.0F) {
> /*  650 */       n2 = n2 % 360.0F + 360.0F;
> /*      */     }
> /*  652 */     if (n2 > 360.0F) {
> /*  653 */       n2 %= 360.0F;
> /*      */     }
> /*  655 */     return n2;
> /*      */   }
> /*      */   
> /*      */   float[] calculatePoints(float n) {
> /*  659 */     float n2 = this._coordSize * 2.0F;
> /*  660 */     return new float[] { roundNumber((new Float(n2 * Math.cos(Math.toRadians(n)))).floatValue()), 
> /*  661 */         roundNumber((new Float(n2 * Math.sin(Math.toRadians(n)))).floatValue()) };
> /*      */   }
> /*      */   
> /*      */   int countCells(float n, int index) {
> /*  665 */     String key = (String)this._hashCurrentDataset.get(new Integer(index / 2));
> /*  666 */     ArrayList<Integer> list = (ArrayList<Integer>)this._hashSliceNumber.get(new Integer(index / 2));
> /*  667 */     int intValue = ((Integer)this._hashTracks.get(key)).intValue();
> /*  668 */     float[][] array = this._listArrayList.get(index);
> /*  669 */     float[][] array2 = this._listArrayList.get(index + 1);
> /*  670 */     int n2 = 0;
> /*  671 */     float angleCorrection = angleCorrection(this._anglePosition + n / 2.0F);
> /*  672 */     float angleCorrection2 = angleCorrection(this._anglePosition - n / 2.0F);
> /*  673 */     float roundNumber = roundNumber((new Float(Math.tan(Math.toRadians(angleCorrection)))).floatValue());
> /*  674 */     float roundNumber2 = roundNumber((new Float(Math.tan(Math.toRadians(angleCorrection2)))).floatValue());
> /*  675 */     for (int i = 0; i < intValue; i++) {
> /*  676 */       int intValue2 = ((Integer)list.get(i)).intValue();
> /*  677 */       float n3 = array[i][intValue2 - 1];
> /*  678 */       float n4 = array2[i][intValue2 - 1];
> /*  679 */       if (((angleCorrection > 0.0F && angleCorrection < 90.0F && angleCorrection2 > 0.0F && 
> /*  680 */         angleCorrection2 < 90.0F) || (
> /*  681 */         angleCorrection > 270.0F && angleCorrection < 360.0F && angleCorrection2 > 270.0F && 
> /*  682 */         angleCorrection2 < 360.0F)) && 
> /*  683 */         n4 <= roundNumber * n3 && n4 >= roundNumber2 * n3) {
> /*  684 */         n2++;
> /*      */       }
> /*  686 */       if (((angleCorrection > 90.0F && angleCorrection < 180.0F && angleCorrection2 > 90.0F && 
> /*  687 */         angleCorrection2 < 180.0F) || (
> /*  688 */         angleCorrection > 180.0F && angleCorrection < 270.0F && angleCorrection2 > 180.0F && 
> /*  689 */         angleCorrection2 < 270.0F)) && 
> /*  690 */         n4 >= roundNumber * n3 && n4 <= roundNumber2 * n3) {
> /*  691 */         n2++;
> /*      */       }
> /*  693 */       if (angleCorrection > 0.0F && angleCorrection < 90.0F) {
> /*  694 */         if (angleCorrection2 > 180.0F && angleCorrection2 < 270.0F && n4 <= roundNumber * n3 && 
> /*  695 */           n4 <= roundNumber2 * n3) {
> /*  696 */           n2++;
> /*      */         }
> /*  698 */         if (angleCorrection2 > 270.0F && angleCorrection2 < 360.0F && n4 <= roundNumber * n3 && 
> /*  699 */           n4 >= roundNumber2 * n3) {
> /*  700 */           n2++;
> /*      */         }
> /*  702 */         if (angleCorrection2 == 270.0F && n3 >= 0.0F && n4 <= roundNumber * n3) {
> /*  703 */           n2++;
> /*      */         }
> /*  705 */         if (angleCorrection2 == 0.0F && n4 >= 0.0F && n4 <= roundNumber * n3) {
> /*  706 */           n2++;
> /*      */         }
> /*      */       } 
> /*  709 */       if (angleCorrection > 90.0F && angleCorrection < 180.0F) {
> /*  710 */         if (angleCorrection2 > 0.0F && angleCorrection2 < 90.0F && n4 >= roundNumber * n3 && 
> /*  711 */           n4 >= roundNumber2 * n3) {
> /*  712 */           n2++;
> /*      */         }
> /*  714 */         if (angleCorrection2 > 270.0F && angleCorrection2 < 360.0F && n4 >= roundNumber * n3 && 
> /*  715 */           n4 >= roundNumber2 * n3) {
> /*  716 */           n2++;
> /*      */         }
> /*  718 */         if (angleCorrection2 == 90.0F && n3 <= 0.0F && n4 >= roundNumber * n3) {
> /*  719 */           n2++;
> /*      */         }
> /*  721 */         if (angleCorrection2 == 0.0F && n4 >= 0.0F && n4 >= roundNumber * n3) {
> /*  722 */           n2++;
> /*      */         }
> /*      */       } 
> /*  725 */       if (angleCorrection > 180.0F && angleCorrection < 270.0F) {
> /*  726 */         if (angleCorrection2 > 90.0F && angleCorrection2 < 180.0F && n4 >= roundNumber * n3 && 
> /*  727 */           n4 <= roundNumber2 * n3) {
> /*  728 */           n2++;
> /*      */         }
> /*  730 */         if (angleCorrection2 > 0.0F && angleCorrection2 < 90.0F && n4 >= roundNumber * n3 && 
> /*  731 */           n4 >= roundNumber2 * n3) {
> /*  732 */           n2++;
> /*      */         }
> /*  734 */         if (angleCorrection2 == 90.0F && n3 <= 0.0F && n4 >= roundNumber * n3) {
> /*  735 */           n2++;
> /*      */         }
> /*  737 */         if (angleCorrection2 == 180.0F && n4 <= 0.0F && n4 >= roundNumber * n3) {
> /*  738 */           n2++;
> /*      */         }
> /*      */       } 
> /*  741 */       if (angleCorrection > 270.0F && angleCorrection < 360.0F) {
> /*  742 */         if (angleCorrection2 > 180.0F && angleCorrection2 < 270.0F && n4 <= roundNumber * n3 && 
> /*  743 */           n4 <= roundNumber2 * n3) {
> /*  744 */           n2++;
> /*      */         }
> /*  746 */         if (angleCorrection2 > 90.0F && angleCorrection2 < 180.0F && n4 <= roundNumber * n3 && 
> /*  747 */           n4 <= roundNumber2 * n3) {
> /*  748 */           n2++;
> /*      */         }
> /*  750 */         if (angleCorrection2 == 180.0F && n4 <= 0.0F && n4 <= roundNumber * n3) {
> /*  751 */           n2++;
> /*      */         }
> /*  753 */         if (angleCorrection2 == 270.0F && n3 >= 0.0F && n4 <= roundNumber * n3) {
> /*  754 */           n2++;
> /*      */         }
> /*      */       } 
> /*  757 */       if (angleCorrection == 90.0F) {
> /*  758 */         if (((angleCorrection2 > 0.0F && angleCorrection2 < 90.0F) || (
> /*  759 */           angleCorrection2 > 270.0F && angleCorrection2 < 360.0F)) && n3 >= 0.0F && 
> /*  760 */           n4 >= roundNumber2 * n3) {
> /*  761 */           n2++;
> /*      */         }
> /*  763 */         if (angleCorrection2 == 0.0F && n3 >= 0.0F && n4 >= 0.0F) {
> /*  764 */           n2++;
> /*      */         }
> /*  766 */         if (angleCorrection2 == 270.0F && n3 >= 0.0F) {
> /*  767 */           n2++;
> /*      */         }
> /*      */       } 
> /*  770 */       if (angleCorrection == 180.0F) {
> /*  771 */         if (((angleCorrection2 > 0.0F && angleCorrection2 < 90.0F) || (
> /*  772 */           angleCorrection2 > 90.0F && angleCorrection2 < 180.0F)) && n4 >= 0.0F && 
> /*  773 */           n4 <= roundNumber2 * n3) {
> /*  774 */           n2++;
> /*      */         }
> /*  776 */         if (angleCorrection2 == 0.0F && n4 >= 0.0F) {
> /*  777 */           n2++;
> /*      */         }
> /*  779 */         if (angleCorrection2 == 90.0F && n3 <= 0.0F && n4 >= 0.0F) {
> /*  780 */           n2++;
> /*      */         }
> /*      */       } 
> /*  783 */       if (angleCorrection == 270.0F) {
> /*  784 */         if (((angleCorrection2 > 90.0F && angleCorrection2 < 180.0F) || (
> /*  785 */           angleCorrection2 > 180.0F && angleCorrection2 < 270.0F)) && n3 <= 0.0F && 
> /*  786 */           n4 <= roundNumber2 * n3) {
> /*  787 */           n2++;
> /*      */         }
> /*  789 */         if (angleCorrection2 == 90.0F && n3 <= 0.0F) {
> /*  790 */           n2++;
> /*      */         }
> /*  792 */         if (angleCorrection2 == 180.0F && n3 <= 0.0F && n4 <= 0.0F) {
> /*  793 */           n2++;
> /*      */         }
> /*      */       } 
> /*  796 */       if (angleCorrection == 360.0F) {
> /*  797 */         if (angleCorrection2 > 180.0F && angleCorrection2 < 270.0F && n4 <= 0.0F && n4 <= roundNumber2 * n3) {
> /*  798 */           n2++;
> /*      */         }
> /*  800 */         if (angleCorrection2 > 270.0F && angleCorrection2 < 360.0F && n4 <= 0.0F && n4 >= roundNumber2 * n3) {
> /*  801 */           n2++;
> /*      */         }
> /*  803 */         if (angleCorrection2 == 180.0F && n4 <= 0.0F) {
> /*  804 */           n2++;
> /*      */         }
> /*  806 */         if (angleCorrection2 == 270.0F && n3 >= 0.0F && n4 <= 0.0F) {
> /*  807 */           n2++;
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*  811 */     return n2;
> /*      */   }
> /*      */   
> /*      */   void plotGraph(int value, int n) {
> /*  815 */     String s = (String)this._hashCurrentDataset.get(new Integer(n / 2));
> /*  816 */     ArrayList<Integer> list = (ArrayList<Integer>)this._hashSliceNumber.get(new Integer(n / 2));
> /*  817 */     int intValue = ((Integer)this._hashTracks.get(s)).intValue();
> /*  818 */     float[][] array = this._listArrayList.get(n);
> /*  819 */     float[][] array2 = this._listArrayList.get(n + 1);
> /*  820 */     double roundDoubleNumbers = 0.0D;
> /*  821 */     double roundDoubleNumbers2 = 0.0D;
> /*  822 */     int i = 0;
> /*  823 */     int j = 0;
> /*  824 */     ArrayList<Double> list2 = null;
> /*      */     
> /*  826 */     for (int k = 0; k < intValue; k++) {
> /*  827 */       int intValue2 = ((Integer)list.get(k)).intValue();
> /*  828 */       roundDoubleNumbers += array[k][intValue2 - 1];
> /*  829 */       roundDoubleNumbers2 += array2[k][intValue2 - 1];
> /*      */     } 
> /*  831 */     if (intValue != 0) {
> /*  832 */       roundDoubleNumbers /= intValue;
> /*  833 */       roundDoubleNumbers2 /= intValue;
> /*      */     } 
> /*  835 */     roundDoubleNumbers = roundDoubleNumbers(roundDoubleNumbers);
> /*  836 */     roundDoubleNumbers2 = roundDoubleNumbers(roundDoubleNumbers2);
> /*      */     
> /*  838 */     float[] array3 = { 0.0F };
> /*  839 */     Plot plot = new Plot(s, "x axis [" + this._unitsPath + "]", "y axis  [" + this._unitsPath + "]", array3, 
> /*  840 */         array3);
> /*  841 */     if (SPTBatch_.chemoScaling.getText().contains("...") == Boolean.TRUE.booleanValue()) {
> /*  842 */       float[] array4 = { this._coordSize, -this._coordSize };
> /*  843 */       float[] array5 = new float[2];
> /*  844 */       plot.setLimits(-this._coordSize, this._coordSize, -this._coordSize, 
> /*  845 */           this._coordSize);
> /*  846 */       plot.addPoints(array4, array5, 2);
> /*  847 */       plot.addPoints(array5, array4, 2);
> /*      */     } 
> /*  849 */     if (SPTBatch_.chemoScaling.getText().contains("...") == Boolean.FALSE.booleanValue()) {
> /*  850 */       float[] array6 = { -Integer.valueOf(SPTBatch_.chemoScaling.getText()).intValue(), 
> /*  851 */           Integer.valueOf(SPTBatch_.chemoScaling.getText()).intValue() };
> /*  852 */       float[] array7 = new float[2];
> /*  853 */       float[] array8 = { -Integer.valueOf(SPTBatch_.chemoScaling.getText()).intValue(), 
> /*  854 */           Integer.valueOf(SPTBatch_.chemoScaling.getText()).intValue() };
> /*  855 */       plot.setLimits(-Double.valueOf(SPTBatch_.chemoScaling.getText()).doubleValue(), 
> /*  856 */           Double.valueOf(SPTBatch_.chemoScaling.getText()).doubleValue(), -Double.valueOf(SPTBatch_.chemoScaling.getText()).doubleValue(), 
> /*  857 */           Double.valueOf(SPTBatch_.chemoScaling.getText()).doubleValue());
> /*  858 */       plot.addPoints(array6, array7, 2);
> /*  859 */       plot.addPoints(array7, array8, 2);
> /*      */     } 
> /*  861 */     plot.draw();
> /*  862 */     plot.setLineWidth(1);
> /*  863 */     float[] array9 = { 0.0F };
> /*  864 */     float[] array10 = { 0.0F };
> /*      */     
> /*  866 */     if (value == 3) {
> /*  867 */       for (int index = 0; index < intValue; index++) {
> /*  868 */         int intValue4 = ((Integer)list.get(index)).intValue();
> /*  869 */         float[] array13 = new float[intValue4];
> /*  870 */         float[] array14 = new float[intValue4];
> /*  871 */         array9[0] = array[index][intValue4 - 1];
> /*  872 */         array10[0] = array2[index][intValue4 - 1];
> /*  873 */         if (array10[0] >= 0.0F) {
> /*  874 */           plot.setColor(Color.black);
> /*  875 */           i++;
> /*      */         } else {
> /*  877 */           plot.setColor(Color.red);
> /*  878 */           j++;
> /*      */         } 
> /*      */         
> /*  881 */         for (int n3 = 0; n3 < intValue4; n3++) {
> /*  882 */           array13[n3] = array[index][n3];
> /*  883 */           array14[n3] = array2[index][n3];
> /*      */         } 
> /*  885 */         plot.setLineWidth(1);
> /*  886 */         plot.addPoints(array13, array14, 2);
> /*      */         
> /*  888 */         plot.setLineWidth(3);
> /*  889 */         plot.addPoints(array9, array10, 0);
> /*      */       } 
> /*  891 */       plot.setColor(Color.black);
> /*      */       
> /*  893 */       plot.addLabel(0.0D, 0.0D, "Number of tracks: " + intValue + "  Counts up: " + i + "  Counts down: " + j);
> /*      */       
> /*  895 */       plot.addLabel(0.0D, 0.04D, 
> /*  896 */           "Center of mass [" + this._unitsPath + "]: x=" + roundDoubleNumbers + " y=" + roundDoubleNumbers2);
> /*      */     } 
> /*      */ 
> /*      */     
> /*  900 */     float[] array19 = { (new Float(roundDoubleNumbers)).floatValue() };
> /*  901 */     float[] array20 = { (new Float(roundDoubleNumbers2)).floatValue() };
> /*  902 */     plot.setColor(Color.blue);
> /*  903 */     plot.setLineWidth(3);
> /*  904 */     plot.addPoints(array19, array20, 5);
> /*      */ 
> /*      */     
> /*  907 */     this._currentOpenWindows.size(); this._listArrayList.size() / 2;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*  916 */     ArrayList<Integer> value2 = new ArrayList<>();
> /*  917 */     value2.add(new Integer(value));
> /*  918 */     value2.add(new Integer(n));
> /*  919 */     value2.add(new Integer(intValue));
> /*  920 */     this._hashPlot.put(s, value2);
> /*      */ 
> /*      */ 
> /*      */     
> /*  924 */     IJ.save(plot.getImagePlus(), SPTBatch_.directChemo + File.separator + "Chemotaxis Plot for " + 
> /*  925 */         SPTBatch_.imps.getShortTitle() + ".png");
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   void readData(String string) throws FileNotFoundException, IOException {
> /*  932 */     this._importedData.add(this.arrayToImport);
> /*  933 */     IJ.showStatus("Dataset imported");
> /*  934 */     string = String.valueOf(this._importedData.size()) + ": " + string;
> /*  935 */     this._hashImportedDataset.put(string, new Integer(this._importedData.size()));
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   double roundDoubleNumbers(double n) {
> /*  940 */     return Math.round(n * 100.0D) / 100.0D;
> /*      */   }
> /*      */   
> /*      */   float roundFloatNumbers(float n) {
> /*  944 */     return Math.round(n * 100.0F) / 100.0F;
> /*      */   }
> /*      */   
> /*      */   float roundNumber(float n) {
> /*  948 */     return Math.round(n * 10000.0F) / 10000.0F;
> /*      */   }
> /*      */   
> /*      */   public void stateChanged(ChangeEvent changeEvent) {
> /*  952 */     int selectedIndex = ((JTabbedPane)changeEvent.getSource()).getSelectedIndex();
> /*  953 */     if (selectedIndex == 1) {
> /*  954 */       if (this._dialog.auto) {
> /*  955 */         PlotWindow.plotHeight = this._plotHeight;
> /*  956 */         PlotWindow.plotWidth = this._plotWidth;
> /*      */       } else {
> /*  958 */         PlotWindow.plotHeight = (int)(this._dialog.fraction * (
> /*  959 */           Math.abs(this._dialog.minimumY) + Math.abs(this._dialog.maximumY)));
> /*  960 */         PlotWindow.plotWidth = (int)(this._dialog.fraction * (
> /*  961 */           Math.abs(this._dialog.minimumX) + Math.abs(this._dialog.maximumX)));
> /*      */       } 
> /*      */     }
> /*  964 */     if (selectedIndex == 3) {
> /*  965 */       PlotWindow.plotHeight = this._plotHeight;
> /*  966 */       PlotWindow.plotWidth = this._plotWidth;
> /*      */     } 
> /*      */   }
> /*      */   
> /*      */   void updateNumberofTracks(String s, int n) {
> /*  971 */     if (this._hashTracks.containsKey(s)) {
> /*  972 */       this._hashTracks.remove(s);
> /*  973 */       this._hashTracks.put(s, new Integer(n));
> /*      */     } else {
> /*  975 */       this._hashTracks.put(s, new Integer(n));
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void windowActivated(WindowEvent windowEvent) {}
> /*      */ 
> /*      */   
> /*      */   public void windowClosed(WindowEvent windowEvent) {}
> /*      */   
> /*      */   public void windowClosing(WindowEvent windowEvent) {
> /*  986 */     if (windowEvent.getSource() == this.gui) {
> /*  987 */       if (this._openInfoWindows != null) {
> /*  988 */         for (int i = 0; i < this._openInfoWindows.size(); i++) {
> /*  989 */           ((JFrame)this._openInfoWindows.get(i)).dispose();
> /*      */         }
> /*  991 */         this._openInfoWindows.clear();
> /*      */       } 
> /*  993 */       this._currentOpenWindows.clear();
> /*  994 */       this._currentOpenDiagrams.clear();
> /*  995 */       WindowManager.closeAllWindows();
> /*  996 */       this.gui.dispose();
> /*      */     } else {
> /*  998 */       if (windowEvent.getSource() instanceof JFrame && this._openInfoWindows.contains(windowEvent.getSource())) {
> /*  999 */         this._openInfoWindows.remove(windowEvent.getSource());
> /*      */       }
> /* 1001 */       if (windowEvent.getSource() instanceof PlotWindow) {
> /* 1002 */         if (this._currentOpenWindows.contains(windowEvent.getSource())) {
> /* 1003 */           for (int j = 0; j < this._currentOpenWindows.size(); j++) {
> /* 1004 */             ((Window)this._currentOpenWindows.get(j)).dispose();
> /*      */           }
> /* 1006 */           this._currentOpenWindows.clear();
> /* 1007 */           this.gui.plotClosed();
> /*      */         } 
> /* 1009 */         if (this._currentOpenDiagrams.contains(windowEvent.getSource())) {
> /* 1010 */           for (int k = 0; k < this._currentOpenDiagrams.size(); k++) {
> /* 1011 */             ((Window)this._currentOpenDiagrams.get(k)).dispose();
> /*      */           }
> /* 1013 */           this._currentOpenDiagrams.clear();
> /*      */         } 
> /*      */       } 
> /*      */     } 
> /*      */   }
> /*      */   
> /*      */   public void windowDeactivated(WindowEvent windowEvent) {}
> /*      */   
> /*      */   public void windowDeiconified(WindowEvent windowEvent) {}
> /*      */   
> /*      */   public void windowIconified(WindowEvent windowEvent) {}
> /*      */   
> /*      */   public void windowOpened(WindowEvent windowEvent) {}
> /*      */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/Chemotaxis_ToolModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: ChooserWizardPanel$1$1.java
Only in jd-gui: ChooserWizardPanel$10$1.java
Only in jd-gui: ChooserWizardPanel$10.java
Only in jd-gui: ChooserWizardPanel$11$1.java
Only in jd-gui: ChooserWizardPanel$11.java
Only in jd-gui: ChooserWizardPanel$12$1.java
Only in jd-gui: ChooserWizardPanel$12.java
Only in jd-gui: ChooserWizardPanel$13$1.java
Only in jd-gui: ChooserWizardPanel$13.java
Only in jd-gui: ChooserWizardPanel$14$1.java
Only in jd-gui: ChooserWizardPanel$14.java
Only in jd-gui: ChooserWizardPanel$15$1.java
Only in jd-gui: ChooserWizardPanel$15.java
Only in jd-gui: ChooserWizardPanel$16$1.java
Only in jd-gui: ChooserWizardPanel$16.java
Only in jd-gui: ChooserWizardPanel$17$1.java
Only in jd-gui: ChooserWizardPanel$17.java
Only in jd-gui: ChooserWizardPanel$18$1.java
Only in jd-gui: ChooserWizardPanel$18.java
Only in jd-gui: ChooserWizardPanel$19.java
Only in jd-gui: ChooserWizardPanel$1.java
Only in jd-gui: ChooserWizardPanel$2$1.java
Only in jd-gui: ChooserWizardPanel$2.java
Only in jd-gui: ChooserWizardPanel$3$1.java
Only in jd-gui: ChooserWizardPanel$3.java
Only in jd-gui: ChooserWizardPanel$4$1.java
Only in jd-gui: ChooserWizardPanel$4.java
Only in jd-gui: ChooserWizardPanel$5$1.java
Only in jd-gui: ChooserWizardPanel$5.java
Only in jd-gui: ChooserWizardPanel$6$1.java
Only in jd-gui: ChooserWizardPanel$6.java
Only in jd-gui: ChooserWizardPanel$7$1.java
Only in jd-gui: ChooserWizardPanel$7.java
Only in jd-gui: ChooserWizardPanel$8$1.java
Only in jd-gui: ChooserWizardPanel$8.java
Only in jd-gui: ChooserWizardPanel$9$1.java
Only in jd-gui: ChooserWizardPanel$9.java
diff -r TrackAnalyzer_/ChooserWizardPanel.java jd-gui/ChooserWizardPanel.java
1,923c1,971
< import ij.IJ;
< import ij.ImagePlus;
< import ij.ImageStack;
< import ij.gui.Roi;
< import ij.measure.Calibration;
< import ij.measure.ResultsTable;
< import ij.process.ColorProcessor;
< import java.awt.BasicStroke;
< import java.awt.BorderLayout;
< import java.awt.Color;
< import java.awt.Dimension;
< import java.awt.FlowLayout;
< import java.awt.Font;
< import java.awt.Rectangle;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.ItemEvent;
< import java.awt.event.ItemListener;
< import java.awt.image.BufferedImage;
< import java.io.File;
< import java.util.ArrayList;
< import java.util.List;
< import javax.swing.BorderFactory;
< import javax.swing.Box;
< import javax.swing.BoxLayout;
< import javax.swing.DefaultListModel;
< import javax.swing.Icon;
< import javax.swing.ImageIcon;
< import javax.swing.JButton;
< import javax.swing.JCheckBox;
< import javax.swing.JComboBox;
< import javax.swing.JFileChooser;
< import javax.swing.JFrame;
< import javax.swing.JLabel;
< import javax.swing.JList;
< import javax.swing.JPanel;
< import javax.swing.JScrollPane;
< import javax.swing.JSeparator;
< import javax.swing.JSlider;
< import javax.swing.JSpinner;
< import javax.swing.JTabbedPane;
< import javax.swing.JTable;
< import javax.swing.JToggleButton;
< import javax.swing.SpinnerNumberModel;
< import javax.swing.event.ChangeEvent;
< import javax.swing.event.ChangeListener;
< import javax.swing.table.DefaultTableCellRenderer;
< import javax.swing.table.DefaultTableModel;
< import jwizardcomponent.JWizardComponents;
< import jwizardcomponent.JWizardPanel;
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.plot.IntervalMarker;
< 
< public class ChooserWizardPanel extends JWizardPanel {
<    JCheckBox checkRPicker;
<    static JTable tableTrack;
<    static JTable tableImages;
<    static DefaultTableModel modelTrack;
<    JScrollPane jScrollPaneTrack;
<    JScrollPane jScrollPaneImages;
<    JSpinner filterMin;
<    JSpinner filterMax;
<    HistogramFilterVersion hs2 = new HistogramFilterVersion();
<    ChartPanel histogram;
<    JComboBox<String> comboFilters;
<    static DefaultListModel<String> modelListClass;
<    static DefaultListModel<String> modelListFeature;
<    static JList<String> classList;
<    static JList<String> featureList;
<    static JLabel labelReset;
<    static String trackEnable = "";
<    static String command;
<    List<Integer> indexesToReset;
<    List<Integer> indexesToReset1;
<    List<Integer> tracksID;
<    List<Integer> tracksID1;
<    List<Integer> indexesTI;
<    static Icon iconTrackCell;
<    static Object[] columnNamesTrack;
<    Thread refreshThread;
<    Thread csvThread;
<    Thread pngThread;
<    Thread paintThread;
<    Thread tInsideThread;
<    Thread tOutsideThread;
<    Thread enableThread;
<    Thread disableThread;
<    Thread slMinThread;
<    Thread filterMinThread;
<    Thread slMaxThread;
<    Thread filterMaxThread;
<    Thread filtersThread;
<    Thread pickerThread;
<    Thread classThread;
<    Thread remClassThread;
<    Thread addThread;
<    Thread remThread;
< 
<    public ChooserWizardPanel(JWizardComponents wizardComponents) {
<       super(wizardComponents, "");
<       tableTrack = new JTable();
<       tableImages = new JTable();
<       tableImages.setModel(FirstWizardPanel.modelImages);
<       tableImages.getColumnModel().getColumn(0).setPreferredWidth(90);
<       tableImages.getColumnModel().getColumn(1).setPreferredWidth(460);
<       tableImages.getColumnModel().getColumn(2).setPreferredWidth(80);
<       modelTrack = new DefaultTableModel();
<       columnNamesTrack = new Object[]{"Label", "TRACK_ID", "TRACK_INDEX", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "TOTAL_ABSOLUTE_ANGLE_XY", "TOTAL_ABSOLUTE_ANGLE_YZ", "TOTAL_ABSOLUTE_ANGLE_ZX"};
<       tableTrack.setModel(modelTrack);
<       tableTrack.setSelectionMode(1);
<       this.jScrollPaneTrack = new JScrollPane(tableTrack);
<       this.jScrollPaneTrack.setPreferredSize(new Dimension(590, 240));
<       this.jScrollPaneTrack.setBorder(BorderFactory.createTitledBorder(""));
<       this.jScrollPaneImages = new JScrollPane(tableImages);
<       this.jScrollPaneImages.setPreferredSize(new Dimension(590, 240));
<       this.jScrollPaneImages.setBorder(BorderFactory.createTitledBorder(""));
<       JPanel mainPanel = new JPanel();
<       mainPanel.setLayout(new BoxLayout(mainPanel, 1));
<       JTabbedPane tabbedPaneTrack = new JTabbedPane(1);
<       ImageIcon iconTrack = FirstWizardPanel.createImageIcon("images/track.jpg");
<       iconTrackCell = new ImageIcon(iconTrack.getImage().getScaledInstance(18, 20, 4));
<       JButton pngButton = new JButton();
<       ImageIcon iconPng = FirstWizardPanel.createImageIcon("images/save.png");
<       Icon pngCell = new ImageIcon(iconPng.getImage().getScaledInstance(18, 20, 4));
<       pngButton.setIcon(pngCell);
<       pngButton.setToolTipText("Click to capture spots overlay.");
<       JPanel panelPng = new JPanel(new FlowLayout(0));
<       panelPng.add(pngButton);
<       JButton csvButton = new JButton();
<       ImageIcon iconCsv = FirstWizardPanel.createImageIcon("images/csv.png");
<       Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
<       csvButton.setIcon(csvCell);
<       csvButton.setToolTipText("Click to export your spots table selection.");
<       JPanel panelCsv = new JPanel(new FlowLayout(0));
<       panelCsv.add(csvButton);
<       JPanel panelPngCsv = new JPanel(new FlowLayout(0));
<       panelPngCsv.add(panelPng);
<       panelPngCsv.add(panelCsv);
<       tabbedPaneTrack.addTab("TRACKS ", iconTrackCell, mainPanel, "Display Track Analysis");
<       tabbedPaneTrack.setTabLayoutPolicy(1);
<       JButton refreshButton = new JButton();
<       ImageIcon iconRefresh = FirstWizardPanel.createImageIcon("images/refresh.png");
<       Icon refreshCell = new ImageIcon(iconRefresh.getImage().getScaledInstance(18, 20, 4));
<       refreshButton.setIcon(refreshCell);
<       refreshButton.setToolTipText("Click this button to get Track analysis");
<       JToggleButton paintButton = new JToggleButton();
<       ImageIcon iconPaint = FirstWizardPanel.createImageIcon("images/paint.png");
<       Icon paintCell = new ImageIcon(iconPaint.getImage().getScaledInstance(18, 20, 4));
<       paintButton.setIcon(paintCell);
<       paintButton.setToolTipText("Click this button to display labeled-Tracks");
<       JToggleButton tInsideButton = new JToggleButton();
<       ImageIcon iconTI = FirstWizardPanel.createImageIcon("images/tinside.png");
<       Icon TICell = new ImageIcon(iconTI.getImage().getScaledInstance(18, 20, 4));
<       tInsideButton.setIcon(TICell);
<       tInsideButton.setToolTipText("Click this button to toggle inside Tracks.");
<       JToggleButton tOutsideButton = new JToggleButton();
<       ImageIcon iconTO = FirstWizardPanel.createImageIcon("images/toutside.png");
<       Icon TOCell = new ImageIcon(iconTO.getImage().getScaledInstance(18, 20, 4));
<       tOutsideButton.setIcon(TOCell);
<       tOutsideButton.setToolTipText("Click this button to toggle outside Tracks.");
<       JButton enableButton = new JButton();
<       ImageIcon iconEnable = FirstWizardPanel.createImageIcon("images/enable.png");
<       Icon enableCell = new ImageIcon(iconEnable.getImage().getScaledInstance(18, 20, 4));
<       enableButton.setIcon(enableCell);
<       enableButton.setToolTipText("Click this button to enable your selection");
<       JButton disableButton = new JButton();
<       ImageIcon iconDisable = FirstWizardPanel.createImageIcon("images/disable.png");
<       Icon disableCell = new ImageIcon(iconDisable.getImage().getScaledInstance(18, 20, 4));
<       disableButton.setIcon(disableCell);
<       disableButton.setToolTipText("Click this button to disable your selection");
<       JPanel buttonPanel = new JPanel(new FlowLayout(2));
<       JSeparator separator1 = new JSeparator(1);
<       JSeparator separator2 = new JSeparator(1);
<       Dimension dime = separator1.getPreferredSize();
<       dime.height = refreshButton.getPreferredSize().height;
<       separator1.setPreferredSize(dime);
<       separator2.setPreferredSize(dime);
<       this.checkRPicker = new JCheckBox(" Track Picker");
<       JLabel filterLabel = new JLabel("   Track Analysis : ");
<       filterLabel.setFont(new Font("Dialog", 1, 13));
<       filterLabel.setBorder(BorderFactory.createRaisedBevelBorder());
<       JPanel filterPanel = new JPanel(new FlowLayout(0));
<       filterPanel.add(filterLabel);
<       filterPanel.add(this.checkRPicker);
<       filterPanel.add(Box.createHorizontalStrut(20));
<       JPanel filterMain = new JPanel(new FlowLayout(0));
<       filterMain.add(filterPanel);
<       buttonPanel.add(refreshButton);
<       buttonPanel.add(paintButton);
<       buttonPanel.add(separator1);
<       buttonPanel.add(enableButton);
<       buttonPanel.add(disableButton);
<       buttonPanel.add(separator2);
<       buttonPanel.add(tInsideButton);
<       buttonPanel.add(tOutsideButton);
<       filterMain.add(buttonPanel);
<       mainPanel.add(this.jScrollPaneImages);
<       mainPanel.add(Box.createVerticalStrut(5));
<       mainPanel.add(filterMain);
<       mainPanel.add(this.jScrollPaneTrack);
<       JLabel settingsLabel = new JLabel("   Settings for Filters/Classes : ");
<       settingsLabel.setFont(new Font("Dialog", 1, 13));
<       settingsLabel.setBorder(BorderFactory.createRaisedBevelBorder());
<       JPanel settingsPanel = new JPanel(new FlowLayout(0));
<       settingsPanel.add(settingsLabel);
<       mainPanel.add(settingsPanel);
<       JPanel filtersMin = new JPanel(new FlowLayout(0));
<       this.filterMin = new JSpinner(new SpinnerNumberModel(30, 0, 5000, 1));
<       this.filterMin.setPreferredSize(new Dimension(60, 20));
<       final JSlider sliderMin = new JSlider(0, 300, 50);
<       sliderMin.setPreferredSize(new Dimension(150, 15));
<       JLabel filterMinLabel = new JLabel("              Min :  ");
<       filtersMin.add(filterMinLabel);
<       filtersMin.add(sliderMin);
<       filtersMin.add(Box.createHorizontalStrut(2));
<       filtersMin.add(this.filterMin);
<       JPanel filtersMax = new JPanel(new FlowLayout(0));
<       this.filterMax = new JSpinner(new SpinnerNumberModel(200, 0, 5000, 1));
<       this.filterMax.setPreferredSize(new Dimension(60, 20));
<       final JSlider sliderMax = new JSlider(0, 300, 150);
<       sliderMax.setPreferredSize(new Dimension(150, 15));
<       JLabel filterMaxLabel = new JLabel("              Max :  ");
<       filtersMax.add(filterMaxLabel);
<       filtersMax.add(sliderMax);
<       filtersMax.add(Box.createHorizontalStrut(2));
<       filtersMax.add(this.filterMax);
<       JPanel boxPanel2 = new JPanel();
<       boxPanel2.setLayout(new BoxLayout(boxPanel2, 1));
<       final IntervalMarker intervalMarker = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.5F);
<       this.histogram = this.hs2.createChartPanel("", new double[]{0.0D, 0.0D, 0.0D}, 100, intervalMarker);
<       JPanel chartPanel2 = new JPanel(new BorderLayout());
<       chartPanel2.setPreferredSize(new Dimension(390, 180));
<       chartPanel2.add(this.histogram);
<       boxPanel2.add(chartPanel2);
<       JPanel controlPanel2 = this.hs2.createControlPanel();
<       boxPanel2.add(controlPanel2);
<       JPanel filtersMain2 = new JPanel();
<       filtersMain2.setLayout(new BoxLayout(filtersMain2, 1));
<       filtersMain2.add(boxPanel2);
<       filtersMain2.add(filtersMin);
<       filtersMain2.add(filtersMax);
<       JLabel featureTrack = new JLabel("  Track-Features :  ");
<       featureTrack.setFont(new Font("Dialog", 1, 13));
<       this.comboFilters = new JComboBox();
< 
<       for(int i = 1; i < columnNamesTrack.length; ++i) {
<          this.comboFilters.addItem((String)columnNamesTrack[i]);
<       }
< 
<       this.comboFilters.setPreferredSize(new Dimension(130, 25));
<       this.comboFilters.setSelectedIndex(0);
<       this.comboFilters.setOpaque(true);
<       JPanel panelFilters = new JPanel(new FlowLayout(0));
<       JSeparator separator3 = new JSeparator(1);
<       Dimension dime2 = separator3.getPreferredSize();
<       dime2.height = filtersMain2.getPreferredSize().height;
<       separator3.setPreferredSize(dime2);
<       panelFilters.add(filtersMain2);
<       panelFilters.add(separator3);
<       modelListClass = new DefaultListModel();
<       classList = new JList(modelListClass);
<       modelListFeature = new DefaultListModel();
<       featureList = new JList(modelListFeature);
<       final ColorEditorTrack colorEditor = new ColorEditorTrack(featureList);
<       JScrollPane scrollListFilter = new JScrollPane(featureList);
<       JScrollPane scrollListClass = new JScrollPane(classList);
<       Dimension d = featureList.getPreferredSize();
<       d.width = 150;
<       d.height = 90;
<       scrollListFilter.setPreferredSize(d);
<       scrollListClass.setPreferredSize(d);
<       JPanel filterPanelButtons = new JPanel(new FlowLayout(0));
<       JPanel classPanelButtons = new JPanel();
<       classPanelButtons.setLayout(new BoxLayout(classPanelButtons, 1));
<       filterPanelButtons.add(scrollListFilter);
<       JPanel fButtonsPanel = new JPanel();
<       fButtonsPanel.setLayout(new BoxLayout(fButtonsPanel, 1));
<       JButton addButton = new JButton();
<       ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
<       Icon addCell = new ImageIcon(iconAdd.getImage().getScaledInstance(14, 16, 4));
<       addButton.setIcon(addCell);
<       addButton.setToolTipText("Click this button to add features");
<       JButton remButton = new JButton();
<       ImageIcon iconRem = FirstWizardPanel.createImageIcon("images/remove.png");
<       Icon remCell = new ImageIcon(iconRem.getImage().getScaledInstance(14, 16, 4));
<       remButton.setIcon(remCell);
<       remButton.setToolTipText("Click this button to remove features");
<       JButton classButton = new JButton();
<       ImageIcon iconClass = FirstWizardPanel.createImageIcon("images/classes.png");
<       Icon classCell = new ImageIcon(iconClass.getImage().getScaledInstance(14, 16, 4));
<       classButton.setIcon(classCell);
<       classButton.setToolTipText("Click this button to create a class.");
<       JButton remClassButton = new JButton();
<       remClassButton.setIcon(remCell);
<       remClassButton.setToolTipText("Click this button to remove a class.");
<       fButtonsPanel.add(addButton);
<       fButtonsPanel.add(remButton);
<       filterPanelButtons.add(fButtonsPanel);
<       classPanelButtons.add(classButton);
<       classPanelButtons.add(remClassButton);
<       JPanel classPanel = new JPanel(new FlowLayout(0));
<       classPanel.add(scrollListClass);
<       classPanel.add(classPanelButtons);
<       JPanel boxPanel = new JPanel();
<       boxPanel.setLayout(new BoxLayout(boxPanel, 1));
<       boxPanel.add(this.comboFilters);
<       boxPanel.add(Box.createHorizontalStrut(5));
<       boxPanel.add(filterPanelButtons);
<       boxPanel.add(Box.createHorizontalStrut(5));
<       boxPanel.add(classPanel);
<       boxPanel.add(panelPngCsv);
<       panelFilters.add(boxPanel);
<       mainPanel.add(panelFilters);
<       this.add(tabbedPaneTrack);
<       this.createMovieTable();
<       paintButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             ChooserWizardPanel.this.paintThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      ChooserWizardPanel.this.paintAndDisableAction();
<                   } else if (ev.getStateChange() == 2) {
<                      ChooserWizardPanel.this.resetAndEnableAction();
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.paintThread.start();
<          }
<       });
<       csvButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.csvThread = new Thread(new Runnable() {
<                public void run() {
<                   List<String> columnTrackHead = new ArrayList();
< 
<                   for(int j = 0; j < ChooserWizardPanel.modelTrack.getColumnCount(); ++j) {
<                      columnTrackHead.add(ChooserWizardPanel.modelTrack.getColumnName(j));
<                   }
< 
<                   ResultsTable rt = new ResultsTable(ChooserWizardPanel.modelTrack.getRowCount());
<                   if (rt != null) {
<                      rt.reset();
<                   }
< 
<                   for(int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<                      for(int jx = 0; jx < ChooserWizardPanel.modelTrack.getColumnCount(); ++jx) {
<                         if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE) {
<                            if (((String)columnTrackHead.get(jx)).equals(columnTrackHead.get(0)) == Boolean.TRUE) {
<                               rt.setValue((String)columnTrackHead.get(jx), i, ((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, jx)).getText());
<                            } else {
<                               rt.setValue((String)columnTrackHead.get(jx), i, ChooserWizardPanel.modelTrack.getValueAt(i, jx).toString());
<                            }
<                         }
<                      }
<                   }
< 
<                   rt.show("Resutls tracks");
<                }
<             });
<             ChooserWizardPanel.this.csvThread.start();
<          }
<       });
<       pngButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.pngThread = new Thread(new Runnable() {
<                public void run() {
<                   if (IJ.getImage() == null) {
<                      IJ.error("You must have an image window active.");
<                   }
< 
<                   if (IJ.getImage() != null) {
<                      JFrame pngFrame = new JFrame();
<                      JFileChooser fileChooser = new JFileChooser();
<                      fileChooser.setFileSelectionMode(1);
<                      fileChooser.setDialogTitle("Specify a directory to save");
<                      int userSelection = fileChooser.showSaveDialog(pngFrame);
<                      if (userSelection == 0) {
<                         File fileToSave = fileChooser.getSelectedFile();
<                         int firstFrame = 0;
<                         int lastFrame = 0;
<                         if (ProcessTrackMateXml.displayer.getImp().getNFrames() > 1) {
<                            firstFrame = Math.max(1, Math.min(IJ.getImage().getNFrames(), 1));
<                            lastFrame = Math.min(IJ.getImage().getNFrames(), Math.max(IJ.getImage().getNFrames(), 1));
<                         }
< 
<                         if (ProcessTrackMateXml.displayer.getImp().getNSlices() > 1) {
<                            firstFrame = Math.max(1, Math.min(IJ.getImage().getNSlices(), 1));
<                            lastFrame = Math.min(IJ.getImage().getNSlices(), Math.max(IJ.getImage().getNSlices(), 1));
<                         }
< 
<                         Rectangle bounds = ProcessTrackMateXml.displayer.getImp().getCanvas().getBounds();
<                         int width = bounds.width;
<                         int height = bounds.height;
<                         int nCaptures = lastFrame - firstFrame + 1;
<                         ImageStack stack = new ImageStack(width, height);
<                         int channel = ProcessTrackMateXml.displayer.getImp().getChannel();
<                         int slice = ProcessTrackMateXml.displayer.getImp().getSlice();
<                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(true);
< 
<                         for(int frame = firstFrame; frame <= lastFrame; ++frame) {
<                            ProcessTrackMateXml.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
<                            BufferedImage bi = new BufferedImage(width, height, 2);
<                            ProcessTrackMateXml.displayer.getImp().getCanvas().paint(bi.getGraphics());
<                            ColorProcessor cp = new ColorProcessor(bi);
<                            int index = ProcessTrackMateXml.displayer.getImp().getStackIndex(channel, slice, frame);
<                            stack.addSlice(ProcessTrackMateXml.displayer.getImp().getImageStack().getSliceLabel(index), cp);
<                         }
< 
<                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(false);
<                         ImagePlus capture = new ImagePlus("TrackMate capture of " + ProcessTrackMateXml.displayer.getImp().getShortTitle(), stack);
<                         ChooserWizardPanel.transferCalibration(ProcessTrackMateXml.displayer.getImp(), capture);
<                         IJ.saveAs(capture, "Tiff", fileToSave.getAbsolutePath() + File.separator + "Capture Overlay for " + IJ.getImage().getShortTitle());
<                      }
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.pngThread.start();
<          }
<       });
<       refreshButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.refreshThread = new Thread(new Runnable() {
<                public void run() {
<                   ChooserWizardPanel.trackEnable = "trackEnable";
<                   ProcessTrackMateXml.tracksVisible = true;
<                   ProcessTrackMateXml.spotsVisible = false;
<                   ProcessTrackMateXml ptx = new ProcessTrackMateXml();
<                   ptx.processTrackMateXml();
<                }
<             });
<             ChooserWizardPanel.this.refreshThread.start();
<          }
<       });
<       enableButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.enableThread = new Thread(new Runnable() {
<                public void run() {
<                   ChooserWizardPanel.this.enableTracks();
<                }
<             });
<             ChooserWizardPanel.this.enableThread.start();
<          }
<       });
<       disableButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.disableThread = new Thread(new Runnable() {
<                public void run() {
<                   ChooserWizardPanel.this.disableTracks();
<                }
<             });
<             ChooserWizardPanel.this.disableThread.start();
<          }
<       });
<       this.checkRPicker.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent e) {
<             ChooserWizardPanel.this.pickerThread = new Thread(new Runnable() {
<                public void run() {
<                   if (e.getStateChange() == 1) {
<                      ChooserWizardPanel.command = "enable";
<                   }
< 
<                   if (e.getStateChange() == 2) {
<                      ChooserWizardPanel.command = null;
<                      ProcessTrackMateXml.selectionModel.clearSpotSelection();
<                      ProcessTrackMateXml.selectionModel.clearSelection();
<                   }
<                }
<             });
<             ChooserWizardPanel.this.pickerThread.start();
<          }
<       });
<       sliderMin.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             ChooserWizardPanel.this.slMinThread = new Thread(new Runnable() {
<                public void run() {
<                   ChooserWizardPanel.this.filterMin.setValue(sliderMin.getValue());
<                   intervalMarker.setStartValue((double)sliderMin.getValue());
<                }
<             });
<             ChooserWizardPanel.this.slMinThread.start();
<          }
<       });
<       this.filterMin.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             ChooserWizardPanel.this.filterMinThread = new Thread(new Runnable() {
<                public void run() {
<                   sliderMin.setValue((Integer)ChooserWizardPanel.this.filterMin.getValue());
<                   intervalMarker.setStartValue((double)(Integer)ChooserWizardPanel.this.filterMin.getValue());
<                }
<             });
<             ChooserWizardPanel.this.filterMinThread.start();
<          }
<       });
<       sliderMax.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             ChooserWizardPanel.this.slMaxThread = new Thread(new Runnable() {
<                public void run() {
<                   ChooserWizardPanel.this.filterMax.setValue(sliderMax.getValue());
<                   intervalMarker.setEndValue((double)sliderMax.getValue());
<                }
<             });
<             ChooserWizardPanel.this.slMaxThread.start();
<          }
<       });
<       this.filterMax.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             ChooserWizardPanel.this.filterMaxThread = new Thread(new Runnable() {
<                public void run() {
<                   sliderMax.setValue((Integer)ChooserWizardPanel.this.filterMax.getValue());
<                   intervalMarker.setEndValue((double)(Integer)ChooserWizardPanel.this.filterMax.getValue());
<                }
<             });
<             ChooserWizardPanel.this.filterMaxThread.start();
<          }
<       });
<       tInsideButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             ChooserWizardPanel.this.tInsideThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      ChooserWizardPanel.this.toggleInsideAction();
<                   } else if (ev.getStateChange() == 2) {
<                      ChooserWizardPanel.this.resetToggleInsideAction();
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.tInsideThread.start();
<          }
<       });
<       this.comboFilters.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.filtersThread = new Thread(new Runnable() {
<                public void run() {
<                   String selectedName = (String)ChooserWizardPanel.this.comboFilters.getSelectedItem();
<                   int selectedIndex = ChooserWizardPanel.this.comboFilters.getSelectedIndex();
<                   double[] valuesx = null;
<                   double[] values = new double[ChooserWizardPanel.tableTrack.getRowCount()];
< 
<                   int i;
<                   for(i = 0; i < ChooserWizardPanel.tableTrack.getRowCount(); ++i) {
<                      for(int c = 0; c < ChooserWizardPanel.tableTrack.getColumnCount(); ++c) {
<                         values[i] = Double.parseDouble((String)ChooserWizardPanel.tableTrack.getValueAt(i, selectedIndex + 2));
<                      }
<                   }
< 
<                   double max = values[0];
< 
<                   for(i = 1; i < values.length; ++i) {
<                      if (values[i] > max) {
<                         max = values[i];
<                      }
<                   }
< 
<                   sliderMin.setMinimum(0);
<                   sliderMin.setMaximum((int)max);
<                   sliderMax.setMinimum(0);
<                   sliderMax.setMaximum((int)max);
<                   ChooserWizardPanel.this.hs2.addHistogramSeries(selectedName, values, (int)max, intervalMarker);
<                }
<             });
<             ChooserWizardPanel.this.filtersThread.start();
<          }
<       });
<       classButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.classThread = new Thread(new Runnable() {
<                public void run() {
<                   ColorEditorTrack.myFrame.setVisible(true);
<                   colorEditor.setClassAction();
<                }
<             });
<             ChooserWizardPanel.this.classThread.start();
<          }
<       });
<       remClassButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.remClassThread = new Thread(new Runnable() {
<                public void run() {
<                   String classSelectedValue = (String)ChooserWizardPanel.classList.getSelectedValue();
<                   int[] classSelectedIndex = ChooserWizardPanel.classList.getSelectedIndices();
< 
<                   int i;
<                   for(i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<                      if (((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1))).getText().equals(classSelectedValue)) {
<                         ChooserWizardPanel.modelTrack.setValueAt(ChooserWizardPanel.labelReset, i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
<                      }
<                   }
< 
<                   for(i = 0; i < classSelectedIndex.length; ++i) {
<                      ChooserWizardPanel.modelListClass.removeElementAt(classSelectedIndex[i]);
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.remClassThread.start();
<          }
<       });
<       addButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.addThread = new Thread(new Runnable() {
<                public void run() {
<                   List<String> listFilters = new ArrayList();
<                   if (ChooserWizardPanel.featureList.getModel().getSize() < 1) {
<                      ChooserWizardPanel.modelListFeature.addElement((String)ChooserWizardPanel.this.comboFilters.getSelectedItem() + ":  [" + ChooserWizardPanel.this.filterMin.getValue() + "," + ChooserWizardPanel.this.filterMax.getValue() + "]");
<                   }
< 
<                   if (ChooserWizardPanel.featureList.getModel().getSize() >= 1) {
<                      for(int i = 0; i < ChooserWizardPanel.featureList.getModel().getSize(); ++i) {
<                         listFilters.add(String.valueOf(((String)ChooserWizardPanel.featureList.getModel().getElementAt(i)).substring(0, ((String)ChooserWizardPanel.featureList.getModel().getElementAt(i)).lastIndexOf(":"))));
<                      }
< 
<                      if (!listFilters.contains(ChooserWizardPanel.this.comboFilters.getSelectedItem().toString())) {
<                         ChooserWizardPanel.modelListFeature.addElement((String)ChooserWizardPanel.this.comboFilters.getSelectedItem() + ":  [" + ChooserWizardPanel.this.filterMin.getValue() + "," + ChooserWizardPanel.this.filterMax.getValue() + "]");
<                      }
< 
<                      if (listFilters.contains(ChooserWizardPanel.this.comboFilters.getSelectedItem().toString())) {
<                         return;
<                      }
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.addThread.start();
<          }
<       });
<       remButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ChooserWizardPanel.this.remThread = new Thread(new Runnable() {
<                public void run() {
<                   try {
<                      int[] indexes = ChooserWizardPanel.featureList.getSelectedIndices();
< 
<                      for(int i = 0; i < indexes.length; ++i) {
<                         ChooserWizardPanel.modelListFeature.remove(indexes[i]);
<                      }
<                   } catch (Exception var3) {
<                      var3.printStackTrace();
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.remThread.start();
<          }
<       });
<       tOutsideButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             ChooserWizardPanel.this.tOutsideThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      ChooserWizardPanel.this.toggleOutsideAction();
<                   } else if (ev.getStateChange() == 2) {
<                      ChooserWizardPanel.this.resetToggleInsideAction();
<                   }
< 
<                }
<             });
<             ChooserWizardPanel.this.tOutsideThread.start();
<          }
<       });
<    }
< 
<    public void toggleOutsideAction() {
<       Roi mainRoi = null;
<       if (IJ.getImage().getRoi().getType() == 0) {
<          mainRoi = IJ.getImage().getRoi();
<       }
< 
<       this.indexesTI = new ArrayList();
< 
<       for(int i = 0; i < modelTrack.getRowCount(); ++i) {
<          if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(modelTrack.getValueAt(i, tableTrack.convertColumnIndexToModel(13)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(modelTrack.getValueAt(i, tableTrack.convertColumnIndexToModel(14)).toString()))) == Boolean.FALSE) {
<             this.indexesTI.add(i);
<             modelTrack.setValueAt(false, i, tableTrack.convertColumnIndexToModel(0));
<             int trackID = Integer.parseInt((String)tableTrack.getValueAt(i, 2));
<             ProcessTrackMateXml.model.beginUpdate();
< 
<             try {
<                ProcessTrackMateXml.model.setTrackVisibility(trackID, false);
<             } finally {
<                ProcessTrackMateXml.model.endUpdate();
<             }
< 
<             ProcessTrackMateXml.displayer.refresh();
<          }
<       }
< 
<    }
< 
<    public void toggleInsideAction() {
<       Roi mainRoi = null;
<       if (IJ.getImage().getRoi().getType() == 0) {
<          mainRoi = IJ.getImage().getRoi();
<       }
< 
<       this.indexesTI = new ArrayList();
< 
<       for(int i = 0; i < modelTrack.getRowCount(); ++i) {
<          if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(modelTrack.getValueAt(i, tableTrack.convertColumnIndexToModel(13)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(modelTrack.getValueAt(i, tableTrack.convertColumnIndexToModel(14)).toString()))) == Boolean.TRUE) {
<             this.indexesTI.add(i);
<             modelTrack.setValueAt(false, i, tableTrack.convertColumnIndexToModel(0));
<             int trackID = Integer.parseInt((String)tableTrack.getValueAt(i, 2));
<             ProcessTrackMateXml.model.beginUpdate();
< 
<             try {
<                ProcessTrackMateXml.model.setTrackVisibility(trackID, false);
<             } finally {
<                ProcessTrackMateXml.model.endUpdate();
<             }
< 
<             ProcessTrackMateXml.displayer.refresh();
<          }
<       }
< 
<    }
< 
<    public void resetToggleInsideAction() {
<       for(int row = 0; row < modelTrack.getRowCount(); ++row) {
<          modelTrack.setValueAt(true, tableTrack.convertRowIndexToModel(row), tableTrack.convertColumnIndexToModel(0));
<          int trackID = Integer.parseInt((String)tableTrack.getValueAt(row, 2));
<          ProcessTrackMateXml.model.beginUpdate();
< 
<          try {
<             ProcessTrackMateXml.model.setTrackVisibility(trackID, true);
<          } finally {
<             ProcessTrackMateXml.model.endUpdate();
<          }
< 
<          ProcessTrackMateXml.displayer.refresh();
<       }
< 
<    }
< 
<    public static void createTrackTable() {
<       modelTrack = new DefaultTableModel(ProcessTrackMateXml.dataTrack, ProcessTrackMateXml.columnHeadersTrack) {
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
<             }
< 
<             return super.getColumnClass(column);
<          }
<       };
<       modelTrack.addColumn("Enable");
<       tableTrack.setModel(modelTrack);
<       tableTrack.moveColumn(tableTrack.getColumnCount() - 1, 0);
<       tableTrack.setSelectionBackground(new Color(229, 255, 204));
<       tableTrack.setSelectionForeground(new Color(0, 102, 0));
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableTrack.setDefaultRenderer(String.class, centerRenderer);
<       tableTrack.setAutoResizeMode(0);
<       tableTrack.setRowHeight(45);
<       tableTrack.setAutoCreateRowSorter(true);
<       tableTrack.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
< 
<       int i;
<       for(i = 0; i < tableTrack.getColumnCount(); ++i) {
<          tableTrack.getColumnModel().getColumn(i).setPreferredWidth(90);
<       }
< 
<       for(i = 3; i < tableTrack.getColumnCount(); ++i) {
<          tableTrack.getColumnModel().getColumn(i).setPreferredWidth(130);
<       }
< 
<       for(i = 0; i < tableTrack.getRowCount(); ++i) {
<          tableTrack.setValueAt(true, i, 0);
<       }
< 
<       tableTrack.getColumnModel().getColumn(1).setCellRenderer(new Renderer());
<       labelReset = new JLabel();
<       labelReset.setText("");
<       labelReset.setOpaque(true);
<       labelReset.setBackground(new Color(214, 217, 223));
< 
<       for(i = 0; i < modelTrack.getRowCount(); ++i) {
<          modelTrack.setValueAt(labelReset, i, tableTrack.convertColumnIndexToModel(1));
<       }
< 
<    }
< 
<    public void enableTracks() {
<       this.indexesToReset1 = new ArrayList();
<       this.tracksID1 = new ArrayList();
<       int[] selectedRows = tableTrack.getSelectedRows();
< 
<       int row;
<       for(row = 0; row < selectedRows.length; ++row) {
<          this.indexesToReset1.add(selectedRows[row]);
<          modelTrack.setValueAt(true, selectedRows[row], tableTrack.convertColumnIndexToModel(0));
<          this.tracksID1.add(Integer.parseInt((String)tableTrack.getValueAt(selectedRows[row], 2)));
<       }
< 
<       for(row = 0; row < this.tracksID1.size(); ++row) {
<          ProcessTrackMateXml.model.beginUpdate();
< 
<          try {
<             ProcessTrackMateXml.model.setTrackVisibility((Integer)this.tracksID1.get(row), true);
<          } finally {
<             ProcessTrackMateXml.model.endUpdate();
<          }
< 
<          ProcessTrackMateXml.displayer.refresh();
<       }
< 
<    }
< 
<    public void disableTracks() {
<       this.indexesToReset1 = new ArrayList();
<       this.tracksID1 = new ArrayList();
<       int[] selectedRows = tableTrack.getSelectedRows();
< 
<       int row;
<       for(row = 0; row < selectedRows.length; ++row) {
<          this.indexesToReset1.add(selectedRows[row]);
<          modelTrack.setValueAt(false, selectedRows[row], tableTrack.convertColumnIndexToModel(0));
<          this.tracksID1.add(Integer.parseInt((String)tableTrack.getValueAt(selectedRows[row], 2)));
<       }
< 
<       for(row = 0; row < this.tracksID1.size(); ++row) {
<          ProcessTrackMateXml.model.beginUpdate();
< 
<          try {
<             ProcessTrackMateXml.model.setTrackVisibility((Integer)this.tracksID1.get(row), false);
<          } finally {
<             ProcessTrackMateXml.model.endUpdate();
<          }
< 
<          ProcessTrackMateXml.displayer.refresh();
<       }
< 
<    }
< 
<    public void createMovieTable() {
<       tableImages.setSelectionBackground(new Color(229, 255, 204));
<       tableImages.setSelectionForeground(new Color(0, 102, 0));
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableImages.setDefaultRenderer(String.class, centerRenderer);
<       tableImages.setAutoResizeMode(0);
<       tableImages.setRowHeight(95);
<       tableImages.setAutoCreateRowSorter(true);
<       tableImages.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
<       tableImages.setModel(FirstWizardPanel.modelImages);
<    }
< 
<    public void paintAndDisableAction() {
<       this.indexesToReset = new ArrayList();
<       this.tracksID = new ArrayList();
< 
<       int row;
<       for(row = 0; row < modelTrack.getRowCount(); ++row) {
<          if (((JLabel)modelTrack.getValueAt(row, tableTrack.convertColumnIndexToModel(1))).getBackground().equals(new Color(214, 217, 223)) == Boolean.TRUE) {
<             this.indexesToReset.add(row);
<             modelTrack.setValueAt(false, row, tableTrack.convertColumnIndexToModel(0));
<             this.tracksID.add(Integer.parseInt((String)tableTrack.getValueAt(row, 2)));
<          }
<       }
< 
<       for(row = 0; row < this.tracksID.size(); ++row) {
<          ProcessTrackMateXml.model.beginUpdate();
< 
<          try {
<             ProcessTrackMateXml.model.setTrackVisibility((Integer)this.tracksID.get(row), false);
<          } finally {
<             ProcessTrackMateXml.model.endUpdate();
<          }
< 
<          ProcessTrackMateXml.displayer.refresh();
<       }
< 
<    }
< 
<    public void resetAndEnableAction() {
<       int row;
<       for(row = 0; row < this.indexesToReset.size(); ++row) {
<          modelTrack.setValueAt(true, tableTrack.convertRowIndexToModel((Integer)this.indexesToReset.get(row)), tableTrack.convertColumnIndexToModel(0));
<       }
< 
<       for(row = 0; row < this.tracksID.size(); ++row) {
<          ProcessTrackMateXml.model.beginUpdate();
< 
<          try {
<             ProcessTrackMateXml.model.setTrackVisibility((Integer)this.tracksID.get(row), true);
<          } finally {
<             ProcessTrackMateXml.model.endUpdate();
<          }
<       }
< 
<       ProcessTrackMateXml.displayer.refresh();
<    }
< 
<    public void update() {
<       this.setNextButtonEnabled(true);
<       this.setFinishButtonEnabled(true);
<       this.setBackButtonEnabled(true);
<    }
< 
<    public void next() {
<       this.switchPanel(2);
<    }
< 
<    public void back() {
<       this.switchPanel(0);
<    }
< 
<    private static final void transferCalibration(ImagePlus from, ImagePlus to) {
<       Calibration fc = from.getCalibration();
<       Calibration tc = to.getCalibration();
<       tc.setUnit(fc.getUnit());
<       tc.setTimeUnit(fc.getTimeUnit());
<       tc.frameInterval = fc.frameInterval;
<       double mag = from.getCanvas().getMagnification();
<       tc.pixelWidth = fc.pixelWidth / mag;
<       tc.pixelHeight = fc.pixelHeight / mag;
<       tc.pixelDepth = fc.pixelDepth;
<    }
< }
---
> /*     */ import ij.IJ;
> /*     */ import ij.ImagePlus;
> /*     */ import ij.ImageStack;
> /*     */ import ij.gui.Roi;
> /*     */ import ij.measure.Calibration;
> /*     */ import ij.measure.ResultsTable;
> /*     */ import ij.process.ColorProcessor;
> /*     */ import ij.process.ImageProcessor;
> /*     */ import java.awt.BasicStroke;
> /*     */ import java.awt.BorderLayout;
> /*     */ import java.awt.Color;
> /*     */ import java.awt.Component;
> /*     */ import java.awt.Dimension;
> /*     */ import java.awt.FlowLayout;
> /*     */ import java.awt.Font;
> /*     */ import java.awt.Rectangle;
> /*     */ import java.awt.event.ActionEvent;
> /*     */ import java.awt.event.ActionListener;
> /*     */ import java.awt.event.ItemEvent;
> /*     */ import java.awt.event.ItemListener;
> /*     */ import java.awt.image.BufferedImage;
> /*     */ import java.io.File;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.List;
> /*     */ import javax.swing.BorderFactory;
> /*     */ import javax.swing.Box;
> /*     */ import javax.swing.BoxLayout;
> /*     */ import javax.swing.DefaultListModel;
> /*     */ import javax.swing.Icon;
> /*     */ import javax.swing.ImageIcon;
> /*     */ import javax.swing.JButton;
> /*     */ import javax.swing.JCheckBox;
> /*     */ import javax.swing.JComboBox;
> /*     */ import javax.swing.JFileChooser;
> /*     */ import javax.swing.JFrame;
> /*     */ import javax.swing.JLabel;
> /*     */ import javax.swing.JList;
> /*     */ import javax.swing.JPanel;
> /*     */ import javax.swing.JScrollPane;
> /*     */ import javax.swing.JSeparator;
> /*     */ import javax.swing.JSlider;
> /*     */ import javax.swing.JSpinner;
> /*     */ import javax.swing.JTabbedPane;
> /*     */ import javax.swing.JTable;
> /*     */ import javax.swing.JToggleButton;
> /*     */ import javax.swing.SpinnerNumberModel;
> /*     */ import javax.swing.event.ChangeEvent;
> /*     */ import javax.swing.event.ChangeListener;
> /*     */ import javax.swing.table.DefaultTableCellRenderer;
> /*     */ import javax.swing.table.DefaultTableModel;
> /*     */ import jwizardcomponent.JWizardComponents;
> /*     */ import jwizardcomponent.JWizardPanel;
> /*     */ import org.jfree.chart.ChartPanel;
> /*     */ import org.jfree.chart.plot.IntervalMarker;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class ChooserWizardPanel
> /*     */   extends JWizardPanel
> /*     */ {
> /*     */   JCheckBox checkRPicker;
> /*     */   static JTable tableTrack;
> /*     */   static JTable tableImages;
> /*     */   static DefaultTableModel modelTrack;
> /*     */   JScrollPane jScrollPaneTrack;
> /*     */   JScrollPane jScrollPaneImages;
> /*     */   JSpinner filterMin;
> /*     */   JSpinner filterMax;
> /*  82 */   HistogramFilterVersion hs2 = new HistogramFilterVersion(); ChartPanel histogram; JComboBox<String> comboFilters;
> /*     */   static DefaultListModel<String> modelListClass;
> /*     */   static DefaultListModel<String> modelListFeature;
> /*     */   static JList<String> classList;
> /*     */   static JList<String> featureList;
> /*     */   static JLabel labelReset;
> /*  88 */   static String trackEnable = ""; static String command; List<Integer> indexesToReset; List<Integer> indexesToReset1; List<Integer> tracksID; List<Integer> tracksID1; List<Integer> indexesTI; static Icon iconTrackCell;
> /*     */   static Object[] columnNamesTrack;
> /*     */   Thread refreshThread;
> /*     */   Thread csvThread;
> /*     */   Thread pngThread;
> /*     */   Thread paintThread;
> /*     */   Thread tInsideThread;
> /*     */   
> /*     */   public ChooserWizardPanel(JWizardComponents wizardComponents) {
> /*  97 */     super(wizardComponents, "");
> /*     */     
> /*  99 */     tableTrack = new JTable();
> /* 100 */     tableImages = new JTable();
> /* 101 */     tableImages.setModel(FirstWizardPanel.modelImages);
> /* 102 */     tableImages.getColumnModel().getColumn(0).setPreferredWidth(90);
> /* 103 */     tableImages.getColumnModel().getColumn(1).setPreferredWidth(460);
> /* 104 */     tableImages.getColumnModel().getColumn(2).setPreferredWidth(80);
> /* 105 */     modelTrack = new DefaultTableModel();
> /* 106 */     columnNamesTrack = new Object[] { "Label", "TRACK_ID", "TRACK_INDEX", "NUMBER_SPOTS", "NUMBER_GAPS", 
> /* 107 */         "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", 
> /* 108 */         "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", 
> /* 109 */         "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", 
> /* 110 */         "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", 
> /* 111 */         "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", 
> /* 112 */         "TOTAL_ABSOLUTE_ANGLE_XY", "TOTAL_ABSOLUTE_ANGLE_YZ", "TOTAL_ABSOLUTE_ANGLE_ZX" };
> /*     */     
> /* 114 */     tableTrack.setModel(modelTrack);
> /* 115 */     tableTrack.setSelectionMode(1);
> /* 116 */     this.jScrollPaneTrack = new JScrollPane(tableTrack);
> /* 117 */     this.jScrollPaneTrack.setPreferredSize(new Dimension(590, 240));
> /* 118 */     this.jScrollPaneTrack.setBorder(BorderFactory.createTitledBorder(""));
> /* 119 */     this.jScrollPaneImages = new JScrollPane(tableImages);
> /* 120 */     this.jScrollPaneImages.setPreferredSize(new Dimension(590, 240));
> /* 121 */     this.jScrollPaneImages.setBorder(BorderFactory.createTitledBorder(""));
> /* 122 */     JPanel mainPanel = new JPanel();
> /* 123 */     mainPanel.setLayout(new BoxLayout(mainPanel, 1));
> /* 124 */     JTabbedPane tabbedPaneTrack = new JTabbedPane(1);
> /* 125 */     ImageIcon iconTrack = FirstWizardPanel.createImageIcon("images/track.jpg");
> /* 126 */     iconTrackCell = new ImageIcon(iconTrack.getImage().getScaledInstance(18, 20, 4));
> /* 127 */     JButton pngButton = new JButton();
> /* 128 */     ImageIcon iconPng = FirstWizardPanel.createImageIcon("images/save.png");
> /* 129 */     Icon pngCell = new ImageIcon(iconPng.getImage().getScaledInstance(18, 20, 4));
> /* 130 */     pngButton.setIcon(pngCell);
> /* 131 */     pngButton.setToolTipText("Click to capture spots overlay.");
> /* 132 */     JPanel panelPng = new JPanel(new FlowLayout(0));
> /* 133 */     panelPng.add(pngButton);
> /* 134 */     JButton csvButton = new JButton();
> /* 135 */     ImageIcon iconCsv = FirstWizardPanel.createImageIcon("images/csv.png");
> /* 136 */     Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
> /* 137 */     csvButton.setIcon(csvCell);
> /* 138 */     csvButton.setToolTipText("Click to export your spots table selection.");
> /* 139 */     JPanel panelCsv = new JPanel(new FlowLayout(0));
> /* 140 */     panelCsv.add(csvButton);
> /* 141 */     JPanel panelPngCsv = new JPanel(new FlowLayout(0));
> /* 142 */     panelPngCsv.add(panelPng);
> /* 143 */     panelPngCsv.add(panelCsv);
> /* 144 */     tabbedPaneTrack.addTab("TRACKS ", iconTrackCell, mainPanel, "Display Track Analysis");
> /* 145 */     tabbedPaneTrack.setTabLayoutPolicy(1);
> /* 146 */     JButton refreshButton = new JButton();
> /* 147 */     ImageIcon iconRefresh = FirstWizardPanel.createImageIcon("images/refresh.png");
> /* 148 */     Icon refreshCell = new ImageIcon(iconRefresh.getImage().getScaledInstance(18, 20, 4));
> /* 149 */     refreshButton.setIcon(refreshCell);
> /* 150 */     refreshButton.setToolTipText("Click this button to get Track analysis");
> /* 151 */     JToggleButton paintButton = new JToggleButton();
> /* 152 */     ImageIcon iconPaint = FirstWizardPanel.createImageIcon("images/paint.png");
> /* 153 */     Icon paintCell = new ImageIcon(iconPaint.getImage().getScaledInstance(18, 20, 4));
> /* 154 */     paintButton.setIcon(paintCell);
> /* 155 */     paintButton.setToolTipText("Click this button to display labeled-Tracks");
> /* 156 */     JToggleButton tInsideButton = new JToggleButton();
> /* 157 */     ImageIcon iconTI = FirstWizardPanel.createImageIcon("images/tinside.png");
> /* 158 */     Icon TICell = new ImageIcon(iconTI.getImage().getScaledInstance(18, 20, 4));
> /* 159 */     tInsideButton.setIcon(TICell);
> /* 160 */     tInsideButton.setToolTipText("Click this button to toggle inside Tracks.");
> /* 161 */     JToggleButton tOutsideButton = new JToggleButton();
> /* 162 */     ImageIcon iconTO = FirstWizardPanel.createImageIcon("images/toutside.png");
> /* 163 */     Icon TOCell = new ImageIcon(iconTO.getImage().getScaledInstance(18, 20, 4));
> /* 164 */     tOutsideButton.setIcon(TOCell);
> /* 165 */     tOutsideButton.setToolTipText("Click this button to toggle outside Tracks.");
> /* 166 */     JButton enableButton = new JButton();
> /* 167 */     ImageIcon iconEnable = FirstWizardPanel.createImageIcon("images/enable.png");
> /* 168 */     Icon enableCell = new ImageIcon(iconEnable.getImage().getScaledInstance(18, 20, 4));
> /* 169 */     enableButton.setIcon(enableCell);
> /* 170 */     enableButton.setToolTipText("Click this button to enable your selection");
> /* 171 */     JButton disableButton = new JButton();
> /* 172 */     ImageIcon iconDisable = FirstWizardPanel.createImageIcon("images/disable.png");
> /* 173 */     Icon disableCell = new ImageIcon(iconDisable.getImage().getScaledInstance(18, 20, 4));
> /* 174 */     disableButton.setIcon(disableCell);
> /* 175 */     disableButton.setToolTipText("Click this button to disable your selection");
> /* 176 */     JPanel buttonPanel = new JPanel(new FlowLayout(2));
> /* 177 */     JSeparator separator1 = new JSeparator(1);
> /* 178 */     JSeparator separator2 = new JSeparator(1);
> /* 179 */     Dimension dime = separator1.getPreferredSize();
> /* 180 */     dime.height = (refreshButton.getPreferredSize()).height;
> /* 181 */     separator1.setPreferredSize(dime);
> /* 182 */     separator2.setPreferredSize(dime);
> /* 183 */     this.checkRPicker = new JCheckBox(" Track Picker");
> /* 184 */     JLabel filterLabel = new JLabel("   Track Analysis : ");
> /* 185 */     filterLabel.setFont(new Font("Dialog", 1, 13));
> /* 186 */     filterLabel.setBorder(BorderFactory.createRaisedBevelBorder());
> /* 187 */     JPanel filterPanel = new JPanel(new FlowLayout(0));
> /* 188 */     filterPanel.add(filterLabel);
> /* 189 */     filterPanel.add(this.checkRPicker);
> /* 190 */     filterPanel.add(Box.createHorizontalStrut(20));
> /* 191 */     JPanel filterMain = new JPanel(new FlowLayout(0));
> /* 192 */     filterMain.add(filterPanel);
> /* 193 */     buttonPanel.add(refreshButton);
> /* 194 */     buttonPanel.add(paintButton);
> /* 195 */     buttonPanel.add(separator1);
> /* 196 */     buttonPanel.add(enableButton);
> /* 197 */     buttonPanel.add(disableButton);
> /* 198 */     buttonPanel.add(separator2);
> /* 199 */     buttonPanel.add(tInsideButton);
> /* 200 */     buttonPanel.add(tOutsideButton);
> /* 201 */     filterMain.add(buttonPanel);
> /* 202 */     mainPanel.add(this.jScrollPaneImages);
> /* 203 */     mainPanel.add(Box.createVerticalStrut(5));
> /* 204 */     mainPanel.add(filterMain);
> /* 205 */     mainPanel.add(this.jScrollPaneTrack);
> /* 206 */     JLabel settingsLabel = new JLabel("   Settings for Filters/Classes : ");
> /* 207 */     settingsLabel.setFont(new Font("Dialog", 1, 13));
> /* 208 */     settingsLabel.setBorder(BorderFactory.createRaisedBevelBorder());
> /* 209 */     JPanel settingsPanel = new JPanel(new FlowLayout(0));
> /* 210 */     settingsPanel.add(settingsLabel);
> /* 211 */     mainPanel.add(settingsPanel);
> /* 212 */     JPanel filtersMin = new JPanel(new FlowLayout(0));
> /* 213 */     this.filterMin = new JSpinner(new SpinnerNumberModel(30, 0, 5000, 1));
> /* 214 */     this.filterMin.setPreferredSize(new Dimension(60, 20));
> /* 215 */     final JSlider sliderMin = new JSlider(0, 300, 50);
> /* 216 */     sliderMin.setPreferredSize(new Dimension(150, 15));
> /* 217 */     JLabel filterMinLabel = new JLabel("              Min :  ");
> /* 218 */     filtersMin.add(filterMinLabel);
> /* 219 */     filtersMin.add(sliderMin);
> /* 220 */     filtersMin.add(Box.createHorizontalStrut(2));
> /* 221 */     filtersMin.add(this.filterMin);
> /* 222 */     JPanel filtersMax = new JPanel(new FlowLayout(0));
> /* 223 */     this.filterMax = new JSpinner(new SpinnerNumberModel(200, 0, 5000, 1));
> /* 224 */     this.filterMax.setPreferredSize(new Dimension(60, 20));
> /* 225 */     final JSlider sliderMax = new JSlider(0, 300, 150);
> /* 226 */     sliderMax.setPreferredSize(new Dimension(150, 15));
> /* 227 */     JLabel filterMaxLabel = new JLabel("              Max :  ");
> /* 228 */     filtersMax.add(filterMaxLabel);
> /* 229 */     filtersMax.add(sliderMax);
> /* 230 */     filtersMax.add(Box.createHorizontalStrut(2));
> /* 231 */     filtersMax.add(this.filterMax);
> /* 232 */     JPanel boxPanel2 = new JPanel();
> /* 233 */     boxPanel2.setLayout(new BoxLayout(boxPanel2, 1));
> /* 234 */     final IntervalMarker intervalMarker = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), 
> /* 235 */         new Color(0, 102, 0), new BasicStroke(1.5F), 0.5F);
> /* 236 */     this.histogram = this.hs2.createChartPanel("", new double[] { 0.0D, 0.0D, 0.0D }, 100, intervalMarker);
> /*     */     
> /* 238 */     JPanel chartPanel2 = new JPanel(new BorderLayout());
> /* 239 */     chartPanel2.setPreferredSize(new Dimension(390, 180));
> /* 240 */     chartPanel2.add((Component)this.histogram);
> /* 241 */     boxPanel2.add(chartPanel2);
> /* 242 */     JPanel controlPanel2 = this.hs2.createControlPanel();
> /* 243 */     boxPanel2.add(controlPanel2);
> /* 244 */     JPanel filtersMain2 = new JPanel();
> /* 245 */     filtersMain2.setLayout(new BoxLayout(filtersMain2, 1));
> /* 246 */     filtersMain2.add(boxPanel2);
> /* 247 */     filtersMain2.add(filtersMin);
> /* 248 */     filtersMain2.add(filtersMax);
> /* 249 */     JLabel featureTrack = new JLabel("  Track-Features :  ");
> /* 250 */     featureTrack.setFont(new Font("Dialog", 1, 13));
> /* 251 */     this.comboFilters = new JComboBox<>();
> /* 252 */     for (int i = 1; i < columnNamesTrack.length; i++)
> /* 253 */       this.comboFilters.addItem((String)columnNamesTrack[i]); 
> /* 254 */     this.comboFilters.setPreferredSize(new Dimension(130, 25));
> /* 255 */     this.comboFilters.setSelectedIndex(0);
> /* 256 */     this.comboFilters.setOpaque(true);
> /* 257 */     JPanel panelFilters = new JPanel(new FlowLayout(0));
> /* 258 */     JSeparator separator3 = new JSeparator(1);
> /* 259 */     Dimension dime2 = separator3.getPreferredSize();
> /* 260 */     dime2.height = (filtersMain2.getPreferredSize()).height;
> /* 261 */     separator3.setPreferredSize(dime2);
> /* 262 */     panelFilters.add(filtersMain2);
> /* 263 */     panelFilters.add(separator3);
> /* 264 */     modelListClass = new DefaultListModel<>();
> /* 265 */     classList = new JList<>(modelListClass);
> /* 266 */     modelListFeature = new DefaultListModel<>();
> /* 267 */     featureList = new JList<>(modelListFeature);
> /* 268 */     final ColorEditorTrack colorEditor = new ColorEditorTrack(featureList);
> /* 269 */     JScrollPane scrollListFilter = new JScrollPane(featureList);
> /* 270 */     JScrollPane scrollListClass = new JScrollPane(classList);
> /* 271 */     Dimension d = featureList.getPreferredSize();
> /* 272 */     d.width = 150;
> /* 273 */     d.height = 90;
> /* 274 */     scrollListFilter.setPreferredSize(d);
> /* 275 */     scrollListClass.setPreferredSize(d);
> /* 276 */     JPanel filterPanelButtons = new JPanel(new FlowLayout(0));
> /* 277 */     JPanel classPanelButtons = new JPanel();
> /* 278 */     classPanelButtons.setLayout(new BoxLayout(classPanelButtons, 1));
> /* 279 */     filterPanelButtons.add(scrollListFilter);
> /* 280 */     JPanel fButtonsPanel = new JPanel();
> /* 281 */     fButtonsPanel.setLayout(new BoxLayout(fButtonsPanel, 1));
> /* 282 */     JButton addButton = new JButton();
> /* 283 */     ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
> /* 284 */     Icon addCell = new ImageIcon(iconAdd.getImage().getScaledInstance(14, 16, 4));
> /* 285 */     addButton.setIcon(addCell);
> /* 286 */     addButton.setToolTipText("Click this button to add features");
> /* 287 */     JButton remButton = new JButton();
> /* 288 */     ImageIcon iconRem = FirstWizardPanel.createImageIcon("images/remove.png");
> /* 289 */     Icon remCell = new ImageIcon(iconRem.getImage().getScaledInstance(14, 16, 4));
> /* 290 */     remButton.setIcon(remCell);
> /* 291 */     remButton.setToolTipText("Click this button to remove features");
> /* 292 */     JButton classButton = new JButton();
> /* 293 */     ImageIcon iconClass = FirstWizardPanel.createImageIcon("images/classes.png");
> /* 294 */     Icon classCell = new ImageIcon(iconClass.getImage().getScaledInstance(14, 16, 4));
> /* 295 */     classButton.setIcon(classCell);
> /* 296 */     classButton.setToolTipText("Click this button to create a class.");
> /* 297 */     JButton remClassButton = new JButton();
> /* 298 */     remClassButton.setIcon(remCell);
> /* 299 */     remClassButton.setToolTipText("Click this button to remove a class.");
> /* 300 */     fButtonsPanel.add(addButton);
> /* 301 */     fButtonsPanel.add(remButton);
> /* 302 */     filterPanelButtons.add(fButtonsPanel);
> /* 303 */     classPanelButtons.add(classButton);
> /* 304 */     classPanelButtons.add(remClassButton);
> /* 305 */     JPanel classPanel = new JPanel(new FlowLayout(0));
> /* 306 */     classPanel.add(scrollListClass);
> /* 307 */     classPanel.add(classPanelButtons);
> /* 308 */     JPanel boxPanel = new JPanel();
> /* 309 */     boxPanel.setLayout(new BoxLayout(boxPanel, 1));
> /* 310 */     boxPanel.add(this.comboFilters);
> /* 311 */     boxPanel.add(Box.createHorizontalStrut(5));
> /* 312 */     boxPanel.add(filterPanelButtons);
> /* 313 */     boxPanel.add(Box.createHorizontalStrut(5));
> /* 314 */     boxPanel.add(classPanel);
> /* 315 */     boxPanel.add(panelPngCsv);
> /* 316 */     panelFilters.add(boxPanel);
> /* 317 */     mainPanel.add(panelFilters);
> /* 318 */     add(tabbedPaneTrack);
> /* 319 */     createMovieTable();
> /*     */     
> /* 321 */     paintButton.addItemListener(new ItemListener() {
> /*     */           public void itemStateChanged(final ItemEvent ev) {
> /* 323 */             ChooserWizardPanel.this.paintThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 325 */                     if (ev.getStateChange() == 1) {
> /* 326 */                       ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this).paintAndDisableAction();
> /* 327 */                     } else if (ev.getStateChange() == 2) {
> /* 328 */                       ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this).resetAndEnableAction();
> /*     */                     } 
> /*     */                   }
> /*     */                 });
> /* 332 */             ChooserWizardPanel.this.paintThread.start();
> /*     */           }
> /*     */         });
> /* 335 */     csvButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 338 */             ChooserWizardPanel.this.csvThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 340 */                     List<String> columnTrackHead = new ArrayList<>();
> /* 341 */                     for (int j = 0; j < ChooserWizardPanel.modelTrack.getColumnCount(); j++) {
> /* 342 */                       columnTrackHead.add(ChooserWizardPanel.modelTrack.getColumnName(j));
> /*     */                     }
> /* 344 */                     ResultsTable rt = new ResultsTable(Integer.valueOf(ChooserWizardPanel.modelTrack.getRowCount()));
> /* 345 */                     if (rt != null) {
> /* 346 */                       rt.reset();
> /*     */                     }
> /* 348 */                     for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); i++) {
> /* 349 */                       for (int k = 0; k < ChooserWizardPanel.modelTrack.getColumnCount(); k++) {
> /* 350 */                         if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE)
> /*     */                         {
> /* 352 */                           if (((String)columnTrackHead.get(k)).equals(columnTrackHead.get(0)) == Boolean.TRUE.booleanValue()) {
> /*     */                             
> /* 354 */                             rt.setValue(columnTrackHead.get(k), i, (
> /* 355 */                                 (JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, k)).getText());
> /*     */                           } else {
> /*     */                             
> /* 358 */                             rt.setValue(columnTrackHead.get(k), i, ChooserWizardPanel.modelTrack.getValueAt(i, k).toString());
> /*     */                           }  } 
> /*     */                       } 
> /* 361 */                     }  rt.show("Resutls tracks");
> /*     */                   }
> /*     */                 });
> /* 364 */             ChooserWizardPanel.this.csvThread.start();
> /*     */           }
> /*     */         });
> /*     */     
> /* 368 */     pngButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 371 */             ChooserWizardPanel.this.pngThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 373 */                     if (IJ.getImage() == null)
> /* 374 */                       IJ.error("You must have an image window active."); 
> /* 375 */                     if (IJ.getImage() != null) {
> /* 376 */                       JFrame pngFrame = new JFrame();
> /* 377 */                       JFileChooser fileChooser = new JFileChooser();
> /* 378 */                       fileChooser.setFileSelectionMode(1);
> /* 379 */                       fileChooser.setDialogTitle("Specify a directory to save");
> /* 380 */                       int userSelection = fileChooser.showSaveDialog(pngFrame);
> /*     */                       
> /* 382 */                       if (userSelection == 0) {
> /* 383 */                         File fileToSave = fileChooser.getSelectedFile();
> /*     */                         
> /* 385 */                         int firstFrame = 0, lastFrame = 0;
> /* 386 */                         if (ProcessTrackMateXml.displayer.getImp().getNFrames() > 1) {
> /* 387 */                           firstFrame = Math.max(1, Math.min(IJ.getImage().getNFrames(), 1));
> /* 388 */                           lastFrame = Math.min(IJ.getImage().getNFrames(), 
> /* 389 */                               Math.max(IJ.getImage().getNFrames(), 1));
> /*     */                         } 
> /* 391 */                         if (ProcessTrackMateXml.displayer.getImp().getNSlices() > 1) {
> /* 392 */                           firstFrame = Math.max(1, Math.min(IJ.getImage().getNSlices(), 1));
> /* 393 */                           lastFrame = Math.min(IJ.getImage().getNSlices(), 
> /* 394 */                               Math.max(IJ.getImage().getNSlices(), 1));
> /*     */                         } 
> /*     */                         
> /* 397 */                         Rectangle bounds = ProcessTrackMateXml.displayer.getImp().getCanvas().getBounds();
> /* 398 */                         int width = bounds.width;
> /* 399 */                         int height = bounds.height;
> /* 400 */                         int nCaptures = lastFrame - firstFrame + 1;
> /* 401 */                         ImageStack stack = new ImageStack(width, height);
> /* 402 */                         int channel = ProcessTrackMateXml.displayer.getImp().getChannel();
> /* 403 */                         int slice = ProcessTrackMateXml.displayer.getImp().getSlice();
> /* 404 */                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(true);
> /* 405 */                         for (int frame = firstFrame; frame <= lastFrame; frame++) {
> /*     */                           
> /* 407 */                           ProcessTrackMateXml.displayer.getImp().setPositionWithoutUpdate(channel, slice, 
> /* 408 */                               frame);
> /* 409 */                           BufferedImage bi = new BufferedImage(width, height, 2);
> /* 410 */                           ProcessTrackMateXml.displayer.getImp().getCanvas().paint(bi.getGraphics());
> /* 411 */                           ColorProcessor cp = new ColorProcessor(bi);
> /* 412 */                           int index = ProcessTrackMateXml.displayer.getImp().getStackIndex(channel, slice, 
> /* 413 */                               frame);
> /* 414 */                           stack.addSlice(
> /* 415 */                               ProcessTrackMateXml.displayer.getImp().getImageStack().getSliceLabel(index), 
> /* 416 */                               (ImageProcessor)cp);
> /*     */                         } 
> /* 418 */                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(false);
> /* 419 */                         ImagePlus capture = new ImagePlus("TrackMate capture of " + 
> /* 420 */                             ProcessTrackMateXml.displayer.getImp().getShortTitle(), stack);
> /* 421 */                         ChooserWizardPanel.transferCalibration(ProcessTrackMateXml.displayer.getImp(), capture);
> /* 422 */                         IJ.saveAs(capture, "Tiff", String.valueOf(fileToSave.getAbsolutePath()) + File.separator + 
> /* 423 */                             "Capture Overlay for " + IJ.getImage().getShortTitle());
> /*     */                       } 
> /*     */                     } 
> /*     */                   }
> /*     */                 });
> /* 428 */             ChooserWizardPanel.this.pngThread.start();
> /*     */           }
> /*     */         });
> /* 431 */     refreshButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 434 */             ChooserWizardPanel.this.refreshThread = new Thread(new Runnable()
> /*     */                 {
> /*     */                   public void run() {
> /* 437 */                     ChooserWizardPanel.trackEnable = "trackEnable";
> /* 438 */                     ProcessTrackMateXml.tracksVisible = true;
> /* 439 */                     ProcessTrackMateXml.spotsVisible = false;
> /* 440 */                     ProcessTrackMateXml ptx = new ProcessTrackMateXml();
> /* 441 */                     ptx.processTrackMateXml();
> /*     */                   }
> /*     */                 });
> /* 444 */             ChooserWizardPanel.this.refreshThread.start();
> /*     */           }
> /*     */         });
> /*     */     
> /* 448 */     enableButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 451 */             ChooserWizardPanel.this.enableThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 453 */                     ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this).enableTracks();
> /*     */                   }
> /*     */                 });
> /* 456 */             ChooserWizardPanel.this.enableThread.start();
> /*     */           }
> /*     */         });
> /*     */     
> /* 460 */     disableButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 463 */             ChooserWizardPanel.this.disableThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 465 */                     ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this).disableTracks();
> /*     */                   }
> /*     */                 });
> /* 468 */             ChooserWizardPanel.this.disableThread.start();
> /*     */           }
> /*     */         });
> /*     */     
> /* 472 */     this.checkRPicker.addItemListener(new ItemListener()
> /*     */         {
> /*     */           public void itemStateChanged(final ItemEvent e)
> /*     */           {
> /* 476 */             ChooserWizardPanel.this.pickerThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 478 */                     if (e.getStateChange() == 1)
> /* 479 */                       ChooserWizardPanel.command = "enable"; 
> /* 480 */                     if (e.getStateChange() == 2) {
> /* 481 */                       ChooserWizardPanel.command = null;
> /* 482 */                       ProcessTrackMateXml.selectionModel.clearSpotSelection();
> /* 483 */                       ProcessTrackMateXml.selectionModel.clearSelection();
> /*     */                       return;
> /*     */                     } 
> /*     */                   }
> /*     */                 });
> /* 488 */             ChooserWizardPanel.this.pickerThread.start();
> /*     */           }
> /*     */         });
> /*     */     
> /* 492 */     sliderMin.addChangeListener(new ChangeListener()
> /*     */         {
> /*     */           public void stateChanged(ChangeEvent e) {
> /* 495 */             ChooserWizardPanel.this.slMinThread = new Thread(new Runnable()
> /*     */                 {
> /*     */                   public void run() {
> /* 498 */                     (ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).filterMin.setValue(Integer.valueOf(sliderMin.getValue()));
> /* 499 */                     intervalMarker.setStartValue(sliderMin.getValue());
> /*     */                   }
> /*     */                 });
> /* 502 */             ChooserWizardPanel.this.slMinThread.start();
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 507 */     this.filterMin.addChangeListener(new ChangeListener()
> /*     */         {
> /*     */           public void stateChanged(ChangeEvent e) {
> /* 510 */             ChooserWizardPanel.this.filterMinThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 512 */                     sliderMin.setValue(((Integer)(ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).filterMin.getValue()).intValue());
> /* 513 */                     intervalMarker.setStartValue(((Integer)(ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).filterMin.getValue()).intValue());
> /*     */                   }
> /*     */                 });
> /* 516 */             ChooserWizardPanel.this.filterMinThread.start();
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 521 */     sliderMax.addChangeListener(new ChangeListener()
> /*     */         {
> /*     */           public void stateChanged(ChangeEvent e) {
> /* 524 */             ChooserWizardPanel.this.slMaxThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 526 */                     (ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).filterMax.setValue(Integer.valueOf(sliderMax.getValue()));
> /* 527 */                     intervalMarker.setEndValue(sliderMax.getValue());
> /*     */                   }
> /*     */                 });
> /* 530 */             ChooserWizardPanel.this.slMaxThread.start();
> /*     */           }
> /*     */         });
> /*     */     
> /* 534 */     this.filterMax.addChangeListener(new ChangeListener()
> /*     */         {
> /*     */           public void stateChanged(ChangeEvent e) {
> /* 537 */             ChooserWizardPanel.this.filterMaxThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 539 */                     sliderMax.setValue(((Integer)(ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).filterMax.getValue()).intValue());
> /* 540 */                     intervalMarker.setEndValue(((Integer)(ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).filterMax.getValue()).intValue());
> /*     */                   }
> /*     */                 });
> /* 543 */             ChooserWizardPanel.this.filterMaxThread.start();
> /*     */           }
> /*     */         });
> /* 546 */     tInsideButton.addItemListener(new ItemListener() {
> /*     */           public void itemStateChanged(final ItemEvent ev) {
> /* 548 */             ChooserWizardPanel.this.tInsideThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 550 */                     if (ev.getStateChange() == 1) {
> /* 551 */                       ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this).toggleInsideAction();
> /* 552 */                     } else if (ev.getStateChange() == 2) {
> /* 553 */                       ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this).resetToggleInsideAction();
> /*     */                     } 
> /*     */                   }
> /*     */                 });
> /* 557 */             ChooserWizardPanel.this.tInsideThread.start();
> /*     */           }
> /*     */         });
> /* 560 */     this.comboFilters.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 562 */             ChooserWizardPanel.this.filtersThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 564 */                     String selectedName = (String)(ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).comboFilters.getSelectedItem();
> /* 565 */                     int selectedIndex = (ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).comboFilters.getSelectedIndex();
> /* 566 */                     double[] values = null;
> /*     */ 
> /*     */                     
> /* 569 */                     values = new double[ChooserWizardPanel.tableTrack.getRowCount()];
> /* 570 */                     for (int r = 0; r < ChooserWizardPanel.tableTrack.getRowCount(); r++) {
> /* 571 */                       for (int c = 0; c < ChooserWizardPanel.tableTrack.getColumnCount(); c++)
> /* 572 */                         values[r] = Double.parseDouble((String)ChooserWizardPanel.tableTrack.getValueAt(r, selectedIndex + 2)); 
> /*     */                     } 
> /* 574 */                     double max = values[0];
> /* 575 */                     for (int i = 1; i < values.length; i++) {
> /* 576 */                       if (values[i] > max)
> /* 577 */                         max = values[i]; 
> /*     */                     } 
> /* 579 */                     sliderMin.setMinimum(0);
> /* 580 */                     sliderMin.setMaximum((int)max);
> /* 581 */                     sliderMax.setMinimum(0);
> /* 582 */                     sliderMax.setMaximum((int)max);
> /*     */                     
> /* 584 */                     (ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).hs2.addHistogramSeries(selectedName, values, (int)max, intervalMarker);
> /*     */                   }
> /*     */                 });
> /* 587 */             ChooserWizardPanel.this.filtersThread.start();
> /*     */           }
> /*     */         });
> /*     */     
> /* 591 */     classButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 594 */             ChooserWizardPanel.this.classThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 596 */                     ColorEditorTrack.myFrame.setVisible(true);
> /* 597 */                     colorEditor.setClassAction();
> /*     */                   }
> /*     */                 });
> /* 600 */             ChooserWizardPanel.this.classThread.start();
> /*     */           }
> /*     */         });
> /* 603 */     remClassButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 606 */             ChooserWizardPanel.this.remClassThread = new Thread(new Runnable()
> /*     */                 {
> /*     */                   public void run() {
> /* 609 */                     String classSelectedValue = ChooserWizardPanel.classList.getSelectedValue();
> /* 610 */                     int[] classSelectedIndex = ChooserWizardPanel.classList.getSelectedIndices(); int i;
> /* 611 */                     for (i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); i++) {
> /* 612 */                       if (((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1))).getText()
> /* 613 */                         .equals(classSelectedValue))
> /* 614 */                         ChooserWizardPanel.modelTrack.setValueAt(ChooserWizardPanel.labelReset, i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1)); 
> /*     */                     } 
> /* 616 */                     for (i = 0; i < classSelectedIndex.length; i++)
> /* 617 */                       ChooserWizardPanel.modelListClass.removeElementAt(classSelectedIndex[i]); 
> /*     */                   }
> /*     */                 });
> /* 620 */             ChooserWizardPanel.this.remClassThread.start();
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 625 */     addButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 628 */             ChooserWizardPanel.this.addThread = new Thread(new Runnable()
> /*     */                 {
> /*     */                   public void run() {
> /* 631 */                     List<String> listFilters = new ArrayList<>();
> /*     */                     
> /* 633 */                     if (ChooserWizardPanel.featureList.getModel().getSize() < 1) {
> /* 634 */                       ChooserWizardPanel.modelListFeature.addElement(String.valueOf((ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).comboFilters.getSelectedItem()) + ":  [" + 
> /* 635 */                           (ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).filterMin.getValue() + "," + (ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).filterMax.getValue() + "]");
> /*     */                     }
> /* 637 */                     if (ChooserWizardPanel.featureList.getModel().getSize() >= 1) {
> /* 638 */                       for (int i = 0; i < ChooserWizardPanel.featureList.getModel().getSize(); i++) {
> /* 639 */                         listFilters.add(String.valueOf(((String)ChooserWizardPanel.featureList.getModel().getElementAt(i)).substring(0, (
> /* 640 */                                 (String)ChooserWizardPanel.featureList.getModel().getElementAt(i)).lastIndexOf(":"))));
> /*     */                       }
> /* 642 */                       if (!listFilters.contains((ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).comboFilters.getSelectedItem().toString())) {
> /* 643 */                         ChooserWizardPanel.modelListFeature.addElement(String.valueOf((ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).comboFilters.getSelectedItem()) + ":  [" + 
> /* 644 */                             (ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).filterMin.getValue() + "," + (ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).filterMax.getValue() + "]");
> /*     */                       }
> /* 646 */                       if (listFilters.contains((ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this)).comboFilters.getSelectedItem().toString())) {
> /*     */                         return;
> /*     */                       }
> /*     */                     } 
> /*     */                   }
> /*     */                 });
> /* 652 */             ChooserWizardPanel.this.addThread.start();
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 657 */     remButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 660 */             ChooserWizardPanel.this.remThread = new Thread(new Runnable()
> /*     */                 {
> /*     */                   public void run() {
> /*     */                     try {
> /* 664 */                       int[] indexes = ChooserWizardPanel.featureList.getSelectedIndices();
> /* 665 */                       for (int i = 0; i < indexes.length; i++)
> /* 666 */                         ChooserWizardPanel.modelListFeature.remove(indexes[i]); 
> /* 667 */                     } catch (Exception e1) {
> /* 668 */                       e1.printStackTrace();
> /*     */                     } 
> /*     */                   }
> /*     */                 });
> /* 672 */             ChooserWizardPanel.this.remThread.start();
> /*     */           }
> /*     */         });
> /* 675 */     tOutsideButton.addItemListener(new ItemListener() {
> /*     */           public void itemStateChanged(final ItemEvent ev) {
> /* 677 */             ChooserWizardPanel.this.tOutsideThread = new Thread(new Runnable()
> /*     */                 {
> /*     */                   public void run() {
> /* 680 */                     if (ev.getStateChange() == 1) {
> /* 681 */                       ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this).toggleOutsideAction();
> /* 682 */                     } else if (ev.getStateChange() == 2) {
> /* 683 */                       ChooserWizardPanel.null.access$0(ChooserWizardPanel.null.this).resetToggleInsideAction();
> /*     */                     } 
> /*     */                   }
> /*     */                 });
> /*     */             
> /* 688 */             ChooserWizardPanel.this.tOutsideThread.start();
> /*     */           }
> /*     */         });
> /*     */   }
> /*     */   Thread tOutsideThread; Thread enableThread; Thread disableThread; Thread slMinThread; Thread filterMinThread; Thread slMaxThread; Thread filterMaxThread; Thread filtersThread; Thread pickerThread; Thread classThread; Thread remClassThread; Thread addThread; Thread remThread;
> /*     */   public void toggleOutsideAction() {
> /* 694 */     Roi mainRoi = null;
> /* 695 */     if (IJ.getImage().getRoi().getType() == 0)
> /* 696 */       mainRoi = IJ.getImage().getRoi(); 
> /* 697 */     this.indexesTI = new ArrayList<>();
> /*     */     
> /* 699 */     for (int i = 0; i < modelTrack.getRowCount(); i++) {
> /*     */       
> /* 701 */       if (mainRoi
> /* 702 */         .contains(
> /*     */           
> /* 704 */           (int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(modelTrack
> /* 705 */               .getValueAt(i, tableTrack.convertColumnIndexToModel(13)).toString())), 
> /*     */           
> /* 707 */           (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(
> /* 708 */               modelTrack.getValueAt(i, tableTrack.convertColumnIndexToModel(14))
> /* 709 */               .toString()))) == Boolean.FALSE.booleanValue()) {
> /* 710 */         this.indexesTI.add(Integer.valueOf(i));
> /* 711 */         modelTrack.setValueAt(Boolean.valueOf(false), i, tableTrack.convertColumnIndexToModel(0));
> /*     */         
> /* 713 */         int trackID = Integer.parseInt((String)tableTrack.getValueAt(i, 2));
> /* 714 */         ProcessTrackMateXml.model.beginUpdate();
> /*     */         try {
> /* 716 */           ProcessTrackMateXml.model.setTrackVisibility(Integer.valueOf(trackID), false);
> /*     */         } finally {
> /* 718 */           ProcessTrackMateXml.model.endUpdate();
> /*     */         } 
> /*     */         
> /* 721 */         ProcessTrackMateXml.displayer.refresh();
> /*     */       } 
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void toggleInsideAction() {
> /* 729 */     Roi mainRoi = null;
> /* 730 */     if (IJ.getImage().getRoi().getType() == 0)
> /* 731 */       mainRoi = IJ.getImage().getRoi(); 
> /* 732 */     this.indexesTI = new ArrayList<>();
> /*     */     
> /* 734 */     for (int i = 0; i < modelTrack.getRowCount(); i++) {
> /*     */       
> /* 736 */       if (mainRoi
> /* 737 */         .contains(
> /*     */           
> /* 739 */           (int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(modelTrack
> /* 740 */               .getValueAt(i, tableTrack.convertColumnIndexToModel(13)).toString())), 
> /*     */           
> /* 742 */           (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(
> /* 743 */               modelTrack.getValueAt(i, tableTrack.convertColumnIndexToModel(14))
> /* 744 */               .toString()))) == Boolean.TRUE.booleanValue()) {
> /* 745 */         this.indexesTI.add(Integer.valueOf(i));
> /* 746 */         modelTrack.setValueAt(Boolean.valueOf(false), i, tableTrack.convertColumnIndexToModel(0));
> /*     */         
> /* 748 */         int trackID = Integer.parseInt((String)tableTrack.getValueAt(i, 2));
> /* 749 */         ProcessTrackMateXml.model.beginUpdate();
> /*     */         try {
> /* 751 */           ProcessTrackMateXml.model.setTrackVisibility(Integer.valueOf(trackID), false);
> /*     */         } finally {
> /* 753 */           ProcessTrackMateXml.model.endUpdate();
> /*     */         } 
> /*     */         
> /* 756 */         ProcessTrackMateXml.displayer.refresh();
> /*     */       } 
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void resetToggleInsideAction() {
> /* 765 */     for (int row = 0; row < modelTrack.getRowCount(); row++) {
> /* 766 */       modelTrack.setValueAt(Boolean.valueOf(true), tableTrack.convertRowIndexToModel(row), 
> /* 767 */           tableTrack.convertColumnIndexToModel(0));
> /* 768 */       int trackID = Integer.parseInt((String)tableTrack.getValueAt(row, 2));
> /* 769 */       ProcessTrackMateXml.model.beginUpdate();
> /*     */       try {
> /* 771 */         ProcessTrackMateXml.model.setTrackVisibility(Integer.valueOf(trackID), true);
> /*     */       } finally {
> /* 773 */         ProcessTrackMateXml.model.endUpdate();
> /*     */       } 
> /*     */       
> /* 776 */       ProcessTrackMateXml.displayer.refresh();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static void createTrackTable() {
> /* 783 */     modelTrack = new DefaultTableModel((Object[][])ProcessTrackMateXml.dataTrack, (Object[])ProcessTrackMateXml.columnHeadersTrack)
> /*     */       {
> /*     */         public Class<?> getColumnClass(int column)
> /*     */         {
> /* 787 */           if (getRowCount() > 0) {
> /* 788 */             Object value = getValueAt(0, column);
> /* 789 */             if (value != null) {
> /* 790 */               return getValueAt(0, column).getClass();
> /*     */             }
> /*     */           } 
> /*     */           
> /* 794 */           return super.getColumnClass(column);
> /*     */         }
> /*     */       };
> /*     */     
> /* 798 */     modelTrack.addColumn("Enable");
> /* 799 */     tableTrack.setModel(modelTrack);
> /* 800 */     tableTrack.moveColumn(tableTrack.getColumnCount() - 1, 0);
> /* 801 */     tableTrack.setSelectionBackground(new Color(229, 255, 204));
> /* 802 */     tableTrack.setSelectionForeground(new Color(0, 102, 0));
> /* 803 */     DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
> /* 804 */     centerRenderer.setHorizontalAlignment(0);
> /* 805 */     tableTrack.setDefaultRenderer(String.class, centerRenderer);
> /* 806 */     tableTrack.setAutoResizeMode(0);
> /* 807 */     tableTrack.setRowHeight(45);
> /* 808 */     tableTrack.setAutoCreateRowSorter(true);
> /* 809 */     tableTrack.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer()); int u;
> /* 810 */     for (u = 0; u < tableTrack.getColumnCount(); u++)
> /* 811 */       tableTrack.getColumnModel().getColumn(u).setPreferredWidth(90); 
> /* 812 */     for (u = 3; u < tableTrack.getColumnCount(); u++)
> /* 813 */       tableTrack.getColumnModel().getColumn(u).setPreferredWidth(130); 
> /*     */     int i;
> /* 815 */     for (i = 0; i < tableTrack.getRowCount(); i++)
> /* 816 */       tableTrack.setValueAt(Boolean.valueOf(true), i, 0); 
> /* 817 */     tableTrack.getColumnModel().getColumn(1).setCellRenderer(new Renderer());
> /* 818 */     labelReset = new JLabel();
> /* 819 */     labelReset.setText("");
> /* 820 */     labelReset.setOpaque(true);
> /* 821 */     labelReset.setBackground(new Color(214, 217, 223));
> /* 822 */     for (i = 0; i < modelTrack.getRowCount(); i++) {
> /* 823 */       modelTrack.setValueAt(labelReset, i, tableTrack.convertColumnIndexToModel(1));
> /*     */     }
> /*     */   }
> /*     */   
> /*     */   public void enableTracks() {
> /* 828 */     this.indexesToReset1 = new ArrayList<>();
> /* 829 */     this.tracksID1 = new ArrayList<>();
> /* 830 */     int[] selectedRows = tableTrack.getSelectedRows();
> /* 831 */     for (int i = 0; i < selectedRows.length; i++) {
> /* 832 */       this.indexesToReset1.add(Integer.valueOf(selectedRows[i]));
> /* 833 */       modelTrack.setValueAt(Boolean.valueOf(true), selectedRows[i], tableTrack.convertColumnIndexToModel(0));
> /* 834 */       this.tracksID1.add(Integer.valueOf(Integer.parseInt((String)tableTrack.getValueAt(selectedRows[i], 2))));
> /*     */     } 
> /*     */     
> /* 837 */     for (int row = 0; row < this.tracksID1.size(); row++) {
> /*     */       
> /* 839 */       ProcessTrackMateXml.model.beginUpdate();
> /*     */       try {
> /* 841 */         ProcessTrackMateXml.model.setTrackVisibility(this.tracksID1.get(row), true);
> /*     */       } finally {
> /* 843 */         ProcessTrackMateXml.model.endUpdate();
> /*     */       } 
> /*     */ 
> /*     */       
> /* 847 */       ProcessTrackMateXml.displayer.refresh();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void disableTracks() {
> /* 854 */     this.indexesToReset1 = new ArrayList<>();
> /* 855 */     this.tracksID1 = new ArrayList<>();
> /* 856 */     int[] selectedRows = tableTrack.getSelectedRows();
> /* 857 */     for (int i = 0; i < selectedRows.length; i++) {
> /* 858 */       this.indexesToReset1.add(Integer.valueOf(selectedRows[i]));
> /* 859 */       modelTrack.setValueAt(Boolean.valueOf(false), selectedRows[i], tableTrack.convertColumnIndexToModel(0));
> /* 860 */       this.tracksID1.add(Integer.valueOf(Integer.parseInt((String)tableTrack.getValueAt(selectedRows[i], 2))));
> /*     */     } 
> /*     */     
> /* 863 */     for (int row = 0; row < this.tracksID1.size(); row++) {
> /*     */       
> /* 865 */       ProcessTrackMateXml.model.beginUpdate();
> /*     */       try {
> /* 867 */         ProcessTrackMateXml.model.setTrackVisibility(this.tracksID1.get(row), false);
> /*     */       } finally {
> /* 869 */         ProcessTrackMateXml.model.endUpdate();
> /*     */       } 
> /*     */ 
> /*     */       
> /* 873 */       ProcessTrackMateXml.displayer.refresh();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void createMovieTable() {
> /* 881 */     tableImages.setSelectionBackground(new Color(229, 255, 204));
> /* 882 */     tableImages.setSelectionForeground(new Color(0, 102, 0));
> /* 883 */     DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
> /* 884 */     centerRenderer.setHorizontalAlignment(0);
> /* 885 */     tableImages.setDefaultRenderer(String.class, centerRenderer);
> /* 886 */     tableImages.setAutoResizeMode(0);
> /* 887 */     tableImages.setRowHeight(95);
> /* 888 */     tableImages.setAutoCreateRowSorter(true);
> /* 889 */     tableImages.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
> /* 890 */     tableImages.setModel(FirstWizardPanel.modelImages);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void paintAndDisableAction() {
> /* 895 */     this.indexesToReset = new ArrayList<>();
> /* 896 */     this.tracksID = new ArrayList<>();
> /*     */     
> /* 898 */     for (int i = 0; i < modelTrack.getRowCount(); i++) {
> /* 899 */       if (((JLabel)modelTrack.getValueAt(i, tableTrack.convertColumnIndexToModel(1))).getBackground()
> /* 900 */         .equals(new Color(214, 217, 223)) == Boolean.TRUE.booleanValue()) {
> /* 901 */         this.indexesToReset.add(Integer.valueOf(i));
> /* 902 */         modelTrack.setValueAt(Boolean.valueOf(false), i, tableTrack.convertColumnIndexToModel(0));
> /* 903 */         this.tracksID.add(Integer.valueOf(Integer.parseInt((String)tableTrack.getValueAt(i, 2))));
> /*     */       } 
> /* 905 */     }  for (int row = 0; row < this.tracksID.size(); row++) {
> /*     */       
> /* 907 */       ProcessTrackMateXml.model.beginUpdate();
> /*     */       try {
> /* 909 */         ProcessTrackMateXml.model.setTrackVisibility(this.tracksID.get(row), false);
> /*     */       } finally {
> /* 911 */         ProcessTrackMateXml.model.endUpdate();
> /*     */       } 
> /*     */ 
> /*     */       
> /* 915 */       ProcessTrackMateXml.displayer.refresh();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void resetAndEnableAction() {
> /* 921 */     for (int i = 0; i < this.indexesToReset.size(); i++)
> /* 922 */       modelTrack.setValueAt(Boolean.valueOf(true), tableTrack.convertRowIndexToModel(((Integer)this.indexesToReset.get(i)).intValue()), 
> /* 923 */           tableTrack.convertColumnIndexToModel(0)); 
> /* 924 */     for (int row = 0; row < this.tracksID.size(); row++) {
> /* 925 */       ProcessTrackMateXml.model.beginUpdate();
> /*     */       try {
> /* 927 */         ProcessTrackMateXml.model.setTrackVisibility(this.tracksID.get(row), true);
> /*     */       } finally {
> /* 929 */         ProcessTrackMateXml.model.endUpdate();
> /*     */       } 
> /*     */     } 
> /* 932 */     ProcessTrackMateXml.displayer.refresh();
> /*     */   }
> /*     */   
> /*     */   public void update() {
> /* 936 */     setNextButtonEnabled(true);
> /* 937 */     setFinishButtonEnabled(true);
> /* 938 */     setBackButtonEnabled(true);
> /*     */   }
> /*     */   
> /*     */   public void next() {
> /* 942 */     switchPanel(2);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void back() {
> /* 948 */     switchPanel(0);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   private static final void transferCalibration(ImagePlus from, ImagePlus to) {
> /* 953 */     Calibration fc = from.getCalibration();
> /* 954 */     Calibration tc = to.getCalibration();
> /*     */     
> /* 956 */     tc.setUnit(fc.getUnit());
> /* 957 */     tc.setTimeUnit(fc.getTimeUnit());
> /* 958 */     tc.frameInterval = fc.frameInterval;
> /*     */     
> /* 960 */     double mag = from.getCanvas().getMagnification();
> /* 961 */     fc.pixelWidth /= mag;
> /* 962 */     fc.pixelHeight /= mag;
> /* 963 */     tc.pixelDepth = fc.pixelDepth;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/ChooserWizardPanel.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/ClusterSizeAnalysis.java jd-gui/ClusterSizeAnalysis.java
1,9c1,66
< import edu.mines.jtk.dsp.Histogram;
< import java.util.ArrayList;
< import java.util.List;
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.plot.XYPlot;
< import org.jfree.chart.renderer.xy.XYBarRenderer;
< import org.jfree.data.statistics.HistogramDataset;
< import smileModified.GaussianMixtureModified;
< import smileModified.MixtureModified;
---
> /*    */ import edu.mines.jtk.dsp.Histogram;
> /*    */ import java.util.ArrayList;
> /*    */ import java.util.List;
> /*    */ import org.jfree.chart.ChartPanel;
> /*    */ import org.jfree.chart.plot.XYPlot;
> /*    */ import org.jfree.chart.renderer.xy.XYBarRenderer;
> /*    */ import org.jfree.data.statistics.HistogramDataset;
> /*    */ import smileModified.GaussianMixtureModified;
> /*    */ import smileModified.MixtureModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class ClusterSizeAnalysis
> /*    */ {
> /* 34 */   List<Double> pdf = new ArrayList<>();
> /*    */   
> /*    */   double[] values;
> /*    */   
> /*    */   int BINS;
> /*    */   
> /*    */   HistogramDataset dataset;
> /*    */   
> /*    */   XYPlot plot;
> /*    */   ChartPanel panel;
> /*    */   XYBarRenderer renderer;
> /*    */   Integer nOfTrack;
> /*    */   
> /*    */   public void Compute(List<Double> xData, Integer nOfTrack) {
> /* 48 */     double[] xDataArray = new double[xData.size()];
> /* 49 */     float[] xDataArrayFloat = new float[xData.size()];
> /* 50 */     for (int i = 0; i < xData.size(); i++) {
> /* 51 */       xDataArray[i] = ((Double)xData.get(i)).doubleValue();
> /* 52 */       xDataArrayFloat[i] = ((Double)xData.get(i)).floatValue();
> /*    */     } 
> /* 54 */     double meanValue = Double.valueOf(xData.stream().mapToDouble(a -> a.doubleValue()).average().getAsDouble()).doubleValue();
> /* 55 */     Histogram histogram = new Histogram(xDataArrayFloat);
> /* 56 */     int BINS = histogram.getBinCount();
> /* 57 */     long[] counts = histogram.getCounts();
> /* 58 */     float[] densities = histogram.getDensities();
> /*    */     
> /* 60 */     GaussianMixtureModified gm2 = GaussianMixtureModified.fit(xDataArray);
> /* 61 */     int k = gm2.size();
> /* 62 */     MixtureModified.Component[] components = gm2.components;
> /* 63 */     NormalDistributionMine nd = new NormalDistributionMine(nOfTrack, components, xDataArray.length, meanValue);
> /* 64 */     nd.runNormalDistribution();
> /*    */   }
> /*    */ }
11,19d67
< public class ClusterSizeAnalysis {
<    List<Double> pdf = new ArrayList();
<    double[] values;
<    int BINS;
<    HistogramDataset dataset;
<    XYPlot plot;
<    ChartPanel panel;
<    XYBarRenderer renderer;
<    Integer nOfTrack;
21,43c69,72
<    public void Compute(List<Double> xData, Integer nOfTrack) {
<       double[] xDataArray = new double[xData.size()];
<       float[] xDataArrayFloat = new float[xData.size()];
< 
<       for(int i = 0; i < xData.size(); ++i) {
<          xDataArray[i] = (Double)xData.get(i);
<          xDataArrayFloat[i] = ((Double)xData.get(i)).floatValue();
<       }
< 
<       double meanValue = Double.valueOf(xData.stream().mapToDouble((a) -> {
<          return a;
<       }).average().getAsDouble());
<       Histogram histogram = new Histogram(xDataArrayFloat);
<       int BINS = histogram.getBinCount();
<       long[] counts = histogram.getCounts();
<       float[] densities = histogram.getDensities();
<       GaussianMixtureModified gm2 = GaussianMixtureModified.fit(xDataArray);
<       int k = gm2.size();
<       MixtureModified.Component[] components = gm2.components;
<       NormalDistributionMine nd = new NormalDistributionMine(nOfTrack, components, xDataArray.length, meanValue);
<       nd.runNormalDistribution();
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/ClusterSizeAnalysis.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: ColorEditorSpot$10.java
Only in jd-gui: ColorEditorSpot$11.java
Only in jd-gui: ColorEditorSpot$12.java
Only in jd-gui: ColorEditorSpot$1.java
Only in jd-gui: ColorEditorSpot$2.java
Only in jd-gui: ColorEditorSpot$3.java
Only in jd-gui: ColorEditorSpot$4.java
Only in jd-gui: ColorEditorSpot$5.java
Only in jd-gui: ColorEditorSpot$6.java
Only in jd-gui: ColorEditorSpot$7.java
Only in jd-gui: ColorEditorSpot$8.java
Only in jd-gui: ColorEditorSpot$9.java
diff -r TrackAnalyzer_/ColorEditorSpot.java jd-gui/ColorEditorSpot.java
1,585c1,651
< import java.awt.Color;
< import java.awt.Component;
< import java.awt.Dimension;
< import java.awt.FlowLayout;
< import java.awt.Point;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.WindowEvent;
< import java.util.ArrayList;
< import java.util.List;
< import java.util.Locale;
< import javax.swing.AbstractCellEditor;
< import javax.swing.Box;
< import javax.swing.BoxLayout;
< import javax.swing.DefaultListModel;
< import javax.swing.Icon;
< import javax.swing.ImageIcon;
< import javax.swing.JButton;
< import javax.swing.JColorChooser;
< import javax.swing.JFrame;
< import javax.swing.JLabel;
< import javax.swing.JList;
< import javax.swing.JOptionPane;
< import javax.swing.JPanel;
< import javax.swing.JScrollPane;
< import javax.swing.JTable;
< import javax.swing.JTextField;
< import javax.swing.table.DefaultTableCellRenderer;
< import javax.swing.table.DefaultTableModel;
< import javax.swing.table.TableCellEditor;
< import javax.swing.table.TableColumn;
< import javax.swing.table.TableModel;
< import javax.swing.table.TableRowSorter;
< 
< public class ColorEditorSpot extends AbstractCellEditor implements TableCellEditor {
<    private JPanel myPanel;
<    private JPanel panelAdd;
<    private JPanel panelEdit;
<    private JLabel labelInitt;
<    private int result;
<    private int input;
<    static DefaultTableModel modelC;
<    static JTable tableC;
<    private JButton addButton;
<    private JButton editButton;
<    private JButton deleteButton;
<    private JButton colorButtonAdd;
<    private JButton colorButtonEdit;
<    private JButton okButton;
<    private JButton okButtonEdit;
<    private JButton cancelButton;
<    private JButton cancelButtonEdit;
<    private JButton okButtonAdd;
<    private JButton cancelButtonAdd;
<    static JList<String> featureList;
<    static JList<String> classList;
<    static DefaultListModel<String> modelListFeature;
<    static DefaultListModel<String> modelListClass;
<    private JLabel addTextAdd;
<    private JLabel addTextEdit;
<    private JTextField addTextFAdd;
<    private JTextField addTextFEdit;
<    private Color currentColorAdd;
<    private Color currentColorEdit;
<    private Color colorCInitial;
<    private Color colorCFinal;
<    private Object labelC;
<    private Object colorC;
<    private Object featureC;
<    private String addTextInitial;
<    private String addTextFinal;
<    private String featureInitial;
<    private String featureFinal;
<    static JFrame myFrame;
<    static JFrame myFrameAdd;
<    static JFrame myFrameEdit;
<    private Icon iconOKCell;
<    private Icon iconCancelCell;
<    private int indexRowC;
< 
<    public ColorEditorSpot(final JList<String> featureList) {
<       ColorEditorSpot.featureList = featureList;
<       this.addButton = new JButton("");
<       this.addButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
<       Icon iconAddCell = new ImageIcon(iconAdd.getImage().getScaledInstance(17, 15, 4));
<       this.addButton.setIcon(iconAddCell);
<       this.addButton.setToolTipText("Click this button to add your class-label.");
<       this.editButton = new JButton("");
<       this.editButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconEdit = FirstWizardPanel.createImageIcon("images/edit.png");
<       Icon iconEditCell = new ImageIcon(iconEdit.getImage().getScaledInstance(17, 15, 4));
<       this.editButton.setIcon(iconEditCell);
<       this.editButton.setToolTipText("Click this button to edit your class-label.");
<       this.deleteButton = new JButton("");
<       this.deleteButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconDelete = FirstWizardPanel.createImageIcon("images/bin.png");
<       Icon iconDeleteCell = new ImageIcon(iconDelete.getImage().getScaledInstance(22, 20, 4));
<       this.deleteButton.setIcon(iconDeleteCell);
<       this.deleteButton.setToolTipText("Click this button to delete your class-label.");
<       myFrame = new JFrame("Manage Labels");
<       myFrame.setLocation(new Point(100, 100));
<       myFrame.setDefaultCloseOperation(2);
<       this.myPanel = new JPanel();
<       this.myPanel.setLayout(new BoxLayout(this.myPanel, 1));
<       Object[][] rowData2 = new Object[0][];
<       Object[] columnNames = new Object[]{"Name", "Color", "Feature"};
<       modelC = new DefaultTableModel(rowData2, columnNames) {
<          private static final long serialVersionUID = 1L;
< 
<          public boolean isCellEditable(int row, int col) {
<             return false;
<          }
< 
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
<             }
< 
<             return super.getColumnClass(column);
<          }
<       };
<       tableC = new JTable();
<       tableC.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
<       tableC.setSelectionBackground(new Color(229, 255, 204));
<       tableC.setSelectionForeground(new Color(0, 102, 0));
<       TableRowSorter<TableModel> rowSorter = new TableRowSorter(modelC);
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableC.setDefaultRenderer(JLabel.class, centerRenderer);
<       tableC.setRowSorter(rowSorter);
<       JPanel panelButtons = new JPanel();
<       panelButtons.setLayout(new FlowLayout());
<       panelButtons.add(this.addButton);
<       panelButtons.add(this.editButton);
<       panelButtons.add(this.deleteButton);
<       tableC.setAutoCreateRowSorter(true);
<       tableC.setEnabled(true);
<       tableC.setCellSelectionEnabled(true);
<       tableC.setRowSelectionAllowed(true);
<       tableC.setColumnSelectionAllowed(false);
<       tableC.setSelectionMode(2);
<       tableC.setDefaultRenderer(JLabel.class, new Renderer());
<       tableC.setDefaultRenderer(Color.class, new ColorRenderer(true));
<       tableC.setModel(modelC);
<       TableColumn column1 = null;
<       column1 = tableC.getColumnModel().getColumn(0);
<       column1.setPreferredWidth(7);
<       column1.setCellRenderer(new ResultRendererC());
<       TableColumn column2 = null;
<       column2 = tableC.getColumnModel().getColumn(1);
<       column2.setPreferredWidth(5);
<       column2.setCellRenderer(new ResultRendererC());
<       TableColumn column3 = null;
<       column3 = tableC.getColumnModel().getColumn(2);
<       column3.setPreferredWidth(15);
<       column3.setCellRenderer(new ResultRendererC());
<       JScrollPane scrollPane = new JScrollPane(tableC);
< 
<       for(int u = 0; u < tableC.getColumnCount(); ++u) {
<          tableC.getColumnModel().getColumn(u).setPreferredWidth(90);
<       }
< 
<       tableC.setRowHeight(25);
<       this.myPanel.add(Box.createHorizontalStrut(15));
<       this.myPanel.add(panelButtons);
<       this.myPanel.add(scrollPane, "Center");
<       this.myPanel.setSize(300, 150);
<       this.myPanel.add(Box.createHorizontalStrut(15));
<       this.okButton = new JButton("");
<       this.okButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconOk = FirstWizardPanel.createImageIcon("images/add.png");
<       this.iconOKCell = new ImageIcon(iconOk.getImage().getScaledInstance(17, 15, 4));
<       this.okButton.setIcon(this.iconOKCell);
<       this.okButton.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButton = new JButton("");
<       this.cancelButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconCancel = FirstWizardPanel.createImageIcon("images/cancel.png");
<       this.iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(17, 15, 4));
<       this.cancelButton.setIcon(this.iconCancelCell);
<       this.cancelButton.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancel = new JPanel();
<       panelOkCancel.setLayout(new FlowLayout());
<       panelOkCancel.add(this.okButton);
<       panelOkCancel.add(this.cancelButton);
<       this.myPanel.add(panelOkCancel);
<       myFrame.getContentPane().add(this.myPanel);
<       myFrame.pack();
<       myFrame.setLocationByPlatform(true);
<       this.panelAdd = new JPanel();
<       this.panelAdd.setPreferredSize(new Dimension(200, 100));
<       JPanel panel1 = new JPanel();
<       panel1.setLayout(new FlowLayout());
<       this.panelAdd.setLayout(new FlowLayout());
<       this.addTextAdd = new JLabel("Label Name: ");
<       this.addTextFAdd = new JTextField(8);
<       panel1.add(this.addTextAdd);
<       panel1.add(this.addTextFAdd);
<       JLabel pickC = new JLabel("Pick a color: ");
<       this.panelAdd.add(pickC);
<       this.colorButtonAdd = new JButton();
<       this.colorButtonAdd.setPreferredSize(new Dimension(200, 75));
<       this.panelAdd.add(this.colorButtonAdd);
<       this.okButtonAdd = new JButton("");
<       this.okButtonAdd.setBounds(50, 100, 95, 30);
<       this.okButtonAdd.setIcon(this.iconOKCell);
<       this.okButtonAdd.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButtonAdd = new JButton("");
<       this.cancelButtonAdd.setBounds(50, 100, 95, 30);
<       this.cancelButtonAdd.setIcon(this.iconCancelCell);
<       this.cancelButtonAdd.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancelAdd = new JPanel();
<       panelOkCancelAdd.setLayout(new FlowLayout());
<       panelOkCancelAdd.add(this.okButtonAdd);
<       panelOkCancelAdd.add(this.cancelButtonAdd);
<       myFrameAdd = new JFrame("Add Label");
<       JPanel mainPanel = new JPanel();
<       mainPanel.add(panel1);
<       mainPanel.add(this.panelAdd);
<       mainPanel.add(panelOkCancelAdd);
<       myFrameAdd.setPreferredSize(new Dimension(250, 250));
<       myFrameAdd.getContentPane().add(mainPanel);
<       myFrameAdd.pack();
<       myFrameAdd.setLocationByPlatform(true);
<       JPanel panel = new JPanel();
<       panel.setPreferredSize(new Dimension(200, 100));
<       JPanel panel2 = new JPanel();
<       panel2.setLayout(new FlowLayout());
<       panel.setLayout(new FlowLayout());
<       this.addTextEdit = new JLabel("Label Name: ");
<       this.addTextFEdit = new JTextField(8);
<       panel2.add(this.addTextEdit);
<       panel2.add(this.addTextFEdit);
<       JLabel pickEdit = new JLabel("Pick a Color: ");
<       panel.add(pickEdit);
<       this.colorButtonEdit = new JButton();
<       this.colorButtonEdit.setPreferredSize(new Dimension(200, 75));
<       panel.add(this.colorButtonEdit);
<       this.okButtonEdit = new JButton("");
<       this.okButtonEdit.setBounds(50, 100, 95, 30);
<       this.okButtonEdit.setIcon(this.iconOKCell);
<       this.okButtonEdit.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButtonEdit = new JButton("");
<       this.cancelButtonEdit.setBounds(50, 100, 95, 30);
<       this.cancelButtonEdit.setIcon(this.iconCancelCell);
<       this.cancelButtonEdit.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancelEdit = new JPanel();
<       panelOkCancelEdit.setLayout(new FlowLayout());
<       panelOkCancelEdit.add(this.okButtonEdit);
<       panelOkCancelEdit.add(this.cancelButtonEdit);
<       myFrameEdit = new JFrame("Edit Label");
<       JPanel mainPanelEdit = new JPanel();
<       mainPanelEdit.add(panel2);
<       mainPanelEdit.add(panel);
<       mainPanelEdit.add(panelOkCancelEdit);
<       myFrameEdit.setPreferredSize(new Dimension(250, 250));
<       myFrameEdit.getContentPane().add(mainPanelEdit);
<       myFrameEdit.pack();
<       myFrameEdit.setLocationByPlatform(true);
<       this.addButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorSpot.tableC.setRowHeight(featureList.getHeight());
<             ColorEditorSpot.myFrameAdd.setVisible(true);
<          }
<       });
<       this.okButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             JLabel labelString = new JLabel();
<             JLabel labelColor = new JLabel();
<             JLabel labelFeature = new JLabel();
<             labelColor.setText("");
<             labelColor.setBackground(ColorEditorSpot.this.currentColorAdd);
<             labelString.setText(ColorEditorSpot.this.addTextFAdd.getText());
<             labelString.setHorizontalAlignment(0);
<             labelString.setBackground(ColorEditorSpot.this.currentColorAdd);
<             labelColor.setOpaque(true);
<             StringBuilder filterItems = new StringBuilder();
< 
<             for(int x = 0; x < featureList.getModel().getSize(); ++x) {
<                filterItems.append((String)featureList.getModel().getElementAt(x)).append("<br>");
<             }
< 
<             labelFeature.setText("<html>" + filterItems.toString() + "</html>");
<             ColorEditorSpot.modelC.addRow(new Object[]{labelString, labelColor, labelFeature});
<             ColorEditorSpot.modelC.fireTableDataChanged();
<             ColorEditorSpot.tableC.repaint();
<             ColorEditorSpot.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameAdd, 201));
<          }
<       });
<       this.cancelButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorSpot.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameAdd, 201));
<          }
<       });
<       this.editButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorSpot.myFrameEdit.setVisible(true);
<             ColorEditorSpot.this.indexRowC = ColorEditorSpot.tableC.getSelectedRow();
<             if (ColorEditorSpot.tableC.getSelectedRowCount() != 0) {
<                if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
<                   ColorEditorSpot.this.labelC = new Object();
<                   ColorEditorSpot.this.colorC = new Object();
<                   ColorEditorSpot.this.labelC = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<                   ColorEditorSpot.this.colorC = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<                   ColorEditorSpot.this.addTextInitial = ((JLabel)ColorEditorSpot.this.labelC).getText();
<                   ColorEditorSpot.this.colorCInitial = ((JLabel)ColorEditorSpot.this.colorC).getBackground();
<                }
< 
<                ColorEditorSpot.this.colorButtonEdit.setBackground(((JLabel)ColorEditorSpot.this.colorC).getBackground());
<                ColorEditorSpot.this.currentColorEdit = ((JLabel)ColorEditorSpot.this.colorC).getBackground();
<                ColorEditorSpot.this.colorButtonEdit.setContentAreaFilled(false);
<                ColorEditorSpot.this.colorButtonEdit.setOpaque(true);
<                ColorEditorSpot.this.addTextFEdit.setText(((JLabel)ColorEditorSpot.this.labelC).getText());
<             }
<          }
<       });
<       this.colorButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Locale.setDefault(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.getDefault());
<             ColorEditorSpot.this.currentColorAdd = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorSpot.this.colorButtonAdd.getBackground());
<             if (ColorEditorSpot.this.currentColorAdd != null) {
<                ColorEditorSpot.this.colorButtonAdd.setBackground(ColorEditorSpot.this.currentColorAdd);
<             }
< 
<          }
<       });
<       this.okButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             JLabel labelString = new JLabel();
<             JLabel labelColor = new JLabel();
<             labelColor.setText("");
<             labelColor.setBackground(ColorEditorSpot.this.currentColorEdit);
<             labelString.setText(ColorEditorSpot.this.addTextFEdit.getText());
<             labelString.setHorizontalAlignment(0);
<             labelString.setBackground(ColorEditorSpot.this.currentColorEdit);
<             labelColor.setOpaque(true);
<             ColorEditorSpot.this.addTextFinal = labelString.getText();
<             ColorEditorSpot.this.colorCFinal = labelColor.getBackground();
<             if (!ColorEditorSpot.this.addTextFinal.equals(ColorEditorSpot.this.addTextInitial)) {
<                ColorEditorSpot.modelC.setValueAt(labelString, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<             }
< 
<             if (ColorEditorSpot.this.addTextFinal.equals(ColorEditorSpot.this.addTextInitial)) {
<                ColorEditorSpot.modelC.setValueAt(ColorEditorSpot.this.labelC, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<             }
< 
<             if (ColorEditorSpot.this.currentColorEdit != ColorEditorSpot.this.colorCInitial) {
<                ColorEditorSpot.modelC.setValueAt(labelColor, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<             }
< 
<             if (ColorEditorSpot.this.currentColorEdit == ColorEditorSpot.this.colorCInitial) {
<                ColorEditorSpot.modelC.setValueAt(ColorEditorSpot.this.colorC, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<             }
< 
<             ColorEditorSpot.modelC.fireTableCellUpdated(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<             ColorEditorSpot.modelC.fireTableCellUpdated(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<             ColorEditorSpot.tableC.repaint();
<             ColorEditorSpot.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameEdit, 201));
<          }
<       });
<       this.cancelButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorSpot.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameEdit, 201));
<          }
<       });
<    }
< 
<    public void setClassAction() {
<       this.colorButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Locale.setDefault(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.getDefault());
<             ColorEditorSpot.this.currentColorEdit = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorSpot.this.colorButtonEdit.getBackground());
<             if (ColorEditorSpot.this.currentColorEdit != null) {
<                ColorEditorSpot.this.colorButtonEdit.setBackground(ColorEditorSpot.this.currentColorEdit);
<             }
< 
<          }
<       });
<       this.okButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             if (ColorEditorSpot.tableC.getSelectedRowCount() <= 0) {
<                ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
<             }
< 
<             if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
<                List<String> listClasses = new ArrayList();
<                ColorEditorSpot.classList = FirstWizardPanel.classList;
<                ColorEditorSpot.modelListClass = FirstWizardPanel.modelListClass;
<                int selectedRow = ColorEditorSpot.tableC.getSelectedRow();
<                JLabel labelsTableC;
<                int ix;
<                ArrayList features;
<                ArrayList featureMin;
<                ArrayList featureMax;
<                int x;
<                int u;
<                String[] filterFeature;
<                if (ColorEditorSpot.modelListClass.getSize() == 0) {
<                   ColorEditorSpot.modelListClass.addElement(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
<                   labelsTableC = new JLabel();
< 
<                   for(ix = 0; ix < ColorEditorSpot.tableC.getModel().getRowCount(); ++ix) {
<                      labelsTableC.setText(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
<                      labelsTableC.setHorizontalAlignment(0);
<                      labelsTableC.setBackground(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(1))).getBackground());
<                      labelsTableC.setOpaque(true);
<                   }
< 
<                   filterFeature = ((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
<                   features = new ArrayList();
<                   featureMin = new ArrayList();
<                   featureMax = new ArrayList();
< 
<                   for(x = 0; x < filterFeature.length; ++x) {
<                      features.add(filterFeature[x].substring(0, filterFeature[x].indexOf(":")));
<                      featureMin.add(filterFeature[x].substring(filterFeature[x].indexOf("[") + 1, filterFeature[x].indexOf(",")));
<                      featureMax.add(filterFeature[x].substring(filterFeature[x].indexOf(",") + 1, filterFeature[x].indexOf("]")));
<                   }
< 
<                   for(x = 0; x < FirstWizardPanel.modelSpot.getRowCount(); ++x) {
<                      for(u = 0; u < features.size(); ++u) {
<                         if (Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble((String)featureMin.get(u)) && Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble((String)featureMax.get(u))) {
<                            FirstWizardPanel.tableSpot.getModel().setValueAt(labelsTableC, FirstWizardPanel.tableSpot.convertRowIndexToModel(x), FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
<                         }
<                      }
<                   }
<                }
< 
<                if (ColorEditorSpot.modelListClass.getSize() >= 1) {
<                   for(int i = 0; i < ColorEditorSpot.modelListClass.getSize(); ++i) {
<                      listClasses.add((String)ColorEditorSpot.modelListClass.getElementAt(i));
<                   }
< 
<                   if (!listClasses.contains(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText())) {
<                      ColorEditorSpot.modelListClass.addElement(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
<                      labelsTableC = new JLabel();
< 
<                      for(ix = 0; ix < ColorEditorSpot.tableC.getModel().getRowCount(); ++ix) {
<                         labelsTableC.setText(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
<                         labelsTableC.setHorizontalAlignment(0);
<                         labelsTableC.setBackground(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(1))).getBackground());
<                         labelsTableC.setOpaque(true);
<                      }
< 
<                      filterFeature = ((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
<                      features = new ArrayList();
<                      featureMin = new ArrayList();
<                      featureMax = new ArrayList();
< 
<                      for(x = 0; x < filterFeature.length; ++x) {
<                         features.add(filterFeature[x].substring(0, filterFeature[x].indexOf(":")));
<                         featureMin.add(filterFeature[x].substring(filterFeature[x].indexOf("[") + 1, filterFeature[x].indexOf(",")));
<                         featureMax.add(filterFeature[x].substring(filterFeature[x].indexOf(",") + 1, filterFeature[x].indexOf("]")));
<                      }
< 
<                      for(x = 0; x < FirstWizardPanel.modelSpot.getRowCount(); ++x) {
<                         for(u = 0; u < features.size(); ++u) {
<                            if (Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble((String)featureMin.get(u)) && Double.parseDouble(FirstWizardPanel.tableSpot.getModel().getValueAt(x, FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble((String)featureMax.get(u))) {
<                               FirstWizardPanel.tableSpot.getModel().setValueAt(labelsTableC, FirstWizardPanel.tableSpot.convertRowIndexToModel(x), FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
<                            }
<                         }
<                      }
<                   }
< 
<                   if (listClasses.contains(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText())) {
<                      ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
<                   }
<                }
<             }
< 
<          }
<       });
<       this.cancelButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
<          }
<       });
<       this.deleteButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Object labelC = null;
<             Object colorC = null;
<             Object[] labelsC = null;
<             Object[] colorsC = null;
<             int[] indexesRowC = ColorEditorSpot.tableC.getSelectedRows();
<             int indexRowC = ColorEditorSpot.tableC.getSelectedRow();
<             if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
<                new Object();
<                new Object();
<                labelC = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<                colorC = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexRowC), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<             }
< 
<             labelsC = new Object[indexesRowC.length];
<             colorsC = new Object[indexesRowC.length];
<             if (ColorEditorSpot.tableC.getSelectedRowCount() > 1) {
<                for(int k = 0; k < indexesRowC.length; ++k) {
<                   labelsC[k] = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorSpot.tableC.convertColumnIndexToModel(0));
<                   colorsC[k] = (JLabel)ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorSpot.tableC.convertColumnIndexToModel(1));
<                }
<             }
< 
<             Locale.setDefault(Locale.ENGLISH);
<             Locale var10000 = Locale.ENGLISH;
<             JOptionPane.setDefaultLocale(Locale.getDefault());
<             if (ColorEditorSpot.tableC.getSelectedRowCount() > 1) {
<                String[] labelsCtoString = new String[indexesRowC.length];
< 
<                int f;
<                for(f = 0; f < indexesRowC.length; ++f) {
<                   labelsCtoString[f] = ((JLabel)labelsC[f]).getText();
<                }
< 
<                ColorEditorSpot.this.input = JOptionPane.showConfirmDialog((Component)null, "Are you sure to delete the selected labels?", "Delete a label", 1, 0);
<                if (ColorEditorSpot.this.input == 0) {
<                   for(f = 0; f < indexesRowC.length; ++f) {
<                      ColorEditorSpot.modelC.removeRow(indexesRowC[f] - f);
<                   }
< 
<                   ColorEditorSpot.modelC.fireTableDataChanged();
<                   ColorEditorSpot.tableC.repaint();
<                }
< 
<                if (ColorEditorSpot.this.input == 1) {
<                   return;
<                }
< 
<                if (ColorEditorSpot.this.input == 2) {
<                   return;
<                }
<             }
< 
<             if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
<                String labelCtoString = ((JLabel)labelC).getText();
<                ColorEditorSpot.this.input = JOptionPane.showConfirmDialog((Component)null, "Are you sure to delete the following label?----- " + labelCtoString, "Delete a label", 1, 0);
<                if (ColorEditorSpot.this.input == 0) {
<                   ColorEditorSpot.modelC.removeRow(indexRowC);
<                   ColorEditorSpot.modelC.fireTableDataChanged();
<                }
< 
<                if (ColorEditorSpot.this.input == 1) {
<                   return;
<                }
< 
<                if (ColorEditorSpot.this.input == 2) {
<                   return;
<                }
<             }
< 
<          }
<       });
<    }
< 
<    public Object getCellEditorValueAdd() {
<       return this.currentColorAdd;
<    }
< 
<    public Object getCellEditorValueEdit() {
<       return this.currentColorEdit;
<    }
< 
<    public Component getTableCellEditorComponentAdd(JTable table, Object value, boolean isSelected, int row, int column) {
<       this.currentColorAdd = (Color)value;
<       return this.colorButtonAdd;
<    }
< 
<    public Component getTableCellEditorComponentEdit(JTable table, Object value, boolean isSelected, int row, int column) {
<       this.currentColorEdit = (Color)value;
<       return this.colorButtonEdit;
<    }
< 
<    public Component getTableCellEditorComponent(JTable arg0, Object arg1, boolean arg2, int arg3, int arg4) {
<       return null;
<    }
< 
<    public Object getCellEditorValue() {
<       return null;
<    }
< }
---
> /*     */ import java.awt.Color;
> /*     */ import java.awt.Component;
> /*     */ import java.awt.Dimension;
> /*     */ import java.awt.FlowLayout;
> /*     */ import java.awt.Point;
> /*     */ import java.awt.event.ActionEvent;
> /*     */ import java.awt.event.ActionListener;
> /*     */ import java.awt.event.WindowEvent;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.List;
> /*     */ import java.util.Locale;
> /*     */ import javax.swing.AbstractCellEditor;
> /*     */ import javax.swing.Box;
> /*     */ import javax.swing.BoxLayout;
> /*     */ import javax.swing.DefaultListModel;
> /*     */ import javax.swing.Icon;
> /*     */ import javax.swing.ImageIcon;
> /*     */ import javax.swing.JButton;
> /*     */ import javax.swing.JColorChooser;
> /*     */ import javax.swing.JFrame;
> /*     */ import javax.swing.JLabel;
> /*     */ import javax.swing.JList;
> /*     */ import javax.swing.JOptionPane;
> /*     */ import javax.swing.JPanel;
> /*     */ import javax.swing.JScrollPane;
> /*     */ import javax.swing.JTable;
> /*     */ import javax.swing.JTextField;
> /*     */ import javax.swing.table.DefaultTableCellRenderer;
> /*     */ import javax.swing.table.DefaultTableModel;
> /*     */ import javax.swing.table.TableCellEditor;
> /*     */ import javax.swing.table.TableCellRenderer;
> /*     */ import javax.swing.table.TableColumn;
> /*     */ import javax.swing.table.TableModel;
> /*     */ import javax.swing.table.TableRowSorter;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class ColorEditorSpot
> /*     */   extends AbstractCellEditor
> /*     */   implements TableCellEditor
> /*     */ {
> /*     */   private JPanel myPanel;
> /*     */   private JPanel panelAdd;
> /*     */   private JPanel panelEdit;
> /*     */   private JLabel labelInitt;
> /*     */   private int result;
> /*     */   private int input;
> /*     */   static DefaultTableModel modelC;
> /*     */   static JTable tableC;
> /*     */   private JButton addButton;
> /*     */   private JButton editButton;
> /*     */   private JButton deleteButton;
> /*     */   private JButton colorButtonAdd;
> /*     */   private JButton colorButtonEdit;
> /*     */   private JButton okButton;
> /*     */   private JButton okButtonEdit;
> /*     */   private JButton cancelButton;
> /*     */   private JButton cancelButtonEdit;
> /*     */   private JButton okButtonAdd;
> /*     */   private JButton cancelButtonAdd;
> /*     */   static JList<String> featureList;
> /*     */   static JList<String> classList;
> /*     */   static DefaultListModel<String> modelListFeature;
> /*     */   
> /*     */   public ColorEditorSpot(final JList<String> featureList) {
> /*  67 */     ColorEditorSpot.featureList = featureList;
> /*     */     
> /*  69 */     this.addButton = new JButton("");
> /*  70 */     this.addButton.setBounds(50, 100, 95, 30);
> /*  71 */     ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
> /*  72 */     Icon iconAddCell = new ImageIcon(iconAdd.getImage().getScaledInstance(17, 15, 4));
> /*  73 */     this.addButton.setIcon(iconAddCell);
> /*  74 */     this.addButton.setToolTipText("Click this button to add your class-label.");
> /*  75 */     this.editButton = new JButton("");
> /*  76 */     this.editButton.setBounds(50, 100, 95, 30);
> /*  77 */     ImageIcon iconEdit = FirstWizardPanel.createImageIcon("images/edit.png");
> /*  78 */     Icon iconEditCell = new ImageIcon(iconEdit.getImage().getScaledInstance(17, 15, 4));
> /*  79 */     this.editButton.setIcon(iconEditCell);
> /*  80 */     this.editButton.setToolTipText("Click this button to edit your class-label.");
> /*  81 */     this.deleteButton = new JButton("");
> /*  82 */     this.deleteButton.setBounds(50, 100, 95, 30);
> /*  83 */     ImageIcon iconDelete = FirstWizardPanel.createImageIcon("images/bin.png");
> /*  84 */     Icon iconDeleteCell = new ImageIcon(iconDelete.getImage().getScaledInstance(22, 20, 4));
> /*  85 */     this.deleteButton.setIcon(iconDeleteCell);
> /*  86 */     this.deleteButton.setToolTipText("Click this button to delete your class-label.");
> /*  87 */     myFrame = new JFrame("Manage Labels");
> /*  88 */     myFrame.setLocation(new Point(100, 100));
> /*  89 */     myFrame.setDefaultCloseOperation(2);
> /*  90 */     this.myPanel = new JPanel();
> /*  91 */     this.myPanel.setLayout(new BoxLayout(this.myPanel, 1));
> /*  92 */     Object[][] rowData2 = new Object[0][];
> /*  93 */     Object[] columnNames = { "Name", "Color", "Feature" };
> /*     */     
> /*  95 */     modelC = new DefaultTableModel(rowData2, columnNames)
> /*     */       {
> /*     */         private static final long serialVersionUID = 1L;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */         
> /*     */         public boolean isCellEditable(int row, int col) {
> /* 106 */           return false;
> /*     */         }
> /*     */ 
> /*     */ 
> /*     */         
> /*     */         public Class<?> getColumnClass(int column) {
> /* 112 */           if (getRowCount() > 0) {
> /* 113 */             Object value = getValueAt(0, column);
> /* 114 */             if (value != null) {
> /* 115 */               return getValueAt(0, column).getClass();
> /*     */             }
> /*     */           } 
> /*     */           
> /* 119 */           return super.getColumnClass(column);
> /*     */         }
> /*     */       };
> /*     */     
> /* 123 */     tableC = new JTable();
> /* 124 */     tableC.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
> /* 125 */     tableC.setSelectionBackground(new Color(229, 255, 204));
> /* 126 */     tableC.setSelectionForeground(new Color(0, 102, 0));
> /* 127 */     TableRowSorter<TableModel> rowSorter = new TableRowSorter<>(modelC);
> /* 128 */     DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
> /* 129 */     centerRenderer.setHorizontalAlignment(0);
> /* 130 */     tableC.setDefaultRenderer(JLabel.class, centerRenderer);
> /* 131 */     tableC.setRowSorter(rowSorter);
> /* 132 */     JPanel panelButtons = new JPanel();
> /* 133 */     panelButtons.setLayout(new FlowLayout());
> /* 134 */     panelButtons.add(this.addButton);
> /* 135 */     panelButtons.add(this.editButton);
> /* 136 */     panelButtons.add(this.deleteButton);
> /* 137 */     tableC.setAutoCreateRowSorter(true);
> /* 138 */     tableC.setEnabled(true);
> /* 139 */     tableC.setCellSelectionEnabled(true);
> /*     */     
> /* 141 */     tableC.setRowSelectionAllowed(true);
> /* 142 */     tableC.setColumnSelectionAllowed(false);
> /* 143 */     tableC.setSelectionMode(2);
> /* 144 */     tableC.setDefaultRenderer(JLabel.class, new Renderer());
> /* 145 */     tableC.setDefaultRenderer(Color.class, new ColorRenderer(true));
> /* 146 */     tableC.setModel(modelC);
> /* 147 */     TableColumn column1 = null;
> /* 148 */     column1 = tableC.getColumnModel().getColumn(0);
> /* 149 */     column1.setPreferredWidth(7);
> /* 150 */     column1.setCellRenderer((TableCellRenderer)new ResultRendererC());
> /* 151 */     TableColumn column2 = null;
> /* 152 */     column2 = tableC.getColumnModel().getColumn(1);
> /* 153 */     column2.setPreferredWidth(5);
> /* 154 */     column2.setCellRenderer((TableCellRenderer)new ResultRendererC());
> /* 155 */     TableColumn column3 = null;
> /* 156 */     column3 = tableC.getColumnModel().getColumn(2);
> /* 157 */     column3.setPreferredWidth(15);
> /* 158 */     column3.setCellRenderer((TableCellRenderer)new ResultRendererC());
> /* 159 */     JScrollPane scrollPane = new JScrollPane(tableC);
> /* 160 */     for (int u = 0; u < tableC.getColumnCount(); u++)
> /* 161 */       tableC.getColumnModel().getColumn(u).setPreferredWidth(90); 
> /* 162 */     tableC.setRowHeight(25);
> /* 163 */     this.myPanel.add(Box.createHorizontalStrut(15));
> /* 164 */     this.myPanel.add(panelButtons);
> /* 165 */     this.myPanel.add(scrollPane, "Center");
> /* 166 */     this.myPanel.setSize(300, 150);
> /*     */     
> /* 168 */     this.myPanel.add(Box.createHorizontalStrut(15));
> /* 169 */     this.okButton = new JButton("");
> /* 170 */     this.okButton.setBounds(50, 100, 95, 30);
> /* 171 */     ImageIcon iconOk = FirstWizardPanel.createImageIcon("images/add.png");
> /* 172 */     this.iconOKCell = new ImageIcon(iconOk.getImage().getScaledInstance(17, 15, 4));
> /* 173 */     this.okButton.setIcon(this.iconOKCell);
> /* 174 */     this.okButton.setToolTipText("Click this button to edit your color selection.");
> /* 175 */     this.cancelButton = new JButton("");
> /* 176 */     this.cancelButton.setBounds(50, 100, 95, 30);
> /* 177 */     ImageIcon iconCancel = FirstWizardPanel.createImageIcon("images/cancel.png");
> /* 178 */     this.iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(17, 15, 4));
> /* 179 */     this.cancelButton.setIcon(this.iconCancelCell);
> /* 180 */     this.cancelButton.setToolTipText("Click this button to cancel your color selection.");
> /* 181 */     JPanel panelOkCancel = new JPanel();
> /* 182 */     panelOkCancel.setLayout(new FlowLayout());
> /* 183 */     panelOkCancel.add(this.okButton);
> /* 184 */     panelOkCancel.add(this.cancelButton);
> /* 185 */     this.myPanel.add(panelOkCancel);
> /* 186 */     myFrame.getContentPane().add(this.myPanel);
> /* 187 */     myFrame.pack();
> /* 188 */     myFrame.setLocationByPlatform(true);
> /*     */ 
> /*     */     
> /* 191 */     this.panelAdd = new JPanel();
> /* 192 */     this.panelAdd.setPreferredSize(new Dimension(200, 100));
> /* 193 */     JPanel panel1 = new JPanel();
> /* 194 */     panel1.setLayout(new FlowLayout());
> /* 195 */     this.panelAdd.setLayout(new FlowLayout());
> /* 196 */     this.addTextAdd = new JLabel("Label Name: ");
> /* 197 */     this.addTextFAdd = new JTextField(8);
> /* 198 */     panel1.add(this.addTextAdd);
> /* 199 */     panel1.add(this.addTextFAdd);
> /* 200 */     JLabel pickC = new JLabel("Pick a color: ");
> /* 201 */     this.panelAdd.add(pickC);
> /* 202 */     this.colorButtonAdd = new JButton();
> /* 203 */     this.colorButtonAdd.setPreferredSize(new Dimension(200, 75));
> /*     */     
> /* 205 */     this.panelAdd.add(this.colorButtonAdd);
> /* 206 */     this.okButtonAdd = new JButton("");
> /* 207 */     this.okButtonAdd.setBounds(50, 100, 95, 30);
> /* 208 */     this.okButtonAdd.setIcon(this.iconOKCell);
> /* 209 */     this.okButtonAdd.setToolTipText("Click this button to edit your color selection.");
> /* 210 */     this.cancelButtonAdd = new JButton("");
> /* 211 */     this.cancelButtonAdd.setBounds(50, 100, 95, 30);
> /* 212 */     this.cancelButtonAdd.setIcon(this.iconCancelCell);
> /* 213 */     this.cancelButtonAdd.setToolTipText("Click this button to cancel your color selection.");
> /* 214 */     JPanel panelOkCancelAdd = new JPanel();
> /* 215 */     panelOkCancelAdd.setLayout(new FlowLayout());
> /* 216 */     panelOkCancelAdd.add(this.okButtonAdd);
> /* 217 */     panelOkCancelAdd.add(this.cancelButtonAdd);
> /* 218 */     myFrameAdd = new JFrame("Add Label");
> /* 219 */     JPanel mainPanel = new JPanel();
> /* 220 */     mainPanel.add(panel1);
> /* 221 */     mainPanel.add(this.panelAdd);
> /* 222 */     mainPanel.add(panelOkCancelAdd);
> /* 223 */     myFrameAdd.setPreferredSize(new Dimension(250, 250));
> /* 224 */     myFrameAdd.getContentPane().add(mainPanel);
> /* 225 */     myFrameAdd.pack();
> /* 226 */     myFrameAdd.setLocationByPlatform(true);
> /*     */ 
> /*     */ 
> /*     */     
> /* 230 */     JPanel panel = new JPanel();
> /* 231 */     panel.setPreferredSize(new Dimension(200, 100));
> /* 232 */     JPanel panel2 = new JPanel();
> /* 233 */     panel2.setLayout(new FlowLayout());
> /* 234 */     panel.setLayout(new FlowLayout());
> /* 235 */     this.addTextEdit = new JLabel("Label Name: ");
> /* 236 */     this.addTextFEdit = new JTextField(8);
> /* 237 */     panel2.add(this.addTextEdit);
> /* 238 */     panel2.add(this.addTextFEdit);
> /* 239 */     JLabel pickEdit = new JLabel("Pick a Color: ");
> /* 240 */     panel.add(pickEdit);
> /* 241 */     this.colorButtonEdit = new JButton();
> /* 242 */     this.colorButtonEdit.setPreferredSize(new Dimension(200, 75));
> /* 243 */     panel.add(this.colorButtonEdit);
> /* 244 */     this.okButtonEdit = new JButton("");
> /* 245 */     this.okButtonEdit.setBounds(50, 100, 95, 30);
> /* 246 */     this.okButtonEdit.setIcon(this.iconOKCell);
> /* 247 */     this.okButtonEdit.setToolTipText("Click this button to edit your color selection.");
> /* 248 */     this.cancelButtonEdit = new JButton("");
> /* 249 */     this.cancelButtonEdit.setBounds(50, 100, 95, 30);
> /* 250 */     this.cancelButtonEdit.setIcon(this.iconCancelCell);
> /* 251 */     this.cancelButtonEdit.setToolTipText("Click this button to cancel your color selection.");
> /* 252 */     JPanel panelOkCancelEdit = new JPanel();
> /* 253 */     panelOkCancelEdit.setLayout(new FlowLayout());
> /* 254 */     panelOkCancelEdit.add(this.okButtonEdit);
> /* 255 */     panelOkCancelEdit.add(this.cancelButtonEdit);
> /* 256 */     myFrameEdit = new JFrame("Edit Label");
> /* 257 */     JPanel mainPanelEdit = new JPanel();
> /* 258 */     mainPanelEdit.add(panel2);
> /* 259 */     mainPanelEdit.add(panel);
> /* 260 */     mainPanelEdit.add(panelOkCancelEdit);
> /* 261 */     myFrameEdit.setPreferredSize(new Dimension(250, 250));
> /* 262 */     myFrameEdit.getContentPane().add(mainPanelEdit);
> /* 263 */     myFrameEdit.pack();
> /* 264 */     myFrameEdit.setLocationByPlatform(true);
> /*     */ 
> /*     */     
> /* 267 */     this.addButton.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 269 */             ColorEditorSpot.tableC.setRowHeight(featureList.getHeight());
> /* 270 */             ColorEditorSpot.myFrameAdd.setVisible(true);
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 275 */     this.okButtonAdd.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 277 */             JLabel labelString = new JLabel();
> /* 278 */             JLabel labelColor = new JLabel();
> /* 279 */             JLabel labelFeature = new JLabel();
> /* 280 */             labelColor.setText("");
> /* 281 */             labelColor.setBackground(ColorEditorSpot.this.currentColorAdd);
> /* 282 */             labelString.setText(ColorEditorSpot.this.addTextFAdd.getText());
> /* 283 */             labelString.setHorizontalAlignment(0);
> /* 284 */             labelString.setBackground(ColorEditorSpot.this.currentColorAdd);
> /* 285 */             labelColor.setOpaque(true);
> /* 286 */             StringBuilder filterItems = new StringBuilder();
> /* 287 */             for (int x = 0; x < featureList.getModel().getSize(); x++)
> /* 288 */               filterItems.append(featureList.getModel().getElementAt(x)).append("<br>"); 
> /* 289 */             labelFeature.setText("<html>" + filterItems.toString() + "</html>");
> /* 290 */             ColorEditorSpot.modelC.addRow(new Object[] { labelString, labelColor, labelFeature });
> /* 291 */             ColorEditorSpot.modelC.fireTableDataChanged();
> /* 292 */             ColorEditorSpot.tableC.repaint();
> /*     */             
> /* 294 */             ColorEditorSpot.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameAdd, 201));
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 299 */     this.cancelButtonAdd.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 301 */             ColorEditorSpot.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameAdd, 201));
> /*     */           }
> /*     */         });
> /*     */     
> /* 305 */     this.editButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           
> /*     */           public void actionPerformed(ActionEvent e)
> /*     */           {
> /* 310 */             ColorEditorSpot.myFrameEdit.setVisible(true);
> /*     */             
> /* 312 */             ColorEditorSpot.this.indexRowC = ColorEditorSpot.tableC.getSelectedRow();
> /* 313 */             if (ColorEditorSpot.tableC.getSelectedRowCount() == 0)
> /*     */               return; 
> /* 315 */             if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
> /* 316 */               ColorEditorSpot.this.labelC = new Object();
> /* 317 */               ColorEditorSpot.this.colorC = new Object();
> /* 318 */               ColorEditorSpot.this.labelC = ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), 
> /* 319 */                   ColorEditorSpot.tableC.convertColumnIndexToModel(0));
> /* 320 */               ColorEditorSpot.this.colorC = ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), 
> /* 321 */                   ColorEditorSpot.tableC.convertColumnIndexToModel(1));
> /* 322 */               ColorEditorSpot.this.addTextInitial = ((JLabel)ColorEditorSpot.this.labelC).getText();
> /* 323 */               ColorEditorSpot.this.colorCInitial = ((JLabel)ColorEditorSpot.this.colorC).getBackground();
> /*     */             } 
> /*     */             
> /* 326 */             ColorEditorSpot.this.colorButtonEdit.setBackground(((JLabel)ColorEditorSpot.this.colorC).getBackground());
> /* 327 */             ColorEditorSpot.this.currentColorEdit = ((JLabel)ColorEditorSpot.this.colorC).getBackground();
> /* 328 */             ColorEditorSpot.this.colorButtonEdit.setContentAreaFilled(false);
> /* 329 */             ColorEditorSpot.this.colorButtonEdit.setOpaque(true);
> /*     */             
> /* 331 */             ColorEditorSpot.this.addTextFEdit.setText(((JLabel)ColorEditorSpot.this.labelC).getText());
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 336 */     this.colorButtonAdd.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 339 */             Locale.setDefault(Locale.ENGLISH);
> /* 340 */             JColorChooser.setDefaultLocale(Locale.ENGLISH);
> /* 341 */             JColorChooser.setDefaultLocale(Locale.getDefault());
> /* 342 */             ColorEditorSpot.this.currentColorAdd = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorSpot.this.colorButtonAdd.getBackground());
> /* 343 */             if (ColorEditorSpot.this.currentColorAdd != null) {
> /* 344 */               ColorEditorSpot.this.colorButtonAdd.setBackground(ColorEditorSpot.this.currentColorAdd);
> /*     */             }
> /*     */           }
> /*     */         });
> /* 348 */     this.okButtonEdit.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 350 */             JLabel labelString = new JLabel();
> /* 351 */             JLabel labelColor = new JLabel();
> /* 352 */             labelColor.setText("");
> /* 353 */             labelColor.setBackground(ColorEditorSpot.this.currentColorEdit);
> /* 354 */             labelString.setText(ColorEditorSpot.this.addTextFEdit.getText());
> /* 355 */             labelString.setHorizontalAlignment(0);
> /* 356 */             labelString.setBackground(ColorEditorSpot.this.currentColorEdit);
> /* 357 */             labelColor.setOpaque(true);
> /* 358 */             ColorEditorSpot.this.addTextFinal = labelString.getText();
> /* 359 */             ColorEditorSpot.this.colorCFinal = labelColor.getBackground();
> /*     */             
> /* 361 */             if (!ColorEditorSpot.this.addTextFinal.equals(ColorEditorSpot.this.addTextInitial))
> /* 362 */               ColorEditorSpot.modelC.setValueAt(labelString, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), 
> /* 363 */                   ColorEditorSpot.tableC.convertColumnIndexToModel(0)); 
> /* 364 */             if (ColorEditorSpot.this.addTextFinal.equals(ColorEditorSpot.this.addTextInitial))
> /* 365 */               ColorEditorSpot.modelC.setValueAt(ColorEditorSpot.this.labelC, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), 
> /* 366 */                   ColorEditorSpot.tableC.convertColumnIndexToModel(0)); 
> /* 367 */             if (ColorEditorSpot.this.currentColorEdit != ColorEditorSpot.this.colorCInitial)
> /* 368 */               ColorEditorSpot.modelC.setValueAt(labelColor, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), 
> /* 369 */                   ColorEditorSpot.tableC.convertColumnIndexToModel(1)); 
> /* 370 */             if (ColorEditorSpot.this.currentColorEdit == ColorEditorSpot.this.colorCInitial) {
> /* 371 */               ColorEditorSpot.modelC.setValueAt(ColorEditorSpot.this.colorC, ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), 
> /* 372 */                   ColorEditorSpot.tableC.convertColumnIndexToModel(1));
> /*     */             }
> /* 374 */             ColorEditorSpot.modelC.fireTableCellUpdated(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), 
> /* 375 */                 ColorEditorSpot.tableC.convertColumnIndexToModel(0));
> /* 376 */             ColorEditorSpot.modelC.fireTableCellUpdated(ColorEditorSpot.tableC.convertRowIndexToModel(ColorEditorSpot.this.indexRowC), 
> /* 377 */                 ColorEditorSpot.tableC.convertColumnIndexToModel(1));
> /* 378 */             ColorEditorSpot.tableC.repaint();
> /*     */             
> /* 380 */             ColorEditorSpot.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameEdit, 201));
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */ 
> /*     */     
> /* 386 */     this.cancelButtonEdit.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 388 */             ColorEditorSpot.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrameEdit, 201));
> /*     */           }
> /*     */         });
> /*     */   } static DefaultListModel<String> modelListClass; private JLabel addTextAdd; private JLabel addTextEdit; private JTextField addTextFAdd; private JTextField addTextFEdit; private Color currentColorAdd; private Color currentColorEdit; private Color colorCInitial; private Color colorCFinal; private Object labelC; private Object colorC; private Object featureC; private String addTextInitial; private String addTextFinal; private String featureInitial; private String featureFinal; static JFrame myFrame; static JFrame myFrameAdd; static JFrame myFrameEdit; private Icon iconOKCell;
> /*     */   private Icon iconCancelCell;
> /*     */   private int indexRowC;
> /*     */   
> /*     */   public void setClassAction() {
> /* 396 */     this.colorButtonEdit.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 399 */             Locale.setDefault(Locale.ENGLISH);
> /* 400 */             JColorChooser.setDefaultLocale(Locale.ENGLISH);
> /* 401 */             JColorChooser.setDefaultLocale(Locale.getDefault());
> /* 402 */             ColorEditorSpot.this.currentColorEdit = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorSpot.this.colorButtonEdit.getBackground());
> /* 403 */             if (ColorEditorSpot.this.currentColorEdit != null)
> /* 404 */               ColorEditorSpot.this.colorButtonEdit.setBackground(ColorEditorSpot.this.currentColorEdit); 
> /*     */           }
> /*     */         });
> /* 407 */     this.okButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e)
> /*     */           {
> /* 411 */             if (ColorEditorSpot.tableC.getSelectedRowCount() <= 0) {
> /* 412 */               ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
> /*     */             }
> /* 414 */             if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
> /*     */               
> /* 416 */               List<String> listClasses = new ArrayList<>();
> /* 417 */               ColorEditorSpot.classList = FirstWizardPanel.classList;
> /* 418 */               ColorEditorSpot.modelListClass = FirstWizardPanel.modelListClass;
> /* 419 */               int selectedRow = ColorEditorSpot.tableC.getSelectedRow();
> /*     */               
> /* 421 */               if (ColorEditorSpot.modelListClass.getSize() == 0) {
> /* 422 */                 ColorEditorSpot.modelListClass.addElement((
> /* 423 */                     (JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), 
> /* 424 */                       ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
> /* 425 */                 JLabel labelsTableC = new JLabel();
> /* 426 */                 for (int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); i++) {
> /* 427 */                   labelsTableC.setText(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, 
> /* 428 */                         ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
> /* 429 */                   labelsTableC.setHorizontalAlignment(0);
> /* 430 */                   labelsTableC.setBackground(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, 
> /* 431 */                         ColorEditorSpot.tableC.convertColumnIndexToModel(1))).getBackground());
> /* 432 */                   labelsTableC.setOpaque(true);
> /*     */                 } 
> /*     */                 
> /* 435 */                 String[] filterFeature = ((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, 
> /* 436 */                     ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "")
> /* 437 */                   .replace("<html>", "").split("<br>");
> /* 438 */                 List<String> features = new ArrayList<>();
> /* 439 */                 List<String> featureMin = new ArrayList<>();
> /* 440 */                 List<String> featureMax = new ArrayList<>();
> /* 441 */                 for (int j = 0; j < filterFeature.length; j++) {
> /* 442 */                   features.add(filterFeature[j].substring(0, filterFeature[j].indexOf(":")));
> /* 443 */                   featureMin.add(filterFeature[j].substring(filterFeature[j].indexOf("[") + 1, 
> /* 444 */                         filterFeature[j].indexOf(",")));
> /* 445 */                   featureMax.add(filterFeature[j].substring(filterFeature[j].indexOf(",") + 1, 
> /* 446 */                         filterFeature[j].indexOf("]")));
> /*     */                 } 
> /*     */                 
> /* 449 */                 for (int x = 0; x < FirstWizardPanel.modelSpot.getRowCount(); x++) {
> /* 450 */                   for (int u = 0; u < features.size(); u++) {
> /* 451 */                     if (Double.parseDouble(FirstWizardPanel.tableSpot.getModel()
> /* 452 */                         .getValueAt(x, 
> /* 453 */                           FirstWizardPanel.tableSpot.getColumn(features.get(u)).getModelIndex())
> /* 454 */                         .toString()) >= Double.parseDouble(featureMin.get(u)))
> /* 455 */                       if (Double.parseDouble(FirstWizardPanel.tableSpot.getModel()
> /* 456 */                           .getValueAt(x, 
> /* 457 */                             FirstWizardPanel.tableSpot.getColumn(features.get(u))
> /* 458 */                             .getModelIndex())
> /* 459 */                           .toString()) <= Double.parseDouble(featureMax.get(u))) {
> /* 460 */                         FirstWizardPanel.tableSpot.getModel().setValueAt(labelsTableC, 
> /* 461 */                             FirstWizardPanel.tableSpot.convertRowIndexToModel(x), 
> /* 462 */                             FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
> /*     */                       } 
> /*     */                   } 
> /*     */                 } 
> /*     */               } 
> /* 467 */               if (ColorEditorSpot.modelListClass.getSize() >= 1) {
> /* 468 */                 for (int i = 0; i < ColorEditorSpot.modelListClass.getSize(); i++) {
> /* 469 */                   listClasses.add(ColorEditorSpot.modelListClass.getElementAt(i));
> /*     */                 }
> /* 471 */                 if (!listClasses.contains((
> /* 472 */                     (JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), 
> /* 473 */                       ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText())) {
> /* 474 */                   ColorEditorSpot.modelListClass.addElement((
> /* 475 */                       (JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), 
> /* 476 */                         ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
> /*     */                   
> /* 478 */                   JLabel labelsTableC = new JLabel();
> /* 479 */                   for (int j = 0; j < ColorEditorSpot.tableC.getModel().getRowCount(); j++) {
> /* 480 */                     labelsTableC.setText(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, 
> /* 481 */                           ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText());
> /* 482 */                     labelsTableC.setHorizontalAlignment(0);
> /* 483 */                     labelsTableC.setBackground(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, 
> /* 484 */                           ColorEditorSpot.tableC.convertColumnIndexToModel(1))).getBackground());
> /* 485 */                     labelsTableC.setOpaque(true);
> /*     */                   } 
> /*     */                   
> /* 488 */                   String[] filterFeature = ((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(selectedRow, 
> /* 489 */                       ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "")
> /* 490 */                     .replace("<html>", "").split("<br>");
> /* 491 */                   List<String> features = new ArrayList<>();
> /* 492 */                   List<String> featureMin = new ArrayList<>();
> /* 493 */                   List<String> featureMax = new ArrayList<>();
> /* 494 */                   for (int k = 0; k < filterFeature.length; k++) {
> /* 495 */                     features.add(filterFeature[k].substring(0, filterFeature[k].indexOf(":")));
> /* 496 */                     featureMin.add(filterFeature[k].substring(filterFeature[k].indexOf("[") + 1, 
> /* 497 */                           filterFeature[k].indexOf(",")));
> /* 498 */                     featureMax.add(filterFeature[k].substring(filterFeature[k].indexOf(",") + 1, 
> /* 499 */                           filterFeature[k].indexOf("]")));
> /*     */                   } 
> /*     */                   
> /* 502 */                   for (int x = 0; x < FirstWizardPanel.modelSpot.getRowCount(); x++) {
> /* 503 */                     for (int u = 0; u < features.size(); u++) {
> /* 504 */                       if (Double.parseDouble(FirstWizardPanel.tableSpot.getModel()
> /* 505 */                           .getValueAt(x, 
> /* 506 */                             FirstWizardPanel.tableSpot.getColumn(features.get(u))
> /* 507 */                             .getModelIndex())
> /* 508 */                           .toString()) >= Double.parseDouble(featureMin.get(u)))
> /* 509 */                         if (Double.parseDouble(FirstWizardPanel.tableSpot.getModel()
> /* 510 */                             .getValueAt(x, 
> /* 511 */                               FirstWizardPanel.tableSpot.getColumn(features.get(u))
> /* 512 */                               .getModelIndex())
> /* 513 */                             .toString()) <= Double.parseDouble(featureMax.get(u))) {
> /* 514 */                           FirstWizardPanel.tableSpot.getModel().setValueAt(labelsTableC, 
> /* 515 */                               FirstWizardPanel.tableSpot.convertRowIndexToModel(x), 
> /* 516 */                               FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
> /*     */                         } 
> /*     */                     } 
> /*     */                   } 
> /*     */                 } 
> /* 521 */                 if (listClasses.contains((
> /* 522 */                     (JLabel)ColorEditorSpot.tableC.getModel().getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(selectedRow), 
> /* 523 */                       ColorEditorSpot.tableC.convertColumnIndexToModel(0))).getText())) {
> /* 524 */                   ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
> /*     */                 }
> /*     */               } 
> /*     */             } 
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 532 */     this.cancelButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 535 */             ColorEditorSpot.myFrame.dispatchEvent(new WindowEvent(ColorEditorSpot.myFrame, 201));
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 540 */     this.deleteButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 543 */             Object labelC = null;
> /* 544 */             Object colorC = null;
> /* 545 */             Object[] labelsC = null;
> /* 546 */             Object[] colorsC = null;
> /* 547 */             int[] indexesRowC = ColorEditorSpot.tableC.getSelectedRows();
> /* 548 */             int indexRowC = ColorEditorSpot.tableC.getSelectedRow();
> /* 549 */             if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
> /* 550 */               labelC = new Object();
> /* 551 */               colorC = new Object();
> /* 552 */               labelC = ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexRowC), 
> /* 553 */                   ColorEditorSpot.tableC.convertColumnIndexToModel(0));
> /* 554 */               colorC = ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexRowC), 
> /* 555 */                   ColorEditorSpot.tableC.convertColumnIndexToModel(1));
> /*     */             } 
> /* 557 */             labelsC = new Object[indexesRowC.length];
> /* 558 */             colorsC = new Object[indexesRowC.length];
> /* 559 */             if (ColorEditorSpot.tableC.getSelectedRowCount() > 1)
> /*     */             {
> /* 561 */               for (int k = 0; k < indexesRowC.length; k++) {
> /* 562 */                 labelsC[k] = ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexesRowC[k]), 
> /* 563 */                     ColorEditorSpot.tableC.convertColumnIndexToModel(0));
> /* 564 */                 colorsC[k] = ColorEditorSpot.modelC.getValueAt(ColorEditorSpot.tableC.convertRowIndexToModel(indexesRowC[k]), 
> /* 565 */                     ColorEditorSpot.tableC.convertColumnIndexToModel(1));
> /*     */               } 
> /*     */             }
> /*     */             
> /* 569 */             Locale.setDefault(Locale.ENGLISH);
> /* 570 */             JOptionPane.setDefaultLocale(Locale.getDefault());
> /* 571 */             if (ColorEditorSpot.tableC.getSelectedRowCount() > 1) {
> /* 572 */               String[] labelsCtoString = new String[indexesRowC.length];
> /* 573 */               for (int k = 0; k < indexesRowC.length; k++)
> /* 574 */                 labelsCtoString[k] = ((JLabel)labelsC[k]).getText(); 
> /* 575 */               ColorEditorSpot.this.input = JOptionPane.showConfirmDialog((Component)null, "Are you sure to delete the selected labels?", 
> /* 576 */                   "Delete a label", 1, 0);
> /*     */               
> /* 578 */               if (ColorEditorSpot.this.input == 0) {
> /* 579 */                 for (int f = 0; f < indexesRowC.length; f++)
> /* 580 */                   ColorEditorSpot.modelC.removeRow(indexesRowC[f] - f); 
> /* 581 */                 ColorEditorSpot.modelC.fireTableDataChanged();
> /* 582 */                 ColorEditorSpot.tableC.repaint();
> /*     */               } 
> /*     */               
> /* 585 */               if (ColorEditorSpot.this.input == 1)
> /*     */                 return; 
> /* 587 */               if (ColorEditorSpot.this.input == 2) {
> /*     */                 return;
> /*     */               }
> /*     */             } 
> /* 591 */             if (ColorEditorSpot.tableC.getSelectedRowCount() == 1) {
> /* 592 */               String labelCtoString = ((JLabel)labelC).getText();
> /* 593 */               ColorEditorSpot.this.input = JOptionPane.showConfirmDialog((Component)null, 
> /* 594 */                   "Are you sure to delete the following label?----- " + labelCtoString, "Delete a label", 
> /* 595 */                   1, 0);
> /*     */               
> /* 597 */               if (ColorEditorSpot.this.input == 0) {
> /* 598 */                 ColorEditorSpot.modelC.removeRow(indexRowC);
> /* 599 */                 ColorEditorSpot.modelC.fireTableDataChanged();
> /*     */               } 
> /*     */               
> /* 602 */               if (ColorEditorSpot.this.input == 1)
> /*     */                 return; 
> /* 604 */               if (ColorEditorSpot.this.input == 2) {
> /*     */                 return;
> /*     */               }
> /*     */             } 
> /*     */           }
> /*     */         });
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object getCellEditorValueAdd() {
> /* 615 */     return this.currentColorAdd;
> /*     */   }
> /*     */   
> /*     */   public Object getCellEditorValueEdit() {
> /* 619 */     return this.currentColorEdit;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public Component getTableCellEditorComponentAdd(JTable table, Object value, boolean isSelected, int row, int column) {
> /* 624 */     this.currentColorAdd = (Color)value;
> /* 625 */     return this.colorButtonAdd;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public Component getTableCellEditorComponentEdit(JTable table, Object value, boolean isSelected, int row, int column) {
> /* 630 */     this.currentColorEdit = (Color)value;
> /* 631 */     return this.colorButtonEdit;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Component getTableCellEditorComponent(JTable arg0, Object arg1, boolean arg2, int arg3, int arg4) {
> /* 637 */     return null;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object getCellEditorValue() {
> /* 643 */     return null;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/ColorEditorSpot.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: ColorEditorTrack$10.java
Only in jd-gui: ColorEditorTrack$11.java
Only in jd-gui: ColorEditorTrack$12.java
Only in jd-gui: ColorEditorTrack$1.java
Only in jd-gui: ColorEditorTrack$2.java
Only in jd-gui: ColorEditorTrack$3.java
Only in jd-gui: ColorEditorTrack$4.java
Only in jd-gui: ColorEditorTrack$5.java
Only in jd-gui: ColorEditorTrack$6.java
Only in jd-gui: ColorEditorTrack$7.java
Only in jd-gui: ColorEditorTrack$8.java
Only in jd-gui: ColorEditorTrack$9.java
diff -r TrackAnalyzer_/ColorEditorTrack.java jd-gui/ColorEditorTrack.java
1,585c1,651
< import java.awt.Color;
< import java.awt.Component;
< import java.awt.Dimension;
< import java.awt.FlowLayout;
< import java.awt.Point;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.WindowEvent;
< import java.util.ArrayList;
< import java.util.List;
< import java.util.Locale;
< import javax.swing.AbstractCellEditor;
< import javax.swing.Box;
< import javax.swing.BoxLayout;
< import javax.swing.DefaultListModel;
< import javax.swing.Icon;
< import javax.swing.ImageIcon;
< import javax.swing.JButton;
< import javax.swing.JColorChooser;
< import javax.swing.JFrame;
< import javax.swing.JLabel;
< import javax.swing.JList;
< import javax.swing.JOptionPane;
< import javax.swing.JPanel;
< import javax.swing.JScrollPane;
< import javax.swing.JTable;
< import javax.swing.JTextField;
< import javax.swing.table.DefaultTableCellRenderer;
< import javax.swing.table.DefaultTableModel;
< import javax.swing.table.TableCellEditor;
< import javax.swing.table.TableColumn;
< import javax.swing.table.TableModel;
< import javax.swing.table.TableRowSorter;
< 
< public class ColorEditorTrack extends AbstractCellEditor implements TableCellEditor {
<    private JPanel myPanel;
<    private JPanel panelAdd;
<    private JPanel panelEdit;
<    private JLabel labelInitt;
<    private int result;
<    private int input;
<    static DefaultTableModel modelC;
<    static JTable tableC;
<    private JButton addButton;
<    private JButton editButton;
<    private JButton deleteButton;
<    private JButton colorButtonAdd;
<    private JButton colorButtonEdit;
<    private JButton okButton;
<    private JButton okButtonEdit;
<    private JButton cancelButton;
<    private JButton cancelButtonEdit;
<    private JButton okButtonAdd;
<    private JButton cancelButtonAdd;
<    static JList<String> featureList;
<    static JList<String> classList;
<    static DefaultListModel<String> modelListFeature;
<    static DefaultListModel<String> modelListClass;
<    private JLabel addTextAdd;
<    private JLabel addTextEdit;
<    private JTextField addTextFAdd;
<    private JTextField addTextFEdit;
<    private Color currentColorAdd;
<    private Color currentColorEdit;
<    private Color colorCInitial;
<    private Color colorCFinal;
<    private Object labelC;
<    private Object colorC;
<    private Object featureC;
<    private String addTextInitial;
<    private String addTextFinal;
<    private String featureInitial;
<    private String featureFinal;
<    static JFrame myFrame;
<    static JFrame myFrameAdd;
<    static JFrame myFrameEdit;
<    private Icon iconOKCell;
<    private Icon iconCancelCell;
<    private int indexRowC;
< 
<    public ColorEditorTrack(final JList<String> featureList) {
<       ColorEditorTrack.featureList = featureList;
<       this.addButton = new JButton("");
<       this.addButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
<       Icon iconAddCell = new ImageIcon(iconAdd.getImage().getScaledInstance(17, 15, 4));
<       this.addButton.setIcon(iconAddCell);
<       this.addButton.setToolTipText("Click this button to add your class-label.");
<       this.editButton = new JButton("");
<       this.editButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconEdit = FirstWizardPanel.createImageIcon("images/edit.png");
<       Icon iconEditCell = new ImageIcon(iconEdit.getImage().getScaledInstance(17, 15, 4));
<       this.editButton.setIcon(iconEditCell);
<       this.editButton.setToolTipText("Click this button to edit your class-label.");
<       this.deleteButton = new JButton("");
<       this.deleteButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconDelete = FirstWizardPanel.createImageIcon("images/bin.png");
<       Icon iconDeleteCell = new ImageIcon(iconDelete.getImage().getScaledInstance(22, 20, 4));
<       this.deleteButton.setIcon(iconDeleteCell);
<       this.deleteButton.setToolTipText("Click this button to delete your class-label.");
<       myFrame = new JFrame("Manage Labels");
<       myFrame.setLocation(new Point(100, 100));
<       myFrame.setDefaultCloseOperation(2);
<       this.myPanel = new JPanel();
<       this.myPanel.setLayout(new BoxLayout(this.myPanel, 1));
<       Object[][] rowData2 = new Object[0][];
<       Object[] columnNames = new Object[]{"Name", "Color", "Feature"};
<       modelC = new DefaultTableModel(rowData2, columnNames) {
<          private static final long serialVersionUID = 1L;
< 
<          public boolean isCellEditable(int row, int col) {
<             return false;
<          }
< 
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
<             }
< 
<             return super.getColumnClass(column);
<          }
<       };
<       tableC = new JTable();
<       tableC.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
<       tableC.setSelectionBackground(new Color(229, 255, 204));
<       tableC.setSelectionForeground(new Color(0, 102, 0));
<       TableRowSorter<TableModel> rowSorter = new TableRowSorter(modelC);
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableC.setDefaultRenderer(JLabel.class, centerRenderer);
<       tableC.setRowSorter(rowSorter);
<       JPanel panelButtons = new JPanel();
<       panelButtons.setLayout(new FlowLayout());
<       panelButtons.add(this.addButton);
<       panelButtons.add(this.editButton);
<       panelButtons.add(this.deleteButton);
<       tableC.setAutoCreateRowSorter(true);
<       tableC.setEnabled(true);
<       tableC.setCellSelectionEnabled(true);
<       tableC.setRowSelectionAllowed(true);
<       tableC.setColumnSelectionAllowed(false);
<       tableC.setSelectionMode(2);
<       tableC.setDefaultRenderer(JLabel.class, new Renderer());
<       tableC.setDefaultRenderer(Color.class, new ColorRenderer(true));
<       tableC.setModel(modelC);
<       TableColumn column1 = null;
<       column1 = tableC.getColumnModel().getColumn(0);
<       column1.setPreferredWidth(7);
<       column1.setCellRenderer(new ResultRendererC());
<       TableColumn column2 = null;
<       column2 = tableC.getColumnModel().getColumn(1);
<       column2.setPreferredWidth(5);
<       column2.setCellRenderer(new ResultRendererC());
<       TableColumn column3 = null;
<       column3 = tableC.getColumnModel().getColumn(2);
<       column3.setPreferredWidth(15);
<       column3.setCellRenderer(new ResultRendererC());
<       JScrollPane scrollPane = new JScrollPane(tableC);
< 
<       for(int u = 0; u < tableC.getColumnCount(); ++u) {
<          tableC.getColumnModel().getColumn(u).setPreferredWidth(90);
<       }
< 
<       tableC.setRowHeight(25);
<       this.myPanel.add(Box.createHorizontalStrut(15));
<       this.myPanel.add(panelButtons);
<       this.myPanel.add(scrollPane, "Center");
<       this.myPanel.setSize(300, 150);
<       this.myPanel.add(Box.createHorizontalStrut(15));
<       this.okButton = new JButton("");
<       this.okButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconOk = FirstWizardPanel.createImageIcon("images/add.png");
<       this.iconOKCell = new ImageIcon(iconOk.getImage().getScaledInstance(17, 15, 4));
<       this.okButton.setIcon(this.iconOKCell);
<       this.okButton.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButton = new JButton("");
<       this.cancelButton.setBounds(50, 100, 95, 30);
<       ImageIcon iconCancel = FirstWizardPanel.createImageIcon("images/cancel.png");
<       this.iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(17, 15, 4));
<       this.cancelButton.setIcon(this.iconCancelCell);
<       this.cancelButton.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancel = new JPanel();
<       panelOkCancel.setLayout(new FlowLayout());
<       panelOkCancel.add(this.okButton);
<       panelOkCancel.add(this.cancelButton);
<       this.myPanel.add(panelOkCancel);
<       myFrame.getContentPane().add(this.myPanel);
<       myFrame.pack();
<       myFrame.setLocationByPlatform(true);
<       this.panelAdd = new JPanel();
<       this.panelAdd.setPreferredSize(new Dimension(200, 100));
<       JPanel panel1 = new JPanel();
<       panel1.setLayout(new FlowLayout());
<       this.panelAdd.setLayout(new FlowLayout());
<       this.addTextAdd = new JLabel("Label Name: ");
<       this.addTextFAdd = new JTextField(8);
<       panel1.add(this.addTextAdd);
<       panel1.add(this.addTextFAdd);
<       JLabel pickC = new JLabel("Pick a color: ");
<       this.panelAdd.add(pickC);
<       this.colorButtonAdd = new JButton();
<       this.colorButtonAdd.setPreferredSize(new Dimension(200, 75));
<       this.panelAdd.add(this.colorButtonAdd);
<       this.okButtonAdd = new JButton("");
<       this.okButtonAdd.setBounds(50, 100, 95, 30);
<       this.okButtonAdd.setIcon(this.iconOKCell);
<       this.okButtonAdd.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButtonAdd = new JButton("");
<       this.cancelButtonAdd.setBounds(50, 100, 95, 30);
<       this.cancelButtonAdd.setIcon(this.iconCancelCell);
<       this.cancelButtonAdd.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancelAdd = new JPanel();
<       panelOkCancelAdd.setLayout(new FlowLayout());
<       panelOkCancelAdd.add(this.okButtonAdd);
<       panelOkCancelAdd.add(this.cancelButtonAdd);
<       myFrameAdd = new JFrame("Add Label");
<       JPanel mainPanel = new JPanel();
<       mainPanel.add(panel1);
<       mainPanel.add(this.panelAdd);
<       mainPanel.add(panelOkCancelAdd);
<       myFrameAdd.setPreferredSize(new Dimension(250, 250));
<       myFrameAdd.getContentPane().add(mainPanel);
<       myFrameAdd.pack();
<       myFrameAdd.setLocationByPlatform(true);
<       JPanel panel = new JPanel();
<       panel.setPreferredSize(new Dimension(200, 100));
<       JPanel panel2 = new JPanel();
<       panel2.setLayout(new FlowLayout());
<       panel.setLayout(new FlowLayout());
<       this.addTextEdit = new JLabel("Label Name: ");
<       this.addTextFEdit = new JTextField(8);
<       panel2.add(this.addTextEdit);
<       panel2.add(this.addTextFEdit);
<       JLabel pickEdit = new JLabel("Pick a Color: ");
<       panel.add(pickEdit);
<       this.colorButtonEdit = new JButton();
<       this.colorButtonEdit.setPreferredSize(new Dimension(200, 75));
<       panel.add(this.colorButtonEdit);
<       this.okButtonEdit = new JButton("");
<       this.okButtonEdit.setBounds(50, 100, 95, 30);
<       this.okButtonEdit.setIcon(this.iconOKCell);
<       this.okButtonEdit.setToolTipText("Click this button to edit your color selection.");
<       this.cancelButtonEdit = new JButton("");
<       this.cancelButtonEdit.setBounds(50, 100, 95, 30);
<       this.cancelButtonEdit.setIcon(this.iconCancelCell);
<       this.cancelButtonEdit.setToolTipText("Click this button to cancel your color selection.");
<       JPanel panelOkCancelEdit = new JPanel();
<       panelOkCancelEdit.setLayout(new FlowLayout());
<       panelOkCancelEdit.add(this.okButtonEdit);
<       panelOkCancelEdit.add(this.cancelButtonEdit);
<       myFrameEdit = new JFrame("Edit Label");
<       JPanel mainPanelEdit = new JPanel();
<       mainPanelEdit.add(panel2);
<       mainPanelEdit.add(panel);
<       mainPanelEdit.add(panelOkCancelEdit);
<       myFrameEdit.setPreferredSize(new Dimension(250, 250));
<       myFrameEdit.getContentPane().add(mainPanelEdit);
<       myFrameEdit.pack();
<       myFrameEdit.setLocationByPlatform(true);
<       this.addButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorTrack.tableC.setRowHeight(featureList.getHeight());
<             ColorEditorTrack.myFrameAdd.setVisible(true);
<          }
<       });
<       this.okButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             JLabel labelString = new JLabel();
<             JLabel labelColor = new JLabel();
<             JLabel labelFeature = new JLabel();
<             labelColor.setText("");
<             labelColor.setBackground(ColorEditorTrack.this.currentColorAdd);
<             labelString.setText(ColorEditorTrack.this.addTextFAdd.getText());
<             labelString.setHorizontalAlignment(0);
<             labelString.setBackground(ColorEditorTrack.this.currentColorAdd);
<             labelColor.setOpaque(true);
<             StringBuilder filterItems = new StringBuilder();
< 
<             for(int x = 0; x < featureList.getModel().getSize(); ++x) {
<                filterItems.append((String)featureList.getModel().getElementAt(x)).append("<br>");
<             }
< 
<             labelFeature.setText("<html>" + filterItems.toString() + "</html>");
<             ColorEditorTrack.modelC.addRow(new Object[]{labelString, labelColor, labelFeature});
<             ColorEditorTrack.modelC.fireTableDataChanged();
<             ColorEditorTrack.tableC.repaint();
<             ColorEditorTrack.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameAdd, 201));
<          }
<       });
<       this.cancelButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorTrack.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameAdd, 201));
<          }
<       });
<       this.editButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorTrack.myFrameEdit.setVisible(true);
<             ColorEditorTrack.this.indexRowC = ColorEditorTrack.tableC.getSelectedRow();
<             if (ColorEditorTrack.tableC.getSelectedRowCount() != 0) {
<                if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
<                   ColorEditorTrack.this.labelC = new Object();
<                   ColorEditorTrack.this.colorC = new Object();
<                   ColorEditorTrack.this.labelC = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<                   ColorEditorTrack.this.colorC = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<                   ColorEditorTrack.this.addTextInitial = ((JLabel)ColorEditorTrack.this.labelC).getText();
<                   ColorEditorTrack.this.colorCInitial = ((JLabel)ColorEditorTrack.this.colorC).getBackground();
<                }
< 
<                ColorEditorTrack.this.colorButtonEdit.setBackground(((JLabel)ColorEditorTrack.this.colorC).getBackground());
<                ColorEditorTrack.this.currentColorEdit = ((JLabel)ColorEditorTrack.this.colorC).getBackground();
<                ColorEditorTrack.this.colorButtonEdit.setContentAreaFilled(false);
<                ColorEditorTrack.this.colorButtonEdit.setOpaque(true);
<                ColorEditorTrack.this.addTextFEdit.setText(((JLabel)ColorEditorTrack.this.labelC).getText());
<             }
<          }
<       });
<       this.colorButtonAdd.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Locale.setDefault(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.getDefault());
<             ColorEditorTrack.this.currentColorAdd = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorTrack.this.colorButtonAdd.getBackground());
<             if (ColorEditorTrack.this.currentColorAdd != null) {
<                ColorEditorTrack.this.colorButtonAdd.setBackground(ColorEditorTrack.this.currentColorAdd);
<             }
< 
<          }
<       });
<       this.okButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             JLabel labelString = new JLabel();
<             JLabel labelColor = new JLabel();
<             labelColor.setText("");
<             labelColor.setBackground(ColorEditorTrack.this.currentColorEdit);
<             labelString.setText(ColorEditorTrack.this.addTextFEdit.getText());
<             labelString.setHorizontalAlignment(0);
<             labelString.setBackground(ColorEditorTrack.this.currentColorEdit);
<             labelColor.setOpaque(true);
<             ColorEditorTrack.this.addTextFinal = labelString.getText();
<             ColorEditorTrack.this.colorCFinal = labelColor.getBackground();
<             if (!ColorEditorTrack.this.addTextFinal.equals(ColorEditorTrack.this.addTextInitial)) {
<                ColorEditorTrack.modelC.setValueAt(labelString, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<             }
< 
<             if (ColorEditorTrack.this.addTextFinal.equals(ColorEditorTrack.this.addTextInitial)) {
<                ColorEditorTrack.modelC.setValueAt(ColorEditorTrack.this.labelC, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<             }
< 
<             if (ColorEditorTrack.this.currentColorEdit != ColorEditorTrack.this.colorCInitial) {
<                ColorEditorTrack.modelC.setValueAt(labelColor, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<             }
< 
<             if (ColorEditorTrack.this.currentColorEdit == ColorEditorTrack.this.colorCInitial) {
<                ColorEditorTrack.modelC.setValueAt(ColorEditorTrack.this.colorC, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<             }
< 
<             ColorEditorTrack.modelC.fireTableCellUpdated(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<             ColorEditorTrack.modelC.fireTableCellUpdated(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<             ColorEditorTrack.tableC.repaint();
<             ColorEditorTrack.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameEdit, 201));
<          }
<       });
<       this.cancelButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorTrack.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameEdit, 201));
<          }
<       });
<    }
< 
<    public void setClassAction() {
<       this.colorButtonEdit.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Locale.setDefault(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.ENGLISH);
<             JColorChooser.setDefaultLocale(Locale.getDefault());
<             ColorEditorTrack.this.currentColorEdit = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorTrack.this.colorButtonEdit.getBackground());
<             if (ColorEditorTrack.this.currentColorEdit != null) {
<                ColorEditorTrack.this.colorButtonEdit.setBackground(ColorEditorTrack.this.currentColorEdit);
<             }
< 
<          }
<       });
<       this.okButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             if (ColorEditorTrack.tableC.getSelectedRowCount() <= 0) {
<                ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
<             }
< 
<             if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
<                List<String> listClasses = new ArrayList();
<                ColorEditorTrack.classList = ChooserWizardPanel.classList;
<                ColorEditorTrack.modelListClass = ChooserWizardPanel.modelListClass;
<                int selectedRow = ColorEditorTrack.tableC.getSelectedRow();
<                JLabel labelsTableC;
<                int ix;
<                ArrayList features;
<                ArrayList featureMin;
<                ArrayList featureMax;
<                int x;
<                int u;
<                String[] filterFeature;
<                if (ColorEditorTrack.modelListClass.getSize() == 0) {
<                   ColorEditorTrack.modelListClass.addElement(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
<                   labelsTableC = new JLabel();
< 
<                   for(ix = 0; ix < ColorEditorTrack.tableC.getModel().getRowCount(); ++ix) {
<                      labelsTableC.setText(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
<                      labelsTableC.setHorizontalAlignment(0);
<                      labelsTableC.setBackground(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(1))).getBackground());
<                      labelsTableC.setOpaque(true);
<                   }
< 
<                   filterFeature = ((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
<                   features = new ArrayList();
<                   featureMin = new ArrayList();
<                   featureMax = new ArrayList();
< 
<                   for(x = 0; x < filterFeature.length; ++x) {
<                      features.add(filterFeature[x].substring(0, filterFeature[x].indexOf(":")));
<                      featureMin.add(filterFeature[x].substring(filterFeature[x].indexOf("[") + 1, filterFeature[x].indexOf(",")));
<                      featureMax.add(filterFeature[x].substring(filterFeature[x].indexOf(",") + 1, filterFeature[x].indexOf("]")));
<                   }
< 
<                   for(x = 0; x < ChooserWizardPanel.modelTrack.getRowCount(); ++x) {
<                      for(u = 0; u < features.size(); ++u) {
<                         if (Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble((String)featureMin.get(u)) && Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble((String)featureMax.get(u))) {
<                            ChooserWizardPanel.tableTrack.getModel().setValueAt(labelsTableC, ChooserWizardPanel.tableTrack.convertRowIndexToModel(x), ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
<                         }
<                      }
<                   }
<                }
< 
<                if (ColorEditorTrack.modelListClass.getSize() >= 1) {
<                   for(int i = 0; i < ColorEditorTrack.modelListClass.getSize(); ++i) {
<                      listClasses.add((String)ColorEditorTrack.modelListClass.getElementAt(i));
<                   }
< 
<                   if (!listClasses.contains(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText())) {
<                      ColorEditorTrack.modelListClass.addElement(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
<                      labelsTableC = new JLabel();
< 
<                      for(ix = 0; ix < ColorEditorTrack.tableC.getModel().getRowCount(); ++ix) {
<                         labelsTableC.setText(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
<                         labelsTableC.setHorizontalAlignment(0);
<                         labelsTableC.setBackground(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(1))).getBackground());
<                         labelsTableC.setOpaque(true);
<                      }
< 
<                      filterFeature = ((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, ColorEditorTrack.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "").replace("<html>", "").split("<br>");
<                      features = new ArrayList();
<                      featureMin = new ArrayList();
<                      featureMax = new ArrayList();
< 
<                      for(x = 0; x < filterFeature.length; ++x) {
<                         features.add(filterFeature[x].substring(0, filterFeature[x].indexOf(":")));
<                         featureMin.add(filterFeature[x].substring(filterFeature[x].indexOf("[") + 1, filterFeature[x].indexOf(",")));
<                         featureMax.add(filterFeature[x].substring(filterFeature[x].indexOf(",") + 1, filterFeature[x].indexOf("]")));
<                      }
< 
<                      for(x = 0; x < ChooserWizardPanel.modelTrack.getRowCount(); ++x) {
<                         for(u = 0; u < features.size(); ++u) {
<                            if (Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) >= Double.parseDouble((String)featureMin.get(u)) && Double.parseDouble(ChooserWizardPanel.tableTrack.getModel().getValueAt(x, ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex()).toString()) <= Double.parseDouble((String)featureMax.get(u))) {
<                               ChooserWizardPanel.tableTrack.getModel().setValueAt(labelsTableC, ChooserWizardPanel.tableTrack.convertRowIndexToModel(x), ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
<                            }
<                         }
<                      }
<                   }
< 
<                   if (listClasses.contains(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText())) {
<                      ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
<                   }
<                }
<             }
< 
<          }
<       });
<       this.cancelButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
<          }
<       });
<       this.deleteButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             Object labelC = null;
<             Object colorC = null;
<             Object[] labelsC = null;
<             Object[] colorsC = null;
<             int[] indexesRowC = ColorEditorTrack.tableC.getSelectedRows();
<             int indexRowC = ColorEditorTrack.tableC.getSelectedRow();
<             if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
<                new Object();
<                new Object();
<                labelC = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<                colorC = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexRowC), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<             }
< 
<             labelsC = new Object[indexesRowC.length];
<             colorsC = new Object[indexesRowC.length];
<             if (ColorEditorTrack.tableC.getSelectedRowCount() > 1) {
<                for(int k = 0; k < indexesRowC.length; ++k) {
<                   labelsC[k] = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorTrack.tableC.convertColumnIndexToModel(0));
<                   colorsC[k] = (JLabel)ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexesRowC[k]), ColorEditorTrack.tableC.convertColumnIndexToModel(1));
<                }
<             }
< 
<             Locale.setDefault(Locale.ENGLISH);
<             Locale var10000 = Locale.ENGLISH;
<             JOptionPane.setDefaultLocale(Locale.getDefault());
<             if (ColorEditorTrack.tableC.getSelectedRowCount() > 1) {
<                String[] labelsCtoString = new String[indexesRowC.length];
< 
<                int f;
<                for(f = 0; f < indexesRowC.length; ++f) {
<                   labelsCtoString[f] = ((JLabel)labelsC[f]).getText();
<                }
< 
<                ColorEditorTrack.this.input = JOptionPane.showConfirmDialog((Component)null, "Are you sure to delete the selected labels?", "Delete a label", 1, 0);
<                if (ColorEditorTrack.this.input == 0) {
<                   for(f = 0; f < indexesRowC.length; ++f) {
<                      ColorEditorTrack.modelC.removeRow(indexesRowC[f] - f);
<                   }
< 
<                   ColorEditorTrack.modelC.fireTableDataChanged();
<                   ColorEditorTrack.tableC.repaint();
<                }
< 
<                if (ColorEditorTrack.this.input == 1) {
<                   return;
<                }
< 
<                if (ColorEditorTrack.this.input == 2) {
<                   return;
<                }
<             }
< 
<             if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
<                String labelCtoString = ((JLabel)labelC).getText();
<                ColorEditorTrack.this.input = JOptionPane.showConfirmDialog((Component)null, "Are you sure to delete the following label?----- " + labelCtoString, "Delete a label", 1, 0);
<                if (ColorEditorTrack.this.input == 0) {
<                   ColorEditorTrack.modelC.removeRow(indexRowC);
<                   ColorEditorTrack.modelC.fireTableDataChanged();
<                }
< 
<                if (ColorEditorTrack.this.input == 1) {
<                   return;
<                }
< 
<                if (ColorEditorTrack.this.input == 2) {
<                   return;
<                }
<             }
< 
<          }
<       });
<    }
< 
<    public Object getCellEditorValueAdd() {
<       return this.currentColorAdd;
<    }
< 
<    public Object getCellEditorValueEdit() {
<       return this.currentColorEdit;
<    }
< 
<    public Component getTableCellEditorComponentAdd(JTable table, Object value, boolean isSelected, int row, int column) {
<       this.currentColorAdd = (Color)value;
<       return this.colorButtonAdd;
<    }
< 
<    public Component getTableCellEditorComponentEdit(JTable table, Object value, boolean isSelected, int row, int column) {
<       this.currentColorEdit = (Color)value;
<       return this.colorButtonEdit;
<    }
< 
<    public Component getTableCellEditorComponent(JTable arg0, Object arg1, boolean arg2, int arg3, int arg4) {
<       return null;
<    }
< 
<    public Object getCellEditorValue() {
<       return null;
<    }
< }
---
> /*     */ import java.awt.Color;
> /*     */ import java.awt.Component;
> /*     */ import java.awt.Dimension;
> /*     */ import java.awt.FlowLayout;
> /*     */ import java.awt.Point;
> /*     */ import java.awt.event.ActionEvent;
> /*     */ import java.awt.event.ActionListener;
> /*     */ import java.awt.event.WindowEvent;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.List;
> /*     */ import java.util.Locale;
> /*     */ import javax.swing.AbstractCellEditor;
> /*     */ import javax.swing.Box;
> /*     */ import javax.swing.BoxLayout;
> /*     */ import javax.swing.DefaultListModel;
> /*     */ import javax.swing.Icon;
> /*     */ import javax.swing.ImageIcon;
> /*     */ import javax.swing.JButton;
> /*     */ import javax.swing.JColorChooser;
> /*     */ import javax.swing.JFrame;
> /*     */ import javax.swing.JLabel;
> /*     */ import javax.swing.JList;
> /*     */ import javax.swing.JOptionPane;
> /*     */ import javax.swing.JPanel;
> /*     */ import javax.swing.JScrollPane;
> /*     */ import javax.swing.JTable;
> /*     */ import javax.swing.JTextField;
> /*     */ import javax.swing.table.DefaultTableCellRenderer;
> /*     */ import javax.swing.table.DefaultTableModel;
> /*     */ import javax.swing.table.TableCellEditor;
> /*     */ import javax.swing.table.TableCellRenderer;
> /*     */ import javax.swing.table.TableColumn;
> /*     */ import javax.swing.table.TableModel;
> /*     */ import javax.swing.table.TableRowSorter;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class ColorEditorTrack
> /*     */   extends AbstractCellEditor
> /*     */   implements TableCellEditor
> /*     */ {
> /*     */   private JPanel myPanel;
> /*     */   private JPanel panelAdd;
> /*     */   private JPanel panelEdit;
> /*     */   private JLabel labelInitt;
> /*     */   private int result;
> /*     */   private int input;
> /*     */   static DefaultTableModel modelC;
> /*     */   static JTable tableC;
> /*     */   private JButton addButton;
> /*     */   private JButton editButton;
> /*     */   private JButton deleteButton;
> /*     */   private JButton colorButtonAdd;
> /*     */   private JButton colorButtonEdit;
> /*     */   private JButton okButton;
> /*     */   private JButton okButtonEdit;
> /*     */   private JButton cancelButton;
> /*     */   private JButton cancelButtonEdit;
> /*     */   private JButton okButtonAdd;
> /*     */   private JButton cancelButtonAdd;
> /*     */   static JList<String> featureList;
> /*     */   static JList<String> classList;
> /*     */   static DefaultListModel<String> modelListFeature;
> /*     */   
> /*     */   public ColorEditorTrack(final JList<String> featureList) {
> /*  67 */     ColorEditorTrack.featureList = featureList;
> /*     */     
> /*  69 */     this.addButton = new JButton("");
> /*  70 */     this.addButton.setBounds(50, 100, 95, 30);
> /*  71 */     ImageIcon iconAdd = FirstWizardPanel.createImageIcon("images/add.png");
> /*  72 */     Icon iconAddCell = new ImageIcon(iconAdd.getImage().getScaledInstance(17, 15, 4));
> /*  73 */     this.addButton.setIcon(iconAddCell);
> /*  74 */     this.addButton.setToolTipText("Click this button to add your class-label.");
> /*  75 */     this.editButton = new JButton("");
> /*  76 */     this.editButton.setBounds(50, 100, 95, 30);
> /*  77 */     ImageIcon iconEdit = FirstWizardPanel.createImageIcon("images/edit.png");
> /*  78 */     Icon iconEditCell = new ImageIcon(iconEdit.getImage().getScaledInstance(17, 15, 4));
> /*  79 */     this.editButton.setIcon(iconEditCell);
> /*  80 */     this.editButton.setToolTipText("Click this button to edit your class-label.");
> /*  81 */     this.deleteButton = new JButton("");
> /*  82 */     this.deleteButton.setBounds(50, 100, 95, 30);
> /*  83 */     ImageIcon iconDelete = FirstWizardPanel.createImageIcon("images/bin.png");
> /*  84 */     Icon iconDeleteCell = new ImageIcon(iconDelete.getImage().getScaledInstance(22, 20, 4));
> /*  85 */     this.deleteButton.setIcon(iconDeleteCell);
> /*  86 */     this.deleteButton.setToolTipText("Click this button to delete your class-label.");
> /*  87 */     myFrame = new JFrame("Manage Labels");
> /*  88 */     myFrame.setLocation(new Point(100, 100));
> /*  89 */     myFrame.setDefaultCloseOperation(2);
> /*  90 */     this.myPanel = new JPanel();
> /*  91 */     this.myPanel.setLayout(new BoxLayout(this.myPanel, 1));
> /*  92 */     Object[][] rowData2 = new Object[0][];
> /*  93 */     Object[] columnNames = { "Name", "Color", "Feature" };
> /*     */     
> /*  95 */     modelC = new DefaultTableModel(rowData2, columnNames)
> /*     */       {
> /*     */         private static final long serialVersionUID = 1L;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */         
> /*     */         public boolean isCellEditable(int row, int col) {
> /* 106 */           return false;
> /*     */         }
> /*     */ 
> /*     */ 
> /*     */         
> /*     */         public Class<?> getColumnClass(int column) {
> /* 112 */           if (getRowCount() > 0) {
> /* 113 */             Object value = getValueAt(0, column);
> /* 114 */             if (value != null) {
> /* 115 */               return getValueAt(0, column).getClass();
> /*     */             }
> /*     */           } 
> /*     */           
> /* 119 */           return super.getColumnClass(column);
> /*     */         }
> /*     */       };
> /*     */     
> /* 123 */     tableC = new JTable();
> /* 124 */     tableC.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
> /* 125 */     tableC.setSelectionBackground(new Color(229, 255, 204));
> /* 126 */     tableC.setSelectionForeground(new Color(0, 102, 0));
> /* 127 */     TableRowSorter<TableModel> rowSorter = new TableRowSorter<>(modelC);
> /* 128 */     DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
> /* 129 */     centerRenderer.setHorizontalAlignment(0);
> /* 130 */     tableC.setDefaultRenderer(JLabel.class, centerRenderer);
> /* 131 */     tableC.setRowSorter(rowSorter);
> /* 132 */     JPanel panelButtons = new JPanel();
> /* 133 */     panelButtons.setLayout(new FlowLayout());
> /* 134 */     panelButtons.add(this.addButton);
> /* 135 */     panelButtons.add(this.editButton);
> /* 136 */     panelButtons.add(this.deleteButton);
> /* 137 */     tableC.setAutoCreateRowSorter(true);
> /* 138 */     tableC.setEnabled(true);
> /* 139 */     tableC.setCellSelectionEnabled(true);
> /*     */     
> /* 141 */     tableC.setRowSelectionAllowed(true);
> /* 142 */     tableC.setColumnSelectionAllowed(false);
> /* 143 */     tableC.setSelectionMode(2);
> /* 144 */     tableC.setDefaultRenderer(JLabel.class, new Renderer());
> /* 145 */     tableC.setDefaultRenderer(Color.class, new ColorRenderer(true));
> /* 146 */     tableC.setModel(modelC);
> /* 147 */     TableColumn column1 = null;
> /* 148 */     column1 = tableC.getColumnModel().getColumn(0);
> /* 149 */     column1.setPreferredWidth(7);
> /* 150 */     column1.setCellRenderer((TableCellRenderer)new ResultRendererC());
> /* 151 */     TableColumn column2 = null;
> /* 152 */     column2 = tableC.getColumnModel().getColumn(1);
> /* 153 */     column2.setPreferredWidth(5);
> /* 154 */     column2.setCellRenderer((TableCellRenderer)new ResultRendererC());
> /* 155 */     TableColumn column3 = null;
> /* 156 */     column3 = tableC.getColumnModel().getColumn(2);
> /* 157 */     column3.setPreferredWidth(15);
> /* 158 */     column3.setCellRenderer((TableCellRenderer)new ResultRendererC());
> /* 159 */     JScrollPane scrollPane = new JScrollPane(tableC);
> /* 160 */     for (int u = 0; u < tableC.getColumnCount(); u++)
> /* 161 */       tableC.getColumnModel().getColumn(u).setPreferredWidth(90); 
> /* 162 */     tableC.setRowHeight(25);
> /* 163 */     this.myPanel.add(Box.createHorizontalStrut(15));
> /* 164 */     this.myPanel.add(panelButtons);
> /* 165 */     this.myPanel.add(scrollPane, "Center");
> /* 166 */     this.myPanel.setSize(300, 150);
> /*     */     
> /* 168 */     this.myPanel.add(Box.createHorizontalStrut(15));
> /* 169 */     this.okButton = new JButton("");
> /* 170 */     this.okButton.setBounds(50, 100, 95, 30);
> /* 171 */     ImageIcon iconOk = FirstWizardPanel.createImageIcon("images/add.png");
> /* 172 */     this.iconOKCell = new ImageIcon(iconOk.getImage().getScaledInstance(17, 15, 4));
> /* 173 */     this.okButton.setIcon(this.iconOKCell);
> /* 174 */     this.okButton.setToolTipText("Click this button to edit your color selection.");
> /* 175 */     this.cancelButton = new JButton("");
> /* 176 */     this.cancelButton.setBounds(50, 100, 95, 30);
> /* 177 */     ImageIcon iconCancel = FirstWizardPanel.createImageIcon("images/cancel.png");
> /* 178 */     this.iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(17, 15, 4));
> /* 179 */     this.cancelButton.setIcon(this.iconCancelCell);
> /* 180 */     this.cancelButton.setToolTipText("Click this button to cancel your color selection.");
> /* 181 */     JPanel panelOkCancel = new JPanel();
> /* 182 */     panelOkCancel.setLayout(new FlowLayout());
> /* 183 */     panelOkCancel.add(this.okButton);
> /* 184 */     panelOkCancel.add(this.cancelButton);
> /* 185 */     this.myPanel.add(panelOkCancel);
> /* 186 */     myFrame.getContentPane().add(this.myPanel);
> /* 187 */     myFrame.pack();
> /* 188 */     myFrame.setLocationByPlatform(true);
> /*     */ 
> /*     */     
> /* 191 */     this.panelAdd = new JPanel();
> /* 192 */     this.panelAdd.setPreferredSize(new Dimension(200, 100));
> /* 193 */     JPanel panel1 = new JPanel();
> /* 194 */     panel1.setLayout(new FlowLayout());
> /* 195 */     this.panelAdd.setLayout(new FlowLayout());
> /* 196 */     this.addTextAdd = new JLabel("Label Name: ");
> /* 197 */     this.addTextFAdd = new JTextField(8);
> /* 198 */     panel1.add(this.addTextAdd);
> /* 199 */     panel1.add(this.addTextFAdd);
> /* 200 */     JLabel pickC = new JLabel("Pick a color: ");
> /* 201 */     this.panelAdd.add(pickC);
> /* 202 */     this.colorButtonAdd = new JButton();
> /* 203 */     this.colorButtonAdd.setPreferredSize(new Dimension(200, 75));
> /*     */     
> /* 205 */     this.panelAdd.add(this.colorButtonAdd);
> /* 206 */     this.okButtonAdd = new JButton("");
> /* 207 */     this.okButtonAdd.setBounds(50, 100, 95, 30);
> /* 208 */     this.okButtonAdd.setIcon(this.iconOKCell);
> /* 209 */     this.okButtonAdd.setToolTipText("Click this button to edit your color selection.");
> /* 210 */     this.cancelButtonAdd = new JButton("");
> /* 211 */     this.cancelButtonAdd.setBounds(50, 100, 95, 30);
> /* 212 */     this.cancelButtonAdd.setIcon(this.iconCancelCell);
> /* 213 */     this.cancelButtonAdd.setToolTipText("Click this button to cancel your color selection.");
> /* 214 */     JPanel panelOkCancelAdd = new JPanel();
> /* 215 */     panelOkCancelAdd.setLayout(new FlowLayout());
> /* 216 */     panelOkCancelAdd.add(this.okButtonAdd);
> /* 217 */     panelOkCancelAdd.add(this.cancelButtonAdd);
> /* 218 */     myFrameAdd = new JFrame("Add Label");
> /* 219 */     JPanel mainPanel = new JPanel();
> /* 220 */     mainPanel.add(panel1);
> /* 221 */     mainPanel.add(this.panelAdd);
> /* 222 */     mainPanel.add(panelOkCancelAdd);
> /* 223 */     myFrameAdd.setPreferredSize(new Dimension(250, 250));
> /* 224 */     myFrameAdd.getContentPane().add(mainPanel);
> /* 225 */     myFrameAdd.pack();
> /* 226 */     myFrameAdd.setLocationByPlatform(true);
> /*     */ 
> /*     */ 
> /*     */     
> /* 230 */     JPanel panel = new JPanel();
> /* 231 */     panel.setPreferredSize(new Dimension(200, 100));
> /* 232 */     JPanel panel2 = new JPanel();
> /* 233 */     panel2.setLayout(new FlowLayout());
> /* 234 */     panel.setLayout(new FlowLayout());
> /* 235 */     this.addTextEdit = new JLabel("Label Name: ");
> /* 236 */     this.addTextFEdit = new JTextField(8);
> /* 237 */     panel2.add(this.addTextEdit);
> /* 238 */     panel2.add(this.addTextFEdit);
> /* 239 */     JLabel pickEdit = new JLabel("Pick a Color: ");
> /* 240 */     panel.add(pickEdit);
> /* 241 */     this.colorButtonEdit = new JButton();
> /* 242 */     this.colorButtonEdit.setPreferredSize(new Dimension(200, 75));
> /* 243 */     panel.add(this.colorButtonEdit);
> /* 244 */     this.okButtonEdit = new JButton("");
> /* 245 */     this.okButtonEdit.setBounds(50, 100, 95, 30);
> /* 246 */     this.okButtonEdit.setIcon(this.iconOKCell);
> /* 247 */     this.okButtonEdit.setToolTipText("Click this button to edit your color selection.");
> /* 248 */     this.cancelButtonEdit = new JButton("");
> /* 249 */     this.cancelButtonEdit.setBounds(50, 100, 95, 30);
> /* 250 */     this.cancelButtonEdit.setIcon(this.iconCancelCell);
> /* 251 */     this.cancelButtonEdit.setToolTipText("Click this button to cancel your color selection.");
> /* 252 */     JPanel panelOkCancelEdit = new JPanel();
> /* 253 */     panelOkCancelEdit.setLayout(new FlowLayout());
> /* 254 */     panelOkCancelEdit.add(this.okButtonEdit);
> /* 255 */     panelOkCancelEdit.add(this.cancelButtonEdit);
> /* 256 */     myFrameEdit = new JFrame("Edit Label");
> /* 257 */     JPanel mainPanelEdit = new JPanel();
> /* 258 */     mainPanelEdit.add(panel2);
> /* 259 */     mainPanelEdit.add(panel);
> /* 260 */     mainPanelEdit.add(panelOkCancelEdit);
> /* 261 */     myFrameEdit.setPreferredSize(new Dimension(250, 250));
> /* 262 */     myFrameEdit.getContentPane().add(mainPanelEdit);
> /* 263 */     myFrameEdit.pack();
> /* 264 */     myFrameEdit.setLocationByPlatform(true);
> /*     */ 
> /*     */     
> /* 267 */     this.addButton.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 269 */             ColorEditorTrack.tableC.setRowHeight(featureList.getHeight());
> /* 270 */             ColorEditorTrack.myFrameAdd.setVisible(true);
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 275 */     this.okButtonAdd.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 277 */             JLabel labelString = new JLabel();
> /* 278 */             JLabel labelColor = new JLabel();
> /* 279 */             JLabel labelFeature = new JLabel();
> /* 280 */             labelColor.setText("");
> /* 281 */             labelColor.setBackground(ColorEditorTrack.this.currentColorAdd);
> /* 282 */             labelString.setText(ColorEditorTrack.this.addTextFAdd.getText());
> /* 283 */             labelString.setHorizontalAlignment(0);
> /* 284 */             labelString.setBackground(ColorEditorTrack.this.currentColorAdd);
> /* 285 */             labelColor.setOpaque(true);
> /* 286 */             StringBuilder filterItems = new StringBuilder();
> /* 287 */             for (int x = 0; x < featureList.getModel().getSize(); x++)
> /* 288 */               filterItems.append(featureList.getModel().getElementAt(x)).append("<br>"); 
> /* 289 */             labelFeature.setText("<html>" + filterItems.toString() + "</html>");
> /* 290 */             ColorEditorTrack.modelC.addRow(new Object[] { labelString, labelColor, labelFeature });
> /* 291 */             ColorEditorTrack.modelC.fireTableDataChanged();
> /* 292 */             ColorEditorTrack.tableC.repaint();
> /*     */             
> /* 294 */             ColorEditorTrack.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameAdd, 201));
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 299 */     this.cancelButtonAdd.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 301 */             ColorEditorTrack.myFrameAdd.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameAdd, 201));
> /*     */           }
> /*     */         });
> /*     */     
> /* 305 */     this.editButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           
> /*     */           public void actionPerformed(ActionEvent e)
> /*     */           {
> /* 310 */             ColorEditorTrack.myFrameEdit.setVisible(true);
> /*     */             
> /* 312 */             ColorEditorTrack.this.indexRowC = ColorEditorTrack.tableC.getSelectedRow();
> /* 313 */             if (ColorEditorTrack.tableC.getSelectedRowCount() == 0)
> /*     */               return; 
> /* 315 */             if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
> /* 316 */               ColorEditorTrack.this.labelC = new Object();
> /* 317 */               ColorEditorTrack.this.colorC = new Object();
> /* 318 */               ColorEditorTrack.this.labelC = ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), 
> /* 319 */                   ColorEditorTrack.tableC.convertColumnIndexToModel(0));
> /* 320 */               ColorEditorTrack.this.colorC = ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), 
> /* 321 */                   ColorEditorTrack.tableC.convertColumnIndexToModel(1));
> /* 322 */               ColorEditorTrack.this.addTextInitial = ((JLabel)ColorEditorTrack.this.labelC).getText();
> /* 323 */               ColorEditorTrack.this.colorCInitial = ((JLabel)ColorEditorTrack.this.colorC).getBackground();
> /*     */             } 
> /*     */             
> /* 326 */             ColorEditorTrack.this.colorButtonEdit.setBackground(((JLabel)ColorEditorTrack.this.colorC).getBackground());
> /* 327 */             ColorEditorTrack.this.currentColorEdit = ((JLabel)ColorEditorTrack.this.colorC).getBackground();
> /* 328 */             ColorEditorTrack.this.colorButtonEdit.setContentAreaFilled(false);
> /* 329 */             ColorEditorTrack.this.colorButtonEdit.setOpaque(true);
> /*     */             
> /* 331 */             ColorEditorTrack.this.addTextFEdit.setText(((JLabel)ColorEditorTrack.this.labelC).getText());
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 336 */     this.colorButtonAdd.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 339 */             Locale.setDefault(Locale.ENGLISH);
> /* 340 */             JColorChooser.setDefaultLocale(Locale.ENGLISH);
> /* 341 */             JColorChooser.setDefaultLocale(Locale.getDefault());
> /* 342 */             ColorEditorTrack.this.currentColorAdd = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorTrack.this.colorButtonAdd.getBackground());
> /* 343 */             if (ColorEditorTrack.this.currentColorAdd != null) {
> /* 344 */               ColorEditorTrack.this.colorButtonAdd.setBackground(ColorEditorTrack.this.currentColorAdd);
> /*     */             }
> /*     */           }
> /*     */         });
> /* 348 */     this.okButtonEdit.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 350 */             JLabel labelString = new JLabel();
> /* 351 */             JLabel labelColor = new JLabel();
> /* 352 */             labelColor.setText("");
> /* 353 */             labelColor.setBackground(ColorEditorTrack.this.currentColorEdit);
> /* 354 */             labelString.setText(ColorEditorTrack.this.addTextFEdit.getText());
> /* 355 */             labelString.setHorizontalAlignment(0);
> /* 356 */             labelString.setBackground(ColorEditorTrack.this.currentColorEdit);
> /* 357 */             labelColor.setOpaque(true);
> /* 358 */             ColorEditorTrack.this.addTextFinal = labelString.getText();
> /* 359 */             ColorEditorTrack.this.colorCFinal = labelColor.getBackground();
> /*     */             
> /* 361 */             if (!ColorEditorTrack.this.addTextFinal.equals(ColorEditorTrack.this.addTextInitial))
> /* 362 */               ColorEditorTrack.modelC.setValueAt(labelString, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), 
> /* 363 */                   ColorEditorTrack.tableC.convertColumnIndexToModel(0)); 
> /* 364 */             if (ColorEditorTrack.this.addTextFinal.equals(ColorEditorTrack.this.addTextInitial))
> /* 365 */               ColorEditorTrack.modelC.setValueAt(ColorEditorTrack.this.labelC, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), 
> /* 366 */                   ColorEditorTrack.tableC.convertColumnIndexToModel(0)); 
> /* 367 */             if (ColorEditorTrack.this.currentColorEdit != ColorEditorTrack.this.colorCInitial)
> /* 368 */               ColorEditorTrack.modelC.setValueAt(labelColor, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), 
> /* 369 */                   ColorEditorTrack.tableC.convertColumnIndexToModel(1)); 
> /* 370 */             if (ColorEditorTrack.this.currentColorEdit == ColorEditorTrack.this.colorCInitial) {
> /* 371 */               ColorEditorTrack.modelC.setValueAt(ColorEditorTrack.this.colorC, ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), 
> /* 372 */                   ColorEditorTrack.tableC.convertColumnIndexToModel(1));
> /*     */             }
> /* 374 */             ColorEditorTrack.modelC.fireTableCellUpdated(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), 
> /* 375 */                 ColorEditorTrack.tableC.convertColumnIndexToModel(0));
> /* 376 */             ColorEditorTrack.modelC.fireTableCellUpdated(ColorEditorTrack.tableC.convertRowIndexToModel(ColorEditorTrack.this.indexRowC), 
> /* 377 */                 ColorEditorTrack.tableC.convertColumnIndexToModel(1));
> /* 378 */             ColorEditorTrack.tableC.repaint();
> /*     */             
> /* 380 */             ColorEditorTrack.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameEdit, 201));
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */ 
> /*     */     
> /* 386 */     this.cancelButtonEdit.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 388 */             ColorEditorTrack.myFrameEdit.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrameEdit, 201));
> /*     */           }
> /*     */         });
> /*     */   } static DefaultListModel<String> modelListClass; private JLabel addTextAdd; private JLabel addTextEdit; private JTextField addTextFAdd; private JTextField addTextFEdit; private Color currentColorAdd; private Color currentColorEdit; private Color colorCInitial; private Color colorCFinal; private Object labelC; private Object colorC; private Object featureC; private String addTextInitial; private String addTextFinal; private String featureInitial; private String featureFinal; static JFrame myFrame; static JFrame myFrameAdd; static JFrame myFrameEdit; private Icon iconOKCell;
> /*     */   private Icon iconCancelCell;
> /*     */   private int indexRowC;
> /*     */   
> /*     */   public void setClassAction() {
> /* 396 */     this.colorButtonEdit.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 399 */             Locale.setDefault(Locale.ENGLISH);
> /* 400 */             JColorChooser.setDefaultLocale(Locale.ENGLISH);
> /* 401 */             JColorChooser.setDefaultLocale(Locale.getDefault());
> /* 402 */             ColorEditorTrack.this.currentColorEdit = JColorChooser.showDialog((Component)null, "Pick a Color: ", ColorEditorTrack.this.colorButtonEdit.getBackground());
> /* 403 */             if (ColorEditorTrack.this.currentColorEdit != null)
> /* 404 */               ColorEditorTrack.this.colorButtonEdit.setBackground(ColorEditorTrack.this.currentColorEdit); 
> /*     */           }
> /*     */         });
> /* 407 */     this.okButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e)
> /*     */           {
> /* 411 */             if (ColorEditorTrack.tableC.getSelectedRowCount() <= 0) {
> /* 412 */               ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
> /*     */             }
> /* 414 */             if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
> /*     */               
> /* 416 */               List<String> listClasses = new ArrayList<>();
> /* 417 */               ColorEditorTrack.classList = ChooserWizardPanel.classList;
> /* 418 */               ColorEditorTrack.modelListClass = ChooserWizardPanel.modelListClass;
> /* 419 */               int selectedRow = ColorEditorTrack.tableC.getSelectedRow();
> /*     */               
> /* 421 */               if (ColorEditorTrack.modelListClass.getSize() == 0) {
> /* 422 */                 ColorEditorTrack.modelListClass.addElement((
> /* 423 */                     (JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), 
> /* 424 */                       ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
> /* 425 */                 JLabel labelsTableC = new JLabel();
> /* 426 */                 for (int i = 0; i < ColorEditorTrack.tableC.getModel().getRowCount(); i++) {
> /* 427 */                   labelsTableC.setText(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, 
> /* 428 */                         ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
> /* 429 */                   labelsTableC.setHorizontalAlignment(0);
> /* 430 */                   labelsTableC.setBackground(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, 
> /* 431 */                         ColorEditorTrack.tableC.convertColumnIndexToModel(1))).getBackground());
> /* 432 */                   labelsTableC.setOpaque(true);
> /*     */                 } 
> /*     */                 
> /* 435 */                 String[] filterFeature = ((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, 
> /* 436 */                     ColorEditorTrack.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "")
> /* 437 */                   .replace("<html>", "").split("<br>");
> /* 438 */                 List<String> features = new ArrayList<>();
> /* 439 */                 List<String> featureMin = new ArrayList<>();
> /* 440 */                 List<String> featureMax = new ArrayList<>();
> /* 441 */                 for (int j = 0; j < filterFeature.length; j++) {
> /* 442 */                   features.add(filterFeature[j].substring(0, filterFeature[j].indexOf(":")));
> /* 443 */                   featureMin.add(filterFeature[j].substring(filterFeature[j].indexOf("[") + 1, 
> /* 444 */                         filterFeature[j].indexOf(",")));
> /* 445 */                   featureMax.add(filterFeature[j].substring(filterFeature[j].indexOf(",") + 1, 
> /* 446 */                         filterFeature[j].indexOf("]")));
> /*     */                 } 
> /*     */                 
> /* 449 */                 for (int x = 0; x < ChooserWizardPanel.modelTrack.getRowCount(); x++) {
> /* 450 */                   for (int u = 0; u < features.size(); u++) {
> /* 451 */                     if (Double.parseDouble(ChooserWizardPanel.tableTrack.getModel()
> /* 452 */                         .getValueAt(x, 
> /* 453 */                           ChooserWizardPanel.tableTrack.getColumn(features.get(u)).getModelIndex())
> /* 454 */                         .toString()) >= Double.parseDouble(featureMin.get(u)))
> /* 455 */                       if (Double.parseDouble(ChooserWizardPanel.tableTrack.getModel()
> /* 456 */                           .getValueAt(x, 
> /* 457 */                             ChooserWizardPanel.tableTrack.getColumn(features.get(u))
> /* 458 */                             .getModelIndex())
> /* 459 */                           .toString()) <= Double.parseDouble(featureMax.get(u))) {
> /* 460 */                         ChooserWizardPanel.tableTrack.getModel().setValueAt(labelsTableC, 
> /* 461 */                             ChooserWizardPanel.tableTrack.convertRowIndexToModel(x), 
> /* 462 */                             ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
> /*     */                       } 
> /*     */                   } 
> /*     */                 } 
> /*     */               } 
> /* 467 */               if (ColorEditorTrack.modelListClass.getSize() >= 1) {
> /* 468 */                 for (int i = 0; i < ColorEditorTrack.modelListClass.getSize(); i++) {
> /* 469 */                   listClasses.add(ColorEditorTrack.modelListClass.getElementAt(i));
> /*     */                 }
> /* 471 */                 if (!listClasses.contains((
> /* 472 */                     (JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), 
> /* 473 */                       ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText())) {
> /* 474 */                   ColorEditorTrack.modelListClass.addElement((
> /* 475 */                       (JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), 
> /* 476 */                         ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
> /*     */                   
> /* 478 */                   JLabel labelsTableC = new JLabel();
> /* 479 */                   for (int j = 0; j < ColorEditorTrack.tableC.getModel().getRowCount(); j++) {
> /* 480 */                     labelsTableC.setText(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, 
> /* 481 */                           ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText());
> /* 482 */                     labelsTableC.setHorizontalAlignment(0);
> /* 483 */                     labelsTableC.setBackground(((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, 
> /* 484 */                           ColorEditorTrack.tableC.convertColumnIndexToModel(1))).getBackground());
> /* 485 */                     labelsTableC.setOpaque(true);
> /*     */                   } 
> /*     */                   
> /* 488 */                   String[] filterFeature = ((JLabel)ColorEditorTrack.tableC.getModel().getValueAt(selectedRow, 
> /* 489 */                       ColorEditorTrack.tableC.convertColumnIndexToModel(2))).getText().replace("</html>", "")
> /* 490 */                     .replace("<html>", "").split("<br>");
> /* 491 */                   List<String> features = new ArrayList<>();
> /* 492 */                   List<String> featureMin = new ArrayList<>();
> /* 493 */                   List<String> featureMax = new ArrayList<>();
> /* 494 */                   for (int k = 0; k < filterFeature.length; k++) {
> /* 495 */                     features.add(filterFeature[k].substring(0, filterFeature[k].indexOf(":")));
> /* 496 */                     featureMin.add(filterFeature[k].substring(filterFeature[k].indexOf("[") + 1, 
> /* 497 */                           filterFeature[k].indexOf(",")));
> /* 498 */                     featureMax.add(filterFeature[k].substring(filterFeature[k].indexOf(",") + 1, 
> /* 499 */                           filterFeature[k].indexOf("]")));
> /*     */                   } 
> /*     */                   
> /* 502 */                   for (int x = 0; x < ChooserWizardPanel.modelTrack.getRowCount(); x++) {
> /* 503 */                     for (int u = 0; u < features.size(); u++) {
> /* 504 */                       if (Double.parseDouble(ChooserWizardPanel.tableTrack.getModel()
> /* 505 */                           .getValueAt(x, 
> /* 506 */                             ChooserWizardPanel.tableTrack.getColumn(features.get(u))
> /* 507 */                             .getModelIndex())
> /* 508 */                           .toString()) >= Double.parseDouble(featureMin.get(u)))
> /* 509 */                         if (Double.parseDouble(ChooserWizardPanel.tableTrack.getModel()
> /* 510 */                             .getValueAt(x, 
> /* 511 */                               ChooserWizardPanel.tableTrack.getColumn(features.get(u))
> /* 512 */                               .getModelIndex())
> /* 513 */                             .toString()) <= Double.parseDouble(featureMax.get(u))) {
> /* 514 */                           ChooserWizardPanel.tableTrack.getModel().setValueAt(labelsTableC, 
> /* 515 */                               ChooserWizardPanel.tableTrack.convertRowIndexToModel(x), 
> /* 516 */                               ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1));
> /*     */                         } 
> /*     */                     } 
> /*     */                   } 
> /*     */                 } 
> /* 521 */                 if (listClasses.contains((
> /* 522 */                     (JLabel)ColorEditorTrack.tableC.getModel().getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(selectedRow), 
> /* 523 */                       ColorEditorTrack.tableC.convertColumnIndexToModel(0))).getText())) {
> /* 524 */                   ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
> /*     */                 }
> /*     */               } 
> /*     */             } 
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 532 */     this.cancelButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 535 */             ColorEditorTrack.myFrame.dispatchEvent(new WindowEvent(ColorEditorTrack.myFrame, 201));
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 540 */     this.deleteButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 543 */             Object labelC = null;
> /* 544 */             Object colorC = null;
> /* 545 */             Object[] labelsC = null;
> /* 546 */             Object[] colorsC = null;
> /* 547 */             int[] indexesRowC = ColorEditorTrack.tableC.getSelectedRows();
> /* 548 */             int indexRowC = ColorEditorTrack.tableC.getSelectedRow();
> /* 549 */             if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
> /* 550 */               labelC = new Object();
> /* 551 */               colorC = new Object();
> /* 552 */               labelC = ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexRowC), 
> /* 553 */                   ColorEditorTrack.tableC.convertColumnIndexToModel(0));
> /* 554 */               colorC = ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexRowC), 
> /* 555 */                   ColorEditorTrack.tableC.convertColumnIndexToModel(1));
> /*     */             } 
> /* 557 */             labelsC = new Object[indexesRowC.length];
> /* 558 */             colorsC = new Object[indexesRowC.length];
> /* 559 */             if (ColorEditorTrack.tableC.getSelectedRowCount() > 1)
> /*     */             {
> /* 561 */               for (int k = 0; k < indexesRowC.length; k++) {
> /* 562 */                 labelsC[k] = ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexesRowC[k]), 
> /* 563 */                     ColorEditorTrack.tableC.convertColumnIndexToModel(0));
> /* 564 */                 colorsC[k] = ColorEditorTrack.modelC.getValueAt(ColorEditorTrack.tableC.convertRowIndexToModel(indexesRowC[k]), 
> /* 565 */                     ColorEditorTrack.tableC.convertColumnIndexToModel(1));
> /*     */               } 
> /*     */             }
> /*     */             
> /* 569 */             Locale.setDefault(Locale.ENGLISH);
> /* 570 */             JOptionPane.setDefaultLocale(Locale.getDefault());
> /* 571 */             if (ColorEditorTrack.tableC.getSelectedRowCount() > 1) {
> /* 572 */               String[] labelsCtoString = new String[indexesRowC.length];
> /* 573 */               for (int k = 0; k < indexesRowC.length; k++)
> /* 574 */                 labelsCtoString[k] = ((JLabel)labelsC[k]).getText(); 
> /* 575 */               ColorEditorTrack.this.input = JOptionPane.showConfirmDialog((Component)null, "Are you sure to delete the selected labels?", 
> /* 576 */                   "Delete a label", 1, 0);
> /*     */               
> /* 578 */               if (ColorEditorTrack.this.input == 0) {
> /* 579 */                 for (int f = 0; f < indexesRowC.length; f++)
> /* 580 */                   ColorEditorTrack.modelC.removeRow(indexesRowC[f] - f); 
> /* 581 */                 ColorEditorTrack.modelC.fireTableDataChanged();
> /* 582 */                 ColorEditorTrack.tableC.repaint();
> /*     */               } 
> /*     */               
> /* 585 */               if (ColorEditorTrack.this.input == 1)
> /*     */                 return; 
> /* 587 */               if (ColorEditorTrack.this.input == 2) {
> /*     */                 return;
> /*     */               }
> /*     */             } 
> /* 591 */             if (ColorEditorTrack.tableC.getSelectedRowCount() == 1) {
> /* 592 */               String labelCtoString = ((JLabel)labelC).getText();
> /* 593 */               ColorEditorTrack.this.input = JOptionPane.showConfirmDialog((Component)null, 
> /* 594 */                   "Are you sure to delete the following label?----- " + labelCtoString, "Delete a label", 
> /* 595 */                   1, 0);
> /*     */               
> /* 597 */               if (ColorEditorTrack.this.input == 0) {
> /* 598 */                 ColorEditorTrack.modelC.removeRow(indexRowC);
> /* 599 */                 ColorEditorTrack.modelC.fireTableDataChanged();
> /*     */               } 
> /*     */               
> /* 602 */               if (ColorEditorTrack.this.input == 1)
> /*     */                 return; 
> /* 604 */               if (ColorEditorTrack.this.input == 2) {
> /*     */                 return;
> /*     */               }
> /*     */             } 
> /*     */           }
> /*     */         });
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object getCellEditorValueAdd() {
> /* 615 */     return this.currentColorAdd;
> /*     */   }
> /*     */   
> /*     */   public Object getCellEditorValueEdit() {
> /* 619 */     return this.currentColorEdit;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public Component getTableCellEditorComponentAdd(JTable table, Object value, boolean isSelected, int row, int column) {
> /* 624 */     this.currentColorAdd = (Color)value;
> /* 625 */     return this.colorButtonAdd;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public Component getTableCellEditorComponentEdit(JTable table, Object value, boolean isSelected, int row, int column) {
> /* 630 */     this.currentColorEdit = (Color)value;
> /* 631 */     return this.colorButtonEdit;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Component getTableCellEditorComponent(JTable arg0, Object arg1, boolean arg2, int arg3, int arg4) {
> /* 637 */     return null;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object getCellEditorValue() {
> /* 643 */     return null;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/ColorEditorTrack.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/ColorRenderer.java jd-gui/ColorRenderer.java
1,42c1,51
< import java.awt.Color;
< import java.awt.Component;
< import javax.swing.BorderFactory;
< import javax.swing.JLabel;
< import javax.swing.JTable;
< import javax.swing.border.Border;
< import javax.swing.table.TableCellRenderer;
< 
< public class ColorRenderer extends JLabel implements TableCellRenderer {
<    private static final long serialVersionUID = 1L;
<    Border unselectedBorder = null;
<    Border selectedBorder = null;
<    boolean isBordered = true;
< 
<    public ColorRenderer(boolean isBordered) {
<       this.isBordered = isBordered;
<       this.setOpaque(true);
<    }
< 
<    public Component getTableCellRendererComponent(JTable table, Object color, boolean isSelected, boolean hasFocus, int row, int column) {
<       Color newColor = (Color)color;
<       this.setBackground(newColor);
<       if (this.isBordered) {
<          if (isSelected) {
<             if (this.selectedBorder == null) {
<                this.selectedBorder = BorderFactory.createMatteBorder(2, 5, 2, 5, table.getSelectionBackground());
<             }
< 
<             this.setBorder(this.selectedBorder);
<          } else {
<             if (this.unselectedBorder == null) {
<                this.unselectedBorder = BorderFactory.createMatteBorder(2, 5, 2, 5, table.getBackground());
<             }
< 
<             this.setBorder(this.unselectedBorder);
<          }
<       }
< 
<       this.setToolTipText("RGB value: " + newColor.getRed() + ", " + newColor.getGreen() + ", " + newColor.getBlue());
<       return this;
<    }
< }
---
> /*    */ import java.awt.Color;
> /*    */ import java.awt.Component;
> /*    */ import javax.swing.BorderFactory;
> /*    */ import javax.swing.JLabel;
> /*    */ import javax.swing.JTable;
> /*    */ import javax.swing.border.Border;
> /*    */ import javax.swing.table.TableCellRenderer;
> /*    */ 
> /*    */ 
> /*    */ public class ColorRenderer
> /*    */   extends JLabel
> /*    */   implements TableCellRenderer
> /*    */ {
> /*    */   private static final long serialVersionUID = 1L;
> /* 15 */   Border unselectedBorder = null;
> /* 16 */   Border selectedBorder = null;
> /*    */   boolean isBordered = true;
> /*    */   
> /*    */   public ColorRenderer(boolean isBordered) {
> /* 20 */     this.isBordered = isBordered;
> /* 21 */     setOpaque(true);
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public Component getTableCellRendererComponent(JTable table, Object color, boolean isSelected, boolean hasFocus, int row, int column) {
> /* 26 */     Color newColor = (Color)color;
> /* 27 */     setBackground(newColor);
> /* 28 */     if (this.isBordered) {
> /* 29 */       if (isSelected) {
> /* 30 */         if (this.selectedBorder == null) {
> /* 31 */           this.selectedBorder = BorderFactory.createMatteBorder(2, 5, 2, 5, table.getSelectionBackground());
> /*    */         }
> /* 33 */         setBorder(this.selectedBorder);
> /*    */       } else {
> /* 35 */         if (this.unselectedBorder == null) {
> /* 36 */           this.unselectedBorder = BorderFactory.createMatteBorder(2, 5, 2, 5, table.getBackground());
> /*    */         }
> /* 38 */         setBorder(this.unselectedBorder);
> /*    */       } 
> /*    */     }
> /*    */     
> /* 42 */     setToolTipText("RGB value: " + newColor.getRed() + ", " + newColor.getGreen() + ", " + newColor.getBlue());
> /* 43 */     return this;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/ColorRenderer.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/ComputeMSD.java jd-gui/ComputeMSD.java
1,223c1,306
< import ij.measure.ResultsTable;
< import java.io.File;
< import java.io.IOException;
< import java.util.ArrayList;
< import java.util.List;
< import math.PowerLawCurveFitModified;
< import org.apache.commons.math3.stat.regression.SimpleRegression;
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartUtils;
< import org.jfree.chart.JFreeChart;
< import org.jfree.data.xy.XYSeries;
< import org.jfree.data.xy.XYSeriesCollection;
< 
< public class ComputeMSD {
<    static List<Double> d14Values;
<    static List<Double> alphaValues;
<    static List<Double> diffValues;
<    static List<Double> msd1Values;
<    static List<Double> msd2Values;
<    static List<Double> msd3Values;
<    static List<Double> msdValues;
<    static List<Double> mssValues;
< 
<    public void Compute(List<Integer> nOfTracks, ResultsTable rtSpots) {
<       List<List<Double>> imported2SpotX = new ArrayList();
<       List<List<Double>> imported2SpotY = new ArrayList();
<       List<List<Double>> imported2SpotT = new ArrayList();
<       List<List<Double>> imported2SpotF = new ArrayList();
<       List<Integer> trackName = new ArrayList();
< 
<       int i;
<       for(i = 0; i < nOfTracks.size(); ++i) {
<          trackName.add((Integer)nOfTracks.get(i));
<          List<Double> imported1SpotX = new ArrayList();
<          List<Double> imported1SpotY = new ArrayList();
<          List<Double> imported1SpotT = new ArrayList();
<          List<Double> imported1SpotF = new ArrayList();
< 
<          for(int i = 0; i < rtSpots.size(); ++i) {
<             if (rtSpots.getStringValue(2, i).equals(String.valueOf((Integer)nOfTracks.get(i))) == Boolean.TRUE) {
<                imported1SpotX.add(Double.valueOf(rtSpots.getStringValue(4, i)));
<                imported1SpotY.add(Double.valueOf(rtSpots.getStringValue(5, i)));
<                imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(7, i)));
<                imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(8, i)));
<             }
<          }
< 
<          imported2SpotX.add(imported1SpotX);
<          imported2SpotY.add(imported1SpotY);
<          imported2SpotT.add(imported1SpotT);
<          imported2SpotF.add(imported1SpotF);
<       }
< 
<       diffValues = new ArrayList();
<       d14Values = new ArrayList();
<       alphaValues = new ArrayList();
<       msd1Values = new ArrayList();
<       msd2Values = new ArrayList();
<       msd3Values = new ArrayList();
<       msdValues = new ArrayList();
<       mssValues = new ArrayList();
< 
<       for(i = 0; i < imported2SpotX.size(); ++i) {
<          XYSeriesCollection datasetMSS = new XYSeriesCollection();
<          double frameInterval = (Double)((List)imported2SpotT.get(i)).get(2) - (Double)((List)imported2SpotT.get(i)).get(1);
<          int nMSD = ((List)imported2SpotX.get(i)).size();
<          int[] tau = new int[4];
< 
<          for(int z = 0; z < 4; ++z) {
<             tau[z] = 1 + z;
<          }
< 
<          double[] msdArray = new double[tau.length];
<          double[] timeArray = new double[tau.length];
<          double[] DArray = new double[tau.length];
<          double msd = -1.0D;
<          SimpleRegression regD14 = new SimpleRegression(true);
<          double msdhelp123 = 0.0D;
<          double msdhelp1 = 0.0D;
<          double msdhelp2 = 0.0D;
<          double msdhelp3 = 0.0D;
< 
<          for(int dt = 0; dt < tau.length; ++dt) {
<             double N = 0.0D;
<             msd = 0.0D;
< 
<             for(int j = tau[dt]; j < ((List)imported2SpotX.get(i)).size(); ++j) {
<                msd += (Math.pow((Double)((List)imported2SpotX.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotX.get(i)).get(j), 2.0D) + Math.pow((Double)((List)imported2SpotY.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotY.get(i)).get(j), 2.0D)) / Math.abs((Double)((List)imported2SpotF.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotF.get(i)).get(j));
<                ++N;
<             }
< 
<             msd /= N;
<             if (tau[dt] == 1) {
<                msdhelp1 = msd;
<             }
< 
<             if (tau[dt] == 2) {
<                msdhelp2 = msd;
<             }
< 
<             if (tau[dt] == 3) {
<                msdhelp3 = msd;
<             }
< 
<             regD14.addData((double)tau[dt] * frameInterval, msd);
<             msdArray[dt] = msd;
<             DArray[dt] = msd / ((double)(4 * tau[dt]) * frameInterval);
<             timeArray[dt] = (double)tau[dt] * frameInterval;
<          }
< 
<          double sum = 0.0D;
< 
<          for(int x = 0; x < msdArray.length; ++x) {
<             sum += msdArray[x];
<          }
< 
<          double sumD = 0.0D;
< 
<          for(int x = 0; x < DArray.length - 1; ++x) {
<             sumD += DArray[x];
<          }
< 
<          double DAvg = sumD / (double)(DArray.length - 1);
<          double slopeDiff14 = regD14.getSlope() / 4.0D;
<          double msdT = -1.0D;
<          SimpleRegression regMSD = new SimpleRegression(true);
<          int[] tauMSD = new int[nMSD - 1];
< 
<          int dt;
<          for(dt = 0; dt < nMSD - 1 - 1 + 1; ++dt) {
<             tauMSD[dt] = 1 + dt;
<          }
< 
<          for(dt = 0; dt < tauMSD.length; ++dt) {
<             double NMSD = 0.0D;
<             msdT = 0.0D;
< 
<             for(int j = tauMSD[dt]; j < ((List)imported2SpotX.get(i)).size(); ++j) {
<                msdT += (Math.pow((Double)((List)imported2SpotX.get(i)).get(j - tauMSD[dt]) - (Double)((List)imported2SpotX.get(i)).get(j), 2.0D) + Math.pow((Double)((List)imported2SpotY.get(i)).get(j - tauMSD[dt]) - (Double)((List)imported2SpotY.get(i)).get(j), 2.0D)) / Math.abs((Double)((List)imported2SpotF.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotF.get(i)).get(j));
<                ++NMSD;
<             }
< 
<             msdT /= NMSD;
<             regMSD.addData((double)tauMSD[dt] * frameInterval, msdT);
<          }
< 
<          double msdReg = regMSD.getSlope();
<          PowerLawCurveFitModified pwf = new PowerLawCurveFitModified();
<          pwf.doFit(timeArray, msdArray);
<          alphaValues.add(Math.abs(pwf.getAlpha()));
<          diffValues.add(Math.abs(DAvg));
<          d14Values.add(Math.abs(slopeDiff14));
<          msdValues.add(Math.abs(msdReg));
<          msd1Values.add(Math.abs(msdhelp1));
<          msd2Values.add(Math.abs(msdhelp2));
<          msd3Values.add(Math.abs(msdhelp3));
<          int[] tauMSS = new int[10];
< 
<          for(int z = 0; z < 10; ++z) {
<             tauMSS[z] = 1 + z;
<          }
< 
<          double[] order = new double[]{1.0D, 2.0D, 3.0D, 4.0D, 5.0D, 6.0D};
<          double[] scalingCoef = new double[order.length];
<          XYSeriesCollection dataset = new XYSeriesCollection();
< 
<          for(int o = 0; o < order.length; ++o) {
<             XYSeries series1 = new XYSeries(order[o]);
<             SimpleRegression regMSS = new SimpleRegression(true);
<             double momenthelp = 0.0D;
<             double moments = -1.0D;
< 
<             for(int dt = 0; dt < tauMSS.length; ++dt) {
<                double Nmoments = 0.0D;
<                moments = 0.0D;
< 
<                for(int j = tauMSS[dt]; j < ((List)imported2SpotX.get(i)).size(); ++j) {
<                   moments += (Math.pow(Math.abs((Double)((List)imported2SpotX.get(i)).get(j - tauMSS[dt]) - (Double)((List)imported2SpotX.get(i)).get(j)), order[o]) + Math.pow(Math.abs((Double)((List)imported2SpotY.get(i)).get(j - tauMSS[dt]) - (Double)((List)imported2SpotY.get(i)).get(j)), order[o])) / Math.abs((Double)((List)imported2SpotF.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotF.get(i)).get(j));
<                   ++Nmoments;
<                }
< 
<                if (moments != 0.0D) {
<                   moments /= Nmoments;
<                   regMSS.addData(Math.log(Math.abs((double)tauMSS[dt] * frameInterval)), Math.log(moments));
<                   series1.add(Math.log(Math.abs((double)tauMSS[dt] * frameInterval)), Math.log(moments));
<                }
<             }
< 
<             dataset.addSeries(series1);
<             scalingCoef[o] = Math.abs(regMSS.getSlope());
<          }
< 
<          JFreeChart chart1 = ChartFactory.createXYLineChart("log ,i(nt) vs. log nt for " + String.valueOf(nOfTracks.get(i)), "log nt", "log ,i(nt)", dataset);
< 
<          try {
<             ChartUtils.saveChartAsPNG(new File(SPTBatch_.directMSS.getAbsolutePath() + File.separator + "log ,i(nt) vs. log nt for " + nOfTracks.get(i)), chart1, 640, 480);
<          } catch (IOException var59) {
<             System.err.println(var59);
<          }
< 
<          SimpleRegression regScal = new SimpleRegression(true);
<          XYSeries series2 = new XYSeries((Comparable)nOfTracks.get(i));
< 
<          for(int z = 0; z < scalingCoef.length; ++z) {
<             regScal.addData((double)(z + 1), scalingCoef[z]);
<             series2.add((double)(z + 1), scalingCoef[z]);
<          }
< 
<          datasetMSS.addSeries(series2);
<          JFreeChart chart2 = ChartFactory.createScatterPlot("MSS  vs. for " + String.valueOf(nOfTracks.get(i)), "", "", datasetMSS);
< 
<          try {
<             ChartUtils.saveChartAsPNG(new File(SPTBatch_.directMSS.getAbsolutePath() + File.separator + "MSS  vs. for " + nOfTracks.get(i)), chart2, 640, 480);
<          } catch (IOException var58) {
<             System.err.println(var58);
<          }
< 
<          double sMss = Math.abs(regScal.getSlope());
<          mssValues.add(sMss);
<       }
< 
<    }
< }
---
> /*     */ import ij.measure.ResultsTable;
> /*     */ import java.io.File;
> /*     */ import java.io.IOException;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.List;
> /*     */ import math.PowerLawCurveFitModified;
> /*     */ import org.apache.commons.math3.stat.regression.SimpleRegression;
> /*     */ import org.jfree.chart.ChartFactory;
> /*     */ import org.jfree.chart.ChartUtils;
> /*     */ import org.jfree.chart.JFreeChart;
> /*     */ import org.jfree.data.xy.XYDataset;
> /*     */ import org.jfree.data.xy.XYSeries;
> /*     */ import org.jfree.data.xy.XYSeriesCollection;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class ComputeMSD
> /*     */ {
> /*     */   static List<Double> d14Values;
> /*     */   static List<Double> alphaValues;
> /*     */   static List<Double> diffValues;
> /*     */   static List<Double> msd1Values;
> /*     */   static List<Double> msd2Values;
> /*     */   static List<Double> msd3Values;
> /*     */   static List<Double> msdValues;
> /*     */   static List<Double> mssValues;
> /*     */   
> /*     */   public void Compute(List<Integer> nOfTracks, ResultsTable rtSpots) {
> /*  63 */     List<List<Double>> imported2SpotX = new ArrayList<>();
> /*  64 */     List<List<Double>> imported2SpotY = new ArrayList<>();
> /*  65 */     List<List<Double>> imported2SpotT = new ArrayList<>();
> /*  66 */     List<List<Double>> imported2SpotF = new ArrayList<>();
> /*  67 */     List<Integer> trackName = new ArrayList<>();
> /*     */     
> /*  69 */     for (int id = 0; id < nOfTracks.size(); id++) {
> /*  70 */       trackName.add(nOfTracks.get(id));
> /*  71 */       List<Double> imported1SpotX = new ArrayList<>();
> /*  72 */       List<Double> imported1SpotY = new ArrayList<>();
> /*  73 */       List<Double> imported1SpotT = new ArrayList<>();
> /*  74 */       List<Double> imported1SpotF = new ArrayList<>();
> /*     */       
> /*  76 */       for (int j = 0; j < rtSpots.size(); j++) {
> /*  77 */         if (rtSpots.getStringValue(2, j).equals(String.valueOf(((Integer)nOfTracks.get(id)).intValue())) == Boolean.TRUE.booleanValue()) {
> /*     */           
> /*  79 */           imported1SpotX.add(Double.valueOf(rtSpots.getStringValue(4, j)));
> /*  80 */           imported1SpotY.add(Double.valueOf(rtSpots.getStringValue(5, j)));
> /*  81 */           imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(7, j)));
> /*  82 */           imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(8, j)));
> /*     */         } 
> /*     */       } 
> /*     */ 
> /*     */ 
> /*     */       
> /*  88 */       imported2SpotX.add(imported1SpotX);
> /*  89 */       imported2SpotY.add(imported1SpotY);
> /*  90 */       imported2SpotT.add(imported1SpotT);
> /*  91 */       imported2SpotF.add(imported1SpotF);
> /*     */     } 
> /*     */ 
> /*     */     
> /*  95 */     diffValues = new ArrayList<>();
> /*  96 */     d14Values = new ArrayList<>();
> /*  97 */     alphaValues = new ArrayList<>();
> /*  98 */     msd1Values = new ArrayList<>();
> /*  99 */     msd2Values = new ArrayList<>();
> /* 100 */     msd3Values = new ArrayList<>();
> /* 101 */     msdValues = new ArrayList<>();
> /* 102 */     mssValues = new ArrayList<>();
> /*     */     
> /* 104 */     for (int i = 0; i < imported2SpotX.size(); i++) {
> /*     */       
> /* 106 */       XYSeriesCollection datasetMSS = new XYSeriesCollection();
> /* 107 */       double frameInterval = ((Double)((List<Double>)imported2SpotT.get(i)).get(2)).doubleValue() - ((Double)((List<Double>)imported2SpotT.get(i)).get(1)).doubleValue();
> /* 108 */       int nMSD = ((List)imported2SpotX.get(i)).size();
> /* 109 */       int[] tau = new int[4];
> /* 110 */       for (int z = 0; z < 4; z++)
> /* 111 */         tau[z] = 1 + z; 
> /* 112 */       double[] msdArray = new double[tau.length];
> /* 113 */       double[] timeArray = new double[tau.length];
> /* 114 */       double[] DArray = new double[tau.length];
> /* 115 */       double msd = -1.0D;
> /* 116 */       SimpleRegression regD14 = new SimpleRegression(true);
> /*     */       
> /* 118 */       double msdhelp123 = 0.0D;
> /* 119 */       double msdhelp1 = 0.0D;
> /* 120 */       double msdhelp2 = 0.0D;
> /* 121 */       double msdhelp3 = 0.0D;
> /* 122 */       for (int dt = 0; dt < tau.length; dt++) {
> /* 123 */         double N = 0.0D;
> /* 124 */         msd = 0.0D;
> /*     */         
> /* 126 */         for (int i2 = tau[dt]; i2 < ((List)imported2SpotX.get(i)).size(); i2++) {
> /* 127 */           msd += (
> /* 128 */             Math.pow(((Double)((List<Double>)imported2SpotX.get(i)).get(i2 - tau[dt])).doubleValue() - (
> /* 129 */               (Double)((List<Double>)imported2SpotX.get(i)).get(i2)).doubleValue(), 2.0D) + 
> /* 130 */             Math.pow(((Double)((List<Double>)imported2SpotY.get(i)).get(i2 - tau[dt])).doubleValue() - (
> /* 131 */               (Double)((List<Double>)imported2SpotY.get(i)).get(i2)).doubleValue(), 2.0D)) / 
> /* 132 */             Math.abs(((Double)((List<Double>)imported2SpotF.get(i)).get(i2 - tau[dt])).doubleValue() - (
> /* 133 */               (Double)((List<Double>)imported2SpotF.get(i)).get(i2)).doubleValue());
> /*     */           
> /* 135 */           N++;
> /*     */         } 
> /*     */ 
> /*     */         
> /* 139 */         msd /= N;
> /* 140 */         msdhelp123 = msd;
> /* 141 */         if (tau[dt] == 1)
> /* 142 */           msdhelp1 = msd; 
> /* 143 */         if (tau[dt] == 2)
> /* 144 */           msdhelp2 = msd; 
> /* 145 */         if (tau[dt] == 3)
> /* 146 */           msdhelp3 = msd; 
> /* 147 */         regD14.addData(tau[dt] * frameInterval, msdhelp123);
> /* 148 */         msdArray[dt] = msd;
> /* 149 */         DArray[dt] = msd / (4 * tau[dt]) * frameInterval;
> /* 150 */         timeArray[dt] = tau[dt] * frameInterval;
> /*     */       } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */       
> /* 159 */       double sum = 0.0D;
> /* 160 */       for (int x = 0; x < msdArray.length; x++) {
> /* 161 */         sum += msdArray[x];
> /*     */       }
> /* 163 */       double sumD = 0.0D;
> /* 164 */       for (int j = 0; j < DArray.length - 1; j++)
> /* 165 */         sumD += DArray[j]; 
> /* 166 */       double DAvg = sumD / (DArray.length - 1);
> /* 167 */       double slopeDiff14 = regD14.getSlope() / 4.0D;
> /*     */ 
> /*     */       
> /* 170 */       double msdT = -1.0D;
> /* 171 */       SimpleRegression regMSD = new SimpleRegression(true);
> /* 172 */       int[] tauMSD = new int[nMSD - 1];
> /* 173 */       for (int m = 0; m < nMSD - 1 - 1 + 1; m++)
> /* 174 */         tauMSD[m] = 1 + m; 
> /* 175 */       for (int k = 0; k < tauMSD.length; k++) {
> /* 176 */         double NMSD = 0.0D;
> /* 177 */         msdT = 0.0D;
> /*     */         
> /* 179 */         for (int i2 = tauMSD[k]; i2 < ((List)imported2SpotX.get(i)).size(); i2++) {
> /* 180 */           msdT += (
> /* 181 */             Math.pow(((Double)((List<Double>)imported2SpotX.get(i)).get(i2 - tauMSD[k])).doubleValue() - (
> /* 182 */               (Double)((List<Double>)imported2SpotX.get(i)).get(i2)).doubleValue(), 2.0D) + 
> /* 183 */             Math.pow(((Double)((List<Double>)imported2SpotY.get(i)).get(i2 - tauMSD[k])).doubleValue() - (
> /* 184 */               (Double)((List<Double>)imported2SpotY.get(i)).get(i2)).doubleValue(), 2.0D)) / 
> /* 185 */             Math.abs(((Double)((List<Double>)imported2SpotF.get(i)).get(i2 - tau[k])).doubleValue() - (
> /* 186 */               (Double)((List<Double>)imported2SpotF.get(i)).get(i2)).doubleValue());
> /*     */           
> /* 188 */           NMSD++;
> /*     */         } 
> /*     */ 
> /*     */         
> /* 192 */         msdT /= NMSD;
> /* 193 */         regMSD.addData(tauMSD[k] * frameInterval, msdT);
> /*     */       } 
> /* 195 */       double msdReg = regMSD.getSlope();
> /*     */ 
> /*     */       
> /* 198 */       PowerLawCurveFitModified pwf = new PowerLawCurveFitModified();
> /* 199 */       pwf.doFit(timeArray, msdArray);
> /*     */ 
> /*     */       
> /* 202 */       alphaValues.add(Double.valueOf(Math.abs(pwf.getAlpha())));
> /* 203 */       diffValues.add(Double.valueOf(Math.abs(DAvg)));
> /* 204 */       d14Values.add(Double.valueOf(Math.abs(slopeDiff14)));
> /* 205 */       msdValues.add(Double.valueOf(Math.abs(msdReg)));
> /* 206 */       msd1Values.add(Double.valueOf(Math.abs(msdhelp1)));
> /* 207 */       msd2Values.add(Double.valueOf(Math.abs(msdhelp2)));
> /* 208 */       msd3Values.add(Double.valueOf(Math.abs(msdhelp3)));
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */       
> /* 213 */       int[] tauMSS = new int[10];
> /* 214 */       for (int n = 0; n < 10; n++) {
> /* 215 */         tauMSS[n] = 1 + n;
> /*     */       }
> /* 217 */       double[] order = { 1.0D, 2.0D, 3.0D, 4.0D, 5.0D, 6.0D };
> /* 218 */       double[] scalingCoef = new double[order.length];
> /* 219 */       XYSeriesCollection dataset = new XYSeriesCollection();
> /* 220 */       for (int o = 0; o < order.length; o++) {
> /* 221 */         XYSeries series1 = new XYSeries(Double.valueOf(order[o]));
> /* 222 */         SimpleRegression regMSS = new SimpleRegression(true);
> /* 223 */         double momenthelp = 0.0D;
> /* 224 */         double moments = -1.0D;
> /* 225 */         for (int i2 = 0; i2 < tauMSS.length; i2++) {
> /*     */           
> /* 227 */           double Nmoments = 0.0D;
> /* 228 */           moments = 0.0D;
> /*     */           
> /* 230 */           for (int i3 = tauMSS[i2]; i3 < ((List)imported2SpotX.get(i)).size(); i3++) {
> /*     */             
> /* 232 */             moments += (
> /* 233 */               Math.pow(Math.abs(((Double)((List<Double>)imported2SpotX.get(i)).get(i3 - tauMSS[i2])).doubleValue() - (
> /* 234 */                   (Double)((List<Double>)imported2SpotX.get(i)).get(i3)).doubleValue()), order[o]) + 
> /* 235 */               Math.pow(Math.abs(((Double)((List<Double>)imported2SpotY.get(i)).get(i3 - tauMSS[i2])).doubleValue() - (
> /* 236 */                   (Double)((List<Double>)imported2SpotY.get(i)).get(i3)).doubleValue()), order[o])) / 
> /* 237 */               Math.abs(((Double)((List<Double>)imported2SpotF.get(i)).get(i3 - tau[i2])).doubleValue() - (
> /* 238 */                 (Double)((List<Double>)imported2SpotF.get(i)).get(i3)).doubleValue());
> /*     */             
> /* 240 */             Nmoments++;
> /*     */           } 
> /*     */ 
> /*     */ 
> /*     */           
> /* 245 */           if (moments != 0.0D) {
> /* 246 */             moments /= Nmoments;
> /* 247 */             momenthelp = moments;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */             
> /* 252 */             regMSS.addData(Math.log(Math.abs(tauMSS[i2] * frameInterval)), Math.log(momenthelp));
> /* 253 */             series1.add(Math.log(Math.abs(tauMSS[i2] * frameInterval)), Math.log(momenthelp));
> /*     */           } 
> /*     */         } 
> /*     */ 
> /*     */ 
> /*     */         
> /* 259 */         dataset.addSeries(series1);
> /*     */ 
> /*     */         
> /* 262 */         scalingCoef[o] = Math.abs(regMSS.getSlope());
> /*     */       } 
> /*     */ 
> /*     */       
> /* 266 */       JFreeChart chart1 = ChartFactory.createXYLineChart(
> /* 267 */           "log ,i(nt) vs. log nt for " + String.valueOf(nOfTracks.get(i)), "log nt", "log ,i(nt)", 
> /* 268 */           (XYDataset)dataset);
> /*     */       
> /*     */       try {
> /* 271 */         ChartUtils.saveChartAsPNG(
> /* 272 */             new File(String.valueOf(SPTBatch_.directMSS.getAbsolutePath()) + File.separator + 
> /* 273 */               "log ,i(nt) vs. log nt for " + String.valueOf(nOfTracks.get(i))), 
> /* 274 */             chart1, 640, 480);
> /* 275 */       } catch (IOException ex) {
> /* 276 */         System.err.println(ex);
> /*     */       } 
> /* 278 */       SimpleRegression regScal = new SimpleRegression(true);
> /* 279 */       XYSeries series2 = new XYSeries(nOfTracks.get(i));
> /* 280 */       for (int i1 = 0; i1 < scalingCoef.length; i1++) {
> /*     */         
> /* 282 */         regScal.addData((i1 + 1), scalingCoef[i1]);
> /* 283 */         series2.add((i1 + 1), scalingCoef[i1]);
> /*     */       } 
> /*     */       
> /* 286 */       datasetMSS.addSeries(series2);
> /* 287 */       JFreeChart chart2 = ChartFactory.createScatterPlot("MSS  vs. for " + String.valueOf(nOfTracks.get(i)), 
> /* 288 */           "", "", (XYDataset)datasetMSS);
> /*     */       try {
> /* 290 */         ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directMSS.getAbsolutePath()) + File.separator + 
> /* 291 */               "MSS  vs. for " + String.valueOf(nOfTracks.get(i))), chart2, 640, 480);
> /* 292 */       } catch (IOException ex) {
> /* 293 */         System.err.println(ex);
> /*     */       } 
> /*     */       
> /* 296 */       double sMss = Math.abs(regScal.getSlope());
> /* 297 */       mssValues.add(Double.valueOf(sMss));
> /*     */     } 
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/ComputeMSD.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/Dialog4BgSub0.java jd-gui/Dialog4BgSub0.java
1,146c1,130
< import ij.IJ;
< import ij.gui.GUI;
< import ij.gui.MultiLineLabel;
< import ij.gui.Roi;
< import ij.plugin.frame.RoiManager;
< import java.awt.Font;
< import java.awt.GridBagConstraints;
< import java.awt.GridBagLayout;
< import java.awt.Insets;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.KeyEvent;
< import java.awt.event.KeyListener;
< import javax.swing.JButton;
< import javax.swing.JDialog;
< 
< public class Dialog4BgSub0 extends JDialog implements ActionListener, KeyListener {
<    public JButton button;
<    public MultiLineLabel label;
<    protected static int xloc = -1;
<    protected static int yloc = -1;
<    private boolean escPressed;
< 
<    public Dialog4BgSub0(String title, String text) {
<       super(IJ.getInstance(), title, false);
<       IJ.protectStatusBar(false);
<       if (text != null && text.startsWith("IJ: ")) {
<          text = text.substring(4);
<       }
< 
<       this.label = new MultiLineLabel(text, 175);
<       if (!IJ.isLinux()) {
<          this.label.setFont(new Font("SansSerif", 0, 14));
<       }
< 
<       if (IJ.isMacOSX()) {
<          RoiManager rm = RoiManager.getInstance();
<          if (rm != null) {
<             rm.runCommand("enable interrupts");
<          }
<       }
< 
<       GridBagLayout gridbag = new GridBagLayout();
<       GridBagConstraints c = new GridBagConstraints();
<       this.setLayout(gridbag);
<       c.insets = new Insets(6, 6, 0, 6);
<       c.gridx = 0;
<       c.gridy = 0;
<       c.anchor = 17;
<       this.add(this.label, c);
<       this.button = new JButton("  OK  ");
<       this.button.setBounds(50, 100, 95, 30);
<       this.button.setToolTipText("Click this button to process next image.");
<       this.button.addActionListener(this);
<       this.button.addKeyListener(this);
<       c.insets = new Insets(2, 6, 6, 6);
<       c.gridx = 0;
<       c.gridy = 2;
<       c.anchor = 13;
<       this.add(this.button, c);
<       this.setResizable(false);
<       this.addKeyListener(this);
<       GUI.scale(this);
<       this.pack();
<       if (xloc == -1) {
<          GUI.centerOnImageJScreen(this);
<       } else {
<          this.setLocation(xloc, yloc);
<       }
< 
<       this.setAlwaysOnTop(true);
<    }
< 
<    public Dialog4BgSub0(String text) {
<       this("Action Required", text);
<    }
< 
<    public void show() {
<       super.show();
<       synchronized(this) {
<          try {
<             this.wait();
<          } catch (InterruptedException var3) {
<             return;
<          }
< 
<       }
<    }
< 
<    public void close() {
<       synchronized(this) {
<          this.notify();
<       }
< 
<       xloc = this.getLocation().x;
<       yloc = this.getLocation().y;
<       this.dispose();
<    }
< 
<    public void actionPerformed(ActionEvent e) {
<       SPTBatch_.impMaxProject.hide();
<       int[] indexes = SPTBatch_.roiManager.getIndexes();
<       SPTBatch_.roiManager.setSelectedIndexes(indexes);
<       SPTBatch_.roiManager.runCommand(SPTBatch_.impMaxProject, "Combine");
<       Roi roiToMeasure = SPTBatch_.impMaxProject.getRoi();
<       SPTBatch_.roiManager.close();
< 
<       for(int i = 0; i < SPTBatch_.slices.length; ++i) {
<          SPTBatch_.slices[i].setRoi(roiToMeasure);
<          SPTBatch_.slicesIntensitySpot[i] = SPTBatch_.slices[i].getStatistics().mean;
<       }
< 
<       this.close();
<    }
< 
<    public void keyPressed(KeyEvent e) {
<       int keyCode = e.getKeyCode();
<       IJ.setKeyDown(keyCode);
<       if (keyCode == 10 || keyCode == 27) {
<          this.escPressed = keyCode == 27;
<          this.close();
<       }
< 
<    }
< 
<    public boolean escPressed() {
<       return this.escPressed;
<    }
< 
<    public void keyReleased(KeyEvent e) {
<       int keyCode = e.getKeyCode();
<       IJ.setKeyUp(keyCode);
<    }
< 
<    public void keyTyped(KeyEvent e) {
<    }
< 
<    public JButton getButton() {
<       return this.button;
<    }
< 
<    public static void setNextLocation(int x, int y) {
<       xloc = x;
<       yloc = y;
<    }
< }
---
> /*     */ import ij.IJ;
> /*     */ import ij.gui.GUI;
> /*     */ import ij.gui.MultiLineLabel;
> /*     */ import ij.gui.Roi;
> /*     */ import ij.plugin.frame.RoiManager;
> /*     */ import java.awt.Component;
> /*     */ import java.awt.Font;
> /*     */ import java.awt.GridBagConstraints;
> /*     */ import java.awt.GridBagLayout;
> /*     */ import java.awt.Insets;
> /*     */ import java.awt.event.ActionEvent;
> /*     */ import java.awt.event.ActionListener;
> /*     */ import java.awt.event.KeyEvent;
> /*     */ import java.awt.event.KeyListener;
> /*     */ import javax.swing.JButton;
> /*     */ import javax.swing.JDialog;
> /*     */ 
> /*     */ public class Dialog4BgSub0 extends JDialog implements ActionListener, KeyListener {
> /*     */   public JButton button;
> /*  20 */   protected static int xloc = -1; public MultiLineLabel label; protected static int yloc = -1;
> /*     */   private boolean escPressed;
> /*     */   
> /*     */   public Dialog4BgSub0(String title, String text) {
> /*  24 */     super((Frame)IJ.getInstance(), title, false);
> /*  25 */     IJ.protectStatusBar(false);
> /*  26 */     if (text != null && text.startsWith("IJ: "))
> /*  27 */       text = text.substring(4); 
> /*  28 */     this.label = new MultiLineLabel(text, 175);
> /*  29 */     if (!IJ.isLinux()) this.label.setFont(new Font("SansSerif", 0, 14)); 
> /*  30 */     if (IJ.isMacOSX()) {
> /*  31 */       RoiManager rm = RoiManager.getInstance();
> /*  32 */       if (rm != null) rm.runCommand("enable interrupts"); 
> /*     */     } 
> /*  34 */     GridBagLayout gridbag = new GridBagLayout();
> /*  35 */     GridBagConstraints c = new GridBagConstraints();
> /*  36 */     setLayout(gridbag);
> /*  37 */     c.insets = new Insets(6, 6, 0, 6);
> /*  38 */     c.gridx = 0; c.gridy = 0; c.anchor = 17;
> /*  39 */     add((Component)this.label, c);
> /*  40 */     this.button = new JButton("  OK  ");
> /*  41 */     this.button.setBounds(50, 100, 95, 30);
> /*  42 */     this.button.setToolTipText("Click this button to process next image.");
> /*  43 */     this.button.addActionListener(this);
> /*  44 */     this.button.addKeyListener(this);
> /*  45 */     c.insets = new Insets(2, 6, 6, 6);
> /*  46 */     c.gridx = 0; c.gridy = 2; c.anchor = 13;
> /*  47 */     add(this.button, c);
> /*  48 */     setResizable(false);
> /*  49 */     addKeyListener(this);
> /*  50 */     GUI.scale(this);
> /*  51 */     pack();
> /*  52 */     if (xloc == -1) {
> /*  53 */       GUI.centerOnImageJScreen(this);
> /*     */     } else {
> /*  55 */       setLocation(xloc, yloc);
> /*  56 */     }  setAlwaysOnTop(true);
> /*     */   }
> /*     */   
> /*     */   public Dialog4BgSub0(String text) {
> /*  60 */     this("Action Required", text);
> /*     */   }
> /*     */   
> /*     */   public void show() {
> /*  64 */     super.show();
> /*  65 */     synchronized (this) { try {
> /*  66 */         wait();
> /*  67 */       } catch (InterruptedException e) {
> /*     */         return;
> /*     */       }  }
> /*     */   
> /*     */   } public void close() {
> /*  72 */     synchronized (this) { notify(); }
> /*  73 */      xloc = (getLocation()).x;
> /*  74 */     yloc = (getLocation()).y;
> /*  75 */     dispose();
> /*     */   }
> /*     */   
> /*     */   public void actionPerformed(ActionEvent e) {
> /*  79 */     SPTBatch_.impMaxProject.hide();
> /*     */     
> /*  81 */     int[] indexes = SPTBatch_.roiManager.getIndexes();
> /*  82 */     SPTBatch_.roiManager.setSelectedIndexes(indexes);
> /*  83 */     SPTBatch_.roiManager.runCommand(SPTBatch_.impMaxProject, "Combine");
> /*  84 */     Roi roiToMeasure = SPTBatch_.impMaxProject.getRoi();
> /*  85 */     SPTBatch_.roiManager.close();
> /*  86 */     for (int i = 0; i < SPTBatch_.slices.length; i++) {
> /*  87 */       SPTBatch_.slices[i].setRoi(roiToMeasure);
> /*  88 */       SPTBatch_.slicesIntensitySpot[i] = (SPTBatch_.slices[i].getStatistics()).mean;
> /*     */     } 
> /*     */     
> /*  91 */     close();
> /*     */   }
> /*     */   
> /*     */   public void keyPressed(KeyEvent e) {
> /*  95 */     int keyCode = e.getKeyCode();
> /*  96 */     IJ.setKeyDown(keyCode);
> /*  97 */     if (keyCode == 10 || keyCode == 27) {
> /*  98 */       this.escPressed = (keyCode == 27);
> /*  99 */       close();
> /*     */     } 
> /*     */   }
> /*     */   
> /*     */   public boolean escPressed() {
> /* 104 */     return this.escPressed;
> /*     */   }
> /*     */   
> /*     */   public void keyReleased(KeyEvent e) {
> /* 108 */     int keyCode = e.getKeyCode();
> /* 109 */     IJ.setKeyUp(keyCode);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void keyTyped(KeyEvent e) {}
> /*     */   
> /*     */   public JButton getButton() {
> /* 116 */     return this.button;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public static void setNextLocation(int x, int y) {
> /* 121 */     xloc = x;
> /* 122 */     yloc = y;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/Dialog4BgSub0.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/DiffusionCoefficientEstimator/AbstractDiffusionCoefficientEstimatorModified.java jd-gui/DiffusionCoefficientEstimator/AbstractDiffusionCoefficientEstimatorModified.java
6c6
<    double[] getDiffusionCoefficient(TrajectoryModified var1, double var2);
---
>   double[] getDiffusionCoefficient(TrajectoryModified paramTrajectoryModified, double paramDouble);
7a8,13
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/DiffusionCoefficientEstimator/AbstractDiffusionCoefficientEstimatorModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/DiffusionCoefficientEstimator/CovarianceDiffusionCoefficientEstimatorModified.java jd-gui/DiffusionCoefficientEstimator/CovarianceDiffusionCoefficientEstimatorModified.java
1,104c1,144
< package DiffusionCoefficientEstimator;
< 
< import features.AbstractTrajectoryFeatureModified;
< import traJ.TrajectoryModified;
< import traJ.TrajectoryValidIndexTimelagIteratorModified;
< import vecmath.Point3dModified;
< 
< public class CovarianceDiffusionCoefficientEstimatorModified extends AbstractTrajectoryFeatureModified implements AbstractDiffusionCoefficientEstimatorModified {
<    private TrajectoryModified t;
<    private double fps;
< 
<    public CovarianceDiffusionCoefficientEstimatorModified() {
<    }
< 
<    public CovarianceDiffusionCoefficientEstimatorModified(TrajectoryModified t, double fps) {
<       this.t = t;
<       this.fps = fps;
<    }
< 
<    private double getDistanceProductX(TrajectoryModified t, int n, int m) {
<       double xn = ((Point3dModified)t.get(n + 1)).x - ((Point3dModified)t.get(n)).x;
<       double xm = ((Point3dModified)t.get(m + 1)).x - ((Point3dModified)t.get(m)).x;
<       return xn * xm;
<    }
< 
<    private double getDistanceProductY(TrajectoryModified t, int n, int m) {
<       double xn = ((Point3dModified)t.get(n + 1)).y - ((Point3dModified)t.get(n)).y;
<       double xm = ((Point3dModified)t.get(m + 1)).y - ((Point3dModified)t.get(m)).y;
<       return xn * xm;
<    }
< 
<    private double getDistanceProductZ(TrajectoryModified t, int n, int m) {
<       double xn = ((Point3dModified)t.get(n + 1)).z - ((Point3dModified)t.get(n)).z;
<       double xm = ((Point3dModified)t.get(m + 1)).z - ((Point3dModified)t.get(m)).z;
<       return xn * xm;
<    }
< 
<    public double[] getDiffusionCoefficient(TrajectoryModified t, double fps) {
<       double[] cov = this.getCovData(t, fps, 0.0D);
<       return cov;
<    }
< 
<    private double[] getCovData(TrajectoryModified track, double fps, double R) {
<       double sumX = 0.0D;
<       double sumX2 = 0.0D;
<       double sumY = 0.0D;
<       double sumY2 = 0.0D;
<       double sumZ = 0.0D;
<       double sumZ2 = 0.0D;
<       int N = 0;
<       int M = 0;
<       TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(track, 1);
< 
<       while(it.hasNext()) {
<          int i = it.next();
<          sumX += this.getDistanceProductX(track, i, i);
<          sumY += this.getDistanceProductY(track, i, i);
<          sumZ += this.getDistanceProductZ(track, i, i);
<          ++N;
<          if (i + 2 < track.size() && track.get(i + 2) != null) {
<             sumX2 += this.getDistanceProductX(track, i, i + 1);
<             sumY2 += this.getDistanceProductY(track, i, i + 1);
<             sumZ2 += this.getDistanceProductZ(track, i, i + 1);
<             ++M;
<          }
<       }
< 
<       double msdX = sumX / (double)N;
<       double msdY = sumY / (double)N;
<       double msdZ = sumZ / (double)N;
<       double covX = sumX2 / (double)M;
<       double covY = sumY2 / (double)M;
<       double covZ = sumZ2 / (double)M;
<       double termXA = msdX / 2.0D * fps;
<       double termXB = covX * fps;
<       double termYA = msdY / 2.0D * fps;
<       double termYB = covY * fps;
<       double termZA = msdZ / 2.0D * fps;
<       double termZB = covZ * fps;
<       double DX = termXA + termXB;
<       double DY = termYA + termYB;
<       double DZ = termZA + termZB;
<       double D = (DX + DY + DZ) / (double)track.getDimension();
<       double[] data = new double[]{D, Math.sqrt(Math.abs(covX)), Math.sqrt(Math.abs(covY)), Math.sqrt(Math.abs(covZ))};
<       return data;
<    }
< 
<    public double[] evaluate() {
<       this.result = this.getDiffusionCoefficient(this.t, this.fps);
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Diffusion coefficient (Covariance)";
<    }
< 
<    public String getShortName() {
<       return "DC-COV";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<    }
< }
---
> /*     */ package DiffusionCoefficientEstimator;
> /*     */ 
> /*     */ import features.AbstractTrajectoryFeatureModified;
> /*     */ import traJ.TrajectoryModified;
> /*     */ import traJ.TrajectoryValidIndexTimelagIteratorModified;
> /*     */ import vecmath.Point3dModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class CovarianceDiffusionCoefficientEstimatorModified
> /*     */   extends AbstractTrajectoryFeatureModified
> /*     */   implements AbstractDiffusionCoefficientEstimatorModified
> /*     */ {
> /*     */   private TrajectoryModified t;
> /*     */   private double fps;
> /*     */   
> /*     */   public CovarianceDiffusionCoefficientEstimatorModified() {}
> /*     */   
> /*     */   public CovarianceDiffusionCoefficientEstimatorModified(TrajectoryModified t, double fps) {
> /*  24 */     this.t = t;
> /*  25 */     this.fps = fps;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   private double getDistanceProductX(TrajectoryModified t, int n, int m) {
> /*  30 */     double xn = ((Point3dModified)t.get(n + 1)).x - ((Point3dModified)t.get(n)).x;
> /*  31 */     double xm = ((Point3dModified)t.get(m + 1)).x - ((Point3dModified)t.get(m)).x;
> /*     */     
> /*  33 */     return xn * xm;
> /*     */   }
> /*     */   
> /*     */   private double getDistanceProductY(TrajectoryModified t, int n, int m) {
> /*  37 */     double xn = ((Point3dModified)t.get(n + 1)).y - ((Point3dModified)t.get(n)).y;
> /*  38 */     double xm = ((Point3dModified)t.get(m + 1)).y - ((Point3dModified)t.get(m)).y;
> /*  39 */     return xn * xm;
> /*     */   }
> /*     */   
> /*     */   private double getDistanceProductZ(TrajectoryModified t, int n, int m) {
> /*  43 */     double xn = ((Point3dModified)t.get(n + 1)).z - ((Point3dModified)t.get(n)).z;
> /*  44 */     double xm = ((Point3dModified)t.get(m + 1)).z - ((Point3dModified)t.get(m)).z;
> /*  45 */     return xn * xm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] getDiffusionCoefficient(TrajectoryModified t, double fps) {
> /*  54 */     double[] cov = getCovData(t, fps, 0.0D);
> /*  55 */     return cov;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private double[] getCovData(TrajectoryModified track, double fps, double R) {
> /*  61 */     double sumX = 0.0D;
> /*  62 */     double sumX2 = 0.0D;
> /*  63 */     double sumY = 0.0D;
> /*  64 */     double sumY2 = 0.0D;
> /*  65 */     double sumZ = 0.0D;
> /*  66 */     double sumZ2 = 0.0D;
> /*  67 */     int N = 0;
> /*  68 */     int M = 0;
> /*  69 */     TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(track, 1);
> /*  70 */     while (it.hasNext()) {
> /*  71 */       int i = it.next().intValue();
> /*  72 */       sumX += getDistanceProductX(track, i, i);
> /*  73 */       sumY += getDistanceProductY(track, i, i);
> /*  74 */       sumZ += getDistanceProductZ(track, i, i);
> /*  75 */       N++;
> /*  76 */       if (i + 2 < track.size() && track.get(i + 2) != null) {
> /*  77 */         sumX2 += getDistanceProductX(track, i, i + 1);
> /*  78 */         sumY2 += getDistanceProductY(track, i, i + 1);
> /*  79 */         sumZ2 += getDistanceProductZ(track, i, i + 1);
> /*  80 */         M++;
> /*     */       } 
> /*     */     } 
> /*     */     
> /*  84 */     double msdX = sumX / N;
> /*     */     
> /*  86 */     double msdY = sumY / N;
> /*  87 */     double msdZ = sumZ / N;
> /*     */     
> /*  89 */     double covX = sumX2 / M;
> /*  90 */     double covY = sumY2 / M;
> /*  91 */     double covZ = sumZ2 / M;
> /*     */     
> /*  93 */     double termXA = msdX / 2.0D * fps;
> /*  94 */     double termXB = covX * fps;
> /*  95 */     double termYA = msdY / 2.0D * fps;
> /*  96 */     double termYB = covY * fps;
> /*  97 */     double termZA = msdZ / 2.0D * fps;
> /*  98 */     double termZB = covZ * fps;
> /*     */     
> /* 100 */     double DX = termXA + termXB;
> /* 101 */     double DY = termYA + termYB;
> /* 102 */     double DZ = termZA + termZB;
> /*     */     
> /* 104 */     double D = (DX + DY + DZ) / track.getDimension();
> /*     */ 
> /*     */     
> /* 107 */     double[] data = new double[4];
> /* 108 */     data[0] = D;
> /* 109 */     data[1] = Math.sqrt(Math.abs(covX));
> /* 110 */     data[2] = Math.sqrt(Math.abs(covY));
> /* 111 */     data[3] = Math.sqrt(Math.abs(covZ));
> /*     */     
> /* 113 */     return data;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double[] evaluate() {
> /* 118 */     this.result = getDiffusionCoefficient(this.t, this.fps);
> /* 119 */     return this.result;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String getName() {
> /* 125 */     return "Diffusion coefficient (Covariance)";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String getShortName() {
> /* 131 */     return "DC-COV";
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void setTrajectory(TrajectoryModified t) {
> /* 136 */     this.t = t;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/DiffusionCoefficientEstimator/CovarianceDiffusionCoefficientEstimatorModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/DiffusionCoefficientEstimator/RegressionDiffusionCoefficientEstimatorModified.java jd-gui/DiffusionCoefficientEstimator/RegressionDiffusionCoefficientEstimatorModified.java
1,94c1,111
< package DiffusionCoefficientEstimator;
< 
< import features.AbstractMeanSquaredDisplacmentEvaluatorModified;
< import features.AbstractTrajectoryFeatureModified;
< import features.MeanSquaredDisplacmentFeatureModified;
< import java.util.ArrayList;
< import math.StraightLineFitModified;
< import org.apache.commons.lang3.ArrayUtils;
< import traJ.TrajectoryModified;
< 
< public class RegressionDiffusionCoefficientEstimatorModified extends AbstractTrajectoryFeatureModified implements AbstractDiffusionCoefficientEstimatorModified {
<    private int lagMin;
<    private int lagMax;
<    private AbstractMeanSquaredDisplacmentEvaluatorModified msdevaluator;
<    private TrajectoryModified t;
<    private double fps;
< 
<    public RegressionDiffusionCoefficientEstimatorModified(int lagMin, int lagMax) {
<       this.lagMin = lagMin;
<       this.lagMax = lagMax;
<       this.msdevaluator = new MeanSquaredDisplacmentFeatureModified((TrajectoryModified)null, lagMin);
<    }
< 
<    public RegressionDiffusionCoefficientEstimatorModified(TrajectoryModified t, double fps, int lagMin, int lagMax) {
<       this.lagMin = lagMin;
<       this.lagMax = lagMax;
<       this.msdevaluator = new MeanSquaredDisplacmentFeatureModified((TrajectoryModified)null, lagMin);
<       this.t = t;
<       this.fps = fps;
<    }
< 
<    public double[] getDiffusionCoefficient(TrajectoryModified t, double fps) {
<       if (t.size() == 1) {
<          return null;
<       } else {
<          ArrayList<Double> xDataList = new ArrayList();
<          ArrayList<Double> yDataList = new ArrayList();
<          double msdhelp = 0.0D;
<          if (this.lagMin == this.lagMax) {
<             xDataList.add(0.0D);
<             yDataList.add(0.0D);
<          }
< 
<          this.msdevaluator.setTrajectory(t);
<          this.msdevaluator.setTimelag(this.lagMin);
< 
<          double[] ydata;
<          for(int i = this.lagMin; i < this.lagMax + 1; ++i) {
<             this.msdevaluator.setTimelag(i);
<             ydata = this.msdevaluator.evaluate();
<             msdhelp = ydata[0];
<             int N = (int)ydata[2];
< 
<             for(int j = 0; j < N; ++j) {
<                xDataList.add((double)i * 1.0D / fps);
<                yDataList.add(msdhelp);
<             }
<          }
< 
<          double[] xdata = ArrayUtils.toPrimitive((Double[])xDataList.toArray(new Double[0]));
<          ydata = ArrayUtils.toPrimitive((Double[])yDataList.toArray(new Double[0]));
<          StraightLineFitModified fdf = new StraightLineFitModified();
<          fdf.doFit(xdata, ydata);
<          this.result = new double[]{fdf.getB() / (2.0D * (double)t.getDimension()), fdf.getB() * 2.0D * (double)t.getDimension(), fdf.getA(), fdf.getGoodness()};
<          return this.result;
<       }
<    }
< 
<    public void setTimelags(int lagMin, int lagMax) {
<       this.lagMin = lagMin;
<       this.lagMax = lagMax;
<    }
< 
<    public void setMeanSquaredDisplacementEvaluator(AbstractMeanSquaredDisplacmentEvaluatorModified msdeval) {
<       this.msdevaluator = msdeval;
<    }
< 
<    public double[] evaluate() {
<       this.result = this.getDiffusionCoefficient(this.t, this.fps);
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Diffusion coefficient (Regression)";
<    }
< 
<    public String getShortName() {
<       return "DC-REG";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<    }
< }
---
> /*     */ package DiffusionCoefficientEstimator;
> /*     */ 
> /*     */ import features.AbstractMeanSquaredDisplacmentEvaluatorModified;
> /*     */ import features.AbstractTrajectoryFeatureModified;
> /*     */ import features.MeanSquaredDisplacmentFeatureModified;
> /*     */ import java.util.ArrayList;
> /*     */ import math.StraightLineFitModified;
> /*     */ import org.apache.commons.lang3.ArrayUtils;
> /*     */ import traJ.TrajectoryModified;
> /*     */ 
> /*     */ 
> /*     */ public class RegressionDiffusionCoefficientEstimatorModified
> /*     */   extends AbstractTrajectoryFeatureModified
> /*     */   implements AbstractDiffusionCoefficientEstimatorModified
> /*     */ {
> /*     */   private int lagMin;
> /*     */   private int lagMax;
> /*     */   private AbstractMeanSquaredDisplacmentEvaluatorModified msdevaluator;
> /*     */   private TrajectoryModified t;
> /*     */   private double fps;
> /*     */   
> /*     */   public RegressionDiffusionCoefficientEstimatorModified(int lagMin, int lagMax) {
> /*  23 */     this.lagMin = lagMin;
> /*  24 */     this.lagMax = lagMax;
> /*  25 */     this.msdevaluator = (AbstractMeanSquaredDisplacmentEvaluatorModified)new MeanSquaredDisplacmentFeatureModified(null, lagMin);
> /*     */   }
> /*     */   
> /*     */   public RegressionDiffusionCoefficientEstimatorModified(TrajectoryModified t, double fps, int lagMin, int lagMax) {
> /*  29 */     this.lagMin = lagMin;
> /*  30 */     this.lagMax = lagMax;
> /*  31 */     this.msdevaluator = (AbstractMeanSquaredDisplacmentEvaluatorModified)new MeanSquaredDisplacmentFeatureModified(null, lagMin);
> /*  32 */     this.t = t;
> /*  33 */     this.fps = fps;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] getDiffusionCoefficient(TrajectoryModified t, double fps) {
> /*  41 */     if (t.size() == 1) {
> /*  42 */       return null;
> /*     */     }
> /*  44 */     ArrayList<Double> xDataList = new ArrayList<>();
> /*  45 */     ArrayList<Double> yDataList = new ArrayList<>();
> /*  46 */     double msdhelp = 0.0D;
> /*  47 */     if (this.lagMin == this.lagMax) {
> /*  48 */       xDataList.add(Double.valueOf(0.0D));
> /*  49 */       yDataList.add(Double.valueOf(0.0D));
> /*     */     } 
> /*  51 */     this.msdevaluator.setTrajectory(t);
> /*  52 */     this.msdevaluator.setTimelag(this.lagMin);
> /*     */     
> /*  54 */     for (int i = this.lagMin; i < this.lagMax + 1; i++) {
> /*  55 */       this.msdevaluator.setTimelag(i);
> /*  56 */       double[] res = this.msdevaluator.evaluate();
> /*  57 */       msdhelp = res[0];
> /*  58 */       int N = (int)res[2];
> /*  59 */       for (int j = 0; j < N; j++) {
> /*  60 */         xDataList.add(Double.valueOf(i * 1.0D / fps));
> /*  61 */         yDataList.add(Double.valueOf(msdhelp));
> /*     */       } 
> /*     */     } 
> /*  64 */     double[] xdata = ArrayUtils.toPrimitive(xDataList.<Double>toArray(new Double[0]));
> /*  65 */     double[] ydata = ArrayUtils.toPrimitive(yDataList.<Double>toArray(new Double[0]));
> /*  66 */     StraightLineFitModified fdf = new StraightLineFitModified();
> /*  67 */     fdf.doFit(xdata, ydata);
> /*     */     
> /*  69 */     this.result = new double[] { fdf.getB() / 2.0D * t.getDimension(), fdf.getB() * 2.0D * t.getDimension(), fdf.getA(), fdf.getGoodness() };
> /*  70 */     return this.result;
> /*     */   }
> /*     */   
> /*     */   public void setTimelags(int lagMin, int lagMax) {
> /*  74 */     this.lagMin = lagMin;
> /*  75 */     this.lagMax = lagMax;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void setMeanSquaredDisplacementEvaluator(AbstractMeanSquaredDisplacmentEvaluatorModified msdeval) {
> /*  80 */     this.msdevaluator = msdeval;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double[] evaluate() {
> /*  85 */     this.result = getDiffusionCoefficient(this.t, this.fps);
> /*  86 */     return this.result;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String getName() {
> /*  92 */     return "Diffusion coefficient (Regression)";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String getShortName() {
> /*  98 */     return "DC-REG";
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void setTrajectory(TrajectoryModified t) {
> /* 103 */     this.t = t;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/DiffusionCoefficientEstimator/RegressionDiffusionCoefficientEstimatorModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/DirectoryListener.java jd-gui/DirectoryListener.java
1,37c1,42
< import java.awt.Component;
< import java.awt.TextField;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.io.File;
< import javax.swing.JFileChooser;
< 
< public class DirectoryListener implements ActionListener {
<    String title;
<    TextField text;
<    int fileSelectionMode;
< 
<    public DirectoryListener(String title, TextField text) {
<       this(title, text, 1);
<    }
< 
<    public DirectoryListener(String title, TextField text, int fileSelectionMode) {
<       this.title = title;
<       this.text = text;
<       this.fileSelectionMode = fileSelectionMode;
<    }
< 
<    public void actionPerformed(ActionEvent e) {
<       File directory;
<       for(directory = new File(this.text.getText()); directory != null && !directory.exists(); directory = directory.getParentFile()) {
<       }
< 
<       JFileChooser fc = new JFileChooser(directory);
<       fc.setFileSelectionMode(this.fileSelectionMode);
<       fc.showOpenDialog((Component)null);
<       File selFile = fc.getSelectedFile();
<       if (selFile != null) {
<          this.text.setText(selFile.getAbsolutePath());
<       }
< 
<    }
< }
---
> /*    */ import java.awt.TextField;
> /*    */ import java.awt.event.ActionEvent;
> /*    */ import java.awt.event.ActionListener;
> /*    */ import java.io.File;
> /*    */ import javax.swing.JFileChooser;
> /*    */ 
> /*    */ public class DirectoryListener
> /*    */   implements ActionListener {
> /*    */   String title;
> /*    */   TextField text;
> /*    */   int fileSelectionMode;
> /*    */   
> /*    */   public DirectoryListener(String title, TextField text) {
> /* 14 */     this(title, text, 1);
> /*    */   }
> /*    */   
> /*    */   public DirectoryListener(String title, TextField text, int fileSelectionMode) {
> /* 18 */     this.title = title;
> /* 19 */     this.text = text;
> /* 20 */     this.fileSelectionMode = fileSelectionMode;
> /*    */   }
> /*    */   
> /*    */   public void actionPerformed(ActionEvent e) {
> /* 24 */     File directory = new File(this.text.getText());
> /* 25 */     while (directory != null && !directory.exists()) {
> /* 26 */       directory = directory.getParentFile();
> /*    */     }
> /* 28 */     JFileChooser fc = new JFileChooser(directory);
> /* 29 */     fc.setFileSelectionMode(this.fileSelectionMode);
> /*    */     
> /* 31 */     fc.showOpenDialog(null);
> /* 32 */     File selFile = fc.getSelectedFile();
> /* 33 */     if (selFile != null)
> /* 34 */       this.text.setText(selFile.getAbsolutePath()); 
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/DirectoryListener.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/drift/StaticDriftCalculatorModified.java jd-gui/drift/StaticDriftCalculatorModified.java
1c1,41
< package drift;
---
> /*    */ package drift;
> /*    */ 
> /*    */ import java.util.ArrayList;
> /*    */ import traJ.TrajectoryModified;
> /*    */ import traJ.TrajectoryValidIndexTimelagIteratorModified;
> /*    */ import vecmath.Point3dModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class StaticDriftCalculatorModified<T extends TrajectoryModified>
> /*    */ {
> /*    */   public double[] calculateDrift(ArrayList<T> tracks) {
> /* 17 */     double[] result = new double[3];
> /*    */     
> /* 19 */     double sumX = 0.0D;
> /* 20 */     double sumY = 0.0D;
> /* 21 */     double sumZ = 0.0D;
> /* 22 */     int N = 0;
> /* 23 */     for (int i = 0; i < tracks.size(); i++) {
> /* 24 */       TrajectoryModified trajectoryModified = (TrajectoryModified)tracks.get(i);
> /* 25 */       TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(trajectoryModified, 1);
> /*    */ 
> /*    */       
> /* 28 */       while (it.hasNext()) {
> /* 29 */         int j = it.next().intValue();
> /* 30 */         sumX += ((Point3dModified)trajectoryModified.get(j + 1)).x - ((Point3dModified)trajectoryModified.get(j)).x;
> /* 31 */         sumY += ((Point3dModified)trajectoryModified.get(j + 1)).y - ((Point3dModified)trajectoryModified.get(j)).y;
> /* 32 */         sumZ += ((Point3dModified)trajectoryModified.get(j + 1)).z - ((Point3dModified)trajectoryModified.get(j)).z;
> /* 33 */         N++;
> /*    */       } 
> /*    */     } 
> /* 36 */     result[0] = sumX / N;
> /* 37 */     result[1] = sumY / N;
> /* 38 */     result[2] = sumZ / N;
> /* 39 */     return result;
> /*    */   }
> /*    */ }
3,6d42
< import java.util.ArrayList;
< import traJ.TrajectoryModified;
< import traJ.TrajectoryValidIndexTimelagIteratorModified;
< import vecmath.Point3dModified;
8,32c44,47
< public class StaticDriftCalculatorModified<T extends TrajectoryModified> {
<    public double[] calculateDrift(ArrayList<T> tracks) {
<       double[] result = new double[3];
<       double sumX = 0.0D;
<       double sumY = 0.0D;
<       double sumZ = 0.0D;
<       int N = 0;
< 
<       for(int i = 0; i < tracks.size(); ++i) {
<          T t = (TrajectoryModified)tracks.get(i);
< 
<          for(TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(t, 1); it.hasNext(); ++N) {
<             int j = it.next();
<             sumX += ((Point3dModified)t.get(j + 1)).x - ((Point3dModified)t.get(j)).x;
<             sumY += ((Point3dModified)t.get(j + 1)).y - ((Point3dModified)t.get(j)).y;
<             sumZ += ((Point3dModified)t.get(j + 1)).z - ((Point3dModified)t.get(j)).z;
<          }
<       }
< 
<       result[0] = sumX / (double)N;
<       result[1] = sumY / (double)N;
<       result[2] = sumZ / (double)N;
<       return result;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/drift/StaticDriftCalculatorModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/AbstractMeanSquaredDisplacmentEvaluatorModified.java jd-gui/features/AbstractMeanSquaredDisplacmentEvaluatorModified.java
6c6,11
<    void setTimelag(int var1);
---
>   void setTimelag(int paramInt);
>   
>   void setTrajectory(TrajectoryModified paramTrajectoryModified);
>   
>   double[] evaluate();
> }
8d12
<    void setTrajectory(TrajectoryModified var1);
10,11c14,17
<    double[] evaluate();
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/AbstractMeanSquaredDisplacmentEvaluatorModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/AbstractTrajectoryFeatureModified.java jd-gui/features/AbstractTrajectoryFeatureModified.java
1,23c1,34
< package features;
< 
< import traJ.TrajectoryModified;
< 
< public abstract class AbstractTrajectoryFeatureModified {
<    protected double[] result = null;
< 
<    public abstract double[] evaluate();
< 
<    public double[] getValue() {
<       if (this.result == null) {
<          this.result = this.evaluate();
<       }
< 
<       return this.result;
<    }
< 
<    public abstract String getName();
< 
<    public abstract String getShortName();
< 
<    public abstract void setTrajectory(TrajectoryModified var1);
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import traJ.TrajectoryModified;
> /*    */ 
> /*    */ public abstract class AbstractTrajectoryFeatureModified {
> /*  6 */   protected double[] result = null;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public abstract double[] evaluate();
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public double[] getValue() {
> /* 17 */     if (this.result == null) {
> /* 18 */       this.result = evaluate();
> /*    */     }
> /* 20 */     return this.result;
> /*    */   }
> /*    */   
> /*    */   public abstract String getName();
> /*    */   
> /*    */   public abstract String getShortName();
> /*    */   
> /*    */   public abstract void setTrajectory(TrajectoryModified paramTrajectoryModified);
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/AbstractTrajectoryFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/ActiveTransportParametersFeatureModified.java jd-gui/features/ActiveTransportParametersFeatureModified.java
1,55c1,86
< package features;
< 
< import java.util.ArrayList;
< import math.ActiveTransportMSDLineFitModified;
< import org.apache.commons.lang3.ArrayUtils;
< import traJ.TrajectoryModified;
< 
< public class ActiveTransportParametersFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private double timelag;
< 
<    public ActiveTransportParametersFeatureModified(TrajectoryModified t, double timelag) {
<       this.t = t;
<       this.timelag = timelag;
<    }
< 
<    public double[] evaluate() {
<       MeanSquaredDisplacmentFeatureModified msdevaluator = new MeanSquaredDisplacmentFeatureModified(this.t, 1);
<       msdevaluator.setTrajectory(this.t);
<       ArrayList<Double> xDataList = new ArrayList();
<       ArrayList<Double> yDataList = new ArrayList();
< 
<       double[] ydata;
<       for(int i = 1; i < this.t.size() / 3; ++i) {
<          msdevaluator.setTimelag(i);
<          ydata = msdevaluator.evaluate();
<          double msdhelp = ydata[0];
<          int N = (int)ydata[2];
< 
<          for(int j = 0; j < N; ++j) {
<             xDataList.add((double)i * this.timelag);
<             yDataList.add(msdhelp);
<          }
<       }
< 
<       double[] xdata = ArrayUtils.toPrimitive((Double[])xDataList.toArray(new Double[0]));
<       ydata = ArrayUtils.toPrimitive((Double[])yDataList.toArray(new Double[0]));
<       ActiveTransportMSDLineFitModified afit = new ActiveTransportMSDLineFitModified();
<       afit.doFit(xdata, ydata);
<       this.result = new double[]{afit.getDiffusionCoefficient(), afit.getVelocity(), afit.getFitGoodness()};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Active transport parameters";
<    }
< 
<    public String getShortName() {
<       return "ACTPARAM";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import java.util.ArrayList;
> /*    */ import math.ActiveTransportMSDLineFitModified;
> /*    */ import org.apache.commons.lang3.ArrayUtils;
> /*    */ import traJ.TrajectoryModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class ActiveTransportParametersFeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   private double timelag;
> /*    */   
> /*    */   public ActiveTransportParametersFeatureModified(TrajectoryModified t, double timelag) {
> /* 30 */     this.t = t;
> /* 31 */     this.timelag = timelag;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public double[] evaluate() {
> /* 41 */     MeanSquaredDisplacmentFeatureModified msdevaluator = new MeanSquaredDisplacmentFeatureModified(this.t, 1);
> /* 42 */     msdevaluator.setTrajectory(this.t);
> /*    */     
> /* 44 */     ArrayList<Double> xDataList = new ArrayList<>();
> /* 45 */     ArrayList<Double> yDataList = new ArrayList<>();
> /* 46 */     for (int i = 1; i < this.t.size() / 3; i++) {
> /* 47 */       msdevaluator.setTimelag(i);
> /* 48 */       double[] res = msdevaluator.evaluate();
> /* 49 */       double msdhelp = res[0];
> /* 50 */       int N = (int)res[2];
> /* 51 */       for (int j = 0; j < N; j++) {
> /* 52 */         xDataList.add(Double.valueOf(i * this.timelag));
> /* 53 */         yDataList.add(Double.valueOf(msdhelp));
> /*    */       } 
> /*    */     } 
> /* 56 */     double[] xdata = ArrayUtils.toPrimitive(xDataList.<Double>toArray(new Double[0]));
> /* 57 */     double[] ydata = ArrayUtils.toPrimitive(yDataList.<Double>toArray(new Double[0]));
> /*    */     
> /* 59 */     ActiveTransportMSDLineFitModified afit = new ActiveTransportMSDLineFitModified();
> /* 60 */     afit.doFit(xdata, ydata);
> /*    */     
> /* 62 */     this.result = new double[] { afit.getDiffusionCoefficient(), afit.getVelocity(), afit.getFitGoodness() };
> /* 63 */     return this.result;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 68 */     return "Active transport parameters";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 73 */     return "ACTPARAM";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 78 */     this.t = t;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/ActiveTransportParametersFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/Asymmetry3FeatureModified.java jd-gui/features/Asymmetry3FeatureModified.java
1,37c1,69
< package features;
< 
< import math.RadiusGyrationTensor2DModified;
< import org.apache.commons.math3.linear.Array2DRowRealMatrix;
< import org.apache.commons.math3.linear.EigenDecomposition;
< import traJ.TrajectoryModified;
< 
< public class Asymmetry3FeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public Asymmetry3FeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       Array2DRowRealMatrix gyr = RadiusGyrationTensor2DModified.getRadiusOfGyrationTensor(this.t);
<       EigenDecomposition eigdec = new EigenDecomposition(gyr);
<       double e1 = eigdec.getRealEigenvalue(0);
<       double e2 = eigdec.getRealEigenvalue(1);
<       double asym = -1.0D * Math.log(1.0D - Math.pow(e1 - e2, 2.0D) / (2.0D * Math.pow(e1 + e2, 2.0D)));
<       this.result = new double[]{asym};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Assymetry3";
<    }
< 
<    public String getShortName() {
<       return "ASYM3";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import math.RadiusGyrationTensor2DModified;
> /*    */ import org.apache.commons.math3.linear.Array2DRowRealMatrix;
> /*    */ import org.apache.commons.math3.linear.EigenDecomposition;
> /*    */ import org.apache.commons.math3.linear.RealMatrix;
> /*    */ import traJ.TrajectoryModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class Asymmetry3FeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   
> /*    */   public Asymmetry3FeatureModified(TrajectoryModified t) {
> /* 30 */     this.t = t;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public double[] evaluate() {
> /* 38 */     Array2DRowRealMatrix gyr = RadiusGyrationTensor2DModified.getRadiusOfGyrationTensor(this.t);
> /* 39 */     EigenDecomposition eigdec = new EigenDecomposition((RealMatrix)gyr);
> /* 40 */     double e1 = eigdec.getRealEigenvalue(0);
> /* 41 */     double e2 = eigdec.getRealEigenvalue(1);
> /* 42 */     double asym = -1.0D * Math.log(1.0D - Math.pow(e1 - e2, 2.0D) / 2.0D * Math.pow(e1 + e2, 2.0D));
> /* 43 */     this.result = new double[] { asym };
> /*    */     
> /* 45 */     return this.result;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 50 */     return "Assymetry3";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 55 */     return "ASYM3";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 60 */     this.t = t;
> /* 61 */     this.result = null;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/Asymmetry3FeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/CenterOfGravityFeatureModified.java jd-gui/features/CenterOfGravityFeatureModified.java
1,43c1,62
< package features;
< 
< import traJ.TrajectoryModified;
< import vecmath.Point3dModified;
< 
< public class CenterOfGravityFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public CenterOfGravityFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       double x = 0.0D;
<       double y = 0.0D;
<       double z = 0.0D;
< 
<       for(int i = 0; i < this.t.size(); ++i) {
<          x += ((Point3dModified)this.t.get(i)).x;
<          y += ((Point3dModified)this.t.get(i)).y;
<          z += ((Point3dModified)this.t.get(i)).z;
<       }
< 
<       x /= (double)this.t.size();
<       y /= (double)this.t.size();
<       z /= (double)this.t.size();
<       this.result = new double[]{x, y, z};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Center of gravity";
<    }
< 
<    public String getShortName() {
<       return "COG";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import traJ.TrajectoryModified;
> /*    */ import vecmath.Point3dModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class CenterOfGravityFeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   
> /*    */   public CenterOfGravityFeatureModified(TrajectoryModified t) {
> /* 17 */     this.t = t;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public double[] evaluate() {
> /* 24 */     double x = 0.0D;
> /* 25 */     double y = 0.0D;
> /* 26 */     double z = 0.0D;
> /*    */     
> /* 28 */     for (int i = 0; i < this.t.size(); i++) {
> /* 29 */       x += ((Point3dModified)this.t.get(i)).x;
> /* 30 */       y += ((Point3dModified)this.t.get(i)).y;
> /* 31 */       z += ((Point3dModified)this.t.get(i)).z;
> /*    */     } 
> /*    */     
> /* 34 */     x /= this.t.size();
> /* 35 */     y /= this.t.size();
> /* 36 */     z /= this.t.size();
> /* 37 */     this.result = new double[] { x, y, z };
> /* 38 */     return this.result;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 43 */     return "Center of gravity";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 48 */     return "COG";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 53 */     this.t = t;
> /* 54 */     this.result = null;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/CenterOfGravityFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/ConfinedDiffusionParametersFeatureModified.java jd-gui/features/ConfinedDiffusionParametersFeatureModified.java
1,79c1,137
< package features;
< 
< import DiffusionCoefficientEstimator.AbstractDiffusionCoefficientEstimatorModified;
< import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
< import java.util.ArrayList;
< import math.ConfinedDiffusionMSDCurveFitModified;
< import org.apache.commons.lang3.ArrayUtils;
< import traJ.TrajectoryModified;
< 
< public class ConfinedDiffusionParametersFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private double timelag;
<    private AbstractDiffusionCoefficientEstimatorModified dcEst;
<    private boolean useReducedModel;
< 
<    public ConfinedDiffusionParametersFeatureModified(TrajectoryModified t, double timelag, boolean useReducedModel) {
<       this.t = t;
<       this.timelag = timelag;
<       this.dcEst = new RegressionDiffusionCoefficientEstimatorModified((TrajectoryModified)null, 1.0D / timelag, 1, 2);
<       this.useReducedModel = useReducedModel;
<    }
< 
<    public ConfinedDiffusionParametersFeatureModified(TrajectoryModified t, double timelag, boolean useReducedModel, AbstractDiffusionCoefficientEstimatorModified dcEst) {
<       this.t = t;
<       this.timelag = timelag;
<       this.dcEst = dcEst;
<       this.useReducedModel = useReducedModel;
<    }
< 
<    public double[] evaluate() {
<       MeanSquaredDisplacmentFeatureModified msd = new MeanSquaredDisplacmentFeatureModified(this.t, 1);
<       msd.setOverlap(false);
<       ArrayList<Double> xDataList = new ArrayList();
<       ArrayList<Double> yDataList = new ArrayList();
< 
<       double[] yData;
<       for(int i = 1; i < this.t.size() / 3; ++i) {
<          msd.setTimelag(i);
<          yData = msd.evaluate();
<          double msdvalue = yData[0];
<          int N = (int)yData[2];
< 
<          for(int j = 0; j < N; ++j) {
<             xDataList.add((double)i * this.timelag);
<             yDataList.add(msdvalue);
<          }
<       }
< 
<       double[] xData = ArrayUtils.toPrimitive((Double[])xDataList.toArray(new Double[0]));
<       yData = ArrayUtils.toPrimitive((Double[])yDataList.toArray(new Double[0]));
<       MaxDistanceBetweenTwoPositionsFeatureModified maxdist = new MaxDistanceBetweenTwoPositionsFeatureModified(this.t);
<       double estdia = maxdist.evaluate()[0];
<       double estDC = this.dcEst.getDiffusionCoefficient(this.t, 1.0D / this.timelag)[0];
<       double[] initialParams = new double[]{estdia * estdia, 0.0D, 0.0D, estDC};
<       ConfinedDiffusionMSDCurveFitModified cmsdfit = new ConfinedDiffusionMSDCurveFitModified();
<       cmsdfit.setInitParameters(initialParams);
<       cmsdfit.doFit(xData, yData, this.useReducedModel);
<       if (this.useReducedModel) {
<          this.result = new double[]{cmsdfit.getA(), cmsdfit.getD(), cmsdfit.getGoodness()};
<       } else {
<          this.result = new double[]{cmsdfit.getA(), cmsdfit.getD(), cmsdfit.getB(), cmsdfit.getC(), cmsdfit.getGoodness()};
<       }
< 
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Confinement Parameters";
<    }
< 
<    public String getShortName() {
<       return "CONFPARAM";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*     */ package features;
> /*     */ 
> /*     */ import DiffusionCoefficientEstimator.AbstractDiffusionCoefficientEstimatorModified;
> /*     */ import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
> /*     */ import java.util.ArrayList;
> /*     */ import math.ConfinedDiffusionMSDCurveFitModified;
> /*     */ import org.apache.commons.lang3.ArrayUtils;
> /*     */ import traJ.TrajectoryModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class ConfinedDiffusionParametersFeatureModified
> /*     */   extends AbstractTrajectoryFeatureModified
> /*     */ {
> /*     */   private TrajectoryModified t;
> /*     */   private double timelag;
> /*     */   private AbstractDiffusionCoefficientEstimatorModified dcEst;
> /*     */   private boolean useReducedModel;
> /*     */   
> /*     */   public ConfinedDiffusionParametersFeatureModified(TrajectoryModified t, double timelag, boolean useReducedModel) {
> /*  41 */     this.t = t;
> /*  42 */     this.timelag = timelag;
> /*  43 */     this.dcEst = (AbstractDiffusionCoefficientEstimatorModified)new RegressionDiffusionCoefficientEstimatorModified(null, 1.0D / timelag, 1, 2);
> /*  44 */     this.useReducedModel = useReducedModel;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ConfinedDiffusionParametersFeatureModified(TrajectoryModified t, double timelag, boolean useReducedModel, AbstractDiffusionCoefficientEstimatorModified dcEst) {
> /*  56 */     this.t = t;
> /*  57 */     this.timelag = timelag;
> /*  58 */     this.dcEst = dcEst;
> /*  59 */     this.useReducedModel = useReducedModel;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] evaluate() {
> /*  71 */     MeanSquaredDisplacmentFeatureModified msd = new MeanSquaredDisplacmentFeatureModified(this.t, 1);
> /*  72 */     msd.setOverlap(false);
> /*     */     
> /*  74 */     ArrayList<Double> xDataList = new ArrayList<>();
> /*  75 */     ArrayList<Double> yDataList = new ArrayList<>();
> /*     */     
> /*  77 */     for (int i = 1; i < this.t.size() / 3; i++) {
> /*  78 */       msd.setTimelag(i);
> /*  79 */       double[] res = msd.evaluate();
> /*  80 */       double msdvalue = res[0];
> /*  81 */       int N = (int)res[2];
> /*  82 */       for (int j = 0; j < N; j++) {
> /*  83 */         xDataList.add(Double.valueOf(i * this.timelag));
> /*  84 */         yDataList.add(Double.valueOf(msdvalue));
> /*     */       } 
> /*     */     } 
> /*  87 */     double[] xData = ArrayUtils.toPrimitive(xDataList.<Double>toArray(new Double[0]));
> /*  88 */     double[] yData = ArrayUtils.toPrimitive(yDataList.<Double>toArray(new Double[0]));
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*  93 */     MaxDistanceBetweenTwoPositionsFeatureModified maxdist = new MaxDistanceBetweenTwoPositionsFeatureModified(this.t);
> /*  94 */     double estdia = maxdist.evaluate()[0];
> /*  95 */     double estDC = this.dcEst.getDiffusionCoefficient(this.t, 1.0D / this.timelag)[0];
> /*     */     
> /*  97 */     double[] initialParams = { estdia * estdia, 0.0D, 0.0D, estDC };
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 103 */     ConfinedDiffusionMSDCurveFitModified cmsdfit = new ConfinedDiffusionMSDCurveFitModified();
> /* 104 */     cmsdfit.setInitParameters(initialParams);
> /* 105 */     cmsdfit.doFit(xData, yData, this.useReducedModel);
> /* 106 */     if (this.useReducedModel) {
> /* 107 */       this.result = new double[] { cmsdfit.getA(), cmsdfit.getD(), cmsdfit.getGoodness() };
> /*     */     } else {
> /* 109 */       this.result = new double[] { cmsdfit.getA(), cmsdfit.getD(), cmsdfit.getB(), cmsdfit.getC(), 
> /* 110 */           cmsdfit.getGoodness() };
> /*     */     } 
> /*     */     
> /* 113 */     return this.result;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public String getName() {
> /* 118 */     return "Confinement Parameters";
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public String getShortName() {
> /* 123 */     return "CONFPARAM";
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void setTrajectory(TrajectoryModified t) {
> /* 128 */     this.t = t;
> /* 129 */     this.result = null;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/ConfinedDiffusionParametersFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/EfficiencyFeatureModified.java jd-gui/features/EfficiencyFeatureModified.java
1,47c1,60
< package features;
< 
< import traJ.TrajectoryModified;
< import vecmath.Point3dModified;
< 
< public class EfficiencyFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public EfficiencyFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       this.result = new double[]{this.getEfficiency()};
<       return this.result;
<    }
< 
<    public double getEfficiency() {
<       double sum = 0.0D;
< 
<       for(int i = 1; i < this.t.size(); ++i) {
<          double d = ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(i - 1));
<          sum += d * d;
<       }
< 
<       if (sum < Math.pow(10.0D, -10.0D)) {
<          return 0.0D;
<       } else {
<          double d = ((Point3dModified)this.t.get(0)).distance((Point3dModified)this.t.get(this.t.size() - 1));
<          double eff = d * d / ((double)this.t.size() * sum);
<          return eff;
<       }
<    }
< 
<    public String getName() {
<       return "Efficiency";
<    }
< 
<    public String getShortName() {
<       return "EFFICENCY";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import traJ.TrajectoryModified;
> /*    */ import vecmath.Point3dModified;
> /*    */ 
> /*    */ public class EfficiencyFeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   
> /*    */   public EfficiencyFeatureModified(TrajectoryModified t) {
> /* 12 */     this.t = t;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public double[] evaluate() {
> /* 20 */     this.result = new double[] { getEfficiency() };
> /* 21 */     return this.result;
> /*    */   }
> /*    */   
> /*    */   public double getEfficiency() {
> /* 25 */     double sum = 0.0D;
> /* 26 */     for (int i = 1; i < this.t.size(); i++) {
> /* 27 */       double d1 = ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(i - 1));
> /* 28 */       sum += d1 * d1;
> /*    */     } 
> /* 30 */     if (sum < Math.pow(10.0D, -10.0D)) {
> /* 31 */       return 0.0D;
> /*    */     }
> /* 33 */     double d = ((Point3dModified)this.t.get(0)).distance((Point3dModified)this.t.get(this.t.size() - 1));
> /* 34 */     double eff = d * d / this.t.size() * sum;
> /* 35 */     return eff;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 40 */     return "Efficiency";
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 46 */     return "EFFICENCY";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 51 */     this.t = t;
> /* 52 */     this.result = null;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/EfficiencyFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/FractalDimensionFeatureModified.java jd-gui/features/FractalDimensionFeatureModified.java
1,55c1,70
< package features;
< 
< import traJ.TrajectoryModified;
< import vecmath.Point3dModified;
< 
< public class FractalDimensionFeatureModified extends AbstractTrajectoryFeatureModified {
<    TrajectoryModified t;
< 
<    public FractalDimensionFeatureModified(TrajectoryModified t) {
<       this.t = t;
<       if (t.getDimension() != 2) {
<          throw new IllegalArgumentException("The fractal dimension feature only supoorts planer (2D) trajetorys");
<       }
<    }
< 
<    public double[] evaluate() {
<       double largestDistance = Double.MIN_VALUE;
<       double totalLength = 0.0D;
< 
<       double d;
<       for(int i = 0; i < this.t.size(); ++i) {
<          for(int j = i + 1; j < this.t.size(); ++j) {
<             d = ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(j));
<             if (d > largestDistance) {
<                largestDistance = d;
<             }
<          }
< 
<          if (i > 0) {
<             totalLength += ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(i - 1));
<          }
<       }
< 
<       double n = (double)(this.t.size() - 1);
<       d = Math.log(n) / (Math.log(n) + Math.log(largestDistance / totalLength));
<       this.result = new double[]{d};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Fractal Dimension";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<       if (t.getDimension() != 2) {
<          throw new IllegalArgumentException("The fractal dimension feature only supoorts planer (2D) trajetorys");
<       }
<    }
< 
<    public String getShortName() {
<       return "FD";
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import traJ.TrajectoryModified;
> /*    */ import vecmath.Point3dModified;
> /*    */ 
> /*    */ public class FractalDimensionFeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   TrajectoryModified t;
> /*    */   
> /*    */   public FractalDimensionFeatureModified(TrajectoryModified t) {
> /* 12 */     this.t = t;
> /* 13 */     if (t.getDimension() != 2) {
> /* 14 */       throw new IllegalArgumentException("The fractal dimension feature only supoorts planer (2D) trajetorys");
> /*    */     }
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public double[] evaluate() {
> /* 23 */     double largestDistance = Double.MIN_VALUE;
> /* 24 */     double totalLength = 0.0D;
> /* 25 */     for (int i = 0; i < this.t.size(); i++) {
> /* 26 */       for (int j = i + 1; j < this.t.size(); j++) {
> /* 27 */         double d = ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(j));
> /* 28 */         if (d > largestDistance) {
> /* 29 */           largestDistance = d;
> /*    */         }
> /*    */       } 
> /* 32 */       if (i > 0) {
> /* 33 */         totalLength += ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(i - 1));
> /*    */       }
> /*    */     } 
> /*    */     
> /* 37 */     double n = (this.t.size() - 1);
> /* 38 */     double fractalDImension = Math.log(n) / (Math.log(n) + Math.log(largestDistance / totalLength));
> /* 39 */     this.result = new double[] { fractalDImension };
> /*    */ 
> /*    */     
> /* 42 */     return this.result;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 47 */     return "Fractal Dimension";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 52 */     this.t = t;
> /* 53 */     this.result = null;
> /* 54 */     if (t.getDimension() != 2) {
> /* 55 */       throw new IllegalArgumentException("The fractal dimension feature only supoorts planer (2D) trajetorys");
> /*    */     }
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 62 */     return "FD";
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/FractalDimensionFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/GaussianityFeautureModified.java jd-gui/features/GaussianityFeautureModified.java
1,38c1,53
< package features;
< 
< import traJ.TrajectoryModified;
< 
< public class GaussianityFeautureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private int timelag;
<    private String name = "Gaussianity";
<    private String sname = "GAUSS";
< 
<    public GaussianityFeautureModified(TrajectoryModified t, int timelag) {
<       this.t = t;
<       this.timelag = timelag;
<    }
< 
<    public double[] evaluate() {
<       MeanSquaredDisplacmentFeatureModified msdf = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag);
<       QuartricMomentFeatureModified qart = new QuartricMomentFeatureModified(this.t, this.timelag);
<       double msd = msdf.evaluate()[0];
<       double q = qart.evaluate()[0];
<       double res = 2.0D * q / (3.0D * msd * msd) - 1.0D;
<       this.result = new double[]{res};
<       return this.result;
<    }
< 
<    public String getName() {
<       return this.name;
<    }
< 
<    public String getShortName() {
<       return this.sname;
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import traJ.TrajectoryModified;
> /*    */ 
> /*    */ public class GaussianityFeautureModified extends AbstractTrajectoryFeatureModified {
> /*    */   private TrajectoryModified t;
> /*    */   private int timelag;
> /*  8 */   private String name = "Gaussianity";
> /*  9 */   private String sname = "GAUSS";
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public GaussianityFeautureModified(TrajectoryModified t, int timelag) {
> /* 16 */     this.t = t;
> /* 17 */     this.timelag = timelag;
> /*    */   }
> /*    */   
> /*    */   public double[] evaluate() {
> /* 21 */     MeanSquaredDisplacmentFeatureModified msdf = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag);
> /* 22 */     QuartricMomentFeatureModified qart = new QuartricMomentFeatureModified(this.t, this.timelag);
> /*    */     
> /* 24 */     double msd = msdf.evaluate()[0];
> /* 25 */     double q = qart.evaluate()[0];
> /*    */     
> /* 27 */     double res = 2.0D * q / 3.0D * msd * msd - 1.0D;
> /* 28 */     this.result = new double[] { res };
> /* 29 */     return this.result;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 34 */     return this.name;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 39 */     return this.sname;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 44 */     this.t = t;
> /* 45 */     this.result = null;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/GaussianityFeautureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/KurtosisFeatureModified.java jd-gui/features/KurtosisFeatureModified.java
1,31c1,48
< package features;
< 
< import math.MomentsCalculatorModified;
< import traJ.TrajectoryModified;
< 
< public class KurtosisFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public KurtosisFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       MomentsCalculatorModified moments = new MomentsCalculatorModified(this.t);
<       this.result = new double[]{moments.calculateNthMoment(4)};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Kurtosis";
<    }
< 
<    public String getShortName() {
<       return "KURT";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import math.MomentsCalculatorModified;
> /*    */ import traJ.TrajectoryModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class KurtosisFeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   
> /*    */   public KurtosisFeatureModified(TrajectoryModified t) {
> /* 14 */     this.t = t;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public double[] evaluate() {
> /* 22 */     MomentsCalculatorModified moments = new MomentsCalculatorModified(this.t);
> /* 23 */     this.result = new double[] { moments.calculateNthMoment(4) };
> /* 24 */     return this.result;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 29 */     return "Kurtosis";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 34 */     return "KURT";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 39 */     this.t = t;
> /* 40 */     this.result = null;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/KurtosisFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/MaxDistanceBetweenTwoPositionsFeatureModified.java jd-gui/features/MaxDistanceBetweenTwoPositionsFeatureModified.java
1,41c1,56
< package features;
< 
< import traJ.TrajectoryModified;
< import vecmath.Point3dModified;
< 
< public class MaxDistanceBetweenTwoPositionsFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public MaxDistanceBetweenTwoPositionsFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       double maxDistance = Double.MIN_VALUE;
< 
<       for(int i = 0; i < this.t.size(); ++i) {
<          for(int j = i + 1; j < this.t.size(); ++j) {
<             double d = ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(j));
<             if (d > maxDistance) {
<                maxDistance = d;
<             }
<          }
<       }
< 
<       this.result = new double[]{maxDistance};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Maximum distance between two positions";
<    }
< 
<    public String getShortName() {
<       return "MAX-DIST-POS";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import traJ.TrajectoryModified;
> /*    */ import vecmath.Point3dModified;
> /*    */ 
> /*    */ 
> /*    */ public class MaxDistanceBetweenTwoPositionsFeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   
> /*    */   public MaxDistanceBetweenTwoPositionsFeatureModified(TrajectoryModified t) {
> /* 13 */     this.t = t;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public double[] evaluate() {
> /* 22 */     double maxDistance = Double.MIN_VALUE;
> /* 23 */     for (int i = 0; i < this.t.size(); i++) {
> /* 24 */       for (int j = i + 1; j < this.t.size(); j++) {
> /* 25 */         double d = ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(j));
> /* 26 */         if (d > maxDistance) {
> /* 27 */           maxDistance = d;
> /*    */         }
> /*    */       } 
> /*    */     } 
> /* 31 */     this.result = new double[] { maxDistance };
> /* 32 */     return this.result;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 37 */     return "Maximum distance between two positions";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 42 */     return "MAX-DIST-POS";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 47 */     this.t = t;
> /* 48 */     this.result = null;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/MaxDistanceBetweenTwoPositionsFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/MeanSpeedFeatureModified.java jd-gui/features/MeanSpeedFeatureModified.java
1,41c1,63
< package features;
< 
< import traJ.TrajectoryModified;
< import vecmath.Point3dModified;
< 
< public class MeanSpeedFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private double timelag;
< 
<    public MeanSpeedFeatureModified(TrajectoryModified t, double timelag) {
<       this.t = t;
<       this.timelag = timelag;
<    }
< 
<    public double[] evaluate() {
<       double sum = 0.0D;
< 
<       for(int i = 1; i < this.t.size(); ++i) {
<          sum += ((Point3dModified)this.t.get(i - 1)).distance((Point3dModified)this.t.get(i)) / this.timelag;
<       }
< 
<       double meanspeed = sum / (double)(this.t.size() - 1);
<       double netDistance = ((Point3dModified)this.t.get(0)).distance((Point3dModified)this.t.get(this.t.size() - 1));
<       double straightLineSpeed = netDistance / ((double)(this.t.size() - 1) * this.timelag);
<       this.result = new double[]{meanspeed, straightLineSpeed};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Mean Speed Feature";
<    }
< 
<    public String getShortName() {
<       return "MEANSPEED";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import traJ.TrajectoryModified;
> /*    */ import vecmath.Point3dModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class MeanSpeedFeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   private double timelag;
> /*    */   
> /*    */   public MeanSpeedFeatureModified(TrajectoryModified t, double timelag) {
> /* 15 */     this.t = t;
> /* 16 */     this.timelag = timelag;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public double[] evaluate() {
> /* 27 */     double sum = 0.0D;
> /* 28 */     for (int i = 1; i < this.t.size(); i++) {
> /* 29 */       sum += ((Point3dModified)this.t.get(i - 1)).distance((Point3dModified)this.t.get(i)) / this.timelag;
> /*    */     }
> /*    */     
> /* 32 */     double meanspeed = sum / (this.t.size() - 1);
> /*    */     
> /* 34 */     double netDistance = ((Point3dModified)this.t.get(0)).distance((Point3dModified)this.t.get(this.t.size() - 1));
> /* 35 */     double straightLineSpeed = netDistance / (this.t.size() - 1) * this.timelag;
> /* 36 */     this.result = new double[] { meanspeed, straightLineSpeed };
> /* 37 */     return this.result;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 43 */     return "Mean Speed Feature";
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 49 */     return "MEANSPEED";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 54 */     this.t = t;
> /* 55 */     this.result = null;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/MeanSpeedFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/MeanSquaredDisplacmentFeatureModified.java jd-gui/features/MeanSquaredDisplacmentFeatureModified.java
1,72c1,120
< package features;
< 
< import traJ.TrajectoryModified;
< import traJ.TrajectoryValidIndexTimelagIteratorModified;
< import vecmath.Point3dModified;
< 
< public class MeanSquaredDisplacmentFeatureModified extends AbstractTrajectoryFeatureModified implements AbstractMeanSquaredDisplacmentEvaluatorModified {
<    private TrajectoryModified t;
<    private int timelag;
<    private boolean overlap = false;
< 
<    public MeanSquaredDisplacmentFeatureModified(TrajectoryModified t, int timelag) {
<       this.t = t;
<       this.timelag = timelag;
<    }
< 
<    public void setTimelag(int timelag) {
<       this.timelag = timelag;
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< 
<    private double[] getMeanSquaredDisplacment(TrajectoryModified t, int timelag) {
<       double msd = 0.0D;
<       double[] result = new double[3];
<       if (t.size() == 1) {
<          result[0] = 0.0D;
<          result[1] = 0.0D;
<          result[2] = 1.0D;
<          return result;
<       } else if (timelag < 1) {
<          throw new IllegalArgumentException("Timelag can not be smaller than 1");
<       } else {
<          TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(t, timelag, this.overlap);
< 
<          int N;
<          for(N = 0; it.hasNext(); ++N) {
<             int i = it.next();
<             msd = msd + Math.pow(((Point3dModified)t.get(i)).x - ((Point3dModified)t.get(i + timelag)).x, 2.0D) + Math.pow(((Point3dModified)t.get(i)).y - ((Point3dModified)t.get(i + timelag)).y, 2.0D) + Math.pow(((Point3dModified)t.get(i)).z - ((Point3dModified)t.get(i + timelag)).z, 2.0D);
<          }
< 
<          msd /= (double)N;
<          result[0] = msd;
<          result[1] = (double)timelag * ((double)(2 * timelag * timelag) + 1.0D) / ((double)(N - timelag) + 1.0D);
<          result[2] = (double)N;
<          return result;
<       }
<    }
< 
<    public double[] evaluate() {
<       return this.getMeanSquaredDisplacment(this.t, this.timelag);
<    }
< 
<    public double getRelativeVariance() {
<       return this.getMeanSquaredDisplacment(this.t, this.timelag)[1];
<    }
< 
<    public String getName() {
<       return "Mean squared displacement-dt-" + this.timelag;
<    }
< 
<    public String getShortName() {
<       return "MSD";
<    }
< 
<    public void setOverlap(boolean overlap) {
<       this.overlap = overlap;
<    }
< }
---
> /*     */ package features;
> /*     */ 
> /*     */ import traJ.TrajectoryModified;
> /*     */ import traJ.TrajectoryValidIndexTimelagIteratorModified;
> /*     */ import vecmath.Point3dModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class MeanSquaredDisplacmentFeatureModified
> /*     */   extends AbstractTrajectoryFeatureModified
> /*     */   implements AbstractMeanSquaredDisplacmentEvaluatorModified
> /*     */ {
> /*     */   private TrajectoryModified t;
> /*     */   private int timelag;
> /*     */   private boolean overlap = false;
> /*     */   
> /*     */   public MeanSquaredDisplacmentFeatureModified(TrajectoryModified t, int timelag) {
> /*  22 */     this.t = t;
> /*  23 */     this.timelag = timelag;
> /*     */   }
> /*     */   
> /*     */   public void setTimelag(int timelag) {
> /*  27 */     this.timelag = timelag;
> /*     */   }
> /*     */   
> /*     */   public void setTrajectory(TrajectoryModified t) {
> /*  31 */     this.t = t;
> /*  32 */     this.result = null;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private double[] getMeanSquaredDisplacment(TrajectoryModified t, int timelag) {
> /*  48 */     double msd = 0.0D;
> /*  49 */     double[] result = new double[3];
> /*  50 */     if (t.size() == 1) {
> /*  51 */       result[0] = 0.0D;
> /*  52 */       result[1] = 0.0D;
> /*  53 */       result[2] = 1.0D;
> /*  54 */       return result;
> /*     */     } 
> /*     */     
> /*  57 */     if (timelag < 1) {
> /*  58 */       throw new IllegalArgumentException("Timelag can not be smaller than 1");
> /*     */     }
> /*  60 */     TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(t, timelag, this.overlap);
> /*  61 */     int N = 0;
> /*  62 */     while (it.hasNext()) {
> /*  63 */       int i = it.next().intValue();
> /*  64 */       msd = msd + 
> /*  65 */         Math.pow(((Point3dModified)t.get(i)).x - ((Point3dModified)t.get(i + timelag)).x, 2.0D) + 
> /*  66 */         Math.pow(((Point3dModified)t.get(i)).y - ((Point3dModified)t.get(i + timelag)).y, 2.0D) + 
> /*  67 */         Math.pow(((Point3dModified)t.get(i)).z - ((Point3dModified)t.get(i + timelag)).z, 2.0D);
> /*  68 */       N++;
> /*     */     } 
> /*     */     
> /*  71 */     msd /= N;
> /*     */     
> /*  73 */     result[0] = msd;
> /*  74 */     result[1] = timelag * ((2 * timelag * timelag) + 1.0D) / ((N - timelag) + 1.0D);
> /*  75 */     result[2] = N;
> /*  76 */     return result;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] evaluate() {
> /*  85 */     return getMeanSquaredDisplacment(this.t, this.timelag);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double getRelativeVariance() {
> /*  96 */     return getMeanSquaredDisplacment(this.t, this.timelag)[1];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String getName() {
> /* 102 */     return "Mean squared displacement-dt-" + this.timelag;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String getShortName() {
> /* 108 */     return "MSD";
> /*     */   }
> /*     */   
> /*     */   public void setOverlap(boolean overlap) {
> /* 112 */     this.overlap = overlap;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/MeanSquaredDisplacmentFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/MSDRatioFeatureModified.java jd-gui/features/MSDRatioFeatureModified.java
1,38c1,61
< package features;
< 
< import traJ.TrajectoryModified;
< 
< public class MSDRatioFeatureModified extends AbstractTrajectoryFeatureModified {
<    private int timelag1;
<    private int timelag2;
<    private TrajectoryModified t;
< 
<    public MSDRatioFeatureModified(TrajectoryModified t, int timelag1, int timelag2) {
<       this.t = t;
<       this.timelag1 = timelag1;
<       this.timelag2 = timelag2;
<    }
< 
<    public double[] evaluate() {
<       MeanSquaredDisplacmentFeatureModified msdf1 = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag1);
<       MeanSquaredDisplacmentFeatureModified msdf2 = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag2);
<       double msd1 = msdf1.evaluate()[0];
<       double msd2 = msdf2.evaluate()[0];
<       double res = msd1 / msd2 - 1.0D * (double)this.timelag1 / (double)this.timelag2;
<       this.result = new double[]{res};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Mean squared displacment ratio";
<    }
< 
<    public String getShortName() {
<       return "MSDR";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import traJ.TrajectoryModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class MSDRatioFeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   private int timelag1;
> /*    */   private int timelag2;
> /*    */   private TrajectoryModified t;
> /*    */   
> /*    */   public MSDRatioFeatureModified(TrajectoryModified t, int timelag1, int timelag2) {
> /* 21 */     this.t = t;
> /* 22 */     this.timelag1 = timelag1;
> /* 23 */     this.timelag2 = timelag2;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public double[] evaluate() {
> /* 30 */     MeanSquaredDisplacmentFeatureModified msdf1 = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag1);
> /* 31 */     MeanSquaredDisplacmentFeatureModified msdf2 = new MeanSquaredDisplacmentFeatureModified(this.t, this.timelag2);
> /*    */     
> /* 33 */     double msd1 = msdf1.evaluate()[0];
> /* 34 */     double msd2 = msdf2.evaluate()[0];
> /* 35 */     double res = msd1 / msd2 - 1.0D * this.timelag1 / this.timelag2;
> /* 36 */     this.result = new double[] { res };
> /* 37 */     return this.result;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 42 */     return "Mean squared displacment ratio";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 47 */     return "MSDR";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 52 */     this.t = t;
> /* 53 */     this.result = null;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/MSDRatioFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/PowerLawFeatureModified.java jd-gui/features/PowerLawFeatureModified.java
1,106c1,153
< package features;
< 
< import java.util.ArrayList;
< import math.PowerLawCurveFitModified;
< import org.apache.commons.lang3.ArrayUtils;
< import traJ.TrajectoryModified;
< 
< public class PowerLawFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private int minlag;
<    private int maxlag;
<    private AbstractMeanSquaredDisplacmentEvaluatorModified msdeval;
<    private int evaluateIndex = 0;
<    private boolean useInitialGuess;
<    private double initalDiffusionCoefficient;
<    private double initalAlpha;
<    private double fps;
<    private double timelag;
< 
<    public PowerLawFeatureModified(TrajectoryModified t, double fps, int minlag, int maxlag) {
<       this.t = t;
<       this.minlag = minlag;
<       this.maxlag = maxlag;
<       this.fps = fps;
<       this.timelag = 1.0D / fps;
<       this.msdeval = new MeanSquaredDisplacmentFeatureModified((TrajectoryModified)null, 0);
<       ((MeanSquaredDisplacmentFeatureModified)this.msdeval).setOverlap(false);
<       this.evaluateIndex = 0;
<       this.useInitialGuess = false;
<    }
< 
<    public PowerLawFeatureModified(TrajectoryModified t, double fps, int minlag, int maxlag, double initalAlpha, double initialDiffusionCoefficient) {
<       this.t = t;
<       this.minlag = minlag;
<       this.maxlag = maxlag;
<       this.fps = fps;
<       this.timelag = 1.0D / fps;
<       this.msdeval = new MeanSquaredDisplacmentFeatureModified((TrajectoryModified)null, 0);
<       ((MeanSquaredDisplacmentFeatureModified)this.msdeval).setOverlap(false);
<       this.evaluateIndex = 0;
<       this.useInitialGuess = true;
<       this.initalAlpha = initalAlpha;
<       this.initalDiffusionCoefficient = initialDiffusionCoefficient;
<    }
< 
<    public double[] evaluate() {
<       ArrayList<Double> xDataList = new ArrayList();
<       ArrayList<Double> yDataList = new ArrayList();
<       this.msdeval.setTrajectory(this.t);
<       double[][] data = new double[this.maxlag - this.minlag + 1][3];
< 
<       int i;
<       double[] yData;
<       for(i = this.minlag; i <= this.maxlag; ++i) {
<          this.msdeval.setTimelag(i);
<          data[i - this.minlag][0] = (double)i * this.timelag;
<          yData = this.msdeval.evaluate();
<          data[i - this.minlag][1] = yData[this.evaluateIndex];
<          data[i - this.minlag][2] = (double)((int)yData[2]);
<       }
< 
<       for(i = 0; i < this.maxlag - this.minlag + 1; ++i) {
<          double x = data[i][0];
<          double y = data[i][1];
<          int np = (int)data[i][2];
< 
<          for(int j = 0; j < np; ++j) {
<             xDataList.add(x);
<             yDataList.add(y);
<          }
<       }
< 
<       double[] xData = ArrayUtils.toPrimitive((Double[])xDataList.toArray(new Double[0]));
<       yData = ArrayUtils.toPrimitive((Double[])yDataList.toArray(new Double[0]));
<       PowerLawCurveFitModified pwFit = new PowerLawCurveFitModified();
<       if (this.useInitialGuess) {
<          pwFit.doFit(xData, yData, this.initalAlpha, this.initalDiffusionCoefficient);
<       } else {
<          pwFit.doFit(xData, yData);
<       }
< 
<       this.result = new double[]{pwFit.getAlpha(), pwFit.getDiffusionCoefficient(), pwFit.getGoodness()};
<       return this.result;
<    }
< 
<    public void setEvaluateIndex(int evaluateIndex) {
<       this.evaluateIndex = evaluateIndex;
<    }
< 
<    public void setMeanSquaredDisplacmentEvaluator(AbstractMeanSquaredDisplacmentEvaluatorModified msdeval) {
<       this.msdeval = msdeval;
<    }
< 
<    public String getName() {
<       return "Power-Law-Feature";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< 
<    public String getShortName() {
<       return "POWER";
<    }
< }
---
> /*     */ package features;
> /*     */ 
> /*     */ import java.util.ArrayList;
> /*     */ import math.PowerLawCurveFitModified;
> /*     */ import org.apache.commons.lang3.ArrayUtils;
> /*     */ import traJ.TrajectoryModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class PowerLawFeatureModified
> /*     */   extends AbstractTrajectoryFeatureModified
> /*     */ {
> /*     */   private TrajectoryModified t;
> /*     */   private int minlag;
> /*     */   private int maxlag;
> /*     */   private AbstractMeanSquaredDisplacmentEvaluatorModified msdeval;
> /*  23 */   private int evaluateIndex = 0;
> /*     */   
> /*     */   private boolean useInitialGuess;
> /*     */   
> /*     */   private double initalDiffusionCoefficient;
> /*     */   
> /*     */   private double initalAlpha;
> /*     */   
> /*     */   private double fps;
> /*     */   
> /*     */   private double timelag;
> /*     */   
> /*     */   public PowerLawFeatureModified(TrajectoryModified t, double fps, int minlag, int maxlag) {
> /*  36 */     this.t = t;
> /*  37 */     this.minlag = minlag;
> /*  38 */     this.maxlag = maxlag;
> /*  39 */     this.fps = fps;
> /*  40 */     this.timelag = 1.0D / fps;
> /*  41 */     this.msdeval = new MeanSquaredDisplacmentFeatureModified(null, 0);
> /*  42 */     ((MeanSquaredDisplacmentFeatureModified)this.msdeval).setOverlap(false);
> /*  43 */     this.evaluateIndex = 0;
> /*  44 */     this.useInitialGuess = false;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public PowerLawFeatureModified(TrajectoryModified t, double fps, int minlag, int maxlag, double initalAlpha, double initialDiffusionCoefficient) {
> /*  57 */     this.t = t;
> /*  58 */     this.minlag = minlag;
> /*  59 */     this.maxlag = maxlag;
> /*  60 */     this.fps = fps;
> /*  61 */     this.timelag = 1.0D / fps;
> /*  62 */     this.msdeval = new MeanSquaredDisplacmentFeatureModified(null, 0);
> /*  63 */     ((MeanSquaredDisplacmentFeatureModified)this.msdeval).setOverlap(false);
> /*  64 */     this.evaluateIndex = 0;
> /*  65 */     this.useInitialGuess = true;
> /*  66 */     this.initalAlpha = initalAlpha;
> /*  67 */     this.initalDiffusionCoefficient = initialDiffusionCoefficient;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] evaluate() {
> /*  76 */     ArrayList<Double> xDataList = new ArrayList<>();
> /*  77 */     ArrayList<Double> yDataList = new ArrayList<>();
> /*  78 */     this.msdeval.setTrajectory(this.t);
> /*  79 */     double[][] data = new double[this.maxlag - this.minlag + 1][3];
> /*     */     int i;
> /*  81 */     for (i = this.minlag; i <= this.maxlag; i++) {
> /*  82 */       this.msdeval.setTimelag(i);
> /*  83 */       data[i - this.minlag][0] = i * this.timelag;
> /*  84 */       double[] res = this.msdeval.evaluate();
> /*  85 */       data[i - this.minlag][1] = res[this.evaluateIndex];
> /*  86 */       data[i - this.minlag][2] = (int)res[2];
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*  92 */     for (i = 0; i < this.maxlag - this.minlag + 1; i++) {
> /*  93 */       double x = data[i][0];
> /*  94 */       double y = data[i][1];
> /*  95 */       int np = (int)data[i][2];
> /*     */       
> /*  97 */       for (int j = 0; j < np; j++) {
> /*  98 */         xDataList.add(Double.valueOf(x));
> /*  99 */         yDataList.add(Double.valueOf(y));
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 103 */     double[] xData = ArrayUtils.toPrimitive(xDataList.<Double>toArray(new Double[0]));
> /* 104 */     double[] yData = ArrayUtils.toPrimitive(yDataList.<Double>toArray(new Double[0]));
> /*     */     
> /* 106 */     PowerLawCurveFitModified pwFit = new PowerLawCurveFitModified();
> /*     */     
> /* 108 */     if (this.useInitialGuess) {
> /* 109 */       pwFit.doFit(xData, yData, this.initalAlpha, this.initalDiffusionCoefficient);
> /*     */     } else {
> /* 111 */       pwFit.doFit(xData, yData);
> /*     */     } 
> /* 113 */     this.result = new double[] { pwFit.getAlpha(), pwFit.getDiffusionCoefficient(), pwFit.getGoodness() };
> /*     */     
> /* 115 */     return this.result;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void setEvaluateIndex(int evaluateIndex) {
> /* 123 */     this.evaluateIndex = evaluateIndex;
> /*     */   }
> /*     */   
> /*     */   public void setMeanSquaredDisplacmentEvaluator(AbstractMeanSquaredDisplacmentEvaluatorModified msdeval) {
> /* 127 */     this.msdeval = msdeval;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String getName() {
> /* 133 */     return "Power-Law-Feature";
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void setTrajectory(TrajectoryModified t) {
> /* 138 */     this.t = t;
> /* 139 */     this.result = null;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String getShortName() {
> /* 145 */     return "POWER";
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/PowerLawFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/QuartricMomentFeatureModified.java jd-gui/features/QuartricMomentFeatureModified.java
1,51c1,66
< package features;
< 
< import traJ.TrajectoryModified;
< import traJ.TrajectoryValidIndexTimelagIteratorModified;
< import vecmath.Point3dModified;
< 
< public class QuartricMomentFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
<    private int timelag;
<    private String shortname = "QMOMENT";
< 
<    public QuartricMomentFeatureModified(TrajectoryModified t, int timelag) {
<       this.t = t;
<       this.timelag = timelag;
<    }
< 
<    public double[] evaluate() {
<       double sum = 0.0D;
<       TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(this.t, this.timelag);
< 
<       int N;
<       for(N = 0; it.hasNext(); ++N) {
<          int i = it.next();
<          sum = sum + Math.pow(((Point3dModified)this.t.get(i)).x - ((Point3dModified)this.t.get(i + this.timelag)).x, 4.0D) + Math.pow(((Point3dModified)this.t.get(i)).y - ((Point3dModified)this.t.get(i + this.timelag)).y, 4.0D) + Math.pow(((Point3dModified)this.t.get(i)).z - ((Point3dModified)this.t.get(i + this.timelag)).z, 4.0D);
<       }
< 
<       this.result = new double[]{sum / (double)N};
<       return this.result;
<    }
< 
<    public void setTimelag(int timelag) {
<       this.timelag = timelag;
<    }
< 
<    public String getName() {
<       return "Quartric Moment";
<    }
< 
<    public String getShortName() {
<       return this.shortname;
<    }
< 
<    public void setShortName(String name) {
<       this.shortname = name;
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import traJ.TrajectoryModified;
> /*    */ import traJ.TrajectoryValidIndexTimelagIteratorModified;
> /*    */ import vecmath.Point3dModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class QuartricMomentFeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   private int timelag;
> /* 14 */   private String shortname = "QMOMENT";
> /*    */   
> /*    */   public QuartricMomentFeatureModified(TrajectoryModified t, int timelag) {
> /* 17 */     this.t = t;
> /* 18 */     this.timelag = timelag;
> /*    */   }
> /*    */   
> /*    */   public double[] evaluate() {
> /* 22 */     double sum = 0.0D;
> /* 23 */     TrajectoryValidIndexTimelagIteratorModified it = new TrajectoryValidIndexTimelagIteratorModified(this.t, this.timelag);
> /* 24 */     int N = 0;
> /* 25 */     while (it.hasNext()) {
> /* 26 */       int i = it.next().intValue();
> /* 27 */       sum = sum + 
> /* 28 */         Math.pow(((Point3dModified)this.t.get(i)).x - ((Point3dModified)this.t.get(i + this.timelag)).x, 4.0D) + 
> /* 29 */         Math.pow(((Point3dModified)this.t.get(i)).y - ((Point3dModified)this.t.get(i + this.timelag)).y, 4.0D) + 
> /* 30 */         Math.pow(((Point3dModified)this.t.get(i)).z - ((Point3dModified)this.t.get(i + this.timelag)).z, 4.0D);
> /* 31 */       N++;
> /*    */     } 
> /* 33 */     this.result = new double[] { sum / N };
> /* 34 */     return this.result;
> /*    */   }
> /*    */   
> /*    */   public void setTimelag(int timelag) {
> /* 38 */     this.timelag = timelag;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 43 */     return "Quartric Moment";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 48 */     return this.shortname;
> /*    */   }
> /*    */   
> /*    */   public void setShortName(String name) {
> /* 52 */     this.shortname = name;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 57 */     this.t = t;
> /* 58 */     this.result = null;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/QuartricMomentFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/StraightnessFeatureModified.java jd-gui/features/StraightnessFeatureModified.java
1,45c1,56
< package features;
< 
< import traJ.TrajectoryModified;
< import vecmath.Point3dModified;
< 
< public class StraightnessFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public StraightnessFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       this.result = new double[]{this.getStraightness()};
<       return this.result;
<    }
< 
<    public double getStraightness() {
<       double sum = 0.0D;
< 
<       for(int i = 1; i < this.t.size(); ++i) {
<          sum += ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(i - 1));
<       }
< 
<       if (sum < Math.pow(10.0D, -10.0D)) {
<          return 0.0D;
<       } else {
<          double straightness = ((Point3dModified)this.t.get(0)).distance((Point3dModified)this.t.get(this.t.size() - 1)) / sum;
<          return straightness;
<       }
<    }
< 
<    public String getName() {
<       return "Straightness";
<    }
< 
<    public String getShortName() {
<       return "STRAIGHTNESS";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import traJ.TrajectoryModified;
> /*    */ import vecmath.Point3dModified;
> /*    */ 
> /*    */ 
> /*    */ public class StraightnessFeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   
> /*    */   public StraightnessFeatureModified(TrajectoryModified t) {
> /* 13 */     this.t = t;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public double[] evaluate() {
> /* 18 */     this.result = new double[] { getStraightness() };
> /* 19 */     return this.result;
> /*    */   }
> /*    */   
> /*    */   public double getStraightness() {
> /* 23 */     double sum = 0.0D;
> /* 24 */     for (int i = 1; i < this.t.size(); i++) {
> /* 25 */       sum += ((Point3dModified)this.t.get(i)).distance((Point3dModified)this.t.get(i - 1));
> /*    */     }
> /* 27 */     if (sum < Math.pow(10.0D, -10.0D)) {
> /* 28 */       return 0.0D;
> /*    */     }
> /* 30 */     double straightness = ((Point3dModified)this.t.get(0)).distance((Point3dModified)this.t.get(this.t.size() - 1)) / sum;
> /* 31 */     return straightness;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 36 */     return "Straightness";
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 42 */     return "STRAIGHTNESS";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 47 */     this.t = t;
> /* 48 */     this.result = null;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/StraightnessFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/features/TrappedProbabilityFeatureModified.java jd-gui/features/TrappedProbabilityFeatureModified.java
1,36c1,67
< package features;
< 
< import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
< import traJ.TrajectoryModified;
< 
< public class TrappedProbabilityFeatureModified extends AbstractTrajectoryFeatureModified {
<    private TrajectoryModified t;
< 
<    public TrappedProbabilityFeatureModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double[] evaluate() {
<       MaxDistanceBetweenTwoPositionsFeatureModified dtwop = new MaxDistanceBetweenTwoPositionsFeatureModified(this.t);
<       double r = dtwop.evaluate()[0] / 2.0D;
<       RegressionDiffusionCoefficientEstimatorModified dcEst = new RegressionDiffusionCoefficientEstimatorModified(this.t, 1.0D, 1, 2);
<       double D = dcEst.evaluate()[0];
<       double time = (double)this.t.size();
<       double p = 1.0D - Math.exp(0.2048D - 2.5117D * (D * time / (r * r)));
<       this.result = new double[]{p};
<       return this.result;
<    }
< 
<    public String getName() {
<       return "Trapped trajectory probability";
<    }
< 
<    public String getShortName() {
<       return "TRAPPED";
<    }
< 
<    public void setTrajectory(TrajectoryModified t) {
<       this.t = t;
<       this.result = null;
<    }
< }
---
> /*    */ package features;
> /*    */ 
> /*    */ import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
> /*    */ import traJ.TrajectoryModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class TrappedProbabilityFeatureModified
> /*    */   extends AbstractTrajectoryFeatureModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   
> /*    */   public TrappedProbabilityFeatureModified(TrajectoryModified t) {
> /* 27 */     this.t = t;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public double[] evaluate() {
> /* 32 */     MaxDistanceBetweenTwoPositionsFeatureModified dtwop = new MaxDistanceBetweenTwoPositionsFeatureModified(this.t);
> /* 33 */     double r = dtwop.evaluate()[0] / 2.0D;
> /*    */ 
> /*    */     
> /* 36 */     RegressionDiffusionCoefficientEstimatorModified dcEst = new RegressionDiffusionCoefficientEstimatorModified(this.t, 1.0D, 1, 2);
> /* 37 */     double D = dcEst.evaluate()[0];
> /* 38 */     double time = this.t.size();
> /*    */     
> /* 40 */     double p = 1.0D - Math.exp(0.2048D - 2.5117D * D * time / r * r);
> /* 41 */     this.result = new double[] { p };
> /* 42 */     return this.result;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public String getName() {
> /* 48 */     return "Trapped trajectory probability";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String getShortName() {
> /* 53 */     return "TRAPPED";
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void setTrajectory(TrajectoryModified t) {
> /* 58 */     this.t = t;
> /* 59 */     this.result = null;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/features/TrappedProbabilityFeatureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: FirstWizardPanel$10$1.java
Only in jd-gui: FirstWizardPanel$10.java
Only in jd-gui: FirstWizardPanel$11$1.java
Only in jd-gui: FirstWizardPanel$11.java
Only in jd-gui: FirstWizardPanel$12$1.java
Only in jd-gui: FirstWizardPanel$12.java
Only in jd-gui: FirstWizardPanel$13$1.java
Only in jd-gui: FirstWizardPanel$13.java
Only in jd-gui: FirstWizardPanel$14$1.java
Only in jd-gui: FirstWizardPanel$14.java
Only in jd-gui: FirstWizardPanel$15$1.java
Only in jd-gui: FirstWizardPanel$15.java
Only in jd-gui: FirstWizardPanel$16$1.java
Only in jd-gui: FirstWizardPanel$16.java
Only in jd-gui: FirstWizardPanel$17$1.java
Only in jd-gui: FirstWizardPanel$17.java
Only in jd-gui: FirstWizardPanel$18$1.java
Only in jd-gui: FirstWizardPanel$18.java
Only in jd-gui: FirstWizardPanel$19$1.java
Only in jd-gui: FirstWizardPanel$19.java
Only in jd-gui: FirstWizardPanel$1.java
Only in jd-gui: FirstWizardPanel$2$1.java
Only in jd-gui: FirstWizardPanel$20.java
Only in jd-gui: FirstWizardPanel$2.java
Only in jd-gui: FirstWizardPanel$3$1.java
Only in jd-gui: FirstWizardPanel$3.java
Only in jd-gui: FirstWizardPanel$4$1.java
Only in jd-gui: FirstWizardPanel$4.java
Only in jd-gui: FirstWizardPanel$5$1.java
Only in jd-gui: FirstWizardPanel$5.java
Only in jd-gui: FirstWizardPanel$6$1.java
Only in jd-gui: FirstWizardPanel$6.java
Only in jd-gui: FirstWizardPanel$7$1.java
Only in jd-gui: FirstWizardPanel$7.java
Only in jd-gui: FirstWizardPanel$8$1.java
Only in jd-gui: FirstWizardPanel$8.java
Only in jd-gui: FirstWizardPanel$9$1.java
Only in jd-gui: FirstWizardPanel$9.java
diff -r TrackAnalyzer_/FirstWizardPanel.java jd-gui/FirstWizardPanel.java
1,1050c1,1066
< import fiji.plugin.trackmate.Spot;
< import fiji.plugin.trackmate.SpotCollection;
< import ij.IJ;
< import ij.ImagePlus;
< import ij.ImageStack;
< import ij.gui.Roi;
< import ij.io.FileInfo;
< import ij.measure.Calibration;
< import ij.measure.ResultsTable;
< import ij.process.ColorProcessor;
< import java.awt.BasicStroke;
< import java.awt.BorderLayout;
< import java.awt.Color;
< import java.awt.Dimension;
< import java.awt.FlowLayout;
< import java.awt.Font;
< import java.awt.Graphics2D;
< import java.awt.Image;
< import java.awt.Rectangle;
< import java.awt.RenderingHints;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.ItemEvent;
< import java.awt.event.ItemListener;
< import java.awt.image.BufferedImage;
< import java.awt.image.ImageObserver;
< import java.io.File;
< import java.io.IOException;
< import java.net.URL;
< import java.util.ArrayList;
< import java.util.List;
< import javax.swing.BorderFactory;
< import javax.swing.Box;
< import javax.swing.BoxLayout;
< import javax.swing.DefaultListModel;
< import javax.swing.Icon;
< import javax.swing.ImageIcon;
< import javax.swing.JButton;
< import javax.swing.JCheckBox;
< import javax.swing.JComboBox;
< import javax.swing.JFileChooser;
< import javax.swing.JFrame;
< import javax.swing.JLabel;
< import javax.swing.JList;
< import javax.swing.JPanel;
< import javax.swing.JScrollPane;
< import javax.swing.JSeparator;
< import javax.swing.JSlider;
< import javax.swing.JSpinner;
< import javax.swing.JTabbedPane;
< import javax.swing.JTable;
< import javax.swing.JToggleButton;
< import javax.swing.ListSelectionModel;
< import javax.swing.SpinnerNumberModel;
< import javax.swing.event.ChangeEvent;
< import javax.swing.event.ChangeListener;
< import javax.swing.table.DefaultTableCellRenderer;
< import javax.swing.table.DefaultTableModel;
< import jwizardcomponent.JWizardComponents;
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.plot.IntervalMarker;
< 
< public class FirstWizardPanel extends LabelWizardPanel {
<    private static final long serialVersionUID = 1L;
<    static JTable tableImages;
<    static JTable tableSpot;
<    static DefaultTableModel modelImages;
<    static DefaultTableModel modelSpot;
<    static ImagePlus[] imps;
<    static ImagePlus[] impsPZ;
<    ImageIcon[] icons;
<    Thread mainProcess;
<    ImagePlus impAnal;
<    static String command = "";
<    static String spotEnable = "";
<    List<Spot> removedSpots;
<    List<Spot> spots;
<    JSpinner filterMin;
<    JSpinner filterMax;
<    ChartPanel histogram;
<    HistogramFilterVersion hs2 = new HistogramFilterVersion();
<    IntervalMarker intervalMarker;
<    JCheckBox checkRPicker;
<    static JList<String> classList;
<    static JList<String> featureList;
<    static DefaultListModel<String> modelListClass;
<    static DefaultListModel<String> modelListFeature;
<    static JComboBox<String> comboFilters;
<    static JLabel labelReset;
<    List<Integer> indexesToReset;
<    List<Integer> spotID;
<    List<Integer> spotIDTI;
<    List<Integer> spotIDTO;
<    List<Integer> indexesTI;
<    List<Integer> indexesTO;
<    static JScrollPane jScrollPaneImages;
<    static JScrollPane jScrollPaneSpot;
<    static Icon iconSpotCell;
<    static Icon refreshCell;
<    static Object[] columnNamesSpot;
<    Thread refreshThread;
<    Thread csvThread;
<    Thread pngThread;
<    Thread paintThread;
<    Thread tInsideThread;
<    Thread tOutsideThread;
<    Thread enableThread;
<    Thread disableThread;
<    Thread slMinThread;
<    Thread filterMinThread;
<    Thread slMaxThread;
<    Thread filterMaxThread;
<    Thread filtersThread;
<    Thread pickerThread;
<    Thread classThread;
<    Thread remClassThread;
<    Thread addThread;
<    Thread remThread;
< 
<    public FirstWizardPanel(JWizardComponents wizardComponents) {
<       super(wizardComponents, "");
<       File imageFolder = new File(TrackAnalyzer_.textImages.getText());
<       File[] listOfFiles = imageFolder.listFiles();
<       String[] imageTitles = new String[listOfFiles.length];
<       File[] filesXML = new File[listOfFiles.length];
< 
<       int i;
<       for(i = 0; i < filesXML.length; ++i) {
<          filesXML[i] = new File(TrackAnalyzer_.textXml.getText());
<       }
< 
<       impsPZ = new ImagePlus[imageTitles.length];
<       imps = new ImagePlus[imageTitles.length];
<       this.icons = new ImageIcon[imps.length];
< 
<       for(i = 0; i < listOfFiles.length; ++i) {
<          if (listOfFiles[i].isFile()) {
<             imageTitles[i] = listOfFiles[i].getName();
<          }
< 
<          imps[i] = IJ.openImage(TrackAnalyzer_.textImages.getText() + "/" + imageTitles[i]);
<          impsPZ[i] = this.extractTFrame(imps[i], 1);
<          this.icons[i] = new ImageIcon(getScaledImage(impsPZ[i].getImage(), 90, 95));
<       }
< 
<       tableImages = new JTable();
<       tableSpot = new JTable();
<       modelImages = new DefaultTableModel();
<       modelSpot = new DefaultTableModel();
<       Object[] columnNames = new Object[]{"Movie", "Title", "Extension"};
<       columnNamesSpot = new Object[]{"ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MEAN_INTENSITY", "MEDIAN_INTENSITY", "MIN_INTENSITY", "MAX_INTENSITY", "TOTAL_INTENSITY", "STANDARD_DEVIATION", "CONTRAST", "SNR", "ESTIMATED_DIAMETER", "MORPHOLOGY", "ELLIPSOIDFIT_SEMIAXISLENGTH_C", "ELLIPSOIDFIT_SEMIAXISLENGTH_B", "ELLIPSOIDFIT_SEMIAXISLENGTH_A", "ELLIPSOIDFIT_AXISPHI_C", "ELLIPSOIDFIT_AXISPHI_B", "ELLIPSOIDFIT_AXISPHI_A", "ELLIPSOIDFIT_AXISTHETA_C", "ELLIPSOIDFIT_AXISTHETA_B", "ELLIPSOIDFIT_AXISTHETA_A", "MANUAL_COLOR"};
<       Object[][] data = new Object[imps.length][columnNames.length];
< 
<       for(int i = 0; i < data.length; ++i) {
<          for(int j = 0; j < data[i].length; ++j) {
<             data[i][j] = "";
<          }
<       }
< 
<       modelSpot = new DefaultTableModel();
<       modelImages = new DefaultTableModel(data, columnNames) {
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
<             }
< 
<             return super.getColumnClass(column);
<          }
<       };
<       tableImages.setModel(modelImages);
<       tableSpot.setModel(modelSpot);
<       tableSpot.setSelectionMode(1);
<       tableImages.getColumnModel().getColumn(0).setPreferredWidth(90);
<       tableImages.getColumnModel().getColumn(1).setPreferredWidth(460);
<       tableImages.getColumnModel().getColumn(2).setPreferredWidth(80);
<       jScrollPaneImages = new JScrollPane(tableImages);
<       jScrollPaneSpot = new JScrollPane(tableSpot);
<       jScrollPaneImages.setPreferredSize(new Dimension(590, 240));
<       jScrollPaneSpot.setPreferredSize(new Dimension(590, 240));
<       JPanel mainPanel = new JPanel();
<       mainPanel.setLayout(new BoxLayout(mainPanel, 1));
<       jScrollPaneImages.setBorder(BorderFactory.createTitledBorder(""));
<       jScrollPaneSpot.setBorder(BorderFactory.createTitledBorder(""));
<       JTabbedPane tabbedPaneSpot = new JTabbedPane(1);
<       ImageIcon iconSpot = createImageIcon("images/spot.png");
<       iconSpotCell = new ImageIcon(iconSpot.getImage().getScaledInstance(18, 20, 4));
<       JButton pngButton = new JButton();
<       ImageIcon iconPng = createImageIcon("images/save.png");
<       Icon pngCell = new ImageIcon(iconPng.getImage().getScaledInstance(18, 20, 4));
<       pngButton.setIcon(pngCell);
<       pngButton.setToolTipText("Click to capture spots overlay.");
<       JPanel panelPng = new JPanel(new FlowLayout(0));
<       panelPng.add(pngButton);
<       JButton csvButton = new JButton();
<       ImageIcon iconCsv = createImageIcon("images/csv.png");
<       Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
<       csvButton.setIcon(csvCell);
<       csvButton.setToolTipText("Click to export your spots table selection.");
<       JPanel panelCsv = new JPanel(new FlowLayout(0));
<       panelCsv.add(csvButton);
<       JPanel panelPngCsv = new JPanel(new FlowLayout(0));
<       panelPngCsv.add(panelPng);
<       panelPngCsv.add(panelCsv);
<       tabbedPaneSpot.addTab("SPOTS ", iconSpotCell, mainPanel, "Display Spot Analysis");
<       tabbedPaneSpot.setTabLayoutPolicy(1);
<       JButton refreshButton = new JButton();
<       ImageIcon iconRefresh = createImageIcon("images/refresh.png");
<       refreshCell = new ImageIcon(iconRefresh.getImage().getScaledInstance(18, 20, 4));
<       refreshButton.setIcon(refreshCell);
<       refreshButton.setToolTipText("Click this button to get spot analysis");
<       JToggleButton paintButton = new JToggleButton();
<       ImageIcon iconPaint = createImageIcon("images/paint.png");
<       Icon paintCell = new ImageIcon(iconPaint.getImage().getScaledInstance(18, 20, 4));
<       paintButton.setIcon(paintCell);
<       paintButton.setToolTipText("Click this button to display labeled-spots");
<       JToggleButton tInsideButton = new JToggleButton();
<       ImageIcon iconTI = createImageIcon("images/tinside.png");
<       Icon TICell = new ImageIcon(iconTI.getImage().getScaledInstance(18, 20, 4));
<       tInsideButton.setIcon(TICell);
<       tInsideButton.setToolTipText("Click this button to toggle inside spots.");
<       JToggleButton tOutsideButton = new JToggleButton();
<       ImageIcon iconTO = createImageIcon("images/toutside.png");
<       Icon TOCell = new ImageIcon(iconTO.getImage().getScaledInstance(18, 20, 4));
<       tOutsideButton.setIcon(TOCell);
<       tOutsideButton.setToolTipText("Click this button to toggle outside spots.");
<       JButton enableButton = new JButton();
<       ImageIcon iconEnable = createImageIcon("images/enable.png");
<       Icon enableCell = new ImageIcon(iconEnable.getImage().getScaledInstance(18, 20, 4));
<       enableButton.setIcon(enableCell);
<       enableButton.setToolTipText("Click this button to enable your selection");
<       JButton disableButton = new JButton();
<       ImageIcon iconDisable = createImageIcon("images/disable.png");
<       Icon disableCell = new ImageIcon(iconDisable.getImage().getScaledInstance(18, 20, 4));
<       disableButton.setIcon(disableCell);
<       disableButton.setToolTipText("Click this button to disable your selection");
<       JPanel buttonPanel = new JPanel(new FlowLayout(2));
<       JSeparator separator1 = new JSeparator(1);
<       JSeparator separator2 = new JSeparator(1);
<       Dimension dime = separator1.getPreferredSize();
<       dime.height = refreshButton.getPreferredSize().height;
<       separator1.setPreferredSize(dime);
<       separator2.setPreferredSize(dime);
<       this.checkRPicker = new JCheckBox(" Spot Picker");
<       JLabel filterLabel = new JLabel("   Spot Analysis : ");
<       filterLabel.setFont(new Font("Dialog", 1, 13));
<       filterLabel.setBorder(BorderFactory.createRaisedBevelBorder());
<       JPanel filterPanel = new JPanel(new FlowLayout(0));
<       filterPanel.add(filterLabel);
<       filterPanel.add(this.checkRPicker);
<       filterPanel.add(Box.createHorizontalStrut(20));
<       JPanel filterMain = new JPanel(new FlowLayout(0));
<       filterMain.add(filterPanel);
<       buttonPanel.add(refreshButton);
<       buttonPanel.add(paintButton);
<       buttonPanel.add(separator1);
<       buttonPanel.add(enableButton);
<       buttonPanel.add(disableButton);
<       buttonPanel.add(separator2);
<       buttonPanel.add(tInsideButton);
<       buttonPanel.add(tOutsideButton);
<       filterMain.add(buttonPanel);
<       mainPanel.add(jScrollPaneImages);
<       mainPanel.add(Box.createVerticalStrut(5));
<       mainPanel.add(filterMain);
<       mainPanel.add(jScrollPaneSpot);
<       JLabel settingsLabel = new JLabel("   Settings for Filters/Classes : ");
<       settingsLabel.setFont(new Font("Dialog", 1, 13));
<       settingsLabel.setBorder(BorderFactory.createRaisedBevelBorder());
<       JPanel settingsPanel = new JPanel(new FlowLayout(0));
<       settingsPanel.add(settingsLabel);
<       mainPanel.add(settingsPanel);
<       JPanel filtersMin = new JPanel(new FlowLayout(0));
<       this.filterMin = new JSpinner(new SpinnerNumberModel(30, 0, 5000, 1));
<       this.filterMin.setPreferredSize(new Dimension(60, 20));
<       final JSlider sliderMin = new JSlider(0, 300, 50);
<       sliderMin.setPreferredSize(new Dimension(150, 15));
<       JLabel filterMinLabel = new JLabel("              Min :  ");
<       filtersMin.add(filterMinLabel);
<       filtersMin.add(sliderMin);
<       filtersMin.add(Box.createHorizontalStrut(2));
<       filtersMin.add(this.filterMin);
<       JPanel filtersMax = new JPanel(new FlowLayout(0));
<       this.filterMax = new JSpinner(new SpinnerNumberModel(200, 0, 5000, 1));
<       this.filterMax.setPreferredSize(new Dimension(60, 20));
<       final JSlider sliderMax = new JSlider(0, 300, 150);
<       sliderMax.setPreferredSize(new Dimension(150, 15));
<       JLabel filterMaxLabel = new JLabel("              Max :  ");
<       filtersMax.add(filterMaxLabel);
<       filtersMax.add(sliderMax);
<       filtersMax.add(Box.createHorizontalStrut(2));
<       filtersMax.add(this.filterMax);
<       JPanel boxPanel2 = new JPanel();
<       boxPanel2.setLayout(new BoxLayout(boxPanel2, 1));
<       final IntervalMarker intervalMarker = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.5F);
<       this.histogram = this.hs2.createChartPanel("", new double[]{0.0D, 0.0D, 0.0D}, 100, intervalMarker);
<       JPanel chartPanel2 = new JPanel(new BorderLayout());
<       chartPanel2.setPreferredSize(new Dimension(390, 180));
<       chartPanel2.add(this.histogram);
<       boxPanel2.add(chartPanel2);
<       JPanel controlPanel2 = this.hs2.createControlPanel();
<       boxPanel2.add(controlPanel2);
<       JPanel filtersMain2 = new JPanel();
<       filtersMain2.setLayout(new BoxLayout(filtersMain2, 1));
<       filtersMain2.add(boxPanel2);
<       filtersMain2.add(filtersMin);
<       filtersMain2.add(filtersMax);
<       JLabel featureSpot = new JLabel("  Spot-Features :  ");
<       featureSpot.setFont(new Font("Dialog", 1, 13));
<       comboFilters = new JComboBox();
< 
<       for(int i = 0; i < columnNamesSpot.length; ++i) {
<          comboFilters.addItem((String)columnNamesSpot[i]);
<       }
< 
<       comboFilters.setPreferredSize(new Dimension(130, 25));
<       comboFilters.setSelectedIndex(0);
<       comboFilters.setOpaque(true);
<       JPanel panelFilters = new JPanel(new FlowLayout(0));
<       JSeparator separator3 = new JSeparator(1);
<       Dimension dime2 = separator3.getPreferredSize();
<       dime2.height = filtersMain2.getPreferredSize().height;
<       separator3.setPreferredSize(dime2);
<       panelFilters.add(filtersMain2);
<       panelFilters.add(separator3);
<       modelListClass = new DefaultListModel();
<       classList = new JList(modelListClass);
<       modelListFeature = new DefaultListModel();
<       featureList = new JList(modelListFeature);
<       final ColorEditorSpot colorEditor = new ColorEditorSpot(featureList);
<       JScrollPane scrollListFilter = new JScrollPane(featureList);
<       JScrollPane scrollListClass = new JScrollPane(classList);
<       Dimension d = featureList.getPreferredSize();
<       d.width = 150;
<       d.height = 90;
<       scrollListFilter.setPreferredSize(d);
<       scrollListClass.setPreferredSize(d);
<       JPanel filterPanelButtons = new JPanel(new FlowLayout(0));
<       JPanel classPanelButtons = new JPanel();
<       classPanelButtons.setLayout(new BoxLayout(classPanelButtons, 1));
<       filterPanelButtons.add(scrollListFilter);
<       JPanel fButtonsPanel = new JPanel();
<       fButtonsPanel.setLayout(new BoxLayout(fButtonsPanel, 1));
<       JButton addButton = new JButton();
<       ImageIcon iconAdd = createImageIcon("images/add.png");
<       Icon addCell = new ImageIcon(iconAdd.getImage().getScaledInstance(14, 16, 4));
<       addButton.setIcon(addCell);
<       addButton.setToolTipText("Click this button to add features");
<       JButton remButton = new JButton();
<       ImageIcon iconRem = createImageIcon("images/remove.png");
<       Icon remCell = new ImageIcon(iconRem.getImage().getScaledInstance(14, 16, 4));
<       remButton.setIcon(remCell);
<       remButton.setToolTipText("Click this button to remove features");
<       JButton classButton = new JButton();
<       ImageIcon iconClass = createImageIcon("images/classes.png");
<       Icon classCell = new ImageIcon(iconClass.getImage().getScaledInstance(14, 16, 4));
<       classButton.setIcon(classCell);
<       classButton.setToolTipText("Click this button to create a class.");
<       JButton remClassButton = new JButton();
<       remClassButton.setIcon(remCell);
<       remClassButton.setToolTipText("Click this button to remove a class.");
<       fButtonsPanel.add(addButton);
<       fButtonsPanel.add(remButton);
<       filterPanelButtons.add(fButtonsPanel);
<       classPanelButtons.add(classButton);
<       classPanelButtons.add(remClassButton);
<       JPanel classPanel = new JPanel(new FlowLayout(0));
<       classPanel.add(scrollListClass);
<       classPanel.add(classPanelButtons);
<       JPanel boxPanel = new JPanel();
<       boxPanel.setLayout(new BoxLayout(boxPanel, 1));
<       boxPanel.add(comboFilters);
<       boxPanel.add(Box.createHorizontalStrut(5));
<       boxPanel.add(filterPanelButtons);
<       boxPanel.add(Box.createHorizontalStrut(5));
<       boxPanel.add(classPanel);
<       boxPanel.add(panelPngCsv);
<       panelFilters.add(boxPanel);
<       mainPanel.add(panelFilters);
<       this.add(tabbedPaneSpot);
<       this.createMovieTable();
<       refreshButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.refreshThread = new Thread(new Runnable() {
<                public void run() {
<                   FirstWizardPanel.spotEnable = "spotEnable";
<                   ProcessTrackMateXml.tracksVisible = false;
<                   ProcessTrackMateXml.spotsVisible = true;
<                   ProcessTrackMateXml ptx = new ProcessTrackMateXml();
<                   ptx.processTrackMateXml();
<                }
<             });
<             FirstWizardPanel.this.refreshThread.start();
<          }
<       });
<       csvButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.csvThread = new Thread(new Runnable() {
<                public void run() {
<                   List<String> columnSpotHead = new ArrayList();
< 
<                   for(int j = 0; j < FirstWizardPanel.modelSpot.getColumnCount(); ++j) {
<                      columnSpotHead.add(FirstWizardPanel.modelSpot.getColumnName(j));
<                   }
< 
<                   ResultsTable rt = new ResultsTable(FirstWizardPanel.modelSpot.getRowCount());
<                   if (rt != null) {
<                      rt.reset();
<                   }
< 
<                   for(int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<                      for(int jx = 0; jx < FirstWizardPanel.modelSpot.getColumnCount(); ++jx) {
<                         if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE) {
<                            if (((String)columnSpotHead.get(jx)).equals(columnSpotHead.get(0)) == Boolean.TRUE) {
<                               rt.setValue((String)columnSpotHead.get(jx), i, ((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, jx)).getText());
<                            } else {
<                               rt.setValue((String)columnSpotHead.get(jx), i, FirstWizardPanel.modelSpot.getValueAt(i, jx).toString());
<                            }
<                         }
<                      }
<                   }
< 
<                   JFrame pngFrame = new JFrame();
<                   JFileChooser fileChooser = new JFileChooser();
<                   fileChooser.setFileSelectionMode(1);
<                   fileChooser.setDialogTitle("Specify a directory to save csv file");
<                   int userSelection = fileChooser.showSaveDialog(pngFrame);
<                   if (userSelection == 0) {
<                      File fileToSave = fileChooser.getSelectedFile();
< 
<                      try {
<                         rt.saveAs(fileToSave.getAbsolutePath() + File.separator + "SpotStatistics for-" + IJ.getImage().getShortTitle() + ".csv");
<                      } catch (IOException var8) {
<                         var8.printStackTrace();
<                      }
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.csvThread.start();
<          }
<       });
<       pngButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.pngThread = new Thread(new Runnable() {
<                public void run() {
<                   if (IJ.getImage() == null) {
<                      IJ.error("You must have an image window active.");
<                   }
< 
<                   if (IJ.getImage() != null) {
<                      JFrame pngFrame = new JFrame();
<                      JFileChooser fileChooser = new JFileChooser();
<                      fileChooser.setFileSelectionMode(1);
<                      fileChooser.setDialogTitle("Specify a directory to save");
<                      int userSelection = fileChooser.showSaveDialog(pngFrame);
<                      if (userSelection == 0) {
<                         File fileToSave = fileChooser.getSelectedFile();
<                         int firstFrame = 0;
<                         int lastFrame = 0;
<                         if (ProcessTrackMateXml.displayer.getImp().getNFrames() > 1) {
<                            firstFrame = Math.max(1, Math.min(IJ.getImage().getNFrames(), 1));
<                            lastFrame = Math.min(IJ.getImage().getNFrames(), Math.max(IJ.getImage().getNFrames(), 1));
<                         }
< 
<                         if (ProcessTrackMateXml.displayer.getImp().getNSlices() > 1) {
<                            firstFrame = Math.max(1, Math.min(IJ.getImage().getNSlices(), 1));
<                            lastFrame = Math.min(IJ.getImage().getNSlices(), Math.max(IJ.getImage().getNSlices(), 1));
<                         }
< 
<                         Rectangle bounds = ProcessTrackMateXml.displayer.getImp().getCanvas().getBounds();
<                         int width = bounds.width;
<                         int height = bounds.height;
<                         int nCaptures = lastFrame - firstFrame + 1;
<                         ImageStack stack = new ImageStack(width, height);
<                         int channel = ProcessTrackMateXml.displayer.getImp().getChannel();
<                         int slice = ProcessTrackMateXml.displayer.getImp().getSlice();
<                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(true);
< 
<                         for(int frame = firstFrame; frame <= lastFrame; ++frame) {
<                            ProcessTrackMateXml.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
<                            BufferedImage bi = new BufferedImage(width, height, 2);
<                            ProcessTrackMateXml.displayer.getImp().getCanvas().paint(bi.getGraphics());
<                            ColorProcessor cp = new ColorProcessor(bi);
<                            int index = ProcessTrackMateXml.displayer.getImp().getStackIndex(channel, slice, frame);
<                            stack.addSlice(ProcessTrackMateXml.displayer.getImp().getImageStack().getSliceLabel(index), cp);
<                         }
< 
<                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(false);
<                         ImagePlus capture = new ImagePlus("TrackMate capture of " + ProcessTrackMateXml.displayer.getImp().getShortTitle(), stack);
<                         FirstWizardPanel.transferCalibration(ProcessTrackMateXml.displayer.getImp(), capture);
<                         IJ.saveAs(capture, "Tiff", fileToSave.getAbsolutePath() + File.separator + "Capture Overlay for " + IJ.getImage().getShortTitle());
<                      }
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.pngThread.start();
<          }
<       });
<       paintButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             FirstWizardPanel.this.paintThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      FirstWizardPanel.this.paintAndDisableAction();
<                   } else if (ev.getStateChange() == 2) {
<                      FirstWizardPanel.this.resetAndEnableAction();
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.paintThread.start();
<          }
<       });
<       tInsideButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             FirstWizardPanel.this.tInsideThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      FirstWizardPanel.this.toggleInsideAction();
<                   } else if (ev.getStateChange() == 2) {
<                      FirstWizardPanel.this.resetToggleInsideAction();
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.tInsideThread.start();
<          }
<       });
<       tOutsideButton.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent ev) {
<             FirstWizardPanel.this.tOutsideThread = new Thread(new Runnable() {
<                public void run() {
<                   if (ev.getStateChange() == 1) {
<                      FirstWizardPanel.this.toggleOutsideAction();
<                   } else if (ev.getStateChange() == 2) {
<                      FirstWizardPanel.this.resetToggleOutsideAction();
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.tOutsideThread.start();
<          }
<       });
<       enableButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.enableThread = new Thread(new Runnable() {
<                public void run() {
<                   FirstWizardPanel.this.enableSpots();
<                }
<             });
<             FirstWizardPanel.this.enableThread.start();
<          }
<       });
<       disableButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.disableThread = new Thread(new Runnable() {
<                public void run() {
<                   FirstWizardPanel.this.disableSpots();
<                }
<             });
<             FirstWizardPanel.this.disableThread.start();
<          }
<       });
<       sliderMin.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             FirstWizardPanel.this.slMinThread = new Thread(new Runnable() {
<                public void run() {
<                   FirstWizardPanel.this.filterMin.setValue(sliderMin.getValue());
<                   intervalMarker.setStartValue((double)sliderMin.getValue());
<                }
<             });
<             FirstWizardPanel.this.slMinThread.start();
<          }
<       });
<       this.filterMin.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             FirstWizardPanel.this.filterMinThread = new Thread(new Runnable() {
<                public void run() {
<                   sliderMin.setValue((Integer)FirstWizardPanel.this.filterMin.getValue());
<                   intervalMarker.setStartValue((double)(Integer)FirstWizardPanel.this.filterMin.getValue());
<                }
<             });
<             FirstWizardPanel.this.filterMinThread.start();
<          }
<       });
<       sliderMax.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             FirstWizardPanel.this.slMaxThread = new Thread(new Runnable() {
<                public void run() {
<                   FirstWizardPanel.this.filterMax.setValue(sliderMax.getValue());
<                   intervalMarker.setEndValue((double)sliderMax.getValue());
<                }
<             });
<             FirstWizardPanel.this.slMaxThread.start();
<          }
<       });
<       this.filterMax.addChangeListener(new ChangeListener() {
<          public void stateChanged(ChangeEvent e) {
<             FirstWizardPanel.this.filterMaxThread = new Thread(new Runnable() {
<                public void run() {
<                   sliderMax.setValue((Integer)FirstWizardPanel.this.filterMax.getValue());
<                   intervalMarker.setEndValue((double)(Integer)FirstWizardPanel.this.filterMax.getValue());
<                }
<             });
<             FirstWizardPanel.this.filterMaxThread.start();
<          }
<       });
<       comboFilters.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.filtersThread = new Thread(new Runnable() {
<                public void run() {
<                   String selectedName = (String)FirstWizardPanel.comboFilters.getSelectedItem();
<                   int selectedIndex = FirstWizardPanel.comboFilters.getSelectedIndex();
<                   double[] valuesx = null;
<                   double[] values = new double[FirstWizardPanel.tableSpot.getRowCount()];
< 
<                   int i;
<                   for(i = 0; i < FirstWizardPanel.tableSpot.getRowCount(); ++i) {
<                      for(int c = 0; c < FirstWizardPanel.tableSpot.getColumnCount(); ++c) {
<                         values[i] = Double.parseDouble((String)FirstWizardPanel.tableSpot.getValueAt(i, selectedIndex + 2));
<                      }
<                   }
< 
<                   double max = values[0];
< 
<                   for(i = 1; i < values.length; ++i) {
<                      if (values[i] > max) {
<                         max = values[i];
<                      }
<                   }
< 
<                   sliderMin.setMinimum(0);
<                   sliderMin.setMaximum((int)max);
<                   sliderMax.setMinimum(0);
<                   sliderMax.setMaximum((int)max);
<                   FirstWizardPanel.this.hs2.addHistogramSeries(selectedName, values, (int)max, intervalMarker);
<                }
<             });
<             FirstWizardPanel.this.filtersThread.start();
<          }
<       });
<       this.checkRPicker.addItemListener(new ItemListener() {
<          public void itemStateChanged(final ItemEvent e) {
<             FirstWizardPanel.this.pickerThread = new Thread(new Runnable() {
<                public void run() {
<                   if (e.getStateChange() == 1) {
<                      FirstWizardPanel.command = "enable";
<                   }
< 
<                   if (e.getStateChange() == 2) {
<                      FirstWizardPanel.command = null;
<                      ProcessTrackMateXml.selectionModel.clearSpotSelection();
<                      ProcessTrackMateXml.selectionModel.clearSelection();
<                   }
<                }
<             });
<             FirstWizardPanel.this.pickerThread.start();
<          }
<       });
<       classButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.classThread = new Thread(new Runnable() {
<                public void run() {
<                   ColorEditorSpot.myFrame.setVisible(true);
<                   colorEditor.setClassAction();
<                }
<             });
<             FirstWizardPanel.this.classThread.start();
<          }
<       });
<       remClassButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.remClassThread = new Thread(new Runnable() {
<                public void run() {
<                   String classSelectedValue = (String)FirstWizardPanel.classList.getSelectedValue();
<                   int[] classSelectedIndex = FirstWizardPanel.classList.getSelectedIndices();
< 
<                   int i;
<                   for(i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<                      if (((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1))).getText().equals(classSelectedValue)) {
<                         FirstWizardPanel.modelSpot.setValueAt(FirstWizardPanel.labelReset, i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1));
<                      }
<                   }
< 
<                   for(i = 0; i < classSelectedIndex.length; ++i) {
<                      FirstWizardPanel.modelListClass.removeElementAt(classSelectedIndex[i]);
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.remClassThread.start();
<          }
<       });
<       addButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.addThread = new Thread(new Runnable() {
<                public void run() {
<                   List<String> listFilters = new ArrayList();
<                   if (FirstWizardPanel.featureList.getModel().getSize() < 1) {
<                      FirstWizardPanel.modelListFeature.addElement((String)FirstWizardPanel.comboFilters.getSelectedItem() + ":  [" + FirstWizardPanel.this.filterMin.getValue() + "," + FirstWizardPanel.this.filterMax.getValue() + "]");
<                   }
< 
<                   if (FirstWizardPanel.featureList.getModel().getSize() >= 1) {
<                      for(int i = 0; i < FirstWizardPanel.featureList.getModel().getSize(); ++i) {
<                         listFilters.add(String.valueOf(((String)FirstWizardPanel.featureList.getModel().getElementAt(i)).substring(0, ((String)FirstWizardPanel.featureList.getModel().getElementAt(i)).lastIndexOf(":"))));
<                      }
< 
<                      if (!listFilters.contains(FirstWizardPanel.comboFilters.getSelectedItem().toString())) {
<                         FirstWizardPanel.modelListFeature.addElement((String)FirstWizardPanel.comboFilters.getSelectedItem() + ":  [" + FirstWizardPanel.this.filterMin.getValue() + "," + FirstWizardPanel.this.filterMax.getValue() + "]");
<                      }
< 
<                      if (listFilters.contains(FirstWizardPanel.comboFilters.getSelectedItem().toString())) {
<                         return;
<                      }
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.addThread.start();
<          }
<       });
<       remButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             FirstWizardPanel.this.remThread = new Thread(new Runnable() {
<                public void run() {
<                   try {
<                      int[] indexes = FirstWizardPanel.featureList.getSelectedIndices();
< 
<                      for(int i = 0; i < indexes.length; ++i) {
<                         FirstWizardPanel.modelListFeature.remove(indexes[i]);
<                      }
<                   } catch (Exception var3) {
<                      var3.printStackTrace();
<                   }
< 
<                }
<             });
<             FirstWizardPanel.this.remThread.start();
<          }
<       });
<    }
< 
<    public void toggleOutsideAction() {
<       Roi mainRoi = null;
<       if (IJ.getImage().getRoi().getType() == 0) {
<          mainRoi = IJ.getImage().getRoi();
<       }
< 
<       this.indexesTO = new ArrayList();
< 
<       for(int i = 0; i < modelSpot.getRowCount(); ++i) {
<          if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(5)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(6)).toString()))) == Boolean.FALSE) {
<             this.indexesTO.add(i);
<             modelSpot.setValueAt(false, i, tableSpot.convertColumnIndexToModel(0));
<             int spotID = Integer.parseInt((String)tableSpot.getValueAt(i, 2));
<             Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
<             if (spot != null) {
<                spot.putFeature("VISIBILITY", SpotCollection.ZERO);
<                ProcessTrackMateXml.model.endUpdate();
<                ProcessTrackMateXml.displayer.refresh();
<             }
<          }
<       }
< 
<    }
< 
<    public void resetToggleOutsideAction() {
<       for(int row = 0; row < modelSpot.getRowCount(); ++row) {
<          modelSpot.setValueAt(true, tableSpot.convertRowIndexToModel(row), tableSpot.convertColumnIndexToModel(0));
<          int spotID = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
<          Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
<          if (spot != null) {
<             spot.putFeature("VISIBILITY", SpotCollection.ONE);
<             ProcessTrackMateXml.model.endUpdate();
<             ProcessTrackMateXml.displayer.refresh();
<          }
<       }
< 
<    }
< 
<    public void toggleInsideAction() {
<       Roi mainRoi = null;
<       if (IJ.getImage().getRoi().getType() == 0) {
<          mainRoi = IJ.getImage().getRoi();
<       }
< 
<       this.indexesTI = new ArrayList();
< 
<       for(int i = 0; i < modelSpot.getRowCount(); ++i) {
<          if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(5)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(6)).toString()))) == Boolean.TRUE) {
<             this.indexesTI.add(i);
<             modelSpot.setValueAt(false, i, tableSpot.convertColumnIndexToModel(0));
<             int spotID = Integer.parseInt((String)tableSpot.getValueAt(i, 2));
<             Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
<             if (spot != null) {
<                spot.putFeature("VISIBILITY", SpotCollection.ZERO);
<                ProcessTrackMateXml.model.endUpdate();
<                ProcessTrackMateXml.displayer.refresh();
<             }
<          }
<       }
< 
<    }
< 
<    public void resetToggleInsideAction() {
<       for(int row = 0; row < modelSpot.getRowCount(); ++row) {
<          modelSpot.setValueAt(true, tableSpot.convertRowIndexToModel(row), tableSpot.convertColumnIndexToModel(0));
<          int spotID = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
<          Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
<          if (spot != null) {
<             spot.putFeature("VISIBILITY", SpotCollection.ONE);
<             ProcessTrackMateXml.model.endUpdate();
<             ProcessTrackMateXml.displayer.refresh();
<          }
<       }
< 
<    }
< 
<    public void paintAndDisableAction() {
<       this.indexesToReset = new ArrayList();
<       this.spotID = new ArrayList();
<       this.spots = new ArrayList();
< 
<       int row;
<       for(row = 0; row < modelSpot.getRowCount(); ++row) {
<          if (((JLabel)modelSpot.getValueAt(row, tableSpot.convertColumnIndexToModel(1))).getBackground().equals(new Color(214, 217, 223)) == Boolean.TRUE) {
<             this.indexesToReset.add(row);
<             modelSpot.setValueAt(false, row, tableSpot.convertColumnIndexToModel(0));
<             this.spotID.add(Integer.parseInt((String)tableSpot.getValueAt(row, 2)));
<          }
<       }
< 
<       for(row = 0; row < this.indexesToReset.size(); ++row) {
<          int spotID = Integer.parseInt((String)tableSpot.getValueAt((Integer)this.indexesToReset.get(row), 2));
<          Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
<          if (spot != null) {
<             spot.putFeature("VISIBILITY", SpotCollection.ZERO);
<             ProcessTrackMateXml.model.endUpdate();
<             ProcessTrackMateXml.displayer.refresh();
<          }
<       }
< 
<    }
< 
<    public void resetAndEnableAction() {
<       int row;
<       for(row = 0; row < this.indexesToReset.size(); ++row) {
<          modelSpot.setValueAt(true, tableSpot.convertRowIndexToModel((Integer)this.indexesToReset.get(row)), tableSpot.convertColumnIndexToModel(0));
<       }
< 
<       for(row = 0; row < this.indexesToReset.size(); ++row) {
<          int spotID = Integer.parseInt((String)tableSpot.getValueAt((Integer)this.indexesToReset.get(row), 2));
<          Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
<          if (spot != null) {
<             spot.putFeature("VISIBILITY", SpotCollection.ONE);
<             ProcessTrackMateXml.model.endUpdate();
<             ProcessTrackMateXml.displayer.refresh();
<          }
<       }
< 
<    }
< 
<    public void enableSpots() {
<       ListSelectionModel lsm = tableSpot.getSelectionModel();
<       int[] selectedIndices = tableSpot.getSelectedRows();
< 
<       int selStart;
<       for(selStart = 0; selStart < selectedIndices.length; ++selStart) {
<          tableSpot.setValueAt(true, selectedIndices[selStart], 0);
<       }
< 
<       selStart = lsm.getMinSelectionIndex();
<       int selEnd = lsm.getMaxSelectionIndex();
<       if (selStart >= 0 && selEnd >= 0) {
<          int minLine = Math.min(selStart, selEnd);
<          int maxLine = Math.max(selStart, selEnd);
< 
<          for(int row = minLine; row <= maxLine; ++row) {
<             int spotIDEnable = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
<             Spot spotEnable = ProcessTrackMateXml.model.getSpots().search(spotIDEnable);
<             if (spotEnable != null) {
<                spotEnable.putFeature("VISIBILITY", SpotCollection.ONE);
<                ProcessTrackMateXml.model.endUpdate();
<                ProcessTrackMateXml.displayer.refresh();
<             }
<          }
< 
<       }
<    }
< 
<    public void disableSpots() {
<       ListSelectionModel lsm = tableSpot.getSelectionModel();
<       int selStart = lsm.getMinSelectionIndex();
<       int selEnd = lsm.getMaxSelectionIndex();
<       if (selStart >= 0 && selEnd >= 0) {
<          int minLine = Math.min(selStart, selEnd);
<          int maxLine = Math.max(selStart, selEnd);
< 
<          int i;
<          for(int row = minLine; row <= maxLine; ++row) {
<             i = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
<             Spot spot = ProcessTrackMateXml.model.getSpots().search(i);
<             if (spot != null) {
<                spot.putFeature("VISIBILITY", SpotCollection.ZERO);
<                ProcessTrackMateXml.model.endUpdate();
<                ProcessTrackMateXml.displayer.refresh();
<             }
<          }
< 
<          int[] selectedIndices = tableSpot.getSelectedRows();
< 
<          for(i = 0; i < selectedIndices.length; ++i) {
<             tableSpot.setValueAt(false, selectedIndices[i], 0);
<          }
< 
<       }
<    }
< 
<    public static void createSpotTable() {
<       modelSpot = new DefaultTableModel(ProcessTrackMateXml.dataSpot, ProcessTrackMateXml.columnHeadersSpot) {
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
<             }
< 
<             return super.getColumnClass(column);
<          }
<       };
<       modelSpot.addColumn("Enable");
<       tableSpot.setModel(modelSpot);
<       tableSpot.moveColumn(tableSpot.getColumnCount() - 1, 0);
<       tableSpot.setSelectionBackground(new Color(229, 255, 204));
<       tableSpot.setSelectionForeground(new Color(0, 102, 0));
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableSpot.setDefaultRenderer(String.class, centerRenderer);
<       tableSpot.setAutoResizeMode(0);
<       tableSpot.setRowHeight(45);
<       tableSpot.setAutoCreateRowSorter(true);
<       tableSpot.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
< 
<       int i;
<       for(i = 0; i < tableSpot.getColumnCount(); ++i) {
<          tableSpot.getColumnModel().getColumn(i).setPreferredWidth(90);
<       }
< 
<       for(i = 16; i < tableSpot.getColumnCount(); ++i) {
<          tableSpot.getColumnModel().getColumn(i).setPreferredWidth(150);
<       }
< 
<       for(i = 0; i < tableSpot.getRowCount(); ++i) {
<          tableSpot.setValueAt(true, i, 0);
<       }
< 
<       tableSpot.getColumnModel().getColumn(1).setCellRenderer(new Renderer());
<       labelReset = new JLabel();
<       labelReset.setText("");
<       labelReset.setOpaque(true);
<       labelReset.setBackground(new Color(214, 217, 223));
< 
<       for(i = 0; i < modelSpot.getRowCount(); ++i) {
<          modelSpot.setValueAt(labelReset, i, tableSpot.convertColumnIndexToModel(1));
<       }
< 
<    }
< 
<    public void createMovieTable() {
<       tableImages.setSelectionBackground(new Color(229, 255, 204));
<       tableImages.setSelectionForeground(new Color(0, 102, 0));
<       DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
<       centerRenderer.setHorizontalAlignment(0);
<       tableImages.setDefaultRenderer(String.class, centerRenderer);
<       tableImages.setAutoResizeMode(0);
<       tableImages.setRowHeight(95);
<       tableImages.setAutoCreateRowSorter(true);
<       tableImages.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
< 
<       for(int i = 0; i < modelImages.getRowCount(); ++i) {
<          modelImages.setValueAt(this.icons[i], i, tableImages.convertColumnIndexToModel(0));
<          modelImages.setValueAt(imps[i].getShortTitle(), i, tableImages.convertColumnIndexToModel(1));
<          modelImages.setValueAt(imps[i].getTitle().substring(imps[i].getTitle().lastIndexOf(".")), i, tableImages.convertColumnIndexToModel(2));
<       }
< 
<    }
< 
<    public static Image getScaledImage(Image srcImg, int w, int h) {
<       BufferedImage resizedImg = new BufferedImage(w, h, 1);
<       Graphics2D g2 = resizedImg.createGraphics();
<       g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
<       g2.drawImage(srcImg, 0, 0, w, h, (ImageObserver)null);
<       g2.dispose();
<       return resizedImg;
<    }
< 
<    public static ImageIcon createImageIcon(String path) {
<       URL imgURL = FirstWizardPanel.class.getResource(path);
<       if (imgURL != null) {
<          return new ImageIcon(imgURL);
<       } else {
<          System.err.println("Couldn't find file: " + path);
<          return null;
<       }
<    }
< 
<    public ImagePlus extractTFrame(ImagePlus imp, int frame) {
<       int width = imp.getWidth();
<       int height = imp.getHeight();
<       int channels = imp.getNChannels();
<       int zslices = imp.getNSlices();
<       FileInfo fileInfo = imp.getOriginalFileInfo();
<       ImageStack stack2 = new ImageStack(width, height);
<       ImagePlus imp2 = new ImagePlus();
<       imp2.setTitle("T" + frame + "-" + imp.getTitle());
< 
<       for(int z = 1; z <= zslices; ++z) {
<          for(int c = 1; c <= channels; ++c) {
<             int sliceSix = imp.getStackIndex(c, z, frame);
<             stack2.addSlice("", imp.getStack().getProcessor(sliceSix));
<          }
<       }
< 
<       imp2.setStack(stack2);
<       imp2.setDimensions(channels, zslices, 1);
<       if (channels * zslices > 1) {
<          imp2.setOpenAsHyperStack(true);
<       }
< 
<       imp2.setFileInfo(fileInfo);
<       return imp2;
<    }
< 
<    private static final void transferCalibration(ImagePlus from, ImagePlus to) {
<       Calibration fc = from.getCalibration();
<       Calibration tc = to.getCalibration();
<       tc.setUnit(fc.getUnit());
<       tc.setTimeUnit(fc.getTimeUnit());
<       tc.frameInterval = fc.frameInterval;
<       double mag = from.getCanvas().getMagnification();
<       tc.pixelWidth = fc.pixelWidth / mag;
<       tc.pixelHeight = fc.pixelHeight / mag;
<       tc.pixelDepth = fc.pixelDepth;
<    }
< }
---
> /*      */ import fiji.plugin.trackmate.Spot;
> /*      */ import fiji.plugin.trackmate.SpotCollection;
> /*      */ import ij.IJ;
> /*      */ import ij.ImagePlus;
> /*      */ import ij.ImageStack;
> /*      */ import ij.gui.Roi;
> /*      */ import ij.io.FileInfo;
> /*      */ import ij.measure.Calibration;
> /*      */ import ij.measure.ResultsTable;
> /*      */ import ij.process.ColorProcessor;
> /*      */ import ij.process.ImageProcessor;
> /*      */ import java.awt.BasicStroke;
> /*      */ import java.awt.BorderLayout;
> /*      */ import java.awt.Color;
> /*      */ import java.awt.Component;
> /*      */ import java.awt.Dimension;
> /*      */ import java.awt.FlowLayout;
> /*      */ import java.awt.Font;
> /*      */ import java.awt.Graphics2D;
> /*      */ import java.awt.Image;
> /*      */ import java.awt.Rectangle;
> /*      */ import java.awt.RenderingHints;
> /*      */ import java.awt.event.ActionEvent;
> /*      */ import java.awt.event.ActionListener;
> /*      */ import java.awt.event.ItemEvent;
> /*      */ import java.awt.event.ItemListener;
> /*      */ import java.awt.image.BufferedImage;
> /*      */ import java.io.File;
> /*      */ import java.io.IOException;
> /*      */ import java.net.URL;
> /*      */ import java.util.ArrayList;
> /*      */ import java.util.List;
> /*      */ import javax.swing.BorderFactory;
> /*      */ import javax.swing.Box;
> /*      */ import javax.swing.BoxLayout;
> /*      */ import javax.swing.DefaultListModel;
> /*      */ import javax.swing.Icon;
> /*      */ import javax.swing.ImageIcon;
> /*      */ import javax.swing.JButton;
> /*      */ import javax.swing.JCheckBox;
> /*      */ import javax.swing.JComboBox;
> /*      */ import javax.swing.JFileChooser;
> /*      */ import javax.swing.JFrame;
> /*      */ import javax.swing.JLabel;
> /*      */ import javax.swing.JList;
> /*      */ import javax.swing.JPanel;
> /*      */ import javax.swing.JScrollPane;
> /*      */ import javax.swing.JSeparator;
> /*      */ import javax.swing.JSlider;
> /*      */ import javax.swing.JSpinner;
> /*      */ import javax.swing.JTabbedPane;
> /*      */ import javax.swing.JTable;
> /*      */ import javax.swing.JToggleButton;
> /*      */ import javax.swing.ListSelectionModel;
> /*      */ import javax.swing.SpinnerNumberModel;
> /*      */ import javax.swing.event.ChangeEvent;
> /*      */ import javax.swing.event.ChangeListener;
> /*      */ import javax.swing.table.DefaultTableCellRenderer;
> /*      */ import javax.swing.table.DefaultTableModel;
> /*      */ import jwizardcomponent.JWizardComponents;
> /*      */ import org.jfree.chart.ChartPanel;
> /*      */ import org.jfree.chart.plot.IntervalMarker;
> /*      */ 
> /*      */ 
> /*      */ public class FirstWizardPanel
> /*      */   extends LabelWizardPanel
> /*      */ {
> /*      */   private static final long serialVersionUID = 1L;
> /*      */   static JTable tableImages;
> /*      */   static JTable tableSpot;
> /*      */   static DefaultTableModel modelImages;
> /*      */   static DefaultTableModel modelSpot;
> /*      */   static ImagePlus[] imps;
> /*      */   static ImagePlus[] impsPZ;
> /*      */   ImageIcon[] icons;
> /*      */   Thread mainProcess;
> /*      */   ImagePlus impAnal;
> /*   78 */   static String command = ""; static String spotEnable = ""; List<Spot> removedSpots; List<Spot> spots;
> /*      */   JSpinner filterMin;
> /*      */   JSpinner filterMax;
> /*      */   ChartPanel histogram;
> /*   82 */   HistogramFilterVersion hs2 = new HistogramFilterVersion(); IntervalMarker intervalMarker; JCheckBox checkRPicker; static JList<String> classList; static JList<String> featureList; static DefaultListModel<String> modelListClass;
> /*      */   static DefaultListModel<String> modelListFeature;
> /*      */   static JComboBox<String> comboFilters;
> /*      */   static JLabel labelReset;
> /*      */   List<Integer> indexesToReset;
> /*      */   List<Integer> spotID;
> /*      */   List<Integer> spotIDTI;
> /*      */   List<Integer> spotIDTO;
> /*      */   List<Integer> indexesTI;
> /*      */   List<Integer> indexesTO;
> /*      */   static JScrollPane jScrollPaneImages;
> /*      */   static JScrollPane jScrollPaneSpot;
> /*      */   static Icon iconSpotCell;
> /*      */   static Icon refreshCell;
> /*      */   
> /*      */   public FirstWizardPanel(JWizardComponents wizardComponents) {
> /*   98 */     super(wizardComponents, "");
> /*      */ 
> /*      */     
> /*  101 */     File imageFolder = new File(TrackAnalyzer_.textImages.getText());
> /*  102 */     File[] listOfFiles = imageFolder.listFiles();
> /*  103 */     String[] imageTitles = new String[listOfFiles.length];
> /*  104 */     File[] filesXML = new File[listOfFiles.length];
> /*      */     
> /*  106 */     for (int u = 0; u < filesXML.length; u++) {
> /*  107 */       filesXML[u] = new File(TrackAnalyzer_.textXml.getText());
> /*      */     }
> /*  109 */     impsPZ = new ImagePlus[imageTitles.length];
> /*  110 */     imps = new ImagePlus[imageTitles.length];
> /*  111 */     this.icons = new ImageIcon[imps.length];
> /*  112 */     for (int i = 0; i < listOfFiles.length; i++) {
> /*  113 */       if (listOfFiles[i].isFile())
> /*  114 */         imageTitles[i] = listOfFiles[i].getName(); 
> /*  115 */       imps[i] = IJ.openImage(String.valueOf(TrackAnalyzer_.textImages.getText()) + "/" + imageTitles[i]);
> /*  116 */       impsPZ[i] = extractTFrame(imps[i], 1);
> /*      */       
> /*  118 */       this.icons[i] = new ImageIcon(getScaledImage(impsPZ[i].getImage(), 90, 95));
> /*      */     } 
> /*      */     
> /*  121 */     tableImages = new JTable();
> /*      */     
> /*  123 */     tableSpot = new JTable();
> /*  124 */     modelImages = new DefaultTableModel();
> /*  125 */     modelSpot = new DefaultTableModel();
> /*  126 */     Object[] columnNames = { "Movie", "Title", "Extension" };
> /*  127 */     columnNamesSpot = new Object[] { "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", 
> /*  128 */         "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MEAN_INTENSITY", "MEDIAN_INTENSITY", "MIN_INTENSITY", 
> /*  129 */         "MAX_INTENSITY", "TOTAL_INTENSITY", "STANDARD_DEVIATION", "CONTRAST", "SNR", "ESTIMATED_DIAMETER", 
> /*  130 */         "MORPHOLOGY", "ELLIPSOIDFIT_SEMIAXISLENGTH_C", "ELLIPSOIDFIT_SEMIAXISLENGTH_B", 
> /*  131 */         "ELLIPSOIDFIT_SEMIAXISLENGTH_A", "ELLIPSOIDFIT_AXISPHI_C", "ELLIPSOIDFIT_AXISPHI_B", 
> /*  132 */         "ELLIPSOIDFIT_AXISPHI_A", "ELLIPSOIDFIT_AXISTHETA_C", "ELLIPSOIDFIT_AXISTHETA_B", 
> /*  133 */         "ELLIPSOIDFIT_AXISTHETA_A", "MANUAL_COLOR" };
> /*  134 */     Object[][] data = new Object[imps.length][columnNames.length];
> /*  135 */     for (int j = 0; j < data.length; j++) {
> /*  136 */       for (int m = 0; m < (data[j]).length; m++)
> /*  137 */         data[j][m] = ""; 
> /*      */     } 
> /*  139 */     modelSpot = new DefaultTableModel();
> /*  140 */     modelImages = new DefaultTableModel(data, columnNames)
> /*      */       {
> /*      */         public Class<?> getColumnClass(int column)
> /*      */         {
> /*  144 */           if (getRowCount() > 0) {
> /*  145 */             Object value = getValueAt(0, column);
> /*  146 */             if (value != null) {
> /*  147 */               return getValueAt(0, column).getClass();
> /*      */             }
> /*      */           } 
> /*      */           
> /*  151 */           return super.getColumnClass(column);
> /*      */         }
> /*      */       };
> /*      */     
> /*  155 */     tableImages.setModel(modelImages);
> /*  156 */     tableSpot.setModel(modelSpot);
> /*  157 */     tableSpot.setSelectionMode(1);
> /*  158 */     tableImages.getColumnModel().getColumn(0).setPreferredWidth(90);
> /*  159 */     tableImages.getColumnModel().getColumn(1).setPreferredWidth(460);
> /*  160 */     tableImages.getColumnModel().getColumn(2).setPreferredWidth(80);
> /*  161 */     jScrollPaneImages = new JScrollPane(tableImages);
> /*  162 */     jScrollPaneSpot = new JScrollPane(tableSpot);
> /*  163 */     jScrollPaneImages.setPreferredSize(new Dimension(590, 240));
> /*  164 */     jScrollPaneSpot.setPreferredSize(new Dimension(590, 240));
> /*  165 */     JPanel mainPanel = new JPanel();
> /*  166 */     mainPanel.setLayout(new BoxLayout(mainPanel, 1));
> /*  167 */     jScrollPaneImages.setBorder(BorderFactory.createTitledBorder(""));
> /*  168 */     jScrollPaneSpot.setBorder(BorderFactory.createTitledBorder(""));
> /*  169 */     JTabbedPane tabbedPaneSpot = new JTabbedPane(1);
> /*  170 */     ImageIcon iconSpot = createImageIcon("images/spot.png");
> /*  171 */     iconSpotCell = new ImageIcon(iconSpot.getImage().getScaledInstance(18, 20, 4));
> /*  172 */     JButton pngButton = new JButton();
> /*  173 */     ImageIcon iconPng = createImageIcon("images/save.png");
> /*  174 */     Icon pngCell = new ImageIcon(iconPng.getImage().getScaledInstance(18, 20, 4));
> /*  175 */     pngButton.setIcon(pngCell);
> /*  176 */     pngButton.setToolTipText("Click to capture spots overlay.");
> /*  177 */     JPanel panelPng = new JPanel(new FlowLayout(0));
> /*  178 */     panelPng.add(pngButton);
> /*  179 */     JButton csvButton = new JButton();
> /*  180 */     ImageIcon iconCsv = createImageIcon("images/csv.png");
> /*  181 */     Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
> /*  182 */     csvButton.setIcon(csvCell);
> /*  183 */     csvButton.setToolTipText("Click to export your spots table selection.");
> /*  184 */     JPanel panelCsv = new JPanel(new FlowLayout(0));
> /*  185 */     panelCsv.add(csvButton);
> /*  186 */     JPanel panelPngCsv = new JPanel(new FlowLayout(0));
> /*  187 */     panelPngCsv.add(panelPng);
> /*  188 */     panelPngCsv.add(panelCsv);
> /*  189 */     tabbedPaneSpot.addTab("SPOTS ", iconSpotCell, mainPanel, "Display Spot Analysis");
> /*  190 */     tabbedPaneSpot.setTabLayoutPolicy(1);
> /*  191 */     JButton refreshButton = new JButton();
> /*  192 */     ImageIcon iconRefresh = createImageIcon("images/refresh.png");
> /*  193 */     refreshCell = new ImageIcon(iconRefresh.getImage().getScaledInstance(18, 20, 4));
> /*  194 */     refreshButton.setIcon(refreshCell);
> /*  195 */     refreshButton.setToolTipText("Click this button to get spot analysis");
> /*  196 */     JToggleButton paintButton = new JToggleButton();
> /*  197 */     ImageIcon iconPaint = createImageIcon("images/paint.png");
> /*  198 */     Icon paintCell = new ImageIcon(iconPaint.getImage().getScaledInstance(18, 20, 4));
> /*  199 */     paintButton.setIcon(paintCell);
> /*  200 */     paintButton.setToolTipText("Click this button to display labeled-spots");
> /*  201 */     JToggleButton tInsideButton = new JToggleButton();
> /*  202 */     ImageIcon iconTI = createImageIcon("images/tinside.png");
> /*  203 */     Icon TICell = new ImageIcon(iconTI.getImage().getScaledInstance(18, 20, 4));
> /*  204 */     tInsideButton.setIcon(TICell);
> /*  205 */     tInsideButton.setToolTipText("Click this button to toggle inside spots.");
> /*  206 */     JToggleButton tOutsideButton = new JToggleButton();
> /*  207 */     ImageIcon iconTO = createImageIcon("images/toutside.png");
> /*  208 */     Icon TOCell = new ImageIcon(iconTO.getImage().getScaledInstance(18, 20, 4));
> /*  209 */     tOutsideButton.setIcon(TOCell);
> /*  210 */     tOutsideButton.setToolTipText("Click this button to toggle outside spots.");
> /*  211 */     JButton enableButton = new JButton();
> /*  212 */     ImageIcon iconEnable = createImageIcon("images/enable.png");
> /*  213 */     Icon enableCell = new ImageIcon(iconEnable.getImage().getScaledInstance(18, 20, 4));
> /*  214 */     enableButton.setIcon(enableCell);
> /*  215 */     enableButton.setToolTipText("Click this button to enable your selection");
> /*  216 */     JButton disableButton = new JButton();
> /*  217 */     ImageIcon iconDisable = createImageIcon("images/disable.png");
> /*  218 */     Icon disableCell = new ImageIcon(iconDisable.getImage().getScaledInstance(18, 20, 4));
> /*  219 */     disableButton.setIcon(disableCell);
> /*  220 */     disableButton.setToolTipText("Click this button to disable your selection");
> /*  221 */     JPanel buttonPanel = new JPanel(new FlowLayout(2));
> /*  222 */     JSeparator separator1 = new JSeparator(1);
> /*  223 */     JSeparator separator2 = new JSeparator(1);
> /*  224 */     Dimension dime = separator1.getPreferredSize();
> /*  225 */     dime.height = (refreshButton.getPreferredSize()).height;
> /*  226 */     separator1.setPreferredSize(dime);
> /*  227 */     separator2.setPreferredSize(dime);
> /*  228 */     this.checkRPicker = new JCheckBox(" Spot Picker");
> /*  229 */     JLabel filterLabel = new JLabel("   Spot Analysis : ");
> /*  230 */     filterLabel.setFont(new Font("Dialog", 1, 13));
> /*  231 */     filterLabel.setBorder(BorderFactory.createRaisedBevelBorder());
> /*  232 */     JPanel filterPanel = new JPanel(new FlowLayout(0));
> /*  233 */     filterPanel.add(filterLabel);
> /*  234 */     filterPanel.add(this.checkRPicker);
> /*  235 */     filterPanel.add(Box.createHorizontalStrut(20));
> /*  236 */     JPanel filterMain = new JPanel(new FlowLayout(0));
> /*  237 */     filterMain.add(filterPanel);
> /*  238 */     buttonPanel.add(refreshButton);
> /*  239 */     buttonPanel.add(paintButton);
> /*  240 */     buttonPanel.add(separator1);
> /*  241 */     buttonPanel.add(enableButton);
> /*  242 */     buttonPanel.add(disableButton);
> /*  243 */     buttonPanel.add(separator2);
> /*  244 */     buttonPanel.add(tInsideButton);
> /*  245 */     buttonPanel.add(tOutsideButton);
> /*  246 */     filterMain.add(buttonPanel);
> /*  247 */     mainPanel.add(jScrollPaneImages);
> /*  248 */     mainPanel.add(Box.createVerticalStrut(5));
> /*  249 */     mainPanel.add(filterMain);
> /*  250 */     mainPanel.add(jScrollPaneSpot);
> /*  251 */     JLabel settingsLabel = new JLabel("   Settings for Filters/Classes : ");
> /*  252 */     settingsLabel.setFont(new Font("Dialog", 1, 13));
> /*  253 */     settingsLabel.setBorder(BorderFactory.createRaisedBevelBorder());
> /*  254 */     JPanel settingsPanel = new JPanel(new FlowLayout(0));
> /*  255 */     settingsPanel.add(settingsLabel);
> /*  256 */     mainPanel.add(settingsPanel);
> /*  257 */     JPanel filtersMin = new JPanel(new FlowLayout(0));
> /*  258 */     this.filterMin = new JSpinner(new SpinnerNumberModel(30, 0, 5000, 1));
> /*  259 */     this.filterMin.setPreferredSize(new Dimension(60, 20));
> /*  260 */     final JSlider sliderMin = new JSlider(0, 300, 50);
> /*  261 */     sliderMin.setPreferredSize(new Dimension(150, 15));
> /*  262 */     JLabel filterMinLabel = new JLabel("              Min :  ");
> /*  263 */     filtersMin.add(filterMinLabel);
> /*  264 */     filtersMin.add(sliderMin);
> /*  265 */     filtersMin.add(Box.createHorizontalStrut(2));
> /*  266 */     filtersMin.add(this.filterMin);
> /*  267 */     JPanel filtersMax = new JPanel(new FlowLayout(0));
> /*  268 */     this.filterMax = new JSpinner(new SpinnerNumberModel(200, 0, 5000, 1));
> /*  269 */     this.filterMax.setPreferredSize(new Dimension(60, 20));
> /*  270 */     final JSlider sliderMax = new JSlider(0, 300, 150);
> /*  271 */     sliderMax.setPreferredSize(new Dimension(150, 15));
> /*  272 */     JLabel filterMaxLabel = new JLabel("              Max :  ");
> /*  273 */     filtersMax.add(filterMaxLabel);
> /*  274 */     filtersMax.add(sliderMax);
> /*  275 */     filtersMax.add(Box.createHorizontalStrut(2));
> /*  276 */     filtersMax.add(this.filterMax);
> /*  277 */     JPanel boxPanel2 = new JPanel();
> /*  278 */     boxPanel2.setLayout(new BoxLayout(boxPanel2, 1));
> /*  279 */     final IntervalMarker intervalMarker = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), 
> /*  280 */         new Color(0, 102, 0), new BasicStroke(1.5F), 0.5F);
> /*  281 */     this.histogram = this.hs2.createChartPanel("", new double[] { 0.0D, 0.0D, 0.0D }, 100, intervalMarker);
> /*      */     
> /*  283 */     JPanel chartPanel2 = new JPanel(new BorderLayout());
> /*  284 */     chartPanel2.setPreferredSize(new Dimension(390, 180));
> /*  285 */     chartPanel2.add((Component)this.histogram);
> /*  286 */     boxPanel2.add(chartPanel2);
> /*  287 */     JPanel controlPanel2 = this.hs2.createControlPanel();
> /*  288 */     boxPanel2.add(controlPanel2);
> /*  289 */     JPanel filtersMain2 = new JPanel();
> /*  290 */     filtersMain2.setLayout(new BoxLayout(filtersMain2, 1));
> /*  291 */     filtersMain2.add(boxPanel2);
> /*  292 */     filtersMain2.add(filtersMin);
> /*  293 */     filtersMain2.add(filtersMax);
> /*  294 */     JLabel featureSpot = new JLabel("  Spot-Features :  ");
> /*  295 */     featureSpot.setFont(new Font("Dialog", 1, 13));
> /*  296 */     comboFilters = new JComboBox<>();
> /*  297 */     for (int k = 0; k < columnNamesSpot.length; k++)
> /*  298 */       comboFilters.addItem((String)columnNamesSpot[k]); 
> /*  299 */     comboFilters.setPreferredSize(new Dimension(130, 25));
> /*  300 */     comboFilters.setSelectedIndex(0);
> /*  301 */     comboFilters.setOpaque(true);
> /*  302 */     JPanel panelFilters = new JPanel(new FlowLayout(0));
> /*  303 */     JSeparator separator3 = new JSeparator(1);
> /*  304 */     Dimension dime2 = separator3.getPreferredSize();
> /*  305 */     dime2.height = (filtersMain2.getPreferredSize()).height;
> /*  306 */     separator3.setPreferredSize(dime2);
> /*  307 */     panelFilters.add(filtersMain2);
> /*  308 */     panelFilters.add(separator3);
> /*  309 */     modelListClass = new DefaultListModel<>();
> /*  310 */     classList = new JList<>(modelListClass);
> /*  311 */     modelListFeature = new DefaultListModel<>();
> /*  312 */     featureList = new JList<>(modelListFeature);
> /*  313 */     final ColorEditorSpot colorEditor = new ColorEditorSpot(featureList);
> /*  314 */     JScrollPane scrollListFilter = new JScrollPane(featureList);
> /*  315 */     JScrollPane scrollListClass = new JScrollPane(classList);
> /*  316 */     Dimension d = featureList.getPreferredSize();
> /*  317 */     d.width = 150;
> /*  318 */     d.height = 90;
> /*  319 */     scrollListFilter.setPreferredSize(d);
> /*  320 */     scrollListClass.setPreferredSize(d);
> /*  321 */     JPanel filterPanelButtons = new JPanel(new FlowLayout(0));
> /*  322 */     JPanel classPanelButtons = new JPanel();
> /*  323 */     classPanelButtons.setLayout(new BoxLayout(classPanelButtons, 1));
> /*  324 */     filterPanelButtons.add(scrollListFilter);
> /*  325 */     JPanel fButtonsPanel = new JPanel();
> /*  326 */     fButtonsPanel.setLayout(new BoxLayout(fButtonsPanel, 1));
> /*  327 */     JButton addButton = new JButton();
> /*  328 */     ImageIcon iconAdd = createImageIcon("images/add.png");
> /*  329 */     Icon addCell = new ImageIcon(iconAdd.getImage().getScaledInstance(14, 16, 4));
> /*  330 */     addButton.setIcon(addCell);
> /*  331 */     addButton.setToolTipText("Click this button to add features");
> /*  332 */     JButton remButton = new JButton();
> /*  333 */     ImageIcon iconRem = createImageIcon("images/remove.png");
> /*  334 */     Icon remCell = new ImageIcon(iconRem.getImage().getScaledInstance(14, 16, 4));
> /*  335 */     remButton.setIcon(remCell);
> /*  336 */     remButton.setToolTipText("Click this button to remove features");
> /*  337 */     JButton classButton = new JButton();
> /*  338 */     ImageIcon iconClass = createImageIcon("images/classes.png");
> /*  339 */     Icon classCell = new ImageIcon(iconClass.getImage().getScaledInstance(14, 16, 4));
> /*  340 */     classButton.setIcon(classCell);
> /*  341 */     classButton.setToolTipText("Click this button to create a class.");
> /*  342 */     JButton remClassButton = new JButton();
> /*  343 */     remClassButton.setIcon(remCell);
> /*  344 */     remClassButton.setToolTipText("Click this button to remove a class.");
> /*  345 */     fButtonsPanel.add(addButton);
> /*  346 */     fButtonsPanel.add(remButton);
> /*  347 */     filterPanelButtons.add(fButtonsPanel);
> /*  348 */     classPanelButtons.add(classButton);
> /*  349 */     classPanelButtons.add(remClassButton);
> /*  350 */     JPanel classPanel = new JPanel(new FlowLayout(0));
> /*  351 */     classPanel.add(scrollListClass);
> /*  352 */     classPanel.add(classPanelButtons);
> /*  353 */     JPanel boxPanel = new JPanel();
> /*  354 */     boxPanel.setLayout(new BoxLayout(boxPanel, 1));
> /*  355 */     boxPanel.add(comboFilters);
> /*  356 */     boxPanel.add(Box.createHorizontalStrut(5));
> /*  357 */     boxPanel.add(filterPanelButtons);
> /*  358 */     boxPanel.add(Box.createHorizontalStrut(5));
> /*  359 */     boxPanel.add(classPanel);
> /*  360 */     boxPanel.add(panelPngCsv);
> /*  361 */     panelFilters.add(boxPanel);
> /*  362 */     mainPanel.add(panelFilters);
> /*  363 */     add(tabbedPaneSpot);
> /*  364 */     createMovieTable();
> /*      */     
> /*  366 */     refreshButton.addActionListener(new ActionListener()
> /*      */         {
> /*      */           public void actionPerformed(ActionEvent e) {
> /*  369 */             FirstWizardPanel.this.refreshThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  371 */                     FirstWizardPanel.spotEnable = "spotEnable";
> /*  372 */                     ProcessTrackMateXml.tracksVisible = false;
> /*  373 */                     ProcessTrackMateXml.spotsVisible = true;
> /*  374 */                     ProcessTrackMateXml ptx = new ProcessTrackMateXml();
> /*  375 */                     ptx.processTrackMateXml();
> /*      */                   }
> /*      */                 });
> /*  378 */             FirstWizardPanel.this.refreshThread.start();
> /*      */           }
> /*      */         });
> /*  381 */     csvButton.addActionListener(new ActionListener()
> /*      */         {
> /*      */           public void actionPerformed(ActionEvent e) {
> /*  384 */             FirstWizardPanel.this.csvThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  386 */                     List<String> columnSpotHead = new ArrayList<>();
> /*  387 */                     for (int j = 0; j < FirstWizardPanel.modelSpot.getColumnCount(); j++) {
> /*  388 */                       columnSpotHead.add(FirstWizardPanel.modelSpot.getColumnName(j));
> /*      */                     }
> /*  390 */                     ResultsTable rt = new ResultsTable(Integer.valueOf(FirstWizardPanel.modelSpot.getRowCount()));
> /*  391 */                     if (rt != null) {
> /*  392 */                       rt.reset();
> /*      */                     }
> /*  394 */                     for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); i++) {
> /*  395 */                       for (int k = 0; k < FirstWizardPanel.modelSpot.getColumnCount(); k++) {
> /*  396 */                         if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE)
> /*      */                         {
> /*  398 */                           if (((String)columnSpotHead.get(k)).equals(columnSpotHead.get(0)) == Boolean.TRUE.booleanValue()) {
> /*      */                             
> /*  400 */                             rt.setValue(columnSpotHead.get(k), i, (
> /*  401 */                                 (JLabel)FirstWizardPanel.modelSpot.getValueAt(i, k)).getText());
> /*      */                           } else {
> /*      */                             
> /*  404 */                             rt.setValue(columnSpotHead.get(k), i, FirstWizardPanel.modelSpot.getValueAt(i, k).toString());
> /*      */                           }  } 
> /*      */                       } 
> /*  407 */                     }  JFrame pngFrame = new JFrame();
> /*  408 */                     JFileChooser fileChooser = new JFileChooser();
> /*  409 */                     fileChooser.setFileSelectionMode(1);
> /*  410 */                     fileChooser.setDialogTitle("Specify a directory to save csv file");
> /*  411 */                     int userSelection = fileChooser.showSaveDialog(pngFrame);
> /*      */                     
> /*  413 */                     if (userSelection == 0) {
> /*  414 */                       File fileToSave = fileChooser.getSelectedFile();
> /*      */                       try {
> /*  416 */                         rt.saveAs(String.valueOf(fileToSave.getAbsolutePath()) + File.separator + "SpotStatistics for-" + 
> /*  417 */                             IJ.getImage().getShortTitle() + ".csv");
> /*  418 */                       } catch (IOException e1) {
> /*      */                         
> /*  420 */                         e1.printStackTrace();
> /*      */                       } 
> /*      */                     } 
> /*      */                   }
> /*      */                 });
> /*  425 */             FirstWizardPanel.this.csvThread.start();
> /*      */           }
> /*      */         });
> /*  428 */     pngButton.addActionListener(new ActionListener()
> /*      */         {
> /*      */           public void actionPerformed(ActionEvent e) {
> /*  431 */             FirstWizardPanel.this.pngThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  433 */                     if (IJ.getImage() == null)
> /*  434 */                       IJ.error("You must have an image window active."); 
> /*  435 */                     if (IJ.getImage() != null) {
> /*  436 */                       JFrame pngFrame = new JFrame();
> /*  437 */                       JFileChooser fileChooser = new JFileChooser();
> /*  438 */                       fileChooser.setFileSelectionMode(1);
> /*  439 */                       fileChooser.setDialogTitle("Specify a directory to save");
> /*  440 */                       int userSelection = fileChooser.showSaveDialog(pngFrame);
> /*      */                       
> /*  442 */                       if (userSelection == 0) {
> /*  443 */                         File fileToSave = fileChooser.getSelectedFile();
> /*      */                         
> /*  445 */                         int firstFrame = 0, lastFrame = 0;
> /*  446 */                         if (ProcessTrackMateXml.displayer.getImp().getNFrames() > 1) {
> /*  447 */                           firstFrame = Math.max(1, Math.min(IJ.getImage().getNFrames(), 1));
> /*  448 */                           lastFrame = Math.min(IJ.getImage().getNFrames(), 
> /*  449 */                               Math.max(IJ.getImage().getNFrames(), 1));
> /*      */                         } 
> /*  451 */                         if (ProcessTrackMateXml.displayer.getImp().getNSlices() > 1) {
> /*  452 */                           firstFrame = Math.max(1, Math.min(IJ.getImage().getNSlices(), 1));
> /*  453 */                           lastFrame = Math.min(IJ.getImage().getNSlices(), 
> /*  454 */                               Math.max(IJ.getImage().getNSlices(), 1));
> /*      */                         } 
> /*      */                         
> /*  457 */                         Rectangle bounds = ProcessTrackMateXml.displayer.getImp().getCanvas().getBounds();
> /*  458 */                         int width = bounds.width;
> /*  459 */                         int height = bounds.height;
> /*  460 */                         int nCaptures = lastFrame - firstFrame + 1;
> /*  461 */                         ImageStack stack = new ImageStack(width, height);
> /*  462 */                         int channel = ProcessTrackMateXml.displayer.getImp().getChannel();
> /*  463 */                         int slice = ProcessTrackMateXml.displayer.getImp().getSlice();
> /*  464 */                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(true);
> /*  465 */                         for (int frame = firstFrame; frame <= lastFrame; frame++) {
> /*      */                           
> /*  467 */                           ProcessTrackMateXml.displayer.getImp().setPositionWithoutUpdate(channel, slice, 
> /*  468 */                               frame);
> /*  469 */                           BufferedImage bi = new BufferedImage(width, height, 2);
> /*  470 */                           ProcessTrackMateXml.displayer.getImp().getCanvas().paint(bi.getGraphics());
> /*  471 */                           ColorProcessor cp = new ColorProcessor(bi);
> /*  472 */                           int index = ProcessTrackMateXml.displayer.getImp().getStackIndex(channel, slice, 
> /*  473 */                               frame);
> /*  474 */                           stack.addSlice(
> /*  475 */                               ProcessTrackMateXml.displayer.getImp().getImageStack().getSliceLabel(index), 
> /*  476 */                               (ImageProcessor)cp);
> /*      */                         } 
> /*  478 */                         ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(false);
> /*  479 */                         ImagePlus capture = new ImagePlus("TrackMate capture of " + 
> /*  480 */                             ProcessTrackMateXml.displayer.getImp().getShortTitle(), stack);
> /*  481 */                         FirstWizardPanel.transferCalibration(ProcessTrackMateXml.displayer.getImp(), capture);
> /*  482 */                         IJ.saveAs(capture, "Tiff", String.valueOf(fileToSave.getAbsolutePath()) + File.separator + 
> /*  483 */                             "Capture Overlay for " + IJ.getImage().getShortTitle());
> /*      */                       } 
> /*      */                     } 
> /*      */                   }
> /*      */                 });
> /*  488 */             FirstWizardPanel.this.pngThread.start();
> /*      */           }
> /*      */         });
> /*      */     
> /*  492 */     paintButton.addItemListener(new ItemListener() {
> /*      */           public void itemStateChanged(final ItemEvent ev) {
> /*  494 */             FirstWizardPanel.this.paintThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  496 */                     if (ev.getStateChange() == 1) {
> /*  497 */                       FirstWizardPanel.null.access$0(FirstWizardPanel.null.this).paintAndDisableAction();
> /*  498 */                     } else if (ev.getStateChange() == 2) {
> /*  499 */                       FirstWizardPanel.null.access$0(FirstWizardPanel.null.this).resetAndEnableAction();
> /*      */                     } 
> /*      */                   }
> /*      */                 });
> /*  503 */             FirstWizardPanel.this.paintThread.start();
> /*      */           }
> /*      */         });
> /*  506 */     tInsideButton.addItemListener(new ItemListener() {
> /*      */           public void itemStateChanged(final ItemEvent ev) {
> /*  508 */             FirstWizardPanel.this.tInsideThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  510 */                     if (ev.getStateChange() == 1) {
> /*  511 */                       FirstWizardPanel.null.access$0(FirstWizardPanel.null.this).toggleInsideAction();
> /*  512 */                     } else if (ev.getStateChange() == 2) {
> /*  513 */                       FirstWizardPanel.null.access$0(FirstWizardPanel.null.this).resetToggleInsideAction();
> /*      */                     } 
> /*      */                   }
> /*      */                 });
> /*  517 */             FirstWizardPanel.this.tInsideThread.start();
> /*      */           }
> /*      */         });
> /*  520 */     tOutsideButton.addItemListener(new ItemListener() {
> /*      */           public void itemStateChanged(final ItemEvent ev) {
> /*  522 */             FirstWizardPanel.this.tOutsideThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  524 */                     if (ev.getStateChange() == 1) {
> /*  525 */                       FirstWizardPanel.null.access$0(FirstWizardPanel.null.this).toggleOutsideAction();
> /*  526 */                     } else if (ev.getStateChange() == 2) {
> /*  527 */                       FirstWizardPanel.null.access$0(FirstWizardPanel.null.this).resetToggleOutsideAction();
> /*      */                     } 
> /*      */                   }
> /*      */                 });
> /*  531 */             FirstWizardPanel.this.tOutsideThread.start();
> /*      */           }
> /*      */         });
> /*  534 */     enableButton.addActionListener(new ActionListener()
> /*      */         {
> /*      */           public void actionPerformed(ActionEvent e) {
> /*  537 */             FirstWizardPanel.this.enableThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  539 */                     FirstWizardPanel.null.access$0(FirstWizardPanel.null.this).enableSpots();
> /*      */                   }
> /*      */                 });
> /*  542 */             FirstWizardPanel.this.enableThread.start();
> /*      */           }
> /*      */         });
> /*  545 */     disableButton.addActionListener(new ActionListener()
> /*      */         {
> /*      */           public void actionPerformed(ActionEvent e) {
> /*  548 */             FirstWizardPanel.this.disableThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  550 */                     FirstWizardPanel.null.access$0(FirstWizardPanel.null.this).disableSpots();
> /*      */                   }
> /*      */                 });
> /*  553 */             FirstWizardPanel.this.disableThread.start();
> /*      */           }
> /*      */         });
> /*      */     
> /*  557 */     sliderMin.addChangeListener(new ChangeListener()
> /*      */         {
> /*      */           public void stateChanged(ChangeEvent e) {
> /*  560 */             FirstWizardPanel.this.slMinThread = new Thread(new Runnable()
> /*      */                 {
> /*      */                   public void run() {
> /*  563 */                     (FirstWizardPanel.null.access$0(FirstWizardPanel.null.this)).filterMin.setValue(Integer.valueOf(sliderMin.getValue()));
> /*  564 */                     intervalMarker.setStartValue(sliderMin.getValue());
> /*      */                   }
> /*      */                 });
> /*  567 */             FirstWizardPanel.this.slMinThread.start();
> /*      */           }
> /*      */         });
> /*      */     
> /*  571 */     this.filterMin.addChangeListener(new ChangeListener()
> /*      */         {
> /*      */           public void stateChanged(ChangeEvent e) {
> /*  574 */             FirstWizardPanel.this.filterMinThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  576 */                     sliderMin.setValue(((Integer)(FirstWizardPanel.null.access$0(FirstWizardPanel.null.this)).filterMin.getValue()).intValue());
> /*  577 */                     intervalMarker.setStartValue(((Integer)(FirstWizardPanel.null.access$0(FirstWizardPanel.null.this)).filterMin.getValue()).intValue());
> /*      */                   }
> /*      */                 });
> /*  580 */             FirstWizardPanel.this.filterMinThread.start();
> /*      */           }
> /*      */         });
> /*      */     
> /*  584 */     sliderMax.addChangeListener(new ChangeListener()
> /*      */         {
> /*      */           public void stateChanged(ChangeEvent e) {
> /*  587 */             FirstWizardPanel.this.slMaxThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  589 */                     (FirstWizardPanel.null.access$0(FirstWizardPanel.null.this)).filterMax.setValue(Integer.valueOf(sliderMax.getValue()));
> /*  590 */                     intervalMarker.setEndValue(sliderMax.getValue());
> /*      */                   }
> /*      */                 });
> /*  593 */             FirstWizardPanel.this.slMaxThread.start();
> /*      */           }
> /*      */         });
> /*      */     
> /*  597 */     this.filterMax.addChangeListener(new ChangeListener()
> /*      */         {
> /*      */           public void stateChanged(ChangeEvent e) {
> /*  600 */             FirstWizardPanel.this.filterMaxThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  602 */                     sliderMax.setValue(((Integer)(FirstWizardPanel.null.access$0(FirstWizardPanel.null.this)).filterMax.getValue()).intValue());
> /*  603 */                     intervalMarker.setEndValue(((Integer)(FirstWizardPanel.null.access$0(FirstWizardPanel.null.this)).filterMax.getValue()).intValue());
> /*      */                   }
> /*      */                 });
> /*  606 */             FirstWizardPanel.this.filterMaxThread.start();
> /*      */           }
> /*      */         });
> /*  609 */     comboFilters.addActionListener(new ActionListener() {
> /*      */           public void actionPerformed(ActionEvent e) {
> /*  611 */             FirstWizardPanel.this.filtersThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  613 */                     String selectedName = (String)FirstWizardPanel.comboFilters.getSelectedItem();
> /*  614 */                     int selectedIndex = FirstWizardPanel.comboFilters.getSelectedIndex();
> /*  615 */                     double[] values = null;
> /*      */ 
> /*      */                     
> /*  618 */                     values = new double[FirstWizardPanel.tableSpot.getRowCount()];
> /*  619 */                     for (int r = 0; r < FirstWizardPanel.tableSpot.getRowCount(); r++) {
> /*  620 */                       for (int c = 0; c < FirstWizardPanel.tableSpot.getColumnCount(); c++)
> /*  621 */                         values[r] = Double.parseDouble((String)FirstWizardPanel.tableSpot.getValueAt(r, selectedIndex + 2)); 
> /*      */                     } 
> /*  623 */                     double max = values[0];
> /*  624 */                     for (int i = 1; i < values.length; i++) {
> /*  625 */                       if (values[i] > max)
> /*  626 */                         max = values[i]; 
> /*      */                     } 
> /*  628 */                     sliderMin.setMinimum(0);
> /*  629 */                     sliderMin.setMaximum((int)max);
> /*  630 */                     sliderMax.setMinimum(0);
> /*  631 */                     sliderMax.setMaximum((int)max);
> /*      */                     
> /*  633 */                     (FirstWizardPanel.null.access$0(FirstWizardPanel.null.this)).hs2.addHistogramSeries(selectedName, values, (int)max, intervalMarker);
> /*      */                   }
> /*      */                 });
> /*  636 */             FirstWizardPanel.this.filtersThread.start();
> /*      */           }
> /*      */         });
> /*      */     
> /*  640 */     this.checkRPicker.addItemListener(new ItemListener()
> /*      */         {
> /*      */           public void itemStateChanged(final ItemEvent e)
> /*      */           {
> /*  644 */             FirstWizardPanel.this.pickerThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  646 */                     if (e.getStateChange() == 1)
> /*  647 */                       FirstWizardPanel.command = "enable"; 
> /*  648 */                     if (e.getStateChange() == 2) {
> /*  649 */                       FirstWizardPanel.command = null;
> /*  650 */                       ProcessTrackMateXml.selectionModel.clearSpotSelection();
> /*  651 */                       ProcessTrackMateXml.selectionModel.clearSelection();
> /*      */                       return;
> /*      */                     } 
> /*      */                   }
> /*      */                 });
> /*  656 */             FirstWizardPanel.this.pickerThread.start();
> /*      */           }
> /*      */         });
> /*      */     
> /*  660 */     classButton.addActionListener(new ActionListener()
> /*      */         {
> /*      */           public void actionPerformed(ActionEvent e) {
> /*  663 */             FirstWizardPanel.this.classThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  665 */                     ColorEditorSpot.myFrame.setVisible(true);
> /*  666 */                     colorEditor.setClassAction();
> /*      */                   }
> /*      */                 });
> /*  669 */             FirstWizardPanel.this.classThread.start();
> /*      */           }
> /*      */         });
> /*      */     
> /*  673 */     remClassButton.addActionListener(new ActionListener()
> /*      */         {
> /*      */           public void actionPerformed(ActionEvent e) {
> /*  676 */             FirstWizardPanel.this.remClassThread = new Thread(new Runnable() {
> /*      */                   public void run() {
> /*  678 */                     String classSelectedValue = FirstWizardPanel.classList.getSelectedValue();
> /*  679 */                     int[] classSelectedIndex = FirstWizardPanel.classList.getSelectedIndices(); int i;
> /*  680 */                     for (i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); i++) {
> /*  681 */                       if (((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1))).getText()
> /*  682 */                         .equals(classSelectedValue))
> /*  683 */                         FirstWizardPanel.modelSpot.setValueAt(FirstWizardPanel.labelReset, i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1)); 
> /*      */                     } 
> /*  685 */                     for (i = 0; i < classSelectedIndex.length; i++)
> /*  686 */                       FirstWizardPanel.modelListClass.removeElementAt(classSelectedIndex[i]); 
> /*      */                   }
> /*      */                 });
> /*  689 */             FirstWizardPanel.this.remClassThread.start();
> /*      */           }
> /*      */         });
> /*      */     
> /*  693 */     addButton.addActionListener(new ActionListener()
> /*      */         {
> /*      */           public void actionPerformed(ActionEvent e) {
> /*  696 */             FirstWizardPanel.this.addThread = new Thread(new Runnable()
> /*      */                 {
> /*      */                   public void run() {
> /*  699 */                     List<String> listFilters = new ArrayList<>();
> /*      */                     
> /*  701 */                     if (FirstWizardPanel.featureList.getModel().getSize() < 1) {
> /*  702 */                       FirstWizardPanel.modelListFeature.addElement(String.valueOf(FirstWizardPanel.comboFilters.getSelectedItem()) + ":  [" + 
> /*  703 */                           (FirstWizardPanel.null.access$0(FirstWizardPanel.null.this)).filterMin.getValue() + "," + (FirstWizardPanel.null.access$0(FirstWizardPanel.null.this)).filterMax.getValue() + "]");
> /*      */                     }
> /*  705 */                     if (FirstWizardPanel.featureList.getModel().getSize() >= 1) {
> /*  706 */                       for (int i = 0; i < FirstWizardPanel.featureList.getModel().getSize(); i++) {
> /*  707 */                         listFilters.add(String.valueOf(((String)FirstWizardPanel.featureList.getModel().getElementAt(i)).substring(0, (
> /*  708 */                                 (String)FirstWizardPanel.featureList.getModel().getElementAt(i)).lastIndexOf(":"))));
> /*      */                       }
> /*  710 */                       if (!listFilters.contains(FirstWizardPanel.comboFilters.getSelectedItem().toString())) {
> /*  711 */                         FirstWizardPanel.modelListFeature.addElement(String.valueOf(FirstWizardPanel.comboFilters.getSelectedItem()) + ":  [" + 
> /*  712 */                             (FirstWizardPanel.null.access$0(FirstWizardPanel.null.this)).filterMin.getValue() + "," + (FirstWizardPanel.null.access$0(FirstWizardPanel.null.this)).filterMax.getValue() + "]");
> /*      */                       }
> /*  714 */                       if (listFilters.contains(FirstWizardPanel.comboFilters.getSelectedItem().toString())) {
> /*      */                         return;
> /*      */                       }
> /*      */                     } 
> /*      */                   }
> /*      */                 });
> /*  720 */             FirstWizardPanel.this.addThread.start();
> /*      */           }
> /*      */         });
> /*      */ 
> /*      */     
> /*  725 */     remButton.addActionListener(new ActionListener()
> /*      */         {
> /*      */           public void actionPerformed(ActionEvent e) {
> /*  728 */             FirstWizardPanel.this.remThread = new Thread(new Runnable()
> /*      */                 {
> /*      */                   public void run() {
> /*      */                     try {
> /*  732 */                       int[] indexes = FirstWizardPanel.featureList.getSelectedIndices();
> /*  733 */                       for (int i = 0; i < indexes.length; i++)
> /*  734 */                         FirstWizardPanel.modelListFeature.remove(indexes[i]); 
> /*  735 */                     } catch (Exception e1) {
> /*  736 */                       e1.printStackTrace();
> /*      */                     } 
> /*      */                   }
> /*      */                 });
> /*      */             
> /*  741 */             FirstWizardPanel.this.remThread.start();
> /*      */           }
> /*      */         });
> /*      */   }
> /*      */   static Object[] columnNamesSpot; Thread refreshThread; Thread csvThread; Thread pngThread; Thread paintThread; Thread tInsideThread; Thread tOutsideThread; Thread enableThread; Thread disableThread; Thread slMinThread; Thread filterMinThread; Thread slMaxThread; Thread filterMaxThread; Thread filtersThread; Thread pickerThread; Thread classThread; Thread remClassThread; Thread addThread; Thread remThread;
> /*      */   
> /*      */   public void toggleOutsideAction() {
> /*  748 */     Roi mainRoi = null;
> /*  749 */     if (IJ.getImage().getRoi().getType() == 0)
> /*  750 */       mainRoi = IJ.getImage().getRoi(); 
> /*  751 */     this.indexesTO = new ArrayList<>();
> /*  752 */     for (int i = 0; i < modelSpot.getRowCount(); i++) {
> /*  753 */       if (mainRoi
> /*  754 */         .contains(
> /*      */           
> /*  756 */           (int)IJ.getImage().getCalibration().getRawX(
> /*  757 */             Double.parseDouble(
> /*  758 */               modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(5))
> /*  759 */               .toString())), 
> /*  760 */           (int)IJ.getImage().getCalibration().getRawY(
> /*  761 */             Double.parseDouble(modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(6))
> /*  762 */               .toString()))) == Boolean.FALSE.booleanValue()) {
> /*  763 */         this.indexesTO.add(Integer.valueOf(i));
> /*  764 */         modelSpot.setValueAt(Boolean.valueOf(false), i, tableSpot.convertColumnIndexToModel(0));
> /*  765 */         int spotID = Integer.parseInt((String)tableSpot.getValueAt(i, 2));
> /*  766 */         Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
> /*      */         
> /*  768 */         if (spot != null) {
> /*  769 */           spot.putFeature("VISIBILITY", SpotCollection.ZERO);
> /*  770 */           ProcessTrackMateXml.model.endUpdate();
> /*  771 */           ProcessTrackMateXml.displayer.refresh();
> /*      */         } 
> /*      */       } 
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public void resetToggleOutsideAction() {
> /*  780 */     for (int row = 0; row < modelSpot.getRowCount(); row++) {
> /*  781 */       modelSpot.setValueAt(Boolean.valueOf(true), tableSpot.convertRowIndexToModel(row), tableSpot.convertColumnIndexToModel(0));
> /*  782 */       int spotID = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
> /*  783 */       Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
> /*  784 */       if (spot != null) {
> /*  785 */         spot.putFeature("VISIBILITY", SpotCollection.ONE);
> /*  786 */         ProcessTrackMateXml.model.endUpdate();
> /*  787 */         ProcessTrackMateXml.displayer.refresh();
> /*      */       } 
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public void toggleInsideAction() {
> /*  796 */     Roi mainRoi = null;
> /*  797 */     if (IJ.getImage().getRoi().getType() == 0)
> /*  798 */       mainRoi = IJ.getImage().getRoi(); 
> /*  799 */     this.indexesTI = new ArrayList<>();
> /*  800 */     for (int i = 0; i < modelSpot.getRowCount(); i++) {
> /*  801 */       if (mainRoi
> /*  802 */         .contains(
> /*      */           
> /*  804 */           (int)IJ.getImage().getCalibration().getRawX(
> /*  805 */             Double.parseDouble(
> /*  806 */               modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(5))
> /*  807 */               .toString())), 
> /*  808 */           (int)IJ.getImage().getCalibration().getRawY(
> /*  809 */             Double.parseDouble(modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(6))
> /*  810 */               .toString()))) == Boolean.TRUE.booleanValue()) {
> /*  811 */         this.indexesTI.add(Integer.valueOf(i));
> /*  812 */         modelSpot.setValueAt(Boolean.valueOf(false), i, tableSpot.convertColumnIndexToModel(0));
> /*  813 */         int spotID = Integer.parseInt((String)tableSpot.getValueAt(i, 2));
> /*  814 */         Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
> /*      */         
> /*  816 */         if (spot != null) {
> /*  817 */           spot.putFeature("VISIBILITY", SpotCollection.ZERO);
> /*  818 */           ProcessTrackMateXml.model.endUpdate();
> /*  819 */           ProcessTrackMateXml.displayer.refresh();
> /*      */         } 
> /*      */       } 
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public void resetToggleInsideAction() {
> /*  829 */     for (int row = 0; row < modelSpot.getRowCount(); row++) {
> /*  830 */       modelSpot.setValueAt(Boolean.valueOf(true), tableSpot.convertRowIndexToModel(row), tableSpot.convertColumnIndexToModel(0));
> /*  831 */       int spotID = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
> /*  832 */       Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
> /*  833 */       if (spot != null) {
> /*  834 */         spot.putFeature("VISIBILITY", SpotCollection.ONE);
> /*  835 */         ProcessTrackMateXml.model.endUpdate();
> /*  836 */         ProcessTrackMateXml.displayer.refresh();
> /*      */       } 
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public void paintAndDisableAction() {
> /*  844 */     this.indexesToReset = new ArrayList<>();
> /*  845 */     this.spotID = new ArrayList<>();
> /*  846 */     this.spots = new ArrayList<>();
> /*  847 */     for (int i = 0; i < modelSpot.getRowCount(); i++) {
> /*  848 */       if (((JLabel)modelSpot.getValueAt(i, tableSpot.convertColumnIndexToModel(1))).getBackground()
> /*  849 */         .equals(new Color(214, 217, 223)) == Boolean.TRUE.booleanValue()) {
> /*  850 */         this.indexesToReset.add(Integer.valueOf(i));
> /*  851 */         modelSpot.setValueAt(Boolean.valueOf(false), i, tableSpot.convertColumnIndexToModel(0));
> /*  852 */         this.spotID.add(Integer.valueOf(Integer.parseInt((String)tableSpot.getValueAt(i, 2))));
> /*      */       } 
> /*  854 */     }  for (int row = 0; row < this.indexesToReset.size(); row++) {
> /*  855 */       int spotID = Integer.parseInt((String)tableSpot.getValueAt(((Integer)this.indexesToReset.get(row)).intValue(), 2));
> /*  856 */       Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
> /*  857 */       if (spot != null) {
> /*  858 */         spot.putFeature("VISIBILITY", SpotCollection.ZERO);
> /*  859 */         ProcessTrackMateXml.model.endUpdate();
> /*  860 */         ProcessTrackMateXml.displayer.refresh();
> /*      */       } 
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public void resetAndEnableAction() {
> /*  868 */     for (int i = 0; i < this.indexesToReset.size(); i++)
> /*  869 */       modelSpot.setValueAt(Boolean.valueOf(true), tableSpot.convertRowIndexToModel(((Integer)this.indexesToReset.get(i)).intValue()), 
> /*  870 */           tableSpot.convertColumnIndexToModel(0)); 
> /*  871 */     for (int row = 0; row < this.indexesToReset.size(); row++) {
> /*  872 */       int spotID = Integer.parseInt((String)tableSpot.getValueAt(((Integer)this.indexesToReset.get(row)).intValue(), 2));
> /*  873 */       Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
> /*  874 */       if (spot != null) {
> /*  875 */         spot.putFeature("VISIBILITY", SpotCollection.ONE);
> /*  876 */         ProcessTrackMateXml.model.endUpdate();
> /*  877 */         ProcessTrackMateXml.displayer.refresh();
> /*      */       } 
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public void enableSpots() {
> /*  886 */     ListSelectionModel lsm = tableSpot.getSelectionModel();
> /*  887 */     int[] selectedIndices = tableSpot.getSelectedRows();
> /*  888 */     for (int i = 0; i < selectedIndices.length; i++)
> /*  889 */       tableSpot.setValueAt(Boolean.valueOf(true), selectedIndices[i], 0); 
> /*  890 */     int selStart = lsm.getMinSelectionIndex();
> /*  891 */     int selEnd = lsm.getMaxSelectionIndex();
> /*  892 */     if (selStart < 0 || selEnd < 0) {
> /*      */       return;
> /*      */     }
> /*  895 */     int minLine = Math.min(selStart, selEnd);
> /*  896 */     int maxLine = Math.max(selStart, selEnd);
> /*  897 */     for (int row = minLine; row <= maxLine; row++) {
> /*  898 */       int spotIDEnable = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
> /*  899 */       Spot spotEnable = ProcessTrackMateXml.model.getSpots().search(spotIDEnable);
> /*  900 */       if (spotEnable != null) {
> /*  901 */         spotEnable.putFeature("VISIBILITY", SpotCollection.ONE);
> /*  902 */         ProcessTrackMateXml.model.endUpdate();
> /*  903 */         ProcessTrackMateXml.displayer.refresh();
> /*      */       } 
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public void disableSpots() {
> /*  911 */     ListSelectionModel lsm = tableSpot.getSelectionModel();
> /*  912 */     int selStart = lsm.getMinSelectionIndex();
> /*  913 */     int selEnd = lsm.getMaxSelectionIndex();
> /*  914 */     if (selStart < 0 || selEnd < 0) {
> /*      */       return;
> /*      */     }
> /*  917 */     int minLine = Math.min(selStart, selEnd);
> /*  918 */     int maxLine = Math.max(selStart, selEnd);
> /*  919 */     for (int row = minLine; row <= maxLine; row++) {
> /*  920 */       int spotID = Integer.parseInt((String)tableSpot.getValueAt(row, 2));
> /*  921 */       Spot spot = ProcessTrackMateXml.model.getSpots().search(spotID);
> /*  922 */       if (spot != null) {
> /*  923 */         spot.putFeature("VISIBILITY", SpotCollection.ZERO);
> /*  924 */         ProcessTrackMateXml.model.endUpdate();
> /*  925 */         ProcessTrackMateXml.displayer.refresh();
> /*      */       } 
> /*      */     } 
> /*      */ 
> /*      */     
> /*  930 */     int[] selectedIndices = tableSpot.getSelectedRows();
> /*  931 */     for (int i = 0; i < selectedIndices.length; i++) {
> /*  932 */       tableSpot.setValueAt(Boolean.valueOf(false), selectedIndices[i], 0);
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void createSpotTable() {
> /*  940 */     modelSpot = new DefaultTableModel((Object[][])ProcessTrackMateXml.dataSpot, (Object[])ProcessTrackMateXml.columnHeadersSpot)
> /*      */       {
> /*      */         public Class<?> getColumnClass(int column)
> /*      */         {
> /*  944 */           if (getRowCount() > 0) {
> /*  945 */             Object value = getValueAt(0, column);
> /*  946 */             if (value != null) {
> /*  947 */               return getValueAt(0, column).getClass();
> /*      */             }
> /*      */           } 
> /*      */           
> /*  951 */           return super.getColumnClass(column);
> /*      */         }
> /*      */       };
> /*      */     
> /*  955 */     modelSpot.addColumn("Enable");
> /*  956 */     tableSpot.setModel(modelSpot);
> /*  957 */     tableSpot.moveColumn(tableSpot.getColumnCount() - 1, 0);
> /*  958 */     tableSpot.setSelectionBackground(new Color(229, 255, 204));
> /*  959 */     tableSpot.setSelectionForeground(new Color(0, 102, 0));
> /*  960 */     DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
> /*  961 */     centerRenderer.setHorizontalAlignment(0);
> /*  962 */     tableSpot.setDefaultRenderer(String.class, centerRenderer);
> /*  963 */     tableSpot.setAutoResizeMode(0);
> /*  964 */     tableSpot.setRowHeight(45);
> /*  965 */     tableSpot.setAutoCreateRowSorter(true);
> /*  966 */     tableSpot.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer()); int u;
> /*  967 */     for (u = 0; u < tableSpot.getColumnCount(); u++)
> /*  968 */       tableSpot.getColumnModel().getColumn(u).setPreferredWidth(90); 
> /*  969 */     for (u = 16; u < tableSpot.getColumnCount(); u++)
> /*  970 */       tableSpot.getColumnModel().getColumn(u).setPreferredWidth(150); 
> /*      */     int i;
> /*  972 */     for (i = 0; i < tableSpot.getRowCount(); i++)
> /*  973 */       tableSpot.setValueAt(Boolean.valueOf(true), i, 0); 
> /*  974 */     tableSpot.getColumnModel().getColumn(1).setCellRenderer(new Renderer());
> /*  975 */     labelReset = new JLabel();
> /*  976 */     labelReset.setText("");
> /*  977 */     labelReset.setOpaque(true);
> /*  978 */     labelReset.setBackground(new Color(214, 217, 223));
> /*  979 */     for (i = 0; i < modelSpot.getRowCount(); i++) {
> /*  980 */       modelSpot.setValueAt(labelReset, i, tableSpot.convertColumnIndexToModel(1));
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void createMovieTable() {
> /*  986 */     tableImages.setSelectionBackground(new Color(229, 255, 204));
> /*  987 */     tableImages.setSelectionForeground(new Color(0, 102, 0));
> /*  988 */     DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
> /*  989 */     centerRenderer.setHorizontalAlignment(0);
> /*  990 */     tableImages.setDefaultRenderer(String.class, centerRenderer);
> /*  991 */     tableImages.setAutoResizeMode(0);
> /*  992 */     tableImages.setRowHeight(95);
> /*  993 */     tableImages.setAutoCreateRowSorter(true);
> /*  994 */     tableImages.getTableHeader().setDefaultRenderer(new SimpleHeaderRenderer());
> /*      */     
> /*  996 */     for (int i = 0; i < modelImages.getRowCount(); i++) {
> /*  997 */       modelImages.setValueAt(this.icons[i], i, tableImages.convertColumnIndexToModel(0));
> /*  998 */       modelImages.setValueAt(imps[i].getShortTitle(), i, tableImages.convertColumnIndexToModel(1));
> /*  999 */       modelImages.setValueAt(imps[i].getTitle().substring(imps[i].getTitle().lastIndexOf(".")), i, 
> /* 1000 */           tableImages.convertColumnIndexToModel(2));
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public static Image getScaledImage(Image srcImg, int w, int h) {
> /* 1006 */     BufferedImage resizedImg = new BufferedImage(w, h, 1);
> /* 1007 */     Graphics2D g2 = resizedImg.createGraphics();
> /* 1008 */     g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
> /* 1009 */     g2.drawImage(srcImg, 0, 0, w, h, null);
> /* 1010 */     g2.dispose();
> /* 1011 */     return resizedImg;
> /*      */   }
> /*      */   
> /*      */   public static ImageIcon createImageIcon(String path) {
> /* 1015 */     URL imgURL = FirstWizardPanel.class.getResource(path);
> /* 1016 */     if (imgURL != null) {
> /* 1017 */       return new ImageIcon(imgURL);
> /*      */     }
> /* 1019 */     System.err.println("Couldn't find file: " + path);
> /* 1020 */     return null;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public ImagePlus extractTFrame(ImagePlus imp, int frame) {
> /* 1025 */     int width = imp.getWidth();
> /* 1026 */     int height = imp.getHeight();
> /* 1027 */     int channels = imp.getNChannels();
> /* 1028 */     int zslices = imp.getNSlices();
> /* 1029 */     FileInfo fileInfo = imp.getOriginalFileInfo();
> /* 1030 */     ImageStack stack2 = new ImageStack(width, height);
> /* 1031 */     ImagePlus imp2 = new ImagePlus();
> /* 1032 */     imp2.setTitle("T" + frame + "-" + imp.getTitle());
> /*      */     
> /* 1034 */     for (int z = 1; z <= zslices; z++) {
> /* 1035 */       for (int c = 1; c <= channels; c++) {
> /* 1036 */         int sliceSix = imp.getStackIndex(c, z, frame);
> /* 1037 */         stack2.addSlice("", imp.getStack().getProcessor(sliceSix));
> /*      */       } 
> /* 1039 */     }  imp2.setStack(stack2);
> /* 1040 */     imp2.setDimensions(channels, zslices, 1);
> /* 1041 */     if (channels * zslices > 1)
> /* 1042 */       imp2.setOpenAsHyperStack(true); 
> /* 1043 */     imp2.setFileInfo(fileInfo);
> /* 1044 */     return imp2;
> /*      */   }
> /*      */   
> /*      */   private static final void transferCalibration(ImagePlus from, ImagePlus to) {
> /* 1048 */     Calibration fc = from.getCalibration();
> /* 1049 */     Calibration tc = to.getCalibration();
> /*      */     
> /* 1051 */     tc.setUnit(fc.getUnit());
> /* 1052 */     tc.setTimeUnit(fc.getTimeUnit());
> /* 1053 */     tc.frameInterval = fc.frameInterval;
> /*      */     
> /* 1055 */     double mag = from.getCanvas().getMagnification();
> /* 1056 */     fc.pixelWidth /= mag;
> /* 1057 */     fc.pixelHeight /= mag;
> /* 1058 */     tc.pixelDepth = fc.pixelDepth;
> /*      */   }
> /*      */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/FirstWizardPanel.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: HistogramFilterVersion$VisibleAction.java
diff -r TrackAnalyzer_/HistogramFilterVersion.java jd-gui/HistogramFilterVersion.java
1,126c1,189
< import java.awt.Color;
< import java.awt.Component;
< import java.awt.Dimension;
< import java.awt.Font;
< import java.awt.Paint;
< import java.awt.event.ActionEvent;
< import javax.swing.AbstractAction;
< import javax.swing.JFrame;
< import javax.swing.JPanel;
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.JFreeChart;
< import org.jfree.chart.plot.DefaultDrawingSupplier;
< import org.jfree.chart.plot.IntervalMarker;
< import org.jfree.chart.plot.PlotOrientation;
< import org.jfree.chart.plot.XYPlot;
< import org.jfree.chart.renderer.xy.StandardXYBarPainter;
< import org.jfree.chart.renderer.xy.XYBarRenderer;
< import org.jfree.data.statistics.HistogramDataset;
< 
< public class HistogramFilterVersion {
<    private int BINS;
<    private HistogramDataset dataset;
<    private XYBarRenderer renderer;
<    private XYPlot plot;
<    private double[] values;
<    private String feature;
<    private ChartPanel panel;
<    public IntervalMarker intervalMarker;
< 
<    public ChartPanel createChartPanel(String feature, double[] values, int BINS, IntervalMarker intervalMarker) {
<       this.feature = feature;
<       this.values = values;
<       this.BINS = BINS;
<       this.intervalMarker = intervalMarker;
<       this.dataset = new HistogramDataset();
<       if (BINS != 0) {
<          this.dataset.addSeries(feature, values, BINS);
<       }
< 
<       JFreeChart chart = ChartFactory.createHistogram("", feature, "", this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       this.plot = (XYPlot)chart.getPlot();
<       this.renderer = (XYBarRenderer)this.plot.getRenderer();
<       this.renderer.setBarPainter(new StandardXYBarPainter());
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       this.plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       this.panel = new ChartPanel(chart);
<       this.panel.setPreferredSize(new Dimension(390, 180));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       Font font3 = new Font("Dialog", 2, 9);
<       this.plot.getDomainAxis().setLabelFont(font3);
<       this.plot.getRangeAxis().setLabelFont(font3);
<       this.plot.getRangeAxis().setTickLabelFont(font3);
<       this.plot.getDomainAxis().setTickLabelFont(font3);
<       chart.getLegend().setVisible(false);
<       this.plot.addDomainMarker(intervalMarker);
<       double x = (double)((float)(0.05D * this.plot.getDomainAxis().getRange().getLength()));
<       double y = (double)((float)(0.85D * this.plot.getRangeAxis().getUpperBound()));
<       return this.panel;
<    }
< 
<    public JPanel createControlPanel() {
<       JPanel panel = new JPanel();
<       return panel;
<    }
< 
<    public void addHistogramSeries(String feature, double[] values, int BINS, IntervalMarker intervalMarker) {
<       this.feature = feature;
<       this.values = values;
<       this.BINS = BINS;
<       this.intervalMarker = intervalMarker;
<       this.panel.removeAll();
<       this.dataset = new HistogramDataset();
<       if (BINS != 0) {
<          this.dataset.addSeries(feature, values, BINS);
<       }
< 
<       JFreeChart chart = ChartFactory.createHistogram("", feature, "COUNTING", this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       this.plot = (XYPlot)chart.getPlot();
<       this.renderer = (XYBarRenderer)this.plot.getRenderer();
<       this.renderer.setBarPainter(new StandardXYBarPainter());
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       this.plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       this.panel.setChart(chart);
<       this.panel.setPreferredSize(new Dimension(390, 180));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(false);
<       Font font3 = new Font("Dialog", 2, 10);
<       this.plot.getDomainAxis().setLabelFont(font3);
<       this.plot.getRangeAxis().setLabelFont(font3);
<       this.plot.getRangeAxis().setTickLabelFont(font3);
<       this.plot.getDomainAxis().setTickLabelFont(font3);
<       this.plot.addDomainMarker(intervalMarker);
<    }
< 
<    public void display() {
<       JFrame f = new JFrame("Histogram");
<       f.setDefaultCloseOperation(3);
<       f.add(this.createControlPanel(), "South");
<       f.pack();
<       f.setLocationRelativeTo((Component)null);
<       f.setVisible(true);
<    }
< 
<    public class VisibleAction extends AbstractAction {
<       private static final long serialVersionUID = 1L;
<       private final int i;
< 
<       public VisibleAction(int i) {
<          this.i = i;
<          this.putValue("Name", (String)HistogramFilterVersion.this.dataset.getSeriesKey(i));
<          this.putValue("SwingSelectedKey", true);
<          HistogramFilterVersion.this.renderer.setSeriesVisible(i, true);
<       }
< 
<       public void actionPerformed(ActionEvent e) {
<          HistogramFilterVersion.this.renderer.setSeriesVisible(this.i, !HistogramFilterVersion.this.renderer.getSeriesVisible(this.i));
<       }
<    }
< }
---
> /*     */ import java.awt.Color;
> /*     */ import java.awt.Component;
> /*     */ import java.awt.Dimension;
> /*     */ import java.awt.Font;
> /*     */ import java.awt.Paint;
> /*     */ import java.awt.event.ActionEvent;
> /*     */ import javax.swing.AbstractAction;
> /*     */ import javax.swing.JFrame;
> /*     */ import javax.swing.JPanel;
> /*     */ import org.jfree.chart.ChartFactory;
> /*     */ import org.jfree.chart.ChartPanel;
> /*     */ import org.jfree.chart.JFreeChart;
> /*     */ import org.jfree.chart.plot.DefaultDrawingSupplier;
> /*     */ import org.jfree.chart.plot.DrawingSupplier;
> /*     */ import org.jfree.chart.plot.IntervalMarker;
> /*     */ import org.jfree.chart.plot.Marker;
> /*     */ import org.jfree.chart.plot.PlotOrientation;
> /*     */ import org.jfree.chart.plot.XYPlot;
> /*     */ import org.jfree.chart.renderer.xy.StandardXYBarPainter;
> /*     */ import org.jfree.chart.renderer.xy.XYBarPainter;
> /*     */ import org.jfree.chart.renderer.xy.XYBarRenderer;
> /*     */ import org.jfree.data.statistics.HistogramDataset;
> /*     */ import org.jfree.data.xy.IntervalXYDataset;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class HistogramFilterVersion
> /*     */ {
> /*     */   private int BINS;
> /*     */   private HistogramDataset dataset;
> /*     */   private XYBarRenderer renderer;
> /*     */   private XYPlot plot;
> /*     */   private double[] values;
> /*     */   private String feature;
> /*     */   private ChartPanel panel;
> /*     */   public IntervalMarker intervalMarker;
> /*     */   
> /*     */   public ChartPanel createChartPanel(String feature, double[] values, int BINS, IntervalMarker intervalMarker) {
> /*  62 */     this.feature = feature;
> /*  63 */     this.values = values;
> /*  64 */     this.BINS = BINS;
> /*  65 */     this.intervalMarker = intervalMarker;
> /*     */ 
> /*     */     
> /*  68 */     this.dataset = new HistogramDataset();
> /*  69 */     if (BINS != 0) {
> /*  70 */       this.dataset.addSeries(feature, values, BINS);
> /*     */     }
> /*  72 */     JFreeChart chart = ChartFactory.createHistogram("", feature, "", (IntervalXYDataset)this.dataset, PlotOrientation.VERTICAL, true, true, 
> /*  73 */         false);
> /*     */     
> /*  75 */     this.plot = (XYPlot)chart.getPlot();
> /*  76 */     this.renderer = (XYBarRenderer)this.plot.getRenderer();
> /*  77 */     this.renderer.setBarPainter((XYBarPainter)new StandardXYBarPainter());
> /*     */     
> /*  79 */     Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
> /*  80 */     this.plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, 
> /*  81 */           DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, 
> /*  82 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, 
> /*  83 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
> /*  84 */     this.panel = new ChartPanel(chart);
> /*     */     
> /*  86 */     this.panel.setPreferredSize(new Dimension(390, 180));
> /*     */     
> /*  88 */     chart.setBackgroundPaint(new Color(255, 255, 255, 0));
> /*  89 */     this.plot.setBackgroundPaint(new Color(255, 255, 255, 0));
> /*  90 */     chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
> /*  91 */     this.panel.setMouseWheelEnabled(true);
> /*  92 */     Font font3 = new Font("Dialog", 2, 9);
> /*  93 */     this.plot.getDomainAxis().setLabelFont(font3);
> /*  94 */     this.plot.getRangeAxis().setLabelFont(font3);
> /*  95 */     this.plot.getRangeAxis().setTickLabelFont(font3);
> /*  96 */     this.plot.getDomainAxis().setTickLabelFont(font3);
> /*  97 */     chart.getLegend().setVisible(false);
> /*  98 */     this.plot.addDomainMarker((Marker)intervalMarker);
> /*  99 */     double x = (float)(0.05D * this.plot.getDomainAxis().getRange().getLength());
> /* 100 */     double y = (float)(0.85D * this.plot.getRangeAxis().getUpperBound());
> /*     */     
> /* 102 */     return this.panel;
> /*     */   }
> /*     */   
> /*     */   public JPanel createControlPanel() {
> /* 106 */     JPanel panel = new JPanel();
> /*     */     
> /* 108 */     return panel;
> /*     */   }
> /*     */   
> /*     */   public void addHistogramSeries(String feature, double[] values, int BINS, IntervalMarker intervalMarker) {
> /* 112 */     this.feature = feature;
> /* 113 */     this.values = values;
> /* 114 */     this.BINS = BINS;
> /* 115 */     this.intervalMarker = intervalMarker;
> /*     */     
> /* 117 */     this.panel.removeAll();
> /* 118 */     this.dataset = new HistogramDataset();
> /* 119 */     if (BINS != 0) {
> /* 120 */       this.dataset.addSeries(feature, values, BINS);
> /*     */     }
> /*     */     
> /* 123 */     JFreeChart chart = ChartFactory.createHistogram("", feature, "COUNTING", (IntervalXYDataset)this.dataset, PlotOrientation.VERTICAL, 
> /* 124 */         true, true, false);
> /*     */     
> /* 126 */     this.plot = (XYPlot)chart.getPlot();
> /* 127 */     this.renderer = (XYBarRenderer)this.plot.getRenderer();
> /* 128 */     this.renderer.setBarPainter((XYBarPainter)new StandardXYBarPainter());
> /*     */     
> /* 130 */     Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
> /* 131 */     this.plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, 
> /* 132 */           DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, 
> /* 133 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, 
> /* 134 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
> /* 135 */     this.panel.setChart(chart);
> /*     */     
> /* 137 */     this.panel.setPreferredSize(new Dimension(390, 180));
> /*     */     
> /* 139 */     chart.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 140 */     this.plot.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 141 */     chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 142 */     this.panel.setMouseWheelEnabled(true);
> /* 143 */     chart.getLegend().setVisible(false);
> /* 144 */     Font font3 = new Font("Dialog", 2, 10);
> /* 145 */     this.plot.getDomainAxis().setLabelFont(font3);
> /* 146 */     this.plot.getRangeAxis().setLabelFont(font3);
> /* 147 */     this.plot.getRangeAxis().setTickLabelFont(font3);
> /* 148 */     this.plot.getDomainAxis().setTickLabelFont(font3);
> /* 149 */     this.plot.addDomainMarker((Marker)intervalMarker);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public class VisibleAction
> /*     */     extends AbstractAction
> /*     */   {
> /*     */     private static final long serialVersionUID = 1L;
> /*     */     
> /*     */     private final int i;
> /*     */ 
> /*     */     
> /*     */     public VisibleAction(int i) {
> /* 162 */       this.i = i;
> /* 163 */       putValue("Name", HistogramFilterVersion.this.dataset.getSeriesKey(i));
> /* 164 */       putValue("SwingSelectedKey", Boolean.valueOf(true));
> /* 165 */       HistogramFilterVersion.this.renderer.setSeriesVisible(i, Boolean.valueOf(true));
> /*     */     }
> /*     */ 
> /*     */     
> /*     */     public void actionPerformed(ActionEvent e) {
> /* 170 */       HistogramFilterVersion.this.renderer.setSeriesVisible(this.i, Boolean.valueOf(!HistogramFilterVersion.this.renderer.getSeriesVisible(this.i).booleanValue()));
> /*     */     }
> /*     */   }
> /*     */   
> /*     */   public void display() {
> /* 175 */     JFrame f = new JFrame("Histogram");
> /* 176 */     f.setDefaultCloseOperation(3);
> /*     */     
> /* 178 */     f.add(createControlPanel(), "South");
> /* 179 */     f.pack();
> /* 180 */     f.setLocationRelativeTo((Component)null);
> /* 181 */     f.setVisible(true);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/HistogramFilterVersion.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/ImagePlusReaderModified.java jd-gui/ImagePlusReaderModified.java
1,506c1,631
< import ij.ImagePlus;
< import ij.ImageStack;
< import ij.io.FileInfo;
< import ij.process.ImageProcessor;
< import ij.process.LUT;
< import java.awt.image.ColorModel;
< import java.io.File;
< import java.io.IOException;
< import java.util.ArrayList;
< import java.util.Iterator;
< import java.util.List;
< import java.util.Vector;
< import loci.common.Location;
< import loci.common.Region;
< import loci.common.StatusEvent;
< import loci.common.StatusListener;
< import loci.common.StatusReporter;
< import loci.common.services.DependencyException;
< import loci.common.services.ServiceException;
< import loci.common.services.ServiceFactory;
< import loci.formats.FilePattern;
< import loci.formats.FormatException;
< import loci.formats.IFormatReader;
< import loci.formats.cache.CacheException;
< import loci.formats.meta.IMetadata;
< import loci.formats.services.OMEXMLService;
< import loci.plugins.Slicer;
< import loci.plugins.in.Calibrator;
< import loci.plugins.in.Colorizer;
< import loci.plugins.in.Concatenator;
< import loci.plugins.in.ImportProcess;
< import loci.plugins.in.ImporterOptions;
< import loci.plugins.util.BFVirtualStack;
< import loci.plugins.util.ImageProcessorReader;
< import loci.plugins.util.LuraWave;
< import loci.plugins.util.VirtualImagePlus;
< 
< public class ImagePlusReaderModified implements StatusReporter {
<    public static final String PROP_SERIES = "Series";
<    public static final String PROP_LUT = "LUT-";
<    public ImportProcess process;
<    public List<StatusListener> listeners = new Vector();
<    public long startTime;
<    public long time;
< 
<    public ImagePlusReaderModified(ImportProcess process) {
<       this.process = process;
<    }
< 
<    public ImagePlus[] openImagePlus() {
<       List<ImagePlus> imps = this.readImages();
<       return (ImagePlus[])imps.toArray(new ImagePlus[0]);
<    }
< 
<    public ImagePlus[] openThumbImagePlus() {
<       List<ImagePlus> imps = this.readThumbImages();
<       return (ImagePlus[])imps.toArray(new ImagePlus[imps.size()]);
<    }
< 
<    public void addStatusListener(StatusListener l) {
<       this.listeners.add(l);
<    }
< 
<    public void removeStatusListener(StatusListener l) {
<       this.listeners.remove(l);
<    }
< 
<    public void notifyListeners(StatusEvent e) {
<       Iterator var3 = this.listeners.iterator();
< 
<       while(var3.hasNext()) {
<          StatusListener l = (StatusListener)var3.next();
<          l.statusUpdated(e);
<       }
< 
<    }
< 
<    public static ImagePlus createImage(String title, List<ImageProcessor> procs) {
<       List<LUT> luts = new ArrayList();
<       ImageStack stack = createStack(procs, (List)null, luts);
<       return createImage(title, stack, luts);
<    }
< 
<    public static ImagePlus createImage(String title, ImageStack stack, List<LUT> luts) {
<       ImagePlus imp = new ImagePlus(title, stack);
<       saveLUTs(imp, luts);
<       return imp;
<    }
< 
<    public static ImageStack createStack(List<ImageProcessor> procs, List<String> labels, List<LUT> luts) {
<       if (procs != null && procs.size() != 0) {
<          ImageProcessor ip0 = (ImageProcessor)procs.get(0);
<          ImageStack stack = new ImageStack(ip0.getWidth(), ip0.getHeight());
< 
<          for(int i = 0; i < procs.size(); ++i) {
<             ImageProcessor ip = (ImageProcessor)procs.get(i);
<             String label = labels == null ? null : (String)labels.get(i);
<             if (luts != null) {
<                ColorModel cm = ip.getColorModel();
<                if (cm instanceof LUT) {
<                   LUT lut = (LUT)cm;
<                   luts.add(lut);
<                   ip.setColorModel(ip.getDefaultColorModel());
<                } else {
<                   luts.add((Object)null);
<                }
<             }
< 
<             stack.addSlice(label, ip);
<          }
< 
<          return stack;
<       } else {
<          return null;
<       }
<    }
< 
<    public List<ImagePlus> readImages() {
<       return this.readImages(false);
<    }
< 
<    public List<ImagePlus> readThumbImages() {
<       return this.readImages(true);
<    }
< 
<    public List<ImagePlus> readImages(boolean thumbnail) {
<       ImporterOptions options = this.process.getOptions();
<       ImageProcessorReader reader = this.process.getReader();
<       List<ImagePlus> imps = new ArrayList();
<       this.startTiming();
< 
<       for(int s = 0; s < reader.getSeriesCount(); ++s) {
<          if (options.isSeriesOn(s)) {
<             ImagePlus imp = this.readImage(s, thumbnail);
<             imps.add(imp);
<          }
<       }
< 
<       List<ImagePlus> imps = this.concatenate(imps);
<       imps = this.applyColors(imps);
<       imps = this.splitDims(imps);
<       if (options.isVirtual()) {
<          this.process.getVirtualReader().setRefCount(imps.size());
<       }
< 
<       this.finishTiming();
<       return imps;
<    }
< 
<    public ImagePlus readImage(int s, boolean thumbnail) {
<       ImporterOptions options = this.process.getOptions();
<       int zCount = this.process.getZCount(s);
<       int cCount = this.process.getCCount(s);
<       int tCount = this.process.getTCount(s);
<       List<LUT> luts = new ArrayList();
<       ImageStack stack;
<       if (options.isVirtual()) {
<          stack = this.createVirtualStack(this.process, s, luts);
<       } else {
<          stack = this.readPlanes(this.process, s, luts, thumbnail);
<       }
< 
<       this.notifyListeners(new StatusEvent(1, 1, "Creating image"));
<       String seriesName = this.process.getOMEMetadata().getImageName(s);
<       String file = this.process.getCurrentFile();
<       IFormatReader reader = this.process.getReader();
<       String title = this.constructImageTitle(reader, file, seriesName, options.isGroupFiles());
<       Object imp;
<       if (stack.isVirtual()) {
<          VirtualImagePlus vip = new VirtualImagePlus(title, stack);
<          vip.setReader(reader);
<          imp = vip;
<          saveLUTs(vip, luts);
<       } else {
<          imp = createImage(title, stack, luts);
<       }
< 
<       String metadata = this.process.getOriginalMetadata().toString();
<       ((ImagePlus)imp).setProperty("Info", metadata);
<       ((ImagePlus)imp).setProperty("Series", s);
<       FileInfo fi = this.createFileInfo();
<       (new Calibrator(this.process)).applyCalibration((ImagePlus)imp);
<       ((ImagePlus)imp).setFileInfo(fi);
<       ((ImagePlus)imp).setDimensions(cCount, zCount, tCount);
<       boolean hyper = !options.isViewStandard();
<       ((ImagePlus)imp).setOpenAsHyperStack(hyper);
<       return (ImagePlus)imp;
<    }
< 
<    public ImageStack createVirtualStack(ImportProcess process, int s, List<LUT> luts) {
<       ImporterOptions options = process.getOptions();
<       ImageProcessorReader reader = process.getReader();
<       reader.setSeries(s);
<       int zCount = process.getZCount(s);
<       int cCount = process.getCCount(s);
<       int tCount = process.getTCount(s);
<       IMetadata meta = process.getOMEMetadata();
<       int imageCount = reader.getImageCount();
<       BFVirtualStack virtualStack = null;
< 
<       try {
<          virtualStack = new BFVirtualStack(options.getId(), reader, false, false, false);
<       } catch (CacheException var18) {
<          var18.printStackTrace();
<       } catch (FormatException var19) {
<          var19.printStackTrace();
<       } catch (IOException var20) {
<          var20.printStackTrace();
<       }
< 
<       int c;
<       for(c = 0; c < imageCount; ++c) {
<          String label = this.constructSliceLabel(c, reader, meta, s, zCount, cCount, tCount);
<          virtualStack.addSlice(label);
<       }
< 
<       if (luts != null) {
<          for(c = 0; c < cCount; ++c) {
<             int index = reader.getIndex(0, c, 0);
<             ImageProcessor ip = null;
< 
<             try {
<                ip = reader.openProcessors(index)[0];
<             } catch (IOException | FormatException var17) {
<                var17.printStackTrace();
<             }
< 
<             ColorModel cm = ip.getColorModel();
<             LUT lut = cm instanceof LUT ? (LUT)cm : null;
<             luts.add(lut);
<          }
<       }
< 
<       return virtualStack;
<    }
< 
<    public ImageStack readPlanes(ImportProcess process, int s, List<LUT> luts, boolean thumbnail) {
<       ImageProcessorReader reader = process.getReader();
<       reader.setSeries(s);
<       int zCount = process.getZCount(s);
<       int cCount = process.getCCount(s);
<       int tCount = process.getTCount(s);
<       IMetadata meta = process.getOMEMetadata();
<       boolean[] load = this.getPlanesToLoad(s);
<       int current = 0;
<       int total = 0;
< 
<       for(int j = 0; j < load.length; ++j) {
<          if (load[j]) {
<             ++total;
<          }
<       }
< 
<       List<ImageProcessor> procs = new ArrayList();
<       List<String> labels = new ArrayList();
<       Region region = process.getCropRegion(s);
< 
<       for(int i = 0; i < load.length; ++i) {
<          if (load[i]) {
<             this.updateTiming(s, current, current++, total);
<             ImageProcessor[] p = this.readProcessors(process, i, region, thumbnail);
<             String label = this.constructSliceLabel(i, reader, meta, s, zCount, cCount, tCount);
<             ImageProcessor[] var22 = p;
<             int var21 = p.length;
< 
<             for(int var20 = 0; var20 < var21; ++var20) {
<                ImageProcessor ip = var22[var20];
<                procs.add(ip);
<                labels.add(label);
<             }
<          }
<       }
< 
<       return createStack(procs, labels, luts);
<    }
< 
<    public ImageProcessor[] readProcessors(ImportProcess process, int no, Region r, boolean thumbnail) {
<       ImageProcessorReader reader = process.getReader();
<       ImporterOptions options = process.getOptions();
<       boolean first = true;
< 
<       for(int i = 0; i < 5; ++i) {
<          String code = LuraWave.initLicenseCode();
< 
<          try {
<             if (thumbnail) {
<                try {
<                   return reader.openThumbProcessors(no);
<                } catch (IOException var12) {
<                   var12.printStackTrace();
<                }
<             }
< 
<             try {
<                return reader.openProcessors(no, r.x, r.y, r.width, r.height);
<             } catch (IOException var11) {
<                var11.printStackTrace();
<             }
<          } catch (FormatException var13) {
<             LuraWave.promptLicenseCode(code, first);
<             if (first) {
<                first = false;
<             }
<          }
<       }
< 
<       return null;
<    }
< 
<    public List<ImagePlus> concatenate(List<ImagePlus> imps) {
<       ImporterOptions options = this.process.getOptions();
<       if (options.isConcatenate()) {
<          imps = (new Concatenator()).concatenate(imps);
<       }
< 
<       return imps;
<    }
< 
<    public List<ImagePlus> applyColors(List<ImagePlus> imps) {
<       return (new Colorizer(this.process)).applyColors(imps);
<    }
< 
<    public List<ImagePlus> splitDims(List<ImagePlus> imps) {
<       ImporterOptions options = this.process.getOptions();
<       boolean sliceC = options.isSplitChannels();
<       boolean sliceZ = options.isSplitFocalPlanes();
<       boolean sliceT = options.isSplitTimepoints();
<       if (sliceC || sliceZ || sliceT) {
<          String stackOrder = this.process.getStackOrder();
<          List<ImagePlus> slicedImps = new ArrayList();
<          Slicer slicer = new Slicer();
<          Iterator var10 = ((List)imps).iterator();
< 
<          while(var10.hasNext()) {
<             ImagePlus imp = (ImagePlus)var10.next();
<             ImagePlus[] results = slicer.reslice(imp, sliceC, sliceZ, sliceT, stackOrder);
<             ImagePlus[] var15 = results;
<             int var14 = results.length;
< 
<             for(int var13 = 0; var13 < var14; ++var13) {
<                ImagePlus result = var15[var13];
<                slicedImps.add(result);
<             }
<          }
< 
<          imps = slicedImps;
<       }
< 
<       return (List)imps;
<    }
< 
<    public void startTiming() {
<       this.startTime = this.time = System.currentTimeMillis();
<    }
< 
<    public void updateTiming(int s, int i, int current, int total) {
<       ImageProcessorReader reader = this.process.getReader();
<       long clock = System.currentTimeMillis();
<       if (clock - this.time >= 100L) {
<          String sLabel = reader.getSeriesCount() > 1 ? "series " + (s + 1) + ", " : "";
<          String pLabel = "plane " + (i + 1) + "/" + total;
<          this.notifyListeners(new StatusEvent("Reading " + sLabel + pLabel));
<          this.time = clock;
<       }
< 
<       this.notifyListeners(new StatusEvent(current, total, (String)null));
<    }
< 
<    public void finishTiming() {
<       ImageProcessorReader reader = this.process.getReader();
<       long endTime = System.currentTimeMillis();
<       double elapsed = (double)(endTime - this.startTime) / 1000.0D;
<       if (reader.getImageCount() == 1) {
<          this.notifyListeners(new StatusEvent("Bio-Formats: " + elapsed + " seconds"));
<       } else {
<          long average = (endTime - this.startTime) / (long)reader.getImageCount();
<          this.notifyListeners(new StatusEvent("Bio-Formats: " + elapsed + " seconds (" + average + " ms per plane)"));
<       }
< 
<    }
< 
<    public FileInfo createFileInfo() {
<       FileInfo fi = new FileInfo();
<       String idDir = this.process.getIdLocation() == null ? null : this.process.getIdLocation().getParent();
<       if (idDir != null && !idDir.endsWith(File.separator)) {
<          idDir = idDir + File.separator;
<       }
< 
<       fi.fileName = this.process.getIdName();
<       fi.directory = idDir;
< 
<       try {
<          ServiceFactory factory = new ServiceFactory();
<          OMEXMLService service = (OMEXMLService)factory.getInstance(OMEXMLService.class);
<          fi.description = service.getOMEXML(this.process.getOMEMetadata());
<       } catch (DependencyException var5) {
<       } catch (ServiceException var6) {
<       }
< 
<       return fi;
<    }
< 
<    public boolean[] getPlanesToLoad(int s) {
<       ImageProcessorReader reader = this.process.getReader();
<       boolean[] load = new boolean[reader.getImageCount()];
<       int cBegin = this.process.getCBegin(s);
<       int cEnd = this.process.getCEnd(s);
<       int cStep = this.process.getCStep(s);
<       int zBegin = this.process.getZBegin(s);
<       int zEnd = this.process.getZEnd(s);
<       int zStep = this.process.getZStep(s);
<       int tBegin = this.process.getTBegin(s);
<       int tEnd = this.process.getTEnd(s);
<       int tStep = this.process.getTStep(s);
< 
<       for(int c = cBegin; c <= cEnd; c += cStep) {
<          for(int z = zBegin; z <= zEnd; z += zStep) {
<             for(int t = tBegin; t <= tEnd; t += tStep) {
<                int index = reader.getIndex(z, c, t);
<                load[index] = true;
<             }
<          }
<       }
< 
<       return load;
<    }
< 
<    public String constructImageTitle(IFormatReader r, String file, String seriesName, boolean groupFiles) {
<       String[] used = r.getUsedFiles();
<       String title = file.substring(file.lastIndexOf(File.separator) + 1);
<       if (used.length > 1 && groupFiles) {
<          FilePattern fp = new FilePattern(new Location(file));
<          title = fp.getPattern();
<          if (title == null) {
<             title = file;
<             if (file.indexOf(".") != -1) {
<                title = file.substring(0, file.lastIndexOf("."));
<             }
<          }
< 
<          title = title.substring(title.lastIndexOf(File.separator) + 1);
<       }
< 
<       if (seriesName != null && !file.endsWith(seriesName) && r.getSeriesCount() > 1) {
<          title = title + " - " + seriesName;
<       }
< 
<       if (title.length() > 128) {
<          String a = title.substring(0, 62);
<          String b = title.substring(title.length() - 62);
<          title = a + "..." + b;
<       }
< 
<       return title;
<    }
< 
<    public String constructSliceLabel(int ndx, ImageProcessorReader r, IMetadata meta, int series, int zCount, int cCount, int tCount) {
<       r.setSeries(series);
<       int[] zct = r.getZCTCoords(ndx);
<       StringBuffer sb = new StringBuffer();
<       boolean first = true;
<       if (zCount > 1) {
<          if (first) {
<             first = false;
<          } else {
<             sb.append("; ");
<          }
< 
<          sb.append("z:");
<          sb.append(zct[0] + 1);
<          sb.append("/");
<          sb.append(r.getSizeZ());
<       }
< 
<       if (tCount > 1) {
<          if (first) {
<             first = false;
<          } else {
<             sb.append("; ");
<          }
< 
<          sb.append("t:");
<          sb.append(zct[2] + 1);
<          sb.append("/");
<          sb.append(r.getSizeT());
<       }
< 
<       String imageName = meta.getImageName(series);
<       if (imageName != null && !imageName.trim().equals("")) {
<          sb.append(" - ");
<          sb.append(imageName);
<       }
< 
<       return sb.toString();
<    }
< 
<    public static void saveLUTs(ImagePlus imp, List<LUT> luts) {
<       for(int i = 0; i < luts.size(); ++i) {
<          LUT lut = (LUT)luts.get(i);
<          if (lut != null) {
<             imp.setProperty("LUT-" + i, lut);
<          }
<       }
< 
<    }
< }
---
> /*     */ import ij.ImagePlus;
> /*     */ import ij.ImageStack;
> /*     */ import ij.io.FileInfo;
> /*     */ import ij.process.ImageProcessor;
> /*     */ import ij.process.LUT;
> /*     */ import java.awt.image.ColorModel;
> /*     */ import java.io.File;
> /*     */ import java.io.IOException;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.List;
> /*     */ import java.util.Vector;
> /*     */ import loci.common.Location;
> /*     */ import loci.common.Region;
> /*     */ import loci.common.StatusEvent;
> /*     */ import loci.common.StatusListener;
> /*     */ import loci.common.StatusReporter;
> /*     */ import loci.common.services.DependencyException;
> /*     */ import loci.common.services.ServiceException;
> /*     */ import loci.common.services.ServiceFactory;
> /*     */ import loci.formats.FilePattern;
> /*     */ import loci.formats.FormatException;
> /*     */ import loci.formats.IFormatReader;
> /*     */ import loci.formats.cache.CacheException;
> /*     */ import loci.formats.meta.IMetadata;
> /*     */ import loci.formats.meta.MetadataRetrieve;
> /*     */ import loci.formats.services.OMEXMLService;
> /*     */ import loci.plugins.Slicer;
> /*     */ import loci.plugins.in.Calibrator;
> /*     */ import loci.plugins.in.Colorizer;
> /*     */ import loci.plugins.in.Concatenator;
> /*     */ import loci.plugins.in.ImportProcess;
> /*     */ import loci.plugins.in.ImporterOptions;
> /*     */ import loci.plugins.util.BFVirtualStack;
> /*     */ import loci.plugins.util.ImageProcessorReader;
> /*     */ import loci.plugins.util.LuraWave;
> /*     */ import loci.plugins.util.VirtualImagePlus;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class ImagePlusReaderModified
> /*     */   implements StatusReporter
> /*     */ {
> /*     */   public static final String PROP_SERIES = "Series";
> /*     */   public static final String PROP_LUT = "LUT-";
> /*     */   public ImportProcess process;
> /*  65 */   public List<StatusListener> listeners = new Vector<>();
> /*     */   
> /*     */   public long startTime;
> /*     */   
> /*     */   public long time;
> /*     */ 
> /*     */   
> /*     */   public ImagePlusReaderModified(ImportProcess process) {
> /*  73 */     this.process = process;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ImagePlus[] openImagePlus() {
> /*  83 */     List<ImagePlus> imps = readImages();
> /*  84 */     return imps.<ImagePlus>toArray(new ImagePlus[0]);
> /*     */   }
> /*     */   
> /*     */   public ImagePlus[] openThumbImagePlus() {
> /*  88 */     List<ImagePlus> imps = readThumbImages();
> /*  89 */     return imps.<ImagePlus>toArray(new ImagePlus[imps.size()]);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void addStatusListener(StatusListener l) {
> /*  95 */     this.listeners.add(l);
> /*     */   }
> /*     */   
> /*     */   public void removeStatusListener(StatusListener l) {
> /*  99 */     this.listeners.remove(l);
> /*     */   }
> /*     */   
> /*     */   public void notifyListeners(StatusEvent e) {
> /* 103 */     for (StatusListener l : this.listeners) l.statusUpdated(e);
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static ImagePlus createImage(String title, List<ImageProcessor> procs) {
> /* 115 */     List<LUT> luts = new ArrayList<>();
> /* 116 */     ImageStack stack = createStack(procs, null, luts);
> /* 117 */     return createImage(title, stack, luts);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static ImagePlus createImage(String title, ImageStack stack, List<LUT> luts) {
> /* 131 */     ImagePlus imp = new ImagePlus(title, stack);
> /*     */     
> /* 133 */     saveLUTs(imp, luts);
> /* 134 */     return imp;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static ImageStack createStack(List<ImageProcessor> procs, List<String> labels, List<LUT> luts) {
> /* 147 */     if (procs == null || procs.size() == 0) return null;
> /*     */     
> /* 149 */     ImageProcessor ip0 = procs.get(0);
> /* 150 */     ImageStack stack = new ImageStack(ip0.getWidth(), ip0.getHeight());
> /*     */ 
> /*     */     
> /* 153 */     for (int i = 0; i < procs.size(); i++) {
> /* 154 */       ImageProcessor ip = procs.get(i);
> /* 155 */       String label = (labels == null) ? null : labels.get(i);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */       
> /* 160 */       if (luts != null) {
> /* 161 */         ColorModel cm = ip.getColorModel();
> /* 162 */         if (cm instanceof LUT) {
> /*     */           
> /* 164 */           LUT lut = (LUT)cm;
> /* 165 */           luts.add(lut);
> /*     */           
> /* 167 */           ip.setColorModel(ip.getDefaultColorModel());
> /*     */         }
> /*     */         else {
> /*     */           
> /* 171 */           luts.add(null);
> /*     */         } 
> /*     */       } 
> /*     */ 
> /*     */       
> /* 176 */       stack.addSlice(label, ip);
> /*     */     } 
> /*     */     
> /* 179 */     return stack;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public List<ImagePlus> readImages() {
> /* 185 */     return readImages(false);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public List<ImagePlus> readThumbImages() {
> /* 190 */     return readImages(true);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public List<ImagePlus> readImages(boolean thumbnail) {
> /* 196 */     ImporterOptions options = this.process.getOptions();
> /* 197 */     ImageProcessorReader reader = this.process.getReader();
> /*     */     
> /* 199 */     List<ImagePlus> imps = new ArrayList<>();
> /*     */ 
> /*     */     
> /* 202 */     startTiming();
> /*     */ 
> /*     */     
> /* 205 */     for (int s = 0; s < reader.getSeriesCount(); s++) {
> /* 206 */       if (options.isSeriesOn(s)) {
> /* 207 */         ImagePlus imp = readImage(s, thumbnail);
> /* 208 */         imps.add(imp);
> /*     */       } 
> /*     */     } 
> /* 211 */     imps = concatenate(imps);
> /*     */ 
> /*     */     
> /* 214 */     imps = applyColors(imps);
> /*     */ 
> /*     */     
> /* 217 */     imps = splitDims(imps);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 222 */     if (options.isVirtual()) {
> /* 223 */       this.process.getVirtualReader().setRefCount(imps.size());
> /*     */     }
> /*     */ 
> /*     */     
> /* 227 */     finishTiming();
> /*     */     
> /* 229 */     return imps;
> /*     */   }
> /*     */   public ImagePlus readImage(int s, boolean thumbnail) {
> /*     */     ImageStack stack;
> /*     */     ImagePlus imp;
> /* 234 */     ImporterOptions options = this.process.getOptions();
> /* 235 */     int zCount = this.process.getZCount(s);
> /* 236 */     int cCount = this.process.getCCount(s);
> /* 237 */     int tCount = this.process.getTCount(s);
> /*     */ 
> /*     */     
> /* 240 */     List<LUT> luts = new ArrayList<>();
> /*     */ 
> /*     */ 
> /*     */     
> /* 244 */     if (options.isVirtual()) { stack = createVirtualStack(this.process, s, luts); }
> /* 245 */     else { stack = readPlanes(this.process, s, luts, thumbnail); }
> /*     */     
> /* 247 */     notifyListeners(new StatusEvent(1, 1, "Creating image"));
> /*     */ 
> /*     */     
> /* 250 */     String seriesName = this.process.getOMEMetadata().getImageName(s);
> /* 251 */     String file = this.process.getCurrentFile();
> /* 252 */     ImageProcessorReader imageProcessorReader = this.process.getReader();
> /* 253 */     String title = constructImageTitle((IFormatReader)imageProcessorReader, 
> /* 254 */         file, seriesName, options.isGroupFiles());
> /*     */ 
> /*     */ 
> /*     */     
> /* 258 */     if (stack.isVirtual()) {
> /* 259 */       VirtualImagePlus vip = new VirtualImagePlus(title, stack);
> /* 260 */       vip.setReader((IFormatReader)imageProcessorReader);
> /* 261 */       VirtualImagePlus virtualImagePlus1 = vip;
> /* 262 */       saveLUTs((ImagePlus)virtualImagePlus1, luts);
> /*     */     } else {
> /* 264 */       imp = createImage(title, stack, luts);
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */     
> /* 269 */     String metadata = this.process.getOriginalMetadata().toString();
> /* 270 */     imp.setProperty("Info", metadata);
> /* 271 */     imp.setProperty("Series", Integer.valueOf(s));
> /*     */ 
> /*     */     
> /* 274 */     FileInfo fi = createFileInfo();
> /* 275 */     (new Calibrator(this.process)).applyCalibration(imp);
> /* 276 */     imp.setFileInfo(fi);
> /* 277 */     imp.setDimensions(cCount, zCount, tCount);
> /*     */ 
> /*     */     
> /* 280 */     boolean hyper = !options.isViewStandard();
> /* 281 */     imp.setOpenAsHyperStack(hyper);
> /*     */     
> /* 283 */     return imp;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ImageStack createVirtualStack(ImportProcess process, int s, List<LUT> luts) {
> /* 289 */     ImporterOptions options = process.getOptions();
> /* 290 */     ImageProcessorReader reader = process.getReader();
> /* 291 */     reader.setSeries(s);
> /* 292 */     int zCount = process.getZCount(s);
> /* 293 */     int cCount = process.getCCount(s);
> /* 294 */     int tCount = process.getTCount(s);
> /* 295 */     IMetadata meta = process.getOMEMetadata();
> /* 296 */     int imageCount = reader.getImageCount();
> /*     */ 
> /*     */     
> /* 299 */     BFVirtualStack virtualStack = null;
> /*     */     try {
> /* 301 */       virtualStack = new BFVirtualStack(options.getId(), 
> /* 302 */           (IFormatReader)reader, false, false, false);
> /* 303 */     } catch (CacheException e) {
> /*     */       
> /* 305 */       e.printStackTrace();
> /* 306 */     } catch (FormatException e) {
> /*     */       
> /* 308 */       e.printStackTrace();
> /* 309 */     } catch (IOException e) {
> /*     */       
> /* 311 */       e.printStackTrace();
> /*     */     } 
> /* 313 */     for (int i = 0; i < imageCount; i++) {
> /* 314 */       String label = constructSliceLabel(i, 
> /* 315 */           reader, meta, s, zCount, cCount, tCount);
> /* 316 */       virtualStack.addSlice(label);
> /*     */     } 
> /*     */     
> /* 319 */     if (luts != null) {
> /* 320 */       for (int c = 0; c < cCount; c++) {
> /* 321 */         int index = reader.getIndex(0, c, 0);
> /* 322 */         ImageProcessor ip = null;
> /*     */         try {
> /* 324 */           ip = reader.openProcessors(index)[0];
> /* 325 */         } catch (FormatException|IOException e) {
> /*     */           
> /* 327 */           e.printStackTrace();
> /*     */         } 
> /* 329 */         ColorModel cm = ip.getColorModel();
> /* 330 */         LUT lut = (cm instanceof LUT) ? (LUT)cm : null;
> /* 331 */         luts.add(lut);
> /*     */       } 
> /*     */     }
> /*     */     
> /* 335 */     return (ImageStack)virtualStack;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ImageStack readPlanes(ImportProcess process, int s, List<LUT> luts, boolean thumbnail) {
> /* 342 */     ImageProcessorReader reader = process.getReader();
> /* 343 */     reader.setSeries(s);
> /* 344 */     int zCount = process.getZCount(s);
> /* 345 */     int cCount = process.getCCount(s);
> /* 346 */     int tCount = process.getTCount(s);
> /* 347 */     IMetadata meta = process.getOMEMetadata();
> /*     */ 
> /*     */     
> /* 350 */     boolean[] load = getPlanesToLoad(s);
> /* 351 */     int current = 0, total = 0;
> /* 352 */     for (int j = 0; j < load.length; ) { if (load[j]) total++;  j++; }
> /*     */     
> /* 354 */     List<ImageProcessor> procs = new ArrayList<>();
> /* 355 */     List<String> labels = new ArrayList<>();
> /*     */ 
> /*     */     
> /* 358 */     Region region = process.getCropRegion(s);
> /* 359 */     for (int i = 0; i < load.length; i++) {
> /* 360 */       if (load[i]) {
> /*     */ 
> /*     */         
> /* 363 */         updateTiming(s, current, current++, total);
> /*     */ 
> /*     */         
> /* 366 */         ImageProcessor[] p = readProcessors(process, i, region, thumbnail);
> /*     */ 
> /*     */         
> /* 369 */         String label = constructSliceLabel(i, 
> /* 370 */             reader, meta, s, zCount, cCount, tCount); byte b; int k;
> /*     */         ImageProcessor[] arrayOfImageProcessor1;
> /* 372 */         for (k = (arrayOfImageProcessor1 = p).length, b = 0; b < k; ) { ImageProcessor ip = arrayOfImageProcessor1[b];
> /* 373 */           procs.add(ip);
> /* 374 */           labels.add(label); b++; }
> /*     */       
> /*     */       } 
> /*     */     } 
> /* 378 */     return createStack(procs, labels, luts);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ImageProcessor[] readProcessors(ImportProcess process, int no, Region r, boolean thumbnail) {
> /* 390 */     ImageProcessorReader reader = process.getReader();
> /* 391 */     ImporterOptions options = process.getOptions();
> /*     */     
> /* 393 */     boolean first = true;
> /* 394 */     for (int i = 0; i < 5; i++) {
> /* 395 */       String code = LuraWave.initLicenseCode();
> /*     */       try {
> /* 397 */         if (thumbnail) {
> /*     */           try {
> /* 399 */             return reader.openThumbProcessors(no);
> /* 400 */           } catch (IOException e) {
> /*     */             
> /* 402 */             e.printStackTrace();
> /*     */           } 
> /*     */         }
> /*     */         try {
> /* 406 */           return reader.openProcessors(no, r.x, r.y, r.width, r.height);
> /* 407 */         } catch (IOException e) {
> /*     */           
> /* 409 */           e.printStackTrace();
> /*     */         }
> /*     */       
> /* 412 */       } catch (FormatException exc) {
> /*     */ 
> /*     */         
> /* 415 */         code = LuraWave.promptLicenseCode(code, first);
> /* 416 */         if (first) first = false; 
> /*     */       } 
> /*     */     } 
> /* 419 */     return null;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public List<ImagePlus> concatenate(List<ImagePlus> imps) {
> /* 426 */     ImporterOptions options = this.process.getOptions();
> /* 427 */     if (options.isConcatenate()) imps = (new Concatenator()).concatenate(imps); 
> /* 428 */     return imps;
> /*     */   }
> /*     */   
> /*     */   public List<ImagePlus> applyColors(List<ImagePlus> imps) {
> /* 432 */     return (new Colorizer(this.process)).applyColors(imps);
> /*     */   }
> /*     */   
> /*     */   public List<ImagePlus> splitDims(List<ImagePlus> imps) {
> /* 436 */     ImporterOptions options = this.process.getOptions();
> /*     */     
> /* 438 */     boolean sliceC = options.isSplitChannels();
> /* 439 */     boolean sliceZ = options.isSplitFocalPlanes();
> /* 440 */     boolean sliceT = options.isSplitTimepoints();
> /* 441 */     if (sliceC || sliceZ || sliceT) {
> /* 442 */       String stackOrder = this.process.getStackOrder();
> /* 443 */       List<ImagePlus> slicedImps = new ArrayList<>();
> /* 444 */       Slicer slicer = new Slicer();
> /* 445 */       for (ImagePlus imp : imps) {
> /* 446 */         ImagePlus[] results = slicer.reslice(imp, 
> /* 447 */             sliceC, sliceZ, sliceT, stackOrder); byte b; int i; ImagePlus[] arrayOfImagePlus1;
> /* 448 */         for (i = (arrayOfImagePlus1 = results).length, b = 0; b < i; ) { ImagePlus result = arrayOfImagePlus1[b]; slicedImps.add(result); b++; }
> /*     */       
> /* 450 */       }  imps = slicedImps;
> /*     */     } 
> /* 452 */     return imps;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void startTiming() {
> /* 460 */     this.startTime = this.time = System.currentTimeMillis();
> /*     */   }
> /*     */   
> /*     */   public void updateTiming(int s, int i, int current, int total) {
> /* 464 */     ImageProcessorReader reader = this.process.getReader();
> /*     */     
> /* 466 */     long clock = System.currentTimeMillis();
> /* 467 */     if (clock - this.time >= 100L) {
> /* 468 */       String sLabel = (reader.getSeriesCount() > 1) ? (
> /* 469 */         "series " + (s + 1) + ", ") : "";
> /* 470 */       String pLabel = "plane " + (i + 1) + "/" + total;
> /* 471 */       notifyListeners(new StatusEvent("Reading " + sLabel + pLabel));
> /* 472 */       this.time = clock;
> /*     */     } 
> /* 474 */     notifyListeners(new StatusEvent(current, total, null));
> /*     */   }
> /*     */   
> /*     */   public void finishTiming() {
> /* 478 */     ImageProcessorReader reader = this.process.getReader();
> /*     */     
> /* 480 */     long endTime = System.currentTimeMillis();
> /* 481 */     double elapsed = (endTime - this.startTime) / 1000.0D;
> /* 482 */     if (reader.getImageCount() == 1) {
> /* 483 */       notifyListeners(new StatusEvent("Bio-Formats: " + elapsed + " seconds"));
> /*     */     } else {
> /*     */       
> /* 486 */       long average = (endTime - this.startTime) / reader.getImageCount();
> /* 487 */       notifyListeners(new StatusEvent("Bio-Formats: " + 
> /* 488 */             elapsed + " seconds (" + average + " ms per plane)"));
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public FileInfo createFileInfo() {
> /* 495 */     FileInfo fi = new FileInfo();
> /*     */ 
> /*     */     
> /* 498 */     String idDir = (this.process.getIdLocation() == null) ? 
> /* 499 */       null : this.process.getIdLocation().getParent();
> /* 500 */     if (idDir != null && !idDir.endsWith(File.separator)) {
> /* 501 */       idDir = String.valueOf(idDir) + File.separator;
> /*     */     }
> /* 503 */     fi.fileName = this.process.getIdName();
> /* 504 */     fi.directory = idDir;
> /*     */ 
> /*     */ 
> /*     */     
> /* 508 */     try { ServiceFactory factory = new ServiceFactory();
> /* 509 */       OMEXMLService service = (OMEXMLService)factory.getInstance(OMEXMLService.class);
> /* 510 */       fi.description = service.getOMEXML((MetadataRetrieve)this.process.getOMEMetadata()); }
> /*     */     
> /* 512 */     catch (DependencyException dependencyException) {  }
> /* 513 */     catch (ServiceException serviceException) {}
> /*     */     
> /* 515 */     return fi;
> /*     */   }
> /*     */   
> /*     */   public boolean[] getPlanesToLoad(int s) {
> /* 519 */     ImageProcessorReader reader = this.process.getReader();
> /* 520 */     boolean[] load = new boolean[reader.getImageCount()];
> /* 521 */     int cBegin = this.process.getCBegin(s);
> /* 522 */     int cEnd = this.process.getCEnd(s);
> /* 523 */     int cStep = this.process.getCStep(s);
> /* 524 */     int zBegin = this.process.getZBegin(s);
> /* 525 */     int zEnd = this.process.getZEnd(s);
> /* 526 */     int zStep = this.process.getZStep(s);
> /* 527 */     int tBegin = this.process.getTBegin(s);
> /* 528 */     int tEnd = this.process.getTEnd(s);
> /* 529 */     int tStep = this.process.getTStep(s);
> /* 530 */     for (int c = cBegin; c <= cEnd; c += cStep) {
> /* 531 */       for (int z = zBegin; z <= zEnd; z += zStep) {
> /* 532 */         for (int t = tBegin; t <= tEnd; t += tStep) {
> /* 533 */           int index = reader.getIndex(z, c, t);
> /* 534 */           load[index] = true;
> /*     */         } 
> /*     */       } 
> /*     */     } 
> /* 538 */     return load;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String constructImageTitle(IFormatReader r, String file, String seriesName, boolean groupFiles) {
> /* 544 */     String[] used = r.getUsedFiles();
> /* 545 */     String title = file.substring(file.lastIndexOf(File.separator) + 1);
> /* 546 */     if (used.length > 1 && groupFiles) {
> /* 547 */       FilePattern fp = new FilePattern(new Location(file));
> /* 548 */       title = fp.getPattern();
> /* 549 */       if (title == null) {
> /* 550 */         title = file;
> /* 551 */         if (title.indexOf(".") != -1) {
> /* 552 */           title = title.substring(0, title.lastIndexOf("."));
> /*     */         }
> /*     */       } 
> /* 555 */       title = title.substring(title.lastIndexOf(File.separator) + 1);
> /*     */     } 
> /* 557 */     if (seriesName != null && !file.endsWith(seriesName) && 
> /* 558 */       r.getSeriesCount() > 1)
> /*     */     {
> /* 560 */       title = String.valueOf(title) + " - " + seriesName;
> /*     */     }
> /* 562 */     if (title.length() > 128) {
> /* 563 */       String a = title.substring(0, 62);
> /* 564 */       String b = title.substring(title.length() - 62);
> /* 565 */       title = String.valueOf(a) + "..." + b;
> /*     */     } 
> /* 567 */     return title;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String constructSliceLabel(int ndx, ImageProcessorReader r, IMetadata meta, int series, int zCount, int cCount, int tCount) {
> /* 573 */     r.setSeries(series);
> /*     */     
> /* 575 */     int[] zct = r.getZCTCoords(ndx);
> /*     */ 
> /*     */     
> /* 578 */     StringBuffer sb = new StringBuffer();
> /*     */     
> /* 580 */     boolean first = true;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 589 */     if (zCount > 1) {
> /* 590 */       if (first) { first = false; }
> /* 591 */       else { sb.append("; "); }
> /* 592 */        sb.append("z:");
> /* 593 */       sb.append(zct[0] + 1);
> /* 594 */       sb.append("/");
> /* 595 */       sb.append(r.getSizeZ());
> /*     */     } 
> /* 597 */     if (tCount > 1) {
> /* 598 */       if (first) { first = false; }
> /* 599 */       else { sb.append("; "); }
> /* 600 */        sb.append("t:");
> /* 601 */       sb.append(zct[2] + 1);
> /* 602 */       sb.append("/");
> /* 603 */       sb.append(r.getSizeT());
> /*     */     } 
> /*     */     
> /* 606 */     String imageName = meta.getImageName(series);
> /* 607 */     if (imageName != null && !imageName.trim().equals("")) {
> /* 608 */       sb.append(" - ");
> /* 609 */       sb.append(imageName);
> /*     */     } 
> /* 611 */     return sb.toString();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static void saveLUTs(ImagePlus imp, List<LUT> luts) {
> /* 619 */     for (int i = 0; i < luts.size(); i++) {
> /* 620 */       LUT lut = luts.get(i);
> /* 621 */       if (lut != null)
> /* 622 */         imp.setProperty("LUT-" + i, lut); 
> /*     */     } 
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/ImagePlusReaderModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in TrackAnalyzer_: images
diff -r TrackAnalyzer_/ISBIChallengeExporterModified.java jd-gui/ISBIChallengeExporterModified.java
1,144c1,160
< import fiji.plugin.trackmate.Logger;
< import fiji.plugin.trackmate.Model;
< import fiji.plugin.trackmate.SelectionModel;
< import fiji.plugin.trackmate.Settings;
< import fiji.plugin.trackmate.Spot;
< import fiji.plugin.trackmate.TrackMate;
< import fiji.plugin.trackmate.action.AbstractTMAction;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings;
< import fiji.plugin.trackmate.io.IOUtils;
< import java.awt.Frame;
< import java.io.File;
< import java.io.FileNotFoundException;
< import java.io.FileOutputStream;
< import java.io.IOException;
< import java.util.Date;
< import java.util.Iterator;
< import java.util.Set;
< import java.util.TreeSet;
< import java.util.regex.Matcher;
< import java.util.regex.Pattern;
< import org.jdom2.Document;
< import org.jdom2.Element;
< import org.jdom2.output.Format;
< import org.jdom2.output.XMLOutputter;
< 
< public class ISBIChallengeExporterModified extends AbstractTMAction {
<    public static final String NAME = "Export to ISBI challenge format";
<    public static final String KEY = "EXPORT_TO_ISBI_CHALLENGE_FORMAT";
<    public static final String INFO_TEXT = "<html>Export the current model content to a XML file following the ISBI 2012 particle tracking challenge format, as specified on <a href='http://bioimageanalysis.org/track/'></a>. <p> Only tracks are exported. If there is no track, this action does nothing. </html>";
<    private static final String CONTENT_KEY = "TrackContestISBI2012";
<    private static final String DATE_ATT = "generationDateTime";
<    private static final String SNR_ATT = "snr";
<    private static final String DENSITY_ATT = "density";
<    private static final String SCENARIO_ATT = "scenario";
<    private static final String TRACK_KEY = "particle";
<    private static final String SPOT_KEY = "detection";
<    private static final String X_ATT = "x";
<    private static final String Y_ATT = "y";
<    private static final String Z_ATT = "z";
<    private static final String T_ATT = "t";
< 
<    public void execute(TrackMate trackmate, SelectionModel selectionModel, DisplaySettings displaySettings, Frame parent) {
<       Model model = trackmate.getModel();
<       File folder = (new File(System.getProperty("user.dir"))).getParentFile().getParentFile();
< 
<       File file;
<       try {
<          String filename = trackmate.getSettings().imageFileName;
<          filename = filename.substring(0, filename.indexOf("."));
<          file = new File(folder.getPath() + File.separator + filename + "_ISBI.xml");
<       } catch (NullPointerException var9) {
<          file = new File(folder.getPath() + File.separator + "ISBIChallenge2012Result.xml");
<       }
< 
<       file = IOUtils.askForFileForSaving(file, parent, this.logger);
<       exportToFile(model, trackmate.getSettings(), file, this.logger);
<    }
< 
<    public static void exportToFile(Model model, Settings settings, File file) {
<       exportToFile(model, settings, file, model.getLogger());
<    }
< 
<    public static void exportToFile(Model model, Settings settings, File file, Logger logger) {
<       SPTBatch_.taskOutput.append("Exporting to ISBI 2012 particle tracking challenge format.\n");
<       int ntracks = model.getTrackModel().nTracks(true);
<       if (ntracks == 0) {
<          SPTBatch_.taskOutput.append("No visible track found. Aborting.\n");
<       } else {
<          SPTBatch_.taskOutput.append("  Preparing XML data.\n");
<          Element root = marshall(model, settings);
<          SPTBatch_.taskOutput.append("  Writing to file.\n");
<          Document document = new Document(root);
<          XMLOutputter outputter = new XMLOutputter(Format.getPrettyFormat());
< 
<          try {
<             outputter.output(document, new FileOutputStream(file));
<          } catch (FileNotFoundException var9) {
<             SPTBatch_.taskOutput.append("Trouble writing to " + file + ":\n" + var9.getMessage());
<          } catch (IOException var10) {
<             SPTBatch_.taskOutput.append("Trouble writing to " + file + ":\n" + var10.getMessage());
<          }
< 
<          SPTBatch_.taskOutput.append("Done.\n");
<       }
<    }
< 
<    private static final Element marshall(Model model, Settings settings) {
<       Logger logger = model.getLogger();
<       Element root = new Element("root");
<       Element content = new Element("TrackContestISBI2012");
<       String filename = settings.imageFileName;
<       String pattern = "^(\\w+) snr (\\d+) density (\\w+)\\.";
<       Pattern r = Pattern.compile("^(\\w+) snr (\\d+) density (\\w+)\\.");
<       Matcher m = r.matcher(filename);
<       String snr_val;
<       String density_val;
<       String scenario_val;
<       if (m.find()) {
<          scenario_val = m.group(1);
<          snr_val = m.group(2);
<          density_val = m.group(3);
<       } else {
<          scenario_val = filename;
<          snr_val = "?";
<          density_val = "?";
<       }
< 
<       content.setAttribute("snr", snr_val);
<       content.setAttribute("density", density_val);
<       content.setAttribute("scenario", scenario_val);
<       content.setAttribute("generationDateTime", (new Date()).toString());
<       SPTBatch_.taskOutput.append("Marshalling...");
<       Integer[] visibleTracks = (Integer[])model.getTrackModel().trackIDs(true).toArray(new Integer[0]);
< 
<       for(int i = 0; i < model.getTrackModel().nTracks(true); ++i) {
<          Element trackElement = new Element("particle");
<          int trackindex = visibleTracks[i];
<          Set<Spot> track = model.getTrackModel().trackSpots(trackindex);
<          TreeSet<Spot> sortedTrack = new TreeSet(Spot.timeComparator);
<          sortedTrack.addAll(track);
<          Iterator var19 = sortedTrack.iterator();
< 
<          while(var19.hasNext()) {
<             Spot spot = (Spot)var19.next();
<             int t = spot.getFeature("FRAME").intValue();
<             double x = spot.getFeature("POSITION_X");
<             double y = spot.getFeature("POSITION_Y");
<             double z = spot.getFeature("POSITION_Z");
<             Element spotElement = new Element("detection");
<             spotElement.setAttribute("t", "" + t);
<             spotElement.setAttribute("x", "" + x);
<             spotElement.setAttribute("y", "" + y);
<             spotElement.setAttribute("z", "" + z);
<             trackElement.addContent(spotElement);
<          }
< 
<          content.addContent(trackElement);
<          SPTBatch_.taskOutput.append(String.valueOf((double)i / (0.0D + (double)model.getTrackModel().nTracks(true))));
<       }
< 
<       root.addContent(content);
<       return root;
<    }
< }
---
> /*     */ import fiji.plugin.trackmate.Logger;
> /*     */ import fiji.plugin.trackmate.Model;
> /*     */ import fiji.plugin.trackmate.SelectionModel;
> /*     */ import fiji.plugin.trackmate.Settings;
> /*     */ import fiji.plugin.trackmate.Spot;
> /*     */ import fiji.plugin.trackmate.TrackMate;
> /*     */ import fiji.plugin.trackmate.action.AbstractTMAction;
> /*     */ import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings;
> /*     */ import fiji.plugin.trackmate.io.IOUtils;
> /*     */ import java.awt.Frame;
> /*     */ import java.io.File;
> /*     */ import java.io.FileNotFoundException;
> /*     */ import java.io.FileOutputStream;
> /*     */ import java.io.IOException;
> /*     */ import java.util.Date;
> /*     */ import java.util.Set;
> /*     */ import java.util.TreeSet;
> /*     */ import java.util.regex.Matcher;
> /*     */ import java.util.regex.Pattern;
> /*     */ import org.jdom2.Content;
> /*     */ import org.jdom2.Document;
> /*     */ import org.jdom2.Element;
> /*     */ import org.jdom2.output.Format;
> /*     */ import org.jdom2.output.XMLOutputter;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class ISBIChallengeExporterModified
> /*     */   extends AbstractTMAction
> /*     */ {
> /*     */   public static final String NAME = "Export to ISBI challenge format";
> /*     */   public static final String KEY = "EXPORT_TO_ISBI_CHALLENGE_FORMAT";
> /*     */   public static final String INFO_TEXT = "<html>Export the current model content to a XML file following the ISBI 2012 particle tracking challenge format, as specified on <a href='http://bioimageanalysis.org/track/'></a>. <p> Only tracks are exported. If there is no track, this action does nothing. </html>";
> /*     */   private static final String CONTENT_KEY = "TrackContestISBI2012";
> /*     */   private static final String DATE_ATT = "generationDateTime";
> /*     */   private static final String SNR_ATT = "snr";
> /*     */   private static final String DENSITY_ATT = "density";
> /*     */   private static final String SCENARIO_ATT = "scenario";
> /*     */   private static final String TRACK_KEY = "particle";
> /*     */   private static final String SPOT_KEY = "detection";
> /*     */   private static final String X_ATT = "x";
> /*     */   private static final String Y_ATT = "y";
> /*     */   private static final String Z_ATT = "z";
> /*     */   private static final String T_ATT = "t";
> /*     */   
> /*     */   public void execute(TrackMate trackmate, SelectionModel selectionModel, DisplaySettings displaySettings, Frame parent) {
> /*  48 */     Model model = trackmate.getModel();
> /*     */     
> /*  50 */     File folder = (new File(System.getProperty("user.dir"))).getParentFile().getParentFile();
> /*     */     try {
> /*  52 */       String filename = (trackmate.getSettings()).imageFileName;
> /*  53 */       filename = filename.substring(0, filename.indexOf("."));
> /*  54 */       file = new File(String.valueOf(folder.getPath()) + File.separator + filename + "_ISBI.xml");
> /*  55 */     } catch (NullPointerException npe) {
> /*  56 */       file = new File(String.valueOf(folder.getPath()) + File.separator + "ISBIChallenge2012Result.xml");
> /*     */     } 
> /*  58 */     File file = IOUtils.askForFileForSaving(file, parent, this.logger);
> /*     */     
> /*  60 */     exportToFile(model, trackmate.getSettings(), file, this.logger);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public static void exportToFile(Model model, Settings settings, File file) {
> /*  65 */     exportToFile(model, settings, file, model.getLogger());
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public static void exportToFile(Model model, Settings settings, File file, Logger logger) {
> /*  70 */     SPTBatch_.taskOutput.append("Exporting to ISBI 2012 particle tracking challenge format.\n");
> /*  71 */     int ntracks = model.getTrackModel().nTracks(true);
> /*  72 */     if (ntracks == 0) {
> /*  73 */       SPTBatch_.taskOutput.append("No visible track found. Aborting.\n");
> /*     */       
> /*     */       return;
> /*     */     } 
> /*  77 */     SPTBatch_.taskOutput.append("  Preparing XML data.\n");
> /*  78 */     Element root = marshall(model, settings);
> /*     */     
> /*  80 */     SPTBatch_.taskOutput.append("  Writing to file.\n");
> /*  81 */     Document document = new Document(root);
> /*  82 */     XMLOutputter outputter = new XMLOutputter(Format.getPrettyFormat());
> /*     */     try {
> /*  84 */       outputter.output(document, new FileOutputStream(file));
> /*  85 */     } catch (FileNotFoundException e) {
> /*  86 */       SPTBatch_.taskOutput.append("Trouble writing to " + file + ":\n" + e.getMessage());
> /*  87 */     } catch (IOException e) {
> /*  88 */       SPTBatch_.taskOutput.append("Trouble writing to " + file + ":\n" + e.getMessage());
> /*     */     } 
> /*  90 */     SPTBatch_.taskOutput.append("Done.\n");
> /*     */   }
> /*     */   private static final Element marshall(Model model, Settings settings) {
> /*     */     String snr_val, density_val, scenario_val;
> /*  94 */     Logger logger = model.getLogger();
> /*     */     
> /*  96 */     Element root = new Element("root");
> /*  97 */     Element content = new Element("TrackContestISBI2012");
> /*     */ 
> /*     */     
> /* 100 */     String filename = settings.imageFileName;
> /* 101 */     String pattern = "^(\\w+) snr (\\d+) density (\\w+)\\.";
> /* 102 */     Pattern r = Pattern.compile("^(\\w+) snr (\\d+) density (\\w+)\\.");
> /* 103 */     Matcher m = r.matcher(filename);
> /*     */ 
> /*     */ 
> /*     */     
> /* 107 */     if (m.find()) {
> /* 108 */       scenario_val = m.group(1);
> /* 109 */       snr_val = m.group(2);
> /* 110 */       density_val = m.group(3);
> /*     */     } else {
> /* 112 */       scenario_val = filename;
> /* 113 */       snr_val = "?";
> /* 114 */       density_val = "?";
> /*     */     } 
> /* 116 */     content.setAttribute("snr", snr_val);
> /* 117 */     content.setAttribute("density", density_val);
> /* 118 */     content.setAttribute("scenario", scenario_val);
> /* 119 */     content.setAttribute("generationDateTime", (new Date()).toString());
> /*     */     
> /* 121 */     SPTBatch_.taskOutput.append("Marshalling...");
> /* 122 */     Integer[] visibleTracks = (Integer[])model.getTrackModel().trackIDs(true).toArray((Object[])new Integer[0]);
> /* 123 */     for (int i = 0; i < model.getTrackModel().nTracks(true); i++) {
> /*     */       
> /* 125 */       Element trackElement = new Element("particle");
> /* 126 */       int trackindex = visibleTracks[i].intValue();
> /* 127 */       Set<Spot> track = model.getTrackModel().trackSpots(Integer.valueOf(trackindex));
> /*     */       
> /* 129 */       TreeSet<Spot> sortedTrack = new TreeSet<>(Spot.timeComparator);
> /* 130 */       sortedTrack.addAll(track);
> /*     */       
> /* 132 */       for (Spot spot : sortedTrack) {
> /* 133 */         int t = spot.getFeature("FRAME").intValue();
> /* 134 */         double x = spot.getFeature("POSITION_X").doubleValue();
> /* 135 */         double y = spot.getFeature("POSITION_Y").doubleValue();
> /* 136 */         double z = spot.getFeature("POSITION_Z").doubleValue();
> /*     */         
> /* 138 */         Element spotElement = new Element("detection");
> /* 139 */         spotElement.setAttribute("t", t);
> /* 140 */         spotElement.setAttribute("x", x);
> /* 141 */         spotElement.setAttribute("y", y);
> /* 142 */         spotElement.setAttribute("z", z);
> /* 143 */         trackElement.addContent((Content)spotElement);
> /*     */       } 
> /* 145 */       content.addContent((Content)trackElement);
> /* 146 */       SPTBatch_.taskOutput.append((new StringBuilder(String.valueOf(i / (0.0D + model.getTrackModel().nTracks(true))))).toString());
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */     
> /* 151 */     root.addContent((Content)content);
> /* 152 */     return root;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/ISBIChallengeExporterModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/LabelWizardPanel.java jd-gui/LabelWizardPanel.java
1,3c1,31
< import javax.swing.JButton;
< import jwizardcomponent.JWizardComponents;
< import jwizardcomponent.JWizardPanel;
---
> /*    */ import javax.swing.JButton;
> /*    */ import jwizardcomponent.JWizardComponents;
> /*    */ import jwizardcomponent.JWizardPanel;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class LabelWizardPanel
> /*    */   extends JWizardPanel
> /*    */ {
> /*    */   public LabelWizardPanel(JWizardComponents wizardComponents, String label) {
> /* 27 */     super(wizardComponents);
> /* 28 */     JButton backButton = wizardComponents.getBackButton();
> /* 29 */     backButton.setText("");
> /*    */   }
> /*    */ }
5,11c33,37
< public class LabelWizardPanel extends JWizardPanel {
<    public LabelWizardPanel(JWizardComponents wizardComponents, String label) {
<       super(wizardComponents);
<       JButton backButton = wizardComponents.getBackButton();
<       backButton.setText("");
<    }
< }
---
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/LabelWizardPanel.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/LastWizardPanel.java jd-gui/LastWizardPanel.java
1,2c1,374
< import javax.swing.JTabbedPane;
< import jwizardcomponent.JWizardComponents;
---
> /*     */ import javax.swing.JTabbedPane;
> /*     */ import jwizardcomponent.JWizardComponents;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class LastWizardPanel
> /*     */   extends LabelWizardPanel
> /*     */ {
> /*     */   public LastWizardPanel(JWizardComponents wizardComponents) {
> /*  25 */     super(wizardComponents, "");
> /*  26 */     setPanelTitle("  PLOT-OPTIONS:  Spots,Links or Tracks");
> /*  27 */     update();
> /*  28 */     removeAll();
> /*     */     
> /*  30 */     JTabbedPane tabbedPane = new JTabbedPane();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void update() {
> /* 350 */     setNextButtonEnabled(false);
> /*     */ 
> /*     */ 
> /*     */     
> /* 354 */     setFinishButtonEnabled(true);
> /* 355 */     setBackButtonEnabled(true);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void next() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void back() {
> /* 367 */     switchPanel(1);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void finish() {
> /* 372 */     switchPanel(2);
> /*     */   }
> /*     */ }
4,11d375
< public class LastWizardPanel extends LabelWizardPanel {
<    public LastWizardPanel(JWizardComponents wizardComponents) {
<       super(wizardComponents, "");
<       this.setPanelTitle("  PLOT-OPTIONS:  Spots,Links or Tracks");
<       this.update();
<       this.removeAll();
<       new JTabbedPane();
<    }
13,29c377,380
<    public void update() {
<       this.setNextButtonEnabled(false);
<       this.setFinishButtonEnabled(true);
<       this.setBackButtonEnabled(true);
<    }
< 
<    public void next() {
<    }
< 
<    public void back() {
<       this.switchPanel(1);
<    }
< 
<    public void finish() {
<       this.switchPanel(2);
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/LastWizardPanel.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/math/ActiveTransportMSDLineFitModified.java jd-gui/math/ActiveTransportMSDLineFitModified.java
1,30c1,50
< package math;
< 
< import ij.measure.CurveFitter;
< 
< public class ActiveTransportMSDLineFitModified {
<    double a;
<    double b;
<    double goodness;
< 
<    public void doFit(double[] xdata, double[] ydata) {
<       new CurveFitter(xdata, ydata);
<       CurveFitter fitter = new CurveFitter(xdata, ydata);
<       fitter.doCustomFit("y=a*a*x*x + 4*sqrt(b*b)*x", new double[]{0.0D, 0.0D}, false);
<       this.a = Math.abs(fitter.getParams()[0]);
<       this.b = Math.abs(fitter.getParams()[1]);
<       this.goodness = fitter.getFitGoodness();
<    }
< 
<    public double getVelocity() {
<       return this.a;
<    }
< 
<    public double getDiffusionCoefficient() {
<       return this.b;
<    }
< 
<    public double getFitGoodness() {
<       return this.goodness;
<    }
< }
---
> /*    */ package math;
> /*    */ 
> /*    */ import ij.measure.CurveFitter;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class ActiveTransportMSDLineFitModified
> /*    */ {
> /*    */   double a;
> /*    */   double b;
> /*    */   double goodness;
> /*    */   
> /*    */   public void doFit(double[] xdata, double[] ydata) {
> /* 22 */     CurveFitter fitter = new CurveFitter(xdata, ydata);
> /*    */     
> /* 24 */     fitter = new CurveFitter(xdata, ydata);
> /*    */     
> /* 26 */     fitter.doCustomFit("y=a*a*x*x + 4*sqrt(b*b)*x", new double[] { 0.0D, 0.0D }, false);
> /* 27 */     this.a = Math.abs(fitter.getParams()[0]);
> /* 28 */     this.b = Math.abs(fitter.getParams()[1]);
> /* 29 */     this.goodness = fitter.getFitGoodness();
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public double getVelocity() {
> /* 34 */     return this.a;
> /*    */   }
> /*    */   
> /*    */   public double getDiffusionCoefficient() {
> /* 38 */     return this.b;
> /*    */   }
> /*    */   
> /*    */   public double getFitGoodness() {
> /* 42 */     return this.goodness;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/math/ActiveTransportMSDLineFitModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/math/ConfinedDiffusionMSDCurveFitModified.java jd-gui/math/ConfinedDiffusionMSDCurveFitModified.java
1,74c1,103
< package math;
< 
< import ij.measure.CurveFitter;
< 
< public class ConfinedDiffusionMSDCurveFitModified {
<    private double a;
<    private double b;
<    private double c;
<    private double D;
<    private double goodness;
<    private double initA = Double.NaN;
<    private double initB = Double.NaN;
<    private double initC = Double.NaN;
<    private double initD = Double.NaN;
< 
<    public void doFit(double[] xdata, double[] ydata, boolean reduced) {
<       CurveFitter fitter = new CurveFitter(xdata, ydata);
<       double ia;
<       double ib;
<       if (!reduced) {
<          ia = Double.isNaN(this.initA) ? 0.0D : this.initA;
<          ib = Double.isNaN(this.initB) ? 0.0D : this.initB;
<          double ic = Double.isNaN(this.initC) ? 0.0D : this.initC;
<          double id = Double.isNaN(this.initD) ? 0.0D : this.initD;
<          double[] initialParams = new double[]{ia, ib, ic, id};
<          fitter.setInitialParameters(initialParams);
<          fitter.doCustomFit("y=sqrt(a*a)*(1-sqrt(b*b)*exp(-4*sqrt(c*c)*sqrt(d*d)*x/sqrt(a*a)))", initialParams, false);
<          double[] params = fitter.getParams();
<          this.a = Math.abs(params[0]);
<          this.b = Math.abs(params[1]);
<          this.c = Math.abs(params[2]);
<          this.D = Math.abs(params[3]);
<          this.goodness = fitter.getFitGoodness();
<       } else {
<          ia = Double.isNaN(this.initA) ? 0.0D : this.initA;
<          ib = Double.isNaN(this.initD) ? 0.0D : this.initD;
<          double[] initialParams = new double[]{ia, ib};
<          fitter.setInitialParameters(initialParams);
<          fitter.doCustomFit("y=sqrt(a*a)*(1-exp(-4*sqrt(b*b)*x/sqrt(a*a)))", initialParams, false);
<          double[] params = fitter.getParams();
<          this.a = Math.abs(params[0]);
<          this.D = Math.abs(params[1]);
<          this.goodness = fitter.getFitGoodness();
<       }
< 
<    }
< 
<    public void setInitParameters(double[] p) {
<       this.initA = p[0];
<       this.initB = p[1];
<       this.initC = p[2];
<       this.initD = p[3];
<    }
< 
<    public double getA() {
<       return this.a;
<    }
< 
<    public double getB() {
<       return this.b;
<    }
< 
<    public double getC() {
<       return this.c;
<    }
< 
<    public double getD() {
<       return this.D;
<    }
< 
<    public double getGoodness() {
<       return this.goodness;
<    }
< }
---
> /*    */ package math;
> /*    */ 
> /*    */ import ij.measure.CurveFitter;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class ConfinedDiffusionMSDCurveFitModified
> /*    */ {
> /*    */   private double a;
> /*    */   private double b;
> /*    */   private double c;
> /*    */   private double D;
> /*    */   private double goodness;
> /* 27 */   private double initA = Double.NaN;
> /* 28 */   private double initB = Double.NaN;
> /* 29 */   private double initC = Double.NaN;
> /* 30 */   private double initD = Double.NaN;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public void doFit(double[] xdata, double[] ydata, boolean reduced) {
> /* 41 */     CurveFitter fitter = new CurveFitter(xdata, ydata);
> /* 42 */     if (!reduced) {
> /* 43 */       double ia = Double.isNaN(this.initA) ? 0.0D : this.initA;
> /* 44 */       double ib = Double.isNaN(this.initB) ? 0.0D : this.initB;
> /* 45 */       double ic = Double.isNaN(this.initC) ? 0.0D : this.initC;
> /* 46 */       double id = Double.isNaN(this.initD) ? 0.0D : this.initD;
> /* 47 */       double[] initialParams = { ia, ib, ic, id };
> /* 48 */       fitter.setInitialParameters(initialParams);
> /*    */       
> /* 50 */       fitter.doCustomFit("y=sqrt(a*a)*(1-sqrt(b*b)*exp(-4*sqrt(c*c)*sqrt(d*d)*x/sqrt(a*a)))", initialParams, false);
> /* 51 */       double[] params = fitter.getParams();
> /* 52 */       this.a = Math.abs(params[0]);
> /* 53 */       this.b = Math.abs(params[1]);
> /* 54 */       this.c = Math.abs(params[2]);
> /* 55 */       this.D = Math.abs(params[3]);
> /* 56 */       this.goodness = fitter.getFitGoodness();
> /*    */     } else {
> /* 58 */       double ia = Double.isNaN(this.initA) ? 0.0D : this.initA;
> /* 59 */       double id = Double.isNaN(this.initD) ? 0.0D : this.initD;
> /* 60 */       double[] initialParams = { ia, id };
> /* 61 */       fitter.setInitialParameters(initialParams);
> /*    */       
> /* 63 */       fitter.doCustomFit("y=sqrt(a*a)*(1-exp(-4*sqrt(b*b)*x/sqrt(a*a)))", initialParams, false);
> /* 64 */       double[] params = fitter.getParams();
> /* 65 */       this.a = Math.abs(params[0]);
> /* 66 */       this.D = Math.abs(params[1]);
> /* 67 */       this.goodness = fitter.getFitGoodness();
> /*    */     } 
> /*    */   }
> /*    */   
> /*    */   public void setInitParameters(double[] p) {
> /* 72 */     this.initA = p[0];
> /* 73 */     this.initB = p[1];
> /* 74 */     this.initC = p[2];
> /* 75 */     this.initD = p[3];
> /*    */   }
> /*    */   
> /*    */   public double getA() {
> /* 79 */     return this.a;
> /*    */   }
> /*    */   
> /*    */   public double getB() {
> /* 83 */     return this.b;
> /*    */   }
> /*    */   
> /*    */   public double getC() {
> /* 87 */     return this.c;
> /*    */   }
> /*    */   
> /*    */   public double getD() {
> /* 91 */     return this.D;
> /*    */   }
> /*    */   
> /*    */   public double getGoodness() {
> /* 95 */     return this.goodness;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/math/ConfinedDiffusionMSDCurveFitModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/math/MomentsCalculatorModified.java jd-gui/math/MomentsCalculatorModified.java
1,44c1,57
< package math;
< 
< import org.apache.commons.math3.linear.Array2DRowRealMatrix;
< import org.apache.commons.math3.linear.EigenDecomposition;
< import org.apache.commons.math3.stat.descriptive.moment.Mean;
< import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;
< import traJ.TrajectoryModified;
< import vecmath.Point3dModified;
< import vecmath.Vector2d;
< 
< public class MomentsCalculatorModified {
<    private TrajectoryModified t;
< 
<    public MomentsCalculatorModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public double calculateNthMoment(int n) {
<       Array2DRowRealMatrix gyr = RadiusGyrationTensor2DModified.getRadiusOfGyrationTensor(this.t);
<       EigenDecomposition eigdec = new EigenDecomposition(gyr);
<       Vector2d eigv = new Vector2d(eigdec.getEigenvector(0).getEntry(0), eigdec.getEigenvector(0).getEntry(1));
<       double[] projected = new double[this.t.size()];
< 
<       double mean;
<       for(int i = 0; i < this.t.size(); ++i) {
<          Vector2d pos = new Vector2d(((Point3dModified)this.t.get(i)).x, ((Point3dModified)this.t.get(i)).y);
<          mean = eigv.dot(pos);
<          projected[i] = mean;
<       }
< 
<       Mean m = new Mean();
<       StandardDeviation s = new StandardDeviation();
<       mean = m.evaluate(projected);
<       double sd = s.evaluate(projected);
<       double sumPowN = 0.0D;
< 
<       for(int i = 0; i < projected.length; ++i) {
<          sumPowN += Math.pow((projected[i] - mean) / sd, (double)n);
<       }
< 
<       double nThMoment = sumPowN / (double)projected.length;
<       return nThMoment;
<    }
< }
---
> /*    */ package math;
> /*    */ 
> /*    */ import org.apache.commons.math3.linear.Array2DRowRealMatrix;
> /*    */ import org.apache.commons.math3.linear.EigenDecomposition;
> /*    */ import org.apache.commons.math3.linear.RealMatrix;
> /*    */ import org.apache.commons.math3.stat.descriptive.moment.Mean;
> /*    */ import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;
> /*    */ import traJ.TrajectoryModified;
> /*    */ import vecmath.Point3dModified;
> /*    */ import vecmath.Vector2d;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class MomentsCalculatorModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   
> /*    */   public MomentsCalculatorModified(TrajectoryModified t) {
> /* 21 */     this.t = t;
> /*    */   }
> /*    */   
> /*    */   public double calculateNthMoment(int n) {
> /* 25 */     Array2DRowRealMatrix gyr = RadiusGyrationTensor2DModified.getRadiusOfGyrationTensor(this.t);
> /* 26 */     EigenDecomposition eigdec = new EigenDecomposition((RealMatrix)gyr);
> /*    */     
> /* 28 */     Vector2d eigv = new Vector2d(eigdec.getEigenvector(0).getEntry(0), eigdec.getEigenvector(0).getEntry(1));
> /*    */     
> /* 30 */     double[] projected = new double[this.t.size()];
> /* 31 */     for (int i = 0; i < this.t.size(); i++) {
> /* 32 */       Vector2d pos = new Vector2d(((Point3dModified)this.t.get(i)).x, ((Point3dModified)this.t.get(i)).y);
> /* 33 */       double v = eigv.dot(pos);
> /* 34 */       projected[i] = v;
> /*    */     } 
> /*    */     
> /* 37 */     Mean m = new Mean();
> /* 38 */     StandardDeviation s = new StandardDeviation();
> /* 39 */     double mean = m.evaluate(projected);
> /* 40 */     double sd = s.evaluate(projected);
> /* 41 */     double sumPowN = 0.0D;
> /*    */     
> /* 43 */     for (int j = 0; j < projected.length; j++) {
> /* 44 */       sumPowN += Math.pow((projected[j] - mean) / sd, n);
> /*    */     }
> /*    */     
> /* 47 */     double nThMoment = sumPowN / projected.length;
> /*    */     
> /* 49 */     return nThMoment;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/math/MomentsCalculatorModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/math/PowerLawCurveFitModified.java jd-gui/math/PowerLawCurveFitModified.java
1,69c1,79
< package math;
< 
< import ij.measure.CurveFitter;
< 
< public class PowerLawCurveFitModified {
<    private double alpha;
<    private double dc;
<    private double goodness;
< 
<    public void doFit(double[] xdata, double[] ydata) {
<       this.doFit(xdata, ydata, false, 0.0D, 0.0D);
<    }
< 
<    public void doFit(double[] xdata, double[] ydata, double initalAlpha, double initalDiffCoeff) {
<       this.doFit(xdata, ydata, true, initalAlpha, initalDiffCoeff);
<    }
< 
<    private void doFit(double[] xdata, double[] ydata, boolean useInitialGuess, double initalAlpha, double initalDiffCoeff) {
<       CurveFitter fitter = new CurveFitter(xdata, ydata);
<       if (useInitialGuess) {
<          fitter.setInitialParameters(new double[]{initalDiffCoeff, this.alpha});
<       }
< 
<       double[] init = null;
<       if (useInitialGuess) {
<          init = new double[]{initalAlpha, initalDiffCoeff};
<       }
< 
<       fitter.doFit(16);
<       double[] params = fitter.getParams();
<       boolean failed = fitter.getStatus() != 0;
<       if (failed) {
<          this.alpha = -1.0D;
<          this.dc = -1.0D;
<          this.goodness = 0.0D;
<       } else {
<          this.alpha = params[1];
<          this.dc = params[0] / 4.0D;
<          this.goodness = fitter.getFitGoodness();
<       }
< 
<       if (failed || this.alpha < 0.0D || this.dc < 0.0D) {
<          fitter = new CurveFitter(xdata, ydata);
< 
<          for(int i = 0; i < ydata.length; ++i) {
<             ydata[i] = Math.log(ydata[i]);
<          }
< 
<          fitter.doCustomFit("y=sqrt(a*a)*log(x)+log(4*sqrt(b*b))", init, false);
<          params = fitter.getParams();
<          this.alpha = Math.abs(params[0]);
<          this.dc = Math.abs(params[1]);
<          this.goodness = fitter.getFitGoodness();
<       }
< 
<    }
< 
<    public double getAlpha() {
<       return this.alpha;
<    }
< 
<    public double getDiffusionCoefficient() {
<       return this.dc;
<    }
< 
<    public double getGoodness() {
<       return this.goodness;
<    }
< }
---
> /*    */ package math;
> /*    */ 
> /*    */ import ij.measure.CurveFitter;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class PowerLawCurveFitModified
> /*    */ {
> /*    */   private double alpha;
> /*    */   private double dc;
> /*    */   private double goodness;
> /*    */   
> /*    */   public void doFit(double[] xdata, double[] ydata) {
> /* 19 */     doFit(xdata, ydata, false, 0.0D, 0.0D);
> /*    */   }
> /*    */   
> /*    */   public void doFit(double[] xdata, double[] ydata, double initalAlpha, double initalDiffCoeff) {
> /* 23 */     doFit(xdata, ydata, true, initalAlpha, initalDiffCoeff);
> /*    */   }
> /*    */   
> /*    */   private void doFit(double[] xdata, double[] ydata, boolean useInitialGuess, double initalAlpha, double initalDiffCoeff) {
> /* 27 */     CurveFitter fitter = new CurveFitter(xdata, ydata);
> /* 28 */     if (useInitialGuess) {
> /* 29 */       fitter.setInitialParameters(new double[] { initalDiffCoeff, this.alpha });
> /*    */     }
> /* 31 */     double[] init = null;
> /* 32 */     if (useInitialGuess) {
> /* 33 */       init = new double[] { initalAlpha, initalDiffCoeff };
> /*    */     }
> /* 35 */     fitter.doFit(16);
> /* 36 */     double[] params = fitter.getParams();
> /* 37 */     boolean failed = (fitter.getStatus() != 0);
> /* 38 */     if (failed) {
> /* 39 */       this.alpha = -1.0D;
> /* 40 */       this.dc = -1.0D;
> /* 41 */       this.goodness = 0.0D;
> /*    */     } else {
> /* 43 */       this.alpha = params[1];
> /* 44 */       this.dc = params[0] / 4.0D;
> /* 45 */       this.goodness = fitter.getFitGoodness();
> /*    */     } 
> /* 47 */     if (failed || this.alpha < 0.0D || this.dc < 0.0D) {
> /*    */       
> /* 49 */       fitter = new CurveFitter(xdata, ydata);
> /* 50 */       for (int i = 0; i < ydata.length; i++) {
> /* 51 */         ydata[i] = Math.log(ydata[i]);
> /*    */       }
> /*    */       
> /* 54 */       fitter.doCustomFit("y=sqrt(a*a)*log(x)+log(4*sqrt(b*b))", init, false);
> /* 55 */       params = fitter.getParams();
> /* 56 */       this.alpha = Math.abs(params[0]);
> /* 57 */       this.dc = Math.abs(params[1]);
> /* 58 */       this.goodness = fitter.getFitGoodness();
> /*    */     } 
> /*    */   }
> /*    */   
> /*    */   public double getAlpha() {
> /* 63 */     return this.alpha;
> /*    */   }
> /*    */   
> /*    */   public double getDiffusionCoefficient() {
> /* 67 */     return this.dc;
> /*    */   }
> /*    */   
> /*    */   public double getGoodness() {
> /* 71 */     return this.goodness;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/math/PowerLawCurveFitModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/math/RadiusGyrationTensor2DModified.java jd-gui/math/RadiusGyrationTensor2DModified.java
1,52c1,75
< package math;
< 
< import org.apache.commons.math3.linear.Array2DRowRealMatrix;
< import traJ.TrajectoryModified;
< import vecmath.Point3dModified;
< 
< public class RadiusGyrationTensor2DModified {
<    private TrajectoryModified t;
< 
<    public RadiusGyrationTensor2DModified(TrajectoryModified t) {
<       this.t = t;
<    }
< 
<    public Array2DRowRealMatrix getRadiusOfGyrationTensor() {
<       return getRadiusOfGyrationTensor(this.t);
<    }
< 
<    public static Array2DRowRealMatrix getRadiusOfGyrationTensor(TrajectoryModified t) {
<       double meanx = 0.0D;
<       double meany = 0.0D;
< 
<       for(int i = 0; i < t.size(); ++i) {
<          meanx += ((Point3dModified)t.get(i)).x;
<          meany += ((Point3dModified)t.get(i)).y;
<       }
< 
<       meanx /= (double)t.size();
<       meany /= (double)t.size();
<       double e11 = 0.0D;
<       double e12 = 0.0D;
<       double e21 = 0.0D;
<       double e22 = 0.0D;
< 
<       for(int i = 0; i < t.size(); ++i) {
<          e11 += Math.pow(((Point3dModified)t.get(i)).x - meanx, 2.0D);
<          e12 += (((Point3dModified)t.get(i)).x - meanx) * (((Point3dModified)t.get(i)).y - meany);
<          e22 += Math.pow(((Point3dModified)t.get(i)).y - meany, 2.0D);
<       }
< 
<       e11 /= (double)t.size();
<       e12 /= (double)t.size();
<       e22 /= (double)t.size();
<       int rows = 2;
<       int columns = 2;
<       Array2DRowRealMatrix gyr = new Array2DRowRealMatrix(rows, columns);
<       gyr.addToEntry(0, 0, e11);
<       gyr.addToEntry(0, 1, e12);
<       gyr.addToEntry(1, 0, e12);
<       gyr.addToEntry(1, 1, e22);
<       return gyr;
<    }
< }
---
> /*    */ package math;
> /*    */ 
> /*    */ import org.apache.commons.math3.linear.Array2DRowRealMatrix;
> /*    */ import traJ.TrajectoryModified;
> /*    */ import vecmath.Point3dModified;
> /*    */ 
> /*    */ 
> /*    */ public class RadiusGyrationTensor2DModified
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   
> /*    */   public RadiusGyrationTensor2DModified(TrajectoryModified t) {
> /* 13 */     this.t = t;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public Array2DRowRealMatrix getRadiusOfGyrationTensor() {
> /* 24 */     return getRadiusOfGyrationTensor(this.t);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public static Array2DRowRealMatrix getRadiusOfGyrationTensor(TrajectoryModified t) {
> /* 35 */     double meanx = 0.0D;
> /* 36 */     double meany = 0.0D;
> /* 37 */     for (int i = 0; i < t.size(); i++) {
> /* 38 */       meanx += ((Point3dModified)t.get(i)).x;
> /* 39 */       meany += ((Point3dModified)t.get(i)).y;
> /*    */     } 
> /* 41 */     meanx /= t.size();
> /* 42 */     meany /= t.size();
> /*    */     
> /* 44 */     double e11 = 0.0D;
> /* 45 */     double e12 = 0.0D;
> /* 46 */     double e21 = 0.0D;
> /* 47 */     double e22 = 0.0D;
> /*    */     
> /* 49 */     for (int j = 0; j < t.size(); j++) {
> /* 50 */       e11 += Math.pow(((Point3dModified)t.get(j)).x - meanx, 2.0D);
> /* 51 */       e12 += (((Point3dModified)t.get(j)).x - meanx) * (((Point3dModified)t.get(j)).y - meany);
> /* 52 */       e22 += Math.pow(((Point3dModified)t.get(j)).y - meany, 2.0D);
> /*    */     } 
> /* 54 */     e11 /= t.size();
> /* 55 */     e12 /= t.size();
> /* 56 */     e21 = e12;
> /* 57 */     e22 /= t.size();
> /* 58 */     int rows = 2;
> /* 59 */     int columns = 2;
> /* 60 */     Array2DRowRealMatrix gyr = new Array2DRowRealMatrix(rows, columns);
> /*    */     
> /* 62 */     gyr.addToEntry(0, 0, e11);
> /* 63 */     gyr.addToEntry(0, 1, e12);
> /* 64 */     gyr.addToEntry(1, 0, e21);
> /* 65 */     gyr.addToEntry(1, 1, e22);
> /*    */     
> /* 67 */     return gyr;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/math/RadiusGyrationTensor2DModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/math/StraightLineFitModified.java jd-gui/math/StraightLineFitModified.java
1,40c1,51
< package math;
< 
< import ij.measure.CurveFitter;
< import traJ.TrajectoryUtilModified;
< 
< public class StraightLineFitModified {
<    double a;
<    double b;
<    double goodness;
< 
<    public void doFit(double[] xdata, double[] ydata) {
<       CurveFitter fitter = new CurveFitter(xdata, ydata);
<       fitter.doFit(0);
<       this.goodness = fitter.getFitGoodness();
<       this.a = fitter.getParams()[0];
<       this.a = TrajectoryUtilModified.isZero(this.a) ? 0.0D : this.a;
<       this.b = fitter.getParams()[1];
<       this.b = TrajectoryUtilModified.isZero(this.b) ? 0.0D : this.b;
<       if (this.b < 0.0D) {
<          fitter = new CurveFitter(xdata, ydata);
<          fitter.doCustomFit("y=sqrt(a*a)+sqrt(b*b)*x", new double[]{0.0D, 0.0D}, false);
<          this.a = Math.abs(fitter.getParams()[0]);
<          this.b = Math.abs(fitter.getParams()[1]);
<          this.goodness = fitter.getFitGoodness();
<       }
< 
<    }
< 
<    public double getA() {
<       return this.a;
<    }
< 
<    public double getB() {
<       return this.b;
<    }
< 
<    public double getGoodness() {
<       return this.goodness;
<    }
< }
---
> /*    */ package math;
> /*    */ 
> /*    */ import ij.measure.CurveFitter;
> /*    */ import traJ.TrajectoryUtilModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class StraightLineFitModified
> /*    */ {
> /*    */   double a;
> /*    */   double b;
> /*    */   double goodness;
> /*    */   
> /*    */   public void doFit(double[] xdata, double[] ydata) {
> /* 17 */     CurveFitter fitter = new CurveFitter(xdata, ydata);
> /* 18 */     fitter.doFit(0);
> /* 19 */     this.goodness = fitter.getFitGoodness();
> /* 20 */     this.a = fitter.getParams()[0];
> /* 21 */     this.a = TrajectoryUtilModified.isZero(this.a) ? 0.0D : this.a;
> /* 22 */     this.b = fitter.getParams()[1];
> /* 23 */     this.b = TrajectoryUtilModified.isZero(this.b) ? 0.0D : this.b;
> /* 24 */     if (this.b < 0.0D) {
> /* 25 */       fitter = new CurveFitter(xdata, ydata);
> /*    */       
> /* 27 */       fitter.doCustomFit("y=sqrt(a*a)+sqrt(b*b)*x", new double[] { 0.0D, 0.0D }, false);
> /* 28 */       this.a = Math.abs(fitter.getParams()[0]);
> /* 29 */       this.b = Math.abs(fitter.getParams()[1]);
> /* 30 */       this.goodness = fitter.getFitGoodness();
> /*    */     } 
> /*    */   }
> /*    */   
> /*    */   public double getA() {
> /* 35 */     return this.a;
> /*    */   }
> /*    */   
> /*    */   public double getB() {
> /* 39 */     return this.b;
> /*    */   }
> /*    */   
> /*    */   public double getGoodness() {
> /* 43 */     return this.goodness;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/math/StraightLineFitModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/NormalDistributionMine.java jd-gui/NormalDistributionMine.java
1,112c1,142
< import ij.measure.ResultsTable;
< import java.awt.BasicStroke;
< import java.awt.Color;
< import java.io.File;
< import java.io.IOException;
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartUtils;
< import org.jfree.chart.JFreeChart;
< import org.jfree.chart.axis.ValueAxis;
< import org.jfree.chart.plot.PlotOrientation;
< import org.jfree.chart.plot.XYPlot;
< import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
< import org.jfree.data.function.Function2D;
< import org.jfree.data.function.NormalDistributionFunction2D;
< import org.jfree.data.general.DatasetUtils;
< import org.jfree.data.xy.XYSeries;
< import org.jfree.data.xy.XYSeriesCollection;
< import smileModified.MixtureModified;
< 
< public class NormalDistributionMine {
<    Integer nOfTrack;
<    MixtureModified.Component[] components;
<    int samples;
<    double meanValue;
< 
<    public NormalDistributionMine(Integer nOfTrack, MixtureModified.Component[] components, int samples, double meanValue) {
<       this.nOfTrack = nOfTrack;
<       this.components = components;
<       this.samples = samples;
<       this.meanValue = meanValue;
<    }
< 
<    public void runNormalDistribution() {
<       XYSeriesCollection dataset = new XYSeriesCollection();
<       ResultsTable rtMonomer = new ResultsTable();
<       String[] var10000 = new String[]{"Subpopulation", "", "", "Entropy", "N of Parameters", "Variance", "N Receptor/Particle", "Monomer Intensity", "Track Mean Intensity"};
<       double monomerValue = 0.0D;
< 
<       for(int i = 0; i < this.components.length; ++i) {
<          Function2D n1 = new NormalDistributionFunction2D(this.components[i].distribution.mean(), this.components[i].distribution.sd());
<          XYSeries s1 = DatasetUtils.sampleFunction2DToSeries(n1, this.components[i].distribution.mean() - 3.0D * this.components[i].distribution.sd(), this.components[i].distribution.mean() + 3.0D * this.components[i].distribution.sd(), this.samples, "subpop-" + i + " : " + " = " + String.format("%.3f", this.components[i].distribution.mean()) + "," + " = " + String.format("%.3f", this.components[i].distribution.sd()));
<          dataset.addSeries(s1);
<          rtMonomer.setValue("Subpopulation", i, String.valueOf(i + 1));
<          rtMonomer.setValue("", i, String.format("%.3f", this.components[i].distribution.mean()));
<          rtMonomer.setValue("", i, String.format("%.3f", this.components[i].distribution.sd()));
<          rtMonomer.setValue("Entropy", i, String.format("%.3f", this.components[i].distribution.entropy()));
<          rtMonomer.setValue("N of Parameters", i, (double)this.components[i].distribution.length());
<          rtMonomer.setValue("Variance", i, String.format("%.3f", this.components[i].distribution.variance()));
<          if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE && this.components.length == 2) {
<             monomerValue = Math.abs(this.components[0].distribution.mean() - this.components[1].distribution.mean());
<          }
<       }
< 
<       if (SPTBatch_.checkMonomer.isSelected() == Boolean.TRUE) {
<          rtMonomer.setValue("N Receptor/Particle", 0, String.valueOf(this.meanValue / Double.valueOf(SPTBatch_.monomerField.getText())));
<       }
< 
<       if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE) {
<          if (monomerValue == 0.0D) {
<             rtMonomer.setValue("N Receptor/Particle", 0, "1");
<             monomerValue = this.components[0].distribution.mean();
<          } else {
<             rtMonomer.setValue("N Receptor/Particle", 0, String.valueOf(this.meanValue / monomerValue));
<          }
<       }
< 
<       if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE) {
<          rtMonomer.setValue("Monomer Intensity", 0, monomerValue);
<       }
< 
<       if (SPTBatch_.checkMonomer.isSelected() == Boolean.TRUE) {
<          rtMonomer.setValue("Monomer Intensity", 0, SPTBatch_.monomerField.getText());
<       }
< 
<       rtMonomer.setValue("Track Mean Intensity", 0, String.valueOf(this.meanValue));
<       JFreeChart chart = ChartFactory.createXYLineChart("Distribution of Single Integrated Intensities for Track-" + this.nOfTrack.toString(), "Integrated Intensity", "Probability Density [nmolecule-1]", dataset, PlotOrientation.VERTICAL, true, true, false);
<       XYPlot plot = (XYPlot)chart.getPlot();
<       plot.setDomainZeroBaselineVisible(true);
<       plot.setRangeZeroBaselineVisible(true);
<       plot.setDomainPannable(true);
<       plot.setRangePannable(true);
<       plot.setBackgroundPaint(Color.white);
<       plot.setDomainGridlinesVisible(true);
<       plot.setRangeGridlinesVisible(true);
<       plot.setDomainMinorGridlinePaint(Color.GRAY);
<       plot.setDomainGridlinePaint(Color.DARK_GRAY);
<       plot.setRangeMinorGridlinePaint(Color.GRAY);
<       plot.setRangeGridlinePaint(Color.DARK_GRAY);
<       ValueAxis xAxis = plot.getDomainAxis();
<       xAxis.setLowerMargin(0.0D);
<       xAxis.setUpperMargin(0.0D);
<       XYLineAndShapeRenderer r = (XYLineAndShapeRenderer)plot.getRenderer();
<       r.setDrawSeriesLineAsPath(true);
< 
<       for(int i = 0; i < dataset.getSeriesCount(); ++i) {
<          r.setSeriesStroke(i, new BasicStroke(2.0F, 1, 1, 1.0F));
<       }
< 
<       try {
<          rtMonomer.saveAs(SPTBatch_.directCluster.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_Cluster_Analysis_" + this.nOfTrack.toString() + ".csv");
<       } catch (IOException var12) {
<          var12.printStackTrace();
<       }
< 
<       try {
<          ChartUtils.saveChartAsPNG(new File(SPTBatch_.directCluster.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_DistributionDensityFunction_" + this.nOfTrack.toString() + ".png"), chart, 500, 400);
<       } catch (IOException var11) {
<          var11.printStackTrace();
<       }
< 
<    }
< }
---
> /*     */ import ij.measure.ResultsTable;
> /*     */ import java.awt.BasicStroke;
> /*     */ import java.awt.Color;
> /*     */ import java.io.File;
> /*     */ import java.io.IOException;
> /*     */ import org.jfree.chart.ChartFactory;
> /*     */ import org.jfree.chart.ChartUtils;
> /*     */ import org.jfree.chart.JFreeChart;
> /*     */ import org.jfree.chart.axis.ValueAxis;
> /*     */ import org.jfree.chart.plot.PlotOrientation;
> /*     */ import org.jfree.chart.plot.XYPlot;
> /*     */ import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
> /*     */ import org.jfree.data.function.Function2D;
> /*     */ import org.jfree.data.function.NormalDistributionFunction2D;
> /*     */ import org.jfree.data.general.DatasetUtils;
> /*     */ import org.jfree.data.xy.XYDataset;
> /*     */ import org.jfree.data.xy.XYSeries;
> /*     */ import org.jfree.data.xy.XYSeriesCollection;
> /*     */ import smileModified.MixtureModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class NormalDistributionMine
> /*     */ {
> /*     */   Integer nOfTrack;
> /*     */   MixtureModified.Component[] components;
> /*     */   int samples;
> /*     */   double meanValue;
> /*     */   
> /*     */   public NormalDistributionMine(Integer nOfTrack, MixtureModified.Component[] components, int samples, double meanValue) {
> /*  43 */     this.nOfTrack = nOfTrack;
> /*  44 */     this.components = components;
> /*  45 */     this.samples = samples;
> /*  46 */     this.meanValue = meanValue;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void runNormalDistribution() {
> /*  51 */     XYSeriesCollection dataset = new XYSeriesCollection();
> /*  52 */     ResultsTable rtMonomer = new ResultsTable();
> /*  53 */     String[] columnNames = { "Subpopulation", "", "", "Entropy", "N of Parameters", 
> /*  54 */         "Variance", "N Receptor/Particle", "Monomer Intensity", "Track Mean Intensity" };
> /*  55 */     double monomerValue = 0.0D;
> /*  56 */     for (int i = 0; i < this.components.length; i++) {
> /*  57 */       NormalDistributionFunction2D normalDistributionFunction2D = new NormalDistributionFunction2D((this.components[i]).distribution.mean(), 
> /*  58 */           (this.components[i]).distribution.sd());
> /*  59 */       XYSeries s1 = DatasetUtils.sampleFunction2DToSeries((Function2D)normalDistributionFunction2D, 
> /*  60 */           (this.components[i]).distribution.mean() - 3.0D * (this.components[i]).distribution.sd(), 
> /*  61 */           (this.components[i]).distribution.mean() + 3.0D * (this.components[i]).distribution.sd(), this.samples, 
> /*  62 */           "subpop-" + i + " : " + " = " + String.format("%.3f", new Object[] { Double.valueOf((this.components[i]).distribution.mean()) }) + "," + 
> /*  63 */           " = " + String.format("%.3f", new Object[] { Double.valueOf((this.components[i]).distribution.sd()) }));
> /*  64 */       dataset.addSeries(s1);
> /*  65 */       rtMonomer.setValue("Subpopulation", i, String.valueOf(i + 1));
> /*  66 */       rtMonomer.setValue("", i, String.format("%.3f", new Object[] { Double.valueOf((this.components[i]).distribution.mean()) }));
> /*  67 */       rtMonomer.setValue("", i, String.format("%.3f", new Object[] { Double.valueOf((this.components[i]).distribution.sd()) }));
> /*  68 */       rtMonomer.setValue("Entropy", i, String.format("%.3f", new Object[] { Double.valueOf((this.components[i]).distribution.entropy()) }));
> /*  69 */       rtMonomer.setValue("N of Parameters", i, (this.components[i]).distribution.length());
> /*  70 */       rtMonomer.setValue("Variance", i, String.format("%.3f", new Object[] { Double.valueOf((this.components[i]).distribution.variance()) }));
> /*     */       
> /*  72 */       if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE.booleanValue() && 
> /*  73 */         this.components.length == 2) {
> /*  74 */         monomerValue = Math.abs((this.components[0]).distribution.mean() - (this.components[1]).distribution.mean());
> /*     */       }
> /*     */     } 
> /*     */     
> /*  78 */     if (SPTBatch_.checkMonomer.isSelected() == Boolean.TRUE.booleanValue())
> /*  79 */       rtMonomer.setValue("N Receptor/Particle", 0, 
> /*  80 */           String.valueOf(this.meanValue / Double.valueOf(SPTBatch_.monomerField.getText()).doubleValue())); 
> /*  81 */     if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE.booleanValue()) {
> /*  82 */       if (monomerValue == 0.0D) {
> /*  83 */         rtMonomer.setValue("N Receptor/Particle", 0, "1");
> /*  84 */         monomerValue = (this.components[0]).distribution.mean();
> /*     */       } else {
> /*  86 */         rtMonomer.setValue("N Receptor/Particle", 0, String.valueOf(this.meanValue / monomerValue));
> /*     */       } 
> /*     */     }
> /*  89 */     if (SPTBatch_.checkMonomer.isSelected() == Boolean.FALSE.booleanValue())
> /*  90 */       rtMonomer.setValue("Monomer Intensity", 0, monomerValue); 
> /*  91 */     if (SPTBatch_.checkMonomer.isSelected() == Boolean.TRUE.booleanValue())
> /*  92 */       rtMonomer.setValue("Monomer Intensity", 0, SPTBatch_.monomerField.getText()); 
> /*  93 */     rtMonomer.setValue("Track Mean Intensity", 0, String.valueOf(this.meanValue));
> /*  94 */     JFreeChart chart = ChartFactory.createXYLineChart(
> /*  95 */         "Distribution of Single Integrated Intensities for Track-" + this.nOfTrack.toString(), 
> /*  96 */         "Integrated Intensity", "Probability Density [nmolecule-1]", (XYDataset)dataset, PlotOrientation.VERTICAL, true, 
> /*  97 */         true, false);
> /*  98 */     XYPlot plot = (XYPlot)chart.getPlot();
> /*  99 */     plot.setDomainZeroBaselineVisible(true);
> /* 100 */     plot.setRangeZeroBaselineVisible(true);
> /* 101 */     plot.setDomainPannable(true);
> /* 102 */     plot.setRangePannable(true);
> /* 103 */     plot.setBackgroundPaint(Color.white);
> /* 104 */     plot.setDomainGridlinesVisible(true);
> /* 105 */     plot.setRangeGridlinesVisible(true);
> /* 106 */     plot.setDomainMinorGridlinePaint(Color.GRAY);
> /* 107 */     plot.setDomainGridlinePaint(Color.DARK_GRAY);
> /* 108 */     plot.setRangeMinorGridlinePaint(Color.GRAY);
> /* 109 */     plot.setRangeGridlinePaint(Color.DARK_GRAY);
> /* 110 */     ValueAxis xAxis = plot.getDomainAxis();
> /* 111 */     xAxis.setLowerMargin(0.0D);
> /* 112 */     xAxis.setUpperMargin(0.0D);
> /* 113 */     XYLineAndShapeRenderer r = (XYLineAndShapeRenderer)plot.getRenderer();
> /* 114 */     r.setDrawSeriesLineAsPath(true);
> /* 115 */     for (int j = 0; j < dataset.getSeriesCount(); j++) {
> /* 116 */       r.setSeriesStroke(j, new BasicStroke(2.0F, 1, 1, 1.0F));
> /*     */     }
> /*     */     
> /*     */     try {
> /* 120 */       rtMonomer.saveAs(String.valueOf(SPTBatch_.directCluster.getAbsolutePath()) + File.separator + SPTBatch_.imps.getShortTitle() + 
> /* 121 */           "_Cluster_Analysis_" + this.nOfTrack.toString() + ".csv");
> /* 122 */     } catch (IOException e) {
> /*     */       
> /* 124 */       e.printStackTrace();
> /*     */     } 
> /*     */     
> /*     */     try {
> /* 128 */       ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directCluster.getAbsolutePath()) + File.separator + 
> /* 129 */             SPTBatch_.imps.getShortTitle() + "_DistributionDensityFunction_" + this.nOfTrack.toString() + ".png"), 
> /* 130 */           chart, 500, 400);
> /* 131 */     } catch (IOException e) {
> /*     */       
> /* 133 */       e.printStackTrace();
> /*     */     } 
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/NormalDistributionMine.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: OptionWizardPanel$10$1.java
Only in jd-gui: OptionWizardPanel$10.java
Only in jd-gui: OptionWizardPanel$11$1.java
Only in jd-gui: OptionWizardPanel$11.java
Only in jd-gui: OptionWizardPanel$12$1.java
Only in jd-gui: OptionWizardPanel$12.java
Only in jd-gui: OptionWizardPanel$13$1.java
Only in jd-gui: OptionWizardPanel$13.java
Only in jd-gui: OptionWizardPanel$14$1.java
Only in jd-gui: OptionWizardPanel$14.java
Only in jd-gui: OptionWizardPanel$1.java
Only in jd-gui: OptionWizardPanel$2.java
Only in jd-gui: OptionWizardPanel$3.java
Only in jd-gui: OptionWizardPanel$4.java
Only in jd-gui: OptionWizardPanel$5$1.java
Only in jd-gui: OptionWizardPanel$5.java
Only in jd-gui: OptionWizardPanel$6$1.java
Only in jd-gui: OptionWizardPanel$6.java
Only in jd-gui: OptionWizardPanel$7$1.java
Only in jd-gui: OptionWizardPanel$7.java
Only in jd-gui: OptionWizardPanel$8$1.java
Only in jd-gui: OptionWizardPanel$8.java
Only in jd-gui: OptionWizardPanel$9$1.java
Only in jd-gui: OptionWizardPanel$9.java
diff -r TrackAnalyzer_/OptionWizardPanel.java jd-gui/OptionWizardPanel.java
1,909c1,986
< import ij.IJ;
< import ij.measure.ResultsTable;
< import java.awt.BasicStroke;
< import java.awt.Color;
< import java.awt.Dimension;
< import java.awt.FlowLayout;
< import java.awt.Font;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.image.BufferedImage;
< import java.io.File;
< import java.io.IOException;
< import java.util.ArrayList;
< import java.util.Arrays;
< import java.util.Collections;
< import java.util.List;
< import javax.imageio.ImageIO;
< import javax.swing.BorderFactory;
< import javax.swing.Box;
< import javax.swing.BoxLayout;
< import javax.swing.Icon;
< import javax.swing.ImageIcon;
< import javax.swing.JButton;
< import javax.swing.JComboBox;
< import javax.swing.JFileChooser;
< import javax.swing.JFrame;
< import javax.swing.JLabel;
< import javax.swing.JPanel;
< import javax.swing.JScrollPane;
< import javax.swing.JSeparator;
< import javax.swing.JSpinner;
< import javax.swing.JTabbedPane;
< import javax.swing.JTable;
< import javax.swing.SpinnerNumberModel;
< import javax.swing.table.DefaultTableModel;
< import jwizardcomponent.JWizardComponents;
< import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.plot.IntervalMarker;
< 
< public class OptionWizardPanel extends LabelWizardPanel {
<    public double maxDomainSpot;
<    public double maxRangeSpot;
<    public double maxDomainTrack;
<    public double maxRangeTrack;
<    public IntervalMarker markerRangeSpot;
<    public IntervalMarker markerDomainSpot;
<    public IntervalMarker markerRangeTrack;
<    public IntervalMarker markerDomainTrack;
<    private JSpinner filterOrderSpot;
<    private JSpinner filterOrderTrack;
<    static int selectedIndexCh2;
<    static int selectedIndexCh3;
<    static int numCh2Positive;
<    static int numCh3Positive;
<    static int countSenescentNumber;
<    static int lhCountAll;
<    static int hhCountAll;
<    static int llCountAll;
<    static int hlCountAll;
<    static int lhCountNID;
<    static int hhCountNID;
<    static int llCountNID;
<    static int hlCountNID;
<    static int lhCountClass;
<    static int hhCountClass;
<    static int llCountClass;
<    static int hlCountClass;
<    static int selectedIndexDomainSpot;
<    static int selectedIndexRangeSpot;
<    static int selectedIndexDomainTrack;
<    static int selectedIndexRangeTrack;
<    static JLabel scatLabel;
<    static JLabel sumLabel;
<    static JLabel labelScoresSpot;
<    static JLabel labelScoresTrack;
<    JComboBox<String> comboFeatureDomainSpot;
<    JComboBox<String> comboFeatureRangeSpot;
<    JComboBox<String> comboFeatureDomainTrack;
<    JComboBox<String> comboFeatureRangeTrack;
<    JComboBox<String> comboClassSpot;
<    JComboBox<String> comboParamSpot;
<    JComboBox<String> comboClassTrack;
<    JComboBox<String> comboParamTrack;
<    JComboBox<String> comboRegressionSpot;
<    JComboBox<String> comboRegressionTrack;
<    List<String> itemFiltersSpot;
<    List<String> itemFiltersTrack;
<    STScatterPlot scatterPlot;
<    JButton refreshButtonSpot;
<    JButton zoomInSpot;
<    JButton zoomOutSpot;
<    JButton refreshButtonTrack;
<    JButton zoomInTrack;
<    JButton zoomOutTrack;
<    STScatterPlot sp2Spot;
<    STScatterPlot sp2Track;
<    ChartPanel scatterPlotSpot;
<    ChartPanel scatterPlotTrack;
<    static JPanel regressionPanelSpot;
<    static JPanel regressionPanelTrack;
<    List<Double> dataToStatisticsSpot;
<    List<Double> dataToStatisticsTrack;
<    DefaultTableModel modelSpot;
<    DefaultTableModel modelTrack;
<    Thread refreshSpotThread;
<    Thread refreshTrackThread;
<    Thread zoomInSpotThread;
<    Thread zoomInTrackThread;
<    Thread zoomOutSpotThread;
<    Thread zoomOutTrackThread;
<    Thread comboRegSpotThread;
<    Thread comboRegTrackThread;
<    Thread comboClassSpotThread;
<    Thread comboClassTrackThread;
< 
<    public OptionWizardPanel(JWizardComponents wizardComponents, String option) {
<       super(wizardComponents, "");
<       this.setPanelTitle("");
<       this.setLayout(new BoxLayout(this, 1));
<       JPanel chartPanel2Spot = new JPanel();
<       this.markerRangeSpot = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.6F);
<       this.markerDomainSpot = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.5F);
<       this.markerRangeTrack = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.6F);
<       this.markerDomainTrack = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), new BasicStroke(1.5F), 0.5F);
<       this.sp2Spot = new STScatterPlot("");
<       this.scatterPlotSpot = this.sp2Spot.createScatterChartPanelInitial("", "", new ArrayList(Arrays.asList(0.0D, 0.0D, 0.0D)), new ArrayList(Arrays.asList(0.0D, 0.0D, 0.0D)), this.markerRangeSpot, this.markerDomainSpot, new Double[][]{{0.0D}, {0.0D}}, new Double[][]{{0.0D}, {0.0D}});
<       this.refreshButtonSpot = new JButton("");
<       this.refreshButtonSpot.setIcon(FirstWizardPanel.refreshCell);
<       this.refreshButtonSpot.setToolTipText("Click this button to refresh scatter-plot.");
<       this.zoomInSpot = new JButton("");
<       ImageIcon iconZoomIn = FirstWizardPanel.createImageIcon("images/zoomin.png");
<       Icon zoomInCell = new ImageIcon(iconZoomIn.getImage().getScaledInstance(18, 20, 4));
<       this.zoomInSpot.setIcon(zoomInCell);
<       this.zoomInSpot.setToolTipText("Click this button to zoom in Chart");
<       this.zoomOutSpot = new JButton("");
<       ImageIcon iconZoomOut = FirstWizardPanel.createImageIcon("images/zoomout.png");
<       Icon zoomOutCell = new ImageIcon(iconZoomOut.getImage().getScaledInstance(18, 20, 4));
<       this.zoomOutSpot.setIcon(zoomOutCell);
<       this.zoomOutSpot.setToolTipText("Click this button to zoom out Chart");
<       this.itemFiltersSpot = new ArrayList();
<       this.itemFiltersTrack = new ArrayList();
< 
<       int i;
<       for(i = 2; i < FirstWizardPanel.columnNamesSpot.length; ++i) {
<          this.itemFiltersSpot.add(FirstWizardPanel.columnNamesSpot[i].toString());
<       }
< 
<       for(i = 0; i < ChooserWizardPanel.columnNamesTrack.length; ++i) {
<          this.itemFiltersTrack.add(ChooserWizardPanel.columnNamesTrack[i].toString());
<       }
< 
<       this.comboFeatureDomainSpot = new JComboBox();
<       this.comboFeatureDomainSpot.setPreferredSize(new Dimension(110, 20));
< 
<       for(i = 0; i < this.itemFiltersSpot.size(); ++i) {
<          this.comboFeatureDomainSpot.addItem((String)this.itemFiltersSpot.get(i));
<       }
< 
<       this.comboFeatureDomainSpot.setOpaque(true);
<       this.scatterPlot = new STScatterPlot("holaa");
<       chartPanel2Spot.add(this.scatterPlotSpot);
<       this.filterOrderSpot = new JSpinner(new SpinnerNumberModel(1, 0, 1000, 1));
<       this.filterOrderSpot.setPreferredSize(new Dimension(60, 20));
<       this.filterOrderSpot.setEnabled(false);
<       JPanel filtersMaxSpot = new JPanel(new FlowLayout(1));
<       filtersMaxSpot.add(Box.createHorizontalStrut(2));
<       this.comboFeatureRangeSpot = new JComboBox();
<       this.comboFeatureRangeSpot.setPreferredSize(new Dimension(110, 20));
< 
<       for(int i = 0; i < this.itemFiltersSpot.size(); ++i) {
<          this.comboFeatureRangeSpot.addItem((String)this.itemFiltersSpot.get(i));
<       }
< 
<       this.comboFeatureRangeSpot.setOpaque(true);
<       filtersMaxSpot.add(new JLabel("X :  "));
<       filtersMaxSpot.add(this.comboFeatureDomainSpot);
<       filtersMaxSpot.add(new JLabel("   Y :  "));
<       filtersMaxSpot.add(this.comboFeatureRangeSpot);
<       JPanel rangePanelFSpot = new JPanel(new FlowLayout(0));
<       JPanel chartDomainPanelBoxSpot = new JPanel();
<       chartDomainPanelBoxSpot.setLayout(new BoxLayout(chartDomainPanelBoxSpot, 1));
<       chartDomainPanelBoxSpot.add(Box.createVerticalStrut(10));
<       chartDomainPanelBoxSpot.add(chartPanel2Spot);
<       chartDomainPanelBoxSpot.add(filtersMaxSpot);
<       rangePanelFSpot.add(chartDomainPanelBoxSpot);
<       JPanel buttonBox = new JPanel();
<       buttonBox.setLayout(new BoxLayout(buttonBox, 1));
<       JPanel refreshButtonPanelSpot = new JPanel(new FlowLayout(0));
<       refreshButtonPanelSpot.add(this.refreshButtonSpot);
<       JPanel zoomOutButtonPanelSpot = new JPanel(new FlowLayout(0));
<       zoomOutButtonPanelSpot.add(this.zoomOutSpot);
<       JPanel zoomInButtonPanelSpot = new JPanel(new FlowLayout(0));
<       zoomInButtonPanelSpot.add(this.zoomInSpot);
<       buttonBox.add(zoomInButtonPanelSpot);
<       buttonBox.add(zoomOutButtonPanelSpot);
<       buttonBox.add(refreshButtonPanelSpot);
<       this.comboRegressionSpot = new JComboBox();
<       this.comboRegressionSpot.setPreferredSize(new Dimension(90, 20));
<       this.comboRegressionSpot.addItem("Linear");
<       this.comboRegressionSpot.addItem("Polynomial");
<       this.comboRegressionSpot.addItem("Power");
<       this.comboRegressionSpot.addItem("Logarithmic");
<       this.comboRegressionSpot.addItem("Exponential");
<       this.comboRegressionSpot.setSelectedIndex(0);
<       this.comboRegressionSpot.setOpaque(true);
<       JPanel regreOrderPanel = new JPanel(new FlowLayout(0));
<       regreOrderPanel.add(this.comboRegressionSpot);
<       JPanel filterOrderPanel = new JPanel(new FlowLayout(0));
<       filterOrderPanel.add(this.filterOrderSpot);
<       buttonBox.add(regreOrderPanel);
<       buttonBox.add(filterOrderPanel);
<       regressionPanelSpot = new JPanel();
<       regressionPanelSpot.setBorder(BorderFactory.createTitledBorder("Reg.Params"));
<       regressionPanelSpot.setPreferredSize(new Dimension(this.comboRegressionSpot.getWidth() + 10, 35));
<       rangePanelFSpot.add(buttonBox);
<       JPanel spotPanel = new JPanel();
<       spotPanel.add(rangePanelFSpot);
<       spotPanel.setBorder(BorderFactory.createTitledBorder(""));
<       JPanel spotStatistics = new JPanel();
<       spotStatistics.setLayout(new BoxLayout(spotStatistics, 1));
<       JPanel spotStatisticsFlow = new JPanel(new FlowLayout(0));
<       JPanel classParamSpot = new JPanel(new FlowLayout(0));
<       this.comboClassSpot = new JComboBox();
<       this.comboClassSpot.setPreferredSize(new Dimension(120, 20));
< 
<       int i;
<       for(i = 2; i < FirstWizardPanel.columnNamesSpot.length; ++i) {
<          this.comboClassSpot.addItem((String)FirstWizardPanel.columnNamesSpot[i]);
<       }
< 
<       this.comboClassSpot.setOpaque(true);
<       this.comboClassSpot.setToolTipText("Choose selected items for descriptive statistics.");
<       this.comboParamSpot = new JComboBox();
<       this.comboParamSpot.setPreferredSize(new Dimension(120, 20));
< 
<       for(i = 2; i < FirstWizardPanel.columnNamesSpot.length; ++i) {
<          this.comboParamSpot.addItem((String)FirstWizardPanel.columnNamesSpot[i]);
<       }
< 
<       this.comboParamSpot.setOpaque(true);
<       this.comboParamSpot.setToolTipText("Choose a spot parameter for descriptive statistics.");
<       classParamSpot.add(this.comboClassSpot);
<       classParamSpot.add(this.comboParamSpot);
<       labelScoresSpot = new JLabel("SCORES");
<       labelScoresSpot.setFont(new Font("Verdana", 1, 20));
<       spotStatisticsFlow.add(labelScoresSpot);
<       spotStatistics.add(Box.createVerticalStrut(60));
<       spotStatistics.add(spotStatisticsFlow);
<       spotStatistics.add(new JSeparator(0));
<       spotStatistics.add(Box.createVerticalStrut(20));
<       spotStatistics.add(classParamSpot);
<       spotStatistics.add(Box.createVerticalStrut(20));
<       spotStatistics.add(new JSeparator(0));
<       String[][] data = new String[][]{{"", "", "", "", "", "", "", "", "", "", ""}};
<       String[] column = new String[]{"Mean ", "Std.Error ", "Median ", "Std.Dev ", "Variance ", "Kurtosis ", "Skewness ", "Min ", "Max ", "Sum ", "Count "};
<       JTable table = new JTable();
<       this.modelSpot = new DefaultTableModel(data, column) {
<          public Class<?> getColumnClass(int column) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, column);
<                if (value != null) {
<                   return this.getValueAt(0, column).getClass();
<                }
<             }
< 
<             return super.getColumnClass(column);
<          }
< 
<          public boolean isCellEditable(int row, int col) {
<             return false;
<          }
<       };
<       table.setAutoResizeMode(0);
<       table.setModel(this.modelSpot);
<       table.setRowHeight(60);
<       JScrollPane sp = new JScrollPane(table);
<       sp.setPreferredSize(new Dimension(500, 100));
<       sp.setVerticalScrollBarPolicy(22);
<       sp.setHorizontalScrollBarPolicy(32);
< 
<       for(int u = 0; u < table.getColumnCount(); ++u) {
<          table.getColumnModel().getColumn(u).setMinWidth(100);
<          table.getColumnModel().getColumn(u).setMaxWidth(100);
<          table.getColumnModel().getColumn(u).setPreferredWidth(100);
<       }
< 
<       spotStatistics.add(Box.createVerticalStrut(20));
<       spotStatistics.add(sp);
<       spotStatistics.add(Box.createVerticalStrut(20));
<       spotStatistics.add(new JSeparator(0));
<       JButton plotButton = new JButton();
<       ImageIcon iconPlot = FirstWizardPanel.createImageIcon("images/plot.jpg");
<       Icon plotCell = new ImageIcon(iconPlot.getImage().getScaledInstance(18, 20, 4));
<       plotButton.setIcon(plotCell);
<       plotButton.setToolTipText("Click to export scatter plot.");
<       JPanel panelPlot = new JPanel(new FlowLayout(0));
<       panelPlot.add(plotButton);
<       JButton csvButton = new JButton();
<       ImageIcon iconCsv = FirstWizardPanel.createImageIcon("images/csv.png");
<       Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
<       csvButton.setIcon(csvCell);
<       csvButton.setToolTipText("Click to export your spots statistics table.");
<       JPanel panelCsv = new JPanel(new FlowLayout(0));
<       panelCsv.add(csvButton);
<       JPanel panelPngCsv = new JPanel(new FlowLayout(0));
<       panelPngCsv.add(panelPlot);
<       panelPngCsv.add(panelCsv);
<       spotStatistics.add(panelPngCsv);
<       spotPanel.add(spotStatistics);
<       JPanel chartPanel2Track = new JPanel();
<       this.sp2Track = new STScatterPlot("");
<       this.scatterPlotTrack = this.sp2Track.createScatterChartPanelInitial("", "", new ArrayList(Arrays.asList(0.0D, 0.0D, 0.0D)), new ArrayList(Arrays.asList(0.0D, 0.0D, 0.0D)), this.markerRangeTrack, this.markerDomainTrack, new Double[][]{{0.0D}, {0.0D}}, new Double[][]{{0.0D}, {0.0D}});
<       this.refreshButtonTrack = new JButton("");
<       this.refreshButtonTrack.setIcon(FirstWizardPanel.refreshCell);
<       this.refreshButtonTrack.setToolTipText("Click this button to refresh scatter-plot.");
<       this.zoomInTrack = new JButton("");
<       this.zoomInTrack.setIcon(zoomInCell);
<       this.zoomInTrack.setToolTipText("Click this button to zoom in Chart");
<       this.zoomOutTrack = new JButton("");
<       this.zoomOutTrack.setIcon(zoomOutCell);
<       this.zoomOutTrack.setToolTipText("Click this button to zoom out Chart");
< 
<       int i;
<       for(i = 0; i < ChooserWizardPanel.columnNamesTrack.length; ++i) {
<          this.itemFiltersTrack.add(ChooserWizardPanel.columnNamesTrack[i].toString());
<       }
< 
<       this.comboFeatureDomainTrack = new JComboBox();
<       this.comboFeatureDomainTrack.setPreferredSize(new Dimension(110, 20));
< 
<       for(i = 3; i < this.itemFiltersTrack.size(); ++i) {
<          this.comboFeatureDomainTrack.addItem((String)this.itemFiltersTrack.get(i));
<       }
< 
<       this.comboFeatureDomainTrack.setOpaque(true);
<       chartPanel2Track.add(this.scatterPlotTrack);
<       this.filterOrderTrack = new JSpinner(new SpinnerNumberModel(1, 0, 1000, 1));
<       this.filterOrderTrack.setPreferredSize(new Dimension(60, 20));
<       this.filterOrderTrack.setEnabled(false);
<       JPanel filtersMaxTrack = new JPanel(new FlowLayout(1));
<       filtersMaxTrack.add(Box.createHorizontalStrut(2));
<       this.comboFeatureRangeTrack = new JComboBox();
<       this.comboFeatureRangeTrack.setPreferredSize(new Dimension(110, 20));
< 
<       for(int i = 3; i < this.itemFiltersTrack.size(); ++i) {
<          this.comboFeatureRangeTrack.addItem((String)this.itemFiltersTrack.get(i));
<       }
< 
<       this.comboFeatureRangeTrack.setOpaque(true);
<       filtersMaxTrack.add(new JLabel("X :  "));
<       filtersMaxTrack.add(this.comboFeatureDomainTrack);
<       filtersMaxTrack.add(new JLabel("   Y :  "));
<       filtersMaxTrack.add(this.comboFeatureRangeTrack);
<       JPanel rangePanelFTrack = new JPanel(new FlowLayout(0));
<       JPanel chartDomainPanelBoxTrack = new JPanel();
<       chartDomainPanelBoxTrack.setLayout(new BoxLayout(chartDomainPanelBoxTrack, 1));
<       chartDomainPanelBoxTrack.add(Box.createVerticalStrut(10));
<       chartDomainPanelBoxTrack.add(chartPanel2Track);
<       chartDomainPanelBoxTrack.add(filtersMaxTrack);
<       rangePanelFTrack.add(chartDomainPanelBoxTrack);
<       JPanel buttonBoxTrack = new JPanel();
<       buttonBoxTrack.setLayout(new BoxLayout(buttonBoxTrack, 1));
<       JPanel refreshButtonPanelTrack = new JPanel(new FlowLayout(0));
<       refreshButtonPanelTrack.add(this.refreshButtonTrack);
<       JPanel zoomOutButtonPanelTrack = new JPanel(new FlowLayout(0));
<       zoomOutButtonPanelTrack.add(this.zoomOutTrack);
<       JPanel zoomInButtonPanelTrack = new JPanel(new FlowLayout(0));
<       zoomInButtonPanelTrack.add(this.zoomInTrack);
<       buttonBoxTrack.add(zoomInButtonPanelTrack);
<       buttonBoxTrack.add(zoomOutButtonPanelTrack);
<       buttonBoxTrack.add(refreshButtonPanelTrack);
<       this.comboRegressionTrack = new JComboBox();
<       this.comboRegressionTrack.setPreferredSize(new Dimension(90, 20));
<       this.comboRegressionTrack.addItem("Linear");
<       this.comboRegressionTrack.addItem("Polynomial");
<       this.comboRegressionTrack.addItem("Power");
<       this.comboRegressionTrack.addItem("Logarithmic");
<       this.comboRegressionTrack.addItem("Exponential");
<       this.comboRegressionTrack.setSelectedIndex(0);
<       this.comboRegressionTrack.setOpaque(true);
<       JPanel regreOrderPanelTrack = new JPanel(new FlowLayout(0));
<       regreOrderPanelTrack.add(this.comboRegressionTrack);
<       JPanel filterOrderPanelTrack = new JPanel(new FlowLayout(0));
<       filterOrderPanelTrack.add(this.filterOrderTrack);
<       buttonBoxTrack.add(regreOrderPanelTrack);
<       buttonBoxTrack.add(filterOrderPanelTrack);
<       regressionPanelTrack = new JPanel();
<       regressionPanelTrack.setBorder(BorderFactory.createTitledBorder("Reg.Params"));
<       regressionPanelTrack.setPreferredSize(new Dimension(this.comboRegressionTrack.getWidth() + 10, 35));
<       rangePanelFTrack.add(buttonBoxTrack);
<       JPanel trackPanel = new JPanel();
<       trackPanel.add(rangePanelFTrack);
<       trackPanel.setBorder(BorderFactory.createTitledBorder(""));
<       JPanel trackStatistics = new JPanel();
<       trackStatistics.setLayout(new BoxLayout(trackStatistics, 1));
<       JPanel trackStatisticsFlow = new JPanel(new FlowLayout(0));
<       JPanel classParamTrack = new JPanel(new FlowLayout(0));
<       this.comboClassTrack = new JComboBox();
<       this.comboClassTrack.setPreferredSize(new Dimension(120, 20));
< 
<       int i;
<       for(i = 3; i < ChooserWizardPanel.columnNamesTrack.length; ++i) {
<          this.comboClassTrack.addItem((String)ChooserWizardPanel.columnNamesTrack[i]);
<       }
< 
<       this.comboClassTrack.setOpaque(true);
<       this.comboClassTrack.setToolTipText("Choose selected items for descriptive statistics.");
<       this.comboParamTrack = new JComboBox();
<       this.comboParamTrack.setPreferredSize(new Dimension(120, 20));
< 
<       for(i = 3; i < ChooserWizardPanel.columnNamesTrack.length; ++i) {
<          this.comboParamTrack.addItem((String)ChooserWizardPanel.columnNamesTrack[i]);
<       }
< 
<       this.comboParamTrack.setOpaque(true);
<       this.comboParamTrack.setToolTipText("Choose a track parameter for descriptive statistics.");
<       classParamTrack.add(this.comboClassTrack);
<       classParamTrack.add(this.comboParamTrack);
<       labelScoresTrack = new JLabel("SCORES");
<       labelScoresTrack.setFont(new Font("Verdana", 1, 20));
<       trackStatisticsFlow.add(labelScoresTrack);
<       trackStatistics.add(Box.createVerticalStrut(60));
<       trackStatistics.add(trackStatisticsFlow);
<       trackStatistics.add(new JSeparator(0));
<       trackStatistics.add(Box.createVerticalStrut(20));
<       trackStatistics.add(classParamTrack);
<       trackStatistics.add(Box.createVerticalStrut(20));
<       trackStatistics.add(new JSeparator(0));
<       String[][] dataTrack = new String[][]{{"", "", "", "", "", "", "", "", "", "", ""}};
<       String[] columnTrack = new String[]{"Mean ", "Std.Error ", "Median ", "Std.Dev ", "Variance ", "Kurtosis ", "Skewness ", "Min ", "Max ", "Sum ", "Count "};
<       JTable tableTrack = new JTable();
<       this.modelTrack = new DefaultTableModel(dataTrack, columnTrack) {
<          public Class<?> getColumnClass(int columnTrack) {
<             if (this.getRowCount() > 0) {
<                Object value = this.getValueAt(0, columnTrack);
<                if (value != null) {
<                   return this.getValueAt(0, columnTrack).getClass();
<                }
<             }
< 
<             return super.getColumnClass(columnTrack);
<          }
< 
<          public boolean isCellEditable(int row, int col) {
<             return false;
<          }
<       };
<       tableTrack.setAutoResizeMode(0);
<       tableTrack.setModel(this.modelTrack);
<       tableTrack.setRowHeight(60);
<       JScrollPane spTrack = new JScrollPane(tableTrack);
<       spTrack.setPreferredSize(new Dimension(500, 100));
<       spTrack.setVerticalScrollBarPolicy(22);
<       spTrack.setHorizontalScrollBarPolicy(32);
< 
<       for(int u = 0; u < tableTrack.getColumnCount(); ++u) {
<          tableTrack.getColumnModel().getColumn(u).setMinWidth(100);
<          tableTrack.getColumnModel().getColumn(u).setMaxWidth(100);
<          tableTrack.getColumnModel().getColumn(u).setPreferredWidth(100);
<       }
< 
<       trackStatistics.add(Box.createVerticalStrut(20));
<       trackStatistics.add(spTrack);
<       trackStatistics.add(Box.createVerticalStrut(20));
<       trackStatistics.add(new JSeparator(0));
<       JButton plotButtonTrack = new JButton();
<       plotButtonTrack.setIcon(plotCell);
<       plotButtonTrack.setToolTipText("Click to export scatter plot.");
<       JPanel panelPlotTrack = new JPanel(new FlowLayout(0));
<       panelPlotTrack.add(plotButtonTrack);
<       JButton csvButtonTrack = new JButton();
<       csvButtonTrack.setIcon(csvCell);
<       csvButtonTrack.setToolTipText("Click to export your tracks statistics table.");
<       JPanel panelCsvTrack = new JPanel(new FlowLayout(0));
<       panelCsvTrack.add(csvButtonTrack);
<       JPanel panelPngCsvTrack = new JPanel(new FlowLayout(0));
<       panelPngCsvTrack.add(panelPlotTrack);
<       panelPngCsvTrack.add(panelCsvTrack);
<       trackStatistics.add(panelPngCsvTrack);
<       trackPanel.add(trackStatistics);
<       JTabbedPane maintabbedPane = new JTabbedPane(1);
<       maintabbedPane.addTab("SPOTS ", FirstWizardPanel.iconSpotCell, spotPanel, "Scatter-Plot for spots");
<       maintabbedPane.addTab("TRACKS ", ChooserWizardPanel.iconTrackCell, trackPanel, "Scatter-Plot for tracks");
<       maintabbedPane.setTabLayoutPolicy(1);
<       this.add(maintabbedPane, "Center");
<       plotButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             JFileChooser fileChooser = new JFileChooser();
<             fileChooser.setFileSelectionMode(1);
<             fileChooser.setDialogTitle("Specify a directory to save plot as .png file");
<             int userSelection = fileChooser.showSaveDialog(new JFrame());
<             if (userSelection == 0) {
<                File fileToSave = fileChooser.getSelectedFile();
<                BufferedImage chartImage = STScatterPlot.plot.getChart().createBufferedImage(1024, 768);
< 
<                try {
<                   ImageIO.write(chartImage, "png", new File(fileToSave.getAbsolutePath() + File.separator + "SpotPlot for " + IJ.getImage().getShortTitle() + ".png"));
<                } catch (IOException var7) {
<                   var7.printStackTrace();
<                }
<             }
< 
<          }
<       });
<       csvButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             List<String> columnSpotHead = new ArrayList();
< 
<             for(int j = 0; j < OptionWizardPanel.this.modelSpot.getColumnCount(); ++j) {
<                columnSpotHead.add(OptionWizardPanel.this.modelSpot.getColumnName(j));
<             }
< 
<             ResultsTable rt = new ResultsTable(OptionWizardPanel.this.modelSpot.getRowCount());
<             if (rt != null) {
<                rt.reset();
<             }
< 
<             for(int i = 0; i < OptionWizardPanel.this.modelSpot.getRowCount(); ++i) {
<                for(int jx = 0; jx < OptionWizardPanel.this.modelSpot.getColumnCount(); ++jx) {
<                   rt.setValue((String)columnSpotHead.get(jx), i, OptionWizardPanel.this.modelSpot.getValueAt(i, jx).toString());
<                }
<             }
< 
<             JFrame pngFrame = new JFrame();
<             JFileChooser fileChooser = new JFileChooser();
<             fileChooser.setFileSelectionMode(1);
<             fileChooser.setDialogTitle("Specify a directory to save csv file");
<             int userSelection = fileChooser.showSaveDialog(pngFrame);
<             if (userSelection == 0) {
<                File fileToSave = fileChooser.getSelectedFile();
< 
<                try {
<                   rt.saveAs(fileToSave.getAbsolutePath() + File.separator + "SpotStatistics for-" + IJ.getImage().getShortTitle() + ".csv");
<                } catch (IOException var9) {
<                   var9.printStackTrace();
<                }
<             }
< 
<          }
<       });
<       this.refreshButtonSpot.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.refreshSpotThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.refreshActionSpot();
<                }
<             });
<             OptionWizardPanel.this.refreshSpotThread.start();
<          }
<       });
<       this.refreshButtonTrack.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.refreshTrackThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.refreshActionTrack();
<                }
<             });
<             OptionWizardPanel.this.refreshTrackThread.start();
<          }
<       });
<       this.zoomInSpot.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.zoomInSpotThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.zoomInSpot.setActionCommand("ZOOM_IN_BOTH");
<                   OptionWizardPanel.this.zoomInSpot.addActionListener(OptionWizardPanel.this.scatterPlotSpot);
<                }
<             });
<             OptionWizardPanel.this.zoomInSpotThread.start();
<          }
<       });
<       this.zoomOutSpot.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.zoomOutSpotThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.zoomOutSpot.setActionCommand("ZOOM_OUT_BOTH");
<                   OptionWizardPanel.this.zoomOutSpot.addActionListener(OptionWizardPanel.this.scatterPlotSpot);
<                }
<             });
<             OptionWizardPanel.this.zoomOutSpotThread.start();
<          }
<       });
<       this.zoomInTrack.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.zoomInTrackThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.zoomInSpot.setActionCommand("ZOOM_IN_BOTH");
<                   OptionWizardPanel.this.zoomInSpot.addActionListener(OptionWizardPanel.this.scatterPlotTrack);
<                }
<             });
<             OptionWizardPanel.this.zoomInTrackThread.start();
<          }
<       });
<       this.zoomOutTrack.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.zoomOutTrackThread = new Thread(new Runnable() {
<                public void run() {
<                   OptionWizardPanel.this.zoomOutTrack.setActionCommand("ZOOM_OUT_BOTH");
<                   OptionWizardPanel.this.zoomOutTrack.addActionListener(OptionWizardPanel.this.scatterPlotTrack);
<                }
<             });
<             OptionWizardPanel.this.zoomOutTrackThread.start();
<          }
<       });
<       this.comboRegressionSpot.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.comboRegSpotThread = new Thread(new Runnable() {
<                public void run() {
<                   if (OptionWizardPanel.this.comboRegressionSpot.getSelectedIndex() == 1) {
<                      OptionWizardPanel.this.filterOrderSpot.setEnabled(true);
<                   }
< 
<                   if (OptionWizardPanel.this.comboRegressionSpot.getSelectedIndex() != 1) {
<                      OptionWizardPanel.this.filterOrderSpot.setEnabled(false);
<                   }
< 
<                }
<             });
<             OptionWizardPanel.this.comboRegSpotThread.start();
<          }
<       });
<       this.comboRegressionTrack.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.comboRegTrackThread = new Thread(new Runnable() {
<                public void run() {
<                   if (OptionWizardPanel.this.comboRegressionTrack.getSelectedIndex() == 1) {
<                      OptionWizardPanel.this.filterOrderTrack.setEnabled(true);
<                   }
< 
<                   if (OptionWizardPanel.this.comboRegressionTrack.getSelectedIndex() != 1) {
<                      OptionWizardPanel.this.filterOrderTrack.setEnabled(false);
<                   }
< 
<                }
<             });
<             OptionWizardPanel.this.comboRegTrackThread.start();
<          }
<       });
<       this.comboClassSpot.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.comboClassSpotThread = new Thread(new Runnable() {
<                public void run() {
<                   int i;
<                   if (OptionWizardPanel.this.comboClassSpot.getSelectedIndex() == 0) {
<                      OptionWizardPanel.this.dataToStatisticsSpot = new ArrayList();
< 
<                      for(i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<                         if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE) {
<                            OptionWizardPanel.this.dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot.getValueAt(i, OptionWizardPanel.this.comboParamSpot.getSelectedIndex() + 3).toString()));
<                         }
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionSpot();
<                   }
< 
<                   if (OptionWizardPanel.this.comboClassSpot.getSelectedIndex() == 1) {
<                      OptionWizardPanel.this.dataToStatisticsSpot = new ArrayList();
< 
<                      for(i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<                         if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, 0)).getText() == "") {
<                            OptionWizardPanel.this.dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot.getValueAt(i, OptionWizardPanel.this.comboParamSpot.getSelectedIndex() + 3).toString()));
<                         }
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionSpot();
<                   }
< 
<                   if (OptionWizardPanel.this.comboClassSpot.getSelectedIndex() == 2) {
<                      OptionWizardPanel.this.dataToStatisticsSpot = new ArrayList();
< 
<                      for(i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<                         if (FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, 0)).getText() == OptionWizardPanel.this.comboClassSpot.getSelectedItem().toString()) {
<                            OptionWizardPanel.this.dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot.getValueAt(i, OptionWizardPanel.this.comboParamSpot.getSelectedIndex() + 3).toString()));
<                         }
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionSpot();
<                   }
< 
<                }
<             });
<             OptionWizardPanel.this.comboClassSpotThread.start();
<          }
<       });
<       this.comboClassTrack.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             OptionWizardPanel.this.comboClassTrackThread = new Thread(new Runnable() {
<                public void run() {
<                   int i;
<                   if (OptionWizardPanel.this.comboClassTrack.getSelectedIndex() == 0) {
<                      OptionWizardPanel.this.dataToStatisticsTrack = new ArrayList();
< 
<                      for(i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<                         if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE) {
<                            OptionWizardPanel.this.dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack.getValueAt(i, OptionWizardPanel.this.comboParamTrack.getSelectedIndex() + 3).toString()));
<                         }
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionTrack();
<                   }
< 
<                   if (OptionWizardPanel.this.comboClassTrack.getSelectedIndex() == 1) {
<                      OptionWizardPanel.this.dataToStatisticsTrack = new ArrayList();
< 
<                      for(i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<                         if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, 0)).getText() == "") {
<                            OptionWizardPanel.this.dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack.getValueAt(i, OptionWizardPanel.this.comboParamTrack.getSelectedIndex() + 3).toString()));
<                         }
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionTrack();
<                   }
< 
<                   if (OptionWizardPanel.this.comboClassTrack.getSelectedIndex() == 2) {
<                      OptionWizardPanel.this.dataToStatisticsTrack = new ArrayList();
< 
<                      for(i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<                         if (ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE && ((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, 0)).getText() == OptionWizardPanel.this.comboClassTrack.getSelectedItem().toString()) {
<                            OptionWizardPanel.this.dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack.getValueAt(i, OptionWizardPanel.this.comboParamTrack.getSelectedIndex() + 3).toString()));
<                         }
<                      }
< 
<                      OptionWizardPanel.this.descriptiveStatisticsActionTrack();
<                   }
< 
<                }
<             });
<             OptionWizardPanel.this.comboClassTrackThread.start();
<          }
<       });
<    }
< 
<    public void descriptiveStatisticsActionSpot() {
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getMean() * 1000.0D) / 1000.0D), 0, 0);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getStandardDeviation() / (double)(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getN() * 1000.0D) / 1000.0D), 0, 1);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getPercentile(50.0D) * 1000.0D) / 1000.0D), 0, 2);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getStandardDeviation() * 1000.0D) / 1000.0D), 0, 3);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getVariance() * 1000.0D) / 1000.0D), 0, 4);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getKurtosis() * 1000.0D) / 1000.0D), 0, 5);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getSkewness() * 1000.0D) / 1000.0D), 0, 6);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getMin() * 1000.0D) / 1000.0D), 0, 7);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getMax() * 1000.0D) / 1000.0D), 0, 8);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getSum() * 1000.0D) / 1000.0D), 0, 9);
<       this.modelSpot.setValueAt(String.valueOf((double)Math.round((double)(new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getN() * 1000.0D) / 1000.0D), 0, 10);
<    }
< 
<    public void descriptiveStatisticsActionTrack() {
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getMean() * 1000.0D) / 1000.0D), 0, 0);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getStandardDeviation() / (double)(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getN() * 1000.0D) / 1000.0D), 0, 1);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getPercentile(50.0D) * 1000.0D) / 1000.0D), 0, 2);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getStandardDeviation() * 1000.0D) / 1000.0D), 0, 3);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getVariance() * 1000.0D) / 1000.0D), 0, 4);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getKurtosis() * 1000.0D) / 1000.0D), 0, 5);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getSkewness() * 1000.0D) / 1000.0D), 0, 6);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getMin() * 1000.0D) / 1000.0D), 0, 7);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getMax() * 1000.0D) / 1000.0D), 0, 8);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getSum() * 1000.0D) / 1000.0D), 0, 9);
<       this.modelTrack.setValueAt(String.valueOf((double)Math.round((double)(new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getN() * 1000.0D) / 1000.0D), 0, 10);
<    }
< 
<    public void refreshActionSpot() {
<       this.comboClassSpot.removeAllItems();
<       this.comboClassSpot.addItem("All items");
<       this.comboClassSpot.addItem("No Identified");
<       int rowCount;
<       if (ColorEditorSpot.modelC.getRowCount() > 0) {
<          for(rowCount = 0; rowCount < ColorEditorSpot.modelC.getRowCount(); ++rowCount) {
<             this.comboClassSpot.addItem(((JLabel)ColorEditorSpot.modelC.getValueAt(rowCount, 0)).getText());
<          }
<       }
< 
<       rowCount = FirstWizardPanel.tableSpot.getRowCount();
<       int columnCount = FirstWizardPanel.tableSpot.getColumnCount();
<       selectedIndexDomainSpot = this.comboFeatureDomainSpot.getSelectedIndex();
<       selectedIndexRangeSpot = this.comboFeatureRangeSpot.getSelectedIndex();
<       List<Double> valuesDomainSpot = new ArrayList();
<       List<Double> valuesRangeSpot = new ArrayList();
<       Object[][] dataSpot = new Object[rowCount][columnCount];
< 
<       int i;
<       for(int i = 0; i < rowCount; ++i) {
<          for(i = 0; i < columnCount; ++i) {
<             dataSpot[i][i] = FirstWizardPanel.tableSpot.getValueAt(i, i);
<          }
< 
<          valuesDomainSpot.add(Double.parseDouble(dataSpot[i][selectedIndexDomainSpot + 4].toString()));
<          valuesRangeSpot.add(Double.parseDouble(dataSpot[i][selectedIndexRangeSpot + 4].toString()));
<       }
< 
<       if (valuesDomainSpot.isEmpty() == Boolean.TRUE) {
<          IJ.error("You should have your spot analysis done. Please go backwards.");
<       } else {
<          this.maxDomainSpot = (Double)Collections.max(valuesDomainSpot);
<          this.maxRangeSpot = (Double)Collections.max(valuesRangeSpot);
<          List<Color> listColorSpot = new ArrayList();
< 
<          for(i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); ++i) {
<             listColorSpot.add(((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, FirstWizardPanel.tableSpot.convertColumnIndexToModel(1))).getBackground());
<          }
< 
<          Color[] classColorSpot = new Color[listColorSpot.size()];
<          listColorSpot.toArray(classColorSpot);
<          if (this.comboRegressionSpot.getSelectedIndex() == 0) {
<             this.sp2Spot.addScatterPlotSeriesLinear(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
<          }
< 
<          if (this.comboRegressionSpot.getSelectedIndex() == 1) {
<             this.sp2Spot.addScatterPlotSeriesPolynomial(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot, (Integer)this.filterOrderSpot.getValue());
<          }
< 
<          if (this.comboRegressionSpot.getSelectedIndex() == 2) {
<             this.sp2Spot.addScatterPlotSeriesPower(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
<          }
< 
<          if (this.comboRegressionSpot.getSelectedIndex() == 3) {
<             this.sp2Spot.addScatterPlotSeriesLogarithmic(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
<          }
< 
<          if (this.comboRegressionSpot.getSelectedIndex() == 4) {
<             this.sp2Spot.addScatterPlotSeriesExponential(this.comboFeatureDomainSpot.getSelectedItem().toString(), this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
<          }
<       }
< 
<    }
< 
<    public void refreshActionTrack() {
<       this.comboClassTrack.removeAllItems();
<       this.comboClassTrack.addItem("All items");
<       this.comboClassTrack.addItem("No Identified");
<       int rowCount;
<       if (ColorEditorTrack.modelC.getRowCount() > 0) {
<          for(rowCount = 0; rowCount < ColorEditorTrack.modelC.getRowCount(); ++rowCount) {
<             this.comboClassTrack.addItem(((JLabel)ColorEditorTrack.modelC.getValueAt(rowCount, 0)).getText());
<          }
<       }
< 
<       rowCount = ChooserWizardPanel.tableTrack.getRowCount();
<       int columnCount = ChooserWizardPanel.tableTrack.getColumnCount();
<       selectedIndexDomainTrack = this.comboFeatureDomainTrack.getSelectedIndex();
<       selectedIndexRangeTrack = this.comboFeatureRangeTrack.getSelectedIndex();
<       List<Double> valuesDomainTrack = new ArrayList();
<       List<Double> valuesRangeTrack = new ArrayList();
<       Object[][] dataTrack = new Object[rowCount][columnCount];
< 
<       int i;
<       for(int i = 0; i < rowCount; ++i) {
<          for(i = 0; i < columnCount; ++i) {
<             dataTrack[i][i] = ChooserWizardPanel.tableTrack.getValueAt(i, i);
<          }
< 
<          valuesDomainTrack.add(Double.parseDouble(dataTrack[i][selectedIndexDomainTrack + 4].toString()));
<          valuesRangeTrack.add(Double.parseDouble(dataTrack[i][selectedIndexRangeTrack + 4].toString()));
<       }
< 
<       if (valuesDomainTrack.isEmpty() == Boolean.TRUE) {
<          IJ.error("You should have your track analysis done. Please go backwards.");
<       } else {
<          this.maxDomainTrack = (Double)Collections.max(valuesDomainTrack);
<          this.maxRangeTrack = (Double)Collections.max(valuesRangeTrack);
<          List<Color> listColorTrack = new ArrayList();
< 
<          for(i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); ++i) {
<             listColorTrack.add(((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1))).getBackground());
<          }
< 
<          Color[] classColorTrack = new Color[listColorTrack.size()];
<          listColorTrack.toArray(classColorTrack);
<          if (this.comboRegressionTrack.getSelectedIndex() == 0) {
<             this.sp2Track.addScatterPlotSeriesLinear(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
<          }
< 
<          if (this.comboRegressionTrack.getSelectedIndex() == 1) {
<             this.sp2Track.addScatterPlotSeriesPolynomial(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack, (Integer)this.filterOrderTrack.getValue());
<          }
< 
<          if (this.comboRegressionTrack.getSelectedIndex() == 2) {
<             this.sp2Track.addScatterPlotSeriesPower(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
<          }
< 
<          if (this.comboRegressionTrack.getSelectedIndex() == 3) {
<             this.sp2Track.addScatterPlotSeriesLogarithmic(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
<          }
< 
<          if (this.comboRegressionTrack.getSelectedIndex() == 4) {
<             this.sp2Track.addScatterPlotSeriesExponential(this.comboFeatureDomainTrack.getSelectedItem().toString(), this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack);
<          }
<       }
< 
<    }
< 
<    public void update1() {
<       this.setNextButtonEnabled(true);
<       this.setFinishButtonEnabled(true);
<       this.setBackButtonEnabled(true);
<    }
< 
<    public void next() {
<       this.setNextButtonEnabled(false);
<    }
< 
<    public void back() {
<       this.switchPanel(1);
<    }
< 
<    public void finish() {
<       this.switchPanel(2);
<    }
< }
---
> /*     */ import ij.IJ;
> /*     */ import ij.measure.ResultsTable;
> /*     */ import java.awt.BasicStroke;
> /*     */ import java.awt.Color;
> /*     */ import java.awt.Component;
> /*     */ import java.awt.Container;
> /*     */ import java.awt.Dimension;
> /*     */ import java.awt.FlowLayout;
> /*     */ import java.awt.Font;
> /*     */ import java.awt.event.ActionEvent;
> /*     */ import java.awt.event.ActionListener;
> /*     */ import java.awt.image.BufferedImage;
> /*     */ import java.io.File;
> /*     */ import java.io.IOException;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.Arrays;
> /*     */ import java.util.Collections;
> /*     */ import java.util.List;
> /*     */ import javax.imageio.ImageIO;
> /*     */ import javax.swing.BorderFactory;
> /*     */ import javax.swing.Box;
> /*     */ import javax.swing.BoxLayout;
> /*     */ import javax.swing.Icon;
> /*     */ import javax.swing.ImageIcon;
> /*     */ import javax.swing.JButton;
> /*     */ import javax.swing.JComboBox;
> /*     */ import javax.swing.JFileChooser;
> /*     */ import javax.swing.JFrame;
> /*     */ import javax.swing.JLabel;
> /*     */ import javax.swing.JPanel;
> /*     */ import javax.swing.JScrollPane;
> /*     */ import javax.swing.JSeparator;
> /*     */ import javax.swing.JSpinner;
> /*     */ import javax.swing.JTabbedPane;
> /*     */ import javax.swing.JTable;
> /*     */ import javax.swing.SpinnerNumberModel;
> /*     */ import javax.swing.table.DefaultTableModel;
> /*     */ import jwizardcomponent.JWizardComponents;
> /*     */ import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
> /*     */ import org.jfree.chart.ChartPanel;
> /*     */ import org.jfree.chart.plot.IntervalMarker;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class OptionWizardPanel
> /*     */   extends LabelWizardPanel
> /*     */ {
> /*     */   public double maxDomainSpot;
> /*     */   public double maxRangeSpot;
> /*     */   public double maxDomainTrack;
> /*     */   public double maxRangeTrack;
> /*     */   public IntervalMarker markerRangeSpot;
> /*     */   public IntervalMarker markerDomainSpot;
> /*     */   public IntervalMarker markerRangeTrack;
> /*     */   public IntervalMarker markerDomainTrack;
> /*     */   private JSpinner filterOrderSpot;
> /*     */   private JSpinner filterOrderTrack;
> /*     */   static int selectedIndexCh2;
> /*     */   static int selectedIndexCh3;
> /*     */   static int numCh2Positive;
> /*     */   static int numCh3Positive;
> /*     */   static int countSenescentNumber;
> /*     */   static int lhCountAll;
> /*     */   static int hhCountAll;
> /*     */   static int llCountAll;
> /*     */   static int hlCountAll;
> /*     */   static int lhCountNID;
> /*     */   static int hhCountNID;
> /*     */   static int llCountNID;
> /*     */   static int hlCountNID;
> /*     */   static int lhCountClass;
> /*     */   static int hhCountClass;
> /*     */   static int llCountClass;
> /*     */   static int hlCountClass;
> /*     */   static int selectedIndexDomainSpot;
> /*     */   static int selectedIndexRangeSpot;
> /*     */   static int selectedIndexDomainTrack;
> /*     */   static int selectedIndexRangeTrack;
> /*     */   static JLabel scatLabel;
> /*     */   static JLabel sumLabel;
> /*     */   static JLabel labelScoresSpot;
> /*     */   static JLabel labelScoresTrack;
> /*     */   JComboBox<String> comboFeatureDomainSpot;
> /*     */   JComboBox<String> comboFeatureRangeSpot;
> /*     */   
> /*     */   public OptionWizardPanel(JWizardComponents wizardComponents, String option) {
> /*  93 */     super(wizardComponents, "");
> /*  94 */     setPanelTitle("");
> /*  95 */     setLayout(new BoxLayout((Container)this, 1));
> /*     */     
> /*  97 */     JPanel chartPanel2Spot = new JPanel();
> /*  98 */     this.markerRangeSpot = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), 
> /*  99 */         new BasicStroke(1.5F), 0.6F);
> /* 100 */     this.markerDomainSpot = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), 
> /* 101 */         new BasicStroke(1.5F), 0.5F);
> /* 102 */     this.markerRangeTrack = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), 
> /* 103 */         new BasicStroke(1.5F), 0.6F);
> /* 104 */     this.markerDomainTrack = new IntervalMarker(0.0D, 0.0D, new Color(229, 255, 204), new BasicStroke(), new Color(0, 102, 0), 
> /* 105 */         new BasicStroke(1.5F), 0.5F);
> /* 106 */     this.sp2Spot = new STScatterPlot("");
> /* 107 */     this.scatterPlotSpot = this.sp2Spot.createScatterChartPanelInitial("", "", new ArrayList<>(Arrays.asList(new Double[] { Double.valueOf(0.0D), Double.valueOf(0.0D), Double.valueOf(0.0D)
> /* 108 */             }, )), new ArrayList<>(Arrays.asList(new Double[] { Double.valueOf(0.0D), Double.valueOf(0.0D), Double.valueOf(0.0D) }, )), this.markerRangeSpot, this.markerDomainSpot, 
> /* 109 */         (Object[][])new Double[][] { { Double.valueOf(0.0D) }, , { Double.valueOf(0.0D) },  }, new Double[][] { { Double.valueOf(0.0D) }, { Double.valueOf(0.0D) } });
> /* 110 */     this.refreshButtonSpot = new JButton("");
> /* 111 */     this.refreshButtonSpot.setIcon(FirstWizardPanel.refreshCell);
> /* 112 */     this.refreshButtonSpot.setToolTipText("Click this button to refresh scatter-plot.");
> /* 113 */     this.zoomInSpot = new JButton("");
> /* 114 */     ImageIcon iconZoomIn = FirstWizardPanel.createImageIcon("images/zoomin.png");
> /* 115 */     Icon zoomInCell = new ImageIcon(iconZoomIn.getImage().getScaledInstance(18, 20, 4));
> /* 116 */     this.zoomInSpot.setIcon(zoomInCell);
> /* 117 */     this.zoomInSpot.setToolTipText("Click this button to zoom in Chart");
> /* 118 */     this.zoomOutSpot = new JButton("");
> /* 119 */     ImageIcon iconZoomOut = FirstWizardPanel.createImageIcon("images/zoomout.png");
> /* 120 */     Icon zoomOutCell = new ImageIcon(iconZoomOut.getImage().getScaledInstance(18, 20, 4));
> /* 121 */     this.zoomOutSpot.setIcon(zoomOutCell);
> /* 122 */     this.zoomOutSpot.setToolTipText("Click this button to zoom out Chart");
> /* 123 */     this.itemFiltersSpot = new ArrayList<>();
> /* 124 */     this.itemFiltersTrack = new ArrayList<>(); int i;
> /* 125 */     for (i = 2; i < FirstWizardPanel.columnNamesSpot.length; i++)
> /* 126 */       this.itemFiltersSpot.add(FirstWizardPanel.columnNamesSpot[i].toString()); 
> /* 127 */     for (i = 0; i < ChooserWizardPanel.columnNamesTrack.length; i++)
> /* 128 */       this.itemFiltersTrack.add(ChooserWizardPanel.columnNamesTrack[i].toString()); 
> /* 129 */     this.comboFeatureDomainSpot = new JComboBox<>();
> /* 130 */     this.comboFeatureDomainSpot.setPreferredSize(new Dimension(110, 20));
> /* 131 */     for (i = 0; i < this.itemFiltersSpot.size(); i++)
> /* 132 */       this.comboFeatureDomainSpot.addItem(this.itemFiltersSpot.get(i)); 
> /* 133 */     this.comboFeatureDomainSpot.setOpaque(true);
> /* 134 */     this.scatterPlot = new STScatterPlot("holaa");
> /* 135 */     chartPanel2Spot.add((Component)this.scatterPlotSpot);
> /* 136 */     this.filterOrderSpot = new JSpinner(new SpinnerNumberModel(1, 0, 1000, 1));
> /* 137 */     this.filterOrderSpot.setPreferredSize(new Dimension(60, 20));
> /* 138 */     this.filterOrderSpot.setEnabled(false);
> /*     */ 
> /*     */ 
> /*     */     
> /* 142 */     JPanel filtersMaxSpot = new JPanel(new FlowLayout(1));
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 147 */     filtersMaxSpot.add(Box.createHorizontalStrut(2));
> /*     */ 
> /*     */     
> /* 150 */     this.comboFeatureRangeSpot = new JComboBox<>();
> /* 151 */     this.comboFeatureRangeSpot.setPreferredSize(new Dimension(110, 20));
> /* 152 */     for (int j = 0; j < this.itemFiltersSpot.size(); j++)
> /* 153 */       this.comboFeatureRangeSpot.addItem(this.itemFiltersSpot.get(j)); 
> /* 154 */     this.comboFeatureRangeSpot.setOpaque(true);
> /* 155 */     filtersMaxSpot.add(new JLabel("X :  "));
> /* 156 */     filtersMaxSpot.add(this.comboFeatureDomainSpot);
> /* 157 */     filtersMaxSpot.add(new JLabel("   Y :  "));
> /* 158 */     filtersMaxSpot.add(this.comboFeatureRangeSpot);
> /* 159 */     JPanel rangePanelFSpot = new JPanel(new FlowLayout(0));
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 167 */     JPanel chartDomainPanelBoxSpot = new JPanel();
> /* 168 */     chartDomainPanelBoxSpot.setLayout(new BoxLayout(chartDomainPanelBoxSpot, 1));
> /* 169 */     chartDomainPanelBoxSpot.add(Box.createVerticalStrut(10));
> /* 170 */     chartDomainPanelBoxSpot.add(chartPanel2Spot);
> /* 171 */     chartDomainPanelBoxSpot.add(filtersMaxSpot);
> /*     */ 
> /*     */ 
> /*     */     
> /* 175 */     rangePanelFSpot.add(chartDomainPanelBoxSpot);
> /* 176 */     JPanel buttonBox = new JPanel();
> /* 177 */     buttonBox.setLayout(new BoxLayout(buttonBox, 1));
> /* 178 */     JPanel refreshButtonPanelSpot = new JPanel(new FlowLayout(0));
> /* 179 */     refreshButtonPanelSpot.add(this.refreshButtonSpot);
> /* 180 */     JPanel zoomOutButtonPanelSpot = new JPanel(new FlowLayout(0));
> /* 181 */     zoomOutButtonPanelSpot.add(this.zoomOutSpot);
> /* 182 */     JPanel zoomInButtonPanelSpot = new JPanel(new FlowLayout(0));
> /* 183 */     zoomInButtonPanelSpot.add(this.zoomInSpot);
> /* 184 */     buttonBox.add(zoomInButtonPanelSpot);
> /* 185 */     buttonBox.add(zoomOutButtonPanelSpot);
> /* 186 */     buttonBox.add(refreshButtonPanelSpot);
> /* 187 */     this.comboRegressionSpot = new JComboBox<>();
> /* 188 */     this.comboRegressionSpot.setPreferredSize(new Dimension(90, 20));
> /* 189 */     this.comboRegressionSpot.addItem("Linear");
> /* 190 */     this.comboRegressionSpot.addItem("Polynomial");
> /* 191 */     this.comboRegressionSpot.addItem("Power");
> /* 192 */     this.comboRegressionSpot.addItem("Logarithmic");
> /* 193 */     this.comboRegressionSpot.addItem("Exponential");
> /*     */     
> /* 195 */     this.comboRegressionSpot.setSelectedIndex(0);
> /* 196 */     this.comboRegressionSpot.setOpaque(true);
> /* 197 */     JPanel regreOrderPanel = new JPanel(new FlowLayout(0));
> /* 198 */     regreOrderPanel.add(this.comboRegressionSpot);
> /* 199 */     JPanel filterOrderPanel = new JPanel(new FlowLayout(0));
> /* 200 */     filterOrderPanel.add(this.filterOrderSpot);
> /* 201 */     buttonBox.add(regreOrderPanel);
> /* 202 */     buttonBox.add(filterOrderPanel);
> /* 203 */     regressionPanelSpot = new JPanel();
> /* 204 */     regressionPanelSpot.setBorder(BorderFactory.createTitledBorder("Reg.Params"));
> /* 205 */     regressionPanelSpot.setPreferredSize(new Dimension(this.comboRegressionSpot.getWidth() + 10, 35));
> /* 206 */     rangePanelFSpot.add(buttonBox);
> /* 207 */     JPanel spotPanel = new JPanel();
> /* 208 */     spotPanel.add(rangePanelFSpot);
> /* 209 */     spotPanel.setBorder(BorderFactory.createTitledBorder(""));
> /*     */     
> /* 211 */     JPanel spotStatistics = new JPanel();
> /* 212 */     spotStatistics.setLayout(new BoxLayout(spotStatistics, 1));
> /* 213 */     JPanel spotStatisticsFlow = new JPanel(new FlowLayout(0));
> /* 214 */     JPanel classParamSpot = new JPanel(new FlowLayout(0));
> /* 215 */     this.comboClassSpot = new JComboBox<>();
> /* 216 */     this.comboClassSpot.setPreferredSize(new Dimension(120, 20)); int k;
> /* 217 */     for (k = 2; k < FirstWizardPanel.columnNamesSpot.length; k++)
> /* 218 */       this.comboClassSpot.addItem((String)FirstWizardPanel.columnNamesSpot[k]); 
> /* 219 */     this.comboClassSpot.setOpaque(true);
> /* 220 */     this.comboClassSpot.setToolTipText("Choose selected items for descriptive statistics.");
> /* 221 */     this.comboParamSpot = new JComboBox<>();
> /* 222 */     this.comboParamSpot.setPreferredSize(new Dimension(120, 20));
> /* 223 */     for (k = 2; k < FirstWizardPanel.columnNamesSpot.length; k++)
> /* 224 */       this.comboParamSpot.addItem((String)FirstWizardPanel.columnNamesSpot[k]); 
> /* 225 */     this.comboParamSpot.setOpaque(true);
> /* 226 */     this.comboParamSpot.setToolTipText("Choose a spot parameter for descriptive statistics.");
> /* 227 */     classParamSpot.add(this.comboClassSpot);
> /* 228 */     classParamSpot.add(this.comboParamSpot);
> /* 229 */     labelScoresSpot = new JLabel("SCORES");
> /* 230 */     labelScoresSpot.setFont(new Font("Verdana", 1, 20));
> /* 231 */     spotStatisticsFlow.add(labelScoresSpot);
> /* 232 */     spotStatistics.add(Box.createVerticalStrut(60));
> /* 233 */     spotStatistics.add(spotStatisticsFlow);
> /* 234 */     spotStatistics.add(new JSeparator(0));
> /* 235 */     spotStatistics.add(Box.createVerticalStrut(20));
> /* 236 */     spotStatistics.add(classParamSpot);
> /* 237 */     spotStatistics.add(Box.createVerticalStrut(20));
> /* 238 */     spotStatistics.add(new JSeparator(0));
> /* 239 */     String[][] data = { { "", "", "", "", "", "", "", "", "", "", "" } };
> /* 240 */     String[] column = { "Mean ", "Std.Error ", "Median ", "Std.Dev ", "Variance ", "Kurtosis ", "Skewness ", "Min ", 
> /* 241 */         "Max ", "Sum ", "Count " };
> /*     */     
> /* 243 */     JTable table = new JTable();
> /* 244 */     this.modelSpot = new DefaultTableModel((Object[][])data, (Object[])column)
> /*     */       {
> /*     */         public Class<?> getColumnClass(int column)
> /*     */         {
> /* 248 */           if (getRowCount() > 0) {
> /* 249 */             Object value = getValueAt(0, column);
> /* 250 */             if (value != null) {
> /* 251 */               return getValueAt(0, column).getClass();
> /*     */             }
> /*     */           } 
> /*     */           
> /* 255 */           return super.getColumnClass(column);
> /*     */         }
> /*     */         
> /*     */         public boolean isCellEditable(int row, int col) {
> /* 259 */           return false;
> /*     */         }
> /*     */       };
> /* 262 */     table.setAutoResizeMode(0);
> /* 263 */     table.setModel(this.modelSpot);
> /* 264 */     table.setRowHeight(60);
> /* 265 */     JScrollPane sp = new JScrollPane(table);
> /* 266 */     sp.setPreferredSize(new Dimension(500, 100));
> /* 267 */     sp.setVerticalScrollBarPolicy(22);
> /* 268 */     sp.setHorizontalScrollBarPolicy(32);
> /* 269 */     for (int u = 0; u < table.getColumnCount(); u++) {
> /* 270 */       table.getColumnModel().getColumn(u).setMinWidth(100);
> /* 271 */       table.getColumnModel().getColumn(u).setMaxWidth(100);
> /* 272 */       table.getColumnModel().getColumn(u).setPreferredWidth(100);
> /*     */     } 
> /*     */     
> /* 275 */     spotStatistics.add(Box.createVerticalStrut(20));
> /* 276 */     spotStatistics.add(sp);
> /* 277 */     spotStatistics.add(Box.createVerticalStrut(20));
> /* 278 */     spotStatistics.add(new JSeparator(0));
> /* 279 */     JButton plotButton = new JButton();
> /* 280 */     ImageIcon iconPlot = FirstWizardPanel.createImageIcon("images/plot.jpg");
> /* 281 */     Icon plotCell = new ImageIcon(iconPlot.getImage().getScaledInstance(18, 20, 4));
> /* 282 */     plotButton.setIcon(plotCell);
> /* 283 */     plotButton.setToolTipText("Click to export scatter plot.");
> /* 284 */     JPanel panelPlot = new JPanel(new FlowLayout(0));
> /* 285 */     panelPlot.add(plotButton);
> /* 286 */     JButton csvButton = new JButton();
> /* 287 */     ImageIcon iconCsv = FirstWizardPanel.createImageIcon("images/csv.png");
> /* 288 */     Icon csvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(18, 20, 4));
> /* 289 */     csvButton.setIcon(csvCell);
> /* 290 */     csvButton.setToolTipText("Click to export your spots statistics table.");
> /* 291 */     JPanel panelCsv = new JPanel(new FlowLayout(0));
> /* 292 */     panelCsv.add(csvButton);
> /* 293 */     JPanel panelPngCsv = new JPanel(new FlowLayout(0));
> /* 294 */     panelPngCsv.add(panelPlot);
> /* 295 */     panelPngCsv.add(panelCsv);
> /* 296 */     spotStatistics.add(panelPngCsv);
> /* 297 */     spotPanel.add(spotStatistics);
> /*     */ 
> /*     */ 
> /*     */     
> /* 301 */     JPanel chartPanel2Track = new JPanel();
> /* 302 */     this.sp2Track = new STScatterPlot("");
> /* 303 */     this.scatterPlotTrack = this.sp2Track.createScatterChartPanelInitial("", "", 
> /* 304 */         new ArrayList<>(Arrays.asList(new Double[] { Double.valueOf(0.0D), Double.valueOf(0.0D), Double.valueOf(0.0D) }, )), new ArrayList<>(Arrays.asList(new Double[] { Double.valueOf(0.0D), Double.valueOf(0.0D), Double.valueOf(0.0D)
> /* 305 */             }, )), this.markerRangeTrack, this.markerDomainTrack, (Object[][])new Double[][] { { Double.valueOf(0.0D) }, , { Double.valueOf(0.0D)
> /* 306 */           },  }, new Double[][] { { Double.valueOf(0.0D) }, { Double.valueOf(0.0D) } });
> /* 307 */     this.refreshButtonTrack = new JButton("");
> /* 308 */     this.refreshButtonTrack.setIcon(FirstWizardPanel.refreshCell);
> /* 309 */     this.refreshButtonTrack.setToolTipText("Click this button to refresh scatter-plot.");
> /* 310 */     this.zoomInTrack = new JButton("");
> /* 311 */     this.zoomInTrack.setIcon(zoomInCell);
> /* 312 */     this.zoomInTrack.setToolTipText("Click this button to zoom in Chart");
> /* 313 */     this.zoomOutTrack = new JButton("");
> /* 314 */     this.zoomOutTrack.setIcon(zoomOutCell);
> /* 315 */     this.zoomOutTrack.setToolTipText("Click this button to zoom out Chart"); int m;
> /* 316 */     for (m = 0; m < ChooserWizardPanel.columnNamesTrack.length; m++)
> /* 317 */       this.itemFiltersTrack.add(ChooserWizardPanel.columnNamesTrack[m].toString()); 
> /* 318 */     this.comboFeatureDomainTrack = new JComboBox<>();
> /* 319 */     this.comboFeatureDomainTrack.setPreferredSize(new Dimension(110, 20));
> /* 320 */     for (m = 3; m < this.itemFiltersTrack.size(); m++)
> /* 321 */       this.comboFeatureDomainTrack.addItem(this.itemFiltersTrack.get(m)); 
> /* 322 */     this.comboFeatureDomainTrack.setOpaque(true);
> /*     */     
> /* 324 */     chartPanel2Track.add((Component)this.scatterPlotTrack);
> /* 325 */     this.filterOrderTrack = new JSpinner(new SpinnerNumberModel(1, 0, 1000, 1));
> /* 326 */     this.filterOrderTrack.setPreferredSize(new Dimension(60, 20));
> /* 327 */     this.filterOrderTrack.setEnabled(false);
> /* 328 */     JPanel filtersMaxTrack = new JPanel(new FlowLayout(1));
> /* 329 */     filtersMaxTrack.add(Box.createHorizontalStrut(2));
> /*     */     
> /* 331 */     this.comboFeatureRangeTrack = new JComboBox<>();
> /* 332 */     this.comboFeatureRangeTrack.setPreferredSize(new Dimension(110, 20));
> /* 333 */     for (int n = 3; n < this.itemFiltersTrack.size(); n++)
> /* 334 */       this.comboFeatureRangeTrack.addItem(this.itemFiltersTrack.get(n)); 
> /* 335 */     this.comboFeatureRangeTrack.setOpaque(true);
> /* 336 */     filtersMaxTrack.add(new JLabel("X :  "));
> /* 337 */     filtersMaxTrack.add(this.comboFeatureDomainTrack);
> /* 338 */     filtersMaxTrack.add(new JLabel("   Y :  "));
> /* 339 */     filtersMaxTrack.add(this.comboFeatureRangeTrack);
> /* 340 */     JPanel rangePanelFTrack = new JPanel(new FlowLayout(0));
> /* 341 */     JPanel chartDomainPanelBoxTrack = new JPanel();
> /* 342 */     chartDomainPanelBoxTrack.setLayout(new BoxLayout(chartDomainPanelBoxTrack, 1));
> /* 343 */     chartDomainPanelBoxTrack.add(Box.createVerticalStrut(10));
> /* 344 */     chartDomainPanelBoxTrack.add(chartPanel2Track);
> /* 345 */     chartDomainPanelBoxTrack.add(filtersMaxTrack);
> /* 346 */     rangePanelFTrack.add(chartDomainPanelBoxTrack);
> /* 347 */     JPanel buttonBoxTrack = new JPanel();
> /* 348 */     buttonBoxTrack.setLayout(new BoxLayout(buttonBoxTrack, 1));
> /* 349 */     JPanel refreshButtonPanelTrack = new JPanel(new FlowLayout(0));
> /* 350 */     refreshButtonPanelTrack.add(this.refreshButtonTrack);
> /* 351 */     JPanel zoomOutButtonPanelTrack = new JPanel(new FlowLayout(0));
> /* 352 */     zoomOutButtonPanelTrack.add(this.zoomOutTrack);
> /* 353 */     JPanel zoomInButtonPanelTrack = new JPanel(new FlowLayout(0));
> /* 354 */     zoomInButtonPanelTrack.add(this.zoomInTrack);
> /* 355 */     buttonBoxTrack.add(zoomInButtonPanelTrack);
> /* 356 */     buttonBoxTrack.add(zoomOutButtonPanelTrack);
> /* 357 */     buttonBoxTrack.add(refreshButtonPanelTrack);
> /* 358 */     this.comboRegressionTrack = new JComboBox<>();
> /* 359 */     this.comboRegressionTrack.setPreferredSize(new Dimension(90, 20));
> /* 360 */     this.comboRegressionTrack.addItem("Linear");
> /* 361 */     this.comboRegressionTrack.addItem("Polynomial");
> /* 362 */     this.comboRegressionTrack.addItem("Power");
> /* 363 */     this.comboRegressionTrack.addItem("Logarithmic");
> /* 364 */     this.comboRegressionTrack.addItem("Exponential");
> /*     */     
> /* 366 */     this.comboRegressionTrack.setSelectedIndex(0);
> /* 367 */     this.comboRegressionTrack.setOpaque(true);
> /* 368 */     JPanel regreOrderPanelTrack = new JPanel(new FlowLayout(0));
> /* 369 */     regreOrderPanelTrack.add(this.comboRegressionTrack);
> /* 370 */     JPanel filterOrderPanelTrack = new JPanel(new FlowLayout(0));
> /* 371 */     filterOrderPanelTrack.add(this.filterOrderTrack);
> /* 372 */     buttonBoxTrack.add(regreOrderPanelTrack);
> /* 373 */     buttonBoxTrack.add(filterOrderPanelTrack);
> /* 374 */     regressionPanelTrack = new JPanel();
> /* 375 */     regressionPanelTrack.setBorder(BorderFactory.createTitledBorder("Reg.Params"));
> /* 376 */     regressionPanelTrack.setPreferredSize(new Dimension(this.comboRegressionTrack.getWidth() + 10, 35));
> /* 377 */     rangePanelFTrack.add(buttonBoxTrack);
> /*     */     
> /* 379 */     JPanel trackPanel = new JPanel();
> /* 380 */     trackPanel.add(rangePanelFTrack);
> /* 381 */     trackPanel.setBorder(BorderFactory.createTitledBorder(""));
> /*     */     
> /* 383 */     JPanel trackStatistics = new JPanel();
> /* 384 */     trackStatistics.setLayout(new BoxLayout(trackStatistics, 1));
> /* 385 */     JPanel trackStatisticsFlow = new JPanel(new FlowLayout(0));
> /* 386 */     JPanel classParamTrack = new JPanel(new FlowLayout(0));
> /* 387 */     this.comboClassTrack = new JComboBox<>();
> /* 388 */     this.comboClassTrack.setPreferredSize(new Dimension(120, 20)); int i1;
> /* 389 */     for (i1 = 3; i1 < ChooserWizardPanel.columnNamesTrack.length; i1++)
> /* 390 */       this.comboClassTrack.addItem((String)ChooserWizardPanel.columnNamesTrack[i1]); 
> /* 391 */     this.comboClassTrack.setOpaque(true);
> /* 392 */     this.comboClassTrack.setToolTipText("Choose selected items for descriptive statistics.");
> /* 393 */     this.comboParamTrack = new JComboBox<>();
> /* 394 */     this.comboParamTrack.setPreferredSize(new Dimension(120, 20));
> /* 395 */     for (i1 = 3; i1 < ChooserWizardPanel.columnNamesTrack.length; i1++)
> /* 396 */       this.comboParamTrack.addItem((String)ChooserWizardPanel.columnNamesTrack[i1]); 
> /* 397 */     this.comboParamTrack.setOpaque(true);
> /* 398 */     this.comboParamTrack.setToolTipText("Choose a track parameter for descriptive statistics.");
> /* 399 */     classParamTrack.add(this.comboClassTrack);
> /* 400 */     classParamTrack.add(this.comboParamTrack);
> /* 401 */     labelScoresTrack = new JLabel("SCORES");
> /* 402 */     labelScoresTrack.setFont(new Font("Verdana", 1, 20));
> /* 403 */     trackStatisticsFlow.add(labelScoresTrack);
> /* 404 */     trackStatistics.add(Box.createVerticalStrut(60));
> /* 405 */     trackStatistics.add(trackStatisticsFlow);
> /* 406 */     trackStatistics.add(new JSeparator(0));
> /* 407 */     trackStatistics.add(Box.createVerticalStrut(20));
> /* 408 */     trackStatistics.add(classParamTrack);
> /* 409 */     trackStatistics.add(Box.createVerticalStrut(20));
> /* 410 */     trackStatistics.add(new JSeparator(0));
> /* 411 */     String[][] dataTrack = { { "", "", "", "", "", "", "", "", "", "", "" } };
> /* 412 */     String[] columnTrack = { "Mean ", "Std.Error ", "Median ", "Std.Dev ", "Variance ", "Kurtosis ", "Skewness ", 
> /* 413 */         "Min ", "Max ", "Sum ", "Count " };
> /*     */     
> /* 415 */     JTable tableTrack = new JTable();
> /* 416 */     this.modelTrack = new DefaultTableModel((Object[][])dataTrack, (Object[])columnTrack)
> /*     */       {
> /*     */         public Class<?> getColumnClass(int columnTrack)
> /*     */         {
> /* 420 */           if (getRowCount() > 0) {
> /* 421 */             Object value = getValueAt(0, columnTrack);
> /* 422 */             if (value != null) {
> /* 423 */               return getValueAt(0, columnTrack).getClass();
> /*     */             }
> /*     */           } 
> /*     */           
> /* 427 */           return super.getColumnClass(columnTrack);
> /*     */         }
> /*     */         
> /*     */         public boolean isCellEditable(int row, int col) {
> /* 431 */           return false;
> /*     */         }
> /*     */       };
> /* 434 */     tableTrack.setAutoResizeMode(0);
> /* 435 */     tableTrack.setModel(this.modelTrack);
> /* 436 */     tableTrack.setRowHeight(60);
> /* 437 */     JScrollPane spTrack = new JScrollPane(tableTrack);
> /* 438 */     spTrack.setPreferredSize(new Dimension(500, 100));
> /* 439 */     spTrack.setVerticalScrollBarPolicy(22);
> /* 440 */     spTrack.setHorizontalScrollBarPolicy(32);
> /* 441 */     for (int i2 = 0; i2 < tableTrack.getColumnCount(); i2++) {
> /* 442 */       tableTrack.getColumnModel().getColumn(i2).setMinWidth(100);
> /* 443 */       tableTrack.getColumnModel().getColumn(i2).setMaxWidth(100);
> /* 444 */       tableTrack.getColumnModel().getColumn(i2).setPreferredWidth(100);
> /*     */     } 
> /*     */     
> /* 447 */     trackStatistics.add(Box.createVerticalStrut(20));
> /* 448 */     trackStatistics.add(spTrack);
> /* 449 */     trackStatistics.add(Box.createVerticalStrut(20));
> /* 450 */     trackStatistics.add(new JSeparator(0));
> /* 451 */     JButton plotButtonTrack = new JButton();
> /* 452 */     plotButtonTrack.setIcon(plotCell);
> /* 453 */     plotButtonTrack.setToolTipText("Click to export scatter plot.");
> /* 454 */     JPanel panelPlotTrack = new JPanel(new FlowLayout(0));
> /* 455 */     panelPlotTrack.add(plotButtonTrack);
> /* 456 */     JButton csvButtonTrack = new JButton();
> /* 457 */     csvButtonTrack.setIcon(csvCell);
> /* 458 */     csvButtonTrack.setToolTipText("Click to export your tracks statistics table.");
> /* 459 */     JPanel panelCsvTrack = new JPanel(new FlowLayout(0));
> /* 460 */     panelCsvTrack.add(csvButtonTrack);
> /* 461 */     JPanel panelPngCsvTrack = new JPanel(new FlowLayout(0));
> /* 462 */     panelPngCsvTrack.add(panelPlotTrack);
> /* 463 */     panelPngCsvTrack.add(panelCsvTrack);
> /* 464 */     trackStatistics.add(panelPngCsvTrack);
> /* 465 */     trackPanel.add(trackStatistics);
> /*     */     
> /* 467 */     JTabbedPane maintabbedPane = new JTabbedPane(1);
> /* 468 */     maintabbedPane.addTab("SPOTS ", FirstWizardPanel.iconSpotCell, spotPanel, "Scatter-Plot for spots");
> /* 469 */     maintabbedPane.addTab("TRACKS ", ChooserWizardPanel.iconTrackCell, trackPanel, "Scatter-Plot for tracks");
> /*     */     
> /* 471 */     maintabbedPane.setTabLayoutPolicy(1);
> /* 472 */     add(maintabbedPane, "Center");
> /*     */     
> /* 474 */     plotButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 477 */             JFileChooser fileChooser = new JFileChooser();
> /* 478 */             fileChooser.setFileSelectionMode(1);
> /* 479 */             fileChooser.setDialogTitle("Specify a directory to save plot as .png file");
> /* 480 */             int userSelection = fileChooser.showSaveDialog(new JFrame());
> /*     */             
> /* 482 */             if (userSelection == 0) {
> /* 483 */               File fileToSave = fileChooser.getSelectedFile();
> /* 484 */               BufferedImage chartImage = STScatterPlot.plot.getChart().createBufferedImage(1024, 768);
> /*     */               try {
> /* 486 */                 ImageIO.write(chartImage, "png", new File(String.valueOf(fileToSave.getAbsolutePath()) + File.separator + 
> /* 487 */                       "SpotPlot for " + IJ.getImage().getShortTitle() + ".png"));
> /* 488 */               } catch (IOException e1) {
> /*     */                 
> /* 490 */                 e1.printStackTrace();
> /*     */               } 
> /*     */             } 
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */     
> /* 497 */     csvButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 500 */             List<String> columnSpotHead = new ArrayList<>();
> /* 501 */             for (int j = 0; j < OptionWizardPanel.this.modelSpot.getColumnCount(); j++) {
> /* 502 */               columnSpotHead.add(OptionWizardPanel.this.modelSpot.getColumnName(j));
> /*     */             }
> /* 504 */             ResultsTable rt = new ResultsTable(Integer.valueOf(OptionWizardPanel.this.modelSpot.getRowCount()));
> /* 505 */             if (rt != null) {
> /* 506 */               rt.reset();
> /*     */             }
> /* 508 */             for (int i = 0; i < OptionWizardPanel.this.modelSpot.getRowCount(); i++) {
> /* 509 */               for (int k = 0; k < OptionWizardPanel.this.modelSpot.getColumnCount(); k++)
> /* 510 */                 rt.setValue(columnSpotHead.get(k), i, OptionWizardPanel.this.modelSpot.getValueAt(i, k).toString()); 
> /* 511 */             }  JFrame pngFrame = new JFrame();
> /* 512 */             JFileChooser fileChooser = new JFileChooser();
> /* 513 */             fileChooser.setFileSelectionMode(1);
> /* 514 */             fileChooser.setDialogTitle("Specify a directory to save csv file");
> /* 515 */             int userSelection = fileChooser.showSaveDialog(pngFrame);
> /*     */             
> /* 517 */             if (userSelection == 0) {
> /* 518 */               File fileToSave = fileChooser.getSelectedFile();
> /*     */               try {
> /* 520 */                 rt.saveAs(String.valueOf(fileToSave.getAbsolutePath()) + File.separator + "SpotStatistics for-" + 
> /* 521 */                     IJ.getImage().getShortTitle() + ".csv");
> /* 522 */               } catch (IOException e1) {
> /*     */                 
> /* 524 */                 e1.printStackTrace();
> /*     */               } 
> /*     */             } 
> /*     */           }
> /*     */         });
> /*     */ 
> /*     */ 
> /*     */     
> /* 532 */     this.refreshButtonSpot.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e)
> /*     */           {
> /* 536 */             OptionWizardPanel.this.refreshSpotThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 538 */                     OptionWizardPanel.null.access$0(OptionWizardPanel.null.this).refreshActionSpot();
> /*     */                   }
> /*     */                 });
> /* 541 */             OptionWizardPanel.this.refreshSpotThread.start();
> /*     */           }
> /*     */         });
> /* 544 */     this.refreshButtonTrack.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e)
> /*     */           {
> /* 548 */             OptionWizardPanel.this.refreshTrackThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 550 */                     OptionWizardPanel.null.access$0(OptionWizardPanel.null.this).refreshActionTrack();
> /*     */                   }
> /*     */                 });
> /* 553 */             OptionWizardPanel.this.refreshTrackThread.start();
> /*     */           }
> /*     */         });
> /* 556 */     this.zoomInSpot.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 559 */             OptionWizardPanel.this.zoomInSpotThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 561 */                     (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).zoomInSpot.setActionCommand("ZOOM_IN_BOTH");
> /* 562 */                     (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).zoomInSpot.addActionListener((ActionListener)(OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).scatterPlotSpot);
> /*     */                   }
> /*     */                 });
> /* 565 */             OptionWizardPanel.this.zoomInSpotThread.start();
> /*     */           }
> /*     */         });
> /* 568 */     this.zoomOutSpot.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 571 */             OptionWizardPanel.this.zoomOutSpotThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 573 */                     (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).zoomOutSpot.setActionCommand("ZOOM_OUT_BOTH");
> /* 574 */                     (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).zoomOutSpot.addActionListener((ActionListener)(OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).scatterPlotSpot);
> /*     */                   }
> /*     */                 });
> /* 577 */             OptionWizardPanel.this.zoomOutSpotThread.start();
> /*     */           }
> /*     */         });
> /* 580 */     this.zoomInTrack.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 583 */             OptionWizardPanel.this.zoomInTrackThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 585 */                     (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).zoomInSpot.setActionCommand("ZOOM_IN_BOTH");
> /* 586 */                     (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).zoomInSpot.addActionListener((ActionListener)(OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).scatterPlotTrack);
> /*     */                   }
> /*     */                 });
> /* 589 */             OptionWizardPanel.this.zoomInTrackThread.start();
> /*     */           }
> /*     */         });
> /* 592 */     this.zoomOutTrack.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 595 */             OptionWizardPanel.this.zoomOutTrackThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 597 */                     (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).zoomOutTrack.setActionCommand("ZOOM_OUT_BOTH");
> /* 598 */                     (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).zoomOutTrack.addActionListener((ActionListener)(OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).scatterPlotTrack);
> /*     */                   }
> /*     */                 });
> /* 601 */             OptionWizardPanel.this.zoomOutTrackThread.start();
> /*     */           }
> /*     */         });
> /* 604 */     this.comboRegressionSpot.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 607 */             OptionWizardPanel.this.comboRegSpotThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 609 */                     if ((OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboRegressionSpot.getSelectedIndex() == 1)
> /* 610 */                       (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).filterOrderSpot.setEnabled(true); 
> /* 611 */                     if ((OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboRegressionSpot.getSelectedIndex() != 1)
> /* 612 */                       (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).filterOrderSpot.setEnabled(false); 
> /*     */                   }
> /*     */                 });
> /* 615 */             OptionWizardPanel.this.comboRegSpotThread.start();
> /*     */           }
> /*     */         });
> /* 618 */     this.comboRegressionTrack.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 621 */             OptionWizardPanel.this.comboRegTrackThread = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 623 */                     if ((OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboRegressionTrack.getSelectedIndex() == 1)
> /* 624 */                       (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).filterOrderTrack.setEnabled(true); 
> /* 625 */                     if ((OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboRegressionTrack.getSelectedIndex() != 1)
> /* 626 */                       (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).filterOrderTrack.setEnabled(false); 
> /*     */                   }
> /*     */                 });
> /* 629 */             OptionWizardPanel.this.comboRegTrackThread.start();
> /*     */           }
> /*     */         });
> /* 632 */     this.comboClassSpot.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 635 */             OptionWizardPanel.this.comboClassSpotThread = new Thread(new Runnable()
> /*     */                 {
> /*     */                   public void run() {
> /* 638 */                     if ((OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboClassSpot.getSelectedIndex() == 0) {
> /* 639 */                       (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsSpot = new ArrayList<>();
> /* 640 */                       for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); i++) {
> /* 641 */                         if (FirstWizardPanel.modelSpot.getValueAt(i, 
> /* 642 */                             FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE)
> /* 643 */                           (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot
> /* 644 */                                 .getValueAt(i, (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboParamSpot.getSelectedIndex() + 3).toString())); 
> /* 645 */                       }  OptionWizardPanel.null.access$0(OptionWizardPanel.null.this).descriptiveStatisticsActionSpot();
> /*     */                     } 
> /* 647 */                     if ((OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboClassSpot.getSelectedIndex() == 1) {
> /* 648 */                       (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsSpot = new ArrayList<>();
> /* 649 */                       for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); i++) {
> /* 650 */                         if (FirstWizardPanel.modelSpot.getValueAt(i, 
> /* 651 */                             FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE)
> /* 652 */                           if (((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, 0)).getText() == "")
> /* 653 */                             (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot
> /* 654 */                                   .getValueAt(i, (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboParamSpot.getSelectedIndex() + 3).toString()));  
> /* 655 */                       }  OptionWizardPanel.null.access$0(OptionWizardPanel.null.this).descriptiveStatisticsActionSpot();
> /*     */                     } 
> /*     */                     
> /* 658 */                     if ((OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboClassSpot.getSelectedIndex() == 2) {
> /* 659 */                       (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsSpot = new ArrayList<>();
> /* 660 */                       for (int i = 0; i < FirstWizardPanel.modelSpot.getRowCount(); i++) {
> /* 661 */                         if (FirstWizardPanel.modelSpot.getValueAt(i, 
> /* 662 */                             FirstWizardPanel.modelSpot.getColumnCount() - 1) == Boolean.TRUE)
> /* 663 */                           if (((JLabel)FirstWizardPanel.modelSpot.getValueAt(i, 0))
> /* 664 */                             .getText() == (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboClassSpot.getSelectedItem().toString())
> /* 665 */                             (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsSpot.add(Double.valueOf(FirstWizardPanel.modelSpot
> /* 666 */                                   .getValueAt(i, (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboParamSpot.getSelectedIndex() + 3).toString()));  
> /* 667 */                       }  OptionWizardPanel.null.access$0(OptionWizardPanel.null.this).descriptiveStatisticsActionSpot();
> /*     */                     } 
> /*     */                   }
> /*     */                 });
> /*     */             
> /* 672 */             OptionWizardPanel.this.comboClassSpotThread.start();
> /*     */           }
> /*     */         });
> /*     */     
> /* 676 */     this.comboClassTrack.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 679 */             OptionWizardPanel.this.comboClassTrackThread = new Thread(new Runnable()
> /*     */                 {
> /*     */                   public void run() {
> /* 682 */                     if ((OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboClassTrack.getSelectedIndex() == 0) {
> /* 683 */                       (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsTrack = new ArrayList<>();
> /* 684 */                       for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); i++) {
> /* 685 */                         if (ChooserWizardPanel.modelTrack.getValueAt(i, 
> /* 686 */                             ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE)
> /* 687 */                           (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack
> /* 688 */                                 .getValueAt(i, (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboParamTrack.getSelectedIndex() + 3).toString())); 
> /* 689 */                       }  OptionWizardPanel.null.access$0(OptionWizardPanel.null.this).descriptiveStatisticsActionTrack();
> /*     */                     } 
> /* 691 */                     if ((OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboClassTrack.getSelectedIndex() == 1) {
> /* 692 */                       (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsTrack = new ArrayList<>();
> /* 693 */                       for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); i++) {
> /* 694 */                         if (ChooserWizardPanel.modelTrack.getValueAt(i, 
> /* 695 */                             ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE)
> /* 696 */                           if (((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, 0)).getText() == "")
> /* 697 */                             (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack
> /* 698 */                                   .getValueAt(i, (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboParamTrack.getSelectedIndex() + 3).toString()));  
> /* 699 */                       }  OptionWizardPanel.null.access$0(OptionWizardPanel.null.this).descriptiveStatisticsActionTrack();
> /*     */                     } 
> /*     */                     
> /* 702 */                     if ((OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboClassTrack.getSelectedIndex() == 2) {
> /* 703 */                       (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsTrack = new ArrayList<>();
> /* 704 */                       for (int i = 0; i < ChooserWizardPanel.modelTrack.getRowCount(); i++) {
> /* 705 */                         if (ChooserWizardPanel.modelTrack.getValueAt(i, 
> /* 706 */                             ChooserWizardPanel.modelTrack.getColumnCount() - 1) == Boolean.TRUE)
> /* 707 */                           if (((JLabel)ChooserWizardPanel.modelTrack.getValueAt(i, 0))
> /* 708 */                             .getText() == (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboClassTrack.getSelectedItem().toString())
> /* 709 */                             (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).dataToStatisticsTrack.add(Double.valueOf(ChooserWizardPanel.modelTrack
> /* 710 */                                   .getValueAt(i, (OptionWizardPanel.null.access$0(OptionWizardPanel.null.this)).comboParamTrack.getSelectedIndex() + 3).toString()));  
> /* 711 */                       }  OptionWizardPanel.null.access$0(OptionWizardPanel.null.this).descriptiveStatisticsActionTrack();
> /*     */                     } 
> /*     */                   }
> /*     */                 });
> /*     */ 
> /*     */             
> /* 717 */             OptionWizardPanel.this.comboClassTrackThread.start();
> /*     */           }
> /*     */         });
> /*     */   }
> /*     */   JComboBox<String> comboFeatureDomainTrack; JComboBox<String> comboFeatureRangeTrack; JComboBox<String> comboClassSpot; JComboBox<String> comboParamSpot; JComboBox<String> comboClassTrack; JComboBox<String> comboParamTrack; JComboBox<String> comboRegressionSpot; JComboBox<String> comboRegressionTrack; List<String> itemFiltersSpot; List<String> itemFiltersTrack; STScatterPlot scatterPlot; JButton refreshButtonSpot; JButton zoomInSpot; JButton zoomOutSpot; JButton refreshButtonTrack; JButton zoomInTrack; JButton zoomOutTrack; STScatterPlot sp2Spot; STScatterPlot sp2Track; ChartPanel scatterPlotSpot; ChartPanel scatterPlotTrack; static JPanel regressionPanelSpot; static JPanel regressionPanelTrack; List<Double> dataToStatisticsSpot; List<Double> dataToStatisticsTrack; DefaultTableModel modelSpot; DefaultTableModel modelTrack; Thread refreshSpotThread; Thread refreshTrackThread; Thread zoomInSpotThread; Thread zoomInTrackThread; Thread zoomOutSpotThread; Thread zoomOutTrackThread; Thread comboRegSpotThread; Thread comboRegTrackThread; Thread comboClassSpotThread;
> /*     */   Thread comboClassTrackThread;
> /*     */   
> /*     */   public void descriptiveStatisticsActionSpot() {
> /* 725 */     this.modelSpot.setValueAt(String.valueOf(
> /* 726 */           Math.round((new DescriptiveStatistics(
> /* 727 */               this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getMean() * 1000.0D) / 
> /* 728 */           1000.0D), 0, 0);
> /* 729 */     this.modelSpot.setValueAt(String.valueOf(Math.round((new DescriptiveStatistics(
> /* 730 */               this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getStandardDeviation() / (
> /* 731 */             new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()))
> /* 732 */             .getN() * 
> /* 733 */             1000.0D) / 1000.0D), 0, 1);
> /*     */     
> /* 735 */     this.modelSpot.setValueAt(String.valueOf(Math.round((
> /* 736 */             new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()))
> /* 737 */             .getPercentile(50.0D) * 1000.0D) / 
> /* 738 */           1000.0D), 0, 2);
> /* 739 */     this.modelSpot.setValueAt(String.valueOf(Math.round((
> /* 740 */             new DescriptiveStatistics(this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray()))
> /* 741 */             .getStandardDeviation() * 1000.0D) / 
> /* 742 */           1000.0D), 0, 3);
> /* 743 */     this.modelSpot.setValueAt(String.valueOf(
> /* 744 */           Math.round((new DescriptiveStatistics(
> /* 745 */               this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getVariance() * 1000.0D) / 
> /* 746 */           1000.0D), 0, 4);
> /* 747 */     this.modelSpot.setValueAt(String.valueOf(
> /* 748 */           Math.round((new DescriptiveStatistics(
> /* 749 */               this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getKurtosis() * 1000.0D) / 
> /* 750 */           1000.0D), 0, 5);
> /* 751 */     this.modelSpot.setValueAt(String.valueOf(
> /* 752 */           Math.round((new DescriptiveStatistics(
> /* 753 */               this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getSkewness() * 1000.0D) / 
> /* 754 */           1000.0D), 0, 6);
> /* 755 */     this.modelSpot.setValueAt(String.valueOf(
> /* 756 */           Math.round((new DescriptiveStatistics(
> /* 757 */               this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getMin() * 1000.0D) / 
> /* 758 */           1000.0D), 0, 7);
> /* 759 */     this.modelSpot.setValueAt(String.valueOf(
> /* 760 */           Math.round((new DescriptiveStatistics(
> /* 761 */               this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getMax() * 1000.0D) / 
> /* 762 */           1000.0D), 0, 8);
> /* 763 */     this.modelSpot.setValueAt(String.valueOf(
> /* 764 */           Math.round((new DescriptiveStatistics(
> /* 765 */               this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getSum() * 1000.0D) / 
> /* 766 */           1000.0D), 0, 9);
> /*     */     
> /* 768 */     this.modelSpot.setValueAt(String.valueOf(
> /* 769 */           Math.round((new DescriptiveStatistics(
> /* 770 */               this.dataToStatisticsSpot.stream().mapToDouble(Double::doubleValue).toArray())).getN() * 1000.0D) / 
> /* 771 */           1000.0D), 0, 10);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void descriptiveStatisticsActionTrack() {
> /* 777 */     this.modelTrack.setValueAt(String.valueOf(
> /* 778 */           Math.round((new DescriptiveStatistics(
> /* 779 */               this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getMean() * 1000.0D) / 
> /* 780 */           1000.0D), 0, 0);
> /* 781 */     this.modelTrack.setValueAt(String.valueOf(Math.round((new DescriptiveStatistics(
> /* 782 */               this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getStandardDeviation() / (
> /* 783 */             new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()))
> /* 784 */             .getN() * 
> /* 785 */             1000.0D) / 1000.0D), 0, 1);
> /*     */     
> /* 787 */     this.modelTrack.setValueAt(String.valueOf(Math.round((
> /* 788 */             new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()))
> /* 789 */             .getPercentile(50.0D) * 1000.0D) / 
> /* 790 */           1000.0D), 0, 2);
> /* 791 */     this.modelTrack.setValueAt(String.valueOf(Math.round((
> /* 792 */             new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()))
> /* 793 */             .getStandardDeviation() * 1000.0D) / 
> /* 794 */           1000.0D), 0, 3);
> /* 795 */     this.modelTrack.setValueAt(String.valueOf(Math.round((
> /* 796 */             new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()))
> /* 797 */             .getVariance() * 1000.0D) / 
> /* 798 */           1000.0D), 0, 4);
> /* 799 */     this.modelTrack.setValueAt(String.valueOf(Math.round((
> /* 800 */             new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()))
> /* 801 */             .getKurtosis() * 1000.0D) / 
> /* 802 */           1000.0D), 0, 5);
> /* 803 */     this.modelTrack.setValueAt(String.valueOf(Math.round((
> /* 804 */             new DescriptiveStatistics(this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray()))
> /* 805 */             .getSkewness() * 1000.0D) / 
> /* 806 */           1000.0D), 0, 6);
> /* 807 */     this.modelTrack.setValueAt(String.valueOf(
> /* 808 */           Math.round((new DescriptiveStatistics(
> /* 809 */               this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getMin() * 1000.0D) / 
> /* 810 */           1000.0D), 0, 7);
> /* 811 */     this.modelTrack.setValueAt(String.valueOf(
> /* 812 */           Math.round((new DescriptiveStatistics(
> /* 813 */               this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getMax() * 1000.0D) / 
> /* 814 */           1000.0D), 0, 8);
> /* 815 */     this.modelTrack.setValueAt(String.valueOf(
> /* 816 */           Math.round((new DescriptiveStatistics(
> /* 817 */               this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getSum() * 1000.0D) / 
> /* 818 */           1000.0D), 0, 9);
> /*     */     
> /* 820 */     this.modelTrack.setValueAt(String.valueOf(
> /* 821 */           Math.round((new DescriptiveStatistics(
> /* 822 */               this.dataToStatisticsTrack.stream().mapToDouble(Double::doubleValue).toArray())).getN() * 1000.0D) / 
> /* 823 */           1000.0D), 0, 10);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void refreshActionSpot() {
> /* 829 */     this.comboClassSpot.removeAllItems();
> /* 830 */     this.comboClassSpot.addItem("All items");
> /* 831 */     this.comboClassSpot.addItem("No Identified");
> /*     */     
> /* 833 */     if (ColorEditorSpot.modelC.getRowCount() > 0) {
> /* 834 */       for (int j = 0; j < ColorEditorSpot.modelC.getRowCount(); j++) {
> /* 835 */         this.comboClassSpot.addItem(((JLabel)ColorEditorSpot.modelC.getValueAt(j, 0)).getText());
> /*     */       }
> /*     */     }
> /* 838 */     int rowCount = FirstWizardPanel.tableSpot.getRowCount();
> /* 839 */     int columnCount = FirstWizardPanel.tableSpot.getColumnCount();
> /* 840 */     selectedIndexDomainSpot = this.comboFeatureDomainSpot.getSelectedIndex();
> /* 841 */     selectedIndexRangeSpot = this.comboFeatureRangeSpot.getSelectedIndex();
> /* 842 */     List<Double> valuesDomainSpot = new ArrayList<>();
> /* 843 */     List<Double> valuesRangeSpot = new ArrayList<>();
> /* 844 */     Object[][] dataSpot = new Object[rowCount][columnCount];
> /* 845 */     for (int i = 0; i < rowCount; i++) {
> /* 846 */       for (int j = 0; j < columnCount; j++) {
> /* 847 */         dataSpot[i][j] = FirstWizardPanel.tableSpot.getValueAt(i, j);
> /*     */       }
> /*     */       
> /* 850 */       valuesDomainSpot.add(Double.valueOf(Double.parseDouble(dataSpot[i][selectedIndexDomainSpot + 4].toString())));
> /* 851 */       valuesRangeSpot.add(Double.valueOf(Double.parseDouble(dataSpot[i][selectedIndexRangeSpot + 4].toString())));
> /*     */     } 
> /* 853 */     if (valuesDomainSpot.isEmpty() == Boolean.TRUE.booleanValue()) {
> /* 854 */       IJ.error("You should have your spot analysis done. Please go backwards.");
> /*     */     } else {
> /*     */       
> /* 857 */       this.maxDomainSpot = ((Double)Collections.<Double>max(valuesDomainSpot)).doubleValue();
> /* 858 */       this.maxRangeSpot = ((Double)Collections.<Double>max(valuesRangeSpot)).doubleValue();
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */       
> /* 864 */       List<Color> listColorSpot = new ArrayList<>();
> /* 865 */       for (int j = 0; j < FirstWizardPanel.modelSpot.getRowCount(); j++)
> /* 866 */         listColorSpot.add(((JLabel)FirstWizardPanel.modelSpot.getValueAt(j, 
> /* 867 */               FirstWizardPanel.tableSpot.convertColumnIndexToModel(1))).getBackground()); 
> /* 868 */       Color[] classColorSpot = new Color[listColorSpot.size()];
> /* 869 */       listColorSpot.toArray(classColorSpot);
> /* 870 */       if (this.comboRegressionSpot.getSelectedIndex() == 0)
> /* 871 */         this.sp2Spot.addScatterPlotSeriesLinear(this.comboFeatureDomainSpot.getSelectedItem().toString(), 
> /* 872 */             this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, 
> /* 873 */             this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot); 
> /* 874 */       if (this.comboRegressionSpot.getSelectedIndex() == 1)
> /* 875 */         this.sp2Spot.addScatterPlotSeriesPolynomial(this.comboFeatureDomainSpot.getSelectedItem().toString(), 
> /* 876 */             this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, 
> /* 877 */             this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot, ((Integer)this.filterOrderSpot.getValue()).intValue()); 
> /* 878 */       if (this.comboRegressionSpot.getSelectedIndex() == 2)
> /* 879 */         this.sp2Spot.addScatterPlotSeriesPower(this.comboFeatureDomainSpot.getSelectedItem().toString(), 
> /* 880 */             this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, 
> /* 881 */             this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot); 
> /* 882 */       if (this.comboRegressionSpot.getSelectedIndex() == 3)
> /* 883 */         this.sp2Spot.addScatterPlotSeriesLogarithmic(this.comboFeatureDomainSpot.getSelectedItem().toString(), 
> /* 884 */             this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, 
> /* 885 */             this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot); 
> /* 886 */       if (this.comboRegressionSpot.getSelectedIndex() == 4) {
> /* 887 */         this.sp2Spot.addScatterPlotSeriesExponential(this.comboFeatureDomainSpot.getSelectedItem().toString(), 
> /* 888 */             this.comboFeatureRangeSpot.getSelectedItem().toString(), valuesDomainSpot, valuesRangeSpot, 
> /* 889 */             this.markerRangeSpot, this.markerDomainSpot, dataSpot, classColorSpot);
> /*     */       }
> /*     */     } 
> /*     */   }
> /*     */   
> /*     */   public void refreshActionTrack() {
> /* 895 */     this.comboClassTrack.removeAllItems();
> /* 896 */     this.comboClassTrack.addItem("All items");
> /* 897 */     this.comboClassTrack.addItem("No Identified");
> /*     */     
> /* 899 */     if (ColorEditorTrack.modelC.getRowCount() > 0) {
> /* 900 */       for (int j = 0; j < ColorEditorTrack.modelC.getRowCount(); j++) {
> /* 901 */         this.comboClassTrack.addItem(((JLabel)ColorEditorTrack.modelC.getValueAt(j, 0)).getText());
> /*     */       }
> /*     */     }
> /* 904 */     int rowCount = ChooserWizardPanel.tableTrack.getRowCount();
> /* 905 */     int columnCount = ChooserWizardPanel.tableTrack.getColumnCount();
> /* 906 */     selectedIndexDomainTrack = this.comboFeatureDomainTrack.getSelectedIndex();
> /* 907 */     selectedIndexRangeTrack = this.comboFeatureRangeTrack.getSelectedIndex();
> /* 908 */     List<Double> valuesDomainTrack = new ArrayList<>();
> /* 909 */     List<Double> valuesRangeTrack = new ArrayList<>();
> /* 910 */     Object[][] dataTrack = new Object[rowCount][columnCount];
> /* 911 */     for (int i = 0; i < rowCount; i++) {
> /* 912 */       for (int j = 0; j < columnCount; j++) {
> /* 913 */         dataTrack[i][j] = ChooserWizardPanel.tableTrack.getValueAt(i, j);
> /*     */       }
> /*     */       
> /* 916 */       valuesDomainTrack.add(Double.valueOf(Double.parseDouble(dataTrack[i][selectedIndexDomainTrack + 4].toString())));
> /* 917 */       valuesRangeTrack.add(Double.valueOf(Double.parseDouble(dataTrack[i][selectedIndexRangeTrack + 4].toString())));
> /*     */     } 
> /* 919 */     if (valuesDomainTrack.isEmpty() == Boolean.TRUE.booleanValue()) {
> /* 920 */       IJ.error("You should have your track analysis done. Please go backwards.");
> /*     */     } else {
> /*     */       
> /* 923 */       this.maxDomainTrack = ((Double)Collections.<Double>max(valuesDomainTrack)).doubleValue();
> /* 924 */       this.maxRangeTrack = ((Double)Collections.<Double>max(valuesRangeTrack)).doubleValue();
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */       
> /* 930 */       List<Color> listColorTrack = new ArrayList<>();
> /* 931 */       for (int j = 0; j < ChooserWizardPanel.modelTrack.getRowCount(); j++)
> /* 932 */         listColorTrack.add(((JLabel)ChooserWizardPanel.modelTrack.getValueAt(j, 
> /* 933 */               ChooserWizardPanel.tableTrack.convertColumnIndexToModel(1))).getBackground()); 
> /* 934 */       Color[] classColorTrack = new Color[listColorTrack.size()];
> /* 935 */       listColorTrack.toArray(classColorTrack);
> /* 936 */       if (this.comboRegressionTrack.getSelectedIndex() == 0)
> /* 937 */         this.sp2Track.addScatterPlotSeriesLinear(this.comboFeatureDomainTrack.getSelectedItem().toString(), 
> /* 938 */             this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, 
> /* 939 */             this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack); 
> /* 940 */       if (this.comboRegressionTrack.getSelectedIndex() == 1)
> /* 941 */         this.sp2Track.addScatterPlotSeriesPolynomial(this.comboFeatureDomainTrack.getSelectedItem().toString(), 
> /* 942 */             this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, 
> /* 943 */             this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack, (
> /* 944 */             (Integer)this.filterOrderTrack.getValue()).intValue()); 
> /* 945 */       if (this.comboRegressionTrack.getSelectedIndex() == 2)
> /* 946 */         this.sp2Track.addScatterPlotSeriesPower(this.comboFeatureDomainTrack.getSelectedItem().toString(), 
> /* 947 */             this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, 
> /* 948 */             this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack); 
> /* 949 */       if (this.comboRegressionTrack.getSelectedIndex() == 3)
> /* 950 */         this.sp2Track.addScatterPlotSeriesLogarithmic(this.comboFeatureDomainTrack.getSelectedItem().toString(), 
> /* 951 */             this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, 
> /* 952 */             this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack); 
> /* 953 */       if (this.comboRegressionTrack.getSelectedIndex() == 4)
> /* 954 */         this.sp2Track.addScatterPlotSeriesExponential(this.comboFeatureDomainTrack.getSelectedItem().toString(), 
> /* 955 */             this.comboFeatureRangeTrack.getSelectedItem().toString(), valuesDomainTrack, valuesRangeTrack, 
> /* 956 */             this.markerRangeTrack, this.markerDomainTrack, dataTrack, classColorTrack); 
> /*     */     } 
> /*     */   }
> /*     */   
> /*     */   public void update1() {
> /* 961 */     setNextButtonEnabled(true);
> /* 962 */     setFinishButtonEnabled(true);
> /* 963 */     setBackButtonEnabled(true);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void next() {
> /* 968 */     setNextButtonEnabled(false);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void back() {
> /* 973 */     switchPanel(1);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void finish() {
> /* 978 */     switchPanel(2);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/OptionWizardPanel.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/PhotobleachingSpotPlot.java jd-gui/PhotobleachingSpotPlot.java
1,148c1,226
< import fiji.plugin.trackmate.gui.displaysettings.Colormap;
< import fiji.plugin.trackmate.visualization.PerTrackFeatureColorGenerator;
< import ij.ImagePlus;
< import ij.gui.OvalRoi;
< import ij.measure.ResultsTable;
< import java.awt.Color;
< import java.awt.Point;
< import java.awt.event.KeyEvent;
< import java.awt.event.MouseEvent;
< import java.awt.geom.Rectangle2D;
< import java.awt.geom.Rectangle2D.Float;
< import java.io.File;
< import java.io.IOException;
< import java.util.ArrayList;
< import java.util.List;
< import java.util.Set;
< import javax.swing.JLabel;
< import javax.swing.JPanel;
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.ChartUtils;
< import org.jfree.chart.JFreeChart;
< import org.jfree.chart.plot.PlotOrientation;
< import org.jfree.chart.plot.XYPlot;
< import org.jfree.chart.renderer.xy.XYItemRenderer;
< import org.jfree.data.xy.XYSeries;
< import org.jfree.data.xy.XYSeriesCollection;
< 
< public class PhotobleachingSpotPlot {
<    JFreeChart chart;
<    JPanel chartpanel = new JPanel();
<    ResultsTable rt;
<    Rectangle2D chartRectangleInSequence = new Float(250.0F, 20.0F, 490.0F, 240.0F);
<    JLabel outLabel = new JLabel();
< 
<    public PhotobleachingSpotPlot() {
<       this.chartpanel.add(new ChartPanel(this.chart, 500, 300, 500, 300, 500, 300, false, false, true, true, true, true));
<    }
< 
<    public void Compute() {
<       Set<Integer> trackIDs = SPTBatch_.model.getTrackModel().trackIDs(true);
<       List<Integer> nOfTracks = new ArrayList();
<       if (SPTBatch_.checkboxSubBg.isSelected()) {
<          int r;
<          for(r = 0; r < SPTBatch_.trackJTable.getRowCount(); ++r) {
<             nOfTracks.add(Integer.valueOf(SPTBatch_.trackJTable.getValueAt(r, 2).toString()));
<          }
< 
<          for(r = 0; r < nOfTracks.size(); ++r) {
<             XYSeriesCollection xyDataset = new XYSeriesCollection();
<             XYSeries seriesTrack = null;
<             XYSeries seriesBg = null;
<             List<Double> perTrack = new ArrayList();
<             List<Double> perFrame = new ArrayList();
<             List<Double> perTrackDef = new ArrayList();
<             List<Double> perXPositionDef = new ArrayList();
<             List<Double> perYPositionDef = new ArrayList();
<             List<Double> perFrameDef = new ArrayList();
< 
<             int i;
<             for(i = 0; i < SPTBatch_.tableSpot.getRowCount(); ++i) {
<                if (Integer.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 2).toString()).equals(nOfTracks.get(r)) == Boolean.TRUE) {
<                   perTrack.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 12).toString()));
<                   perFrame.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 8).toString()));
<                   perTrackDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 12).toString()));
<                   perFrameDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 8).toString()));
<                   perXPositionDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 4).toString()));
<                   perYPositionDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(i, 5).toString()));
<                }
<             }
< 
<             this.rt = new ResultsTable();
<             seriesTrack = new XYSeries("Spot Mean Raw Intensity Track ");
<             seriesBg = new XYSeries("Bg Intensity");
< 
<             for(i = 0; i < perTrackDef.size(); ++i) {
<                seriesTrack.add((Number)perFrameDef.get(i), (Number)perTrackDef.get(i));
<                this.rt.setValue("Spot Mean Raw Intensity Track ", i, (Double)perTrackDef.get(i));
<             }
< 
<             for(i = 0; i < SPTBatch_.imps.getStack().getSize(); ++i) {
<                seriesBg.add((double)i, SPTBatch_.slicesIntensitySpot[i]);
<                this.rt.setValue("Bg Intensity", i, Double.valueOf(SPTBatch_.slicesIntensitySpot[i]));
<             }
< 
<             if (((Double)perFrameDef.get(perFrameDef.size() - 1)).intValue() != SPTBatch_.imps.getStack().getSize() - 1) {
<                ImagePlus[] slices = SPTBatch_.stack2images(SPTBatch_.imps.duplicate());
<                OvalRoi ovalRoi = new OvalRoi((Double)perXPositionDef.get(perXPositionDef.size() - 1), (Double)perXPositionDef.get(perXPositionDef.size() - 1), Double.valueOf(SPTBatch_.RADIUS) / SPTBatch_.imps.getCalibration().pixelWidth, Double.valueOf(SPTBatch_.RADIUS) / SPTBatch_.imps.getCalibration().pixelWidth);
< 
<                for(int i = ((Double)perFrameDef.get(perFrameDef.size() - 1)).intValue(); i < SPTBatch_.imps.getStack().getSize(); ++i) {
<                   slices[i].setRoi(ovalRoi);
<                   seriesTrack.add((double)i, slices[i].getStatistics().mean);
<                   this.rt.setValue("Spot Mean Raw Intensity Track ", i, slices[i].getStatistics().mean);
<                }
<             }
< 
<             xyDataset.addSeries(seriesTrack);
<             xyDataset.addSeries(seriesBg);
<             this.chart = ChartFactory.createXYLineChart("PhotoBleaching step for Track " + nOfTracks.get(r), "Frame", "Intensity", xyDataset, PlotOrientation.VERTICAL, true, true, false);
<             this.chartpanel.removeAll();
<             if (this.chart != null) {
<                XYItemRenderer renderer = ((XYPlot)this.chart.getPlot()).getRenderer();
<                PerTrackFeatureColorGenerator tcg = new PerTrackFeatureColorGenerator(SPTBatch_.model, "TRACK_INDEX", (Color)null, (Color)null, Colormap.Turbo, 0.0D, 1.0D);
<                XYPlot plot = this.chart.getXYPlot();
<                plot.setDataset(0, xyDataset);
<                plot.setRenderer(0, renderer);
<                plot.getRendererForDataset(plot.getDataset(0)).setSeriesPaint(0, tcg.colorOf((Integer)nOfTracks.get(r)));
<             }
< 
<             XYPlot plot = (XYPlot)this.chart.getPlot();
<             plot.setBackgroundPaint(Color.white);
<             plot.setDomainGridlinesVisible(true);
<             plot.setRangeGridlinesVisible(true);
<             plot.setDomainMinorGridlinePaint(Color.GRAY);
<             plot.setDomainGridlinePaint(Color.DARK_GRAY);
<             plot.setRangeMinorGridlinePaint(Color.GRAY);
<             plot.setRangeGridlinePaint(Color.DARK_GRAY);
<             this.chartpanel.add(new ChartPanel(this.chart));
<             this.chartpanel.updateUI();
< 
<             try {
<                ChartUtils.saveChartAsPNG(new File(SPTBatch_.directPBS.getAbsolutePath() + File.separator + SPTBatch_.imgTitle + "_" + ((Integer)nOfTracks.get(r)).toString() + ".png"), this.chart, 2000, 400);
<             } catch (IOException var17) {
<                var17.printStackTrace();
<             }
< 
<             try {
<                this.rt.saveAs(SPTBatch_.directPBS.getAbsolutePath() + File.separator + SPTBatch_.imgTitle + "_" + ((Integer)SPTBatch_.nOfTracks.get(r)).toString() + ".csv");
<             } catch (IOException var16) {
<                var16.printStackTrace();
<             }
<          }
<       }
< 
<    }
< 
<    public void keyPressed(Point p, KeyEvent e) {
<    }
< 
<    public void mouseClick(Point p, MouseEvent e) {
<    }
< 
<    public void mouseDrag(Point p, MouseEvent e) {
<    }
< 
<    public void mouseMove(Point p, MouseEvent e) {
<    }
< }
---
> /*     */ import fiji.plugin.trackmate.gui.displaysettings.Colormap;
> /*     */ import fiji.plugin.trackmate.visualization.PerTrackFeatureColorGenerator;
> /*     */ import ij.ImagePlus;
> /*     */ import ij.gui.OvalRoi;
> /*     */ import ij.gui.Roi;
> /*     */ import ij.measure.ResultsTable;
> /*     */ import java.awt.Color;
> /*     */ import java.awt.Component;
> /*     */ import java.awt.Point;
> /*     */ import java.awt.event.KeyEvent;
> /*     */ import java.awt.event.MouseEvent;
> /*     */ import java.awt.geom.Rectangle2D;
> /*     */ import java.io.File;
> /*     */ import java.io.IOException;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.List;
> /*     */ import java.util.Set;
> /*     */ import javax.swing.JLabel;
> /*     */ import javax.swing.JPanel;
> /*     */ import org.jfree.chart.ChartFactory;
> /*     */ import org.jfree.chart.ChartPanel;
> /*     */ import org.jfree.chart.ChartUtils;
> /*     */ import org.jfree.chart.JFreeChart;
> /*     */ import org.jfree.chart.plot.PlotOrientation;
> /*     */ import org.jfree.chart.plot.XYPlot;
> /*     */ import org.jfree.chart.renderer.xy.XYItemRenderer;
> /*     */ import org.jfree.data.xy.XYDataset;
> /*     */ import org.jfree.data.xy.XYSeries;
> /*     */ import org.jfree.data.xy.XYSeriesCollection;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class PhotobleachingSpotPlot
> /*     */ {
> /*     */   JFreeChart chart;
> /*  54 */   JPanel chartpanel = new JPanel();
> /*     */ 
> /*     */   
> /*     */   ResultsTable rt;
> /*     */ 
> /*     */   
> /*     */   Rectangle2D chartRectangleInSequence;
> /*     */   
> /*     */   JLabel outLabel;
> /*     */ 
> /*     */   
> /*     */   public void Compute() {
> /*  66 */     Set<Integer> trackIDs = SPTBatch_.model.getTrackModel().trackIDs(true);
> /*  67 */     List<Integer> nOfTracks = new ArrayList<>();
> /*  68 */     if (SPTBatch_.checkboxSubBg.isSelected()) {
> /*     */       
> /*  70 */       for (int t = 0; t < SPTBatch_.trackJTable.getRowCount(); t++)
> /*  71 */         nOfTracks.add(Integer.valueOf(SPTBatch_.trackJTable.getValueAt(t, 2).toString())); 
> /*  72 */       for (int r = 0; r < nOfTracks.size(); r++) {
> /*  73 */         XYSeriesCollection xyDataset = new XYSeriesCollection();
> /*  74 */         XYSeries seriesTrack = null;
> /*  75 */         XYSeries seriesBg = null;
> /*  76 */         List<Double> perTrack = new ArrayList<>();
> /*  77 */         List<Double> perFrame = new ArrayList<>();
> /*  78 */         List<Double> perTrackDef = new ArrayList<>();
> /*  79 */         List<Double> perXPositionDef = new ArrayList<>();
> /*  80 */         List<Double> perYPositionDef = new ArrayList<>();
> /*  81 */         List<Double> perFrameDef = new ArrayList<>();
> /*     */         
> /*  83 */         for (int j = 0; j < SPTBatch_.tableSpot.getRowCount(); j++) {
> /*  84 */           if (Integer.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(j, 2).toString())
> /*  85 */             .equals(nOfTracks.get(r)) == Boolean.TRUE.booleanValue()) {
> /*  86 */             perTrack.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(j, 12).toString()));
> /*  87 */             perFrame.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(j, 8).toString()));
> /*     */             
> /*  89 */             perTrackDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(j, 12).toString()));
> /*  90 */             perFrameDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(j, 8).toString()));
> /*  91 */             perXPositionDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(j, 4).toString()));
> /*  92 */             perYPositionDef.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(j, 5).toString()));
> /*     */           } 
> /*     */         } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */         
> /* 105 */         this.rt = new ResultsTable();
> /*     */ 
> /*     */ 
> /*     */         
> /* 109 */         seriesTrack = new XYSeries("Spot Mean Raw Intensity Track ");
> /* 110 */         seriesBg = new XYSeries("Bg Intensity");
> /*     */ 
> /*     */         
> /*     */         int i;
> /*     */ 
> /*     */         
> /* 116 */         for (i = 0; i < perTrackDef.size(); i++) {
> /* 117 */           seriesTrack.add(perFrameDef.get(i), perTrackDef.get(i));
> /* 118 */           this.rt.setValue("Spot Mean Raw Intensity Track ", i, ((Double)perTrackDef.get(i)).doubleValue());
> /*     */         } 
> /*     */         
> /* 121 */         for (i = 0; i < SPTBatch_.imps.getStack().getSize(); i++) {
> /* 122 */           seriesBg.add(i, Double.valueOf(SPTBatch_.slicesIntensitySpot[i]));
> /* 123 */           this.rt.setValue("Bg Intensity", i, Double.valueOf(SPTBatch_.slicesIntensitySpot[i]).doubleValue());
> /*     */         } 
> /*     */         
> /* 126 */         if (((Double)perFrameDef.get(perFrameDef.size() - 1)).intValue() != SPTBatch_.imps.getStack().getSize() - 1) {
> /* 127 */           ImagePlus[] slices = SPTBatch_.stack2images(SPTBatch_.imps.duplicate());
> /* 128 */           OvalRoi ovalRoi = new OvalRoi(((Double)perXPositionDef.get(perXPositionDef.size() - 1)).doubleValue(), (
> /* 129 */               (Double)perXPositionDef.get(perXPositionDef.size() - 1)).doubleValue(), 
> /* 130 */               Double.valueOf(SPTBatch_.RADIUS).doubleValue() / 
> /* 131 */               (SPTBatch_.imps.getCalibration()).pixelWidth, 
> /* 132 */               Double.valueOf(SPTBatch_.RADIUS).doubleValue() / 
> /* 133 */               (SPTBatch_.imps.getCalibration()).pixelWidth);
> /*     */           
> /* 135 */           for (int k = ((Double)perFrameDef.get(perFrameDef.size() - 1)).intValue(); k < SPTBatch_.imps.getStack()
> /* 136 */             .getSize(); k++) {
> /* 137 */             slices[k].setRoi((Roi)ovalRoi);
> /* 138 */             seriesTrack.add(k, (slices[k].getStatistics()).mean);
> /* 139 */             this.rt.setValue("Spot Mean Raw Intensity Track ", k, (slices[k].getStatistics()).mean);
> /*     */           } 
> /*     */         } 
> /*     */ 
> /*     */         
> /* 144 */         xyDataset.addSeries(seriesTrack);
> /* 145 */         xyDataset.addSeries(seriesBg);
> /*     */         
> /* 147 */         this.chart = ChartFactory.createXYLineChart("PhotoBleaching step for Track " + nOfTracks.get(r), 
> /*     */             
> /* 149 */             "Frame", 
> /* 150 */             "Intensity", 
> /* 151 */             (XYDataset)xyDataset, 
> /* 152 */             PlotOrientation.VERTICAL, true, 
> /* 153 */             true, 
> /* 154 */             false);
> /*     */ 
> /*     */         
> /* 157 */         this.chartpanel.removeAll();
> /*     */         
> /* 159 */         if (this.chart != null) {
> /*     */           
> /* 161 */           XYItemRenderer renderer = ((XYPlot)this.chart.getPlot()).getRenderer();
> /*     */           
> /* 163 */           PerTrackFeatureColorGenerator tcg = new PerTrackFeatureColorGenerator(SPTBatch_.model, 
> /* 164 */               "TRACK_INDEX", null, null, Colormap.Turbo, 0.0D, 1.0D);
> /* 165 */           XYPlot xYPlot = this.chart.getXYPlot();
> /*     */ 
> /*     */           
> /* 168 */           xYPlot.setDataset(0, (XYDataset)xyDataset);
> /* 169 */           xYPlot.setRenderer(0, renderer);
> /* 170 */           xYPlot.getRendererForDataset(xYPlot.getDataset(0)).setSeriesPaint(0, tcg.colorOf(nOfTracks.get(r)));
> /*     */         } 
> /*     */         
> /* 173 */         XYPlot plot = (XYPlot)this.chart.getPlot();
> /* 174 */         plot.setBackgroundPaint(Color.white);
> /* 175 */         plot.setDomainGridlinesVisible(true);
> /* 176 */         plot.setRangeGridlinesVisible(true);
> /* 177 */         plot.setDomainMinorGridlinePaint(Color.GRAY);
> /* 178 */         plot.setDomainGridlinePaint(Color.DARK_GRAY);
> /* 179 */         plot.setRangeMinorGridlinePaint(Color.GRAY);
> /* 180 */         plot.setRangeGridlinePaint(Color.DARK_GRAY);
> /* 181 */         this.chartpanel.add((Component)new ChartPanel(this.chart));
> /*     */         
> /* 183 */         this.chartpanel.updateUI();
> /*     */         try {
> /* 185 */           ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directPBS.getAbsolutePath()) + File.separator + 
> /* 186 */                 SPTBatch_.imgTitle + "_" + ((Integer)nOfTracks.get(r)).toString() + ".png"), this.chart, 2000, 400);
> /* 187 */         } catch (IOException e) {
> /*     */           
> /* 189 */           e.printStackTrace();
> /*     */         } 
> /*     */         try {
> /* 192 */           this.rt.saveAs(String.valueOf(SPTBatch_.directPBS.getAbsolutePath()) + File.separator + SPTBatch_.imgTitle + "_" + (
> /* 193 */               (Integer)SPTBatch_.nOfTracks.get(r)).toString() + ".csv");
> /* 194 */         } catch (IOException e) {
> /*     */           
> /* 196 */           e.printStackTrace();
> /*     */         } 
> /*     */       } 
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public PhotobleachingSpotPlot() {
> /* 207 */     this.chartRectangleInSequence = new Rectangle2D.Float(250.0F, 20.0F, 490.0F, 240.0F);
> /*     */     
> /* 209 */     this.outLabel = new JLabel();
> /*     */     this.chartpanel.add((Component)new ChartPanel(this.chart, 500, 300, 500, 300, 500, 300, false, false, true, true, true, true));
> /*     */   }
> /*     */   
> /*     */   public void keyPressed(Point p, KeyEvent e) {}
> /*     */   
> /*     */   public void mouseClick(Point p, MouseEvent e) {}
> /*     */   
> /*     */   public void mouseDrag(Point p, MouseEvent e) {}
> /*     */   
> /*     */   public void mouseMove(Point p, MouseEvent e) {}
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/PhotobleachingSpotPlot.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in TrackAnalyzer_/plugins: chemotaxis_tool.jar
Only in jd-gui/plugins: chemotaxis_tool.jar.src.zip
Only in jd-gui/plugins: commons-lang3-3.12.0.jar.src.zip
Only in jd-gui/plugins: commons-math3-3.6.1.jar.src.zip
Only in jd-gui/plugins: commons-math3-3.6.1-javadoc.jar.src.zip
Only in jd-gui/plugins: commons-math3-3.6.1-sources.jar.src.zip
Only in TrackAnalyzer_/plugins: commons-math3-3.6.1-tools.jar
Only in jd-gui/plugins: commons-math3-3.6.1-tools.jar.src.zip
Only in TrackAnalyzer_/plugins: DetectionResult.jar
Only in jd-gui/plugins: DetectionResult.jar.src.zip
Only in jd-gui/plugins: edu_mines_jtk.jar.src.zip
Only in TrackAnalyzer_/plugins: hamcrest-core-1.3.jar
Only in jd-gui/plugins: hamcrest-core-1.3.jar.src.zip
Only in jd-gui/plugins: ij-1.53c.jar.src.zip
Only in jd-gui/plugins: ij_trajectory_classifier-0.8.2.jar.src.zip
Only in jd-gui/plugins: imglib2-3.2.1.jar.src.zip
Only in jd-gui/plugins: imglib2-5.12.0.jar.src.zip
Only in jd-gui/plugins: imglib2-algorithm-0.6.2.jar.src.zip
Only in jd-gui/plugins: jacorb-3.9.jar.src.zip
Only in jd-gui/plugins: jacorb-omgapi-3.9.jar.src.zip
Only in jd-gui/plugins: javacpp-1.5.7.jar.src.zip
Only in jd-gui/plugins: jcommon-1.0.23.jar.src.zip
Only in jd-gui/plugins: jdom2-2.0.5.jar.src.zip
Only in jd-gui/plugins: jfreechart-1.0.19-demo.jar.src.zip
Only in jd-gui/plugins: jfreechart-1.5.0.jar.src.zip
Only in TrackAnalyzer_/plugins: jfreesvg-2.0.jar
Only in jd-gui/plugins: jfreesvg-2.0.jar.src.zip
Only in jd-gui/plugins: jgrapht.jar.src.zip
Only in jd-gui/plugins: junit-4.11.jar.src.zip
Only in TrackAnalyzer_/plugins: JWizardComponent.jar
Only in jd-gui/plugins: JWizardComponent.jar.src.zip
Only in jd-gui/plugins: loci_tools.jar.src.zip
Only in jd-gui/plugins: log4j-1.2.13.jar.src.zip
Only in TrackAnalyzer_/plugins: logkit-1.0.1.jar
Only in jd-gui/plugins: logkit-1.0.1.jar.src.zip
Only in jd-gui/plugins: MorphoLibJ_-1.4.2.1.jar.src.zip
Only in jd-gui/plugins: openblas-0.3.19-1.5.7.jar.src.zip
Only in jd-gui/plugins: opencsv-4.1.jar.src.zip
Only in jd-gui/plugins: orsoncharts-1.4-eval-nofx.jar.src.zip
Only in TrackAnalyzer_/plugins: orsonpdf-1.6-eval.jar
Only in jd-gui/plugins: orsonpdf-1.6-eval.jar.src.zip
Only in jd-gui/plugins: poi-3.13.jar.src.zip
Only in jd-gui/plugins: poi-ooxml-3.13.jar.src.zip
Only in jd-gui/plugins: poi-ooxml-schemas-3.13.jar.src.zip
Only in jd-gui/plugins/renjin: datasets-0.9.2724.jar.src.zip
Only in jd-gui/plugins/renjin: gcc-bridge-compiler-0.9.2724.jar.src.zip
Only in jd-gui/plugins/renjin: gcc-runtime-0.9.2724.jar.src.zip
Only in jd-gui/plugins/renjin: graphics-0.9.2724.jar.src.zip
Only in jd-gui/plugins/renjin: grDevices-0.9.2724.jar.src.zip
Only in jd-gui/plugins/renjin: grid-0.9.2724.jar.src.zip
Only in jd-gui/plugins/renjin: methods-0.9.2724.jar.src.zip
Only in jd-gui/plugins/renjin: plyr-1.8.3-renjin-10.jar.src.zip
Only in jd-gui/plugins/renjin: randomForest-4.6-12-b29.jar.src.zip
Only in TrackAnalyzer_/plugins/renjin: Rcpp-0.12.5-renjin-7.jar
Only in jd-gui/plugins/renjin: Rcpp-0.12.5-renjin-7.jar.src.zip
Only in jd-gui/plugins/renjin: renjin-core-0.9.2724.jar.src.zip
Only in TrackAnalyzer_/plugins/renjin: renjin-gnur-compiler-0.9.2724.jar
Only in jd-gui/plugins/renjin: renjin-gnur-compiler-0.9.2724.jar.src.zip
Only in jd-gui/plugins/renjin: renjin-gnur-runtime-0.9.2724.jar.src.zip
Only in TrackAnalyzer_/plugins/renjin: renjin-script-engine-0.9.2723.jar
Only in jd-gui/plugins/renjin: renjin-script-engine-0.9.2723.jar.src.zip
Only in jd-gui/plugins/renjin: stats-0.9.2724.jar.src.zip
Only in jd-gui/plugins/renjin: utils-0.9.2724.jar.src.zip
Only in TrackAnalyzer_/plugins: RonnyTrackMate_-0.0.6-SNAPSHOT.jar
Only in jd-gui/plugins: RonnyTrackMate_-0.0.6-SNAPSHOT.jar.src.zip
Only in TrackAnalyzer_/plugins: servlet.jar
Only in jd-gui/plugins: servlet.jar.src.zip
Only in TrackAnalyzer_/plugins: slf4j-api-1.7.14.jar
Only in jd-gui/plugins: slf4j-api-1.7.14.jar.src.zip
Only in jd-gui/plugins: SLTDisplayer_.jar.src.zip
Only in jd-gui/plugins: smile-math-2.5.3.jar.src.zip
Only in TrackAnalyzer_/plugins: swtgraphics2d.jar
Only in jd-gui/plugins: swtgraphics2d.jar.src.zip
Only in jd-gui/plugins: TrackMate-7.5.1.jar.src.zip
Only in TrackAnalyzer_/plugins: TrackMate_extras-0.0.4.jar
Only in jd-gui/plugins: TrackMate_extras-0.0.4.jar.src.zip
Only in TrackAnalyzer_/plugins: TrackProcessorMSD.jar
Only in jd-gui/plugins: TrackProcessorMSD.jar.src.zip
Only in jd-gui/plugins: traj-0.5.6.jar.src.zip
Only in jd-gui/plugins: vecmath-1.5.1.jar.src.zip
Only in jd-gui/plugins: vecmath.jar.src.zip
Only in jd-gui: ProcessTrackMateXml$1$1.java
Only in jd-gui: ProcessTrackMateXml$1$2.java
Only in jd-gui: ProcessTrackMateXml$1.java
diff -r TrackAnalyzer_/ProcessTrackMateXml.java jd-gui/ProcessTrackMateXml.java
1,991c1,1109
< import fiji.plugin.trackmate.Dimension;
< import fiji.plugin.trackmate.FeatureModel;
< import fiji.plugin.trackmate.Model;
< import fiji.plugin.trackmate.SelectionModel;
< import fiji.plugin.trackmate.Settings;
< import fiji.plugin.trackmate.Spot;
< import fiji.plugin.trackmate.SpotCollection;
< import fiji.plugin.trackmate.TrackMate;
< import fiji.plugin.trackmate.detection.DogDetectorFactory;
< import fiji.plugin.trackmate.detection.LogDetectorFactory;
< import fiji.plugin.trackmate.detection.ManualDetectorFactory;
< import fiji.plugin.trackmate.features.FeatureFilter;
< import fiji.plugin.trackmate.features.FeatureUtils;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettingsIO;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings.TrackDisplayMode;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings.TrackMateObject;
< import fiji.plugin.trackmate.io.TmXmlReader;
< import fiji.plugin.trackmate.tracking.LAPUtils;
< import fiji.plugin.trackmate.tracking.ManualTrackerFactory;
< import fiji.plugin.trackmate.tracking.kalman.KalmanTrackerFactory;
< import fiji.plugin.trackmate.tracking.sparselap.SimpleSparseLAPTrackerFactory;
< import fiji.plugin.trackmate.tracking.sparselap.SparseLAPTrackerFactory;
< import fiji.plugin.trackmate.util.TMUtils;
< import fiji.plugin.trackmate.visualization.FeatureColorGenerator;
< import fiji.plugin.trackmate.visualization.hyperstack.HyperStackDisplayer;
< import fiji.plugin.trackmate.visualization.table.TablePanel;
< import ij.ImagePlus;
< import ij.ImageStack;
< import ij.WindowManager;
< import ij.measure.Calibration;
< import ij.measure.ResultsTable;
< import ij.process.ColorProcessor;
< import java.awt.Color;
< import java.awt.Rectangle;
< import java.awt.event.MouseAdapter;
< import java.awt.event.MouseEvent;
< import java.awt.image.BufferedImage;
< import java.io.File;
< import java.io.IOException;
< import java.util.ArrayList;
< import java.util.Collection;
< import java.util.Collections;
< import java.util.HashMap;
< import java.util.HashSet;
< import java.util.Iterator;
< import java.util.List;
< import java.util.Map;
< import java.util.Set;
< import java.util.function.BiConsumer;
< import java.util.function.BiFunction;
< import java.util.function.Function;
< import java.util.function.Supplier;
< import java.util.stream.Collectors;
< import java.util.stream.Stream;
< import javax.swing.ListSelectionModel;
< import javax.xml.parsers.DocumentBuilder;
< import javax.xml.parsers.DocumentBuilderFactory;
< import javax.xml.parsers.ParserConfigurationException;
< import javax.xml.xpath.XPath;
< import javax.xml.xpath.XPathConstants;
< import javax.xml.xpath.XPathExpression;
< import javax.xml.xpath.XPathExpressionException;
< import javax.xml.xpath.XPathFactory;
< import org.jgrapht.graph.DefaultWeightedEdge;
< import org.w3c.dom.Document;
< import org.w3c.dom.Node;
< import org.w3c.dom.NodeList;
< import org.xml.sax.SAXException;
< 
< public class ProcessTrackMateXml {
<    Thread mainProcess;
<    String zstart;
<    String zend;
<    String ystart;
<    String yend;
<    String xstart;
<    String xend;
<    String tstart;
<    String tend;
<    String RADIUS;
<    String THRESHOLD;
<    String TARGET_CHANNEL;
<    String DO_SUBPIXEL_LOCALIZATION;
<    String DO_MEDIAN_FILTERING;
<    String DETECTOR_NAME;
<    String NSPLIT;
<    String DOWNSAMPLE_FACTOR;
<    String initialSpotFilter;
<    String TRACKER_NAME;
<    String CUTOFF_PERCENTILE;
<    String ALTERNATIVE_LINKING_COST_FACTOR;
<    String LINKING_MAX_DISTANCE;
<    String MAX_FRAME_GAP;
<    String MAX_DISTANCE;
<    String ALLOW_GAP_CLOSING;
<    String SPLITTING_MAX_DISTANCE;
<    String ALLOW_TRACK_SPLITTING;
<    String MERGING_MAX_DISTANCE;
<    String ALLOW_TRACK_MERGING;
<    String BLOCKING_VALUE;
<    static Model model;
<    static Settings settings;
<    static SelectionModel selectionModel;
<    static TrackMate trackmate;
<    SpotCollection totalSpots;
<    static HyperStackDisplayer displayer;
<    ImagePlus impAnal;
<    ImagePlus[] imps;
<    static boolean tracksVisible;
<    static boolean spotsVisible;
<    static String[][] dataSpot;
<    static String[][] dataTrack;
<    static String[] columnHeadersSpot;
<    static String[] columnHeadersTrack;
<    static DisplaySettings ds;
<    public static final String NAME = "Export statistics to tables";
<    public static final String KEY = "EXPORT_STATS_TO_IJ";
<    public static final String INFO_TEXT = "<html>Compute and export all statistics to 3 ImageJ results table. Statistisc are separated in features computed for: <ol> \t<li> spots in filtered tracks; \t<li> links between those spots; \t<li> filtered tracks. </ol> For tracks and links, they are recalculated prior to exporting. Note that spots and links that are not in a filtered tracks are not part of this export.</html>";
<    private static final String SPOT_TABLE_NAME = "Spots in tracks statistics";
<    private static final String EDGE_TABLE_NAME = "Links in tracks statistics";
<    private static final String TRACK_TABLE_NAME = "Track statistics";
<    private static final String ID_COLUMN = "ID";
<    private static final String TRACK_ID_COLUMN = "TRACK_ID";
<    private ResultsTable spotTable;
<    private ResultsTable edgeTable;
<    private ResultsTable trackTable;
<    public static final String KEYLINEAR = "Linear track analysis";
<    public static final String TRACK_TOTAL_DISTANCE_TRAVELED = "TOTAL_DISTANCE_TRAVELED";
<    public static final String TRACK_MAX_DISTANCE_TRAVELED = "MAX_DISTANCE_TRAVELED";
<    public static final String TRACK_CONFINMENT_RATIO = "CONFINMENT_RATIO";
<    public static final String TRACK_MEAN_STRAIGHT_LINE_SPEED = "MEAN_STRAIGHT_LINE_SPEED";
<    public static final String TRACK_LINEARITY_OF_FORWARD_PROGRESSION = "LINEARITY_OF_FORWARD_PROGRESSION";
<    public static final String TOTAL_ABSOLUTE_ANGLE_XY = "TOTAL_ABSOLUTE_ANGLE_XY";
<    public static final String TOTAL_ABSOLUTE_ANGLE_YZ = "TOTAL_ABSOLUTE_ANGLE_YZ";
<    public static final String TOTAL_ABSOLUTE_ANGLE_ZX = "TOTAL_ABSOLUTE_ANGLE_ZX";
<    public static final List<String> FEATURES = new ArrayList(9);
<    public static final Map<String, String> FEATURE_NAMES = new HashMap(9);
<    public static final Map<String, String> FEATURE_SHORT_NAMES = new HashMap(9);
<    public static final Map<String, Dimension> FEATURE_DIMENSIONS = new HashMap(9);
<    public static final Map<String, Boolean> IS_INT = new HashMap(9);
< 
<    public ProcessTrackMateXml() {
<       this.imps = FirstWizardPanel.imps;
<    }
< 
<    public void processTrackMateXml() {
<       this.mainProcess = new Thread(new Runnable() {
<          public void run() {
<             File fileXML = new File(TrackAnalyzer_.xmlPath);
<             List<ImagePlus> impAnalClose = new ArrayList();
<             int[] IDs = WindowManager.getIDList();
<             int i;
<             if (IDs != null) {
<                for(i = 0; i < IDs.length; ++i) {
<                   impAnalClose.add(WindowManager.getImage(IDs[i]));
<                }
<             }
< 
<             if (FirstWizardPanel.spotEnable.equals("spotEnable") == Boolean.TRUE && FirstWizardPanel.tableImages.getSelectedRow() != -1) {
<                if (IDs != null) {
<                   for(i = 0; i < IDs.length; ++i) {
<                      ((ImagePlus)impAnalClose.get(i)).hide();
<                   }
<                }
< 
<                ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[FirstWizardPanel.tableImages.getSelectedRow()];
<             }
< 
<             if (FirstWizardPanel.spotEnable.equals("spotEnable") == Boolean.TRUE && FirstWizardPanel.tableImages.getSelectedRow() == -1) {
<                ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[ChooserWizardPanel.tableImages.getSelectedRow()];
<             }
< 
<             if (ChooserWizardPanel.trackEnable.equals("trackEnable") == Boolean.TRUE && ChooserWizardPanel.tableImages.getSelectedRow() != -1) {
<                if (IDs != null) {
<                   for(i = 0; i < IDs.length; ++i) {
<                      ((ImagePlus)impAnalClose.get(i)).hide();
<                   }
<                }
< 
<                ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[ChooserWizardPanel.tableImages.getSelectedRow()];
<             }
< 
<             if (ChooserWizardPanel.trackEnable.equals("trackEnable") == Boolean.TRUE && ChooserWizardPanel.tableImages.getSelectedRow() == -1) {
<                ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[FirstWizardPanel.tableImages.getSelectedRow()];
<             }
< 
<             ProcessTrackMateXml.this.impAnal.show();
<             int[] dims = ProcessTrackMateXml.this.impAnal.getDimensions();
<             if (dims[4] == 1 && dims[3] > 1) {
<                ProcessTrackMateXml.this.impAnal.setDimensions(dims[2], dims[4], dims[3]);
<                Calibration calibration = ProcessTrackMateXml.this.impAnal.getCalibration();
<                calibration.frameInterval = 1.0D;
<             }
< 
<             new TmXmlReader(fileXML);
<             DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
<             DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
<             DocumentBuilder builder = null;
< 
<             try {
<                builder = factory.newDocumentBuilder();
<             } catch (ParserConfigurationException var116) {
<                var116.printStackTrace();
<             }
< 
<             Document doc = null;
< 
<             try {
<                doc = builder.parse(TrackAnalyzer_.xmlPath);
<             } catch (SAXException var114) {
<                var114.printStackTrace();
<             } catch (IOException var115) {
<                var115.printStackTrace();
<             }
< 
<             XPathFactory xPathfactory = XPathFactory.newInstance();
<             XPath xpath = xPathfactory.newXPath();
<             XPathExpression exprBasicSettings = null;
<             XPathExpression exprDetectorSettings = null;
<             XPathExpression exprInitialSpotFilter = null;
<             XPathExpression exprFilter = null;
<             XPathExpression exprTrackerSettings = null;
<             XPathExpression exprLinking = null;
<             XPathExpression exprGapClosing = null;
<             XPathExpression exprSplitting = null;
<             XPathExpression exprMerging = null;
<             XPathExpression exprTrackFilter = null;
<             XPathExpression exprLinkingP = null;
< 
<             try {
<                exprBasicSettings = xpath.compile("//Settings/BasicSettings[@zstart]");
<             } catch (XPathExpressionException var113) {
<                var113.printStackTrace();
<             }
< 
<             try {
<                exprLinkingP = xpath.compile("//Linking/FeaturePenalties[@MEAN_INTENSITY]");
<             } catch (XPathExpressionException var112) {
<                var112.printStackTrace();
<             }
< 
<             try {
<                exprDetectorSettings = xpath.compile("//Settings/DetectorSettings[@RADIUS]");
<             } catch (XPathExpressionException var111) {
<                var111.printStackTrace();
<             }
< 
<             try {
<                exprInitialSpotFilter = xpath.compile("//Settings/InitialSpotFilter[@feature]");
<             } catch (XPathExpressionException var110) {
<                var110.printStackTrace();
<             }
< 
<             try {
<                exprFilter = xpath.compile("//SpotFilterCollection/Filter[@feature]");
<             } catch (XPathExpressionException var109) {
<                var109.printStackTrace();
<             }
< 
<             try {
<                exprTrackerSettings = xpath.compile("//Settings/TrackerSettings[@TRACKER_NAME]");
<             } catch (XPathExpressionException var108) {
<                var108.printStackTrace();
<             }
< 
<             try {
<                exprLinking = xpath.compile("//TrackerSettings/Linking[@LINKING_MAX_DISTANCE]");
<             } catch (XPathExpressionException var107) {
<                var107.printStackTrace();
<             }
< 
<             try {
<                exprGapClosing = xpath.compile("//TrackerSettings/GapClosing[@MAX_FRAME_GAP]");
<             } catch (XPathExpressionException var106) {
<                var106.printStackTrace();
<             }
< 
<             try {
<                exprSplitting = xpath.compile("//TrackerSettings/TrackSplitting[@SPLITTING_MAX_DISTANCE]");
<             } catch (XPathExpressionException var105) {
<                var105.printStackTrace();
<             }
< 
<             try {
<                exprMerging = xpath.compile("//TrackerSettings/TrackMerging[@MERGING_MAX_DISTANCE]");
<             } catch (XPathExpressionException var104) {
<                var104.printStackTrace();
<             }
< 
<             try {
<                exprTrackFilter = xpath.compile("//TrackFilterCollection/Filter[@feature]");
<             } catch (XPathExpressionException var103) {
<                var103.printStackTrace();
<             }
< 
<             NodeList nlBasicSettings = null;
<             NodeList nlDetectorSettings = null;
<             NodeList nlInitialSpotFilter = null;
<             NodeList nlFilter = null;
<             NodeList nlTrackerSettings = null;
<             NodeList nlLinking = null;
<             NodeList nlGapClosing = null;
<             NodeList nlSplitting = null;
<             NodeList nlMerging = null;
<             NodeList nlTrackFilter = null;
<             NodeList nlLinkingP = null;
< 
<             try {
<                nlBasicSettings = (NodeList)exprBasicSettings.evaluate(doc, XPathConstants.NODESET);
<                nlDetectorSettings = (NodeList)exprDetectorSettings.evaluate(doc, XPathConstants.NODESET);
<                nlInitialSpotFilter = (NodeList)exprInitialSpotFilter.evaluate(doc, XPathConstants.NODESET);
<                nlFilter = (NodeList)exprFilter.evaluate(doc, XPathConstants.NODESET);
<                nlTrackerSettings = (NodeList)exprTrackerSettings.evaluate(doc, XPathConstants.NODESET);
<                nlLinking = (NodeList)exprLinking.evaluate(doc, XPathConstants.NODESET);
<                nlGapClosing = (NodeList)exprGapClosing.evaluate(doc, XPathConstants.NODESET);
<                nlSplitting = (NodeList)exprSplitting.evaluate(doc, XPathConstants.NODESET);
<                nlMerging = (NodeList)exprMerging.evaluate(doc, XPathConstants.NODESET);
<                nlTrackFilter = (NodeList)exprTrackFilter.evaluate(doc, XPathConstants.NODESET);
<                nlLinkingP = (NodeList)exprLinkingP.evaluate(doc, XPathConstants.NODESET);
<             } catch (XPathExpressionException var102) {
<                var102.printStackTrace();
<             }
< 
<             Node linkingNames;
<             for(int ixx = 0; ixx < nlBasicSettings.getLength(); ++ixx) {
<                linkingNames = nlBasicSettings.item(ixx);
<                ProcessTrackMateXml.this.zstart = linkingNames.getAttributes().getNamedItem("zstart").getNodeValue();
<                ProcessTrackMateXml.this.zend = linkingNames.getAttributes().getNamedItem("zend").getNodeValue();
<                ProcessTrackMateXml.this.ystart = linkingNames.getAttributes().getNamedItem("ystart").getNodeValue();
<                ProcessTrackMateXml.this.yend = linkingNames.getAttributes().getNamedItem("yend").getNodeValue();
<                ProcessTrackMateXml.this.xstart = linkingNames.getAttributes().getNamedItem("xstart").getNodeValue();
<                ProcessTrackMateXml.this.xend = linkingNames.getAttributes().getNamedItem("xend").getNodeValue();
<                ProcessTrackMateXml.this.tstart = linkingNames.getAttributes().getNamedItem("tstart").getNodeValue();
<                ProcessTrackMateXml.this.tend = linkingNames.getAttributes().getNamedItem("tend").getNodeValue();
<             }
< 
<             Node currentItem = null;
< 
<             for(int ix = 0; ix < nlDetectorSettings.getLength(); ++ix) {
<                currentItem = nlDetectorSettings.item(ix);
<                ProcessTrackMateXml.this.RADIUS = currentItem.getAttributes().getNamedItem("RADIUS").getNodeValue();
<                ProcessTrackMateXml.this.THRESHOLD = currentItem.getAttributes().getNamedItem("THRESHOLD").getNodeValue();
<                ProcessTrackMateXml.this.TARGET_CHANNEL = currentItem.getAttributes().getNamedItem("TARGET_CHANNEL").getNodeValue();
<                ProcessTrackMateXml.this.DO_SUBPIXEL_LOCALIZATION = currentItem.getAttributes().getNamedItem("DO_SUBPIXEL_LOCALIZATION").getNodeValue();
<                ProcessTrackMateXml.this.DO_MEDIAN_FILTERING = currentItem.getAttributes().getNamedItem("DO_MEDIAN_FILTERING").getNodeValue();
<                ProcessTrackMateXml.this.DETECTOR_NAME = currentItem.getAttributes().getNamedItem("DETECTOR_NAME").getNodeValue();
<                if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("BLOCK_LOG_DETECTOR")) {
<                   ProcessTrackMateXml.this.NSPLIT = currentItem.getAttributes().getNamedItem("NSPLIT").getNodeValue();
<                }
< 
<                if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("DOWNSAMLE_LOG_DETECTOR")) {
<                   ProcessTrackMateXml.this.DOWNSAMPLE_FACTOR = currentItem.getAttributes().getNamedItem("DOWNSAMPLE_FACTOR").getNodeValue();
<                }
<             }
< 
<             linkingNames = null;
<             String linkingValues = null;
< 
<             int ixxx;
<             for(ixxx = 0; ixxx < nlLinkingP.getLength(); ++ixxx) {
<                nlLinkingP.item(ixxx).getAttributes().item(ixxx).getNodeName();
<                nlLinkingP.item(ixxx).getAttributes().item(ixxx).getNodeValue();
<             }
< 
<             for(ixxx = 0; ixxx < nlInitialSpotFilter.getLength(); ++ixxx) {
<                currentItem = nlInitialSpotFilter.item(ixxx);
<                ProcessTrackMateXml.this.initialSpotFilter = currentItem.getAttributes().getNamedItem("value").getNodeValue();
<             }
< 
<             String initialFilterFeature = null;
<             String initialFilterValue = null;
<             String initialFilterAbove = null;
< 
<             for(int ixxxx = 0; ixxxx < nlFilter.getLength(); ++ixxxx) {
<                currentItem = nlFilter.item(ixxxx);
<                initialFilterFeature = currentItem.getAttributes().getNamedItem("feature").getNodeValue();
<                initialFilterValue = currentItem.getAttributes().getNamedItem("value").getNodeValue();
<                initialFilterAbove = currentItem.getAttributes().getNamedItem("isabove").getNodeValue();
<             }
< 
<             String initialTrackFilterFeature = null;
<             String initialTrackFilterValue = null;
<             String initialTrackFilterAbove = null;
< 
<             int ixxxxx;
<             for(ixxxxx = 0; ixxxxx < nlTrackerSettings.getLength(); ++ixxxxx) {
<                currentItem = nlTrackerSettings.item(ixxxxx);
<                ProcessTrackMateXml.this.TRACKER_NAME = currentItem.getAttributes().getNamedItem("TRACKER_NAME").getNodeValue();
<                ProcessTrackMateXml.this.CUTOFF_PERCENTILE = currentItem.getAttributes().getNamedItem("CUTOFF_PERCENTILE").getNodeValue();
<                ProcessTrackMateXml.this.BLOCKING_VALUE = currentItem.getAttributes().getNamedItem("BLOCKING_VALUE").getNodeValue();
<                ProcessTrackMateXml.this.ALTERNATIVE_LINKING_COST_FACTOR = currentItem.getAttributes().getNamedItem("ALTERNATIVE_LINKING_COST_FACTOR").getNodeValue();
<             }
< 
<             for(ixxxxx = 0; ixxxxx < nlLinking.getLength(); ++ixxxxx) {
<                currentItem = nlLinking.item(ixxxxx);
<                ProcessTrackMateXml.this.LINKING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("LINKING_MAX_DISTANCE").getNodeValue();
<             }
< 
<             for(ixxxxx = 0; ixxxxx < nlGapClosing.getLength(); ++ixxxxx) {
<                currentItem = nlGapClosing.item(ixxxxx);
<                ProcessTrackMateXml.this.MAX_FRAME_GAP = currentItem.getAttributes().getNamedItem("MAX_FRAME_GAP").getNodeValue();
<                ProcessTrackMateXml.this.MAX_DISTANCE = currentItem.getAttributes().getNamedItem("GAP_CLOSING_MAX_DISTANCE").getNodeValue();
<                ProcessTrackMateXml.this.ALLOW_GAP_CLOSING = currentItem.getAttributes().getNamedItem("ALLOW_GAP_CLOSING").getNodeValue();
<             }
< 
<             for(ixxxxx = 0; ixxxxx < nlSplitting.getLength(); ++ixxxxx) {
<                currentItem = nlSplitting.item(ixxxxx);
<                ProcessTrackMateXml.this.SPLITTING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("SPLITTING_MAX_DISTANCE").getNodeValue();
<                ProcessTrackMateXml.this.ALLOW_TRACK_SPLITTING = currentItem.getAttributes().getNamedItem("ALLOW_TRACK_SPLITTING").getNodeValue();
<             }
< 
<             for(ixxxxx = 0; ixxxxx < nlMerging.getLength(); ++ixxxxx) {
<                currentItem = nlMerging.item(ixxxxx);
<                ProcessTrackMateXml.this.MERGING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("MERGING_MAX_DISTANCE").getNodeValue();
<                ProcessTrackMateXml.this.ALLOW_TRACK_MERGING = currentItem.getAttributes().getNamedItem("ALLOW_TRACK_MERGING").getNodeValue();
<             }
< 
<             ProcessTrackMateXml.settings = new Settings(ProcessTrackMateXml.this.impAnal);
<             ProcessTrackMateXml.settings.dt = 0.05D;
<             FeatureFilter ok;
<             if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("LOG_DETECTOR")) {
<                ProcessTrackMateXml.settings.detectorFactory = new LogDetectorFactory();
<                ProcessTrackMateXml.settings.detectorSettings = ProcessTrackMateXml.settings.detectorFactory.getDefaultSettings();
<                ProcessTrackMateXml.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", Boolean.parseBoolean(ProcessTrackMateXml.this.DO_SUBPIXEL_LOCALIZATION));
<                ProcessTrackMateXml.settings.detectorSettings.put("RADIUS", Double.parseDouble(ProcessTrackMateXml.this.RADIUS));
<                ProcessTrackMateXml.settings.detectorSettings.put("TARGET_CHANNEL", Integer.parseInt(ProcessTrackMateXml.this.TARGET_CHANNEL));
<                ProcessTrackMateXml.settings.detectorSettings.put("THRESHOLD", Double.parseDouble(ProcessTrackMateXml.this.THRESHOLD));
<                ProcessTrackMateXml.settings.detectorSettings.put("DO_MEDIAN_FILTERING", Boolean.parseBoolean(ProcessTrackMateXml.this.DO_MEDIAN_FILTERING));
<                if (ProcessTrackMateXml.this.initialSpotFilter != null) {
<                   ProcessTrackMateXml.settings.initialSpotFilterValue = Double.parseDouble(ProcessTrackMateXml.this.initialSpotFilter);
<                }
< 
<                if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("MANUAL_DETECTOR")) {
<                   ProcessTrackMateXml.settings.detectorFactory = new ManualDetectorFactory();
<                   ProcessTrackMateXml.settings.detectorSettings.put("RADIUS", Double.parseDouble(ProcessTrackMateXml.this.RADIUS));
<                   if (ProcessTrackMateXml.this.initialSpotFilter != null) {
<                      ProcessTrackMateXml.settings.initialSpotFilterValue = Double.parseDouble(ProcessTrackMateXml.this.initialSpotFilter);
<                   }
<                }
< 
<                if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("DOG_DETECTOR")) {
<                   ProcessTrackMateXml.settings.detectorFactory = new DogDetectorFactory();
<                   ProcessTrackMateXml.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", Boolean.parseBoolean(ProcessTrackMateXml.this.DO_SUBPIXEL_LOCALIZATION));
<                   ProcessTrackMateXml.settings.detectorSettings.put("RADIUS", Double.parseDouble(ProcessTrackMateXml.this.RADIUS));
<                   ProcessTrackMateXml.settings.detectorSettings.put("TARGET_CHANNEL", Integer.parseInt(ProcessTrackMateXml.this.TARGET_CHANNEL));
<                   ProcessTrackMateXml.settings.detectorSettings.put("THRESHOLD", Double.parseDouble(ProcessTrackMateXml.this.THRESHOLD));
<                   ProcessTrackMateXml.settings.detectorSettings.put("DO_MEDIAN_FILTERING", Double.parseDouble(ProcessTrackMateXml.this.DO_MEDIAN_FILTERING));
<                   if (ProcessTrackMateXml.this.initialSpotFilter != null) {
<                      ProcessTrackMateXml.settings.initialSpotFilterValue = Double.parseDouble(ProcessTrackMateXml.this.initialSpotFilter);
<                   }
<                }
< 
<                if (initialFilterFeature != null) {
<                   ok = new FeatureFilter(initialFilterFeature, Double.parseDouble(initialFilterValue), Boolean.parseBoolean(initialFilterAbove));
<                   ProcessTrackMateXml.settings.addSpotFilter(ok);
<                }
<             }
< 
<             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
<                ProcessTrackMateXml.settings.trackerFactory = new ManualTrackerFactory();
<                ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<             }
< 
<             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
<                ProcessTrackMateXml.settings.trackerFactory = new ManualTrackerFactory();
<                ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<             }
< 
<             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("KALMAN_TRACKER")) {
<                ProcessTrackMateXml.settings.trackerFactory = new KalmanTrackerFactory();
<                ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                ProcessTrackMateXml.settings.trackerSettings.put("KALMAN_SEARCH_RADIUS", Double.parseDouble(ProcessTrackMateXml.this.RADIUS));
<             }
< 
<             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("SIMPLE_SPARSE_LAP_TRACKER")) {
<                ProcessTrackMateXml.settings.trackerFactory = new SimpleSparseLAPTrackerFactory();
<                ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                ProcessTrackMateXml.settings.trackerSettings.put("LINKING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.LINKING_MAX_DISTANCE));
<                ProcessTrackMateXml.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.MAX_DISTANCE));
<                ProcessTrackMateXml.settings.trackerSettings.put("MAX_FRAME_GAP", Double.parseDouble(ProcessTrackMateXml.this.MAX_FRAME_GAP));
<             }
< 
<             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("SPARSE_LAP_TRACKER")) {
<                ProcessTrackMateXml.settings.trackerFactory = new SparseLAPTrackerFactory();
<                ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                ProcessTrackMateXml.settings.trackerSettings.put("LINKING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.LINKING_MAX_DISTANCE));
<                Map<String, Double> linkingPenalty = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((data) -> {
<                   return (String)data[0];
<                }, (data) -> {
<                   return (Double)data[1];
<                }));
<                ProcessTrackMateXml.settings.trackerSettings.put("ALLOW_GAP_CLOSING", Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_GAP_CLOSING));
<                Map var44;
<                if (Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_GAP_CLOSING)) {
<                   ProcessTrackMateXml.settings.trackerSettings.put("MAX_FRAME_GAP", Integer.parseInt(ProcessTrackMateXml.this.MAX_FRAME_GAP));
<                   ProcessTrackMateXml.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.MAX_DISTANCE));
<                   var44 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((data) -> {
<                      return (String)data[0];
<                   }, (data) -> {
<                      return (Double)data[1];
<                   }));
<                }
< 
<                ProcessTrackMateXml.settings.trackerSettings.put("ALLOW_TRACK_SPLITTING", Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_SPLITTING));
<                if (Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_SPLITTING)) {
<                   ProcessTrackMateXml.settings.trackerSettings.put("SPLITTING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.SPLITTING_MAX_DISTANCE));
<                   var44 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((data) -> {
<                      return (String)data[0];
<                   }, (data) -> {
<                      return (Double)data[1];
<                   }));
<                }
< 
<                ProcessTrackMateXml.settings.trackerSettings.put("ALLOW_TRACK_MERGING", Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_MERGING));
<                if (Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_MERGING)) {
<                   ProcessTrackMateXml.settings.trackerSettings.put("MERGING_MAX_DISTANCE", Double.parseDouble(ProcessTrackMateXml.this.MERGING_MAX_DISTANCE));
<                   var44 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((data) -> {
<                      return (String)data[0];
<                   }, (data) -> {
<                      return (Double)data[1];
<                   }));
<                }
<             }
< 
<             ProcessTrackMateXml.settings.addAllAnalyzers();
<             ProcessTrackMateXml.model = new Model();
<             ProcessTrackMateXml.trackmate = new TrackMate(ProcessTrackMateXml.model, ProcessTrackMateXml.settings);
<             ok = null;
<             Boolean okx = ProcessTrackMateXml.trackmate.checkInput();
<             okx = ProcessTrackMateXml.trackmate.process();
<             FeatureModel fm = ProcessTrackMateXml.model.getFeatureModel();
<             Set<Integer> trackIDs = ProcessTrackMateXml.model.getTrackModel().trackIDs(true);
<             Set<Spot> track = null;
< 
<             for(int id = 0; id < trackIDs.size(); ++id) {
<                fm.getTrackFeature(id, "TRACK_MEAN_SPEED");
<                track = ProcessTrackMateXml.model.getTrackModel().trackSpots(id);
<             }
< 
<             Double widthx;
<             Double heightx;
<             Double nCapturesx;
<             Double stackx;
<             Double channelx;
<             Double slicex;
<             Spot spot;
<             for(Iterator var48 = track.iterator(); var48.hasNext(); slicex = spot.getFeature("MEAN_INTENSITY")) {
<                spot = (Spot)var48.next();
<                int sid = spot.ID();
<                widthx = spot.getFeature("POSITION_X");
<                heightx = spot.getFeature("POSITION_Y");
<                nCapturesx = spot.getFeature("FRAME");
<                stackx = spot.getFeature("QUALITY");
<                channelx = spot.getFeature("SNR");
<             }
< 
<             ProcessTrackMateXml.this.totalSpots = ProcessTrackMateXml.model.getSpots();
<             ProcessTrackMateXml.displayer = null;
<             ProcessTrackMateXml.selectionModel = new SelectionModel(ProcessTrackMateXml.model);
<             ProcessTrackMateXml.ds = DisplaySettingsIO.readUserDefault();
<             ProcessTrackMateXml.ds.setSpotShowName(true);
<             ProcessTrackMateXml.ds.setSpotVisible(ProcessTrackMateXml.spotsVisible);
<             ProcessTrackMateXml.ds.setSpotColorBy(TrackMateObject.TRACKS, "TRACK_INDEX");
<             ProcessTrackMateXml.ds.setTrackVisible(ProcessTrackMateXml.tracksVisible);
<             ProcessTrackMateXml.ds.setTrackColorBy(TrackMateObject.TRACKS, "TRACK_INDEX");
<             ProcessTrackMateXml.ds.setTrackDisplayMode(TrackDisplayMode.FULL);
<             ProcessTrackMateXml.displayer = new HyperStackDisplayer(ProcessTrackMateXml.model, ProcessTrackMateXml.selectionModel, ProcessTrackMateXml.this.impAnal, ProcessTrackMateXml.ds);
<             ProcessTrackMateXml.displayer.render();
<             ProcessTrackMateXml.displayer.refresh();
<             spot = null;
<             Integer firstFrame = null;
<             Integer lastFrame = null;
<             widthx = null;
<             heightx = null;
<             nCapturesx = null;
<             stackx = null;
<             channelx = null;
<             slicex = null;
<             BufferedImage bi = null;
<             ColorProcessor cp = null;
<             Integer index = null;
<             ImagePlus capture = null;
<             if (ProcessTrackMateXml.this.impAnal.getNFrames() > 1) {
<                firstFrame = Math.max(1, Math.min(ProcessTrackMateXml.this.impAnal.getNFrames(), 1));
<                lastFrame = Math.min(ProcessTrackMateXml.this.impAnal.getNFrames(), Math.max(ProcessTrackMateXml.this.impAnal.getNFrames(), 1));
<             }
< 
<             if (ProcessTrackMateXml.this.impAnal.getNSlices() > 1) {
<                firstFrame = Math.max(1, Math.min(ProcessTrackMateXml.this.impAnal.getNSlices(), 1));
<                lastFrame = Math.min(ProcessTrackMateXml.this.impAnal.getNSlices(), Math.max(ProcessTrackMateXml.this.impAnal.getNSlices(), 1));
<             }
< 
<             Rectangle bounds = ProcessTrackMateXml.displayer.getImp().getCanvas().getBounds();
<             Integer width = bounds.width;
<             Integer height = bounds.height;
<             Integer nCaptures = lastFrame - firstFrame + 1;
<             ImageStack stack = new ImageStack(width, height);
<             Integer channel = ProcessTrackMateXml.displayer.getImp().getChannel();
<             Integer slice = ProcessTrackMateXml.displayer.getImp().getSlice();
<             ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(true);
< 
<             for(int frame = firstFrame; frame <= lastFrame; ++frame) {
<                ProcessTrackMateXml.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
<                bi = new BufferedImage(width, height, 2);
<                ProcessTrackMateXml.displayer.getImp().getCanvas().paint(bi.getGraphics());
<                cp = new ColorProcessor(bi);
<                index = ProcessTrackMateXml.displayer.getImp().getStackIndex(channel, slice, frame);
<                stack.addSlice(ProcessTrackMateXml.displayer.getImp().getImageStack().getSliceLabel(index), cp);
<             }
< 
<             ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(false);
<             capture = new ImagePlus("TrackMate capture of " + ProcessTrackMateXml.displayer.getImp().getShortTitle(), stack);
<             ProcessTrackMateXml.transferCalibration(ProcessTrackMateXml.displayer.getImp(), capture);
<             FeatureModel fm1;
<             Set trackIDs1;
<             Set edges;
<             final Model model;
<             int j;
<             ArrayList dataListSpot;
<             int jx;
<             if (FirstWizardPanel.spotEnable.equals("spotEnable") == Boolean.TRUE) {
<                model = ProcessTrackMateXml.trackmate.getModel();
<                fm1 = model.getFeatureModel();
<                trackIDs1 = model.getTrackModel().trackIDs(true);
<                Collection<String> spotFeatures = ProcessTrackMateXml.trackmate.getModel().getFeatureModel().getSpotFeatures();
<                ResultsTable spotTable = new ResultsTable();
<                Iterator var66 = trackIDs1.iterator();
< 
<                ArrayList stringsSpot;
<                while(var66.hasNext()) {
<                   Integer trackIDx = (Integer)var66.next();
<                   edges = model.getTrackModel().trackSpots(trackIDx);
<                   stringsSpot = new ArrayList(edges);
<                   Collections.sort(stringsSpot, Spot.frameComparator);
<                   Iterator var70 = stringsSpot.iterator();
< 
<                   while(var70.hasNext()) {
<                      Spot spotx = (Spot)var70.next();
<                      spotTable.incrementCounter();
<                      spotTable.addLabel(spotx.getName());
<                      spotTable.addValue("ID", "" + spotx.ID());
<                      spotTable.addValue("TRACK_ID", "" + trackIDx);
<                      Iterator var72 = spotFeatures.iterator();
< 
<                      while(var72.hasNext()) {
<                         String featurex = (String)var72.next();
<                         Double valx = spotx.getFeature(featurex);
<                         if (valx == null) {
<                            spotTable.addValue(featurex, "None");
<                         } else if ((Boolean)fm1.getSpotFeatureIsInt().get(featurex)) {
<                            spotTable.addValue(featurex, "" + valx.intValue());
<                         } else {
<                            spotTable.addValue(featurex, valx);
<                         }
<                      }
<                   }
<                }
< 
<                ProcessTrackMateXml.columnHeadersSpot = spotTable.getHeadings();
<                j = spotTable.size();
<                dataListSpot = new ArrayList();
< 
<                for(jx = 0; jx < j; ++jx) {
<                   stringsSpot = new ArrayList();
< 
<                   for(int c = 0; c < ProcessTrackMateXml.columnHeadersSpot.length; ++c) {
<                      String valuesSpot = spotTable.getStringValue(ProcessTrackMateXml.columnHeadersSpot[c], jx);
<                      stringsSpot.add(valuesSpot);
<                   }
< 
<                   dataListSpot.add(stringsSpot);
<                }
< 
<                ProcessTrackMateXml.dataSpot = new String[dataListSpot.size()][];
< 
<                for(jx = 0; jx < ProcessTrackMateXml.dataSpot.length; ++jx) {
<                   ProcessTrackMateXml.dataSpot[jx] = new String[((List)dataListSpot.get(jx)).size()];
<                }
< 
<                for(jx = 0; jx < dataListSpot.size(); ++jx) {
<                   for(int ux = 1; ux < ((List)dataListSpot.get(jx)).size(); ++ux) {
<                      ProcessTrackMateXml.dataSpot[jx][ux] = (String)((List)dataListSpot.get(jx)).get(ux);
<                   }
<                }
< 
<                FirstWizardPanel.createSpotTable();
<                FirstWizardPanel.tableSpot.addMouseListener(new MouseAdapter() {
<                   public void mouseReleased(MouseEvent e) {
<                      if (ProcessTrackMateXml.selectionModel != null && FirstWizardPanel.command == "enable" && FirstWizardPanel.command != null) {
<                         ListSelectionModel lsm = FirstWizardPanel.tableSpot.getSelectionModel();
<                         int selStart = lsm.getMinSelectionIndex();
<                         int selEnd = lsm.getMaxSelectionIndex();
<                         if (selStart < 0 || selEnd < 0) {
<                            return;
<                         }
< 
<                         int minLine = Math.min(selStart, selEnd);
<                         int maxLine = Math.max(selStart, selEnd);
<                         Set<Spot> spots = new HashSet();
< 
<                         for(int row = minLine; row <= maxLine; ++row) {
<                            int spotID = Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(row, 2));
<                            Spot spot = ProcessTrackMateXml.this.totalSpots.search(spotID);
<                            if (spot != null) {
<                               spots.add(spot);
<                            }
<                         }
< 
<                         ProcessTrackMateXml.selectionModel.clearSelection();
<                         ProcessTrackMateXml.selectionModel.addSpotToSelection(spots);
<                      }
< 
<                   }
<                });
<             }
< 
<             if (ChooserWizardPanel.trackEnable.equals("trackEnable") == Boolean.TRUE) {
<                ProcessTrackMateXml.FEATURES.add("TOTAL_DISTANCE_TRAVELED");
<                ProcessTrackMateXml.FEATURES.add("MAX_DISTANCE_TRAVELED");
<                ProcessTrackMateXml.FEATURES.add("CONFINMENT_RATIO");
<                ProcessTrackMateXml.FEATURES.add("MEAN_STRAIGHT_LINE_SPEED");
<                ProcessTrackMateXml.FEATURES.add("LINEARITY_OF_FORWARD_PROGRESSION");
<                ProcessTrackMateXml.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_XY");
<                ProcessTrackMateXml.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_YZ");
<                ProcessTrackMateXml.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_ZX");
<                ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total distance traveled");
<                ProcessTrackMateXml.FEATURE_NAMES.put("MAX_DISTANCE_TRAVELED", "Max distance traveled");
<                ProcessTrackMateXml.FEATURE_NAMES.put("CONFINMENT_RATIO", "Confinment ratio");
<                ProcessTrackMateXml.FEATURE_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean straight line speed");
<                ProcessTrackMateXml.FEATURE_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Linearity of forward progression");
<                ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Absolute angle in xy plane");
<                ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Absolute angle in yz plane");
<                ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Absolute angle in zx plane");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total dist.");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("MAX_DISTANCE_TRAVELED", "Max dist.");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("CONFINMENT_RATIO", "Cnfnmnt ratio");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean v. line");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Lin. fwd. progr.");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Abs. angle xy");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Abs. angle yz");
<                ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Abs. angle zx");
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_DISTANCE_TRAVELED", Dimension.LENGTH);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("MAX_DISTANCE_TRAVELED", Dimension.LENGTH);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("CONFINMENT_RATIO", Dimension.NONE);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("MEAN_STRAIGHT_LINE_SPEED", Dimension.VELOCITY);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("LINEARITY_OF_FORWARD_PROGRESSION", Dimension.NONE);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_XY", Dimension.ANGLE);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_YZ", Dimension.ANGLE);
<                ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_ZX", Dimension.ANGLE);
<                ProcessTrackMateXml.IS_INT.put("TOTAL_DISTANCE_TRAVELED", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("MAX_DISTANCE_TRAVELED", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("CONFINMENT_RATIO", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("MEAN_STRAIGHT_LINE_SPEED", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("LINEARITY_OF_FORWARD_PROGRESSION", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_XY", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_YZ", Boolean.FALSE);
<                ProcessTrackMateXml.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_ZX", Boolean.FALSE);
<                model = ProcessTrackMateXml.trackmate.getModel();
<                fm1 = model.getFeatureModel();
<                trackIDs1 = model.getTrackModel().trackIDs(true);
<                ProcessTrackMateXml.this.trackTable = new ResultsTable();
<                Iterator var139 = trackIDs1.iterator();
< 
<                while(var139.hasNext()) {
<                   Integer trackID = (Integer)var139.next();
<                   List<Spot> spots = new ArrayList(model.getTrackModel().trackSpots(trackID));
<                   Collections.sort(spots, Spot.frameComparator);
<                   Spot first = (Spot)spots.get(0);
<                   edges = model.getTrackModel().trackEdges(trackID);
<                   double totalDistance = 0.0D;
<                   double maxDistanceSq = Double.NEGATIVE_INFINITY;
<                   double maxDistance = 0.0D;
<                   double dx = 0.0D;
<                   double dy = 0.0D;
<                   double dz = 0.0D;
< 
<                   Spot source;
<                   Spot target;
<                   double vMean;
<                   double confinmentRatio;
<                   for(Iterator var81 = edges.iterator(); var81.hasNext(); dz += target.getDoublePosition(2) - source.getDoublePosition(2)) {
<                      DefaultWeightedEdge edge = (DefaultWeightedEdge)var81.next();
<                      source = model.getTrackModel().getEdgeSource(edge);
<                      target = model.getTrackModel().getEdgeTarget(edge);
<                      vMean = Math.sqrt(source.squareDistanceTo(target));
<                      totalDistance += vMean;
<                      confinmentRatio = first.squareDistanceTo(target);
<                      if (confinmentRatio > maxDistanceSq) {
<                         maxDistanceSq = confinmentRatio;
<                         maxDistance = Math.sqrt(confinmentRatio);
<                      }
< 
<                      dx += target.getDoublePosition(0) - source.getDoublePosition(0);
<                      dy += target.getDoublePosition(1) - source.getDoublePosition(1);
<                   }
< 
<                   double netDistance = fm1.getTrackFeature(trackID, "TRACK_DISPLACEMENT");
<                   double tTotal = fm1.getTrackFeature(trackID, "TRACK_DURATION");
<                   vMean = fm1.getTrackFeature(trackID, "TRACK_MEAN_SPEED");
<                   confinmentRatio = netDistance / totalDistance;
<                   double meanStraightLineSpeed = netDistance / tTotal;
<                   double linearityForwardProgression = meanStraightLineSpeed / vMean;
<                   double angleXY = Math.atan2(dy, dx);
<                   double angleYZ = Math.atan2(dz, dy);
<                   double angleZX = Math.atan2(dx, dz);
<                   Collection<String> trackFeatures = fm1.getTrackFeatures();
<                   ProcessTrackMateXml.this.trackTable.incrementCounter();
<                   ProcessTrackMateXml.this.trackTable.addLabel(model.getTrackModel().name(trackID));
<                   ProcessTrackMateXml.this.trackTable.addValue("TRACK_ID", "" + trackID);
<                   Iterator var100 = trackFeatures.iterator();
< 
<                   while(var100.hasNext()) {
<                      String feature = (String)var100.next();
<                      Double val = fm1.getTrackFeature(trackID, feature);
<                      if (val == null) {
<                         ProcessTrackMateXml.this.trackTable.addValue(feature, "None");
<                      } else if ((Boolean)fm1.getTrackFeatureIsInt().get(feature)) {
<                         ProcessTrackMateXml.this.trackTable.addValue(feature, "" + val.intValue());
<                      } else {
<                         ProcessTrackMateXml.this.trackTable.addValue(feature, val);
<                      }
<                   }
< 
<                   ProcessTrackMateXml.this.trackTable.addValue("TOTAL_DISTANCE_TRAVELED", "" + (double)Math.round(totalDistance * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("MAX_DISTANCE_TRAVELED", "" + (double)Math.round(maxDistance * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("MEAN_STRAIGHT_LINE_SPEED", "" + (double)Math.round(meanStraightLineSpeed * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("LINEARITY_OF_FORWARD_PROGRESSION", "" + (double)Math.round(linearityForwardProgression * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_XY", "" + (double)Math.round(angleXY * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_YZ", "" + (double)Math.round(angleYZ * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_ZX", "" + (double)Math.round(angleZX * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("CONFINMENT_RATIO", "" + (double)Math.round(confinmentRatio * 1000.0D) / 1000.0D);
<                   ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "");
<                   if (confinmentRatio == 0.0D) {
<                      ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Total-Confined Track");
<                   }
< 
<                   if (confinmentRatio == 1.0D) {
<                      ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Perfectly Straight Track");
<                   }
< 
<                   if (confinmentRatio > 0.0D && confinmentRatio <= 0.5D) {
<                      ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Strongly Confined Track");
<                   }
< 
<                   if (confinmentRatio > 0.05D && confinmentRatio <= 0.25D) {
<                      ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Purely Random Track");
<                   }
< 
<                   if (confinmentRatio > 0.25D && confinmentRatio < 1.0D) {
<                      ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Fairly Straight Track");
<                   }
<                }
< 
<                ProcessTrackMateXml.columnHeadersTrack = ProcessTrackMateXml.this.trackTable.getHeadings();
<                int rowsTrack = ProcessTrackMateXml.this.trackTable.size();
<                List<List<String>> dataListTrack = new ArrayList();
< 
<                for(j = 0; j < rowsTrack; ++j) {
<                   dataListSpot = new ArrayList();
< 
<                   for(jx = 0; jx < ProcessTrackMateXml.columnHeadersTrack.length; ++jx) {
<                      String valuesTrack = ProcessTrackMateXml.this.trackTable.getStringValue(ProcessTrackMateXml.columnHeadersTrack[jx], j);
<                      dataListSpot.add(valuesTrack);
<                   }
< 
<                   dataListTrack.add(dataListSpot);
<                }
< 
<                ProcessTrackMateXml.dataTrack = new String[dataListTrack.size()][];
< 
<                for(j = 0; j < ProcessTrackMateXml.dataTrack.length; ++j) {
<                   ProcessTrackMateXml.dataTrack[j] = new String[((List)dataListTrack.get(j)).size()];
<                }
< 
<                for(j = 0; j < dataListTrack.size(); ++j) {
<                   for(int u = 1; u < ((List)dataListTrack.get(j)).size(); ++u) {
<                      ProcessTrackMateXml.dataTrack[j][u] = (String)((List)dataListTrack.get(j)).get(u);
<                   }
<                }
< 
<                ChooserWizardPanel.createTrackTable();
<                ChooserWizardPanel.tableTrack.addMouseListener(new MouseAdapter() {
<                   public void mouseReleased(MouseEvent e) {
<                      if (ProcessTrackMateXml.selectionModel != null && ChooserWizardPanel.command == "enable" && ChooserWizardPanel.command != null) {
<                         ListSelectionModel lsm = ChooserWizardPanel.tableTrack.getSelectionModel();
<                         int selStart = lsm.getMinSelectionIndex();
<                         int selEnd = lsm.getMaxSelectionIndex();
<                         if (selStart < 0 || selEnd < 0) {
<                            return;
<                         }
< 
<                         int minLine = Math.min(selStart, selEnd);
<                         int maxLine = Math.max(selStart, selEnd);
<                         Set<DefaultWeightedEdge> edges = new HashSet();
<                         Set<Spot> spots = new HashSet();
< 
<                         for(int row = minLine; row <= maxLine; ++row) {
<                            int trackID = Integer.parseInt((String)ChooserWizardPanel.tableTrack.getValueAt(row, 2));
<                            spots.addAll(model.getTrackModel().trackSpots(trackID));
<                            edges.addAll(model.getTrackModel().trackEdges(trackID));
<                         }
< 
<                         ProcessTrackMateXml.selectionModel.clearSelection();
<                         ProcessTrackMateXml.selectionModel.addSpotToSelection(spots);
<                         ProcessTrackMateXml.selectionModel.addEdgeToSelection(edges);
<                      }
< 
<                   }
<                });
<             }
< 
<          }
<       });
<       this.mainProcess.start();
<    }
< 
<    private static void transferCalibration(ImagePlus from, ImagePlus to) {
<       Calibration fc = from.getCalibration();
<       Calibration tc = to.getCalibration();
<       tc.setUnit(fc.getUnit());
<       tc.setTimeUnit(fc.getTimeUnit());
<       tc.frameInterval = fc.frameInterval;
<       double mag = from.getCanvas().getMagnification();
<       tc.pixelWidth = fc.pixelWidth / mag;
<       tc.pixelHeight = fc.pixelHeight / mag;
<       tc.pixelDepth = fc.pixelDepth;
<    }
< 
<    private final TablePanel<Spot> createSpotTableRT(Model model, DisplaySettings ds) {
<       List<Spot> objects = new ArrayList();
<       Iterator var5 = model.getTrackModel().unsortedTrackIDs(true).iterator();
< 
<       while(var5.hasNext()) {
<          Integer trackID = (Integer)var5.next();
<          objects.addAll(model.getTrackModel().trackSpots(trackID));
<       }
< 
<       List<String> features = new ArrayList(model.getFeatureModel().getSpotFeatures());
<       Map<String, String> featureNames = model.getFeatureModel().getSpotFeatureNames();
<       Map<String, String> featureShortNames = model.getFeatureModel().getSpotFeatureShortNames();
<       Map<String, String> featureUnits = new HashMap();
<       Iterator var9 = features.iterator();
< 
<       while(var9.hasNext()) {
<          String feature = (String)var9.next();
<          Dimension dimension = (Dimension)model.getFeatureModel().getSpotFeatureDimensions().get(feature);
<          String units = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
<          featureUnits.put(feature, units);
<       }
< 
<       Map<String, Boolean> isInts = model.getFeatureModel().getSpotFeatureIsInt();
<       Map<String, String> infoTexts = new HashMap();
<       Function<Spot, String> labelGenerator = (spot) -> {
<          return spot.getName();
<       };
<       BiConsumer<Spot, String> labelSetter = (spot, label) -> {
<          spot.setName(label);
<       };
<       String SPOT_ID = "ID";
<       features.add(0, "ID");
<       featureNames.put("ID", "Spot ID");
<       featureShortNames.put("ID", "Spot ID");
<       featureUnits.put("ID", "");
<       isInts.put("ID", Boolean.TRUE);
<       infoTexts.put("ID", "The id of the spot.");
<       String TRACK_ID = "TRACK_ID";
<       features.add(1, "TRACK_ID");
<       featureNames.put("TRACK_ID", "Track ID");
<       featureShortNames.put("TRACK_ID", "Track ID");
<       featureUnits.put("TRACK_ID", "");
<       isInts.put("TRACK_ID", Boolean.TRUE);
<       infoTexts.put("TRACK_ID", "The id of the track this spot belongs to.");
<       BiFunction<Spot, String, Double> featureFun = (spot, featurex) -> {
<          if (featurex.equals("TRACK_ID")) {
<             Integer trackID = model.getTrackModel().trackIDOf(spot);
<             return trackID == null ? null : trackID.doubleValue();
<          } else {
<             return featurex.equals("ID") ? (double)spot.ID() : spot.getFeature(featurex);
<          }
<       };
<       BiConsumer<Spot, Color> colorSetter = (spot, color) -> {
<          spot.putFeature("MANUAL_SPOT_COLOR", (double)color.getRGB());
<       };
<       Supplier<FeatureColorGenerator<Spot>> coloring = () -> {
<          return FeatureUtils.createSpotColorGenerator(model, ds);
<       };
<       TablePanel<Spot> table = new TablePanel(objects, features, featureFun, featureNames, featureShortNames, featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter, "MANUAL_SPOT_COLOR", colorSetter);
<       return table;
<    }
< }
---
> /*      */ import fiji.plugin.trackmate.Dimension;
> /*      */ import fiji.plugin.trackmate.FeatureModel;
> /*      */ import fiji.plugin.trackmate.Model;
> /*      */ import fiji.plugin.trackmate.SelectionModel;
> /*      */ import fiji.plugin.trackmate.Settings;
> /*      */ import fiji.plugin.trackmate.Spot;
> /*      */ import fiji.plugin.trackmate.SpotCollection;
> /*      */ import fiji.plugin.trackmate.TrackMate;
> /*      */ import fiji.plugin.trackmate.detection.DogDetectorFactory;
> /*      */ import fiji.plugin.trackmate.detection.LogDetectorFactory;
> /*      */ import fiji.plugin.trackmate.detection.ManualDetectorFactory;
> /*      */ import fiji.plugin.trackmate.detection.SpotDetectorFactoryBase;
> /*      */ import fiji.plugin.trackmate.features.FeatureFilter;
> /*      */ import fiji.plugin.trackmate.features.FeatureUtils;
> /*      */ import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings;
> /*      */ import fiji.plugin.trackmate.gui.displaysettings.DisplaySettingsIO;
> /*      */ import fiji.plugin.trackmate.io.TmXmlReader;
> /*      */ import fiji.plugin.trackmate.tracking.LAPUtils;
> /*      */ import fiji.plugin.trackmate.tracking.ManualTrackerFactory;
> /*      */ import fiji.plugin.trackmate.tracking.SpotTrackerFactory;
> /*      */ import fiji.plugin.trackmate.tracking.kalman.KalmanTrackerFactory;
> /*      */ import fiji.plugin.trackmate.tracking.sparselap.SimpleSparseLAPTrackerFactory;
> /*      */ import fiji.plugin.trackmate.tracking.sparselap.SparseLAPTrackerFactory;
> /*      */ import fiji.plugin.trackmate.util.TMUtils;
> /*      */ import fiji.plugin.trackmate.visualization.FeatureColorGenerator;
> /*      */ import fiji.plugin.trackmate.visualization.hyperstack.HyperStackDisplayer;
> /*      */ import fiji.plugin.trackmate.visualization.table.TablePanel;
> /*      */ import ij.ImagePlus;
> /*      */ import ij.ImageStack;
> /*      */ import ij.WindowManager;
> /*      */ import ij.measure.Calibration;
> /*      */ import ij.measure.ResultsTable;
> /*      */ import ij.process.ColorProcessor;
> /*      */ import ij.process.ImageProcessor;
> /*      */ import java.awt.Color;
> /*      */ import java.awt.Rectangle;
> /*      */ import java.awt.event.MouseAdapter;
> /*      */ import java.awt.event.MouseEvent;
> /*      */ import java.awt.image.BufferedImage;
> /*      */ import java.io.File;
> /*      */ import java.io.IOException;
> /*      */ import java.util.ArrayList;
> /*      */ import java.util.Collection;
> /*      */ import java.util.Collections;
> /*      */ import java.util.HashMap;
> /*      */ import java.util.HashSet;
> /*      */ import java.util.List;
> /*      */ import java.util.Map;
> /*      */ import java.util.Set;
> /*      */ import java.util.function.BiConsumer;
> /*      */ import java.util.function.BiFunction;
> /*      */ import java.util.function.Function;
> /*      */ import java.util.function.Supplier;
> /*      */ import java.util.stream.Collectors;
> /*      */ import java.util.stream.Stream;
> /*      */ import javax.swing.ListSelectionModel;
> /*      */ import javax.xml.parsers.DocumentBuilder;
> /*      */ import javax.xml.parsers.DocumentBuilderFactory;
> /*      */ import javax.xml.parsers.ParserConfigurationException;
> /*      */ import javax.xml.xpath.XPath;
> /*      */ import javax.xml.xpath.XPathConstants;
> /*      */ import javax.xml.xpath.XPathExpression;
> /*      */ import javax.xml.xpath.XPathExpressionException;
> /*      */ import javax.xml.xpath.XPathFactory;
> /*      */ import net.imglib2.RealLocalizable;
> /*      */ import org.jgrapht.graph.DefaultWeightedEdge;
> /*      */ import org.w3c.dom.Document;
> /*      */ import org.w3c.dom.Node;
> /*      */ import org.w3c.dom.NodeList;
> /*      */ import org.xml.sax.SAXException;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ public class ProcessTrackMateXml
> /*      */ {
> /*      */   Thread mainProcess;
> /*      */   String zstart;
> /*      */   String zend;
> /*      */   String ystart;
> /*      */   String yend;
> /*      */   String xstart;
> /*      */   String xend;
> /*      */   String tstart;
> /*      */   String tend;
> /*      */   String RADIUS;
> /*      */   String THRESHOLD;
> /*      */   String TARGET_CHANNEL;
> /*      */   String DO_SUBPIXEL_LOCALIZATION;
> /*      */   String DO_MEDIAN_FILTERING;
> /*      */   String DETECTOR_NAME;
> /*      */   String NSPLIT;
> /*      */   String DOWNSAMPLE_FACTOR;
> /*      */   String initialSpotFilter;
> /*  108 */   ImagePlus[] imps = FirstWizardPanel.imps;
> /*      */   
> /*      */   String TRACKER_NAME;
> /*      */   
> /*      */   String CUTOFF_PERCENTILE;
> /*      */   
> /*      */   String ALTERNATIVE_LINKING_COST_FACTOR;
> /*      */   
> /*      */   String LINKING_MAX_DISTANCE;
> /*      */   
> /*      */   String MAX_FRAME_GAP;
> /*      */   
> /*      */   String MAX_DISTANCE;
> /*      */   
> /*      */   String ALLOW_GAP_CLOSING;
> /*      */   
> /*      */   String SPLITTING_MAX_DISTANCE;
> /*      */   String ALLOW_TRACK_SPLITTING;
> /*      */   String MERGING_MAX_DISTANCE;
> /*      */   String ALLOW_TRACK_MERGING;
> /*      */   String BLOCKING_VALUE;
> /*      */   static Model model;
> /*      */   static Settings settings;
> /*      */   static SelectionModel selectionModel;
> /*      */   static TrackMate trackmate;
> /*      */   SpotCollection totalSpots;
> /*      */   static HyperStackDisplayer displayer;
> /*      */   ImagePlus impAnal;
> /*      */   static boolean tracksVisible;
> /*      */   static boolean spotsVisible;
> /*      */   static String[][] dataSpot;
> /*      */   static String[][] dataTrack;
> /*      */   static String[] columnHeadersSpot;
> /*      */   static String[] columnHeadersTrack;
> /*      */   static DisplaySettings ds;
> /*      */   public static final String NAME = "Export statistics to tables";
> /*      */   public static final String KEY = "EXPORT_STATS_TO_IJ";
> /*      */   public static final String INFO_TEXT = "<html>Compute and export all statistics to 3 ImageJ results table. Statistisc are separated in features computed for: <ol> \t<li> spots in filtered tracks; \t<li> links between those spots; \t<li> filtered tracks. </ol> For tracks and links, they are recalculated prior to exporting. Note that spots and links that are not in a filtered tracks are not part of this export.</html>";
> /*      */   private static final String SPOT_TABLE_NAME = "Spots in tracks statistics";
> /*      */   private static final String EDGE_TABLE_NAME = "Links in tracks statistics";
> /*      */   private static final String TRACK_TABLE_NAME = "Track statistics";
> /*      */   private static final String ID_COLUMN = "ID";
> /*      */   private static final String TRACK_ID_COLUMN = "TRACK_ID";
> /*      */   private ResultsTable spotTable;
> /*      */   private ResultsTable edgeTable;
> /*      */   private ResultsTable trackTable;
> /*      */   public static final String KEYLINEAR = "Linear track analysis";
> /*      */   public static final String TRACK_TOTAL_DISTANCE_TRAVELED = "TOTAL_DISTANCE_TRAVELED";
> /*      */   public static final String TRACK_MAX_DISTANCE_TRAVELED = "MAX_DISTANCE_TRAVELED";
> /*      */   public static final String TRACK_CONFINMENT_RATIO = "CONFINMENT_RATIO";
> /*      */   public static final String TRACK_MEAN_STRAIGHT_LINE_SPEED = "MEAN_STRAIGHT_LINE_SPEED";
> /*      */   public static final String TRACK_LINEARITY_OF_FORWARD_PROGRESSION = "LINEARITY_OF_FORWARD_PROGRESSION";
> /*      */   public static final String TOTAL_ABSOLUTE_ANGLE_XY = "TOTAL_ABSOLUTE_ANGLE_XY";
> /*      */   public static final String TOTAL_ABSOLUTE_ANGLE_YZ = "TOTAL_ABSOLUTE_ANGLE_YZ";
> /*      */   public static final String TOTAL_ABSOLUTE_ANGLE_ZX = "TOTAL_ABSOLUTE_ANGLE_ZX";
> /*  163 */   public static final List<String> FEATURES = new ArrayList<>(9);
> /*      */   
> /*  165 */   public static final Map<String, String> FEATURE_NAMES = new HashMap<>(9);
> /*      */   
> /*  167 */   public static final Map<String, String> FEATURE_SHORT_NAMES = new HashMap<>(9);
> /*      */   
> /*  169 */   public static final Map<String, Dimension> FEATURE_DIMENSIONS = new HashMap<>(9);
> /*      */   
> /*  171 */   public static final Map<String, Boolean> IS_INT = new HashMap<>(9);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public void processTrackMateXml() {
> /*  178 */     this.mainProcess = new Thread(new Runnable()
> /*      */         {
> /*      */ 
> /*      */           
> /*      */           public void run()
> /*      */           {
> /*  184 */             File fileXML = new File(TrackAnalyzer_.xmlPath);
> /*  185 */             List<ImagePlus> impAnalClose = new ArrayList<>();
> /*  186 */             int[] IDs = WindowManager.getIDList();
> /*  187 */             if (IDs != null)
> /*  188 */               for (int i1 = 0; i1 < IDs.length; i1++) {
> /*  189 */                 impAnalClose.add(WindowManager.getImage(IDs[i1]));
> /*      */               } 
> /*  191 */             if (FirstWizardPanel.spotEnable.equals("spotEnable") == Boolean.TRUE.booleanValue() && 
> /*  192 */               FirstWizardPanel.tableImages.getSelectedRow() != -1) {
> /*  193 */               if (IDs != null)
> /*  194 */                 for (int i1 = 0; i1 < IDs.length; i1++)
> /*  195 */                   ((ImagePlus)impAnalClose.get(i1)).hide();  
> /*  196 */               ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[FirstWizardPanel.tableImages.getSelectedRow()];
> /*      */             } 
> /*  198 */             if (FirstWizardPanel.spotEnable.equals("spotEnable") == Boolean.TRUE.booleanValue() && 
> /*  199 */               FirstWizardPanel.tableImages.getSelectedRow() == -1)
> /*  200 */               ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[ChooserWizardPanel.tableImages.getSelectedRow()]; 
> /*  201 */             if (ChooserWizardPanel.trackEnable.equals("trackEnable") == Boolean.TRUE.booleanValue() && 
> /*  202 */               ChooserWizardPanel.tableImages.getSelectedRow() != -1) {
> /*  203 */               if (IDs != null)
> /*  204 */                 for (int i1 = 0; i1 < IDs.length; i1++) {
> /*  205 */                   ((ImagePlus)impAnalClose.get(i1)).hide();
> /*      */                 } 
> /*  207 */               ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[ChooserWizardPanel.tableImages.getSelectedRow()];
> /*      */             } 
> /*  209 */             if (ChooserWizardPanel.trackEnable.equals("trackEnable") == Boolean.TRUE.booleanValue() && 
> /*  210 */               ChooserWizardPanel.tableImages.getSelectedRow() == -1) {
> /*  211 */               ProcessTrackMateXml.this.impAnal = ProcessTrackMateXml.this.imps[FirstWizardPanel.tableImages.getSelectedRow()];
> /*      */             }
> /*  213 */             ProcessTrackMateXml.this.impAnal.show();
> /*  214 */             int[] dims = ProcessTrackMateXml.this.impAnal.getDimensions();
> /*      */             
> /*  216 */             if (dims[4] == 1 && dims[3] > 1) {
> /*      */               
> /*  218 */               ProcessTrackMateXml.this.impAnal.setDimensions(dims[2], dims[4], dims[3]);
> /*  219 */               Calibration calibration = ProcessTrackMateXml.this.impAnal.getCalibration();
> /*  220 */               calibration.frameInterval = 1.0D;
> /*      */             } 
> /*      */ 
> /*      */             
> /*  224 */             TmXmlReader reader = new TmXmlReader(fileXML);
> /*  225 */             DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
> /*  226 */             DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
> /*  227 */             DocumentBuilder builder = null;
> /*      */             try {
> /*  229 */               builder = factory.newDocumentBuilder();
> /*  230 */             } catch (ParserConfigurationException e) {
> /*      */               
> /*  232 */               e.printStackTrace();
> /*      */             } 
> /*  234 */             Document doc = null;
> /*      */             try {
> /*  236 */               doc = builder.parse(TrackAnalyzer_.xmlPath);
> /*  237 */             } catch (SAXException e) {
> /*      */               
> /*  239 */               e.printStackTrace();
> /*  240 */             } catch (IOException e) {
> /*      */               
> /*  242 */               e.printStackTrace();
> /*      */             } 
> /*  244 */             XPathFactory xPathfactory = XPathFactory.newInstance();
> /*  245 */             XPath xpath = xPathfactory.newXPath();
> /*      */             
> /*  247 */             XPathExpression exprBasicSettings = null;
> /*  248 */             XPathExpression exprDetectorSettings = null;
> /*  249 */             XPathExpression exprInitialSpotFilter = null;
> /*  250 */             XPathExpression exprFilter = null;
> /*  251 */             XPathExpression exprTrackerSettings = null;
> /*  252 */             XPathExpression exprLinking = null;
> /*  253 */             XPathExpression exprGapClosing = null;
> /*  254 */             XPathExpression exprSplitting = null;
> /*  255 */             XPathExpression exprMerging = null;
> /*  256 */             XPathExpression exprTrackFilter = null;
> /*  257 */             XPathExpression exprLinkingP = null;
> /*      */ 
> /*      */             
> /*      */             try {
> /*  261 */               exprBasicSettings = xpath.compile("//Settings/BasicSettings[@zstart]");
> /*  262 */             } catch (XPathExpressionException e) {
> /*      */               
> /*  264 */               e.printStackTrace();
> /*      */             } 
> /*      */             
> /*      */             try {
> /*  268 */               exprLinkingP = xpath.compile("//Linking/FeaturePenalties[@MEAN_INTENSITY]");
> /*  269 */             } catch (XPathExpressionException e) {
> /*      */               
> /*  271 */               e.printStackTrace();
> /*      */             } 
> /*      */             
> /*      */             try {
> /*  275 */               exprDetectorSettings = xpath.compile("//Settings/DetectorSettings[@RADIUS]");
> /*  276 */             } catch (XPathExpressionException e) {
> /*      */               
> /*  278 */               e.printStackTrace();
> /*      */             } 
> /*      */             
> /*      */             try {
> /*  282 */               exprInitialSpotFilter = xpath.compile("//Settings/InitialSpotFilter[@feature]");
> /*  283 */             } catch (XPathExpressionException e) {
> /*      */               
> /*  285 */               e.printStackTrace();
> /*      */             } 
> /*      */             
> /*      */             try {
> /*  289 */               exprFilter = xpath.compile("//SpotFilterCollection/Filter[@feature]");
> /*  290 */             } catch (XPathExpressionException e) {
> /*      */               
> /*  292 */               e.printStackTrace();
> /*      */             } 
> /*      */ 
> /*      */             
> /*      */             try {
> /*  297 */               exprTrackerSettings = xpath.compile("//Settings/TrackerSettings[@TRACKER_NAME]");
> /*  298 */             } catch (XPathExpressionException e) {
> /*      */               
> /*  300 */               e.printStackTrace();
> /*      */             } 
> /*      */             
> /*      */             try {
> /*  304 */               exprLinking = xpath.compile("//TrackerSettings/Linking[@LINKING_MAX_DISTANCE]");
> /*  305 */             } catch (XPathExpressionException e) {
> /*      */               
> /*  307 */               e.printStackTrace();
> /*      */             } 
> /*      */             
> /*      */             try {
> /*  311 */               exprGapClosing = xpath.compile("//TrackerSettings/GapClosing[@MAX_FRAME_GAP]");
> /*  312 */             } catch (XPathExpressionException e) {
> /*      */               
> /*  314 */               e.printStackTrace();
> /*      */             } 
> /*      */             
> /*      */             try {
> /*  318 */               exprSplitting = xpath
> /*  319 */                 .compile("//TrackerSettings/TrackSplitting[@SPLITTING_MAX_DISTANCE]");
> /*  320 */             } catch (XPathExpressionException e) {
> /*      */               
> /*  322 */               e.printStackTrace();
> /*      */             } 
> /*      */             
> /*      */             try {
> /*  326 */               exprMerging = xpath
> /*  327 */                 .compile("//TrackerSettings/TrackMerging[@MERGING_MAX_DISTANCE]");
> /*  328 */             } catch (XPathExpressionException e) {
> /*      */               
> /*  330 */               e.printStackTrace();
> /*      */             } 
> /*      */             
> /*      */             try {
> /*  334 */               exprTrackFilter = xpath.compile("//TrackFilterCollection/Filter[@feature]");
> /*  335 */             } catch (XPathExpressionException e) {
> /*      */               
> /*  337 */               e.printStackTrace();
> /*      */             } 
> /*      */             
> /*  340 */             NodeList nlBasicSettings = null;
> /*  341 */             NodeList nlDetectorSettings = null;
> /*  342 */             NodeList nlInitialSpotFilter = null;
> /*  343 */             NodeList nlFilter = null;
> /*  344 */             NodeList nlTrackerSettings = null;
> /*  345 */             NodeList nlLinking = null;
> /*  346 */             NodeList nlGapClosing = null;
> /*  347 */             NodeList nlSplitting = null;
> /*  348 */             NodeList nlMerging = null;
> /*  349 */             NodeList nlTrackFilter = null;
> /*  350 */             NodeList nlLinkingP = null;
> /*      */             
> /*      */             try {
> /*  353 */               nlBasicSettings = (NodeList)exprBasicSettings.evaluate(doc, XPathConstants.NODESET);
> /*  354 */               nlDetectorSettings = (NodeList)exprDetectorSettings.evaluate(doc, XPathConstants.NODESET);
> /*  355 */               nlInitialSpotFilter = (NodeList)exprInitialSpotFilter.evaluate(doc, XPathConstants.NODESET);
> /*  356 */               nlFilter = (NodeList)exprFilter.evaluate(doc, XPathConstants.NODESET);
> /*  357 */               nlTrackerSettings = (NodeList)exprTrackerSettings.evaluate(doc, XPathConstants.NODESET);
> /*  358 */               nlLinking = (NodeList)exprLinking.evaluate(doc, XPathConstants.NODESET);
> /*  359 */               nlGapClosing = (NodeList)exprGapClosing.evaluate(doc, XPathConstants.NODESET);
> /*  360 */               nlSplitting = (NodeList)exprSplitting.evaluate(doc, XPathConstants.NODESET);
> /*  361 */               nlMerging = (NodeList)exprMerging.evaluate(doc, XPathConstants.NODESET);
> /*  362 */               nlTrackFilter = (NodeList)exprTrackFilter.evaluate(doc, XPathConstants.NODESET);
> /*  363 */               nlLinkingP = (NodeList)exprLinkingP.evaluate(doc, XPathConstants.NODESET);
> /*      */             }
> /*  365 */             catch (XPathExpressionException e) {
> /*      */               
> /*  367 */               e.printStackTrace();
> /*      */             } 
> /*      */             
> /*  370 */             for (int i = 0; i < nlBasicSettings.getLength(); i++) {
> /*  371 */               Node node = nlBasicSettings.item(i);
> /*  372 */               ProcessTrackMateXml.this.zstart = node.getAttributes().getNamedItem("zstart").getNodeValue();
> /*  373 */               ProcessTrackMateXml.this.zend = node.getAttributes().getNamedItem("zend").getNodeValue();
> /*  374 */               ProcessTrackMateXml.this.ystart = node.getAttributes().getNamedItem("ystart").getNodeValue();
> /*  375 */               ProcessTrackMateXml.this.yend = node.getAttributes().getNamedItem("yend").getNodeValue();
> /*  376 */               ProcessTrackMateXml.this.xstart = node.getAttributes().getNamedItem("xstart").getNodeValue();
> /*  377 */               ProcessTrackMateXml.this.xend = node.getAttributes().getNamedItem("xend").getNodeValue();
> /*  378 */               ProcessTrackMateXml.this.tstart = node.getAttributes().getNamedItem("tstart").getNodeValue();
> /*  379 */               ProcessTrackMateXml.this.tend = node.getAttributes().getNamedItem("tend").getNodeValue();
> /*      */             } 
> /*  381 */             Node currentItem = null;
> /*  382 */             for (int j = 0; j < nlDetectorSettings.getLength(); j++) {
> /*  383 */               currentItem = nlDetectorSettings.item(j);
> /*  384 */               ProcessTrackMateXml.this.RADIUS = currentItem.getAttributes().getNamedItem("RADIUS").getNodeValue();
> /*  385 */               ProcessTrackMateXml.this.THRESHOLD = currentItem.getAttributes().getNamedItem("THRESHOLD").getNodeValue();
> /*  386 */               ProcessTrackMateXml.this.TARGET_CHANNEL = currentItem.getAttributes().getNamedItem("TARGET_CHANNEL").getNodeValue();
> /*  387 */               ProcessTrackMateXml.this.DO_SUBPIXEL_LOCALIZATION = currentItem.getAttributes().getNamedItem("DO_SUBPIXEL_LOCALIZATION")
> /*  388 */                 .getNodeValue();
> /*  389 */               ProcessTrackMateXml.this.DO_MEDIAN_FILTERING = currentItem.getAttributes().getNamedItem("DO_MEDIAN_FILTERING")
> /*  390 */                 .getNodeValue();
> /*  391 */               ProcessTrackMateXml.this.DETECTOR_NAME = currentItem.getAttributes().getNamedItem("DETECTOR_NAME").getNodeValue();
> /*  392 */               if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("BLOCK_LOG_DETECTOR"))
> /*  393 */                 ProcessTrackMateXml.this.NSPLIT = currentItem.getAttributes().getNamedItem("NSPLIT").getNodeValue(); 
> /*  394 */               if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("DOWNSAMLE_LOG_DETECTOR")) {
> /*  395 */                 ProcessTrackMateXml.this.DOWNSAMPLE_FACTOR = currentItem.getAttributes().getNamedItem("DOWNSAMPLE_FACTOR")
> /*  396 */                   .getNodeValue();
> /*      */               }
> /*      */             } 
> /*      */             
> /*  400 */             String linkingNames = null;
> /*  401 */             String linkingValues = null; int k;
> /*  402 */             for (k = 0; k < nlLinkingP.getLength(); k++) {
> /*  403 */               linkingNames = nlLinkingP.item(k).getAttributes().item(k).getNodeName();
> /*  404 */               linkingValues = nlLinkingP.item(k).getAttributes().item(k).getNodeValue();
> /*      */             } 
> /*  406 */             for (k = 0; k < nlInitialSpotFilter.getLength(); k++) {
> /*  407 */               currentItem = nlInitialSpotFilter.item(k);
> /*  408 */               ProcessTrackMateXml.this.initialSpotFilter = currentItem.getAttributes().getNamedItem("value").getNodeValue();
> /*      */             } 
> /*      */             
> /*  411 */             String initialFilterFeature = null;
> /*  412 */             String initialFilterValue = null;
> /*  413 */             String initialFilterAbove = null;
> /*  414 */             for (int m = 0; m < nlFilter.getLength(); m++) {
> /*  415 */               currentItem = nlFilter.item(m);
> /*  416 */               initialFilterFeature = currentItem.getAttributes().getNamedItem("feature").getNodeValue();
> /*  417 */               initialFilterValue = currentItem.getAttributes().getNamedItem("value").getNodeValue();
> /*  418 */               initialFilterAbove = currentItem.getAttributes().getNamedItem("isabove").getNodeValue();
> /*      */             } 
> /*      */ 
> /*      */             
> /*  422 */             String initialTrackFilterFeature = null;
> /*  423 */             String initialTrackFilterValue = null;
> /*  424 */             String initialTrackFilterAbove = null;
> /*      */             int n;
> /*  426 */             for (n = 0; n < nlTrackerSettings.getLength(); n++) {
> /*  427 */               currentItem = nlTrackerSettings.item(n);
> /*  428 */               ProcessTrackMateXml.this.TRACKER_NAME = currentItem.getAttributes().getNamedItem("TRACKER_NAME").getNodeValue();
> /*  429 */               ProcessTrackMateXml.this.CUTOFF_PERCENTILE = currentItem.getAttributes().getNamedItem("CUTOFF_PERCENTILE").getNodeValue();
> /*  430 */               ProcessTrackMateXml.this.BLOCKING_VALUE = currentItem.getAttributes().getNamedItem("BLOCKING_VALUE").getNodeValue();
> /*  431 */               ProcessTrackMateXml.this.ALTERNATIVE_LINKING_COST_FACTOR = currentItem.getAttributes()
> /*  432 */                 .getNamedItem("ALTERNATIVE_LINKING_COST_FACTOR").getNodeValue();
> /*      */             } 
> /*  434 */             for (n = 0; n < nlLinking.getLength(); n++) {
> /*  435 */               currentItem = nlLinking.item(n);
> /*  436 */               ProcessTrackMateXml.this.LINKING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("LINKING_MAX_DISTANCE")
> /*  437 */                 .getNodeValue();
> /*      */             } 
> /*  439 */             for (n = 0; n < nlGapClosing.getLength(); n++) {
> /*  440 */               currentItem = nlGapClosing.item(n);
> /*  441 */               ProcessTrackMateXml.this.MAX_FRAME_GAP = currentItem.getAttributes().getNamedItem("MAX_FRAME_GAP").getNodeValue();
> /*  442 */               ProcessTrackMateXml.this.MAX_DISTANCE = currentItem.getAttributes().getNamedItem("GAP_CLOSING_MAX_DISTANCE").getNodeValue();
> /*  443 */               ProcessTrackMateXml.this.ALLOW_GAP_CLOSING = currentItem.getAttributes().getNamedItem("ALLOW_GAP_CLOSING").getNodeValue();
> /*      */             } 
> /*      */             
> /*  446 */             for (n = 0; n < nlSplitting.getLength(); n++) {
> /*  447 */               currentItem = nlSplitting.item(n);
> /*  448 */               ProcessTrackMateXml.this.SPLITTING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("SPLITTING_MAX_DISTANCE")
> /*  449 */                 .getNodeValue();
> /*  450 */               ProcessTrackMateXml.this.ALLOW_TRACK_SPLITTING = currentItem.getAttributes().getNamedItem("ALLOW_TRACK_SPLITTING")
> /*  451 */                 .getNodeValue();
> /*      */             } 
> /*  453 */             for (n = 0; n < nlMerging.getLength(); n++) {
> /*  454 */               currentItem = nlMerging.item(n);
> /*  455 */               ProcessTrackMateXml.this.MERGING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("MERGING_MAX_DISTANCE")
> /*  456 */                 .getNodeValue();
> /*  457 */               ProcessTrackMateXml.this.ALLOW_TRACK_MERGING = currentItem.getAttributes().getNamedItem("ALLOW_TRACK_MERGING")
> /*  458 */                 .getNodeValue();
> /*      */             } 
> /*      */             
> /*  461 */             ProcessTrackMateXml.settings = new Settings(ProcessTrackMateXml.this.impAnal);
> /*      */             
> /*  463 */             ProcessTrackMateXml.settings.dt = 0.05D;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */             
> /*  481 */             if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("LOG_DETECTOR")) {
> /*      */               
> /*  483 */               ProcessTrackMateXml.settings.detectorFactory = (SpotDetectorFactoryBase)new LogDetectorFactory();
> /*  484 */               ProcessTrackMateXml.settings.detectorSettings = ProcessTrackMateXml.settings.detectorFactory.getDefaultSettings();
> /*  485 */               ProcessTrackMateXml.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", 
> /*  486 */                   Boolean.valueOf(Boolean.parseBoolean(ProcessTrackMateXml.this.DO_SUBPIXEL_LOCALIZATION)));
> /*  487 */               ProcessTrackMateXml.settings.detectorSettings.put("RADIUS", Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.RADIUS)));
> /*  488 */               ProcessTrackMateXml.settings.detectorSettings.put("TARGET_CHANNEL", Integer.valueOf(Integer.parseInt(ProcessTrackMateXml.this.TARGET_CHANNEL)));
> /*  489 */               ProcessTrackMateXml.settings.detectorSettings.put("THRESHOLD", Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.THRESHOLD)));
> /*  490 */               ProcessTrackMateXml.settings.detectorSettings.put("DO_MEDIAN_FILTERING", 
> /*  491 */                   Boolean.valueOf(Boolean.parseBoolean(ProcessTrackMateXml.this.DO_MEDIAN_FILTERING)));
> /*  492 */               if (ProcessTrackMateXml.this.initialSpotFilter != null) {
> /*  493 */                 ProcessTrackMateXml.settings.initialSpotFilterValue = Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.initialSpotFilter));
> /*      */               }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */               
> /*  508 */               if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("MANUAL_DETECTOR")) {
> /*      */                 
> /*  510 */                 ProcessTrackMateXml.settings.detectorFactory = (SpotDetectorFactoryBase)new ManualDetectorFactory();
> /*  511 */                 ProcessTrackMateXml.settings.detectorSettings.put("RADIUS", Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.RADIUS)));
> /*  512 */                 if (ProcessTrackMateXml.this.initialSpotFilter != null) {
> /*  513 */                   ProcessTrackMateXml.settings.initialSpotFilterValue = Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.initialSpotFilter));
> /*      */                 }
> /*      */               } 
> /*      */               
> /*  517 */               if (ProcessTrackMateXml.this.DETECTOR_NAME.equals("DOG_DETECTOR")) {
> /*  518 */                 ProcessTrackMateXml.settings.detectorFactory = (SpotDetectorFactoryBase)new DogDetectorFactory();
> /*  519 */                 ProcessTrackMateXml.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", 
> /*  520 */                     Boolean.valueOf(Boolean.parseBoolean(ProcessTrackMateXml.this.DO_SUBPIXEL_LOCALIZATION)));
> /*  521 */                 ProcessTrackMateXml.settings.detectorSettings.put("RADIUS", Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.RADIUS)));
> /*  522 */                 ProcessTrackMateXml.settings.detectorSettings.put("TARGET_CHANNEL", 
> /*  523 */                     Integer.valueOf(Integer.parseInt(ProcessTrackMateXml.this.TARGET_CHANNEL)));
> /*  524 */                 ProcessTrackMateXml.settings.detectorSettings.put("THRESHOLD", Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.THRESHOLD)));
> /*  525 */                 ProcessTrackMateXml.settings.detectorSettings.put("DO_MEDIAN_FILTERING", 
> /*  526 */                     Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.DO_MEDIAN_FILTERING)));
> /*  527 */                 if (ProcessTrackMateXml.this.initialSpotFilter != null) {
> /*  528 */                   ProcessTrackMateXml.settings.initialSpotFilterValue = Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.initialSpotFilter));
> /*      */                 }
> /*      */               } 
> /*      */               
> /*  532 */               if (initialFilterFeature != null) {
> /*      */                 
> /*  534 */                 FeatureFilter filter1 = new FeatureFilter(initialFilterFeature, 
> /*  535 */                     Double.parseDouble(initialFilterValue), Boolean.parseBoolean(initialFilterAbove));
> /*      */                 
> /*  537 */                 ProcessTrackMateXml.settings.addSpotFilter(filter1);
> /*      */               } 
> /*      */             } 
> /*      */ 
> /*      */             
> /*  542 */             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
> /*      */               
> /*  544 */               ProcessTrackMateXml.settings.trackerFactory = (SpotTrackerFactory)new ManualTrackerFactory();
> /*  545 */               ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
> /*      */             } 
> /*      */             
> /*  548 */             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
> /*  549 */               ProcessTrackMateXml.settings.trackerFactory = (SpotTrackerFactory)new ManualTrackerFactory();
> /*  550 */               ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
> /*      */             } 
> /*      */ 
> /*      */             
> /*  554 */             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("KALMAN_TRACKER")) {
> /*      */               
> /*  556 */               ProcessTrackMateXml.settings.trackerFactory = (SpotTrackerFactory)new KalmanTrackerFactory();
> /*  557 */               ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
> /*  558 */               ProcessTrackMateXml.settings.trackerSettings.put("KALMAN_SEARCH_RADIUS", 
> /*  559 */                   Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.RADIUS)));
> /*      */             } 
> /*      */ 
> /*      */             
> /*  563 */             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("SIMPLE_SPARSE_LAP_TRACKER")) {
> /*      */               
> /*  565 */               ProcessTrackMateXml.settings.trackerFactory = (SpotTrackerFactory)new SimpleSparseLAPTrackerFactory();
> /*  566 */               ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
> /*  567 */               ProcessTrackMateXml.settings.trackerSettings.put("LINKING_MAX_DISTANCE", 
> /*  568 */                   Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.LINKING_MAX_DISTANCE)));
> /*  569 */               ProcessTrackMateXml.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", 
> /*  570 */                   Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.MAX_DISTANCE)));
> /*  571 */               ProcessTrackMateXml.settings.trackerSettings.put("MAX_FRAME_GAP", 
> /*  572 */                   Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.MAX_FRAME_GAP)));
> /*      */             } 
> /*      */ 
> /*      */             
> /*  576 */             if (ProcessTrackMateXml.this.TRACKER_NAME.equals("SPARSE_LAP_TRACKER")) {
> /*      */               
> /*  578 */               ProcessTrackMateXml.settings.trackerFactory = (SpotTrackerFactory)new SparseLAPTrackerFactory();
> /*  579 */               ProcessTrackMateXml.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
> /*  580 */               ProcessTrackMateXml.settings.trackerSettings.put("LINKING_MAX_DISTANCE", 
> /*  581 */                   Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.LINKING_MAX_DISTANCE)));
> /*  582 */               Map<String, Double> linkingPenalty = 
> /*  583 */                 (Map<String, Double>)Stream.<Object[]>of(new Object[][] { { "MEAN_INTENSITY", Double.valueOf(1.0D) }, { "QUALITY", Double.valueOf(1.0D)
> /*      */                     }
> /*  585 */                   }).collect(Collectors.toMap(data -> (String)data[0], data -> (Double)data[1]));
> /*      */               
> /*  587 */               ProcessTrackMateXml.settings.trackerSettings.put("ALLOW_GAP_CLOSING", 
> /*  588 */                   Boolean.valueOf(Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_GAP_CLOSING)));
> /*  589 */               if (Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_GAP_CLOSING)) {
> /*  590 */                 ProcessTrackMateXml.settings.trackerSettings.put("MAX_FRAME_GAP", 
> /*  591 */                     Integer.valueOf(Integer.parseInt(ProcessTrackMateXml.this.MAX_FRAME_GAP)));
> /*  592 */                 ProcessTrackMateXml.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", 
> /*  593 */                     Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.MAX_DISTANCE)));
> /*      */                 
> /*  595 */                 Map map = 
> /*  596 */                   (Map)Stream.<Object[]>of(new Object[][] { { "MEAN_INTENSITY", Double.valueOf(1.0D) }, { "QUALITY", Double.valueOf(1.0D)
> /*  597 */                       } }).collect(Collectors.toMap(data -> (String)data[0], data -> (Double)data[1]));
> /*      */               } 
> /*      */ 
> /*      */               
> /*  601 */               ProcessTrackMateXml.settings.trackerSettings.put("ALLOW_TRACK_SPLITTING", 
> /*  602 */                   Boolean.valueOf(Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_SPLITTING)));
> /*  603 */               if (Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_SPLITTING)) {
> /*  604 */                 ProcessTrackMateXml.settings.trackerSettings.put("SPLITTING_MAX_DISTANCE", 
> /*  605 */                     Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.SPLITTING_MAX_DISTANCE)));
> /*  606 */                 Map map = 
> /*  607 */                   (Map)Stream.<Object[]>of(new Object[][] { { "MEAN_INTENSITY", Double.valueOf(1.0D) }, { "QUALITY", Double.valueOf(1.0D)
> /*  608 */                       } }).collect(Collectors.toMap(data -> (String)data[0], data -> (Double)data[1]));
> /*      */               } 
> /*      */ 
> /*      */               
> /*  612 */               ProcessTrackMateXml.settings.trackerSettings.put("ALLOW_TRACK_MERGING", 
> /*  613 */                   Boolean.valueOf(Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_MERGING)));
> /*  614 */               if (Boolean.parseBoolean(ProcessTrackMateXml.this.ALLOW_TRACK_MERGING)) {
> /*  615 */                 ProcessTrackMateXml.settings.trackerSettings.put("MERGING_MAX_DISTANCE", 
> /*  616 */                     Double.valueOf(Double.parseDouble(ProcessTrackMateXml.this.MERGING_MAX_DISTANCE)));
> /*  617 */                 Map map = 
> /*  618 */                   (Map)Stream.<Object[]>of(new Object[][] { { "MEAN_INTENSITY", Double.valueOf(1.0D) }, { "QUALITY", Double.valueOf(1.0D)
> /*  619 */                       } }).collect(Collectors.toMap(data -> (String)data[0], data -> (Double)data[1]));
> /*      */               } 
> /*      */             } 
> /*      */ 
> /*      */ 
> /*      */             
> /*  625 */             ProcessTrackMateXml.settings.addAllAnalyzers();
> /*      */             
> /*  627 */             ProcessTrackMateXml.model = new Model();
> /*  628 */             ProcessTrackMateXml.trackmate = new TrackMate(ProcessTrackMateXml.model, ProcessTrackMateXml.settings);
> /*      */             
> /*  630 */             Boolean ok = null;
> /*      */             
> /*  632 */             ok = Boolean.valueOf(ProcessTrackMateXml.trackmate.checkInput());
> /*  633 */             ok = Boolean.valueOf(ProcessTrackMateXml.trackmate.process());
> /*      */             
> /*  635 */             FeatureModel fm = ProcessTrackMateXml.model.getFeatureModel();
> /*  636 */             Set<Integer> trackIDs = ProcessTrackMateXml.model.getTrackModel().trackIDs(true);
> /*  637 */             Set<Spot> track = null;
> /*  638 */             for (int id = 0; id < trackIDs.size(); id++) {
> /*  639 */               Double v = fm.getTrackFeature(Integer.valueOf(id), "TRACK_MEAN_SPEED");
> /*  640 */               track = ProcessTrackMateXml.model.getTrackModel().trackSpots(Integer.valueOf(id));
> /*      */             } 
> /*      */             
> /*  643 */             for (Spot spot : track) {
> /*  644 */               int sid = spot.ID();
> /*  645 */               Double x = spot.getFeature("POSITION_X");
> /*  646 */               Double y = spot.getFeature("POSITION_Y");
> /*  647 */               Double t = spot.getFeature("FRAME");
> /*  648 */               Double q = spot.getFeature("QUALITY");
> /*  649 */               Double snr = spot.getFeature("SNR");
> /*  650 */               Double double_1 = spot.getFeature("MEAN_INTENSITY");
> /*      */             } 
> /*  652 */             ProcessTrackMateXml.this.totalSpots = ProcessTrackMateXml.model.getSpots();
> /*  653 */             ProcessTrackMateXml.displayer = null;
> /*  654 */             ProcessTrackMateXml.selectionModel = new SelectionModel(ProcessTrackMateXml.model);
> /*  655 */             ProcessTrackMateXml.ds = DisplaySettingsIO.readUserDefault();
> /*  656 */             ProcessTrackMateXml.ds.setSpotShowName(true);
> /*  657 */             ProcessTrackMateXml.ds.setSpotVisible(ProcessTrackMateXml.spotsVisible);
> /*  658 */             ProcessTrackMateXml.ds.setSpotColorBy(DisplaySettings.TrackMateObject.TRACKS, "TRACK_INDEX");
> /*  659 */             ProcessTrackMateXml.ds.setTrackVisible(ProcessTrackMateXml.tracksVisible);
> /*  660 */             ProcessTrackMateXml.ds.setTrackColorBy(DisplaySettings.TrackMateObject.TRACKS, "TRACK_INDEX");
> /*  661 */             ProcessTrackMateXml.ds.setTrackDisplayMode(DisplaySettings.TrackDisplayMode.FULL);
> /*  662 */             ProcessTrackMateXml.displayer = new HyperStackDisplayer(ProcessTrackMateXml.model, ProcessTrackMateXml.selectionModel, ProcessTrackMateXml.this.impAnal, ProcessTrackMateXml.ds);
> /*  663 */             ProcessTrackMateXml.displayer.render();
> /*  664 */             ProcessTrackMateXml.displayer.refresh();
> /*      */             
> /*  666 */             Rectangle bounds = null;
> /*  667 */             Integer firstFrame = null;
> /*  668 */             Integer lastFrame = null;
> /*  669 */             Integer width = null;
> /*  670 */             Integer height = null;
> /*  671 */             Integer nCaptures = null;
> /*  672 */             ImageStack stack = null;
> /*  673 */             Integer channel = null;
> /*  674 */             Integer slice = null;
> /*  675 */             BufferedImage bi = null;
> /*  676 */             ColorProcessor cp = null;
> /*  677 */             Integer index = null;
> /*  678 */             ImagePlus capture = null;
> /*      */             
> /*  680 */             if (ProcessTrackMateXml.this.impAnal.getNFrames() > 1) {
> /*  681 */               firstFrame = Integer.valueOf(Math.max(1, Math.min(ProcessTrackMateXml.this.impAnal.getNFrames(), 1)));
> /*  682 */               lastFrame = Integer.valueOf(Math.min(ProcessTrackMateXml.this.impAnal.getNFrames(), Math.max(ProcessTrackMateXml.this.impAnal.getNFrames(), 1)));
> /*      */             } 
> /*  684 */             if (ProcessTrackMateXml.this.impAnal.getNSlices() > 1) {
> /*  685 */               firstFrame = Integer.valueOf(Math.max(1, Math.min(ProcessTrackMateXml.this.impAnal.getNSlices(), 1)));
> /*  686 */               lastFrame = Integer.valueOf(Math.min(ProcessTrackMateXml.this.impAnal.getNSlices(), Math.max(ProcessTrackMateXml.this.impAnal.getNSlices(), 1)));
> /*      */             } 
> /*  688 */             bounds = ProcessTrackMateXml.displayer.getImp().getCanvas().getBounds();
> /*  689 */             width = Integer.valueOf(bounds.width);
> /*  690 */             height = Integer.valueOf(bounds.height);
> /*  691 */             nCaptures = Integer.valueOf(lastFrame.intValue() - firstFrame.intValue() + 1);
> /*  692 */             stack = new ImageStack(width.intValue(), height.intValue());
> /*      */             
> /*  694 */             channel = Integer.valueOf(ProcessTrackMateXml.displayer.getImp().getChannel());
> /*  695 */             slice = Integer.valueOf(ProcessTrackMateXml.displayer.getImp().getSlice());
> /*  696 */             ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(true);
> /*  697 */             for (int frame = firstFrame.intValue(); frame <= lastFrame.intValue(); frame++) {
> /*  698 */               ProcessTrackMateXml.displayer.getImp().setPositionWithoutUpdate(channel.intValue(), slice.intValue(), frame);
> /*  699 */               bi = new BufferedImage(width.intValue(), height.intValue(), 2);
> /*  700 */               ProcessTrackMateXml.displayer.getImp().getCanvas().paint(bi.getGraphics());
> /*  701 */               cp = new ColorProcessor(bi);
> /*  702 */               index = Integer.valueOf(ProcessTrackMateXml.displayer.getImp().getStackIndex(channel.intValue(), slice.intValue(), frame));
> /*  703 */               stack.addSlice(ProcessTrackMateXml.displayer.getImp().getImageStack().getSliceLabel(index.intValue()), (ImageProcessor)cp);
> /*      */             } 
> /*  705 */             ProcessTrackMateXml.displayer.getImp().getCanvas().hideZoomIndicator(false);
> /*  706 */             capture = new ImagePlus("TrackMate capture of " + ProcessTrackMateXml.displayer.getImp().getShortTitle(), stack);
> /*  707 */             ProcessTrackMateXml.transferCalibration(ProcessTrackMateXml.displayer.getImp(), capture);
> /*      */             
> /*  709 */             if (FirstWizardPanel.spotEnable.equals("spotEnable") == Boolean.TRUE.booleanValue()) {
> /*      */ 
> /*      */               
> /*  712 */               final Model model = ProcessTrackMateXml.trackmate.getModel();
> /*  713 */               FeatureModel fm1 = model.getFeatureModel();
> /*      */ 
> /*      */ 
> /*      */               
> /*  717 */               Set<Integer> trackIDs1 = model.getTrackModel().trackIDs(true);
> /*  718 */               Collection<String> spotFeatures = ProcessTrackMateXml.trackmate.getModel().getFeatureModel().getSpotFeatures();
> /*      */               
> /*  720 */               ResultsTable spotTable = new ResultsTable();
> /*      */ 
> /*      */               
> /*  723 */               for (Integer trackID : trackIDs1) {
> /*  724 */                 Set<Spot> track1 = model.getTrackModel().trackSpots(trackID);
> /*      */                 
> /*  726 */                 List<Spot> sortedTrack = new ArrayList<>(track1);
> /*  727 */                 Collections.sort(sortedTrack, Spot.frameComparator);
> /*      */                 
> /*  729 */                 for (Spot spot : sortedTrack) {
> /*  730 */                   spotTable.incrementCounter();
> /*  731 */                   spotTable.addLabel(spot.getName());
> /*  732 */                   spotTable.addValue("ID", spot.ID());
> /*  733 */                   spotTable.addValue("TRACK_ID", trackID.intValue());
> /*  734 */                   for (String feature : spotFeatures) {
> /*  735 */                     Double val = spot.getFeature(feature);
> /*  736 */                     if (val == null) {
> /*  737 */                       spotTable.addValue(feature, "None"); continue;
> /*      */                     } 
> /*  739 */                     if (((Boolean)fm1.getSpotFeatureIsInt().get(feature)).booleanValue()) {
> /*  740 */                       spotTable.addValue(feature, val.intValue()); continue;
> /*      */                     } 
> /*  742 */                     spotTable.addValue(feature, val.doubleValue());
> /*      */                   } 
> /*      */                 } 
> /*      */               } 
> /*      */ 
> /*      */ 
> /*      */               
> /*  749 */               ProcessTrackMateXml.columnHeadersSpot = spotTable.getHeadings();
> /*  750 */               int rowsSpot = spotTable.size();
> /*  751 */               List<List<String>> dataListSpot = new ArrayList<>();
> /*  752 */               for (int r = 0; r < rowsSpot; r++) {
> /*  753 */                 List<String> stringsSpot = new ArrayList<>();
> /*  754 */                 for (int c = 0; c < ProcessTrackMateXml.columnHeadersSpot.length; c++) {
> /*  755 */                   String valuesSpot = spotTable.getStringValue(ProcessTrackMateXml.columnHeadersSpot[c], r);
> /*  756 */                   stringsSpot.add(valuesSpot);
> /*      */                 } 
> /*      */                 
> /*  759 */                 dataListSpot.add(stringsSpot);
> /*      */               } 
> /*  761 */               ProcessTrackMateXml.dataSpot = new String[dataListSpot.size()][]; int i1;
> /*  762 */               for (i1 = 0; i1 < ProcessTrackMateXml.dataSpot.length; i1++) {
> /*  763 */                 ProcessTrackMateXml.dataSpot[i1] = new String[((List)dataListSpot.get(i1)).size()];
> /*      */               }
> /*  765 */               for (i1 = 0; i1 < dataListSpot.size(); i1++) {
> /*  766 */                 for (int u = 1; u < ((List)dataListSpot.get(i1)).size(); u++)
> /*  767 */                   ProcessTrackMateXml.dataSpot[i1][u] = ((List<String>)dataListSpot.get(i1)).get(u); 
> /*      */               } 
> /*  769 */               FirstWizardPanel.createSpotTable();
> /*      */               
> /*  771 */               FirstWizardPanel.tableSpot.addMouseListener(new MouseAdapter()
> /*      */                   {
> /*      */                     public void mouseReleased(MouseEvent e)
> /*      */                     {
> /*  775 */                       if (ProcessTrackMateXml.selectionModel != null && FirstWizardPanel.command == "enable" && 
> /*  776 */                         FirstWizardPanel.command != null) {
> /*  777 */                         ListSelectionModel lsm = FirstWizardPanel.tableSpot.getSelectionModel();
> /*  778 */                         int selStart = lsm.getMinSelectionIndex();
> /*  779 */                         int selEnd = lsm.getMaxSelectionIndex();
> /*  780 */                         if (selStart < 0 || selEnd < 0) {
> /*      */                           return;
> /*      */                         }
> /*  783 */                         int minLine = Math.min(selStart, selEnd);
> /*  784 */                         int maxLine = Math.max(selStart, selEnd);
> /*  785 */                         Set<Spot> spots = new HashSet<>();
> /*  786 */                         for (int row = minLine; row <= maxLine; row++) {
> /*  787 */                           int spotID = 
> /*  788 */                             Integer.parseInt((String)FirstWizardPanel.tableSpot.getValueAt(row, 2));
> /*  789 */                           Spot spot = (ProcessTrackMateXml.null.access$8(ProcessTrackMateXml.null.this)).totalSpots.search(spotID);
> /*  790 */                           if (spot != null)
> /*  791 */                             spots.add(spot); 
> /*      */                         } 
> /*  793 */                         ProcessTrackMateXml.selectionModel.clearSelection();
> /*  794 */                         ProcessTrackMateXml.selectionModel.addSpotToSelection(spots);
> /*      */                       } 
> /*      */                     }
> /*      */                   });
> /*      */             } 
> /*      */ 
> /*      */             
> /*  801 */             if (ChooserWizardPanel.trackEnable.equals("trackEnable") == Boolean.TRUE.booleanValue()) {
> /*      */               
> /*  803 */               ProcessTrackMateXml.FEATURES.add("TOTAL_DISTANCE_TRAVELED");
> /*  804 */               ProcessTrackMateXml.FEATURES.add("MAX_DISTANCE_TRAVELED");
> /*  805 */               ProcessTrackMateXml.FEATURES.add("CONFINMENT_RATIO");
> /*  806 */               ProcessTrackMateXml.FEATURES.add("MEAN_STRAIGHT_LINE_SPEED");
> /*  807 */               ProcessTrackMateXml.FEATURES.add("LINEARITY_OF_FORWARD_PROGRESSION");
> /*      */               
> /*  809 */               ProcessTrackMateXml.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_XY");
> /*  810 */               ProcessTrackMateXml.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_YZ");
> /*  811 */               ProcessTrackMateXml.FEATURES.add("TOTAL_ABSOLUTE_ANGLE_ZX");
> /*      */               
> /*  813 */               ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total distance traveled");
> /*  814 */               ProcessTrackMateXml.FEATURE_NAMES.put("MAX_DISTANCE_TRAVELED", "Max distance traveled");
> /*  815 */               ProcessTrackMateXml.FEATURE_NAMES.put("CONFINMENT_RATIO", "Confinment ratio");
> /*  816 */               ProcessTrackMateXml.FEATURE_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean straight line speed");
> /*  817 */               ProcessTrackMateXml.FEATURE_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Linearity of forward progression");
> /*      */ 
> /*      */               
> /*  820 */               ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Absolute angle in xy plane");
> /*  821 */               ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Absolute angle in yz plane");
> /*  822 */               ProcessTrackMateXml.FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Absolute angle in zx plane");
> /*      */               
> /*  824 */               ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total dist.");
> /*  825 */               ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("MAX_DISTANCE_TRAVELED", "Max dist.");
> /*  826 */               ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("CONFINMENT_RATIO", "Cnfnmnt ratio");
> /*  827 */               ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean v. line");
> /*  828 */               ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Lin. fwd. progr.");
> /*      */ 
> /*      */               
> /*  831 */               ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Abs. angle xy");
> /*  832 */               ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Abs. angle yz");
> /*  833 */               ProcessTrackMateXml.FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Abs. angle zx");
> /*      */               
> /*  835 */               ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_DISTANCE_TRAVELED", Dimension.LENGTH);
> /*  836 */               ProcessTrackMateXml.FEATURE_DIMENSIONS.put("MAX_DISTANCE_TRAVELED", Dimension.LENGTH);
> /*  837 */               ProcessTrackMateXml.FEATURE_DIMENSIONS.put("CONFINMENT_RATIO", Dimension.NONE);
> /*  838 */               ProcessTrackMateXml.FEATURE_DIMENSIONS.put("MEAN_STRAIGHT_LINE_SPEED", Dimension.VELOCITY);
> /*  839 */               ProcessTrackMateXml.FEATURE_DIMENSIONS.put("LINEARITY_OF_FORWARD_PROGRESSION", Dimension.NONE);
> /*      */               
> /*  841 */               ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_XY", Dimension.ANGLE);
> /*  842 */               ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_YZ", Dimension.ANGLE);
> /*  843 */               ProcessTrackMateXml.FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_ZX", Dimension.ANGLE);
> /*      */               
> /*  845 */               ProcessTrackMateXml.IS_INT.put("TOTAL_DISTANCE_TRAVELED", Boolean.FALSE);
> /*  846 */               ProcessTrackMateXml.IS_INT.put("MAX_DISTANCE_TRAVELED", Boolean.FALSE);
> /*  847 */               ProcessTrackMateXml.IS_INT.put("CONFINMENT_RATIO", Boolean.FALSE);
> /*  848 */               ProcessTrackMateXml.IS_INT.put("MEAN_STRAIGHT_LINE_SPEED", Boolean.FALSE);
> /*  849 */               ProcessTrackMateXml.IS_INT.put("LINEARITY_OF_FORWARD_PROGRESSION", Boolean.FALSE);
> /*      */               
> /*  851 */               ProcessTrackMateXml.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_XY", Boolean.FALSE);
> /*  852 */               ProcessTrackMateXml.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_YZ", Boolean.FALSE);
> /*  853 */               ProcessTrackMateXml.IS_INT.put("TOTAL_ABSOLUTE_ANGLE_ZX", Boolean.FALSE);
> /*      */ 
> /*      */               
> /*  856 */               final Model model = ProcessTrackMateXml.trackmate.getModel();
> /*  857 */               FeatureModel fm1 = model.getFeatureModel();
> /*      */ 
> /*      */               
> /*  860 */               Set<Integer> trackIDs1 = model.getTrackModel().trackIDs(true);
> /*      */ 
> /*      */               
> /*  863 */               ProcessTrackMateXml.this.trackTable = new ResultsTable();
> /*      */ 
> /*      */               
> /*  866 */               for (Integer trackID : trackIDs1) {
> /*      */                 
> /*  868 */                 List<Spot> spots = new ArrayList<>(model.getTrackModel().trackSpots(trackID));
> /*  869 */                 Collections.sort(spots, Spot.frameComparator);
> /*  870 */                 Spot first = spots.get(0);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                 
> /*  876 */                 Set<DefaultWeightedEdge> edges = model.getTrackModel().trackEdges(trackID);
> /*      */                 
> /*  878 */                 double totalDistance = 0.0D;
> /*  879 */                 double maxDistanceSq = Double.NEGATIVE_INFINITY;
> /*  880 */                 double maxDistance = 0.0D;
> /*  881 */                 double dx = 0.0D;
> /*  882 */                 double dy = 0.0D;
> /*  883 */                 double dz = 0.0D;
> /*      */                 
> /*  885 */                 for (DefaultWeightedEdge edge : edges) {
> /*      */                   
> /*  887 */                   Spot source = model.getTrackModel().getEdgeSource(edge);
> /*  888 */                   Spot target = model.getTrackModel().getEdgeTarget(edge);
> /*  889 */                   double d = Math.sqrt(source.squareDistanceTo((RealLocalizable)target));
> /*  890 */                   totalDistance += d;
> /*      */ 
> /*      */                   
> /*  893 */                   double dToFirstSq = first.squareDistanceTo((RealLocalizable)target);
> /*  894 */                   if (dToFirstSq > maxDistanceSq) {
> /*  895 */                     maxDistanceSq = dToFirstSq;
> /*  896 */                     maxDistance = Math.sqrt(maxDistanceSq);
> /*      */                   } 
> /*      */                   
> /*  899 */                   dx += target.getDoublePosition(0) - source.getDoublePosition(0);
> /*  900 */                   dy += target.getDoublePosition(1) - source.getDoublePosition(1);
> /*  901 */                   dz += target.getDoublePosition(2) - source.getDoublePosition(2);
> /*      */                 } 
> /*      */ 
> /*      */                 
> /*  905 */                 double netDistance = fm1.getTrackFeature(trackID, 
> /*  906 */                     "TRACK_DISPLACEMENT").doubleValue();
> /*  907 */                 double tTotal = fm1.getTrackFeature(trackID, "TRACK_DURATION").doubleValue();
> /*  908 */                 double vMean = fm1.getTrackFeature(trackID, 
> /*  909 */                     "TRACK_MEAN_SPEED").doubleValue();
> /*      */ 
> /*      */                 
> /*  912 */                 double confinmentRatio = netDistance / totalDistance;
> /*  913 */                 double meanStraightLineSpeed = netDistance / tTotal;
> /*  914 */                 double linearityForwardProgression = meanStraightLineSpeed / vMean;
> /*      */ 
> /*      */ 
> /*      */                 
> /*  918 */                 double angleXY = Math.atan2(dy, dx);
> /*  919 */                 double angleYZ = Math.atan2(dz, dy);
> /*  920 */                 double angleZX = Math.atan2(dx, dz);
> /*  921 */                 Collection<String> trackFeatures = fm1.getTrackFeatures();
> /*  922 */                 ProcessTrackMateXml.this.trackTable.incrementCounter();
> /*  923 */                 ProcessTrackMateXml.this.trackTable.addLabel(model.getTrackModel().name(trackID));
> /*  924 */                 ProcessTrackMateXml.this.trackTable.addValue("TRACK_ID", trackID.intValue());
> /*      */                 
> /*  926 */                 for (String feature : trackFeatures) {
> /*  927 */                   Double val = fm1.getTrackFeature(trackID, feature);
> /*  928 */                   if (val == null) {
> /*  929 */                     ProcessTrackMateXml.this.trackTable.addValue(feature, "None"); continue;
> /*      */                   } 
> /*  931 */                   if (((Boolean)fm1.getTrackFeatureIsInt().get(feature)).booleanValue()) {
> /*  932 */                     ProcessTrackMateXml.this.trackTable.addValue(feature, val.intValue()); continue;
> /*      */                   } 
> /*  934 */                   ProcessTrackMateXml.this.trackTable.addValue(feature, val.doubleValue());
> /*      */                 } 
> /*      */ 
> /*      */ 
> /*      */                 
> /*  939 */                 ProcessTrackMateXml.this.trackTable.addValue("TOTAL_DISTANCE_TRAVELED", 
> /*  940 */                     Math.round(totalDistance * 1000.0D) / 1000.0D);
> /*  941 */                 ProcessTrackMateXml.this.trackTable.addValue("MAX_DISTANCE_TRAVELED", 
> /*  942 */                     Math.round(maxDistance * 1000.0D) / 1000.0D);
> /*  943 */                 ProcessTrackMateXml.this.trackTable.addValue("MEAN_STRAIGHT_LINE_SPEED", 
> /*  944 */                     Math.round(meanStraightLineSpeed * 1000.0D) / 1000.0D);
> /*  945 */                 ProcessTrackMateXml.this.trackTable.addValue("LINEARITY_OF_FORWARD_PROGRESSION", 
> /*  946 */                     Math.round(linearityForwardProgression * 1000.0D) / 1000.0D);
> /*  947 */                 ProcessTrackMateXml.this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_XY", Math.round(angleXY * 1000.0D) / 1000.0D);
> /*  948 */                 ProcessTrackMateXml.this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_YZ", Math.round(angleYZ * 1000.0D) / 1000.0D);
> /*  949 */                 ProcessTrackMateXml.this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_ZX", Math.round(angleZX * 1000.0D) / 1000.0D);
> /*  950 */                 ProcessTrackMateXml.this.trackTable.addValue("CONFINMENT_RATIO", 
> /*  951 */                     Math.round(confinmentRatio * 1000.0D) / 1000.0D);
> /*  952 */                 ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "");
> /*      */                 
> /*  954 */                 if (confinmentRatio == 0.0D)
> /*  955 */                   ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Total-Confined Track"); 
> /*  956 */                 if (confinmentRatio == 1.0D)
> /*  957 */                   ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Perfectly Straight Track"); 
> /*  958 */                 if (confinmentRatio > 0.0D && confinmentRatio <= 0.5D)
> /*  959 */                   ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Strongly Confined Track"); 
> /*  960 */                 if (confinmentRatio > 0.05D && confinmentRatio <= 0.25D)
> /*  961 */                   ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Purely Random Track"); 
> /*  962 */                 if (confinmentRatio > 0.25D && confinmentRatio < 1.0D) {
> /*  963 */                   ProcessTrackMateXml.this.trackTable.addValue("TRACK_CLASSIFICATION", "Fairly Straight Track");
> /*      */                 }
> /*      */               } 
> /*  966 */               ProcessTrackMateXml.columnHeadersTrack = ProcessTrackMateXml.this.trackTable.getHeadings();
> /*  967 */               int rowsTrack = ProcessTrackMateXml.this.trackTable.size();
> /*  968 */               List<List<String>> dataListTrack = new ArrayList<>();
> /*  969 */               for (int r = 0; r < rowsTrack; r++) {
> /*  970 */                 List<String> stringsTrack = new ArrayList<>();
> /*  971 */                 for (int c = 0; c < ProcessTrackMateXml.columnHeadersTrack.length; c++) {
> /*  972 */                   String valuesTrack = ProcessTrackMateXml.this.trackTable.getStringValue(ProcessTrackMateXml.columnHeadersTrack[c], r);
> /*  973 */                   stringsTrack.add(valuesTrack);
> /*      */                 } 
> /*      */                 
> /*  976 */                 dataListTrack.add(stringsTrack);
> /*      */               } 
> /*  978 */               ProcessTrackMateXml.dataTrack = new String[dataListTrack.size()][]; int i1;
> /*  979 */               for (i1 = 0; i1 < ProcessTrackMateXml.dataTrack.length; i1++) {
> /*  980 */                 ProcessTrackMateXml.dataTrack[i1] = new String[((List)dataListTrack.get(i1)).size()];
> /*      */               }
> /*  982 */               for (i1 = 0; i1 < dataListTrack.size(); i1++) {
> /*  983 */                 for (int u = 1; u < ((List)dataListTrack.get(i1)).size(); u++)
> /*  984 */                   ProcessTrackMateXml.dataTrack[i1][u] = ((List<String>)dataListTrack.get(i1)).get(u); 
> /*      */               } 
> /*  986 */               ChooserWizardPanel.createTrackTable();
> /*  987 */               ChooserWizardPanel.tableTrack.addMouseListener(new MouseAdapter()
> /*      */                   {
> /*      */                     public void mouseReleased(MouseEvent e)
> /*      */                     {
> /*  991 */                       if (ProcessTrackMateXml.selectionModel != null && ChooserWizardPanel.command == "enable" && 
> /*  992 */                         ChooserWizardPanel.command != null) {
> /*  993 */                         ListSelectionModel lsm = ChooserWizardPanel.tableTrack.getSelectionModel();
> /*  994 */                         int selStart = lsm.getMinSelectionIndex();
> /*  995 */                         int selEnd = lsm.getMaxSelectionIndex();
> /*  996 */                         if (selStart < 0 || selEnd < 0) {
> /*      */                           return;
> /*      */                         }
> /*  999 */                         int minLine = Math.min(selStart, selEnd);
> /* 1000 */                         int maxLine = Math.max(selStart, selEnd);
> /* 1001 */                         Set<DefaultWeightedEdge> edges = new HashSet<>();
> /* 1002 */                         Set<Spot> spots = new HashSet<>();
> /* 1003 */                         for (int row = minLine; row <= maxLine; row++) {
> /* 1004 */                           int trackID = 
> /* 1005 */                             Integer.parseInt((String)ChooserWizardPanel.tableTrack.getValueAt(row, 2));
> /* 1006 */                           spots.addAll(model.getTrackModel().trackSpots(Integer.valueOf(trackID)));
> /* 1007 */                           edges.addAll(model.getTrackModel().trackEdges(Integer.valueOf(trackID)));
> /*      */                         } 
> /* 1009 */                         ProcessTrackMateXml.selectionModel.clearSelection();
> /* 1010 */                         ProcessTrackMateXml.selectionModel.addSpotToSelection(spots);
> /* 1011 */                         ProcessTrackMateXml.selectionModel.addEdgeToSelection(edges);
> /*      */                       } 
> /*      */                     }
> /*      */                   });
> /*      */             } 
> /*      */           }
> /*      */         });
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /* 1023 */     this.mainProcess.start();
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   private static void transferCalibration(ImagePlus from, ImagePlus to) {
> /* 1028 */     Calibration fc = from.getCalibration();
> /* 1029 */     Calibration tc = to.getCalibration();
> /*      */     
> /* 1031 */     tc.setUnit(fc.getUnit());
> /* 1032 */     tc.setTimeUnit(fc.getTimeUnit());
> /* 1033 */     tc.frameInterval = fc.frameInterval;
> /*      */     
> /* 1035 */     double mag = from.getCanvas().getMagnification();
> /* 1036 */     fc.pixelWidth /= mag;
> /* 1037 */     fc.pixelHeight /= mag;
> /* 1038 */     tc.pixelDepth = fc.pixelDepth;
> /*      */   }
> /*      */   
> /*      */   private final TablePanel<Spot> createSpotTableRT(Model model, DisplaySettings ds) {
> /* 1042 */     List<Spot> objects = new ArrayList<>();
> /* 1043 */     for (Integer trackID : model.getTrackModel().unsortedTrackIDs(true))
> /* 1044 */       objects.addAll(model.getTrackModel().trackSpots(trackID)); 
> /* 1045 */     List<String> features = new ArrayList<>(model.getFeatureModel().getSpotFeatures());
> /* 1046 */     Map<String, String> featureNames = model.getFeatureModel().getSpotFeatureNames();
> /* 1047 */     Map<String, String> featureShortNames = model.getFeatureModel().getSpotFeatureShortNames();
> /* 1048 */     Map<String, String> featureUnits = new HashMap<>();
> /* 1049 */     for (String feature : features) {
> /* 1050 */       Dimension dimension = (Dimension)model.getFeatureModel().getSpotFeatureDimensions()
> /* 1051 */         .get(feature);
> /* 1052 */       String units = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
> /* 1053 */       featureUnits.put(feature, units);
> /*      */     } 
> /* 1055 */     Map<String, Boolean> isInts = model.getFeatureModel().getSpotFeatureIsInt();
> /* 1056 */     Map<String, String> infoTexts = new HashMap<>();
> /* 1057 */     Function<Spot, String> labelGenerator = spot -> spot.getName();
> /* 1058 */     BiConsumer<Spot, String> labelSetter = (spot, label) -> spot.setName(label);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /* 1063 */     String SPOT_ID = "ID";
> /* 1064 */     features.add(0, "ID");
> /* 1065 */     featureNames.put("ID", "Spot ID");
> /* 1066 */     featureShortNames.put("ID", "Spot ID");
> /* 1067 */     featureUnits.put("ID", "");
> /* 1068 */     isInts.put("ID", Boolean.TRUE);
> /* 1069 */     infoTexts.put("ID", "The id of the spot.");
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /* 1074 */     String TRACK_ID = "TRACK_ID";
> /* 1075 */     features.add(1, "TRACK_ID");
> /* 1076 */     featureNames.put("TRACK_ID", "Track ID");
> /* 1077 */     featureShortNames.put("TRACK_ID", "Track ID");
> /* 1078 */     featureUnits.put("TRACK_ID", "");
> /* 1079 */     isInts.put("TRACK_ID", Boolean.TRUE);
> /* 1080 */     infoTexts.put("TRACK_ID", "The id of the track this spot belongs to.");
> /*      */     
> /* 1082 */     BiFunction<Spot, String, Double> featureFun = (spot, feature) -> {
> /*      */         if (feature.equals("TRACK_ID")) {
> /*      */           Integer trackID = paramModel.getTrackModel().trackIDOf(spot);
> /*      */           
> /*      */           return (trackID == null) ? null : Double.valueOf(trackID.doubleValue());
> /*      */         } 
> /*      */         
> /*      */         return feature.equals("ID") ? Double.valueOf(spot.ID()) : spot.getFeature(feature);
> /*      */       };
> /*      */     
> /* 1092 */     BiConsumer<Spot, Color> colorSetter = (spot, color) -> spot.putFeature("MANUAL_SPOT_COLOR", Double.valueOf(color.getRGB()));
> /*      */ 
> /*      */     
> /* 1095 */     Supplier<FeatureColorGenerator<Spot>> coloring = () -> FeatureUtils.createSpotColorGenerator(paramModel, paramDisplaySettings);
> /*      */     
> /* 1097 */     TablePanel<Spot> table = new TablePanel(objects, features, featureFun, featureNames, featureShortNames, 
> /* 1098 */         featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter, 
> /* 1099 */         "MANUAL_SPOT_COLOR", colorSetter);
> /*      */     
> /* 1101 */     return table;
> /*      */   }
> /*      */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/ProcessTrackMateXml.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/RegressionLE_.java jd-gui/RegressionLE_.java
1,313c1,372
< import org.jfree.data.function.Function2D;
< import org.jfree.data.function.LineFunction2D;
< import org.jfree.data.function.PowerFunction2D;
< import org.jfree.data.xy.XYDataset;
< 
< public class RegressionLE_ {
<    private static double[][] getXYData(XYDataset data, int series) {
<       int n = data.getItemCount(series);
<       if (n < 1) {
<          throw new IllegalArgumentException("Not enough data.");
<       } else {
<          double[][] result = new double[n][2];
< 
<          for(int i = 0; i < n; ++i) {
<             result[i][0] = data.getXValue(series, i);
<             result[i][1] = data.getYValue(series, i);
<          }
< 
<          return result;
<       }
<    }
< 
<    public static double[] getOLSRegression(double[][] data) {
<       int n = data.length;
<       if (n < 2) {
<          throw new IllegalArgumentException("LinearRegression: Not enough data.");
<       } else {
<          double sumX = 0.0D;
<          double sumY = 0.0D;
<          double sumXX = 0.0D;
<          double sumYY = 0.0D;
<          double sumXY = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             double x = data[i][0];
<             double y = data[i][1];
<             sumX += x;
<             sumY += y;
<             double xx = x * x;
<             sumXX += xx;
<             double yy = y * y;
<             sumYY += yy;
<             double xy = x * y;
<             sumXY += xy;
<          }
< 
<          double sxx = sumXX - sumX * sumX / (double)n;
<          double sxy = sumXY - sumX * sumY / (double)n;
<          double xbar = sumX / (double)n;
<          double ybar = sumY / (double)n;
<          double tmp1 = (double)n * sumXX - sumX * sumX;
<          double tmp2 = (double)n * sumYY - sumY * sumY;
<          if (!(tmp1 < 0.0D) && !(tmp2 < 0.0D)) {
<             double numerator = (double)n * sumXY - sumX * sumY;
<             double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
<             if (denominator == 0.0D) {
<                throw new IllegalArgumentException("LinearRegression: Data would cause divide by zero error.");
<             } else {
<                double r = numerator / denominator;
<                double[] result = new double[]{0.0D, 0.0D, r * r};
<                if (sxx < 0.0D) {
<                   throw new IllegalArgumentException("LinearRegression: Data would cause divide by zero error.");
<                } else {
<                   result[1] = sxy / sxx;
<                   result[0] = ybar - result[1] * xbar;
<                   return result;
<                }
<             }
<          } else {
<             throw new IllegalArgumentException("LinearRegression: Data would cause sqrt of a negative number.");
<          }
<       }
<    }
< 
<    public static double[] getOLSRegression(XYDataset data, int series) {
<       return getOLSRegression(getXYData(data, series));
<    }
< 
<    public static double[] getPowerRegression(double[][] data) {
<       int n = data.length;
<       if (n < 2) {
<          throw new IllegalArgumentException("Not enough data.");
<       } else {
<          double sumX = 0.0D;
<          double sumY = 0.0D;
<          double sumXX = 0.0D;
<          double sumYY = 0.0D;
<          double sumXY = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             if (!(data[i][0] > 0.0D) || !(data[i][1] > 0.0D)) {
<                throw new IllegalArgumentException("PowerRegression: X & Y Data must be greater than zero.");
<             }
< 
<             double x = Math.log(data[i][0]);
<             double y = Math.log(data[i][1]);
<             sumX += x;
<             sumY += y;
<             double xx = x * x;
<             sumXX += xx;
<             double yy = y * y;
<             sumYY += yy;
<             double xy = x * y;
<             sumXY += xy;
<          }
< 
<          double sxx = sumXX - sumX * sumX / (double)n;
<          double sxy = sumXY - sumX * sumY / (double)n;
<          double xbar = sumX / (double)n;
<          double ybar = sumY / (double)n;
<          double tmp1 = (double)n * sumXX - sumX * sumX;
<          double tmp2 = (double)n * sumYY - sumY * sumY;
<          if (!(tmp1 < 0.0D) && !(tmp2 < 0.0D)) {
<             double numerator = (double)n * sumXY - sumX * sumY;
<             double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
<             if (denominator == 0.0D) {
<                throw new IllegalArgumentException("PowerRegression: Data would cause divide by zero error.");
<             } else {
<                double r = numerator / denominator;
<                double[] result = new double[]{0.0D, 0.0D, r * r};
<                if (sxx < 0.0D) {
<                   throw new IllegalArgumentException("PowerRegression: Data would cause divide by zero error.");
<                } else {
<                   result[1] = sxy / sxx;
<                   result[0] = Math.pow(Math.exp(1.0D), ybar - result[1] * xbar);
<                   return result;
<                }
<             }
<          } else {
<             throw new IllegalArgumentException("PowerRegression: Data would cause sqrt of a negative number.");
<          }
<       }
<    }
< 
<    public static double[] getPowerRegression(XYDataset data, int series) {
<       return getPowerRegression(getXYData(data, series));
<    }
< 
<    public static double[] getLogarithmicRegression(double[][] data) {
<       int n = data.length;
<       if (n < 2) {
<          throw new IllegalArgumentException("LogarithmicRegression: Not enough data.");
<       } else {
<          double sumX = 0.0D;
<          double sumY = 0.0D;
<          double sumXX = 0.0D;
<          double sumYY = 0.0D;
<          double sumXY = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             if (!(data[i][0] > 0.0D)) {
<                throw new IllegalArgumentException("LogarithmicRegression: X Data must be greater than zero.");
<             }
< 
<             double x = Math.log(data[i][0]);
<             double y = data[i][1];
<             sumX += x;
<             sumY += y;
<             double xx = x * x;
<             sumXX += xx;
<             double yy = y * y;
<             sumYY += yy;
<             double xy = x * y;
<             sumXY += xy;
<          }
< 
<          double sxx = sumXX - sumX * sumX / (double)n;
<          double sxy = sumXY - sumX * sumY / (double)n;
<          double xbar = sumX / (double)n;
<          double ybar = sumY / (double)n;
<          double tmp1 = (double)n * sumXX - sumX * sumX;
<          double tmp2 = (double)n * sumYY - sumY * sumY;
<          if (!(tmp1 < 0.0D) && !(tmp2 < 0.0D)) {
<             double numerator = (double)n * sumXY - sumX * sumY;
<             double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
<             if (denominator == 0.0D) {
<                throw new IllegalArgumentException("LogarithmicRegression: Data would cause divide by zero error.");
<             } else {
<                double r = numerator / denominator;
<                double[] result = new double[]{0.0D, 0.0D, r * r};
<                if (sxx < 0.0D) {
<                   throw new IllegalArgumentException("LogarithmicRegression: Data would cause divide by zero error.");
<                } else {
<                   result[1] = sxy / sxx;
<                   result[0] = ybar - result[1] * xbar;
<                   return result;
<                }
<             }
<          } else {
<             throw new IllegalArgumentException("LogarithmicRegression: Data would cause sqrt of a negative number.");
<          }
<       }
<    }
< 
<    public static double[] getLogarithmicRegression(XYDataset data, int series) {
<       return getLogarithmicRegression(getXYData(data, series));
<    }
< 
<    public static double[] getExponentialRegression(double[][] data) {
<       int n = data.length;
<       if (n < 2) {
<          throw new IllegalArgumentException("ExponentialRegression: Not enough data.");
<       } else {
<          double sumX = 0.0D;
<          double sumY = 0.0D;
<          double sumXX = 0.0D;
<          double sumYY = 0.0D;
<          double sumXY = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             double x = data[i][0];
<             if (!(data[i][1] > 0.0D)) {
<                throw new IllegalArgumentException("ExponentialRegression: Y Data must be greater than zero.");
<             }
< 
<             double y = Math.log(data[i][1]);
<             sumX += x;
<             sumY += y;
<             double xx = x * x;
<             sumXX += xx;
<             double yy = y * y;
<             sumYY += yy;
<             double xy = x * y;
<             sumXY += xy;
<          }
< 
<          double sxx = sumXX - sumX * sumX / (double)n;
<          double sxy = sumXY - sumX * sumY / (double)n;
<          double xbar = sumX / (double)n;
<          double ybar = sumY / (double)n;
<          double tmp1 = (double)n * sumXX - sumX * sumX;
<          double tmp2 = (double)n * sumYY - sumY * sumY;
<          if (!(tmp1 < 0.0D) && !(tmp2 < 0.0D)) {
<             double numerator = (double)n * sumXY - sumX * sumY;
<             double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
<             if (denominator == 0.0D) {
<                throw new IllegalArgumentException("ExponentialRegression: Data would cause divide by zero error.");
<             } else {
<                double r = numerator / denominator;
<                double[] result = new double[]{0.0D, 0.0D, r * r};
<                if (sxx < 0.0D) {
<                   throw new IllegalArgumentException("ExponentialRegression: Data would cause divide by zero error.");
<                } else {
<                   result[1] = sxy / sxx;
<                   result[0] = Math.exp(ybar - result[1] * xbar);
<                   return result;
<                }
<             }
<          } else {
<             throw new IllegalArgumentException("ExponentialRegression: Data would cause sqrt of a negative number.");
<          }
<       }
<    }
< 
<    public static double[] getExponentialRegression(XYDataset data, int series) {
<       return getExponentialRegression(getXYData(data, series));
<    }
< 
<    public static Function2D getBestRegressionFunction(double[][] data) {
<       Function2D retVal = null;
<       double r2 = 0.0D;
<       Object var4 = null;
< 
<       double[] coefficients;
<       try {
<          coefficients = getOLSRegression(data);
<          retVal = new LineFunction2D(coefficients[0], coefficients[1]);
<          r2 = coefficients[2];
<       } catch (Exception var9) {
<          System.err.println(var9.getMessage());
<       }
< 
<       try {
<          coefficients = getPowerRegression(data);
<          if (coefficients[2] > r2) {
<             retVal = new PowerFunction2D(coefficients[0], coefficients[1]);
<             r2 = coefficients[2];
<          }
<       } catch (Exception var8) {
<          System.err.println(var8.getMessage());
<       }
< 
<       try {
<          coefficients = getLogarithmicRegression(data);
<          if (coefficients[2] > r2) {
<             retVal = new LogarithmicFunction2D(coefficients[0], coefficients[1]);
<             r2 = coefficients[2];
<          }
<       } catch (Exception var7) {
<          System.err.println(var7.getMessage());
<       }
< 
<       try {
<          coefficients = getExponentialRegression(data);
<          if (coefficients[2] > r2) {
<             retVal = new ExponentialFunction2D(coefficients[0], coefficients[1]);
<             r2 = coefficients[2];
<          }
<       } catch (Exception var6) {
<          System.err.println(var6.getMessage());
<       }
< 
<       if (retVal == null) {
<          throw new IllegalArgumentException("No regression functions were found with current dataset.");
<       } else {
<          return (Function2D)retVal;
<       }
<    }
< 
<    public static Function2D getBestRegressionFunction(XYDataset data, int series) {
<       return getBestRegressionFunction(getXYData(data, series));
<    }
< }
---
> /*     */ import org.jfree.data.function.Function2D;
> /*     */ import org.jfree.data.function.LineFunction2D;
> /*     */ import org.jfree.data.function.PowerFunction2D;
> /*     */ import org.jfree.data.xy.XYDataset;
> /*     */ 
> /*     */ 
> /*     */ public class RegressionLE_
> /*     */ {
> /*     */   private static double[][] getXYData(XYDataset data, int series) {
> /*  10 */     int n = data.getItemCount(series);
> /*  11 */     if (n < 1) {
> /*  12 */       throw new IllegalArgumentException("Not enough data.");
> /*     */     }
> /*  14 */     double[][] result = new double[n][2];
> /*  15 */     for (int i = 0; i < n; i++) {
> /*  16 */       result[i][0] = data.getXValue(series, i);
> /*  17 */       result[i][1] = data.getYValue(series, i);
> /*     */     } 
> /*  19 */     return result;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double[] getOLSRegression(double[][] data) {
> /*  33 */     int n = data.length;
> /*  34 */     if (n < 2) {
> /*  35 */       throw new IllegalArgumentException("LinearRegression: Not enough data.");
> /*     */     }
> /*     */     
> /*  38 */     double sumX = 0.0D;
> /*  39 */     double sumY = 0.0D;
> /*  40 */     double sumXX = 0.0D;
> /*  41 */     double sumYY = 0.0D;
> /*  42 */     double sumXY = 0.0D;
> /*  43 */     for (int i = 0; i < n; i++) {
> /*  44 */       double x = data[i][0];
> /*  45 */       double y = data[i][1];
> /*  46 */       sumX += x;
> /*  47 */       sumY += y;
> /*  48 */       double xx = x * x;
> /*  49 */       sumXX += xx;
> /*  50 */       double yy = y * y;
> /*  51 */       sumYY += yy;
> /*  52 */       double xy = x * y;
> /*  53 */       sumXY += xy;
> /*     */     } 
> /*  55 */     double sxx = sumXX - sumX * sumX / n;
> /*  56 */     double sxy = sumXY - sumX * sumY / n;
> /*  57 */     double xbar = sumX / n;
> /*  58 */     double ybar = sumY / n;
> /*     */ 
> /*     */     
> /*  61 */     double tmp1 = n * sumXX - sumX * sumX;
> /*  62 */     double tmp2 = n * sumYY - sumY * sumY;
> /*  63 */     if (tmp1 < 0.0D || tmp2 < 0.0D)
> /*  64 */       throw new IllegalArgumentException("LinearRegression: Data would cause sqrt of a negative number."); 
> /*  65 */     double numerator = n * sumXY - sumX * sumY;
> /*  66 */     double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
> /*  67 */     if (denominator == 0.0D)
> /*  68 */       throw new IllegalArgumentException("LinearRegression: Data would cause divide by zero error."); 
> /*  69 */     double r = numerator / denominator;
> /*     */     
> /*  71 */     double[] result = new double[3];
> /*  72 */     result[2] = r * r;
> /*  73 */     if (sxx < 0.0D)
> /*  74 */       throw new IllegalArgumentException("LinearRegression: Data would cause divide by zero error."); 
> /*  75 */     result[1] = sxy / sxx;
> /*  76 */     result[0] = ybar - result[1] * xbar;
> /*     */     
> /*  78 */     return result;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double[] getOLSRegression(XYDataset data, int series) {
> /*  95 */     return getOLSRegression(getXYData(data, series));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double[] getPowerRegression(double[][] data) {
> /* 101 */     int n = data.length;
> /* 102 */     if (n < 2) {
> /* 103 */       throw new IllegalArgumentException("Not enough data.");
> /*     */     }
> /*     */     
> /* 106 */     double sumX = 0.0D;
> /* 107 */     double sumY = 0.0D;
> /* 108 */     double sumXX = 0.0D;
> /* 109 */     double sumYY = 0.0D;
> /* 110 */     double sumXY = 0.0D;
> /* 111 */     for (int i = 0; i < n; i++) {
> /*     */       double x, y;
> /* 113 */       if (data[i][0] > 0.0D && data[i][1] > 0.0D) {
> /* 114 */         x = Math.log(data[i][0]);
> /* 115 */         y = Math.log(data[i][1]);
> /*     */       } else {
> /* 117 */         throw new IllegalArgumentException("PowerRegression: X & Y Data must be greater than zero.");
> /* 118 */       }  sumX += x;
> /* 119 */       sumY += y;
> /* 120 */       double xx = x * x;
> /* 121 */       sumXX += xx;
> /* 122 */       double yy = y * y;
> /* 123 */       sumYY += yy;
> /* 124 */       double xy = x * y;
> /* 125 */       sumXY += xy;
> /*     */     } 
> /* 127 */     double sxx = sumXX - sumX * sumX / n;
> /* 128 */     double sxy = sumXY - sumX * sumY / n;
> /* 129 */     double xbar = sumX / n;
> /* 130 */     double ybar = sumY / n;
> /*     */ 
> /*     */     
> /* 133 */     double tmp1 = n * sumXX - sumX * sumX;
> /* 134 */     double tmp2 = n * sumYY - sumY * sumY;
> /* 135 */     if (tmp1 < 0.0D || tmp2 < 0.0D)
> /* 136 */       throw new IllegalArgumentException("PowerRegression: Data would cause sqrt of a negative number."); 
> /* 137 */     double numerator = n * sumXY - sumX * sumY;
> /* 138 */     double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
> /* 139 */     if (denominator == 0.0D)
> /* 140 */       throw new IllegalArgumentException("PowerRegression: Data would cause divide by zero error."); 
> /* 141 */     double r = numerator / denominator;
> /*     */     
> /* 143 */     double[] result = new double[3];
> /* 144 */     result[2] = r * r;
> /* 145 */     if (sxx < 0.0D)
> /* 146 */       throw new IllegalArgumentException("PowerRegression: Data would cause divide by zero error."); 
> /* 147 */     result[1] = sxy / sxx;
> /* 148 */     result[0] = Math.pow(Math.exp(1.0D), ybar - result[1] * xbar);
> /* 149 */     return result;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double[] getPowerRegression(XYDataset data, int series) {
> /* 165 */     return getPowerRegression(getXYData(data, series));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double[] getLogarithmicRegression(double[][] data) {
> /* 171 */     int n = data.length;
> /* 172 */     if (n < 2) {
> /* 173 */       throw new IllegalArgumentException("LogarithmicRegression: Not enough data.");
> /*     */     }
> /*     */     
> /* 176 */     double sumX = 0.0D;
> /* 177 */     double sumY = 0.0D;
> /* 178 */     double sumXX = 0.0D;
> /* 179 */     double sumYY = 0.0D;
> /* 180 */     double sumXY = 0.0D;
> /* 181 */     for (int i = 0; i < n; i++) {
> /*     */       double x;
> /* 183 */       if (data[i][0] > 0.0D) {
> /* 184 */         x = Math.log(data[i][0]);
> /*     */       } else {
> /* 186 */         throw new IllegalArgumentException("LogarithmicRegression: X Data must be greater than zero.");
> /* 187 */       }  double y = data[i][1];
> /* 188 */       sumX += x;
> /* 189 */       sumY += y;
> /* 190 */       double xx = x * x;
> /* 191 */       sumXX += xx;
> /* 192 */       double yy = y * y;
> /* 193 */       sumYY += yy;
> /* 194 */       double xy = x * y;
> /* 195 */       sumXY += xy;
> /*     */     } 
> /* 197 */     double sxx = sumXX - sumX * sumX / n;
> /* 198 */     double sxy = sumXY - sumX * sumY / n;
> /* 199 */     double xbar = sumX / n;
> /* 200 */     double ybar = sumY / n;
> /*     */ 
> /*     */     
> /* 203 */     double tmp1 = n * sumXX - sumX * sumX;
> /* 204 */     double tmp2 = n * sumYY - sumY * sumY;
> /* 205 */     if (tmp1 < 0.0D || tmp2 < 0.0D)
> /* 206 */       throw new IllegalArgumentException("LogarithmicRegression: Data would cause sqrt of a negative number."); 
> /* 207 */     double numerator = n * sumXY - sumX * sumY;
> /* 208 */     double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
> /* 209 */     if (denominator == 0.0D)
> /* 210 */       throw new IllegalArgumentException("LogarithmicRegression: Data would cause divide by zero error."); 
> /* 211 */     double r = numerator / denominator;
> /*     */     
> /* 213 */     double[] result = new double[3];
> /* 214 */     result[2] = r * r;
> /* 215 */     if (sxx < 0.0D)
> /* 216 */       throw new IllegalArgumentException("LogarithmicRegression: Data would cause divide by zero error."); 
> /* 217 */     result[1] = sxy / sxx;
> /* 218 */     result[0] = ybar - result[1] * xbar;
> /* 219 */     return result;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double[] getLogarithmicRegression(XYDataset data, int series) {
> /* 235 */     return getLogarithmicRegression(getXYData(data, series));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double[] getExponentialRegression(double[][] data) {
> /* 250 */     int n = data.length;
> /* 251 */     if (n < 2) {
> /* 252 */       throw new IllegalArgumentException("ExponentialRegression: Not enough data.");
> /*     */     }
> /*     */     
> /* 255 */     double sumX = 0.0D;
> /* 256 */     double sumY = 0.0D;
> /* 257 */     double sumXX = 0.0D;
> /* 258 */     double sumYY = 0.0D;
> /* 259 */     double sumXY = 0.0D;
> /* 260 */     for (int i = 0; i < n; i++) {
> /*     */       
> /* 262 */       double y, x = data[i][0];
> /* 263 */       if (data[i][1] > 0.0D) {
> /* 264 */         y = Math.log(data[i][1]);
> /*     */       } else {
> /* 266 */         throw new IllegalArgumentException("ExponentialRegression: Y Data must be greater than zero.");
> /* 267 */       }  sumX += x;
> /* 268 */       sumY += y;
> /* 269 */       double xx = x * x;
> /* 270 */       sumXX += xx;
> /* 271 */       double yy = y * y;
> /* 272 */       sumYY += yy;
> /* 273 */       double xy = x * y;
> /* 274 */       sumXY += xy;
> /*     */     } 
> /* 276 */     double sxx = sumXX - sumX * sumX / n;
> /* 277 */     double sxy = sumXY - sumX * sumY / n;
> /* 278 */     double xbar = sumX / n;
> /* 279 */     double ybar = sumY / n;
> /*     */ 
> /*     */     
> /* 282 */     double tmp1 = n * sumXX - sumX * sumX;
> /* 283 */     double tmp2 = n * sumYY - sumY * sumY;
> /* 284 */     if (tmp1 < 0.0D || tmp2 < 0.0D)
> /* 285 */       throw new IllegalArgumentException("ExponentialRegression: Data would cause sqrt of a negative number."); 
> /* 286 */     double numerator = n * sumXY - sumX * sumY;
> /* 287 */     double denominator = Math.sqrt(tmp1) * Math.sqrt(tmp2);
> /* 288 */     if (denominator == 0.0D)
> /* 289 */       throw new IllegalArgumentException("ExponentialRegression: Data would cause divide by zero error."); 
> /* 290 */     double r = numerator / denominator;
> /*     */     
> /* 292 */     double[] result = new double[3];
> /* 293 */     result[2] = r * r;
> /* 294 */     if (sxx < 0.0D)
> /* 295 */       throw new IllegalArgumentException("ExponentialRegression: Data would cause divide by zero error."); 
> /* 296 */     result[1] = sxy / sxx;
> /* 297 */     result[0] = Math.exp(ybar - result[1] * xbar);
> /* 298 */     return result;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double[] getExponentialRegression(XYDataset data, int series) {
> /* 304 */     return getExponentialRegression(getXYData(data, series));
> /*     */   }
> /*     */   
> /*     */   public static Function2D getBestRegressionFunction(double[][] data) {
> /*     */     ExponentialFunction2D exponentialFunction2D;
> /* 309 */     Function2D retVal = null;
> /* 310 */     double r2 = 0.0D;
> /* 311 */     double[] coefficients = null;
> /*     */ 
> /*     */     
> /*     */     try {
> /* 315 */       coefficients = getOLSRegression(data);
> /* 316 */       LineFunction2D lineFunction2D = new LineFunction2D(coefficients[0], coefficients[1]);
> /* 317 */       r2 = coefficients[2];
> /* 318 */     } catch (Exception e) {
> /* 319 */       System.err.println(e.getMessage());
> /*     */     } 
> /*     */ 
> /*     */     
> /*     */     try {
> /* 324 */       coefficients = getPowerRegression(data);
> /* 325 */       if (coefficients[2] > r2) {
> /* 326 */         PowerFunction2D powerFunction2D = new PowerFunction2D(coefficients[0], coefficients[1]);
> /* 327 */         r2 = coefficients[2];
> /*     */       } 
> /* 329 */     } catch (Exception e) {
> /* 330 */       System.err.println(e.getMessage());
> /*     */     } 
> /*     */ 
> /*     */     
> /*     */     try {
> /* 335 */       coefficients = getLogarithmicRegression(data);
> /* 336 */       if (coefficients[2] > r2) {
> /* 337 */         LogarithmicFunction2D logarithmicFunction2D = new LogarithmicFunction2D(coefficients[0], coefficients[1]);
> /* 338 */         r2 = coefficients[2];
> /*     */       } 
> /* 340 */     } catch (Exception e) {
> /* 341 */       System.err.println(e.getMessage());
> /*     */     } 
> /*     */ 
> /*     */     
> /*     */     try {
> /* 346 */       coefficients = getExponentialRegression(data);
> /* 347 */       if (coefficients[2] > r2) {
> /* 348 */         exponentialFunction2D = new ExponentialFunction2D(coefficients[0], coefficients[1]);
> /* 349 */         r2 = coefficients[2];
> /*     */       } 
> /* 351 */     } catch (Exception e) {
> /* 352 */       System.err.println(e.getMessage());
> /*     */     } 
> /*     */     
> /* 355 */     if (exponentialFunction2D == null) {
> /* 356 */       throw new IllegalArgumentException("No regression functions were found with current dataset.");
> /*     */     }
> /*     */     
> /* 359 */     return (Function2D)exponentialFunction2D;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public static Function2D getBestRegressionFunction(XYDataset data, int series) {
> /* 364 */     return getBestRegressionFunction(getXYData(data, series));
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/RegressionLE_.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/Renderer.java jd-gui/Renderer.java
1,4c1,31
< import java.awt.Color;
< import java.awt.Component;
< import javax.swing.JTable;
< import javax.swing.table.DefaultTableCellRenderer;
---
> /*    */ import java.awt.Color;
> /*    */ import java.awt.Component;
> /*    */ import javax.swing.JTable;
> /*    */ import javax.swing.table.DefaultTableCellRenderer;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class Renderer
> /*    */   extends DefaultTableCellRenderer
> /*    */ {
> /*    */   public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
> /* 18 */     Component comp = getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
> /* 19 */     value = table.getModel().getValueAt(row, 0);
> /*    */     
> /* 21 */     if (value.equals(Boolean.valueOf(true))) {
> /* 22 */       comp.setBackground(Color.LIGHT_GRAY);
> /*    */     } else {
> /*    */       
> /* 25 */       comp.setForeground(Color.white);
> /*    */     } 
> /*    */ 
> /*    */     
> /* 29 */     return comp;
> /*    */   }
> /*    */ }
6,14d32
< public class Renderer extends DefaultTableCellRenderer {
<    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
<       Component comp = this.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
<       value = table.getModel().getValueAt(row, 0);
<       if (value.equals(true)) {
<          comp.setBackground(Color.LIGHT_GRAY);
<       } else {
<          comp.setForeground(Color.white);
<       }
16,18c34,37
<       return comp;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/Renderer.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/RollingBall.java jd-gui/RollingBall.java
1,4c1,642
< class RollingBall {
<    float[] data;
<    int width;
<    int shrinkFactor;
---
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ class RollingBall
> /*     */ {
> /*     */   float[] data;
> /*     */   int width;
> /*     */   int shrinkFactor;
> /*     */   
> /*     */   RollingBall(double radius) {
> /*     */     int arcTrimPer;
> /* 594 */     if (radius <= 10.0D) {
> /* 595 */       this.shrinkFactor = 1;
> /* 596 */       arcTrimPer = 24;
> /* 597 */     } else if (radius <= 30.0D) {
> /* 598 */       this.shrinkFactor = 2;
> /* 599 */       arcTrimPer = 24;
> /* 600 */     } else if (radius <= 100.0D) {
> /* 601 */       this.shrinkFactor = 4;
> /* 602 */       arcTrimPer = 32;
> /*     */     } else {
> /* 604 */       this.shrinkFactor = 8;
> /* 605 */       arcTrimPer = 40;
> /*     */     } 
> /* 607 */     buildRollingBall(radius, arcTrimPer);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void buildRollingBall(double ballradius, int arcTrimPer) {
> /* 623 */     this.shrinkFactor = this.shrinkFactor;
> /* 624 */     double smallballradius = ballradius / this.shrinkFactor;
> /* 625 */     if (smallballradius < 1.0D)
> /* 626 */       smallballradius = 1.0D; 
> /* 627 */     double rsquare = smallballradius * smallballradius;
> /* 628 */     int xtrim = (int)(arcTrimPer * smallballradius) / 100;
> /* 629 */     int halfWidth = (int)Math.round(smallballradius - xtrim);
> /* 630 */     this.width = 2 * halfWidth + 1;
> /* 631 */     this.data = new float[this.width * this.width];
> /*     */     
> /* 633 */     for (int y = 0, p = 0; y < this.width; y++) {
> /* 634 */       for (int x = 0; x < this.width; x++, p++) {
> /* 635 */         int xval = x - halfWidth;
> /* 636 */         int yval = y - halfWidth;
> /* 637 */         double temp = rsquare - (xval * xval) - (yval * yval);
> /* 638 */         this.data[p] = (temp > 0.0D) ? (float)Math.sqrt(temp) : 0.0F;
> /*     */       } 
> /*     */     } 
> /*     */   }
> /*     */ }
6,20d643
<    RollingBall(double radius) {
<       byte arcTrimPer;
<       if (radius <= 10.0D) {
<          this.shrinkFactor = 1;
<          arcTrimPer = 24;
<       } else if (radius <= 30.0D) {
<          this.shrinkFactor = 2;
<          arcTrimPer = 24;
<       } else if (radius <= 100.0D) {
<          this.shrinkFactor = 4;
<          arcTrimPer = 32;
<       } else {
<          this.shrinkFactor = 8;
<          arcTrimPer = 40;
<       }
22,50c645,648
<       this.buildRollingBall(radius, arcTrimPer);
<    }
< 
<    void buildRollingBall(double ballradius, int arcTrimPer) {
<       this.shrinkFactor = this.shrinkFactor;
<       double smallballradius = ballradius / (double)this.shrinkFactor;
<       if (smallballradius < 1.0D) {
<          smallballradius = 1.0D;
<       }
< 
<       double rsquare = smallballradius * smallballradius;
<       int xtrim = (int)((double)arcTrimPer * smallballradius) / 100;
<       int halfWidth = (int)Math.round(smallballradius - (double)xtrim);
<       this.width = 2 * halfWidth + 1;
<       this.data = new float[this.width * this.width];
<       int y = 0;
< 
<       for(int p = 0; y < this.width; ++y) {
<          for(int x = 0; x < this.width; ++p) {
<             int xval = x - halfWidth;
<             int yval = y - halfWidth;
<             double temp = rsquare - (double)(xval * xval) - (double)(yval * yval);
<             this.data[p] = temp > 0.0D ? (float)Math.sqrt(temp) : 0.0F;
<             ++x;
<          }
<       }
< 
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/RollingBall.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/SimpleHeaderRenderer.java jd-gui/SimpleHeaderRenderer.java
1,7c1,27
< import java.awt.Color;
< import java.awt.Component;
< import java.awt.Font;
< import javax.swing.BorderFactory;
< import javax.swing.JLabel;
< import javax.swing.JTable;
< import javax.swing.table.TableCellRenderer;
---
> /*    */ import java.awt.Color;
> /*    */ import java.awt.Component;
> /*    */ import java.awt.Font;
> /*    */ import javax.swing.BorderFactory;
> /*    */ import javax.swing.JLabel;
> /*    */ import javax.swing.JTable;
> /*    */ import javax.swing.table.TableCellRenderer;
> /*    */ 
> /*    */ public class SimpleHeaderRenderer
> /*    */   extends JLabel
> /*    */   implements TableCellRenderer
> /*    */ {
> /*    */   public SimpleHeaderRenderer() {
> /* 14 */     setFont(new Font("SansSerif", 1, 12));
> /* 15 */     setForeground(Color.DARK_GRAY);
> /* 16 */     setBorder(BorderFactory.createEtchedBorder());
> /* 17 */     setBackground(new Color(230, 250, 240, 50));
> /* 18 */     setHorizontalAlignment(0);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
> /* 24 */     setText(value.toString());
> /* 25 */     return this;
> /*    */   }
> /*    */ }
9,16d28
< public class SimpleHeaderRenderer extends JLabel implements TableCellRenderer {
<    public SimpleHeaderRenderer() {
<       this.setFont(new Font("SansSerif", 1, 12));
<       this.setForeground(Color.DARK_GRAY);
<       this.setBorder(BorderFactory.createEtchedBorder());
<       this.setBackground(new Color(230, 250, 240, 50));
<       this.setHorizontalAlignment(0);
<    }
18,22c30,33
<    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
<       this.setText(value.toString());
<       return this;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/SimpleHeaderRenderer.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: SLTResultsTableVersion$EdgeSourceSpotFrameComparator.java
diff -r TrackAnalyzer_/SLTResultsTableVersion.java jd-gui/SLTResultsTableVersion.java
1,306c1,430
< import fiji.plugin.trackmate.Dimension;
< import fiji.plugin.trackmate.FeatureModel;
< import fiji.plugin.trackmate.Model;
< import fiji.plugin.trackmate.SelectionModel;
< import fiji.plugin.trackmate.Spot;
< import fiji.plugin.trackmate.TrackMate;
< import fiji.plugin.trackmate.util.ModelTools;
< import ij.measure.ResultsTable;
< import java.util.ArrayList;
< import java.util.Collection;
< import java.util.Collections;
< import java.util.Comparator;
< import java.util.HashMap;
< import java.util.Iterator;
< import java.util.List;
< import java.util.Map;
< import java.util.Set;
< import org.jgrapht.graph.DefaultWeightedEdge;
< 
< public class SLTResultsTableVersion {
<    public static final String NAME = "Export statistics to tables";
<    public static final String KEY = "EXPORT_STATS_TO_IJ";
<    public static final String INFO_TEXT = "<html>Compute and export all statistics to 3 ImageJ results table. Statistisc are separated in features computed for: <ol> \t<li> spots in filtered tracks; \t<li> links between those spots; \t<li> filtered tracks. </ol> For tracks and links, they are recalculated prior to exporting. Note that spots and links that are not in a filtered tracks are not part of this export.</html>";
<    private static final String SPOT_TABLE_NAME = "Spots in tracks statistics";
<    private static final String EDGE_TABLE_NAME = "Links in tracks statistics";
<    private static final String TRACK_TABLE_NAME = "Track statistics";
<    private static final String ID_COLUMN = "ID";
<    private static final String TRACK_ID_COLUMN = "TRACK_ID";
<    private ResultsTable spotTable;
<    private ResultsTable edgeTable;
<    private ResultsTable trackTable;
<    private final SelectionModel selectionModel;
<    public static final String KEYLINEAR = "Linear track analysis";
<    public static final String TRACK_TOTAL_DISTANCE_TRAVELED = "TOTAL_DISTANCE_TRAVELED";
<    public static final String TRACK_MAX_DISTANCE_TRAVELED = "MAX_DISTANCE_TRAVELED";
<    public static final String TRACK_CONFINMENT_RATIO = "CONFINMENT_RATIO";
<    public static final String TRACK_MEAN_STRAIGHT_LINE_SPEED = "MEAN_STRAIGHT_LINE_SPEED";
<    public static final String TRACK_LINEARITY_OF_FORWARD_PROGRESSION = "LINEARITY_OF_FORWARD_PROGRESSION";
<    public static final String TOTAL_ABSOLUTE_ANGLE_XY = "TOTAL_ABSOLUTE_ANGLE_XY";
<    public static final String TOTAL_ABSOLUTE_ANGLE_YZ = "TOTAL_ABSOLUTE_ANGLE_YZ";
<    public static final String TOTAL_ABSOLUTE_ANGLE_ZX = "TOTAL_ABSOLUTE_ANGLE_ZX";
<    public static final List<String> FEATURES = new ArrayList(9);
<    public static final Map<String, String> FEATURE_NAMES = new HashMap(9);
<    public static final Map<String, String> FEATURE_SHORT_NAMES = new HashMap(9);
<    public static final Map<String, Dimension> FEATURE_DIMENSIONS = new HashMap(9);
<    public static final Map<String, Boolean> IS_INT = new HashMap(9);
< 
<    public SLTResultsTableVersion(SelectionModel selectionModel) {
<       this.selectionModel = selectionModel;
<    }
< 
<    public ResultsTable executeSpot(TrackMate trackmate) {
<       Model model = trackmate.getModel();
<       FeatureModel fm = model.getFeatureModel();
<       Set<Integer> trackIDs = model.getTrackModel().trackIDs(true);
<       Collection<String> spotFeatures = trackmate.getModel().getFeatureModel().getSpotFeatures();
<       this.spotTable = new ResultsTable();
<       Iterator var7 = trackIDs.iterator();
< 
<       while(var7.hasNext()) {
<          Integer trackID = (Integer)var7.next();
<          Set<Spot> track = model.getTrackModel().trackSpots(trackID);
<          List<Spot> sortedTrack = new ArrayList(track);
<          Collections.sort(sortedTrack, Spot.frameComparator);
<          Iterator var11 = sortedTrack.iterator();
< 
<          while(var11.hasNext()) {
<             Spot spot = (Spot)var11.next();
<             this.spotTable.incrementCounter();
<             this.spotTable.addLabel(spot.getName());
<             this.spotTable.addValue("ID", "" + spot.ID());
<             this.spotTable.addValue("TRACK_ID", "" + trackID);
<             Iterator var13 = spotFeatures.iterator();
< 
<             while(var13.hasNext()) {
<                String feature = (String)var13.next();
<                Double val = spot.getFeature(feature);
<                if (val == null) {
<                   this.spotTable.addValue(feature, "None");
<                } else if ((Boolean)fm.getSpotFeatureIsInt().get(feature)) {
<                   this.spotTable.addValue(feature, "" + val.intValue());
<                } else {
<                   this.spotTable.addValue(feature, val);
<                }
<             }
<          }
<       }
< 
<       return this.spotTable;
<    }
< 
<    public ResultsTable executeLink(TrackMate trackmate) {
<       Model model = trackmate.getModel();
<       FeatureModel fm = model.getFeatureModel();
<       Set<Integer> trackIDs = model.getTrackModel().trackIDs(true);
<       Collection<String> edgeFeatures = fm.getEdgeFeatures();
<       this.edgeTable = new ResultsTable();
<       Iterator var7 = trackIDs.iterator();
< 
<       while(var7.hasNext()) {
<          Integer trackID = (Integer)var7.next();
<          Comparator<DefaultWeightedEdge> edgeTimeComparator = ModelTools.featureEdgeComparator("EDGE_TIME", fm);
<          Comparator<DefaultWeightedEdge> edgeSourceSpotTimeComparator = new SLTResultsTableVersion.EdgeSourceSpotFrameComparator(model);
<          Set<DefaultWeightedEdge> track = model.getTrackModel().trackEdges(trackID);
<          List<DefaultWeightedEdge> sortedTrack = new ArrayList(track);
<          if (model.getFeatureModel().getEdgeFeatures().contains("Edge location")) {
<             Collections.sort(sortedTrack, edgeTimeComparator);
<          } else {
<             Collections.sort(sortedTrack, edgeSourceSpotTimeComparator);
<          }
< 
<          Iterator var13 = sortedTrack.iterator();
< 
<          while(var13.hasNext()) {
<             DefaultWeightedEdge edge = (DefaultWeightedEdge)var13.next();
<             this.edgeTable.incrementCounter();
<             this.edgeTable.addLabel(edge.toString());
<             this.edgeTable.addValue("TRACK_ID", "" + trackID);
<             Iterator var15 = edgeFeatures.iterator();
< 
<             while(var15.hasNext()) {
<                String feature = (String)var15.next();
<                Object o = fm.getEdgeFeature(edge, feature);
<                if (!(o instanceof String)) {
<                   Number d = (Number)o;
<                   if (d == null) {
<                      this.edgeTable.addValue(feature, "None");
<                   } else if ((Boolean)fm.getEdgeFeatureIsInt().get(feature)) {
<                      this.edgeTable.addValue(feature, "" + d.intValue());
<                   } else {
<                      this.edgeTable.addValue(feature, d.doubleValue());
<                   }
<                }
<             }
<          }
<       }
< 
<       return this.edgeTable;
<    }
< 
<    public ResultsTable executeTrack(TrackMate trackmate) {
<       FEATURES.add("TOTAL_DISTANCE_TRAVELED");
<       FEATURES.add("MAX_DISTANCE_TRAVELED");
<       FEATURES.add("CONFINMENT_RATIO");
<       FEATURES.add("MEAN_STRAIGHT_LINE_SPEED");
<       FEATURES.add("LINEARITY_OF_FORWARD_PROGRESSION");
<       FEATURES.add("TOTAL_ABSOLUTE_ANGLE_XY");
<       FEATURES.add("TOTAL_ABSOLUTE_ANGLE_YZ");
<       FEATURES.add("TOTAL_ABSOLUTE_ANGLE_ZX");
<       FEATURE_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total distance traveled");
<       FEATURE_NAMES.put("MAX_DISTANCE_TRAVELED", "Max distance traveled");
<       FEATURE_NAMES.put("CONFINMENT_RATIO", "Confinment ratio");
<       FEATURE_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean straight line speed");
<       FEATURE_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Linearity of forward progression");
<       FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Absolute angle in xy plane");
<       FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Absolute angle in yz plane");
<       FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Absolute angle in zx plane");
<       FEATURE_SHORT_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total dist.");
<       FEATURE_SHORT_NAMES.put("MAX_DISTANCE_TRAVELED", "Max dist.");
<       FEATURE_SHORT_NAMES.put("CONFINMENT_RATIO", "Cnfnmnt ratio");
<       FEATURE_SHORT_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean v. line");
<       FEATURE_SHORT_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Lin. fwd. progr.");
<       FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Abs. angle xy");
<       FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Abs. angle yz");
<       FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Abs. angle zx");
<       FEATURE_DIMENSIONS.put("TOTAL_DISTANCE_TRAVELED", Dimension.LENGTH);
<       FEATURE_DIMENSIONS.put("MAX_DISTANCE_TRAVELED", Dimension.LENGTH);
<       FEATURE_DIMENSIONS.put("CONFINMENT_RATIO", Dimension.NONE);
<       FEATURE_DIMENSIONS.put("MEAN_STRAIGHT_LINE_SPEED", Dimension.VELOCITY);
<       FEATURE_DIMENSIONS.put("LINEARITY_OF_FORWARD_PROGRESSION", Dimension.NONE);
<       FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_XY", Dimension.ANGLE);
<       FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_YZ", Dimension.ANGLE);
<       FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_ZX", Dimension.ANGLE);
<       IS_INT.put("TOTAL_DISTANCE_TRAVELED", Boolean.FALSE);
<       IS_INT.put("MAX_DISTANCE_TRAVELED", Boolean.FALSE);
<       IS_INT.put("CONFINMENT_RATIO", Boolean.FALSE);
<       IS_INT.put("MEAN_STRAIGHT_LINE_SPEED", Boolean.FALSE);
<       IS_INT.put("LINEARITY_OF_FORWARD_PROGRESSION", Boolean.FALSE);
<       IS_INT.put("TOTAL_ABSOLUTE_ANGLE_XY", Boolean.FALSE);
<       IS_INT.put("TOTAL_ABSOLUTE_ANGLE_YZ", Boolean.FALSE);
<       IS_INT.put("TOTAL_ABSOLUTE_ANGLE_ZX", Boolean.FALSE);
<       Model model = trackmate.getModel();
<       FeatureModel fm = model.getFeatureModel();
<       Set<Integer> trackIDs = model.getTrackModel().trackIDs(true);
<       this.trackTable = new ResultsTable();
<       Iterator var6 = trackIDs.iterator();
< 
<       while(var6.hasNext()) {
<          Integer trackID = (Integer)var6.next();
<          List<Spot> spots = new ArrayList(model.getTrackModel().trackSpots(trackID));
<          Collections.sort(spots, Spot.frameComparator);
<          Spot first = (Spot)spots.get(0);
<          Set<DefaultWeightedEdge> edges = model.getTrackModel().trackEdges(trackID);
<          double totalDistance = 0.0D;
<          double maxDistanceSq = Double.NEGATIVE_INFINITY;
<          double maxDistance = 0.0D;
<          double dx = 0.0D;
<          double dy = 0.0D;
<          double dz = 0.0D;
< 
<          Spot source;
<          Spot target;
<          double vMean;
<          double confinmentRatio;
<          for(Iterator var23 = edges.iterator(); var23.hasNext(); dz += target.getDoublePosition(2) - source.getDoublePosition(2)) {
<             DefaultWeightedEdge edge = (DefaultWeightedEdge)var23.next();
<             source = model.getTrackModel().getEdgeSource(edge);
<             target = model.getTrackModel().getEdgeTarget(edge);
<             vMean = Math.sqrt(source.squareDistanceTo(target));
<             totalDistance += vMean;
<             confinmentRatio = first.squareDistanceTo(target);
<             if (confinmentRatio > maxDistanceSq) {
<                maxDistanceSq = confinmentRatio;
<                maxDistance = Math.sqrt(confinmentRatio);
<             }
< 
<             dx += target.getDoublePosition(0) - source.getDoublePosition(0);
<             dy += target.getDoublePosition(1) - source.getDoublePosition(1);
<          }
< 
<          double netDistance = fm.getTrackFeature(trackID, "TRACK_DISPLACEMENT");
<          double tTotal = fm.getTrackFeature(trackID, "TRACK_DURATION");
<          vMean = fm.getTrackFeature(trackID, "TRACK_MEAN_SPEED");
<          confinmentRatio = netDistance / totalDistance;
<          double meanStraightLineSpeed = netDistance / tTotal;
<          double linearityForwardProgression = meanStraightLineSpeed / vMean;
<          double angleXY = Math.atan2(dy, dx);
<          double angleYZ = Math.atan2(dz, dy);
<          double angleZX = Math.atan2(dx, dz);
<          Collection<String> trackFeatures = fm.getTrackFeatures();
<          this.trackTable.incrementCounter();
<          this.trackTable.addLabel(model.getTrackModel().name(trackID));
<          this.trackTable.addValue("TRACK_ID", "" + trackID);
<          Iterator var42 = trackFeatures.iterator();
< 
<          while(var42.hasNext()) {
<             String feature = (String)var42.next();
<             Double val = fm.getTrackFeature(trackID, feature);
<             if (val == null) {
<                this.trackTable.addValue(feature, "None");
<             } else if ((Boolean)fm.getTrackFeatureIsInt().get(feature)) {
<                this.trackTable.addValue(feature, "" + val.intValue());
<             } else {
<                this.trackTable.addValue(feature, val);
<             }
<          }
< 
<          this.trackTable.addValue("TOTAL_DISTANCE_TRAVELED", "" + (double)Math.round(totalDistance * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("MAX_DISTANCE_TRAVELED", "" + (double)Math.round(maxDistance * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("MEAN_STRAIGHT_LINE_SPEED", "" + (double)Math.round(meanStraightLineSpeed * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("LINEARITY_OF_FORWARD_PROGRESSION", "" + (double)Math.round(linearityForwardProgression * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_XY", "" + (double)Math.round(angleXY * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_YZ", "" + (double)Math.round(angleYZ * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_ZX", "" + (double)Math.round(angleZX * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("CONFINMENT_RATIO", "" + (double)Math.round(confinmentRatio * 1000.0D) / 1000.0D);
<          this.trackTable.addValue("TRACK_CLASSIFICATION", "");
<          if (confinmentRatio == 0.0D) {
<             this.trackTable.addValue("TRACK_CLASSIFICATION", "Total-Confined Track");
<          }
< 
<          if (confinmentRatio == 1.0D) {
<             this.trackTable.addValue("TRACK_CLASSIFICATION", "Perfectly Straight Track");
<          }
< 
<          if (confinmentRatio > 0.0D && confinmentRatio <= 0.5D) {
<             this.trackTable.addValue("TRACK_CLASSIFICATION", "Strongly Confined Track");
<          }
< 
<          if (confinmentRatio > 0.05D && confinmentRatio <= 0.25D) {
<             this.trackTable.addValue("TRACK_CLASSIFICATION", "Purely Random Track");
<          }
< 
<          if (confinmentRatio > 0.25D && confinmentRatio < 1.0D) {
<             this.trackTable.addValue("TRACK_CLASSIFICATION", "Fairly Straight Track");
<          }
<       }
< 
<       return this.trackTable;
<    }
< 
<    public ResultsTable getEdgeTable() {
<       return this.edgeTable;
<    }
< 
<    public ResultsTable getTrackTable() {
<       return this.trackTable;
<    }
< 
<    private static final class EdgeSourceSpotFrameComparator implements Comparator<DefaultWeightedEdge> {
<       private final Model model;
< 
<       public EdgeSourceSpotFrameComparator(Model model) {
<          this.model = model;
<       }
< 
<       public int compare(DefaultWeightedEdge e1, DefaultWeightedEdge e2) {
<          double t1 = this.model.getTrackModel().getEdgeSource(e1).getFeature("FRAME");
<          double t2 = this.model.getTrackModel().getEdgeSource(e2).getFeature("FRAME");
<          if (t1 < t2) {
<             return -1;
<          } else {
<             return t1 > t2 ? 1 : 0;
<          }
<       }
<    }
< }
---
> /*     */ import fiji.plugin.trackmate.Dimension;
> /*     */ import fiji.plugin.trackmate.FeatureModel;
> /*     */ import fiji.plugin.trackmate.Model;
> /*     */ import fiji.plugin.trackmate.SelectionModel;
> /*     */ import fiji.plugin.trackmate.Spot;
> /*     */ import fiji.plugin.trackmate.TrackMate;
> /*     */ import fiji.plugin.trackmate.util.ModelTools;
> /*     */ import ij.measure.ResultsTable;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.Collection;
> /*     */ import java.util.Collections;
> /*     */ import java.util.Comparator;
> /*     */ import java.util.HashMap;
> /*     */ import java.util.List;
> /*     */ import java.util.Map;
> /*     */ import java.util.Set;
> /*     */ import net.imglib2.RealLocalizable;
> /*     */ import org.jgrapht.graph.DefaultWeightedEdge;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class SLTResultsTableVersion
> /*     */ {
> /*     */   public static final String NAME = "Export statistics to tables";
> /*     */   public static final String KEY = "EXPORT_STATS_TO_IJ";
> /*     */   public static final String INFO_TEXT = "<html>Compute and export all statistics to 3 ImageJ results table. Statistisc are separated in features computed for: <ol> \t<li> spots in filtered tracks; \t<li> links between those spots; \t<li> filtered tracks. </ol> For tracks and links, they are recalculated prior to exporting. Note that spots and links that are not in a filtered tracks are not part of this export.</html>";
> /*     */   private static final String SPOT_TABLE_NAME = "Spots in tracks statistics";
> /*     */   private static final String EDGE_TABLE_NAME = "Links in tracks statistics";
> /*     */   private static final String TRACK_TABLE_NAME = "Track statistics";
> /*     */   private static final String ID_COLUMN = "ID";
> /*     */   private static final String TRACK_ID_COLUMN = "TRACK_ID";
> /*     */   private ResultsTable spotTable;
> /*     */   private ResultsTable edgeTable;
> /*     */   private ResultsTable trackTable;
> /*     */   private final SelectionModel selectionModel;
> /*     */   public static final String KEYLINEAR = "Linear track analysis";
> /*     */   public static final String TRACK_TOTAL_DISTANCE_TRAVELED = "TOTAL_DISTANCE_TRAVELED";
> /*     */   public static final String TRACK_MAX_DISTANCE_TRAVELED = "MAX_DISTANCE_TRAVELED";
> /*     */   public static final String TRACK_CONFINMENT_RATIO = "CONFINMENT_RATIO";
> /*     */   public static final String TRACK_MEAN_STRAIGHT_LINE_SPEED = "MEAN_STRAIGHT_LINE_SPEED";
> /*     */   public static final String TRACK_LINEARITY_OF_FORWARD_PROGRESSION = "LINEARITY_OF_FORWARD_PROGRESSION";
> /*     */   public static final String TOTAL_ABSOLUTE_ANGLE_XY = "TOTAL_ABSOLUTE_ANGLE_XY";
> /*     */   public static final String TOTAL_ABSOLUTE_ANGLE_YZ = "TOTAL_ABSOLUTE_ANGLE_YZ";
> /*     */   public static final String TOTAL_ABSOLUTE_ANGLE_ZX = "TOTAL_ABSOLUTE_ANGLE_ZX";
> /*  87 */   public static final List<String> FEATURES = new ArrayList<>(9);
> /*     */   
> /*  89 */   public static final Map<String, String> FEATURE_NAMES = new HashMap<>(9);
> /*     */   
> /*  91 */   public static final Map<String, String> FEATURE_SHORT_NAMES = new HashMap<>(9);
> /*     */   
> /*  93 */   public static final Map<String, Dimension> FEATURE_DIMENSIONS = new HashMap<>(9);
> /*     */   
> /*  95 */   public static final Map<String, Boolean> IS_INT = new HashMap<>(9);
> /*     */   
> /*     */   public SLTResultsTableVersion(SelectionModel selectionModel) {
> /*  98 */     this.selectionModel = selectionModel;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ResultsTable executeSpot(TrackMate trackmate) {
> /* 111 */     Model model = trackmate.getModel();
> /* 112 */     FeatureModel fm = model.getFeatureModel();
> /*     */ 
> /*     */ 
> /*     */     
> /* 116 */     Set<Integer> trackIDs = model.getTrackModel().trackIDs(true);
> /* 117 */     Collection<String> spotFeatures = trackmate.getModel().getFeatureModel().getSpotFeatures();
> /*     */     
> /* 119 */     this.spotTable = new ResultsTable();
> /*     */ 
> /*     */     
> /* 122 */     for (Integer trackID : trackIDs) {
> /* 123 */       Set<Spot> track = model.getTrackModel().trackSpots(trackID);
> /*     */       
> /* 125 */       List<Spot> sortedTrack = new ArrayList<>(track);
> /* 126 */       Collections.sort(sortedTrack, Spot.frameComparator);
> /*     */       
> /* 128 */       for (Spot spot : sortedTrack) {
> /* 129 */         this.spotTable.incrementCounter();
> /* 130 */         this.spotTable.addLabel(spot.getName());
> /* 131 */         this.spotTable.addValue("ID", spot.ID());
> /* 132 */         this.spotTable.addValue("TRACK_ID", trackID.intValue());
> /* 133 */         for (String feature : spotFeatures) {
> /* 134 */           Double val = spot.getFeature(feature);
> /* 135 */           if (val == null) {
> /* 136 */             this.spotTable.addValue(feature, "None"); continue;
> /*     */           } 
> /* 138 */           if (((Boolean)fm.getSpotFeatureIsInt().get(feature)).booleanValue()) {
> /* 139 */             this.spotTable.addValue(feature, val.intValue()); continue;
> /*     */           } 
> /* 141 */           this.spotTable.addValue(feature, val.doubleValue());
> /*     */         } 
> /*     */       } 
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */     
> /* 148 */     return this.spotTable;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ResultsTable executeLink(TrackMate trackmate) {
> /* 155 */     Model model = trackmate.getModel();
> /* 156 */     FeatureModel fm = model.getFeatureModel();
> /*     */ 
> /*     */     
> /* 159 */     Set<Integer> trackIDs = model.getTrackModel().trackIDs(true);
> /*     */     
> /* 161 */     Collection<String> edgeFeatures = fm.getEdgeFeatures();
> /*     */     
> /* 163 */     this.edgeTable = new ResultsTable();
> /*     */ 
> /*     */     
> /* 166 */     for (Integer trackID : trackIDs) {
> /*     */       
> /* 168 */       Comparator<DefaultWeightedEdge> edgeTimeComparator = 
> /* 169 */         ModelTools.featureEdgeComparator("EDGE_TIME", fm);
> /* 170 */       Comparator<DefaultWeightedEdge> edgeSourceSpotTimeComparator = new EdgeSourceSpotFrameComparator(
> /* 171 */           model);
> /*     */       
> /* 173 */       Set<DefaultWeightedEdge> track = model.getTrackModel().trackEdges(trackID);
> /* 174 */       List<DefaultWeightedEdge> sortedTrack = new ArrayList<>(track);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */       
> /* 180 */       if (model.getFeatureModel().getEdgeFeatures().contains("Edge location")) {
> /* 181 */         Collections.sort(sortedTrack, edgeTimeComparator);
> /*     */       } else {
> /* 183 */         Collections.sort(sortedTrack, edgeSourceSpotTimeComparator);
> /*     */       } 
> /* 185 */       for (DefaultWeightedEdge edge : sortedTrack) {
> /* 186 */         this.edgeTable.incrementCounter();
> /* 187 */         this.edgeTable.addLabel(edge.toString());
> /* 188 */         this.edgeTable.addValue("TRACK_ID", trackID.intValue());
> /* 189 */         for (String feature : edgeFeatures) {
> /* 190 */           Object o = fm.getEdgeFeature(edge, feature);
> /* 191 */           if (o instanceof String) {
> /*     */             continue;
> /*     */           }
> /* 194 */           Number d = (Number)o;
> /* 195 */           if (d == null) {
> /* 196 */             this.edgeTable.addValue(feature, "None"); continue;
> /*     */           } 
> /* 198 */           if (((Boolean)fm.getEdgeFeatureIsInt().get(feature)).booleanValue()) {
> /* 199 */             this.edgeTable.addValue(feature, d.intValue()); continue;
> /*     */           } 
> /* 201 */           this.edgeTable.addValue(feature, d.doubleValue());
> /*     */         } 
> /*     */       } 
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 213 */     return this.edgeTable;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public ResultsTable executeTrack(TrackMate trackmate) {
> /* 218 */     FEATURES.add("TOTAL_DISTANCE_TRAVELED");
> /* 219 */     FEATURES.add("MAX_DISTANCE_TRAVELED");
> /* 220 */     FEATURES.add("CONFINMENT_RATIO");
> /* 221 */     FEATURES.add("MEAN_STRAIGHT_LINE_SPEED");
> /* 222 */     FEATURES.add("LINEARITY_OF_FORWARD_PROGRESSION");
> /*     */     
> /* 224 */     FEATURES.add("TOTAL_ABSOLUTE_ANGLE_XY");
> /* 225 */     FEATURES.add("TOTAL_ABSOLUTE_ANGLE_YZ");
> /* 226 */     FEATURES.add("TOTAL_ABSOLUTE_ANGLE_ZX");
> /*     */     
> /* 228 */     FEATURE_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total distance traveled");
> /* 229 */     FEATURE_NAMES.put("MAX_DISTANCE_TRAVELED", "Max distance traveled");
> /* 230 */     FEATURE_NAMES.put("CONFINMENT_RATIO", "Confinment ratio");
> /* 231 */     FEATURE_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean straight line speed");
> /* 232 */     FEATURE_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Linearity of forward progression");
> /*     */ 
> /*     */     
> /* 235 */     FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Absolute angle in xy plane");
> /* 236 */     FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Absolute angle in yz plane");
> /* 237 */     FEATURE_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Absolute angle in zx plane");
> /*     */     
> /* 239 */     FEATURE_SHORT_NAMES.put("TOTAL_DISTANCE_TRAVELED", "Total dist.");
> /* 240 */     FEATURE_SHORT_NAMES.put("MAX_DISTANCE_TRAVELED", "Max dist.");
> /* 241 */     FEATURE_SHORT_NAMES.put("CONFINMENT_RATIO", "Cnfnmnt ratio");
> /* 242 */     FEATURE_SHORT_NAMES.put("MEAN_STRAIGHT_LINE_SPEED", "Mean v. line");
> /* 243 */     FEATURE_SHORT_NAMES.put("LINEARITY_OF_FORWARD_PROGRESSION", "Lin. fwd. progr.");
> /*     */ 
> /*     */     
> /* 246 */     FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_XY", "Abs. angle xy");
> /* 247 */     FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_YZ", "Abs. angle yz");
> /* 248 */     FEATURE_SHORT_NAMES.put("TOTAL_ABSOLUTE_ANGLE_ZX", "Abs. angle zx");
> /*     */     
> /* 250 */     FEATURE_DIMENSIONS.put("TOTAL_DISTANCE_TRAVELED", Dimension.LENGTH);
> /* 251 */     FEATURE_DIMENSIONS.put("MAX_DISTANCE_TRAVELED", Dimension.LENGTH);
> /* 252 */     FEATURE_DIMENSIONS.put("CONFINMENT_RATIO", Dimension.NONE);
> /* 253 */     FEATURE_DIMENSIONS.put("MEAN_STRAIGHT_LINE_SPEED", Dimension.VELOCITY);
> /* 254 */     FEATURE_DIMENSIONS.put("LINEARITY_OF_FORWARD_PROGRESSION", Dimension.NONE);
> /*     */     
> /* 256 */     FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_XY", Dimension.ANGLE);
> /* 257 */     FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_YZ", Dimension.ANGLE);
> /* 258 */     FEATURE_DIMENSIONS.put("TOTAL_ABSOLUTE_ANGLE_ZX", Dimension.ANGLE);
> /*     */     
> /* 260 */     IS_INT.put("TOTAL_DISTANCE_TRAVELED", Boolean.FALSE);
> /* 261 */     IS_INT.put("MAX_DISTANCE_TRAVELED", Boolean.FALSE);
> /* 262 */     IS_INT.put("CONFINMENT_RATIO", Boolean.FALSE);
> /* 263 */     IS_INT.put("MEAN_STRAIGHT_LINE_SPEED", Boolean.FALSE);
> /* 264 */     IS_INT.put("LINEARITY_OF_FORWARD_PROGRESSION", Boolean.FALSE);
> /*     */     
> /* 266 */     IS_INT.put("TOTAL_ABSOLUTE_ANGLE_XY", Boolean.FALSE);
> /* 267 */     IS_INT.put("TOTAL_ABSOLUTE_ANGLE_YZ", Boolean.FALSE);
> /* 268 */     IS_INT.put("TOTAL_ABSOLUTE_ANGLE_ZX", Boolean.FALSE);
> /*     */ 
> /*     */     
> /* 271 */     Model model = trackmate.getModel();
> /* 272 */     FeatureModel fm = model.getFeatureModel();
> /*     */ 
> /*     */     
> /* 275 */     Set<Integer> trackIDs = model.getTrackModel().trackIDs(true);
> /*     */ 
> /*     */     
> /* 278 */     this.trackTable = new ResultsTable();
> /*     */ 
> /*     */     
> /* 281 */     for (Integer trackID : trackIDs) {
> /*     */       
> /* 283 */       List<Spot> spots = new ArrayList<>(model.getTrackModel().trackSpots(trackID));
> /* 284 */       Collections.sort(spots, Spot.frameComparator);
> /* 285 */       Spot first = spots.get(0);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */       
> /* 291 */       Set<DefaultWeightedEdge> edges = model.getTrackModel().trackEdges(trackID);
> /*     */       
> /* 293 */       double totalDistance = 0.0D;
> /* 294 */       double maxDistanceSq = Double.NEGATIVE_INFINITY;
> /* 295 */       double maxDistance = 0.0D;
> /* 296 */       double dx = 0.0D;
> /* 297 */       double dy = 0.0D;
> /* 298 */       double dz = 0.0D;
> /*     */       
> /* 300 */       for (DefaultWeightedEdge edge : edges) {
> /*     */         
> /* 302 */         Spot source = model.getTrackModel().getEdgeSource(edge);
> /* 303 */         Spot target = model.getTrackModel().getEdgeTarget(edge);
> /* 304 */         double d = Math.sqrt(source.squareDistanceTo((RealLocalizable)target));
> /* 305 */         totalDistance += d;
> /*     */ 
> /*     */         
> /* 308 */         double dToFirstSq = first.squareDistanceTo((RealLocalizable)target);
> /* 309 */         if (dToFirstSq > maxDistanceSq) {
> /* 310 */           maxDistanceSq = dToFirstSq;
> /* 311 */           maxDistance = Math.sqrt(maxDistanceSq);
> /*     */         } 
> /*     */         
> /* 314 */         dx += target.getDoublePosition(0) - source.getDoublePosition(0);
> /* 315 */         dy += target.getDoublePosition(1) - source.getDoublePosition(1);
> /* 316 */         dz += target.getDoublePosition(2) - source.getDoublePosition(2);
> /*     */       } 
> /*     */ 
> /*     */       
> /* 320 */       double netDistance = fm.getTrackFeature(trackID, "TRACK_DISPLACEMENT").doubleValue();
> /* 321 */       double tTotal = fm.getTrackFeature(trackID, "TRACK_DURATION").doubleValue();
> /* 322 */       double vMean = fm.getTrackFeature(trackID, "TRACK_MEAN_SPEED").doubleValue();
> /*     */ 
> /*     */       
> /* 325 */       double confinmentRatio = netDistance / totalDistance;
> /* 326 */       double meanStraightLineSpeed = netDistance / tTotal;
> /* 327 */       double linearityForwardProgression = meanStraightLineSpeed / vMean;
> /*     */ 
> /*     */ 
> /*     */       
> /* 331 */       double angleXY = Math.atan2(dy, dx);
> /* 332 */       double angleYZ = Math.atan2(dz, dy);
> /* 333 */       double angleZX = Math.atan2(dx, dz);
> /* 334 */       Collection<String> trackFeatures = fm.getTrackFeatures();
> /* 335 */       this.trackTable.incrementCounter();
> /* 336 */       this.trackTable.addLabel(model.getTrackModel().name(trackID));
> /* 337 */       this.trackTable.addValue("TRACK_ID", trackID.intValue());
> /*     */       
> /* 339 */       for (String feature : trackFeatures) {
> /* 340 */         Double val = fm.getTrackFeature(trackID, feature);
> /* 341 */         if (val == null) {
> /* 342 */           this.trackTable.addValue(feature, "None"); continue;
> /*     */         } 
> /* 344 */         if (((Boolean)fm.getTrackFeatureIsInt().get(feature)).booleanValue()) {
> /* 345 */           this.trackTable.addValue(feature, val.intValue()); continue;
> /*     */         } 
> /* 347 */         this.trackTable.addValue(feature, val.doubleValue());
> /*     */       } 
> /*     */ 
> /*     */ 
> /*     */       
> /* 352 */       this.trackTable.addValue("TOTAL_DISTANCE_TRAVELED", Math.round(totalDistance * 1000.0D) / 1000.0D);
> /* 353 */       this.trackTable.addValue("MAX_DISTANCE_TRAVELED", Math.round(maxDistance * 1000.0D) / 1000.0D);
> /* 354 */       this.trackTable.addValue("MEAN_STRAIGHT_LINE_SPEED", 
> /* 355 */           Math.round(meanStraightLineSpeed * 1000.0D) / 1000.0D);
> /* 356 */       this.trackTable.addValue("LINEARITY_OF_FORWARD_PROGRESSION", 
> /* 357 */           Math.round(linearityForwardProgression * 1000.0D) / 1000.0D);
> /* 358 */       this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_XY", Math.round(angleXY * 1000.0D) / 1000.0D);
> /* 359 */       this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_YZ", Math.round(angleYZ * 1000.0D) / 1000.0D);
> /* 360 */       this.trackTable.addValue("TOTAL_ABSOLUTE_ANGLE_ZX", Math.round(angleZX * 1000.0D) / 1000.0D);
> /* 361 */       this.trackTable.addValue("CONFINMENT_RATIO", Math.round(confinmentRatio * 1000.0D) / 1000.0D);
> /* 362 */       this.trackTable.addValue("TRACK_CLASSIFICATION", "");
> /*     */       
> /* 364 */       if (confinmentRatio == 0.0D)
> /* 365 */         this.trackTable.addValue("TRACK_CLASSIFICATION", "Total-Confined Track"); 
> /* 366 */       if (confinmentRatio == 1.0D)
> /* 367 */         this.trackTable.addValue("TRACK_CLASSIFICATION", "Perfectly Straight Track"); 
> /* 368 */       if (confinmentRatio > 0.0D && confinmentRatio <= 0.5D)
> /* 369 */         this.trackTable.addValue("TRACK_CLASSIFICATION", "Strongly Confined Track"); 
> /* 370 */       if (confinmentRatio > 0.05D && confinmentRatio <= 0.25D)
> /* 371 */         this.trackTable.addValue("TRACK_CLASSIFICATION", "Purely Random Track"); 
> /* 372 */       if (confinmentRatio > 0.25D && confinmentRatio < 1.0D) {
> /* 373 */         this.trackTable.addValue("TRACK_CLASSIFICATION", "Fairly Straight Track");
> /*     */       }
> /*     */     } 
> /*     */ 
> /*     */     
> /* 378 */     return this.trackTable;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ResultsTable getEdgeTable() {
> /* 389 */     return this.edgeTable;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ResultsTable getTrackTable() {
> /* 400 */     return this.trackTable;
> /*     */   }
> /*     */   
> /*     */   private static final class EdgeSourceSpotFrameComparator
> /*     */     implements Comparator<DefaultWeightedEdge> {
> /*     */     private final Model model;
> /*     */     
> /*     */     public EdgeSourceSpotFrameComparator(Model model) {
> /* 408 */       this.model = model;
> /*     */     }
> /*     */ 
> /*     */     
> /*     */     public int compare(DefaultWeightedEdge e1, DefaultWeightedEdge e2) {
> /* 413 */       double t1 = this.model.getTrackModel().getEdgeSource(e1).getFeature("FRAME").doubleValue();
> /* 414 */       double t2 = this.model.getTrackModel().getEdgeSource(e2).getFeature("FRAME").doubleValue();
> /* 415 */       if (t1 < t2) {
> /* 416 */         return -1;
> /*     */       }
> /* 418 */       if (t1 > t2) {
> /* 419 */         return 1;
> /*     */       }
> /* 421 */       return 0;
> /*     */     }
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/SLTResultsTableVersion.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/AbstractDistributionModified.java jd-gui/smileModified/AbstractDistributionModified.java
1,40c1,138
< package smileModified;
< 
< public abstract class AbstractDistributionModified implements DistributionModified {
<    protected double rejection(double pmax, double xmin, double xmax) {
<       double x;
<       double y;
<       do {
<          x = xmin + MathExModified.random() * (xmax - xmin);
<          y = MathExModified.random() * pmax;
<       } while(this.p(x) < y);
< 
<       return x;
<    }
< 
<    protected double inverseTransformSampling() {
<       double u = MathExModified.random();
<       return this.quantile(u);
<    }
< 
<    protected double quantile(double p, double xmin, double xmax, double eps) {
<       if (eps <= 0.0D) {
<          throw new IllegalArgumentException("Invalid epsilon: " + eps);
<       } else {
<          while(Math.abs(xmax - xmin) > eps) {
<             double xmed = (xmax + xmin) / 2.0D;
<             if (this.cdf(xmed) > p) {
<                xmax = xmed;
<             } else {
<                xmin = xmed;
<             }
<          }
< 
<          return xmin;
<       }
<    }
< 
<    protected double quantile(double p, double xmin, double xmax) {
<       return this.quantile(p, xmin, xmax, 1.0E-6D);
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class AbstractDistributionModified
> /*     */   implements DistributionModified
> /*     */ {
> /*     */   protected double rejection(double pmax, double xmin, double xmax) {
> /*     */     double x;
> /*     */     double y;
> /*     */     do {
> /*  64 */       x = xmin + MathExModified.random() * (xmax - xmin);
> /*  65 */       y = MathExModified.random() * pmax;
> /*  66 */     } while (p(x) < y);
> /*     */     
> /*  68 */     return x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   protected double inverseTransformSampling() {
> /*  90 */     double u = MathExModified.random();
> /*  91 */     return quantile(u);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   protected double quantile(double p, double xmin, double xmax, double eps) {
> /* 105 */     if (eps <= 0.0D) {
> /* 106 */       throw new IllegalArgumentException("Invalid epsilon: " + eps);
> /*     */     }
> /*     */     
> /* 109 */     while (Math.abs(xmax - xmin) > eps) {
> /* 110 */       double xmed = (xmax + xmin) / 2.0D;
> /* 111 */       if (cdf(xmed) > p) {
> /* 112 */         xmax = xmed; continue;
> /*     */       } 
> /* 114 */       xmin = xmed;
> /*     */     } 
> /*     */ 
> /*     */     
> /* 118 */     return xmin;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   protected double quantile(double p, double xmin, double xmax) {
> /* 130 */     return quantile(p, xmin, xmax, 1.0E-6D);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/AbstractDistributionModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/BLASModified.java jd-gui/smileModified/BLASModified.java
1,223c1,643
< package smileModified;
< 
< import java.nio.DoubleBuffer;
< import java.nio.FloatBuffer;
< import org.bytedeco.javacpp.DoublePointer;
< import org.slf4j.Logger;
< import org.slf4j.LoggerFactory;
< 
< public interface BLASModified {
<    BLASModified engine = getInstance();
< 
<    static BLASModified getInstance() {
<       BLASModified mkl = MKL();
<       return (BLASModified)(mkl != null ? mkl : new OpenBLASModified());
<    }
< 
<    static BLASModified MKL() {
<       Logger logger = LoggerFactory.getLogger(BLASModified.class);
< 
<       try {
<          Class<?> clazz = Class.forName("smile.math.blas.mkl.MKL");
<          logger.info("smile-mkl module is available.");
<          return (BLASModified)clazz.getDeclaredConstructor().newInstance();
<       } catch (Exception var2) {
<          logger.debug("Failed to create MKL instance: ", var2);
<          return null;
<       }
<    }
< 
<    double asum(int var1, double[] var2, int var3);
< 
<    float asum(int var1, float[] var2, int var3);
< 
<    default double asum(double[] x) {
<       return this.asum(x.length, (double[])x, 1);
<    }
< 
<    default float asum(float[] x) {
<       return this.asum(x.length, (float[])x, 1);
<    }
< 
<    void axpy(int var1, double var2, double[] var4, int var5, double[] var6, int var7);
< 
<    void axpy(int var1, float var2, float[] var3, int var4, float[] var5, int var6);
< 
<    default void axpy(double alpha, double[] x, double[] y) {
<       this.axpy(x.length, alpha, x, 1, y, 1);
<    }
< 
<    default void axpy(float alpha, float[] x, float[] y) {
<       this.axpy(x.length, alpha, x, 1, y, 1);
<    }
< 
<    double dot(int var1, double[] var2, int var3, double[] var4, int var5);
< 
<    float dot(int var1, float[] var2, int var3, float[] var4, int var5);
< 
<    default double dot(double[] x, double[] y) {
<       return this.dot(x.length, (double[])x, 1, (double[])y, 1);
<    }
< 
<    default float dot(float[] x, float[] y) {
<       return this.dot(x.length, (float[])x, 1, (float[])y, 1);
<    }
< 
<    double nrm2(int var1, double[] var2, int var3);
< 
<    float nrm2(int var1, float[] var2, int var3);
< 
<    default double nrm2(double[] x) {
<       return this.nrm2(x.length, (double[])x, 1);
<    }
< 
<    default float nrm2(float[] x) {
<       return this.nrm2(x.length, (float[])x, 1);
<    }
< 
<    void scal(int var1, double var2, double[] var4, int var5);
< 
<    void scal(int var1, float var2, float[] var3, int var4);
< 
<    default void scal(double alpha, double[] x) {
<       this.scal(x.length, alpha, x, 1);
<    }
< 
<    default void scal(float alpha, float[] x) {
<       this.scal(x.length, alpha, x, 1);
<    }
< 
<    void swap(int var1, double[] var2, int var3, double[] var4, int var5);
< 
<    void swap(int var1, float[] var2, int var3, float[] var4, int var5);
< 
<    default void swap(double[] x, double[] y) {
<       this.swap(x.length, (double[])x, 1, (double[])y, 1);
<    }
< 
<    default void swap(float[] x, float[] y) {
<       this.swap(x.length, (float[])x, 1, (float[])y, 1);
<    }
< 
<    long iamax(int var1, double[] var2, int var3);
< 
<    long iamax(int var1, float[] var2, int var3);
< 
<    default long iamax(double[] x) {
<       return this.iamax(x.length, (double[])x, 1);
<    }
< 
<    default long iamax(float[] x) {
<       return this.iamax(x.length, (float[])x, 1);
<    }
< 
<    void gemv(LayoutModified var1, TransposeModified var2, int var3, int var4, double var5, double[] var7, int var8, double[] var9, int var10, double var11, double[] var13, int var14);
< 
<    void gemv(LayoutModified var1, TransposeModified var2, int var3, int var4, double var5, DoubleBuffer var7, int var8, DoubleBuffer var9, int var10, double var11, DoubleBuffer var13, int var14);
< 
<    void gemv(LayoutModified var1, TransposeModified var2, int var3, int var4, double var5, DoublePointer var7, int var8, DoublePointer var9, int var10, double var11, DoublePointer var13, int var14);
< 
<    void gemv(LayoutModified var1, TransposeModified var2, int var3, int var4, float var5, float[] var6, int var7, float[] var8, int var9, float var10, float[] var11, int var12);
< 
<    void gemv(LayoutModified var1, TransposeModified var2, int var3, int var4, float var5, FloatBuffer var6, int var7, FloatBuffer var8, int var9, float var10, FloatBuffer var11, int var12);
< 
<    void symv(LayoutModified var1, UPLOModified var2, int var3, double var4, double[] var6, int var7, double[] var8, int var9, double var10, double[] var12, int var13);
< 
<    void symv(LayoutModified var1, UPLOModified var2, int var3, double var4, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9, double var10, DoubleBuffer var12, int var13);
< 
<    void symv(LayoutModified var1, UPLOModified var2, int var3, double var4, DoublePointer var6, int var7, DoublePointer var8, int var9, double var10, DoublePointer var12, int var13);
< 
<    void symv(LayoutModified var1, UPLOModified var2, int var3, float var4, float[] var5, int var6, float[] var7, int var8, float var9, float[] var10, int var11);
< 
<    void symv(LayoutModified var1, UPLOModified var2, int var3, float var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, float var9, FloatBuffer var10, int var11);
< 
<    void spmv(LayoutModified var1, UPLOModified var2, int var3, double var4, double[] var6, double[] var7, int var8, double var9, double[] var11, int var12);
< 
<    void spmv(LayoutModified var1, UPLOModified var2, int var3, double var4, DoubleBuffer var6, DoubleBuffer var7, int var8, double var9, DoubleBuffer var11, int var12);
< 
<    void spmv(LayoutModified var1, UPLOModified var2, int var3, float var4, float[] var5, float[] var6, int var7, float var8, float[] var9, int var10);
< 
<    void spmv(LayoutModified var1, UPLOModified var2, int var3, float var4, FloatBuffer var5, FloatBuffer var6, int var7, float var8, FloatBuffer var9, int var10);
< 
<    void trmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, double[] var6, int var7, double[] var8, int var9);
< 
<    void trmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9);
< 
<    void trmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, DoublePointer var6, int var7, DoublePointer var8, int var9);
< 
<    void trmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, float[] var6, int var7, float[] var8, int var9);
< 
<    void trmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, FloatBuffer var6, int var7, FloatBuffer var8, int var9);
< 
<    void tpmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, double[] var6, double[] var7, int var8);
< 
<    void tpmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, DoubleBuffer var6, DoubleBuffer var7, int var8);
< 
<    void tpmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, float[] var6, float[] var7, int var8);
< 
<    void tpmv(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, FloatBuffer var6, FloatBuffer var7, int var8);
< 
<    void gbmv(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, double var7, double[] var9, int var10, double[] var11, int var12, double var13, double[] var15, int var16);
< 
<    void gbmv(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, double var7, DoubleBuffer var9, int var10, DoubleBuffer var11, int var12, double var13, DoubleBuffer var15, int var16);
< 
<    void gbmv(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, float var7, float[] var8, int var9, float[] var10, int var11, float var12, float[] var13, int var14);
< 
<    void gbmv(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, float var7, FloatBuffer var8, int var9, FloatBuffer var10, int var11, float var12, FloatBuffer var13, int var14);
< 
<    void sbmv(LayoutModified var1, UPLOModified var2, int var3, int var4, double var5, double[] var7, int var8, double[] var9, int var10, double var11, double[] var13, int var14);
< 
<    void sbmv(LayoutModified var1, UPLOModified var2, int var3, int var4, double var5, DoubleBuffer var7, int var8, DoubleBuffer var9, int var10, double var11, DoubleBuffer var13, int var14);
< 
<    void sbmv(LayoutModified var1, UPLOModified var2, int var3, int var4, float var5, float[] var6, int var7, float[] var8, int var9, float var10, float[] var11, int var12);
< 
<    void sbmv(LayoutModified var1, UPLOModified var2, int var3, int var4, float var5, FloatBuffer var6, int var7, FloatBuffer var8, int var9, float var10, FloatBuffer var11, int var12);
< 
<    void ger(LayoutModified var1, int var2, int var3, double var4, double[] var6, int var7, double[] var8, int var9, double[] var10, int var11);
< 
<    void ger(LayoutModified var1, int var2, int var3, double var4, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9, DoubleBuffer var10, int var11);
< 
<    void ger(LayoutModified var1, int var2, int var3, double var4, DoublePointer var6, int var7, DoublePointer var8, int var9, DoublePointer var10, int var11);
< 
<    void ger(LayoutModified var1, int var2, int var3, float var4, float[] var5, int var6, float[] var7, int var8, float[] var9, int var10);
< 
<    void ger(LayoutModified var1, int var2, int var3, float var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, int var10);
< 
<    void syr(LayoutModified var1, UPLOModified var2, int var3, double var4, double[] var6, int var7, double[] var8, int var9);
< 
<    void syr(LayoutModified var1, UPLOModified var2, int var3, double var4, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9);
< 
<    void syr(LayoutModified var1, UPLOModified var2, int var3, double var4, DoublePointer var6, int var7, DoublePointer var8, int var9);
< 
<    void syr(LayoutModified var1, UPLOModified var2, int var3, float var4, float[] var5, int var6, float[] var7, int var8);
< 
<    void syr(LayoutModified var1, UPLOModified var2, int var3, float var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8);
< 
<    void spr(LayoutModified var1, UPLOModified var2, int var3, double var4, double[] var6, int var7, double[] var8);
< 
<    void spr(LayoutModified var1, UPLOModified var2, int var3, double var4, DoubleBuffer var6, int var7, DoubleBuffer var8);
< 
<    void spr(LayoutModified var1, UPLOModified var2, int var3, float var4, float[] var5, int var6, float[] var7);
< 
<    void spr(LayoutModified var1, UPLOModified var2, int var3, float var4, FloatBuffer var5, int var6, FloatBuffer var7);
< 
<    void gemm(LayoutModified var1, TransposeModified var2, TransposeModified var3, int var4, int var5, int var6, double var7, double[] var9, int var10, double[] var11, int var12, double var13, double[] var15, int var16);
< 
<    void gemm(LayoutModified var1, TransposeModified var2, TransposeModified var3, int var4, int var5, int var6, double var7, DoubleBuffer var9, int var10, DoubleBuffer var11, int var12, double var13, DoubleBuffer var15, int var16);
< 
<    void gemm(LayoutModified var1, TransposeModified var2, TransposeModified var3, int var4, int var5, int var6, double var7, DoublePointer var9, int var10, DoublePointer var11, int var12, double var13, DoublePointer var15, int var16);
< 
<    void gemm(LayoutModified var1, TransposeModified var2, TransposeModified var3, int var4, int var5, int var6, float var7, float[] var8, int var9, float[] var10, int var11, float var12, float[] var13, int var14);
< 
<    void gemm(LayoutModified var1, TransposeModified var2, TransposeModified var3, int var4, int var5, int var6, float var7, FloatBuffer var8, int var9, FloatBuffer var10, int var11, float var12, FloatBuffer var13, int var14);
< 
<    void symm(LayoutModified var1, SideModified var2, UPLOModified var3, int var4, int var5, double var6, double[] var8, int var9, double[] var10, int var11, double var12, double[] var14, int var15);
< 
<    void symm(LayoutModified var1, SideModified var2, UPLOModified var3, int var4, int var5, double var6, DoubleBuffer var8, int var9, DoubleBuffer var10, int var11, double var12, DoubleBuffer var14, int var15);
< 
<    void symm(LayoutModified var1, SideModified var2, UPLOModified var3, int var4, int var5, double var6, DoublePointer var8, int var9, DoublePointer var10, int var11, double var12, DoublePointer var14, int var15);
< 
<    void symm(LayoutModified var1, SideModified var2, UPLOModified var3, int var4, int var5, float var6, float[] var7, int var8, float[] var9, int var10, float var11, float[] var12, int var13);
< 
<    void symm(LayoutModified var1, SideModified var2, UPLOModified var3, int var4, int var5, float var6, FloatBuffer var7, int var8, FloatBuffer var9, int var10, float var11, FloatBuffer var12, int var13);
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.nio.DoubleBuffer;
> /*     */ import java.nio.FloatBuffer;
> /*     */ import org.bytedeco.javacpp.DoublePointer;
> /*     */ import org.slf4j.Logger;
> /*     */ import org.slf4j.LoggerFactory;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public interface BLASModified
> /*     */ {
> /*  35 */   public static final BLASModified engine = getInstance();
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static BLASModified getInstance() {
> /*  42 */     BLASModified mkl = MKL();
> /*  43 */     return (mkl != null) ? mkl : new OpenBLASModified();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static BLASModified MKL() {
> /*  51 */     Logger logger = LoggerFactory.getLogger(BLASModified.class);
> /*     */     
> /*     */     try {
> /*  54 */       Class<?> clazz = Class.forName("smile.math.blas.mkl.MKL");
> /*  55 */       logger.info("smile-mkl module is available.");
> /*  56 */       return clazz.getDeclaredConstructor(new Class[0]).newInstance(new Object[0]);
> /*  57 */     } catch (Exception e) {
> /*  58 */       logger.debug("Failed to create MKL instance: ", e);
> /*     */ 
> /*     */       
> /*  61 */       return null;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   double asum(int paramInt1, double[] paramArrayOfdouble, int paramInt2);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   float asum(int paramInt1, float[] paramArrayOffloat, int paramInt2);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default double asum(double[] x) {
> /* 108 */     return asum(x.length, x, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default float asum(float[] x) {
> /* 119 */     return asum(x.length, x, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void axpy(int paramInt1, double paramDouble, double[] paramArrayOfdouble1, int paramInt2, double[] paramArrayOfdouble2, int paramInt3);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void axpy(int paramInt1, float paramFloat, float[] paramArrayOffloat1, int paramInt2, float[] paramArrayOffloat2, int paramInt3);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default void axpy(double alpha, double[] x, double[] y) {
> /* 200 */     axpy(x.length, alpha, x, 1, y, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default void axpy(float alpha, float[] x, float[] y) {
> /* 219 */     axpy(x.length, alpha, x, 1, y, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   double dot(int paramInt1, double[] paramArrayOfdouble1, int paramInt2, double[] paramArrayOfdouble2, int paramInt3);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   float dot(int paramInt1, float[] paramArrayOffloat1, int paramInt2, float[] paramArrayOffloat2, int paramInt3);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default double dot(double[] x, double[] y) {
> /* 282 */     return dot(x.length, x, 1, y, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default float dot(float[] x, float[] y) {
> /* 295 */     return dot(x.length, x, 1, y, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   double nrm2(int paramInt1, double[] paramArrayOfdouble, int paramInt2);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   float nrm2(int paramInt1, float[] paramArrayOffloat, int paramInt2);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default double nrm2(double[] x) {
> /* 336 */     return nrm2(x.length, x, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default float nrm2(float[] x) {
> /* 347 */     return nrm2(x.length, x, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void scal(int paramInt1, double paramDouble, double[] paramArrayOfdouble, int paramInt2);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void scal(int paramInt1, float paramFloat, float[] paramArrayOffloat, int paramInt2);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default void scal(double alpha, double[] x) {
> /* 388 */     scal(x.length, alpha, x, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default void scal(float alpha, float[] x) {
> /* 399 */     scal(x.length, alpha, x, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void swap(int paramInt1, double[] paramArrayOfdouble1, int paramInt2, double[] paramArrayOfdouble2, int paramInt3);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   void swap(int paramInt1, float[] paramArrayOffloat1, int paramInt2, float[] paramArrayOffloat2, int paramInt3);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default void swap(double[] x, double[] y) {
> /* 456 */     swap(x.length, x, 1, y, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default void swap(float[] x, float[] y) {
> /* 467 */     swap(x.length, x, 1, y, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   long iamax(int paramInt1, double[] paramArrayOfdouble, int paramInt2);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   long iamax(int paramInt1, float[] paramArrayOffloat, int paramInt2);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default long iamax(double[] x) {
> /* 513 */     return iamax(x.length, x, 1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default long iamax(float[] x) {
> /* 525 */     return iamax(x.length, x, 1);
> /*     */   }
> /*     */   
> /*     */   void gemv(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, double paramDouble1, double[] paramArrayOfdouble1, int paramInt3, double[] paramArrayOfdouble2, int paramInt4, double paramDouble2, double[] paramArrayOfdouble3, int paramInt5);
> /*     */   
> /*     */   void gemv(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, double paramDouble1, DoubleBuffer paramDoubleBuffer1, int paramInt3, DoubleBuffer paramDoubleBuffer2, int paramInt4, double paramDouble2, DoubleBuffer paramDoubleBuffer3, int paramInt5);
> /*     */   
> /*     */   void gemv(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, double paramDouble1, DoublePointer paramDoublePointer1, int paramInt3, DoublePointer paramDoublePointer2, int paramInt4, double paramDouble2, DoublePointer paramDoublePointer3, int paramInt5);
> /*     */   
> /*     */   void gemv(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, float paramFloat1, float[] paramArrayOffloat1, int paramInt3, float[] paramArrayOffloat2, int paramInt4, float paramFloat2, float[] paramArrayOffloat3, int paramInt5);
> /*     */   
> /*     */   void gemv(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, float paramFloat1, FloatBuffer paramFloatBuffer1, int paramInt3, FloatBuffer paramFloatBuffer2, int paramInt4, float paramFloat2, FloatBuffer paramFloatBuffer3, int paramInt5);
> /*     */   
> /*     */   void symv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double paramDouble1, double[] paramArrayOfdouble1, int paramInt2, double[] paramArrayOfdouble2, int paramInt3, double paramDouble2, double[] paramArrayOfdouble3, int paramInt4);
> /*     */   
> /*     */   void symv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double paramDouble1, DoubleBuffer paramDoubleBuffer1, int paramInt2, DoubleBuffer paramDoubleBuffer2, int paramInt3, double paramDouble2, DoubleBuffer paramDoubleBuffer3, int paramInt4);
> /*     */   
> /*     */   void symv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double paramDouble1, DoublePointer paramDoublePointer1, int paramInt2, DoublePointer paramDoublePointer2, int paramInt3, double paramDouble2, DoublePointer paramDoublePointer3, int paramInt4);
> /*     */   
> /*     */   void symv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, float paramFloat1, float[] paramArrayOffloat1, int paramInt2, float[] paramArrayOffloat2, int paramInt3, float paramFloat2, float[] paramArrayOffloat3, int paramInt4);
> /*     */   
> /*     */   void symv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, float paramFloat1, FloatBuffer paramFloatBuffer1, int paramInt2, FloatBuffer paramFloatBuffer2, int paramInt3, float paramFloat2, FloatBuffer paramFloatBuffer3, int paramInt4);
> /*     */   
> /*     */   void spmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double paramDouble1, double[] paramArrayOfdouble1, double[] paramArrayOfdouble2, int paramInt2, double paramDouble2, double[] paramArrayOfdouble3, int paramInt3);
> /*     */   
> /*     */   void spmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double paramDouble1, DoubleBuffer paramDoubleBuffer1, DoubleBuffer paramDoubleBuffer2, int paramInt2, double paramDouble2, DoubleBuffer paramDoubleBuffer3, int paramInt3);
> /*     */   
> /*     */   void spmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, float paramFloat1, float[] paramArrayOffloat1, float[] paramArrayOffloat2, int paramInt2, float paramFloat2, float[] paramArrayOffloat3, int paramInt3);
> /*     */   
> /*     */   void spmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, float paramFloat1, FloatBuffer paramFloatBuffer1, FloatBuffer paramFloatBuffer2, int paramInt2, float paramFloat2, FloatBuffer paramFloatBuffer3, int paramInt3);
> /*     */   
> /*     */   void trmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, double[] paramArrayOfdouble1, int paramInt2, double[] paramArrayOfdouble2, int paramInt3);
> /*     */   
> /*     */   void trmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, DoubleBuffer paramDoubleBuffer1, int paramInt2, DoubleBuffer paramDoubleBuffer2, int paramInt3);
> /*     */   
> /*     */   void trmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, DoublePointer paramDoublePointer1, int paramInt2, DoublePointer paramDoublePointer2, int paramInt3);
> /*     */   
> /*     */   void trmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, float[] paramArrayOffloat1, int paramInt2, float[] paramArrayOffloat2, int paramInt3);
> /*     */   
> /*     */   void trmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, FloatBuffer paramFloatBuffer1, int paramInt2, FloatBuffer paramFloatBuffer2, int paramInt3);
> /*     */   
> /*     */   void tpmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, double[] paramArrayOfdouble1, double[] paramArrayOfdouble2, int paramInt2);
> /*     */   
> /*     */   void tpmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, DoubleBuffer paramDoubleBuffer1, DoubleBuffer paramDoubleBuffer2, int paramInt2);
> /*     */   
> /*     */   void tpmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, float[] paramArrayOffloat1, float[] paramArrayOffloat2, int paramInt2);
> /*     */   
> /*     */   void tpmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, FloatBuffer paramFloatBuffer1, FloatBuffer paramFloatBuffer2, int paramInt2);
> /*     */   
> /*     */   void gbmv(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, double paramDouble1, double[] paramArrayOfdouble1, int paramInt5, double[] paramArrayOfdouble2, int paramInt6, double paramDouble2, double[] paramArrayOfdouble3, int paramInt7);
> /*     */   
> /*     */   void gbmv(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, double paramDouble1, DoubleBuffer paramDoubleBuffer1, int paramInt5, DoubleBuffer paramDoubleBuffer2, int paramInt6, double paramDouble2, DoubleBuffer paramDoubleBuffer3, int paramInt7);
> /*     */   
> /*     */   void gbmv(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, float paramFloat1, float[] paramArrayOffloat1, int paramInt5, float[] paramArrayOffloat2, int paramInt6, float paramFloat2, float[] paramArrayOffloat3, int paramInt7);
> /*     */   
> /*     */   void gbmv(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, float paramFloat1, FloatBuffer paramFloatBuffer1, int paramInt5, FloatBuffer paramFloatBuffer2, int paramInt6, float paramFloat2, FloatBuffer paramFloatBuffer3, int paramInt7);
> /*     */   
> /*     */   void sbmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double paramDouble1, double[] paramArrayOfdouble1, int paramInt3, double[] paramArrayOfdouble2, int paramInt4, double paramDouble2, double[] paramArrayOfdouble3, int paramInt5);
> /*     */   
> /*     */   void sbmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double paramDouble1, DoubleBuffer paramDoubleBuffer1, int paramInt3, DoubleBuffer paramDoubleBuffer2, int paramInt4, double paramDouble2, DoubleBuffer paramDoubleBuffer3, int paramInt5);
> /*     */   
> /*     */   void sbmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float paramFloat1, float[] paramArrayOffloat1, int paramInt3, float[] paramArrayOffloat2, int paramInt4, float paramFloat2, float[] paramArrayOffloat3, int paramInt5);
> /*     */   
> /*     */   void sbmv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float paramFloat1, FloatBuffer paramFloatBuffer1, int paramInt3, FloatBuffer paramFloatBuffer2, int paramInt4, float paramFloat2, FloatBuffer paramFloatBuffer3, int paramInt5);
> /*     */   
> /*     */   void ger(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, double paramDouble, double[] paramArrayOfdouble1, int paramInt3, double[] paramArrayOfdouble2, int paramInt4, double[] paramArrayOfdouble3, int paramInt5);
> /*     */   
> /*     */   void ger(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, double paramDouble, DoubleBuffer paramDoubleBuffer1, int paramInt3, DoubleBuffer paramDoubleBuffer2, int paramInt4, DoubleBuffer paramDoubleBuffer3, int paramInt5);
> /*     */   
> /*     */   void ger(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, double paramDouble, DoublePointer paramDoublePointer1, int paramInt3, DoublePointer paramDoublePointer2, int paramInt4, DoublePointer paramDoublePointer3, int paramInt5);
> /*     */   
> /*     */   void ger(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, float paramFloat, float[] paramArrayOffloat1, int paramInt3, float[] paramArrayOffloat2, int paramInt4, float[] paramArrayOffloat3, int paramInt5);
> /*     */   
> /*     */   void ger(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, float paramFloat, FloatBuffer paramFloatBuffer1, int paramInt3, FloatBuffer paramFloatBuffer2, int paramInt4, FloatBuffer paramFloatBuffer3, int paramInt5);
> /*     */   
> /*     */   void syr(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double paramDouble, double[] paramArrayOfdouble1, int paramInt2, double[] paramArrayOfdouble2, int paramInt3);
> /*     */   
> /*     */   void syr(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double paramDouble, DoubleBuffer paramDoubleBuffer1, int paramInt2, DoubleBuffer paramDoubleBuffer2, int paramInt3);
> /*     */   
> /*     */   void syr(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double paramDouble, DoublePointer paramDoublePointer1, int paramInt2, DoublePointer paramDoublePointer2, int paramInt3);
> /*     */   
> /*     */   void syr(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, float paramFloat, float[] paramArrayOffloat1, int paramInt2, float[] paramArrayOffloat2, int paramInt3);
> /*     */   
> /*     */   void syr(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, float paramFloat, FloatBuffer paramFloatBuffer1, int paramInt2, FloatBuffer paramFloatBuffer2, int paramInt3);
> /*     */   
> /*     */   void spr(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double paramDouble, double[] paramArrayOfdouble1, int paramInt2, double[] paramArrayOfdouble2);
> /*     */   
> /*     */   void spr(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double paramDouble, DoubleBuffer paramDoubleBuffer1, int paramInt2, DoubleBuffer paramDoubleBuffer2);
> /*     */   
> /*     */   void spr(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, float paramFloat, float[] paramArrayOffloat1, int paramInt2, float[] paramArrayOffloat2);
> /*     */   
> /*     */   void spr(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, float paramFloat, FloatBuffer paramFloatBuffer1, int paramInt2, FloatBuffer paramFloatBuffer2);
> /*     */   
> /*     */   void gemm(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified1, TransposeModified paramTransposeModified2, int paramInt1, int paramInt2, int paramInt3, double paramDouble1, double[] paramArrayOfdouble1, int paramInt4, double[] paramArrayOfdouble2, int paramInt5, double paramDouble2, double[] paramArrayOfdouble3, int paramInt6);
> /*     */   
> /*     */   void gemm(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified1, TransposeModified paramTransposeModified2, int paramInt1, int paramInt2, int paramInt3, double paramDouble1, DoubleBuffer paramDoubleBuffer1, int paramInt4, DoubleBuffer paramDoubleBuffer2, int paramInt5, double paramDouble2, DoubleBuffer paramDoubleBuffer3, int paramInt6);
> /*     */   
> /*     */   void gemm(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified1, TransposeModified paramTransposeModified2, int paramInt1, int paramInt2, int paramInt3, double paramDouble1, DoublePointer paramDoublePointer1, int paramInt4, DoublePointer paramDoublePointer2, int paramInt5, double paramDouble2, DoublePointer paramDoublePointer3, int paramInt6);
> /*     */   
> /*     */   void gemm(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified1, TransposeModified paramTransposeModified2, int paramInt1, int paramInt2, int paramInt3, float paramFloat1, float[] paramArrayOffloat1, int paramInt4, float[] paramArrayOffloat2, int paramInt5, float paramFloat2, float[] paramArrayOffloat3, int paramInt6);
> /*     */   
> /*     */   void gemm(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified1, TransposeModified paramTransposeModified2, int paramInt1, int paramInt2, int paramInt3, float paramFloat1, FloatBuffer paramFloatBuffer1, int paramInt4, FloatBuffer paramFloatBuffer2, int paramInt5, float paramFloat2, FloatBuffer paramFloatBuffer3, int paramInt6);
> /*     */   
> /*     */   void symm(LayoutModified paramLayoutModified, SideModified paramSideModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double paramDouble1, double[] paramArrayOfdouble1, int paramInt3, double[] paramArrayOfdouble2, int paramInt4, double paramDouble2, double[] paramArrayOfdouble3, int paramInt5);
> /*     */   
> /*     */   void symm(LayoutModified paramLayoutModified, SideModified paramSideModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double paramDouble1, DoubleBuffer paramDoubleBuffer1, int paramInt3, DoubleBuffer paramDoubleBuffer2, int paramInt4, double paramDouble2, DoubleBuffer paramDoubleBuffer3, int paramInt5);
> /*     */   
> /*     */   void symm(LayoutModified paramLayoutModified, SideModified paramSideModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double paramDouble1, DoublePointer paramDoublePointer1, int paramInt3, DoublePointer paramDoublePointer2, int paramInt4, double paramDouble2, DoublePointer paramDoublePointer3, int paramInt5);
> /*     */   
> /*     */   void symm(LayoutModified paramLayoutModified, SideModified paramSideModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float paramFloat1, float[] paramArrayOffloat1, int paramInt3, float[] paramArrayOffloat2, int paramInt4, float paramFloat2, float[] paramArrayOffloat3, int paramInt5);
> /*     */   
> /*     */   void symm(LayoutModified paramLayoutModified, SideModified paramSideModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float paramFloat1, FloatBuffer paramFloatBuffer1, int paramInt3, FloatBuffer paramFloatBuffer2, int paramInt4, float paramFloat2, FloatBuffer paramFloatBuffer3, int paramInt5);
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/BLASModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/DiagModified.java jd-gui/smileModified/DiagModified.java
1c1,62
< package smileModified;
---
> /*    */ package smileModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public enum DiagModified
> /*    */ {
> /* 30 */   NON_UNIT(
> /* 31 */     131, (byte)78),
> /* 32 */   UNIT(
> /* 33 */     132, (byte)85);
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   private final int blas;
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   private final byte lapack;
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   DiagModified(int blas, byte lapack) {
> /* 46 */     this.blas = blas;
> /* 47 */     this.lapack = lapack;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public int blas() {
> /* 54 */     return this.blas;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public byte lapack() {
> /* 60 */     return this.lapack;
> /*    */   }
> /*    */ }
3,5d63
< public enum DiagModified {
<    NON_UNIT(131, (byte)78),
<    UNIT(132, (byte)85);
7,22c65,68
<    private final int blas;
<    private final byte lapack;
< 
<    private DiagModified(int blas, byte lapack) {
<       this.blas = blas;
<       this.lapack = lapack;
<    }
< 
<    public int blas() {
<       return this.blas;
<    }
< 
<    public byte lapack() {
<       return this.lapack;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/DiagModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/DistanceModified.java jd-gui/smileModified/DistanceModified.java
1,52c1,116
< package smileModified;
< 
< import java.io.Serializable;
< import java.util.function.ToDoubleBiFunction;
< import java.util.stream.IntStream;
< 
< public interface DistanceModified<T> extends ToDoubleBiFunction<T, T>, Serializable {
<    double d(T var1, T var2);
< 
<    default double apply(T x, T y) {
<       return this.d(x, y);
<    }
< 
<    default double applyAsDouble(T x, T y) {
<       return this.d(x, y);
<    }
< 
<    default MatrixModified D(T[] x) {
<       int n = x.length;
<       int N = n * (n - 1) / 2;
<       MatrixModified D = new MatrixModified(n, n);
<       IntStream.range(0, N).parallel().forEach((k) -> {
<          int j = n - 2 - (int)Math.floor(Math.sqrt((double)(-8 * k + 4 * n * (n - 1) - 7)) / 2.0D - 0.5D);
<          int i = k + j + 1 - n * (n - 1) / 2 + (n - j) * (n - j - 1) / 2;
<          D.set(i, j, this.d(x[i], x[j]));
<       });
< 
<       for(int i = 0; i < n; ++i) {
<          for(int j = i + 1; j < n; ++j) {
<             D.set(i, j, D.get(j, i));
<          }
<       }
< 
<       D.uplo(UPLOModified.LOWER);
<       return D;
<    }
< 
<    default MatrixModified D(T[] x, T[] y) {
<       int m = x.length;
<       int n = y.length;
<       MatrixModified D = new MatrixModified(m, n);
<       IntStream.range(0, m).parallel().forEach((i) -> {
<          T xi = x[i];
< 
<          for(int j = 0; j < n; ++j) {
<             D.set(i, j, this.d(xi, y[j]));
<          }
< 
<       });
<       return D;
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ import java.util.function.ToDoubleBiFunction;
> /*     */ import java.util.stream.IntStream;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public interface DistanceModified<T>
> /*     */   extends ToDoubleBiFunction<T, T>, Serializable
> /*     */ {
> /*     */   default double apply(T x, T y) {
> /*  54 */     return d(x, y);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   default double applyAsDouble(T x, T y) {
> /*  59 */     return d(x, y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default MatrixModified D(Object[] x) {
> /*  69 */     int n = x.length;
> /*  70 */     int N = n * (n - 1) / 2;
> /*  71 */     MatrixModified D = new MatrixModified(n, n);
> /*  72 */     IntStream.range(0, N).parallel().forEach(k -> {
> /*     */           int j = paramInt1 - 2 - (int)Math.floor(Math.sqrt((-8 * k + 4 * paramInt1 * (paramInt1 - 1) - 7)) / 2.0D - 0.5D);
> /*     */           
> /*     */           int i = k + j + 1 - paramInt1 * (paramInt1 - 1) / 2 + (paramInt1 - j) * (paramInt1 - j - 1) / 2;
> /*     */           paramMatrixModified.set(i, j, d((T)paramArrayOfObject[i], (T)paramArrayOfObject[j]));
> /*     */         });
> /*  78 */     for (int i = 0; i < n; i++) {
> /*  79 */       for (int j = i + 1; j < n; j++) {
> /*  80 */         D.set(i, j, D.get(j, i));
> /*     */       }
> /*     */     } 
> /*     */     
> /*  84 */     D.uplo(UPLOModified.LOWER);
> /*  85 */     return D;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default MatrixModified D(Object[] x, Object[] y) {
> /*  96 */     int m = x.length;
> /*  97 */     int n = y.length;
> /*  98 */     MatrixModified D = new MatrixModified(m, n);
> /*  99 */     IntStream.range(0, m).parallel().forEach(i -> {
> /*     */           T xi = (T)paramArrayOfObject1[i];
> /*     */           
> /*     */           for (int j = 0; j < paramInt1; j++) {
> /*     */             paramMatrixModified.set(i, j, d(xi, (T)paramArrayOfObject2[j]));
> /*     */           }
> /*     */         });
> /* 106 */     return D;
> /*     */   }
> /*     */   
> /*     */   double d(T paramT1, T paramT2);
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/DistanceModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/DistributionModified.java jd-gui/smileModified/DistributionModified.java
1,54c1,134
< package smileModified;
< 
< import java.io.Serializable;
< 
< public interface DistributionModified extends Serializable {
<    int length();
< 
<    double mean();
< 
<    double variance();
< 
<    default double sd() {
<       return Math.sqrt(this.variance());
<    }
< 
<    double entropy();
< 
<    double rand();
< 
<    default double[] rand(int n) {
<       double[] data = new double[n];
< 
<       for(int i = 0; i < n; ++i) {
<          data[i] = this.rand();
<       }
< 
<       return data;
<    }
< 
<    double p(double var1);
< 
<    double logp(double var1);
< 
<    double cdf(double var1);
< 
<    double quantile(double var1);
< 
<    default double likelihood(double[] x) {
<       return Math.exp(this.logLikelihood(x));
<    }
< 
<    default double logLikelihood(double[] x) {
<       double L = 0.0D;
<       double[] var8 = x;
<       int var7 = x.length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          double xi = var8[var6];
<          L += this.logp(xi);
<       }
< 
<       return L;
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public interface DistributionModified
> /*     */   extends Serializable
> /*     */ {
> /*     */   int length();
> /*     */   
> /*     */   double mean();
> /*     */   
> /*     */   double variance();
> /*     */   
> /*     */   default double sd() {
> /*  48 */     return Math.sqrt(variance());
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   double entropy();
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   double rand();
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default double[] rand(int n) {
> /*  69 */     double[] data = new double[n];
> /*  70 */     for (int i = 0; i < n; i++) {
> /*  71 */       data[i] = rand();
> /*     */     }
> /*  73 */     return data;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   double p(double paramDouble);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   double logp(double paramDouble);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   double cdf(double paramDouble);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   double quantile(double paramDouble);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default double likelihood(double[] x) {
> /* 112 */     return Math.exp(logLikelihood(x));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   default double logLikelihood(double[] x) {
> /* 121 */     double L = 0.0D; byte b; int i;
> /*     */     double[] arrayOfDouble;
> /* 123 */     for (i = (arrayOfDouble = x).length, b = 0; b < i; ) { double xi = arrayOfDouble[b];
> /* 124 */       L += logp(xi); b++; }
> /*     */     
> /* 126 */     return L;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/DistributionModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/DoubleArrayListModified.java jd-gui/smileModified/DoubleArrayListModified.java
1,120c1,245
< package smileModified;
< 
< import java.io.Serializable;
< import java.text.DecimalFormat;
< import java.util.Arrays;
< import java.util.stream.Collectors;
< import java.util.stream.DoubleStream;
< 
< public final class DoubleArrayListModified implements Serializable {
<    private static final long serialVersionUID = 1L;
<    private static final DecimalFormat format = new DecimalFormat("#.######");
<    double[] data;
<    private int size;
< 
<    public DoubleArrayListModified() {
<       this(10);
<    }
< 
<    public DoubleArrayListModified(int capacity) {
<       this.data = new double[capacity];
<       this.size = 0;
<    }
< 
<    public DoubleArrayListModified(double[] values) {
<       this(Math.max(values.length, 10));
<       this.add(values);
<    }
< 
<    public String toString() {
<       DoubleStream var10000 = Arrays.stream(this.data).limit((long)this.size);
<       DecimalFormat var10001 = format;
<       var10001.getClass();
<       return (String)var10000.mapToObj(var10001::format).collect(Collectors.joining(", ", "[", "]"));
<    }
< 
<    public DoubleStream stream() {
<       return DoubleStream.of(this.data).limit((long)this.size);
<    }
< 
<    public void ensureCapacity(int capacity) {
<       if (capacity > this.data.length) {
<          int newCap = Math.max(this.data.length << 1, capacity);
<          double[] tmp = new double[newCap];
<          System.arraycopy(this.data, 0, tmp, 0, this.data.length);
<          this.data = tmp;
<       }
< 
<    }
< 
<    public int size() {
<       return this.size;
<    }
< 
<    public boolean isEmpty() {
<       return this.size == 0;
<    }
< 
<    public void trim() {
<       if (this.data.length > this.size()) {
<          this.data = this.toArray();
<       }
< 
<    }
< 
<    public void add(double val) {
<       this.ensureCapacity(this.size + 1);
<       this.data[this.size++] = val;
<    }
< 
<    public void add(double[] vals) {
<       this.ensureCapacity(this.size + vals.length);
<       System.arraycopy(vals, 0, this.data, this.size, vals.length);
<       this.size += vals.length;
<    }
< 
<    public double get(int index) {
<       return this.data[index];
<    }
< 
<    public void set(int index, double val) {
<       if (index >= 0 && index < this.size) {
<          this.data[index] = val;
<       } else {
<          throw new IndexOutOfBoundsException(String.valueOf(index));
<       }
<    }
< 
<    public void clear() {
<       this.size = 0;
<    }
< 
<    public double remove(int index) {
<       if (index >= 0 && index < this.size) {
<          double old = this.get(index);
<          if (index == 0) {
<             System.arraycopy(this.data, 1, this.data, 0, this.size - 1);
<          } else if (this.size - 1 != index) {
<             System.arraycopy(this.data, index + 1, this.data, index, this.size - (index + 1));
<          }
< 
<          --this.size;
<          return old;
<       } else {
<          throw new IndexOutOfBoundsException(String.valueOf(index));
<       }
<    }
< 
<    public double[] toArray() {
<       return this.toArray((double[])null);
<    }
< 
<    public double[] toArray(double[] dest) {
<       if (dest == null || dest.length < this.size()) {
<          dest = new double[this.size];
<       }
< 
<       System.arraycopy(this.data, 0, dest, 0, this.size);
<       return dest;
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ import java.text.DecimalFormat;
> /*     */ import java.util.Arrays;
> /*     */ import java.util.stream.Collectors;
> /*     */ import java.util.stream.DoubleStream;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public final class DoubleArrayListModified
> /*     */   implements Serializable
> /*     */ {
> /*     */   private static final long serialVersionUID = 1L;
> /*  35 */   private static final DecimalFormat format = new DecimalFormat("#.######");
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   double[] data;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private int size;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public DoubleArrayListModified() {
> /*  51 */     this(10);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public DoubleArrayListModified(int capacity) {
> /*  60 */     this.data = new double[capacity];
> /*  61 */     this.size = 0;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public DoubleArrayListModified(double[] values) {
> /*  70 */     this(Math.max(values.length, 10));
> /*  71 */     add(values);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /*  76 */     return Arrays.stream(this.data).limit(this.size).<CharSequence>mapToObj(format::format).collect(Collectors.joining(", ", "[", "]"));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public DoubleStream stream() {
> /*  84 */     return DoubleStream.of(this.data).limit(this.size);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void ensureCapacity(int capacity) {
> /*  95 */     if (capacity > this.data.length) {
> /*  96 */       int newCap = Math.max(this.data.length << 1, capacity);
> /*  97 */       double[] tmp = new double[newCap];
> /*  98 */       System.arraycopy(this.data, 0, tmp, 0, this.data.length);
> /*  99 */       this.data = tmp;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int size() {
> /* 109 */     return this.size;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean isEmpty() {
> /* 118 */     return (this.size == 0);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void trim() {
> /* 125 */     if (this.data.length > size()) {
> /* 126 */       this.data = toArray();
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void add(double val) {
> /* 136 */     ensureCapacity(this.size + 1);
> /* 137 */     this.data[this.size++] = val;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void add(double[] vals) {
> /* 146 */     ensureCapacity(this.size + vals.length);
> /* 147 */     System.arraycopy(vals, 0, this.data, this.size, vals.length);
> /* 148 */     this.size += vals.length;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double get(int index) {
> /* 158 */     return this.data[index];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void set(int index, double val) {
> /* 170 */     if (index < 0 || index >= this.size) {
> /* 171 */       throw new IndexOutOfBoundsException(String.valueOf(index));
> /*     */     }
> /* 173 */     this.data[index] = val;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void clear() {
> /* 181 */     this.size = 0;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double remove(int index) {
> /* 192 */     if (index < 0 || index >= this.size) {
> /* 193 */       throw new IndexOutOfBoundsException(String.valueOf(index));
> /*     */     }
> /*     */     
> /* 196 */     double old = get(index);
> /*     */     
> /* 198 */     if (index == 0) {
> /*     */       
> /* 200 */       System.arraycopy(this.data, 1, this.data, 0, this.size - 1);
> /* 201 */     } else if (this.size - 1 != index) {
> /*     */       
> /* 203 */       System.arraycopy(this.data, index + 1, this.data, index, this.size - index + 1);
> /*     */     } 
> /*     */     
> /* 206 */     this.size--;
> /* 207 */     return old;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] toArray() {
> /* 217 */     return toArray(null);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] toArray(double[] dest) {
> /* 232 */     if (dest == null || dest.length < size()) {
> /* 233 */       dest = new double[this.size];
> /*     */     }
> /*     */     
> /* 236 */     System.arraycopy(this.data, 0, dest, 0, this.size);
> /* 237 */     return dest;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/DoubleArrayListModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/DoubleConsumerModified.java jd-gui/smileModified/DoubleConsumerModified.java
4c4
<    void accept(int var1, int var2, double var3);
---
>   void accept(int paramInt1, int paramInt2, double paramDouble);
5a6,11
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/DoubleConsumerModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/EigenRangeModified.java jd-gui/smileModified/EigenRangeModified.java
1c1,50
< package smileModified;
---
> /*    */ package smileModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public enum EigenRangeModified
> /*    */ {
> /* 22 */   ALL((byte)
> /*    */ 
> /*    */     
> /* 25 */     65),
> /* 26 */   VALUE((byte)
> /*    */ 
> /*    */ 
> /*    */     
> /* 30 */     86),
> /* 31 */   INDEX((byte)
> /*    */ 
> /*    */     
> /* 34 */     73);
> /*    */ 
> /*    */   
> /*    */   private final byte lapack;
> /*    */ 
> /*    */   
> /*    */   EigenRangeModified(byte lapack) {
> /* 41 */     this.lapack = lapack;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public byte lapack() {
> /* 48 */     return this.lapack;
> /*    */   }
> /*    */ }
3,6d51
< public enum EigenRangeModified {
<    ALL((byte)65),
<    VALUE((byte)86),
<    INDEX((byte)73);
8,17c53,56
<    private final byte lapack;
< 
<    private EigenRangeModified(byte lapack) {
<       this.lapack = lapack;
<    }
< 
<    public byte lapack() {
<       return this.lapack;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/EigenRangeModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/ErfModified.java jd-gui/smileModified/ErfModified.java
1,65c1,146
< package smileModified;
< 
< public class ErfModified {
<    private static final double[] cof = new double[]{-1.3026537197817094D, 0.6419697923564902D, 0.019476473204185836D, -0.00956151478680863D, -9.46595344482036E-4D, 3.66839497852761E-4D, 4.2523324806907E-5D, -2.0278578112534E-5D, -1.624290004647E-6D, 1.30365583558E-6D, 1.5626441722E-8D, -8.5238095915E-8D, 6.529054439E-9D, 5.059343495E-9D, -9.91364156E-10D, -2.27365122E-10D, 9.6467911E-11D, 2.394038E-12D, -6.886027E-12D, 8.94487E-13D, 3.13092E-13D, -1.12708E-13D, 3.81E-16D, 7.106E-15D, -1.523E-15D, -9.4E-17D, 1.21E-16D, -2.8E-17D};
< 
<    private ErfModified() {
<    }
< 
<    public static double erf(double x) {
<       return x >= 0.0D ? 1.0D - erfccheb(x) : erfccheb(-x) - 1.0D;
<    }
< 
<    public static double erfc(double x) {
<       return x >= 0.0D ? erfccheb(x) : 2.0D - erfccheb(-x);
<    }
< 
<    public static double erfcc(double x) {
<       double z = Math.abs(x);
<       double t = 2.0D / (2.0D + z);
<       double ans = t * Math.exp(-z * z - 1.26551223D + t * (1.00002368D + t * (0.37409196D + t * (0.09678418D + t * (-0.18628806D + t * (0.27886807D + t * (-1.13520398D + t * (1.48851587D + t * (-0.82215223D + t * 0.17087277D)))))))));
<       return x >= 0.0D ? ans : 2.0D - ans;
<    }
< 
<    private static double erfccheb(double z) {
<       double d = 0.0D;
<       double dd = 0.0D;
<       if (z < 0.0D) {
<          throw new IllegalArgumentException("erfccheb requires non-negative argument");
<       } else {
<          double t = 2.0D / (2.0D + z);
<          double ty = 4.0D * t - 2.0D;
< 
<          for(int j = cof.length - 1; j > 0; --j) {
<             double tmp = d;
<             d = ty * d - dd + cof[j];
<             dd = tmp;
<          }
< 
<          return t * Math.exp(-z * z + 0.5D * (cof[0] + ty * d) - dd);
<       }
<    }
< 
<    public static double inverfc(double p) {
<       if (p >= 2.0D) {
<          return -100.0D;
<       } else if (p <= 0.0D) {
<          return 100.0D;
<       } else {
<          double pp = p < 1.0D ? p : 2.0D - p;
<          double t = Math.sqrt(-2.0D * Math.log(pp / 2.0D));
<          double x = -0.70711D * ((2.30753D + t * 0.27061D) / (1.0D + t * (0.99229D + t * 0.04481D)) - t);
< 
<          for(int j = 0; j < 2; ++j) {
<             double err = erfc(x) - pp;
<             x += err / (1.1283791670955126D * Math.exp(-x * x) - x * err);
<          }
< 
<          return p < 1.0D ? x : -x;
<       }
<    }
< 
<    public static double inverf(double p) {
<       return inverfc(1.0D - p);
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class ErfModified
> /*     */ {
> /*  42 */   private static final double[] cof = new double[] { 
> /*  43 */       -1.3026537197817094D, 0.6419697923564902D, 
> /*  44 */       0.019476473204185836D, -0.00956151478680863D, -9.46595344482036E-4D, 
> /*  45 */       3.66839497852761E-4D, 4.2523324806907E-5D, -2.0278578112534E-5D, 
> /*  46 */       -1.624290004647E-6D, 1.30365583558E-6D, 1.5626441722E-8D, -8.5238095915E-8D, 
> /*  47 */       6.529054439E-9D, 5.059343495E-9D, -9.91364156E-10D, -2.27365122E-10D, 
> /*  48 */       9.6467911E-11D, 2.394038E-12D, -6.886027E-12D, 8.94487E-13D, 3.13092E-13D, 
> /*  49 */       -1.12708E-13D, 3.81E-16D, 7.106E-15D, -1.523E-15D, -9.4E-17D, 1.21E-16D, -2.8E-17D };
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double erf(double x) {
> /*  58 */     if (x >= 0.0D) {
> /*  59 */       return 1.0D - erfccheb(x);
> /*     */     }
> /*  61 */     return erfccheb(-x) - 1.0D;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double erfc(double x) {
> /*  71 */     if (x >= 0.0D) {
> /*  72 */       return erfccheb(x);
> /*     */     }
> /*  74 */     return 2.0D - erfccheb(-x);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double erfcc(double x) {
> /*  85 */     double z = Math.abs(x);
> /*  86 */     double t = 2.0D / (2.0D + z);
> /*  87 */     double ans = t * Math.exp(-z * z - 1.26551223D + t * (1.00002368D + t * (0.37409196D + t * (0.09678418D + 
> /*  88 */         t * (-0.18628806D + t * (0.27886807D + t * (-1.13520398D + t * (1.48851587D + 
> /*  89 */         t * (-0.82215223D + t * 0.17087277D)))))))));
> /*     */     
> /*  91 */     return (x >= 0.0D) ? ans : (2.0D - ans);
> /*     */   }
> /*     */   
> /*     */   private static double erfccheb(double z) {
> /*  95 */     double d = 0.0D, dd = 0.0D;
> /*  96 */     if (z < 0.0D) {
> /*  97 */       throw new IllegalArgumentException("erfccheb requires non-negative argument");
> /*     */     }
> /*  99 */     double t = 2.0D / (2.0D + z);
> /* 100 */     double ty = 4.0D * t - 2.0D;
> /* 101 */     for (int j = cof.length - 1; j > 0; j--) {
> /* 102 */       double tmp = d;
> /* 103 */       d = ty * d - dd + cof[j];
> /* 104 */       dd = tmp;
> /*     */     } 
> /* 106 */     return t * Math.exp(-z * z + 0.5D * (cof[0] + ty * d) - dd);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double inverfc(double p) {
> /* 116 */     if (p >= 2.0D) {
> /* 117 */       return -100.0D;
> /*     */     }
> /* 119 */     if (p <= 0.0D) {
> /* 120 */       return 100.0D;
> /*     */     }
> /* 122 */     double pp = (p < 1.0D) ? p : (2.0D - p);
> /* 123 */     double t = Math.sqrt(-2.0D * Math.log(pp / 2.0D));
> /* 124 */     double x = -0.70711D * ((2.30753D + t * 0.27061D) / (1.0D + t * (0.99229D + t * 0.04481D)) - t);
> /* 125 */     for (int j = 0; j < 2; j++) {
> /* 126 */       double err = erfc(x) - pp;
> /* 127 */       x += err / (1.1283791670955126D * Math.exp(-x * x) - x * err);
> /*     */     } 
> /* 129 */     return (p < 1.0D) ? x : -x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static double inverf(double p) {
> /* 138 */     return inverfc(1.0D - p);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/ErfModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/EVDJobModified.java jd-gui/smileModified/EVDJobModified.java
1c1,41
< package smileModified;
---
> /*    */ package smileModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public enum EVDJobModified
> /*    */ {
> /* 22 */   NO_VECTORS((byte)
> /* 23 */     78),
> /* 24 */   VECTORS((byte)
> /* 25 */     86);
> /*    */ 
> /*    */   
> /*    */   private final byte lapack;
> /*    */ 
> /*    */   
> /*    */   EVDJobModified(byte lapack) {
> /* 32 */     this.lapack = lapack;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public byte lapack() {
> /* 39 */     return this.lapack;
> /*    */   }
> /*    */ }
3,5d42
< public enum EVDJobModified {
<    NO_VECTORS((byte)78),
<    VECTORS((byte)86);
7,16c44,47
<    private final byte lapack;
< 
<    private EVDJobModified(byte lapack) {
<       this.lapack = lapack;
<    }
< 
<    public byte lapack() {
<       return this.lapack;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/EVDJobModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/ExponentialFamilyMixtureModified.java jd-gui/smileModified/ExponentialFamilyMixtureModified.java
1,122c1,150
< package smileModified;
< 
< import org.slf4j.Logger;
< import org.slf4j.LoggerFactory;
< 
< public class ExponentialFamilyMixtureModified extends MixtureModified {
<    private static final long serialVersionUID = 2L;
<    private static final Logger logger = LoggerFactory.getLogger(ExponentialFamilyMixtureModified.class);
<    public final double L;
<    public final double bic;
< 
<    public ExponentialFamilyMixtureModified(MixtureModified.Component... components) {
<       this(0.0D, 1, components);
<    }
< 
<    ExponentialFamilyMixtureModified(double L, int n, MixtureModified.Component... components) {
<       super(components);
<       MixtureModified.Component[] var8 = components;
<       int var7 = components.length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          MixtureModified.Component component = var8[var6];
<          if (!(component.distribution instanceof ExponentialFamilyModified)) {
<             throw new IllegalArgumentException("Component " + component + " is not of exponential family.");
<          }
<       }
< 
<       this.L = L;
<       this.bic = L - 0.5D * (double)this.length() * Math.log((double)n);
<    }
< 
<    public static ExponentialFamilyMixtureModified fit(double[] x, MixtureModified.Component... components) {
<       return fit(x, components, 0.0D, 500, 1.0E-4D);
<    }
< 
<    public static ExponentialFamilyMixtureModified fit(double[] x, MixtureModified.Component[] components, double gamma, int maxIter, double tol) {
<       if (x.length < components.length / 2) {
<          throw new IllegalArgumentException("Too many components");
<       } else if (!(gamma < 0.0D) && !(gamma > 0.2D)) {
<          int n = x.length;
<          int k = components.length;
<          double[][] posteriori = new double[k][n];
<          double L = 0.0D;
<          double diff = Double.MAX_VALUE;
< 
<          for(int iter = 1; iter <= maxIter && diff > tol; ++iter) {
<             int j;
<             int i;
<             for(j = 0; j < k; ++j) {
<                MixtureModified.Component c = components[j];
< 
<                for(i = 0; i < n; ++i) {
<                   posteriori[j][i] = c.priori * c.distribution.p(x[i]);
<                }
<             }
< 
<             for(j = 0; j < n; ++j) {
<                double p = 0.0D;
< 
<                int i;
<                for(i = 0; i < k; ++i) {
<                   p += posteriori[i][j];
<                }
< 
<                for(i = 0; i < k; ++i) {
<                   posteriori[i][j] /= p;
<                }
< 
<                if (gamma > 0.0D) {
<                   for(i = 0; i < k; ++i) {
<                      posteriori[i][j] *= 1.0D + gamma * MathExModified.log2(posteriori[i][j]);
<                      if (Double.isNaN(posteriori[i][j]) || posteriori[i][j] < 0.0D) {
<                         posteriori[i][j] = 0.0D;
<                      }
<                   }
<                }
<             }
< 
<             double Z = 0.0D;
< 
<             for(i = 0; i < k; ++i) {
<                components[i] = ((ExponentialFamilyModified)components[i].distribution).M(x, posteriori[i]);
<                Z += components[i].priori;
<             }
< 
<             for(i = 0; i < k; ++i) {
<                components[i] = new MixtureModified.Component(components[i].priori / Z, components[i].distribution);
<             }
< 
<             double loglikelihood = 0.0D;
<             double[] var23 = x;
<             int var22 = x.length;
< 
<             for(int var21 = 0; var21 < var22; ++var21) {
<                double xi = var23[var21];
<                double p = 0.0D;
<                MixtureModified.Component[] var29 = components;
<                int var28 = components.length;
< 
<                for(int var27 = 0; var27 < var28; ++var27) {
<                   MixtureModified.Component c = var29[var27];
<                   p += c.priori * c.distribution.p(xi);
<                }
< 
<                if (p > 0.0D) {
<                   loglikelihood += Math.log(p);
<                }
<             }
< 
<             diff = loglikelihood - L;
<             L = loglikelihood;
<             if (iter % 10 == 0) {
<                logger.info(String.format("The log-likelihood after %d iterations: %.4f", iter, loglikelihood));
<             }
<          }
< 
<          return new ExponentialFamilyMixtureModified(L, x.length, components);
<       } else {
<          throw new IllegalArgumentException("Invalid regularization factor gamma.");
<       }
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ public class ExponentialFamilyMixtureModified extends MixtureModified {
> /*   4 */   private static final Logger logger = LoggerFactory.getLogger(ExponentialFamilyMixtureModified.class);
> /*     */ 
> /*     */   
> /*     */   private static final long serialVersionUID = 2L;
> /*     */ 
> /*     */   
> /*     */   public final double L;
> /*     */   
> /*     */   public final double bic;
> /*     */ 
> /*     */   
> /*     */   public ExponentialFamilyMixtureModified(MixtureModified.Component... components) {
> /*  16 */     this(0.0D, 1, components);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   ExponentialFamilyMixtureModified(double L, int n, MixtureModified.Component... components) {
> /*  26 */     super(components); byte b; int i;
> /*     */     MixtureModified.Component[] arrayOfComponent;
> /*  28 */     for (i = (arrayOfComponent = components).length, b = 0; b < i; ) { MixtureModified.Component component = arrayOfComponent[b];
> /*  29 */       if (!(component.distribution instanceof ExponentialFamilyModified)) {
> /*  30 */         throw new IllegalArgumentException("Component " + component + " is not of exponential family.");
> /*     */       }
> /*     */       b++; }
> /*     */     
> /*  34 */     this.L = L;
> /*  35 */     this.bic = L - 0.5D * length() * Math.log(n);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static ExponentialFamilyMixtureModified fit(double[] x, MixtureModified.Component... components) {
> /*  46 */     return fit(x, components, 0.0D, 500, 1.0E-4D);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static ExponentialFamilyMixtureModified fit(double[] x, MixtureModified.Component[] components, double gamma, int maxIter, double tol) {
> /*  63 */     if (x.length < components.length / 2) {
> /*  64 */       throw new IllegalArgumentException("Too many components");
> /*     */     }
> /*     */     
> /*  67 */     if (gamma < 0.0D || gamma > 0.2D) {
> /*  68 */       throw new IllegalArgumentException("Invalid regularization factor gamma.");
> /*     */     }
> /*     */     
> /*  71 */     int n = x.length;
> /*  72 */     int k = components.length;
> /*     */     
> /*  74 */     double[][] posteriori = new double[k][n];
> /*     */ 
> /*     */     
> /*  77 */     double L = 0.0D;
> /*     */ 
> /*     */     
> /*  80 */     double diff = Double.MAX_VALUE;
> /*  81 */     for (int iter = 1; iter <= maxIter && diff > tol; iter++) {
> /*     */       
> /*  83 */       for (int i = 0; i < k; i++) {
> /*  84 */         MixtureModified.Component c = components[i];
> /*     */         
> /*  86 */         for (int i2 = 0; i2 < n; i2++) {
> /*  87 */           posteriori[i][i2] = c.priori * c.distribution.p(x[i2]);
> /*     */         }
> /*     */       } 
> /*     */ 
> /*     */       
> /*  92 */       for (int j = 0; j < n; j++) {
> /*  93 */         double p = 0.0D;
> /*     */         int i2;
> /*  95 */         for (i2 = 0; i2 < k; i2++) {
> /*  96 */           p += posteriori[i2][j];
> /*     */         }
> /*     */         
> /*  99 */         for (i2 = 0; i2 < k; i2++) {
> /* 100 */           posteriori[i2][j] = posteriori[i2][j] / p;
> /*     */         }
> /*     */ 
> /*     */         
> /* 104 */         if (gamma > 0.0D) {
> /* 105 */           for (i2 = 0; i2 < k; i2++) {
> /* 106 */             posteriori[i2][j] = posteriori[i2][j] * (1.0D + gamma * MathExModified.log2(posteriori[i2][j]));
> /* 107 */             if (Double.isNaN(posteriori[i2][j]) || posteriori[i2][j] < 0.0D) {
> /* 108 */               posteriori[i2][j] = 0.0D;
> /*     */             }
> /*     */           } 
> /*     */         }
> /*     */       } 
> /*     */ 
> /*     */       
> /* 115 */       double Z = 0.0D; int m;
> /* 116 */       for (m = 0; m < k; m++) {
> /* 117 */         components[m] = ((ExponentialFamilyModified)(components[m]).distribution).M(x, posteriori[m]);
> /* 118 */         Z += (components[m]).priori;
> /*     */       } 
> /*     */       
> /* 121 */       for (m = 0; m < k; m++) {
> /* 122 */         components[m] = new MixtureModified.Component((components[m]).priori / Z, (components[m]).distribution);
> /*     */       }
> /*     */       
> /* 125 */       double loglikelihood = 0.0D; byte b; int i1; double[] arrayOfDouble;
> /* 126 */       for (i1 = (arrayOfDouble = x).length, b = 0; b < i1; ) { double xi = arrayOfDouble[b];
> /* 127 */         double p = 0.0D; byte b1; int i2; MixtureModified.Component[] arrayOfComponent;
> /* 128 */         for (i2 = (arrayOfComponent = components).length, b1 = 0; b1 < i2; ) { MixtureModified.Component c = arrayOfComponent[b1];
> /* 129 */           p += c.priori * c.distribution.p(xi); b1++; }
> /*     */         
> /* 131 */         if (p > 0.0D) loglikelihood += Math.log(p); 
> /*     */         b++; }
> /*     */       
> /* 134 */       diff = loglikelihood - L;
> /* 135 */       L = loglikelihood;
> /*     */       
> /* 137 */       if (iter % 10 == 0) {
> /* 138 */         logger.info(String.format("The log-likelihood after %d iterations: %.4f", new Object[] { Integer.valueOf(iter), Double.valueOf(L) }));
> /*     */       }
> /*     */     } 
> /*     */     
> /* 142 */     return new ExponentialFamilyMixtureModified(L, x.length, components);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/ExponentialFamilyMixtureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/ExponentialFamilyModified.java jd-gui/smileModified/ExponentialFamilyModified.java
4c4
<    MixtureModified.Component M(double[] var1, double[] var2);
---
>   MixtureModified.Component M(double[] paramArrayOfdouble1, double[] paramArrayOfdouble2);
5a6,11
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/ExponentialFamilyModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/GaussianDistributionModified.java jd-gui/smileModified/GaussianDistributionModified.java
1,183c1,258
< package smileModified;
< 
< public class GaussianDistributionModified extends AbstractDistributionModified implements ExponentialFamilyModified {
<    private static final long serialVersionUID = 2L;
<    private static final double LOG2PIE_2 = Math.log(17.079468445347132D) / 2.0D;
<    private static final double LOG2PI_2 = Math.log(6.283185307179586D) / 2.0D;
<    private static final GaussianDistributionModified singleton = new GaussianDistributionModified(0.0D, 1.0D);
<    public final double mu;
<    public final double sigma;
<    private final double variance;
<    private final double entropy;
<    private final double pdfConstant;
<    private double z1 = Double.NaN;
< 
<    public GaussianDistributionModified(double mu, double sigma) {
<       this.mu = mu;
<       this.sigma = sigma;
<       this.variance = sigma * sigma;
<       this.entropy = Math.log(sigma) + LOG2PIE_2;
<       this.pdfConstant = Math.log(sigma) + LOG2PI_2;
<    }
< 
<    public static GaussianDistributionModified fit(double[] data) {
<       double mu = MathExModified.mean(data);
<       double sigma = MathExModified.sd(data);
<       return new GaussianDistributionModified(mu, sigma);
<    }
< 
<    public static GaussianDistributionModified getInstance() {
<       return singleton;
<    }
< 
<    public int length() {
<       return 2;
<    }
< 
<    public double mean() {
<       return this.mu;
<    }
< 
<    public double variance() {
<       return this.variance;
<    }
< 
<    public double sd() {
<       return this.sigma;
<    }
< 
<    public double entropy() {
<       return this.entropy;
<    }
< 
<    public String toString() {
<       return String.format("Gaussian Distribution(%.4f, %.4f)", this.mu, this.sigma);
<    }
< 
<    public double rand() {
<       double z0;
<       if (Double.isNaN(this.z1)) {
<          double x;
<          double y;
<          double r;
<          do {
<             x = MathExModified.random(-1.0D, 1.0D);
<             y = MathExModified.random(-1.0D, 1.0D);
<             r = x * x + y * y;
<          } while(r >= 1.0D);
< 
<          double z = Math.sqrt(-2.0D * Math.log(r) / r);
<          this.z1 = x * z;
<          z0 = y * z;
<       } else {
<          z0 = this.z1;
<          this.z1 = Double.NaN;
<       }
< 
<       return this.mu + this.sigma * z0;
<    }
< 
<    public double inverseCDF() {
<       double a0 = 2.50662823884D;
<       double a1 = -18.61500062529D;
<       double a2 = 41.39119773534D;
<       double a3 = -25.44106049637D;
<       double b0 = -8.4735109309D;
<       double b1 = 23.08336743743D;
<       double b2 = -21.06224101826D;
<       double b3 = 3.13082909833D;
<       double c0 = 0.3374754822726147D;
<       double c1 = 0.9761690190917186D;
<       double c2 = 0.1607979714918209D;
<       double c3 = 0.0276438810333863D;
<       double c4 = 0.0038405729373609D;
<       double c5 = 3.951896511919E-4D;
<       double c6 = 3.21767881768E-5D;
<       double c7 = 2.888167364E-7D;
<       double c8 = 3.960315187E-7D;
< 
<       double u;
<       for(u = MathExModified.random(); u == 0.0D; u = MathExModified.random()) {
<       }
< 
<       double y = u - 0.5D;
<       double r;
<       double x;
<       if (Math.abs(y) < 0.42D) {
<          r = y * y;
<          x = y * (((-25.44106049637D * r + 41.39119773534D) * r + -18.61500062529D) * r + 2.50662823884D) / ((((3.13082909833D * r + -21.06224101826D) * r + 23.08336743743D) * r + -8.4735109309D) * r + 1.0D);
<       } else {
<          r = u;
<          if (y > 0.0D) {
<             r = 1.0D - u;
<          }
< 
<          r = Math.log(-Math.log(r));
<          x = 0.3374754822726147D + r * (0.9761690190917186D + r * (0.1607979714918209D + r * (0.0276438810333863D + r * (0.0038405729373609D + r * (3.951896511919E-4D + r * (3.21767881768E-5D + r * (2.888167364E-7D + r * 3.960315187E-7D)))))));
<          if (y < 0.0D) {
<             x = -x;
<          }
<       }
< 
<       return this.mu + this.sigma * x;
<    }
< 
<    public double p(double x) {
<       if (this.sigma == 0.0D) {
<          return x == this.mu ? 1.0D : 0.0D;
<       } else {
<          return Math.exp(this.logp(x));
<       }
<    }
< 
<    public double logp(double x) {
<       if (this.sigma == 0.0D) {
<          return x == this.mu ? 0.0D : Double.NEGATIVE_INFINITY;
<       } else {
<          double d = x - this.mu;
<          return -0.5D * d * d / this.variance - this.pdfConstant;
<       }
<    }
< 
<    public double cdf(double x) {
<       if (this.sigma == 0.0D) {
<          return x < this.mu ? 0.0D : 1.0D;
<       } else {
<          return 0.5D * ErfModified.erfc(-0.7071067811865476D * (x - this.mu) / this.sigma);
<       }
<    }
< 
<    public double quantile(double p) {
<       if (!(p < 0.0D) && !(p > 1.0D)) {
<          if (this.sigma == 0.0D) {
<             return p < 1.0D ? this.mu - 1.0E-10D : this.mu;
<          } else {
<             return -1.4142135623730951D * this.sigma * ErfModified.inverfc(2.0D * p) + this.mu;
<          }
<       } else {
<          throw new IllegalArgumentException("Invalid p: " + p);
<       }
<    }
< 
<    public MixtureModified.Component M(double[] x, double[] posteriori) {
<       double alpha = 0.0D;
<       double mean = 0.0D;
<       double sd = 0.0D;
< 
<       int i;
<       for(i = 0; i < x.length; ++i) {
<          alpha += posteriori[i];
<          mean += x[i] * posteriori[i];
<       }
< 
<       mean /= alpha;
< 
<       for(i = 0; i < x.length; ++i) {
<          double d = x[i] - mean;
<          sd += d * d * posteriori[i];
<       }
< 
<       sd = Math.sqrt(sd / alpha);
<       return new MixtureModified.Component(alpha, new GaussianDistributionModified(mean, sd));
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ public class GaussianDistributionModified
> /*     */   extends AbstractDistributionModified implements ExponentialFamilyModified {
> /*     */   private static final long serialVersionUID = 2L;
> /*   6 */   private static final double LOG2PIE_2 = Math.log(17.079468445347132D) / 2.0D;
> /*   7 */   private static final double LOG2PI_2 = Math.log(6.283185307179586D) / 2.0D;
> /*   8 */   private static final GaussianDistributionModified singleton = new GaussianDistributionModified(0.0D, 1.0D);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double mu;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double sigma;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private final double variance;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private final double entropy;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private final double pdfConstant;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private double z1;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static GaussianDistributionModified fit(double[] data) {
> /*     */     double mu = MathExModified.mean(data);
> /*     */     double sigma = MathExModified.sd(data);
> /*     */     return new GaussianDistributionModified(mu, sigma);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static GaussianDistributionModified getInstance() {
> /*     */     return singleton;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int length() {
> /*     */     return 2;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double mean() {
> /*     */     return this.mu;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public GaussianDistributionModified(double mu, double sigma) {
> /*  88 */     this.z1 = Double.NaN;
> /*     */     this.mu = mu;
> /*     */     this.sigma = sigma;
> /*     */     this.variance = sigma * sigma;
> /*     */     this.entropy = Math.log(sigma) + LOG2PIE_2;
> /*     */     this.pdfConstant = Math.log(sigma) + LOG2PI_2; } public double variance() {
> /*     */     return this.variance;
> /*     */   } public double rand() {
> /*     */     double z0;
> /*  97 */     if (Double.isNaN(this.z1)) {
> /*     */       double x, y, r; do {
> /*  99 */         x = MathExModified.random(-1.0D, 1.0D);
> /* 100 */         y = MathExModified.random(-1.0D, 1.0D);
> /* 101 */         r = x * x + y * y;
> /* 102 */       } while (r >= 1.0D);
> /*     */       
> /* 104 */       double z = Math.sqrt(-2.0D * Math.log(r) / r);
> /* 105 */       this.z1 = x * z;
> /* 106 */       z0 = y * z;
> /*     */     } else {
> /* 108 */       z0 = this.z1;
> /* 109 */       this.z1 = Double.NaN;
> /*     */     } 
> /*     */     
> /* 112 */     return this.mu + this.sigma * z0;
> /*     */   }
> /*     */   
> /*     */   public double sd() {
> /*     */     return this.sigma;
> /*     */   }
> /*     */   
> /*     */   public double inverseCDF() {
> /* 120 */     double x, a0 = 2.50662823884D;
> /* 121 */     double a1 = -18.61500062529D;
> /* 122 */     double a2 = 41.39119773534D;
> /* 123 */     double a3 = -25.44106049637D;
> /* 124 */     double b0 = -8.4735109309D;
> /* 125 */     double b1 = 23.08336743743D;
> /* 126 */     double b2 = -21.06224101826D;
> /* 127 */     double b3 = 3.13082909833D;
> /* 128 */     double c0 = 0.3374754822726147D;
> /* 129 */     double c1 = 0.9761690190917186D;
> /* 130 */     double c2 = 0.1607979714918209D;
> /* 131 */     double c3 = 0.0276438810333863D;
> /* 132 */     double c4 = 0.0038405729373609D;
> /* 133 */     double c5 = 3.951896511919E-4D;
> /* 134 */     double c6 = 3.21767881768E-5D;
> /* 135 */     double c7 = 2.888167364E-7D;
> /* 136 */     double c8 = 3.960315187E-7D;
> /*     */ 
> /*     */ 
> /*     */     
> /* 140 */     double u = MathExModified.random();
> /* 141 */     while (u == 0.0D) {
> /* 142 */       u = MathExModified.random();
> /*     */     }
> /*     */     
> /* 145 */     double y = u - 0.5D;
> /*     */     
> /* 147 */     if (Math.abs(y) < 0.42D) {
> /* 148 */       double r = y * y;
> /* 149 */       x = y * (((-25.44106049637D * r + 41.39119773534D) * r + -18.61500062529D) * r + 2.50662823884D) / ((((
> /* 150 */         3.13082909833D * r + -21.06224101826D) * r + 23.08336743743D) * r + -8.4735109309D) * r + 1.0D);
> /*     */     } else {
> /*     */       
> /* 153 */       double r = u;
> /* 154 */       if (y > 0.0D) {
> /* 155 */         r = 1.0D - u;
> /*     */       }
> /* 157 */       r = Math.log(-Math.log(r));
> /* 158 */       x = 0.3374754822726147D + r * (0.9761690190917186D + r * (0.1607979714918209D + r * (0.0276438810333863D + r * (0.0038405729373609D + r * (3.951896511919E-4D + r * (3.21767881768E-5D + r * (2.888167364E-7D + r * 3.960315187E-7D)))))));
> /* 159 */       if (y < 0.0D) {
> /* 160 */         x = -x;
> /*     */       }
> /*     */     } 
> /*     */     
> /* 164 */     return this.mu + this.sigma * x;
> /*     */   } public double entropy() {
> /*     */     return this.entropy;
> /*     */   }
> /*     */   public double p(double x) {
> /* 169 */     if (this.sigma == 0.0D) {
> /* 170 */       if (x == this.mu) {
> /* 171 */         return 1.0D;
> /*     */       }
> /* 173 */       return 0.0D;
> /*     */     } 
> /*     */ 
> /*     */     
> /* 177 */     return Math.exp(logp(x));
> /*     */   } public String toString() {
> /*     */     return String.format("Gaussian Distribution(%.4f, %.4f)", new Object[] { Double.valueOf(this.mu), Double.valueOf(this.sigma) });
> /*     */   }
> /*     */   public double logp(double x) {
> /* 182 */     if (this.sigma == 0.0D) {
> /* 183 */       if (x == this.mu) {
> /* 184 */         return 0.0D;
> /*     */       }
> /* 186 */       return Double.NEGATIVE_INFINITY;
> /*     */     } 
> /*     */ 
> /*     */     
> /* 190 */     double d = x - this.mu;
> /* 191 */     return -0.5D * d * d / this.variance - this.pdfConstant;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double cdf(double x) {
> /* 196 */     if (this.sigma == 0.0D) {
> /* 197 */       if (x < this.mu) {
> /* 198 */         return 0.0D;
> /*     */       }
> /* 200 */       return 1.0D;
> /*     */     } 
> /*     */ 
> /*     */     
> /* 204 */     return 0.5D * ErfModified.erfc(-0.7071067811865476D * (x - this.mu) / this.sigma);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double quantile(double p) {
> /* 216 */     if (p < 0.0D || p > 1.0D) {
> /* 217 */       throw new IllegalArgumentException("Invalid p: " + p);
> /*     */     }
> /*     */     
> /* 220 */     if (this.sigma == 0.0D) {
> /* 221 */       if (p < 1.0D) {
> /* 222 */         return this.mu - 1.0E-10D;
> /*     */       }
> /* 224 */       return this.mu;
> /*     */     } 
> /*     */     
> /* 227 */     return -1.4142135623730951D * this.sigma * ErfModified.inverfc(2.0D * p) + this.mu;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public MixtureModified.Component M(double[] x, double[] posteriori) {
> /* 232 */     double alpha = 0.0D;
> /* 233 */     double mean = 0.0D;
> /* 234 */     double sd = 0.0D;
> /*     */     int i;
> /* 236 */     for (i = 0; i < x.length; i++) {
> /* 237 */       alpha += posteriori[i];
> /* 238 */       mean += x[i] * posteriori[i];
> /*     */     } 
> /*     */     
> /* 241 */     mean /= alpha;
> /*     */     
> /* 243 */     for (i = 0; i < x.length; i++) {
> /* 244 */       double d = x[i] - mean;
> /* 245 */       sd += d * d * posteriori[i];
> /*     */     } 
> /*     */     
> /* 248 */     sd = Math.sqrt(sd / alpha);
> /*     */     
> /* 250 */     return new MixtureModified.Component(alpha, new GaussianDistributionModified(mean, sd));
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/GaussianDistributionModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/GaussianMixtureModified.java jd-gui/smileModified/GaussianMixtureModified.java
1,92c1,123
< package smileModified;
< 
< import org.slf4j.Logger;
< import org.slf4j.LoggerFactory;
< 
< public class GaussianMixtureModified extends ExponentialFamilyMixtureModified {
<    private static final long serialVersionUID = 2L;
<    private static final Logger logger = LoggerFactory.getLogger(GaussianMixtureModified.class);
< 
<    public GaussianMixtureModified(MixtureModified.Component... components) {
<       this(0.0D, 1, components);
<    }
< 
<    private GaussianMixtureModified(double L, int n, MixtureModified.Component... components) {
<       super(L, n, components);
<       MixtureModified.Component[] var8 = components;
<       int var7 = components.length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          MixtureModified.Component component = var8[var6];
<          if (!(component.distribution instanceof GaussianDistributionModified)) {
<             throw new IllegalArgumentException("Component " + component + " is not of Gaussian distribution.");
<          }
<       }
< 
<    }
< 
<    public static GaussianMixtureModified fit(int k, double[] x) {
<       if (k < 2) {
<          throw new IllegalArgumentException("Invalid number of components in the mixture.");
<       } else {
<          double min = MathExModified.min(x);
<          double max = MathExModified.max(x);
<          double step = (max - min) / (double)(k + 1);
<          MixtureModified.Component[] components = new MixtureModified.Component[k];
< 
<          for(int i = 0; i < k; ++i) {
<             components[i] = new MixtureModified.Component(1.0D / (double)k, new GaussianDistributionModified(min += step, step));
<          }
< 
<          ExponentialFamilyMixtureModified model = fit(x, components);
<          return new GaussianMixtureModified(model.L, x.length, model.components);
<       }
<    }
< 
<    public static GaussianMixtureModified fit(double[] x) {
<       if (x.length < 20) {
<          throw new IllegalArgumentException("Too few samples.");
<       } else {
<          GaussianMixtureModified mixture = new GaussianMixtureModified(new MixtureModified.Component[]{new MixtureModified.Component(1.0D, GaussianDistributionModified.fit(x))});
<          double bic = mixture.bic(x);
<          logger.info(String.format("The BIC of %s = %.4f", mixture, bic));
< 
<          for(int k = 2; k < x.length / 10; ++k) {
<             ExponentialFamilyMixtureModified model = fit(k, x);
<             logger.info(String.format("The BIC of %s = %.4f", model, model.bic));
<             if (model.bic <= bic) {
<                break;
<             }
< 
<             mixture = new GaussianMixtureModified(model.L, x.length, model.components);
<             bic = model.bic;
<          }
< 
<          return mixture;
<       }
<    }
< 
<    private static MixtureModified.Component[] split(MixtureModified.Component... components) {
<       int k = components.length;
<       int index = -1;
<       double maxSigma = Double.NEGATIVE_INFINITY;
< 
<       for(int i = 0; i < k; ++i) {
<          MixtureModified.Component c = components[i];
<          if (c.distribution.sd() > maxSigma) {
<             maxSigma = c.distribution.sd();
<             index = i;
<          }
<       }
< 
<       MixtureModified.Component component = components[index];
<       double priori = component.priori / 2.0D;
<       double delta = component.distribution.sd();
<       double mu = component.distribution.mean();
<       MixtureModified.Component[] mixture = new MixtureModified.Component[k + 1];
<       System.arraycopy(components, 0, mixture, 0, k);
<       mixture[index] = new MixtureModified.Component(priori, new GaussianDistributionModified(mu + delta / 2.0D, delta));
<       mixture[k] = new MixtureModified.Component(priori, new GaussianDistributionModified(mu - delta / 2.0D, delta));
<       return mixture;
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import org.slf4j.Logger;
> /*     */ import org.slf4j.LoggerFactory;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class GaussianMixtureModified
> /*     */   extends ExponentialFamilyMixtureModified
> /*     */ {
> /*     */   private static final long serialVersionUID = 2L;
> /*  12 */   private static final Logger logger = LoggerFactory.getLogger(GaussianMixtureModified.class);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public GaussianMixtureModified(MixtureModified.Component... components) {
> /*  19 */     this(0.0D, 1, components);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private GaussianMixtureModified(double L, int n, MixtureModified.Component... components) {
> /*  29 */     super(L, n, components); byte b; int i;
> /*     */     MixtureModified.Component[] arrayOfComponent;
> /*  31 */     for (i = (arrayOfComponent = components).length, b = 0; b < i; ) { MixtureModified.Component component = arrayOfComponent[b];
> /*  32 */       if (!(component.distribution instanceof GaussianDistributionModified)) {
> /*  33 */         throw new IllegalArgumentException("Component " + component + " is not of Gaussian distribution.");
> /*     */       }
> /*     */       b++; }
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static GaussianMixtureModified fit(int k, double[] x) {
> /*  45 */     if (k < 2) {
> /*  46 */       throw new IllegalArgumentException("Invalid number of components in the mixture.");
> /*     */     }
> /*  48 */     double min = MathExModified.min(x);
> /*  49 */     double max = MathExModified.max(x);
> /*  50 */     double step = (max - min) / (k + 1);
> /*     */     
> /*  52 */     MixtureModified.Component[] components = new MixtureModified.Component[k];
> /*  53 */     for (int i = 0; i < k; i++) {
> /*  54 */       components[i] = new MixtureModified.Component(1.0D / k, new GaussianDistributionModified(min += step, step));
> /*     */     }
> /*     */     
> /*  57 */     ExponentialFamilyMixtureModified model = fit(x, components);
> /*  58 */     return new GaussianMixtureModified(model.L, x.length, model.components);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static GaussianMixtureModified fit(double[] x) {
> /*  68 */     if (x.length < 20) {
> /*  69 */       throw new IllegalArgumentException("Too few samples.");
> /*     */     }
> /*     */     
> /*  72 */     GaussianMixtureModified mixture = new GaussianMixtureModified(new MixtureModified.Component[] { new MixtureModified.Component(1.0D, GaussianDistributionModified.fit(x)) });
> /*  73 */     double bic = mixture.bic(x);
> /*  74 */     logger.info(String.format("The BIC of %s = %.4f", new Object[] { mixture, Double.valueOf(bic) }));
> /*     */     
> /*  76 */     for (int k = 2; k < x.length / 10; k++) {
> /*  77 */       ExponentialFamilyMixtureModified model = fit(k, x);
> /*  78 */       logger.info(String.format("The BIC of %s = %.4f", new Object[] { model, Double.valueOf(model.bic) }));
> /*     */       
> /*  80 */       if (model.bic <= bic)
> /*     */         break; 
> /*  82 */       mixture = new GaussianMixtureModified(model.L, x.length, model.components);
> /*  83 */       bic = model.bic;
> /*     */     } 
> /*     */     
> /*  86 */     return mixture;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private static MixtureModified.Component[] split(MixtureModified.Component... components) {
> /*  94 */     int k = components.length;
> /*  95 */     int index = -1;
> /*  96 */     double maxSigma = Double.NEGATIVE_INFINITY;
> /*  97 */     for (int i = 0; i < k; i++) {
> /*  98 */       MixtureModified.Component c = components[i];
> /*  99 */       if (c.distribution.sd() > maxSigma) {
> /* 100 */         maxSigma = c.distribution.sd();
> /* 101 */         index = i;
> /*     */       } 
> /*     */     } 
> /*     */ 
> /*     */     
> /* 106 */     MixtureModified.Component component = components[index];
> /* 107 */     double priori = component.priori / 2.0D;
> /* 108 */     double delta = component.distribution.sd();
> /* 109 */     double mu = component.distribution.mean();
> /*     */     
> /* 111 */     MixtureModified.Component[] mixture = new MixtureModified.Component[k + 1];
> /* 112 */     System.arraycopy(components, 0, mixture, 0, k);
> /* 113 */     mixture[index] = new MixtureModified.Component(priori, new GaussianDistributionModified(mu + delta / 2.0D, delta));
> /* 114 */     mixture[k] = new MixtureModified.Component(priori, new GaussianDistributionModified(mu - delta / 2.0D, delta));
> /* 115 */     return mixture;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/GaussianMixtureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/IMatrixModified.java jd-gui/smileModified/IMatrixModified.java
1,727c1,982
< package smileModified;
< 
< import java.io.IOException;
< import java.io.LineNumberReader;
< import java.io.Serializable;
< import java.nio.file.Files;
< import java.nio.file.Path;
< import java.text.ParseException;
< import java.util.ArrayList;
< import java.util.Iterator;
< import java.util.List;
< import java.util.Scanner;
< import org.slf4j.Logger;
< import org.slf4j.LoggerFactory;
< 
< public abstract class IMatrixModified implements Cloneable, Serializable {
<    private static final Logger logger = LoggerFactory.getLogger(IMatrixModified.class);
<    private String[] rowNames;
<    private String[] colNames;
< 
<    public abstract int nrow();
< 
<    public abstract int ncol();
< 
<    public abstract long size();
< 
<    public String[] rowNames() {
<       return this.rowNames;
<    }
< 
<    public void rowNames(String[] names) {
<       if (names != null && names.length != this.nrow()) {
<          throw new IllegalArgumentException(String.format("Invalid row names length: %d != %d", names.length, this.nrow()));
<       } else {
<          this.rowNames = names;
<       }
<    }
< 
<    public String rowName(int i) {
<       return this.rowNames[i];
<    }
< 
<    public String[] colNames() {
<       return this.colNames;
<    }
< 
<    public void colNames(String[] names) {
<       if (names != null && names.length != this.ncol()) {
<          throw new IllegalArgumentException(String.format("Invalid column names length: %d != %d", names.length, this.ncol()));
<       } else {
<          this.colNames = names;
<       }
<    }
< 
<    public String colName(int i) {
<       return this.colNames[i];
<    }
< 
<    public String toString() {
<       return this.toString(false);
<    }
< 
<    public String toString(boolean full) {
<       return full ? this.toString(this.nrow(), this.ncol()) : this.toString(7, 7);
<    }
< 
<    public String toString(int m, int n) {
<       StringBuilder sb = new StringBuilder(this.nrow() + " x " + this.ncol() + "\n");
<       m = Math.min(m, this.nrow());
<       n = Math.min(n, this.ncol());
<       String newline = n < this.ncol() ? "  ...\n" : "\n";
<       int i;
<       if (this.colNames != null) {
<          if (this.rowNames != null) {
<             sb.append("            ");
<          }
< 
<          for(i = 0; i < n; ++i) {
<             sb.append(String.format(" %12.12s", this.colNames[i]));
<          }
< 
<          sb.append(newline);
<       }
< 
<       for(i = 0; i < m; ++i) {
<          if (this.rowNames != null) {
<             sb.append(String.format("%-12.12s", this.rowNames[i]));
<          }
< 
<          for(int j = 0; j < n; ++j) {
<             sb.append(String.format(" %12.12s", this.str(i, j)));
<          }
< 
<          sb.append(newline);
<       }
< 
<       if (m < this.nrow()) {
<          sb.append("  ...\n");
<       }
< 
<       return sb.toString();
<    }
< 
<    private String str(int i, int j) {
<       return StringsModified.format(this.get(i, j), true);
<    }
< 
<    public abstract void mv(TransposeModified var1, double var2, double[] var4, double var5, double[] var7);
< 
<    public double[] mv(double[] x) {
<       double[] y = new double[this.nrow()];
<       this.mv(TransposeModified.NO_TRANSPOSE, 1.0D, x, 0.0D, y);
<       return y;
<    }
< 
<    public void mv(double[] x, double[] y) {
<       this.mv(TransposeModified.NO_TRANSPOSE, 1.0D, x, 0.0D, y);
<    }
< 
<    public void mv(double alpha, double[] x, double beta, double[] y) {
<       this.mv(TransposeModified.NO_TRANSPOSE, alpha, x, beta, y);
<    }
< 
<    public abstract void mv(double[] var1, int var2, int var3);
< 
<    public double[] tv(double[] x) {
<       double[] y = new double[this.ncol()];
<       this.mv(TransposeModified.TRANSPOSE, 1.0D, x, 0.0D, y);
<       return y;
<    }
< 
<    public void tv(double[] x, double[] y) {
<       this.mv(TransposeModified.TRANSPOSE, 1.0D, x, 0.0D, y);
<    }
< 
<    public void tv(double alpha, double[] x, double beta, double[] y) {
<       this.mv(TransposeModified.TRANSPOSE, alpha, x, beta, y);
<    }
< 
<    public abstract void tv(double[] var1, int var2, int var3);
< 
<    static int ld(int n) {
<       int elementSize = 4;
<       return n <= 256 / elementSize ? n : ((n * elementSize + 511) / 512 * 512 + 64) / elementSize;
<    }
< 
<    static TransposeModified flip(TransposeModified trans) {
<       return trans == TransposeModified.NO_TRANSPOSE ? TransposeModified.TRANSPOSE : TransposeModified.NO_TRANSPOSE;
<    }
< 
<    public void set(int i, int j, double x) {
<       throw new UnsupportedOperationException();
<    }
< 
<    public void update(int i, int j, double x) {
<       this.set(i, j, x);
<    }
< 
<    public double get(int i, int j) {
<       throw new UnsupportedOperationException();
<    }
< 
<    public double apply(int i, int j) {
<       return this.get(i, j);
<    }
< 
<    public double[] diag() {
<       int n = Math.min(this.nrow(), this.ncol());
<       double[] d = new double[n];
< 
<       for(int i = 0; i < n; ++i) {
<          d[i] = this.get(i, i);
<       }
< 
<       return d;
<    }
< 
<    public double trace() {
<       int n = Math.min(this.nrow(), this.ncol());
<       double t = 0.0D;
< 
<       for(int i = 0; i < n; ++i) {
<          t += this.get(i, i);
<       }
< 
<       return t;
<    }
< 
<    public double eigen(double[] v) {
<       return this.eigen(v, 0.0D, Math.max(1.0E-6D, (double)this.nrow() * MathExModified.EPSILON), Math.max(20, 2 * this.nrow()));
<    }
< 
<    public double eigen(double[] v, double p, double tol, int maxIter) {
<       if (this.nrow() != this.ncol()) {
<          throw new IllegalArgumentException("Matrix is not square.");
<       } else if (tol <= 0.0D) {
<          throw new IllegalArgumentException("Invalid tolerance: " + tol);
<       } else if (maxIter <= 0) {
<          throw new IllegalArgumentException("Invalid maximum number of iterations: " + maxIter);
<       } else {
<          int n = this.nrow();
<          tol = Math.max(tol, MathExModified.EPSILON * (double)n);
<          double[] z = new double[n];
<          double lambda = this.power(v, z, p);
< 
<          for(int iter = 1; iter <= maxIter; ++iter) {
<             double l = lambda;
<             lambda = this.power(v, z, p);
<             double eps = Math.abs(lambda - l);
<             if (iter % 10 == 0) {
<                logger.trace(String.format("Largest eigenvalue after %3d power iterations: %.4f", iter, lambda + p));
<             }
< 
<             if (eps < tol) {
<                logger.info(String.format("Largest eigenvalue after %3d power iterations: %.4f", iter, lambda + p));
<                return lambda + p;
<             }
<          }
< 
<          logger.info(String.format("Largest eigenvalue after %3d power iterations: %.4f", maxIter, lambda + p));
<          logger.error("Power iteration exceeded the maximum number of iterations.");
<          return lambda + p;
<       }
<    }
< 
<    private double power(double[] x, double[] y, double p) {
<       this.mv(x, y);
<       if (p != 0.0D) {
<          for(int i = 0; i < y.length; ++i) {
<             y[i] -= p * x[i];
<          }
<       }
< 
<       double lambda = y[0];
< 
<       int i;
<       for(i = 1; i < y.length; ++i) {
<          if (Math.abs(y[i]) > Math.abs(lambda)) {
<             lambda = y[i];
<          }
<       }
< 
<       for(i = 0; i < y.length; ++i) {
<          x[i] = y[i] / lambda;
<       }
< 
<       return lambda;
<    }
< 
<    public static IMatrixModified market(Path path) throws IOException, ParseException {
<       Throwable var1 = null;
<       Object var2 = null;
< 
<       try {
<          LineNumberReader reader = new LineNumberReader(Files.newBufferedReader(path));
< 
<          MatrixModified var40;
<          label1105: {
<             SymmMatrixModified var41;
<             label1106: {
<                label1107: {
<                   SparseMatrixModified var10000;
<                   try {
<                      Scanner scanner = new Scanner(reader);
< 
<                      try {
<                         String header = scanner.next();
<                         if (!header.equals("%%MatrixMarket")) {
<                            throw new ParseException("Invalid Matrix Market file header", reader.getLineNumber());
<                         }
< 
<                         String object = scanner.next();
<                         if (!object.equals("matrix")) {
<                            throw new UnsupportedOperationException("The object is not a matrix file: " + object);
<                         }
< 
<                         String format = scanner.next();
<                         String field = scanner.next();
<                         if (field.equals("complex") || field.equals("pattern")) {
<                            throw new UnsupportedOperationException("No support of complex or pattern matrix");
<                         }
< 
<                         String symmetry = scanner.nextLine().trim();
<                         if (symmetry.equals("Hermitian")) {
<                            throw new UnsupportedOperationException("No support of Hermitian matrix");
<                         }
< 
<                         boolean symmetric = symmetry.equals("symmetric");
<                         boolean skew = symmetry.equals("skew-symmetric");
< 
<                         String line;
<                         for(line = scanner.nextLine(); line.startsWith("%"); line = scanner.nextLine()) {
<                         }
< 
<                         Scanner s;
<                         int nrow;
<                         int ncol;
<                         int k;
<                         if (format.equals("array")) {
<                            s = new Scanner(line);
<                            nrow = s.nextInt();
<                            ncol = s.nextInt();
<                            MatrixModified matrix = new MatrixModified(nrow, ncol);
< 
<                            for(int j = 0; j < ncol; ++j) {
<                               for(k = 0; k < nrow; ++k) {
<                                  double x = scanner.nextDouble();
<                                  matrix.set(k, j, x);
<                               }
<                            }
< 
<                            if (symmetric) {
<                               matrix.uplo(UPLOModified.LOWER);
<                            }
< 
<                            var40 = matrix;
<                            break label1105;
<                         }
< 
<                         if (!format.equals("coordinate")) {
<                            throw new ParseException("Invalid Matrix Market format: " + format, 0);
<                         }
< 
<                         s = new Scanner(line);
<                         nrow = s.nextInt();
<                         ncol = s.nextInt();
<                         int nz = s.nextInt();
<                         int i;
<                         String[] tokens;
<                         int i;
<                         double x;
<                         if (symmetric && nz == nrow * (nrow + 1) / 2) {
<                            if (nrow != ncol) {
<                               throw new IllegalStateException(String.format("Symmetric matrix is not square: %d != %d", nrow, ncol));
<                            }
< 
<                            SymmMatrixModified matrix = new SymmMatrixModified(UPLOModified.LOWER, nrow);
< 
<                            for(k = 0; k < nz; ++k) {
<                               tokens = scanner.nextLine().trim().split("\\s+");
<                               if (tokens.length != 3) {
<                                  throw new ParseException("Invalid data line: " + line, reader.getLineNumber());
<                               }
< 
<                               i = Integer.parseInt(tokens[0]) - 1;
<                               i = Integer.parseInt(tokens[1]) - 1;
<                               x = Double.parseDouble(tokens[2]);
<                               matrix.set(i, i, x);
<                            }
< 
<                            var41 = matrix;
<                            break label1106;
<                         }
< 
<                         if (skew && nz == nrow * (nrow + 1) / 2) {
<                            if (nrow != ncol) {
<                               throw new IllegalStateException(String.format("Skew-symmetric matrix is not square: %d != %d", nrow, ncol));
<                            }
< 
<                            MatrixModified matrix = new MatrixModified(nrow, ncol);
< 
<                            for(k = 0; k < nz; ++k) {
<                               tokens = scanner.nextLine().trim().split("\\s+");
<                               if (tokens.length != 3) {
<                                  throw new ParseException("Invalid data line: " + line, reader.getLineNumber());
<                               }
< 
<                               i = Integer.parseInt(tokens[0]) - 1;
<                               i = Integer.parseInt(tokens[1]) - 1;
<                               x = Double.parseDouble(tokens[2]);
<                               matrix.set(i, i, x);
<                               matrix.set(i, i, -x);
<                            }
< 
<                            var40 = matrix;
<                            break label1107;
<                         }
< 
<                         int[] colSize = new int[ncol];
<                         List<SparseArrayModified> rows = new ArrayList();
< 
<                         int k;
<                         for(k = 0; k < nrow; ++k) {
<                            rows.add(new SparseArrayModified());
<                         }
< 
<                         int var10002;
<                         for(k = 0; k < nz; ++k) {
<                            String[] tokens = scanner.nextLine().trim().split("\\s+");
<                            if (tokens.length != 3) {
<                               throw new ParseException("Invalid data line: " + line, reader.getLineNumber());
<                            }
< 
<                            i = Integer.parseInt(tokens[0]) - 1;
<                            int j = Integer.parseInt(tokens[1]) - 1;
<                            double x = Double.parseDouble(tokens[2]);
<                            SparseArrayModified row = (SparseArrayModified)rows.get(i);
<                            row.set(j, x);
<                            var10002 = colSize[j]++;
<                            if (symmetric) {
<                               row = (SparseArrayModified)rows.get(j);
<                               row.set(i, x);
<                               var10002 = colSize[i]++;
<                            } else if (skew) {
<                               row = (SparseArrayModified)rows.get(j);
<                               row.set(i, -x);
<                               var10002 = colSize[i]++;
<                            }
<                         }
< 
<                         int[] pos = new int[ncol];
<                         int[] colIndex = new int[ncol + 1];
< 
<                         for(i = 0; i < ncol; ++i) {
<                            colIndex[i + 1] = colIndex[i] + colSize[i];
<                         }
< 
<                         if (symmetric || skew) {
<                            nz *= 2;
<                         }
< 
<                         int[] rowIndex = new int[nz];
<                         double[] x = new double[nz];
<                         int i = 0;
< 
<                         while(true) {
<                            if (i >= nrow) {
<                               var10000 = new SparseMatrixModified(nrow, ncol, x, rowIndex, colIndex);
<                               break;
<                            }
< 
<                            int j;
<                            for(Iterator var56 = ((SparseArrayModified)rows.get(i)).iterator(); var56.hasNext(); var10002 = pos[j]++) {
<                               SparseArrayModified.Entry e = (SparseArrayModified.Entry)var56.next();
<                               j = e.i;
<                               int k = colIndex[j] + pos[j];
<                               rowIndex[k] = i;
<                               x[k] = e.x;
<                            }
< 
<                            ++i;
<                         }
<                      } finally {
<                         if (scanner != null) {
<                            scanner.close();
<                         }
< 
<                      }
<                   } catch (Throwable var38) {
<                      if (var1 == null) {
<                         var1 = var38;
<                      } else if (var1 != var38) {
<                         var1.addSuppressed(var38);
<                      }
< 
<                      if (reader != null) {
<                         reader.close();
<                      }
< 
<                      throw var1;
<                   }
< 
<                   if (reader != null) {
<                      reader.close();
<                   }
< 
<                   return var10000;
<                }
< 
<                if (reader != null) {
<                   reader.close();
<                }
< 
<                return var40;
<             }
< 
<             if (reader != null) {
<                reader.close();
<             }
< 
<             return var41;
<          }
< 
<          if (reader != null) {
<             reader.close();
<          }
< 
<          return var40;
<       } catch (Throwable var39) {
<          if (var1 == null) {
<             var1 = var39;
<          } else if (var1 != var39) {
<             var1.addSuppressed(var39);
<          }
< 
<          throw var1;
<       }
<    }
< 
<    public IMatrixModified square() {
<       return new IMatrixModified.Square(this);
<    }
< 
<    public IMatrixModified.Preconditioner Jacobi() {
<       double[] diag = this.diag();
<       return (b, x) -> {
<          int n = diag.length;
< 
<          for(int i = 0; i < n; ++i) {
<             x[i] = diag[i] != 0.0D ? b[i] / diag[i] : b[i];
<          }
< 
<       };
<    }
< 
<    public double solve(double[] b, double[] x) {
<       return this.solve(b, x, this.Jacobi(), 1.0E-6D, 1, 2 * Math.max(this.nrow(), this.ncol()));
<    }
< 
<    public double solve(double[] b, double[] x, IMatrixModified.Preconditioner P, double tol, int itol, int maxIter) {
<       if (tol <= 0.0D) {
<          throw new IllegalArgumentException("Invalid tolerance: " + tol);
<       } else if (itol >= 1 && itol <= 4) {
<          if (maxIter <= 0) {
<             throw new IllegalArgumentException("Invalid maximum iterations: " + maxIter);
<          } else {
<             double err = 0.0D;
<             double bkden = 1.0D;
<             double znrm = 0.0D;
<             int n = b.length;
<             double[] p = new double[n];
<             double[] pp = new double[n];
<             double[] r = new double[n];
<             double[] rr = new double[n];
<             double[] z = new double[n];
<             double[] zz = new double[n];
<             this.mv(x, r);
< 
<             int j;
<             for(j = 0; j < n; ++j) {
<                r[j] = b[j] - r[j];
<                rr[j] = r[j];
<             }
< 
<             double bnrm;
<             if (itol == 1) {
<                bnrm = norm(b, itol);
<                P.asolve(r, z);
<             } else if (itol == 2) {
<                P.asolve(b, z);
<                bnrm = norm(z, itol);
<                P.asolve(r, z);
<             } else {
<                if (itol != 3 && itol != 4) {
<                   throw new IllegalArgumentException(String.format("Illegal itol: %d", itol));
<                }
< 
<                P.asolve(b, z);
<                bnrm = norm(z, itol);
<                P.asolve(r, z);
<                znrm = norm(z, itol);
<             }
< 
<             for(int iter = 1; iter <= maxIter; ++iter) {
<                P.asolve(rr, zz);
<                double bknum = 0.0D;
< 
<                for(j = 0; j < n; ++j) {
<                   bknum += z[j] * rr[j];
<                }
< 
<                if (iter == 1) {
<                   for(j = 0; j < n; ++j) {
<                      p[j] = z[j];
<                      pp[j] = zz[j];
<                   }
<                } else {
<                   double bk = bknum / bkden;
< 
<                   for(j = 0; j < n; ++j) {
<                      p[j] = bk * p[j] + z[j];
<                      pp[j] = bk * pp[j] + zz[j];
<                   }
<                }
< 
<                bkden = bknum;
<                this.mv(p, z);
<                double akden = 0.0D;
< 
<                for(j = 0; j < n; ++j) {
<                   akden += z[j] * pp[j];
<                }
< 
<                double ak = bknum / akden;
<                this.tv(pp, zz);
< 
<                for(j = 0; j < n; ++j) {
<                   x[j] += ak * p[j];
<                   r[j] -= ak * z[j];
<                   rr[j] -= ak * zz[j];
<                }
< 
<                P.asolve(r, z);
<                if (itol == 1) {
<                   err = norm(r, itol) / bnrm;
<                } else if (itol == 2) {
<                   err = norm(z, itol) / bnrm;
<                } else if (itol == 3 || itol == 4) {
<                   double zm1nrm = znrm;
<                   znrm = norm(z, itol);
<                   if (!(Math.abs(zm1nrm - znrm) > MathExModified.EPSILON * znrm)) {
<                      err = znrm / bnrm;
<                      continue;
<                   }
< 
<                   double dxnrm = Math.abs(ak) * norm(p, itol);
<                   err = znrm / Math.abs(zm1nrm - znrm) * dxnrm;
<                   double xnrm = norm(x, itol);
<                   if (!(err <= 0.5D * xnrm)) {
<                      err = znrm / bnrm;
<                      continue;
<                   }
< 
<                   err /= xnrm;
<                }
< 
<                if (iter % 10 == 0) {
<                   logger.info(String.format("BCG: the error after %3d iterations: %.5g", iter, err));
<                }
< 
<                if (err <= tol) {
<                   logger.info(String.format("BCG: the error after %3d iterations: %.5g", iter, err));
<                   break;
<                }
<             }
< 
<             return err;
<          }
<       } else {
<          throw new IllegalArgumentException("Invalid itol: " + itol);
<       }
<    }
< 
<    private static double norm(double[] x, int itol) {
<       int n = x.length;
<       if (itol > 3) {
<          int isamax = 0;
< 
<          for(int i = 0; i < n; ++i) {
<             if (Math.abs(x[i]) > Math.abs(x[isamax])) {
<                isamax = i;
<             }
<          }
< 
<          return Math.abs(x[isamax]);
<       } else {
<          double ans = 0.0D;
<          double[] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             double v = var9[var7];
<             ans += v * v;
<          }
< 
<          return Math.sqrt(ans);
<       }
<    }
< 
<    public interface Preconditioner {
<       void asolve(double[] var1, double[] var2);
<    }
< 
<    static class Square extends IMatrixModified {
<       private final IMatrixModified A;
<       private final int m;
<       private final int n;
<       private final double[] Ax;
< 
<       public Square(IMatrixModified A) {
<          this.A = A;
<          this.m = Math.max(A.nrow(), A.ncol());
<          this.n = Math.min(A.nrow(), A.ncol());
<          this.Ax = new double[this.m + this.n];
<       }
< 
<       public int nrow() {
<          return this.n;
<       }
< 
<       public int ncol() {
<          return this.n;
<       }
< 
<       public long size() {
<          return this.A.size();
<       }
< 
<       public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
<          if (this.A.nrow() >= this.A.ncol()) {
<             this.A.mv(x, this.Ax);
<             this.A.tv(alpha, this.Ax, beta, y);
<          } else {
<             this.A.tv(x, this.Ax);
<             this.A.mv(alpha, this.Ax, beta, y);
<          }
< 
<       }
< 
<       public void mv(double[] work, int inputOffset, int outputOffset) {
<          System.arraycopy(work, inputOffset, this.Ax, 0, this.n);
<          if (this.A.nrow() >= this.A.ncol()) {
<             this.A.mv(this.Ax, 0, this.n);
<             this.A.tv(this.Ax, this.n, 0);
<          } else {
<             this.A.tv(this.Ax, 0, this.n);
<             this.A.mv(this.Ax, this.n, 0);
<          }
< 
<          System.arraycopy(this.Ax, 0, work, outputOffset, this.n);
<       }
< 
<       public void tv(double[] work, int inputOffset, int outputOffset) {
<          this.mv(work, inputOffset, outputOffset);
<       }
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.io.IOException;
> /*     */ import java.io.Serializable;
> /*     */ import java.nio.file.Path;
> /*     */ import java.text.ParseException;
> /*     */ import org.slf4j.Logger;
> /*     */ import org.slf4j.LoggerFactory;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class IMatrixModified
> /*     */   implements Cloneable, Serializable
> /*     */ {
> /*  17 */   private static final Logger logger = LoggerFactory.getLogger(IMatrixModified.class);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private String[] rowNames;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private String[] colNames;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String[] rowNames() {
> /*  53 */     return this.rowNames;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void rowNames(String[] names) {
> /*  61 */     if (names != null && names.length != nrow()) {
> /*  62 */       throw new IllegalArgumentException(String.format("Invalid row names length: %d != %d", new Object[] { Integer.valueOf(names.length), Integer.valueOf(nrow()) }));
> /*     */     }
> /*  64 */     this.rowNames = names;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String rowName(int i) {
> /*  73 */     return this.rowNames[i];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String[] colNames() {
> /*  81 */     return this.colNames;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void colNames(String[] names) {
> /*  89 */     if (names != null && names.length != ncol()) {
> /*  90 */       throw new IllegalArgumentException(String.format("Invalid column names length: %d != %d", new Object[] { Integer.valueOf(names.length), Integer.valueOf(ncol()) }));
> /*     */     }
> /*  92 */     this.colNames = names;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String colName(int i) {
> /* 101 */     return this.colNames[i];
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 106 */     return toString(false);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString(boolean full) {
> /* 116 */     return full ? toString(nrow(), ncol()) : toString(7, 7);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString(int m, int n) {
> /* 126 */     StringBuilder sb = new StringBuilder(String.valueOf(nrow()) + " x " + ncol() + "\n");
> /* 127 */     m = Math.min(m, nrow());
> /* 128 */     n = Math.min(n, ncol());
> /*     */     
> /* 130 */     String newline = (n < ncol()) ? "  ...\n" : "\n";
> /*     */     
> /* 132 */     if (this.colNames != null) {
> /* 133 */       if (this.rowNames != null) sb.append("            ");
> /*     */       
> /* 135 */       for (int j = 0; j < n; j++) {
> /* 136 */         sb.append(String.format(" %12.12s", new Object[] { this.colNames[j] }));
> /*     */       } 
> /* 138 */       sb.append(newline);
> /*     */     } 
> /*     */     
> /* 141 */     for (int i = 0; i < m; i++) {
> /* 142 */       if (this.rowNames != null) sb.append(String.format("%-12.12s", new Object[] { this.rowNames[i] }));
> /*     */       
> /* 144 */       for (int j = 0; j < n; j++) {
> /* 145 */         sb.append(String.format(" %12.12s", new Object[] { str(i, j) }));
> /*     */       } 
> /* 147 */       sb.append(newline);
> /*     */     } 
> /*     */     
> /* 150 */     if (m < nrow()) {
> /* 151 */       sb.append("  ...\n");
> /*     */     }
> /*     */     
> /* 154 */     return sb.toString();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private String str(int i, int j) {
> /* 164 */     return StringsModified.format(get(i, j), true);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] mv(double[] x) {
> /* 190 */     double[] y = new double[nrow()];
> /* 191 */     mv(TransposeModified.NO_TRANSPOSE, 1.0D, x, 0.0D, y);
> /* 192 */     return y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void mv(double[] x, double[] y) {
> /* 201 */     mv(TransposeModified.NO_TRANSPOSE, 1.0D, x, 0.0D, y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void mv(double alpha, double[] x, double beta, double[] y) {
> /* 217 */     mv(TransposeModified.NO_TRANSPOSE, alpha, x, beta, y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] tv(double[] x) {
> /* 234 */     double[] y = new double[ncol()];
> /* 235 */     mv(TransposeModified.TRANSPOSE, 1.0D, x, 0.0D, y);
> /* 236 */     return y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void tv(double[] x, double[] y) {
> /* 245 */     mv(TransposeModified.TRANSPOSE, 1.0D, x, 0.0D, y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void tv(double alpha, double[] x, double beta, double[] y) {
> /* 261 */     mv(TransposeModified.TRANSPOSE, alpha, x, beta, y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static int ld(int n) {
> /* 297 */     int elementSize = 4;
> /* 298 */     if (n <= 256 / elementSize) return n;
> /*     */     
> /* 300 */     return ((n * elementSize + 511) / 512 * 512 + 64) / elementSize;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   static TransposeModified flip(TransposeModified trans) {
> /* 305 */     return (trans == TransposeModified.NO_TRANSPOSE) ? TransposeModified.TRANSPOSE : TransposeModified.NO_TRANSPOSE;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void set(int i, int j, double x) {
> /* 315 */     throw new UnsupportedOperationException();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void update(int i, int j, double x) {
> /* 325 */     set(i, j, x);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double get(int i, int j) {
> /* 335 */     throw new UnsupportedOperationException();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double apply(int i, int j) {
> /* 345 */     return get(i, j);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] diag() {
> /* 353 */     int n = Math.min(nrow(), ncol());
> /*     */     
> /* 355 */     double[] d = new double[n];
> /* 356 */     for (int i = 0; i < n; i++) {
> /* 357 */       d[i] = get(i, i);
> /*     */     }
> /*     */     
> /* 360 */     return d;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double trace() {
> /* 368 */     int n = Math.min(nrow(), ncol());
> /*     */     
> /* 370 */     double t = 0.0D;
> /* 371 */     for (int i = 0; i < n; i++) {
> /* 372 */       t += get(i, i);
> /*     */     }
> /*     */     
> /* 375 */     return t;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double eigen(double[] v) {
> /* 389 */     return eigen(v, 0.0D, Math.max(1.0E-6D, nrow() * MathExModified.EPSILON), Math.max(20, 2 * nrow()));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double eigen(double[] v, double p, double tol, int maxIter) {
> /* 416 */     if (nrow() != ncol()) {
> /* 417 */       throw new IllegalArgumentException("Matrix is not square.");
> /*     */     }
> /*     */     
> /* 420 */     if (tol <= 0.0D) {
> /* 421 */       throw new IllegalArgumentException("Invalid tolerance: " + tol);
> /*     */     }
> /*     */     
> /* 424 */     if (maxIter <= 0) {
> /* 425 */       throw new IllegalArgumentException("Invalid maximum number of iterations: " + maxIter);
> /*     */     }
> /*     */     
> /* 428 */     int n = nrow();
> /* 429 */     tol = Math.max(tol, MathExModified.EPSILON * n);
> /*     */     
> /* 431 */     double[] z = new double[n];
> /* 432 */     double lambda = power(v, z, p);
> /*     */     
> /* 434 */     for (int iter = 1; iter <= maxIter; iter++) {
> /* 435 */       double l = lambda;
> /* 436 */       lambda = power(v, z, p);
> /*     */       
> /* 438 */       double eps = Math.abs(lambda - l);
> /* 439 */       if (iter % 10 == 0) {
> /* 440 */         logger.trace(String.format("Largest eigenvalue after %3d power iterations: %.4f", new Object[] { Integer.valueOf(iter), Double.valueOf(lambda + p) }));
> /*     */       }
> /*     */       
> /* 443 */       if (eps < tol) {
> /* 444 */         logger.info(String.format("Largest eigenvalue after %3d power iterations: %.4f", new Object[] { Integer.valueOf(iter), Double.valueOf(lambda + p) }));
> /* 445 */         return lambda + p;
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 449 */     logger.info(String.format("Largest eigenvalue after %3d power iterations: %.4f", new Object[] { Integer.valueOf(maxIter), Double.valueOf(lambda + p) }));
> /* 450 */     logger.error("Power iteration exceeded the maximum number of iterations.");
> /* 451 */     return lambda + p;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private double power(double[] x, double[] y, double p) {
> /* 459 */     mv(x, y);
> /*     */     
> /* 461 */     if (p != 0.0D) {
> /* 462 */       for (int j = 0; j < y.length; j++) {
> /* 463 */         y[j] = y[j] - p * x[j];
> /*     */       }
> /*     */     }
> /*     */     
> /* 467 */     double lambda = y[0]; int i;
> /* 468 */     for (i = 1; i < y.length; i++) {
> /* 469 */       if (Math.abs(y[i]) > Math.abs(lambda)) {
> /* 470 */         lambda = y[i];
> /*     */       }
> /*     */     } 
> /*     */     
> /* 474 */     for (i = 0; i < y.length; i++) {
> /* 475 */       x[i] = y[i] / lambda;
> /*     */     }
> /*     */     
> /* 478 */     return lambda;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static IMatrixModified market(Path path) throws IOException, ParseException {
> /* 494 */     Exception exception1 = null, exception2 = null;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     try {
> /*     */     
> /*     */     } finally {
> /* 660 */       exception2 = null; if (exception1 == null) { exception1 = exception2; } else if (exception1 != exception2) { exception1.addSuppressed(exception2); }
> /*     */     
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static interface Preconditioner
> /*     */   {
> /*     */     void asolve(double[] param1ArrayOfdouble1, double[] param1ArrayOfdouble2);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static class Square
> /*     */     extends IMatrixModified
> /*     */   {
> /*     */     private final IMatrixModified A;
> /*     */ 
> /*     */     
> /*     */     private final int m;
> /*     */ 
> /*     */     
> /*     */     private final int n;
> /*     */ 
> /*     */     
> /*     */     private final double[] Ax;
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public Square(IMatrixModified A) {
> /* 691 */       this.A = A;
> /* 692 */       this.m = Math.max(A.nrow(), A.ncol());
> /* 693 */       this.n = Math.min(A.nrow(), A.ncol());
> /* 694 */       this.Ax = new double[this.m + this.n];
> /*     */     }
> /*     */ 
> /*     */     
> /*     */     public int nrow() {
> /* 699 */       return this.n;
> /*     */     }
> /*     */ 
> /*     */     
> /*     */     public int ncol() {
> /* 704 */       return this.n;
> /*     */     }
> /*     */ 
> /*     */     
> /*     */     public long size() {
> /* 709 */       return this.A.size();
> /*     */     }
> /*     */ 
> /*     */     
> /*     */     public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
> /* 714 */       if (this.A.nrow() >= this.A.ncol()) {
> /* 715 */         this.A.mv(x, this.Ax);
> /* 716 */         this.A.tv(alpha, this.Ax, beta, y);
> /*     */       } else {
> /* 718 */         this.A.tv(x, this.Ax);
> /* 719 */         this.A.mv(alpha, this.Ax, beta, y);
> /*     */       } 
> /*     */     }
> /*     */ 
> /*     */     
> /*     */     public void mv(double[] work, int inputOffset, int outputOffset) {
> /* 725 */       System.arraycopy(work, inputOffset, this.Ax, 0, this.n);
> /*     */       
> /* 727 */       if (this.A.nrow() >= this.A.ncol()) {
> /* 728 */         this.A.mv(this.Ax, 0, this.n);
> /* 729 */         this.A.tv(this.Ax, this.n, 0);
> /*     */       } else {
> /* 731 */         this.A.tv(this.Ax, 0, this.n);
> /* 732 */         this.A.mv(this.Ax, this.n, 0);
> /*     */       } 
> /*     */       
> /* 735 */       System.arraycopy(this.Ax, 0, work, outputOffset, this.n);
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public void tv(double[] work, int inputOffset, int outputOffset) {
> /* 741 */       mv(work, inputOffset, outputOffset);
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public IMatrixModified square() {
> /* 754 */     return new Square(this);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Preconditioner Jacobi() {
> /* 787 */     double[] diag = diag();
> /* 788 */     return (b, x) -> {
> /*     */         int n = paramArrayOfdouble1.length;
> /*     */         for (int i = 0; i < n; i++) {
> /*     */           x[i] = (paramArrayOfdouble1[i] != 0.0D) ? (b[i] / paramArrayOfdouble1[i]) : b[i];
> /*     */         }
> /*     */       };
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double solve(double[] b, double[] x) {
> /* 807 */     return solve(b, x, Jacobi(), 1.0E-6D, 1, 2 * Math.max(nrow(), ncol()));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double solve(double[] b, double[] x, Preconditioner P, double tol, int itol, int maxIter) {
> /*     */     double bnrm;
> /* 831 */     if (tol <= 0.0D) {
> /* 832 */       throw new IllegalArgumentException("Invalid tolerance: " + tol);
> /*     */     }
> /*     */     
> /* 835 */     if (itol < 1 || itol > 4) {
> /* 836 */       throw new IllegalArgumentException("Invalid itol: " + itol);
> /*     */     }
> /*     */     
> /* 839 */     if (maxIter <= 0) {
> /* 840 */       throw new IllegalArgumentException("Invalid maximum iterations: " + maxIter);
> /*     */     }
> /*     */     
> /* 843 */     double err = 0.0D;
> /* 844 */     double bkden = 1.0D, znrm = 0.0D;
> /* 845 */     int n = b.length;
> /*     */     
> /* 847 */     double[] p = new double[n];
> /* 848 */     double[] pp = new double[n];
> /* 849 */     double[] r = new double[n];
> /* 850 */     double[] rr = new double[n];
> /* 851 */     double[] z = new double[n];
> /* 852 */     double[] zz = new double[n];
> /*     */     
> /* 854 */     mv(x, r); int j;
> /* 855 */     for (j = 0; j < n; j++) {
> /* 856 */       r[j] = b[j] - r[j];
> /* 857 */       rr[j] = r[j];
> /*     */     } 
> /*     */     
> /* 860 */     if (itol == 1) {
> /* 861 */       bnrm = norm(b, itol);
> /* 862 */       P.asolve(r, z);
> /* 863 */     } else if (itol == 2) {
> /* 864 */       P.asolve(b, z);
> /* 865 */       bnrm = norm(z, itol);
> /* 866 */       P.asolve(r, z);
> /* 867 */     } else if (itol == 3 || itol == 4) {
> /* 868 */       P.asolve(b, z);
> /* 869 */       bnrm = norm(z, itol);
> /* 870 */       P.asolve(r, z);
> /* 871 */       znrm = norm(z, itol);
> /*     */     } else {
> /* 873 */       throw new IllegalArgumentException(String.format("Illegal itol: %d", new Object[] { Integer.valueOf(itol) }));
> /*     */     } 
> /*     */     
> /* 876 */     for (int iter = 1; iter <= maxIter; iter++) {
> /* 877 */       P.asolve(rr, zz); double bknum;
> /* 878 */       for (bknum = 0.0D, j = 0; j < n; j++) {
> /* 879 */         bknum += z[j] * rr[j];
> /*     */       }
> /* 881 */       if (iter == 1) {
> /* 882 */         for (j = 0; j < n; j++) {
> /* 883 */           p[j] = z[j];
> /* 884 */           pp[j] = zz[j];
> /*     */         } 
> /*     */       } else {
> /* 887 */         double bk = bknum / bkden;
> /* 888 */         for (j = 0; j < n; j++) {
> /* 889 */           p[j] = bk * p[j] + z[j];
> /* 890 */           pp[j] = bk * pp[j] + zz[j];
> /*     */         } 
> /*     */       } 
> /* 893 */       bkden = bknum;
> /* 894 */       mv(p, z); double akden;
> /* 895 */       for (akden = 0.0D, j = 0; j < n; j++) {
> /* 896 */         akden += z[j] * pp[j];
> /*     */       }
> /* 898 */       double ak = bknum / akden;
> /* 899 */       tv(pp, zz);
> /* 900 */       for (j = 0; j < n; j++) {
> /* 901 */         x[j] = x[j] + ak * p[j];
> /* 902 */         r[j] = r[j] - ak * z[j];
> /* 903 */         rr[j] = rr[j] - ak * zz[j];
> /*     */       } 
> /* 905 */       P.asolve(r, z);
> /* 906 */       if (itol == 1) {
> /* 907 */         err = norm(r, itol) / bnrm;
> /* 908 */       } else if (itol == 2) {
> /* 909 */         err = norm(z, itol) / bnrm;
> /* 910 */       } else if (itol == 3 || itol == 4) {
> /* 911 */         double zm1nrm = znrm;
> /* 912 */         znrm = norm(z, itol);
> /* 913 */         if (Math.abs(zm1nrm - znrm) > MathExModified.EPSILON * znrm) {
> /* 914 */           double dxnrm = Math.abs(ak) * norm(p, itol);
> /* 915 */           err = znrm / Math.abs(zm1nrm - znrm) * dxnrm;
> /*     */         } else {
> /* 917 */           err = znrm / bnrm;
> /*     */           iter++;
> /*     */         } 
> /* 920 */         double xnrm = norm(x, itol);
> /* 921 */         if (err <= 0.5D * xnrm) {
> /* 922 */           err /= xnrm;
> /*     */         } else {
> /* 924 */           err = znrm / bnrm;
> /*     */           
> /*     */           iter++;
> /*     */         } 
> /*     */       } 
> /* 929 */       if (iter % 10 == 0) {
> /* 930 */         logger.info(String.format("BCG: the error after %3d iterations: %.5g", new Object[] { Integer.valueOf(iter), Double.valueOf(err) }));
> /*     */       }
> /*     */       
> /* 933 */       if (err <= tol) {
> /* 934 */         logger.info(String.format("BCG: the error after %3d iterations: %.5g", new Object[] { Integer.valueOf(iter), Double.valueOf(err) }));
> /*     */         
> /*     */         break;
> /*     */       } 
> /*     */     } 
> /* 939 */     return err;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private static double norm(double[] x, int itol) {
> /* 946 */     int n = x.length;
> /*     */     
> /* 948 */     if (itol <= 3) {
> /* 949 */       double ans = 0.0D; byte b; int j; double[] arrayOfDouble;
> /* 950 */       for (j = (arrayOfDouble = x).length, b = 0; b < j; ) { double v = arrayOfDouble[b];
> /* 951 */         ans += v * v; b++; }
> /*     */       
> /* 953 */       return Math.sqrt(ans);
> /*     */     } 
> /* 955 */     int isamax = 0;
> /* 956 */     for (int i = 0; i < n; i++) {
> /* 957 */       if (Math.abs(x[i]) > Math.abs(x[isamax])) {
> /* 958 */         isamax = i;
> /*     */       }
> /*     */     } 
> /*     */     
> /* 962 */     return Math.abs(x[isamax]);
> /*     */   }
> /*     */   
> /*     */   public abstract int nrow();
> /*     */   
> /*     */   public abstract int ncol();
> /*     */   
> /*     */   public abstract long size();
> /*     */   
> /*     */   public abstract void mv(TransposeModified paramTransposeModified, double paramDouble1, double[] paramArrayOfdouble1, double paramDouble2, double[] paramArrayOfdouble2);
> /*     */   
> /*     */   public abstract void mv(double[] paramArrayOfdouble, int paramInt1, int paramInt2);
> /*     */   
> /*     */   public abstract void tv(double[] paramArrayOfdouble, int paramInt1, int paramInt2);
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/IMatrixModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/IntArrayListModified.java jd-gui/smileModified/IntArrayListModified.java
1,121c1,237
< package smileModified;
< 
< import java.io.Serializable;
< import java.util.Arrays;
< import java.util.stream.Collectors;
< import java.util.stream.IntStream;
< 
< public final class IntArrayListModified implements Serializable {
<    private static final long serialVersionUID = 1L;
<    int[] data;
<    private int size;
< 
<    public IntArrayListModified() {
<       this(10);
<    }
< 
<    public IntArrayListModified(int capacity) {
<       this.data = new int[capacity];
<       this.size = 0;
<    }
< 
<    public IntArrayListModified(int[] values) {
<       this(Math.max(values.length, 10));
<       this.add(values);
<    }
< 
<    public String toString() {
<       return (String)Arrays.stream(this.data).limit((long)this.size).mapToObj(String::valueOf).collect(Collectors.joining(", ", "[", "]"));
<    }
< 
<    public IntStream stream() {
<       return IntStream.of(this.data).limit((long)this.size);
<    }
< 
<    public void ensureCapacity(int capacity) {
<       if (capacity > this.data.length) {
<          int newCap = Math.max(this.data.length << 1, capacity);
<          int[] tmp = new int[newCap];
<          System.arraycopy(this.data, 0, tmp, 0, this.data.length);
<          this.data = tmp;
<       }
< 
<    }
< 
<    public int size() {
<       return this.size;
<    }
< 
<    public boolean isEmpty() {
<       return this.size == 0;
<    }
< 
<    public void trim() {
<       if (this.data.length > this.size) {
<          this.data = this.toArray();
<       }
< 
<    }
< 
<    public void add(int val) {
<       this.ensureCapacity(this.size + 1);
<       this.data[this.size++] = val;
<    }
< 
<    public void add(IntArrayListModified vals) {
<       this.ensureCapacity(this.size + vals.size);
<       System.arraycopy(vals.data, 0, this.data, this.size, vals.size);
<       this.size += vals.size;
<    }
< 
<    public void add(int[] vals) {
<       this.ensureCapacity(this.size + vals.length);
<       System.arraycopy(vals, 0, this.data, this.size, vals.length);
<       this.size += vals.length;
<    }
< 
<    public int get(int index) {
<       return this.data[index];
<    }
< 
<    public void set(int index, int val) {
<       if (index >= 0 && index < this.size) {
<          this.data[index] = val;
<       } else {
<          throw new IndexOutOfBoundsException(String.valueOf(index));
<       }
<    }
< 
<    public void clear() {
<       this.size = 0;
<    }
< 
<    public int remove(int index) {
<       if (index >= 0 && index < this.size) {
<          int old = this.get(index);
<          if (index == 0) {
<             System.arraycopy(this.data, 1, this.data, 0, this.size - 1);
<          } else if (index != this.size - 1) {
<             System.arraycopy(this.data, index + 1, this.data, index, this.size - (index + 1));
<          }
< 
<          --this.size;
<          return old;
<       } else {
<          throw new IndexOutOfBoundsException(String.valueOf(index));
<       }
<    }
< 
<    public int[] toArray() {
<       return this.toArray((int[])null);
<    }
< 
<    public int[] toArray(int[] dest) {
<       if (dest == null || dest.length < this.size()) {
<          dest = new int[this.size];
<       }
< 
<       System.arraycopy(this.data, 0, dest, 0, this.size);
<       return dest;
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ import java.util.Arrays;
> /*     */ import java.util.stream.Collectors;
> /*     */ import java.util.stream.IntStream;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public final class IntArrayListModified
> /*     */   implements Serializable
> /*     */ {
> /*     */   private static final long serialVersionUID = 1L;
> /*     */   int[] data;
> /*     */   private int size;
> /*     */   
> /*     */   public IntArrayListModified() {
> /*  32 */     this(10);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public IntArrayListModified(int capacity) {
> /*  41 */     this.data = new int[capacity];
> /*  42 */     this.size = 0;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public IntArrayListModified(int[] values) {
> /*  51 */     this(Math.max(values.length, 10));
> /*  52 */     add(values);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /*  57 */     return Arrays.stream(this.data).limit(this.size).<CharSequence>mapToObj(String::valueOf).collect(Collectors.joining(", ", "[", "]"));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public IntStream stream() {
> /*  65 */     return IntStream.of(this.data).limit(this.size);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void ensureCapacity(int capacity) {
> /*  76 */     if (capacity > this.data.length) {
> /*  77 */       int newCap = Math.max(this.data.length << 1, capacity);
> /*  78 */       int[] tmp = new int[newCap];
> /*  79 */       System.arraycopy(this.data, 0, tmp, 0, this.data.length);
> /*  80 */       this.data = tmp;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int size() {
> /*  90 */     return this.size;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean isEmpty() {
> /*  99 */     return (this.size == 0);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void trim() {
> /* 106 */     if (this.data.length > this.size) {
> /* 107 */       this.data = toArray();
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void add(int val) {
> /* 117 */     ensureCapacity(this.size + 1);
> /* 118 */     this.data[this.size++] = val;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void add(IntArrayListModified vals) {
> /* 127 */     ensureCapacity(this.size + vals.size);
> /* 128 */     System.arraycopy(vals.data, 0, this.data, this.size, vals.size);
> /* 129 */     this.size += vals.size;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void add(int[] vals) {
> /* 138 */     ensureCapacity(this.size + vals.length);
> /* 139 */     System.arraycopy(vals, 0, this.data, this.size, vals.length);
> /* 140 */     this.size += vals.length;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int get(int index) {
> /* 150 */     return this.data[index];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void set(int index, int val) {
> /* 162 */     if (index < 0 || index >= this.size) {
> /* 163 */       throw new IndexOutOfBoundsException(String.valueOf(index));
> /*     */     }
> /* 165 */     this.data[index] = val;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void clear() {
> /* 173 */     this.size = 0;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int remove(int index) {
> /* 184 */     if (index < 0 || index >= this.size) {
> /* 185 */       throw new IndexOutOfBoundsException(String.valueOf(index));
> /*     */     }
> /*     */     
> /* 188 */     int old = get(index);
> /*     */     
> /* 190 */     if (index == 0) {
> /*     */       
> /* 192 */       System.arraycopy(this.data, 1, this.data, 0, this.size - 1);
> /* 193 */     } else if (index != this.size - 1) {
> /*     */       
> /* 195 */       System.arraycopy(this.data, index + 1, this.data, index, this.size - index + 1);
> /*     */     } 
> /*     */     
> /* 198 */     this.size--;
> /* 199 */     return old;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int[] toArray() {
> /* 209 */     return toArray(null);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int[] toArray(int[] dest) {
> /* 224 */     if (dest == null || dest.length < size()) {
> /* 225 */       dest = new int[this.size];
> /*     */     }
> /*     */     
> /* 228 */     System.arraycopy(this.data, 0, dest, 0, this.size);
> /* 229 */     return dest;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/IntArrayListModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/IntPair.java jd-gui/smileModified/IntPair.java
1c1,40
< package smileModified;
---
> /*    */ package smileModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class IntPair
> /*    */ {
> /*    */   public final int i;
> /*    */   public final int j;
> /*    */   
> /*    */   public IntPair(int i, int j) {
> /* 17 */     this.i = i;
> /* 18 */     this.j = j;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public int hashCode() {
> /* 23 */     return this.i * 31 + this.j;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public String toString() {
> /* 28 */     return String.format("(%d, %d)", new Object[] { Integer.valueOf(this.i), Integer.valueOf(this.j) });
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public boolean equals(Object o) {
> /* 33 */     if (o instanceof IntPair) {
> /* 34 */       IntPair p = (IntPair)o;
> /* 35 */       return (this.i == p.i && this.j == p.j);
> /*    */     } 
> /*    */     
> /* 38 */     return false;
> /*    */   }
> /*    */ }
3,5d41
< public class IntPair {
<    public final int i;
<    public final int j;
7,28c43,46
<    public IntPair(int i, int j) {
<       this.i = i;
<       this.j = j;
<    }
< 
<    public int hashCode() {
<       return this.i * 31 + this.j;
<    }
< 
<    public String toString() {
<       return String.format("(%d, %d)", this.i, this.j);
<    }
< 
<    public boolean equals(Object o) {
<       if (o instanceof IntPair) {
<          IntPair p = (IntPair)o;
<          return this.i == p.i && this.j == p.j;
<       } else {
<          return false;
<       }
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/IntPair.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/LAPACKModified.java jd-gui/smileModified/LAPACKModified.java
1,345c1,386
< package smileModified;
< 
< import java.nio.DoubleBuffer;
< import java.nio.FloatBuffer;
< import java.nio.IntBuffer;
< import org.bytedeco.javacpp.DoublePointer;
< import org.bytedeco.javacpp.IntPointer;
< import org.slf4j.Logger;
< import org.slf4j.LoggerFactory;
< 
< public interface LAPACKModified {
<    LAPACKModified engine = getInstance();
< 
<    static LAPACKModified getInstance() {
<       LAPACKModified mkl = MKL();
<       return (LAPACKModified)(mkl != null ? mkl : new OpenBLASModified());
<    }
< 
<    static LAPACKModified MKL() {
<       Logger logger = LoggerFactory.getLogger(LAPACKModified.class);
< 
<       try {
<          Class<?> clazz = Class.forName("smile.math.blas.mkl.MKL");
<          logger.info("smile-mkl module is available.");
<          return (LAPACKModified)clazz.getDeclaredConstructor().newInstance();
<       } catch (Exception var2) {
<          logger.debug("Failed to create MKL instance: ", var2);
<          return null;
<       }
<    }
< 
<    int gesv(LayoutModified var1, int var2, int var3, double[] var4, int var5, int[] var6, double[] var7, int var8);
< 
<    int gesv(LayoutModified var1, int var2, int var3, DoubleBuffer var4, int var5, IntBuffer var6, DoubleBuffer var7, int var8);
< 
<    int gesv(LayoutModified var1, int var2, int var3, DoublePointer var4, int var5, IntPointer var6, DoublePointer var7, int var8);
< 
<    int gesv(LayoutModified var1, int var2, int var3, float[] var4, int var5, int[] var6, float[] var7, int var8);
< 
<    int gesv(LayoutModified var1, int var2, int var3, FloatBuffer var4, int var5, IntBuffer var6, FloatBuffer var7, int var8);
< 
<    int sysv(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int var6, int[] var7, double[] var8, int var9);
< 
<    int sysv(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, int var6, IntBuffer var7, DoubleBuffer var8, int var9);
< 
<    int sysv(LayoutModified var1, UPLOModified var2, int var3, int var4, DoublePointer var5, int var6, IntPointer var7, DoublePointer var8, int var9);
< 
<    int sysv(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int var6, int[] var7, float[] var8, int var9);
< 
<    int sysv(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, int var6, IntBuffer var7, FloatBuffer var8, int var9);
< 
<    int spsv(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int[] var6, double[] var7, int var8);
< 
<    int spsv(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, IntBuffer var6, DoubleBuffer var7, int var8);
< 
<    int spsv(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int[] var6, float[] var7, int var8);
< 
<    int spsv(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, IntBuffer var6, FloatBuffer var7, int var8);
< 
<    int posv(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8);
< 
<    int posv(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8);
< 
<    int posv(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8);
< 
<    int posv(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8);
< 
<    int ppsv(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, double[] var6, int var7);
< 
<    int ppsv(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, DoubleBuffer var6, int var7);
< 
<    int ppsv(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, float[] var6, int var7);
< 
<    int ppsv(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, FloatBuffer var6, int var7);
< 
<    int gbsv(LayoutModified var1, int var2, int var3, int var4, int var5, double[] var6, int var7, int[] var8, double[] var9, int var10);
< 
<    int gbsv(LayoutModified var1, int var2, int var3, int var4, int var5, DoubleBuffer var6, int var7, IntBuffer var8, DoubleBuffer var9, int var10);
< 
<    int gbsv(LayoutModified var1, int var2, int var3, int var4, int var5, float[] var6, int var7, int[] var8, float[] var9, int var10);
< 
<    int gbsv(LayoutModified var1, int var2, int var3, int var4, int var5, FloatBuffer var6, int var7, IntBuffer var8, FloatBuffer var9, int var10);
< 
<    int gels(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, double[] var6, int var7, double[] var8, int var9);
< 
<    int gels(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9);
< 
<    int gels(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, float[] var6, int var7, float[] var8, int var9);
< 
<    int gels(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, FloatBuffer var6, int var7, FloatBuffer var8, int var9);
< 
<    int gelsy(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8, int[] var9, double var10, int[] var12);
< 
<    int gelsy(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8, IntBuffer var9, double var10, IntBuffer var12);
< 
<    int gelsy(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8, int[] var9, float var10, int[] var11);
< 
<    int gelsy(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, IntBuffer var9, float var10, IntBuffer var11);
< 
<    int gelss(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8, double[] var9, double var10, int[] var12);
< 
<    int gelss(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, double var10, IntBuffer var12);
< 
<    int gelss(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8, float[] var9, float var10, int[] var11);
< 
<    int gelss(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, float var10, IntBuffer var11);
< 
<    int gelsd(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8, double[] var9, double var10, int[] var12);
< 
<    int gelsd(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, double var10, IntBuffer var12);
< 
<    int gelsd(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8, float[] var9, float var10, int[] var11);
< 
<    int gelsd(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, float var10, IntBuffer var11);
< 
<    int gglse(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8, double[] var9, double[] var10, double[] var11);
< 
<    int gglse(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, DoubleBuffer var10, DoubleBuffer var11);
< 
<    int gglse(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8, float[] var9, float[] var10, float[] var11);
< 
<    int gglse(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, FloatBuffer var10, FloatBuffer var11);
< 
<    int ggglm(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8, double[] var9, double[] var10, double[] var11);
< 
<    int ggglm(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, DoubleBuffer var10, DoubleBuffer var11);
< 
<    int ggglm(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8, float[] var9, float[] var10, float[] var11);
< 
<    int ggglm(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, FloatBuffer var10, FloatBuffer var11);
< 
<    int geev(LayoutModified var1, EVDJobModified var2, EVDJobModified var3, int var4, double[] var5, int var6, double[] var7, double[] var8, double[] var9, int var10, double[] var11, int var12);
< 
<    int geev(LayoutModified var1, EVDJobModified var2, EVDJobModified var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, DoubleBuffer var8, DoubleBuffer var9, int var10, DoubleBuffer var11, int var12);
< 
<    int geev(LayoutModified var1, EVDJobModified var2, EVDJobModified var3, int var4, DoublePointer var5, int var6, DoublePointer var7, DoublePointer var8, DoublePointer var9, int var10, DoublePointer var11, int var12);
< 
<    int geev(LayoutModified var1, EVDJobModified var2, EVDJobModified var3, int var4, float[] var5, int var6, float[] var7, float[] var8, float[] var9, int var10, float[] var11, int var12);
< 
<    int geev(LayoutModified var1, EVDJobModified var2, EVDJobModified var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, FloatBuffer var8, FloatBuffer var9, int var10, FloatBuffer var11, int var12);
< 
<    int syev(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, double[] var5, int var6, double[] var7);
< 
<    int syev(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7);
< 
<    int syev(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, float[] var5, int var6, float[] var7);
< 
<    int syev(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7);
< 
<    int syevd(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, double[] var5, int var6, double[] var7);
< 
<    int syevd(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7);
< 
<    int syevd(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, DoublePointer var5, int var6, DoublePointer var7);
< 
<    int syevd(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, float[] var5, int var6, float[] var7);
< 
<    int syevd(LayoutModified var1, EVDJobModified var2, UPLOModified var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7);
< 
<    int syevr(LayoutModified var1, EVDJobModified var2, EigenRangeModified var3, UPLOModified var4, int var5, double[] var6, int var7, double var8, double var10, int var12, int var13, double var14, int[] var16, double[] var17, double[] var18, int var19, int[] var20);
< 
<    int syevr(LayoutModified var1, EVDJobModified var2, EigenRangeModified var3, UPLOModified var4, int var5, DoubleBuffer var6, int var7, double var8, double var10, int var12, int var13, double var14, IntBuffer var16, DoubleBuffer var17, DoubleBuffer var18, int var19, IntBuffer var20);
< 
<    int syevr(LayoutModified var1, EVDJobModified var2, EigenRangeModified var3, UPLOModified var4, int var5, float[] var6, int var7, float var8, float var9, int var10, int var11, float var12, int[] var13, float[] var14, float[] var15, int var16, int[] var17);
< 
<    int syevr(LayoutModified var1, EVDJobModified var2, EigenRangeModified var3, UPLOModified var4, int var5, FloatBuffer var6, int var7, float var8, float var9, int var10, int var11, float var12, IntBuffer var13, FloatBuffer var14, FloatBuffer var15, int var16, IntBuffer var17);
< 
<    int gesvd(LayoutModified var1, SVDJobModified var2, SVDJobModified var3, int var4, int var5, double[] var6, int var7, double[] var8, double[] var9, int var10, double[] var11, int var12, double[] var13);
< 
<    int gesvd(LayoutModified var1, SVDJobModified var2, SVDJobModified var3, int var4, int var5, DoubleBuffer var6, int var7, DoubleBuffer var8, DoubleBuffer var9, int var10, DoubleBuffer var11, int var12, DoubleBuffer var13);
< 
<    int gesvd(LayoutModified var1, SVDJobModified var2, SVDJobModified var3, int var4, int var5, float[] var6, int var7, float[] var8, float[] var9, int var10, float[] var11, int var12, float[] var13);
< 
<    int gesvd(LayoutModified var1, SVDJobModified var2, SVDJobModified var3, int var4, int var5, FloatBuffer var6, int var7, FloatBuffer var8, FloatBuffer var9, int var10, FloatBuffer var11, int var12, FloatBuffer var13);
< 
<    int gesdd(LayoutModified var1, SVDJobModified var2, int var3, int var4, double[] var5, int var6, double[] var7, double[] var8, int var9, double[] var10, int var11);
< 
<    int gesdd(LayoutModified var1, SVDJobModified var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, DoubleBuffer var8, int var9, DoubleBuffer var10, int var11);
< 
<    int gesdd(LayoutModified var1, SVDJobModified var2, int var3, int var4, DoublePointer var5, int var6, DoublePointer var7, DoublePointer var8, int var9, DoublePointer var10, int var11);
< 
<    int gesdd(LayoutModified var1, SVDJobModified var2, int var3, int var4, float[] var5, int var6, float[] var7, float[] var8, int var9, float[] var10, int var11);
< 
<    int gesdd(LayoutModified var1, SVDJobModified var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, FloatBuffer var8, int var9, FloatBuffer var10, int var11);
< 
<    int getrf(LayoutModified var1, int var2, int var3, double[] var4, int var5, int[] var6);
< 
<    int getrf(LayoutModified var1, int var2, int var3, DoubleBuffer var4, int var5, IntBuffer var6);
< 
<    int getrf(LayoutModified var1, int var2, int var3, DoublePointer var4, int var5, IntPointer var6);
< 
<    int getrf(LayoutModified var1, int var2, int var3, float[] var4, int var5, int[] var6);
< 
<    int getrf(LayoutModified var1, int var2, int var3, FloatBuffer var4, int var5, IntBuffer var6);
< 
<    int getrf2(LayoutModified var1, int var2, int var3, double[] var4, int var5, int[] var6);
< 
<    int getrf2(LayoutModified var1, int var2, int var3, DoubleBuffer var4, int var5, IntBuffer var6);
< 
<    int getrf2(LayoutModified var1, int var2, int var3, float[] var4, int var5, int[] var6);
< 
<    int getrf2(LayoutModified var1, int var2, int var3, FloatBuffer var4, int var5, IntBuffer var6);
< 
<    int gbtrf(LayoutModified var1, int var2, int var3, int var4, int var5, double[] var6, int var7, int[] var8);
< 
<    int gbtrf(LayoutModified var1, int var2, int var3, int var4, int var5, DoubleBuffer var6, int var7, IntBuffer var8);
< 
<    int gbtrf(LayoutModified var1, int var2, int var3, int var4, int var5, float[] var6, int var7, int[] var8);
< 
<    int gbtrf(LayoutModified var1, int var2, int var3, int var4, int var5, FloatBuffer var6, int var7, IntBuffer var8);
< 
<    int sptrf(LayoutModified var1, UPLOModified var2, int var3, double[] var4, int[] var5);
< 
<    int sptrf(LayoutModified var1, UPLOModified var2, int var3, DoubleBuffer var4, IntBuffer var5);
< 
<    int sptrf(LayoutModified var1, UPLOModified var2, int var3, float[] var4, int[] var5);
< 
<    int sptrf(LayoutModified var1, UPLOModified var2, int var3, FloatBuffer var4, IntBuffer var5);
< 
<    int getrs(LayoutModified var1, TransposeModified var2, int var3, int var4, double[] var5, int var6, int[] var7, double[] var8, int var9);
< 
<    int getrs(LayoutModified var1, TransposeModified var2, int var3, int var4, DoubleBuffer var5, int var6, IntBuffer var7, DoubleBuffer var8, int var9);
< 
<    int getrs(LayoutModified var1, TransposeModified var2, int var3, int var4, DoublePointer var5, int var6, IntPointer var7, DoublePointer var8, int var9);
< 
<    int getrs(LayoutModified var1, TransposeModified var2, int var3, int var4, float[] var5, int var6, int[] var7, float[] var8, int var9);
< 
<    int getrs(LayoutModified var1, TransposeModified var2, int var3, int var4, FloatBuffer var5, int var6, IntBuffer var7, FloatBuffer var8, int var9);
< 
<    int gbtrs(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, double[] var7, int var8, int[] var9, double[] var10, int var11);
< 
<    int gbtrs(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, DoubleBuffer var7, int var8, IntBuffer var9, DoubleBuffer var10, int var11);
< 
<    int gbtrs(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, float[] var7, int var8, int[] var9, float[] var10, int var11);
< 
<    int gbtrs(LayoutModified var1, TransposeModified var2, int var3, int var4, int var5, int var6, FloatBuffer var7, int var8, IntBuffer var9, FloatBuffer var10, int var11);
< 
<    int sptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int[] var6, double[] var7, int var8);
< 
<    int sptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, IntBuffer var6, DoubleBuffer var7, int var8);
< 
<    int sptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, IntBuffer var6, FloatBuffer var7, int var8);
< 
<    int sptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int[] var6, float[] var7, int var8);
< 
<    int potrf(LayoutModified var1, UPLOModified var2, int var3, double[] var4, int var5);
< 
<    int potrf(LayoutModified var1, UPLOModified var2, int var3, DoubleBuffer var4, int var5);
< 
<    int potrf(LayoutModified var1, UPLOModified var2, int var3, DoublePointer var4, int var5);
< 
<    int potrf(LayoutModified var1, UPLOModified var2, int var3, float[] var4, int var5);
< 
<    int potrf(LayoutModified var1, UPLOModified var2, int var3, FloatBuffer var4, int var5);
< 
<    int potrf2(LayoutModified var1, UPLOModified var2, int var3, double[] var4, int var5);
< 
<    int potrf2(LayoutModified var1, UPLOModified var2, int var3, DoubleBuffer var4, int var5);
< 
<    int potrf2(LayoutModified var1, UPLOModified var2, int var3, float[] var4, int var5);
< 
<    int potrf2(LayoutModified var1, UPLOModified var2, int var3, FloatBuffer var4, int var5);
< 
<    int pbtrf(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int var6);
< 
<    int pbtrf(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, int var6);
< 
<    int pbtrf(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int var6);
< 
<    int pbtrf(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, int var6);
< 
<    int pptrf(LayoutModified var1, UPLOModified var2, int var3, double[] var4);
< 
<    int pptrf(LayoutModified var1, UPLOModified var2, int var3, DoubleBuffer var4);
< 
<    int pptrf(LayoutModified var1, UPLOModified var2, int var3, float[] var4);
< 
<    int pptrf(LayoutModified var1, UPLOModified var2, int var3, FloatBuffer var4);
< 
<    int potrs(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, int var6, double[] var7, int var8);
< 
<    int potrs(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7, int var8);
< 
<    int potrs(LayoutModified var1, UPLOModified var2, int var3, int var4, DoublePointer var5, int var6, DoublePointer var7, int var8);
< 
<    int potrs(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, int var6, float[] var7, int var8);
< 
<    int potrs(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7, int var8);
< 
<    int pbtrs(LayoutModified var1, UPLOModified var2, int var3, int var4, int var5, double[] var6, int var7, double[] var8, int var9);
< 
<    int pbtrs(LayoutModified var1, UPLOModified var2, int var3, int var4, int var5, DoubleBuffer var6, int var7, DoubleBuffer var8, int var9);
< 
<    int pbtrs(LayoutModified var1, UPLOModified var2, int var3, int var4, int var5, float[] var6, int var7, float[] var8, int var9);
< 
<    int pbtrs(LayoutModified var1, UPLOModified var2, int var3, int var4, int var5, FloatBuffer var6, int var7, FloatBuffer var8, int var9);
< 
<    int pptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, double[] var5, double[] var6, int var7);
< 
<    int pptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, DoubleBuffer var5, DoubleBuffer var6, int var7);
< 
<    int pptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, float[] var5, float[] var6, int var7);
< 
<    int pptrs(LayoutModified var1, UPLOModified var2, int var3, int var4, FloatBuffer var5, FloatBuffer var6, int var7);
< 
<    int geqrf(LayoutModified var1, int var2, int var3, double[] var4, int var5, double[] var6);
< 
<    int geqrf(LayoutModified var1, int var2, int var3, DoubleBuffer var4, int var5, DoubleBuffer var6);
< 
<    int geqrf(LayoutModified var1, int var2, int var3, DoublePointer var4, int var5, DoublePointer var6);
< 
<    int geqrf(LayoutModified var1, int var2, int var3, float[] var4, int var5, float[] var6);
< 
<    int geqrf(LayoutModified var1, int var2, int var3, FloatBuffer var4, int var5, FloatBuffer var6);
< 
<    int ormqr(LayoutModified var1, SideModified var2, TransposeModified var3, int var4, int var5, int var6, double[] var7, int var8, double[] var9, double[] var10, int var11);
< 
<    int ormqr(LayoutModified var1, SideModified var2, TransposeModified var3, int var4, int var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, DoubleBuffer var10, int var11);
< 
<    int ormqr(LayoutModified var1, SideModified var2, TransposeModified var3, int var4, int var5, int var6, DoublePointer var7, int var8, DoublePointer var9, DoublePointer var10, int var11);
< 
<    int ormqr(LayoutModified var1, SideModified var2, TransposeModified var3, int var4, int var5, int var6, float[] var7, int var8, float[] var9, float[] var10, int var11);
< 
<    int ormqr(LayoutModified var1, SideModified var2, TransposeModified var3, int var4, int var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, FloatBuffer var10, int var11);
< 
<    int orgqr(LayoutModified var1, int var2, int var3, int var4, double[] var5, int var6, double[] var7);
< 
<    int orgqr(LayoutModified var1, int var2, int var3, int var4, DoubleBuffer var5, int var6, DoubleBuffer var7);
< 
<    int orgqr(LayoutModified var1, int var2, int var3, int var4, DoublePointer var5, int var6, DoublePointer var7);
< 
<    int orgqr(LayoutModified var1, int var2, int var3, int var4, float[] var5, int var6, float[] var7);
< 
<    int orgqr(LayoutModified var1, int var2, int var3, int var4, FloatBuffer var5, int var6, FloatBuffer var7);
< 
<    int trtrs(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, int var6, double[] var7, int var8, double[] var9, int var10);
< 
<    int trtrs(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, int var6, DoubleBuffer var7, int var8, DoubleBuffer var9, int var10);
< 
<    int trtrs(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, int var6, DoublePointer var7, int var8, DoublePointer var9, int var10);
< 
<    int trtrs(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, int var6, float[] var7, int var8, float[] var9, int var10);
< 
<    int trtrs(LayoutModified var1, UPLOModified var2, TransposeModified var3, DiagModified var4, int var5, int var6, FloatBuffer var7, int var8, FloatBuffer var9, int var10);
< }
---
> /*    */ package smileModified;
> /*    */ 
> /*    */ import java.nio.DoubleBuffer;
> /*    */ import java.nio.FloatBuffer;
> /*    */ import java.nio.IntBuffer;
> /*    */ import org.bytedeco.javacpp.DoublePointer;
> /*    */ import org.bytedeco.javacpp.IntPointer;
> /*    */ import org.slf4j.Logger;
> /*    */ import org.slf4j.LoggerFactory;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public interface LAPACKModified
> /*    */ {
> /* 37 */   public static final LAPACKModified engine = getInstance();
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   static LAPACKModified getInstance() {
> /* 44 */     LAPACKModified mkl = MKL();
> /* 45 */     return (mkl != null) ? mkl : new OpenBLASModified();
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   static LAPACKModified MKL() {
> /* 53 */     Logger logger = LoggerFactory.getLogger(LAPACKModified.class);
> /*    */     
> /*    */     try {
> /* 56 */       Class<?> clazz = Class.forName("smile.math.blas.mkl.MKL");
> /* 57 */       logger.info("smile-mkl module is available.");
> /* 58 */       return clazz.getDeclaredConstructor(new Class[0]).newInstance(new Object[0]);
> /* 59 */     } catch (Exception e) {
> /* 60 */       logger.debug("Failed to create MKL instance: ", e);
> /*    */ 
> /*    */       
> /* 63 */       return null;
> /*    */     } 
> /*    */   }
> /*    */   
> /*    */   int gesv(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, int paramInt3, int[] paramArrayOfint, double[] paramArrayOfdouble2, int paramInt4);
> /*    */   
> /*    */   int gesv(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, int paramInt3, IntBuffer paramIntBuffer, DoubleBuffer paramDoubleBuffer2, int paramInt4);
> /*    */   
> /*    */   int gesv(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, DoublePointer paramDoublePointer1, int paramInt3, IntPointer paramIntPointer, DoublePointer paramDoublePointer2, int paramInt4);
> /*    */   
> /*    */   int gesv(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, int paramInt3, int[] paramArrayOfint, float[] paramArrayOffloat2, int paramInt4);
> /*    */   
> /*    */   int gesv(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, int paramInt3, IntBuffer paramIntBuffer, FloatBuffer paramFloatBuffer2, int paramInt4);
> /*    */   
> /*    */   int sysv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, int paramInt3, int[] paramArrayOfint, double[] paramArrayOfdouble2, int paramInt4);
> /*    */   
> /*    */   int sysv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, int paramInt3, IntBuffer paramIntBuffer, DoubleBuffer paramDoubleBuffer2, int paramInt4);
> /*    */   
> /*    */   int sysv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, DoublePointer paramDoublePointer1, int paramInt3, IntPointer paramIntPointer, DoublePointer paramDoublePointer2, int paramInt4);
> /*    */   
> /*    */   int sysv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, int paramInt3, int[] paramArrayOfint, float[] paramArrayOffloat2, int paramInt4);
> /*    */   
> /*    */   int sysv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, int paramInt3, IntBuffer paramIntBuffer, FloatBuffer paramFloatBuffer2, int paramInt4);
> /*    */   
> /*    */   int spsv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, int[] paramArrayOfint, double[] paramArrayOfdouble2, int paramInt3);
> /*    */   
> /*    */   int spsv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, IntBuffer paramIntBuffer, DoubleBuffer paramDoubleBuffer2, int paramInt3);
> /*    */   
> /*    */   int spsv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, int[] paramArrayOfint, float[] paramArrayOffloat2, int paramInt3);
> /*    */   
> /*    */   int spsv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, IntBuffer paramIntBuffer, FloatBuffer paramFloatBuffer2, int paramInt3);
> /*    */   
> /*    */   int posv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, int paramInt3, double[] paramArrayOfdouble2, int paramInt4);
> /*    */   
> /*    */   int posv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, int paramInt3, DoubleBuffer paramDoubleBuffer2, int paramInt4);
> /*    */   
> /*    */   int posv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, int paramInt3, float[] paramArrayOffloat2, int paramInt4);
> /*    */   
> /*    */   int posv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, int paramInt3, FloatBuffer paramFloatBuffer2, int paramInt4);
> /*    */   
> /*    */   int ppsv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, double[] paramArrayOfdouble2, int paramInt3);
> /*    */   
> /*    */   int ppsv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, DoubleBuffer paramDoubleBuffer2, int paramInt3);
> /*    */   
> /*    */   int ppsv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, float[] paramArrayOffloat2, int paramInt3);
> /*    */   
> /*    */   int ppsv(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, FloatBuffer paramFloatBuffer2, int paramInt3);
> /*    */   
> /*    */   int gbsv(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, double[] paramArrayOfdouble1, int paramInt5, int[] paramArrayOfint, double[] paramArrayOfdouble2, int paramInt6);
> /*    */   
> /*    */   int gbsv(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, DoubleBuffer paramDoubleBuffer1, int paramInt5, IntBuffer paramIntBuffer, DoubleBuffer paramDoubleBuffer2, int paramInt6);
> /*    */   
> /*    */   int gbsv(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, float[] paramArrayOffloat1, int paramInt5, int[] paramArrayOfint, float[] paramArrayOffloat2, int paramInt6);
> /*    */   
> /*    */   int gbsv(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, FloatBuffer paramFloatBuffer1, int paramInt5, IntBuffer paramIntBuffer, FloatBuffer paramFloatBuffer2, int paramInt6);
> /*    */   
> /*    */   int gels(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, double[] paramArrayOfdouble1, int paramInt4, double[] paramArrayOfdouble2, int paramInt5);
> /*    */   
> /*    */   int gels(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, DoubleBuffer paramDoubleBuffer1, int paramInt4, DoubleBuffer paramDoubleBuffer2, int paramInt5);
> /*    */   
> /*    */   int gels(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOffloat1, int paramInt4, float[] paramArrayOffloat2, int paramInt5);
> /*    */   
> /*    */   int gels(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer1, int paramInt4, FloatBuffer paramFloatBuffer2, int paramInt5);
> /*    */   
> /*    */   int gelsy(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, double[] paramArrayOfdouble1, int paramInt4, double[] paramArrayOfdouble2, int paramInt5, int[] paramArrayOfint1, double paramDouble, int[] paramArrayOfint2);
> /*    */   
> /*    */   int gelsy(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, DoubleBuffer paramDoubleBuffer1, int paramInt4, DoubleBuffer paramDoubleBuffer2, int paramInt5, IntBuffer paramIntBuffer1, double paramDouble, IntBuffer paramIntBuffer2);
> /*    */   
> /*    */   int gelsy(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOffloat1, int paramInt4, float[] paramArrayOffloat2, int paramInt5, int[] paramArrayOfint1, float paramFloat, int[] paramArrayOfint2);
> /*    */   
> /*    */   int gelsy(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer1, int paramInt4, FloatBuffer paramFloatBuffer2, int paramInt5, IntBuffer paramIntBuffer1, float paramFloat, IntBuffer paramIntBuffer2);
> /*    */   
> /*    */   int gelss(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, double[] paramArrayOfdouble1, int paramInt4, double[] paramArrayOfdouble2, int paramInt5, double[] paramArrayOfdouble3, double paramDouble, int[] paramArrayOfint);
> /*    */   
> /*    */   int gelss(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, DoubleBuffer paramDoubleBuffer1, int paramInt4, DoubleBuffer paramDoubleBuffer2, int paramInt5, DoubleBuffer paramDoubleBuffer3, double paramDouble, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int gelss(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOffloat1, int paramInt4, float[] paramArrayOffloat2, int paramInt5, float[] paramArrayOffloat3, float paramFloat, int[] paramArrayOfint);
> /*    */   
> /*    */   int gelss(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer1, int paramInt4, FloatBuffer paramFloatBuffer2, int paramInt5, FloatBuffer paramFloatBuffer3, float paramFloat, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int gelsd(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, double[] paramArrayOfdouble1, int paramInt4, double[] paramArrayOfdouble2, int paramInt5, double[] paramArrayOfdouble3, double paramDouble, int[] paramArrayOfint);
> /*    */   
> /*    */   int gelsd(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, DoubleBuffer paramDoubleBuffer1, int paramInt4, DoubleBuffer paramDoubleBuffer2, int paramInt5, DoubleBuffer paramDoubleBuffer3, double paramDouble, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int gelsd(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOffloat1, int paramInt4, float[] paramArrayOffloat2, int paramInt5, float[] paramArrayOffloat3, float paramFloat, int[] paramArrayOfint);
> /*    */   
> /*    */   int gelsd(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer1, int paramInt4, FloatBuffer paramFloatBuffer2, int paramInt5, FloatBuffer paramFloatBuffer3, float paramFloat, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int gglse(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, double[] paramArrayOfdouble1, int paramInt4, double[] paramArrayOfdouble2, int paramInt5, double[] paramArrayOfdouble3, double[] paramArrayOfdouble4, double[] paramArrayOfdouble5);
> /*    */   
> /*    */   int gglse(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, DoubleBuffer paramDoubleBuffer1, int paramInt4, DoubleBuffer paramDoubleBuffer2, int paramInt5, DoubleBuffer paramDoubleBuffer3, DoubleBuffer paramDoubleBuffer4, DoubleBuffer paramDoubleBuffer5);
> /*    */   
> /*    */   int gglse(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOffloat1, int paramInt4, float[] paramArrayOffloat2, int paramInt5, float[] paramArrayOffloat3, float[] paramArrayOffloat4, float[] paramArrayOffloat5);
> /*    */   
> /*    */   int gglse(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer1, int paramInt4, FloatBuffer paramFloatBuffer2, int paramInt5, FloatBuffer paramFloatBuffer3, FloatBuffer paramFloatBuffer4, FloatBuffer paramFloatBuffer5);
> /*    */   
> /*    */   int ggglm(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, double[] paramArrayOfdouble1, int paramInt4, double[] paramArrayOfdouble2, int paramInt5, double[] paramArrayOfdouble3, double[] paramArrayOfdouble4, double[] paramArrayOfdouble5);
> /*    */   
> /*    */   int ggglm(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, DoubleBuffer paramDoubleBuffer1, int paramInt4, DoubleBuffer paramDoubleBuffer2, int paramInt5, DoubleBuffer paramDoubleBuffer3, DoubleBuffer paramDoubleBuffer4, DoubleBuffer paramDoubleBuffer5);
> /*    */   
> /*    */   int ggglm(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOffloat1, int paramInt4, float[] paramArrayOffloat2, int paramInt5, float[] paramArrayOffloat3, float[] paramArrayOffloat4, float[] paramArrayOffloat5);
> /*    */   
> /*    */   int ggglm(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer1, int paramInt4, FloatBuffer paramFloatBuffer2, int paramInt5, FloatBuffer paramFloatBuffer3, FloatBuffer paramFloatBuffer4, FloatBuffer paramFloatBuffer5);
> /*    */   
> /*    */   int geev(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified1, EVDJobModified paramEVDJobModified2, int paramInt1, double[] paramArrayOfdouble1, int paramInt2, double[] paramArrayOfdouble2, double[] paramArrayOfdouble3, double[] paramArrayOfdouble4, int paramInt3, double[] paramArrayOfdouble5, int paramInt4);
> /*    */   
> /*    */   int geev(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified1, EVDJobModified paramEVDJobModified2, int paramInt1, DoubleBuffer paramDoubleBuffer1, int paramInt2, DoubleBuffer paramDoubleBuffer2, DoubleBuffer paramDoubleBuffer3, DoubleBuffer paramDoubleBuffer4, int paramInt3, DoubleBuffer paramDoubleBuffer5, int paramInt4);
> /*    */   
> /*    */   int geev(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified1, EVDJobModified paramEVDJobModified2, int paramInt1, DoublePointer paramDoublePointer1, int paramInt2, DoublePointer paramDoublePointer2, DoublePointer paramDoublePointer3, DoublePointer paramDoublePointer4, int paramInt3, DoublePointer paramDoublePointer5, int paramInt4);
> /*    */   
> /*    */   int geev(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified1, EVDJobModified paramEVDJobModified2, int paramInt1, float[] paramArrayOffloat1, int paramInt2, float[] paramArrayOffloat2, float[] paramArrayOffloat3, float[] paramArrayOffloat4, int paramInt3, float[] paramArrayOffloat5, int paramInt4);
> /*    */   
> /*    */   int geev(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified1, EVDJobModified paramEVDJobModified2, int paramInt1, FloatBuffer paramFloatBuffer1, int paramInt2, FloatBuffer paramFloatBuffer2, FloatBuffer paramFloatBuffer3, FloatBuffer paramFloatBuffer4, int paramInt3, FloatBuffer paramFloatBuffer5, int paramInt4);
> /*    */   
> /*    */   int syev(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, UPLOModified paramUPLOModified, int paramInt1, double[] paramArrayOfdouble1, int paramInt2, double[] paramArrayOfdouble2);
> /*    */   
> /*    */   int syev(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, UPLOModified paramUPLOModified, int paramInt1, DoubleBuffer paramDoubleBuffer1, int paramInt2, DoubleBuffer paramDoubleBuffer2);
> /*    */   
> /*    */   int syev(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, UPLOModified paramUPLOModified, int paramInt1, float[] paramArrayOffloat1, int paramInt2, float[] paramArrayOffloat2);
> /*    */   
> /*    */   int syev(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, UPLOModified paramUPLOModified, int paramInt1, FloatBuffer paramFloatBuffer1, int paramInt2, FloatBuffer paramFloatBuffer2);
> /*    */   
> /*    */   int syevd(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, UPLOModified paramUPLOModified, int paramInt1, double[] paramArrayOfdouble1, int paramInt2, double[] paramArrayOfdouble2);
> /*    */   
> /*    */   int syevd(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, UPLOModified paramUPLOModified, int paramInt1, DoubleBuffer paramDoubleBuffer1, int paramInt2, DoubleBuffer paramDoubleBuffer2);
> /*    */   
> /*    */   int syevd(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, UPLOModified paramUPLOModified, int paramInt1, DoublePointer paramDoublePointer1, int paramInt2, DoublePointer paramDoublePointer2);
> /*    */   
> /*    */   int syevd(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, UPLOModified paramUPLOModified, int paramInt1, float[] paramArrayOffloat1, int paramInt2, float[] paramArrayOffloat2);
> /*    */   
> /*    */   int syevd(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, UPLOModified paramUPLOModified, int paramInt1, FloatBuffer paramFloatBuffer1, int paramInt2, FloatBuffer paramFloatBuffer2);
> /*    */   
> /*    */   int syevr(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, EigenRangeModified paramEigenRangeModified, UPLOModified paramUPLOModified, int paramInt1, double[] paramArrayOfdouble1, int paramInt2, double paramDouble1, double paramDouble2, int paramInt3, int paramInt4, double paramDouble3, int[] paramArrayOfint1, double[] paramArrayOfdouble2, double[] paramArrayOfdouble3, int paramInt5, int[] paramArrayOfint2);
> /*    */   
> /*    */   int syevr(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, EigenRangeModified paramEigenRangeModified, UPLOModified paramUPLOModified, int paramInt1, DoubleBuffer paramDoubleBuffer1, int paramInt2, double paramDouble1, double paramDouble2, int paramInt3, int paramInt4, double paramDouble3, IntBuffer paramIntBuffer1, DoubleBuffer paramDoubleBuffer2, DoubleBuffer paramDoubleBuffer3, int paramInt5, IntBuffer paramIntBuffer2);
> /*    */   
> /*    */   int syevr(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, EigenRangeModified paramEigenRangeModified, UPLOModified paramUPLOModified, int paramInt1, float[] paramArrayOffloat1, int paramInt2, float paramFloat1, float paramFloat2, int paramInt3, int paramInt4, float paramFloat3, int[] paramArrayOfint1, float[] paramArrayOffloat2, float[] paramArrayOffloat3, int paramInt5, int[] paramArrayOfint2);
> /*    */   
> /*    */   int syevr(LayoutModified paramLayoutModified, EVDJobModified paramEVDJobModified, EigenRangeModified paramEigenRangeModified, UPLOModified paramUPLOModified, int paramInt1, FloatBuffer paramFloatBuffer1, int paramInt2, float paramFloat1, float paramFloat2, int paramInt3, int paramInt4, float paramFloat3, IntBuffer paramIntBuffer1, FloatBuffer paramFloatBuffer2, FloatBuffer paramFloatBuffer3, int paramInt5, IntBuffer paramIntBuffer2);
> /*    */   
> /*    */   int gesvd(LayoutModified paramLayoutModified, SVDJobModified paramSVDJobModified1, SVDJobModified paramSVDJobModified2, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, int paramInt3, double[] paramArrayOfdouble2, double[] paramArrayOfdouble3, int paramInt4, double[] paramArrayOfdouble4, int paramInt5, double[] paramArrayOfdouble5);
> /*    */   
> /*    */   int gesvd(LayoutModified paramLayoutModified, SVDJobModified paramSVDJobModified1, SVDJobModified paramSVDJobModified2, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, int paramInt3, DoubleBuffer paramDoubleBuffer2, DoubleBuffer paramDoubleBuffer3, int paramInt4, DoubleBuffer paramDoubleBuffer4, int paramInt5, DoubleBuffer paramDoubleBuffer5);
> /*    */   
> /*    */   int gesvd(LayoutModified paramLayoutModified, SVDJobModified paramSVDJobModified1, SVDJobModified paramSVDJobModified2, int paramInt1, int paramInt2, float[] paramArrayOffloat1, int paramInt3, float[] paramArrayOffloat2, float[] paramArrayOffloat3, int paramInt4, float[] paramArrayOffloat4, int paramInt5, float[] paramArrayOffloat5);
> /*    */   
> /*    */   int gesvd(LayoutModified paramLayoutModified, SVDJobModified paramSVDJobModified1, SVDJobModified paramSVDJobModified2, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, int paramInt3, FloatBuffer paramFloatBuffer2, FloatBuffer paramFloatBuffer3, int paramInt4, FloatBuffer paramFloatBuffer4, int paramInt5, FloatBuffer paramFloatBuffer5);
> /*    */   
> /*    */   int gesdd(LayoutModified paramLayoutModified, SVDJobModified paramSVDJobModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, int paramInt3, double[] paramArrayOfdouble2, double[] paramArrayOfdouble3, int paramInt4, double[] paramArrayOfdouble4, int paramInt5);
> /*    */   
> /*    */   int gesdd(LayoutModified paramLayoutModified, SVDJobModified paramSVDJobModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, int paramInt3, DoubleBuffer paramDoubleBuffer2, DoubleBuffer paramDoubleBuffer3, int paramInt4, DoubleBuffer paramDoubleBuffer4, int paramInt5);
> /*    */   
> /*    */   int gesdd(LayoutModified paramLayoutModified, SVDJobModified paramSVDJobModified, int paramInt1, int paramInt2, DoublePointer paramDoublePointer1, int paramInt3, DoublePointer paramDoublePointer2, DoublePointer paramDoublePointer3, int paramInt4, DoublePointer paramDoublePointer4, int paramInt5);
> /*    */   
> /*    */   int gesdd(LayoutModified paramLayoutModified, SVDJobModified paramSVDJobModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, int paramInt3, float[] paramArrayOffloat2, float[] paramArrayOffloat3, int paramInt4, float[] paramArrayOffloat4, int paramInt5);
> /*    */   
> /*    */   int gesdd(LayoutModified paramLayoutModified, SVDJobModified paramSVDJobModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, int paramInt3, FloatBuffer paramFloatBuffer2, FloatBuffer paramFloatBuffer3, int paramInt4, FloatBuffer paramFloatBuffer4, int paramInt5);
> /*    */   
> /*    */   int getrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble, int paramInt3, int[] paramArrayOfint);
> /*    */   
> /*    */   int getrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer, int paramInt3, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int getrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, DoublePointer paramDoublePointer, int paramInt3, IntPointer paramIntPointer);
> /*    */   
> /*    */   int getrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, float[] paramArrayOffloat, int paramInt3, int[] paramArrayOfint);
> /*    */   
> /*    */   int getrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer, int paramInt3, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int getrf2(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble, int paramInt3, int[] paramArrayOfint);
> /*    */   
> /*    */   int getrf2(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer, int paramInt3, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int getrf2(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, float[] paramArrayOffloat, int paramInt3, int[] paramArrayOfint);
> /*    */   
> /*    */   int getrf2(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer, int paramInt3, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int gbtrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, double[] paramArrayOfdouble, int paramInt5, int[] paramArrayOfint);
> /*    */   
> /*    */   int gbtrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, DoubleBuffer paramDoubleBuffer, int paramInt5, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int gbtrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, float[] paramArrayOffloat, int paramInt5, int[] paramArrayOfint);
> /*    */   
> /*    */   int gbtrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, FloatBuffer paramFloatBuffer, int paramInt5, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int sptrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt, double[] paramArrayOfdouble, int[] paramArrayOfint);
> /*    */   
> /*    */   int sptrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt, DoubleBuffer paramDoubleBuffer, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int sptrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt, float[] paramArrayOffloat, int[] paramArrayOfint);
> /*    */   
> /*    */   int sptrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt, FloatBuffer paramFloatBuffer, IntBuffer paramIntBuffer);
> /*    */   
> /*    */   int getrs(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, int paramInt3, int[] paramArrayOfint, double[] paramArrayOfdouble2, int paramInt4);
> /*    */   
> /*    */   int getrs(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, int paramInt3, IntBuffer paramIntBuffer, DoubleBuffer paramDoubleBuffer2, int paramInt4);
> /*    */   
> /*    */   int getrs(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, DoublePointer paramDoublePointer1, int paramInt3, IntPointer paramIntPointer, DoublePointer paramDoublePointer2, int paramInt4);
> /*    */   
> /*    */   int getrs(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, int paramInt3, int[] paramArrayOfint, float[] paramArrayOffloat2, int paramInt4);
> /*    */   
> /*    */   int getrs(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, int paramInt3, IntBuffer paramIntBuffer, FloatBuffer paramFloatBuffer2, int paramInt4);
> /*    */   
> /*    */   int gbtrs(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, double[] paramArrayOfdouble1, int paramInt5, int[] paramArrayOfint, double[] paramArrayOfdouble2, int paramInt6);
> /*    */   
> /*    */   int gbtrs(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, DoubleBuffer paramDoubleBuffer1, int paramInt5, IntBuffer paramIntBuffer, DoubleBuffer paramDoubleBuffer2, int paramInt6);
> /*    */   
> /*    */   int gbtrs(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, float[] paramArrayOffloat1, int paramInt5, int[] paramArrayOfint, float[] paramArrayOffloat2, int paramInt6);
> /*    */   
> /*    */   int gbtrs(LayoutModified paramLayoutModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, int paramInt4, FloatBuffer paramFloatBuffer1, int paramInt5, IntBuffer paramIntBuffer, FloatBuffer paramFloatBuffer2, int paramInt6);
> /*    */   
> /*    */   int sptrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, int[] paramArrayOfint, double[] paramArrayOfdouble2, int paramInt3);
> /*    */   
> /*    */   int sptrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, IntBuffer paramIntBuffer, DoubleBuffer paramDoubleBuffer2, int paramInt3);
> /*    */   
> /*    */   int sptrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, IntBuffer paramIntBuffer, FloatBuffer paramFloatBuffer2, int paramInt3);
> /*    */   
> /*    */   int sptrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, int[] paramArrayOfint, float[] paramArrayOffloat2, int paramInt3);
> /*    */   
> /*    */   int potrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double[] paramArrayOfdouble, int paramInt2);
> /*    */   
> /*    */   int potrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, DoubleBuffer paramDoubleBuffer, int paramInt2);
> /*    */   
> /*    */   int potrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, DoublePointer paramDoublePointer, int paramInt2);
> /*    */   
> /*    */   int potrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, float[] paramArrayOffloat, int paramInt2);
> /*    */   
> /*    */   int potrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, FloatBuffer paramFloatBuffer, int paramInt2);
> /*    */   
> /*    */   int potrf2(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, double[] paramArrayOfdouble, int paramInt2);
> /*    */   
> /*    */   int potrf2(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, DoubleBuffer paramDoubleBuffer, int paramInt2);
> /*    */   
> /*    */   int potrf2(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, float[] paramArrayOffloat, int paramInt2);
> /*    */   
> /*    */   int potrf2(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, FloatBuffer paramFloatBuffer, int paramInt2);
> /*    */   
> /*    */   int pbtrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble, int paramInt3);
> /*    */   
> /*    */   int pbtrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer, int paramInt3);
> /*    */   
> /*    */   int pbtrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float[] paramArrayOffloat, int paramInt3);
> /*    */   
> /*    */   int pbtrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer, int paramInt3);
> /*    */   
> /*    */   int pptrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt, double[] paramArrayOfdouble);
> /*    */   
> /*    */   int pptrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt, DoubleBuffer paramDoubleBuffer);
> /*    */   
> /*    */   int pptrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt, float[] paramArrayOffloat);
> /*    */   
> /*    */   int pptrf(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt, FloatBuffer paramFloatBuffer);
> /*    */   
> /*    */   int potrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, int paramInt3, double[] paramArrayOfdouble2, int paramInt4);
> /*    */   
> /*    */   int potrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, int paramInt3, DoubleBuffer paramDoubleBuffer2, int paramInt4);
> /*    */   
> /*    */   int potrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, DoublePointer paramDoublePointer1, int paramInt3, DoublePointer paramDoublePointer2, int paramInt4);
> /*    */   
> /*    */   int potrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, int paramInt3, float[] paramArrayOffloat2, int paramInt4);
> /*    */   
> /*    */   int potrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, int paramInt3, FloatBuffer paramFloatBuffer2, int paramInt4);
> /*    */   
> /*    */   int pbtrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, int paramInt3, double[] paramArrayOfdouble1, int paramInt4, double[] paramArrayOfdouble2, int paramInt5);
> /*    */   
> /*    */   int pbtrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, int paramInt3, DoubleBuffer paramDoubleBuffer1, int paramInt4, DoubleBuffer paramDoubleBuffer2, int paramInt5);
> /*    */   
> /*    */   int pbtrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOffloat1, int paramInt4, float[] paramArrayOffloat2, int paramInt5);
> /*    */   
> /*    */   int pbtrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer1, int paramInt4, FloatBuffer paramFloatBuffer2, int paramInt5);
> /*    */   
> /*    */   int pptrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, double[] paramArrayOfdouble2, int paramInt3);
> /*    */   
> /*    */   int pptrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, DoubleBuffer paramDoubleBuffer2, int paramInt3);
> /*    */   
> /*    */   int pptrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, float[] paramArrayOffloat2, int paramInt3);
> /*    */   
> /*    */   int pptrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, FloatBuffer paramFloatBuffer2, int paramInt3);
> /*    */   
> /*    */   int geqrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, int paramInt3, double[] paramArrayOfdouble2);
> /*    */   
> /*    */   int geqrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, int paramInt3, DoubleBuffer paramDoubleBuffer2);
> /*    */   
> /*    */   int geqrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, DoublePointer paramDoublePointer1, int paramInt3, DoublePointer paramDoublePointer2);
> /*    */   
> /*    */   int geqrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, int paramInt3, float[] paramArrayOffloat2);
> /*    */   
> /*    */   int geqrf(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, int paramInt3, FloatBuffer paramFloatBuffer2);
> /*    */   
> /*    */   int ormqr(LayoutModified paramLayoutModified, SideModified paramSideModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, double[] paramArrayOfdouble1, int paramInt4, double[] paramArrayOfdouble2, double[] paramArrayOfdouble3, int paramInt5);
> /*    */   
> /*    */   int ormqr(LayoutModified paramLayoutModified, SideModified paramSideModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, DoubleBuffer paramDoubleBuffer1, int paramInt4, DoubleBuffer paramDoubleBuffer2, DoubleBuffer paramDoubleBuffer3, int paramInt5);
> /*    */   
> /*    */   int ormqr(LayoutModified paramLayoutModified, SideModified paramSideModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, DoublePointer paramDoublePointer1, int paramInt4, DoublePointer paramDoublePointer2, DoublePointer paramDoublePointer3, int paramInt5);
> /*    */   
> /*    */   int ormqr(LayoutModified paramLayoutModified, SideModified paramSideModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOffloat1, int paramInt4, float[] paramArrayOffloat2, float[] paramArrayOffloat3, int paramInt5);
> /*    */   
> /*    */   int ormqr(LayoutModified paramLayoutModified, SideModified paramSideModified, TransposeModified paramTransposeModified, int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer1, int paramInt4, FloatBuffer paramFloatBuffer2, FloatBuffer paramFloatBuffer3, int paramInt5);
> /*    */   
> /*    */   int orgqr(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, double[] paramArrayOfdouble1, int paramInt4, double[] paramArrayOfdouble2);
> /*    */   
> /*    */   int orgqr(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, DoubleBuffer paramDoubleBuffer1, int paramInt4, DoubleBuffer paramDoubleBuffer2);
> /*    */   
> /*    */   int orgqr(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, DoublePointer paramDoublePointer1, int paramInt4, DoublePointer paramDoublePointer2);
> /*    */   
> /*    */   int orgqr(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, float[] paramArrayOffloat1, int paramInt4, float[] paramArrayOffloat2);
> /*    */   
> /*    */   int orgqr(LayoutModified paramLayoutModified, int paramInt1, int paramInt2, int paramInt3, FloatBuffer paramFloatBuffer1, int paramInt4, FloatBuffer paramFloatBuffer2);
> /*    */   
> /*    */   int trtrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, int paramInt2, double[] paramArrayOfdouble1, int paramInt3, double[] paramArrayOfdouble2, int paramInt4);
> /*    */   
> /*    */   int trtrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, int paramInt2, DoubleBuffer paramDoubleBuffer1, int paramInt3, DoubleBuffer paramDoubleBuffer2, int paramInt4);
> /*    */   
> /*    */   int trtrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, int paramInt2, DoublePointer paramDoublePointer1, int paramInt3, DoublePointer paramDoublePointer2, int paramInt4);
> /*    */   
> /*    */   int trtrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, int paramInt2, float[] paramArrayOffloat1, int paramInt3, float[] paramArrayOffloat2, int paramInt4);
> /*    */   
> /*    */   int trtrs(LayoutModified paramLayoutModified, UPLOModified paramUPLOModified, TransposeModified paramTransposeModified, DiagModified paramDiagModified, int paramInt1, int paramInt2, FloatBuffer paramFloatBuffer1, int paramInt3, FloatBuffer paramFloatBuffer2, int paramInt4);
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/LAPACKModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/LayoutModified.java jd-gui/smileModified/LayoutModified.java
1c1,50
< package smileModified;
---
> /*    */ package smileModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public enum LayoutModified
> /*    */ {
> /* 22 */   ROW_MAJOR(
> /* 23 */     101),
> /* 24 */   COL_MAJOR(
> /* 25 */     102);
> /*    */ 
> /*    */   
> /*    */   private final int blas;
> /*    */   
> /*    */   private final int lapack;
> /*    */ 
> /*    */   
> /*    */   LayoutModified(int value) {
> /* 34 */     this.blas = value;
> /* 35 */     this.lapack = value;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public int blas() {
> /* 42 */     return this.blas;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public int lapack() {
> /* 48 */     return this.lapack;
> /*    */   }
> /*    */ }
3,5d51
< public enum LayoutModified {
<    ROW_MAJOR(101),
<    COL_MAJOR(102);
7,22c53,56
<    private final int blas;
<    private final int lapack;
< 
<    private LayoutModified(int value) {
<       this.blas = value;
<       this.lapack = value;
<    }
< 
<    public int blas() {
<       return this.blas;
<    }
< 
<    public int lapack() {
<       return this.lapack;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/LayoutModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/MathExModified.java jd-gui/smileModified/MathExModified.java
1,3292c1,4683
< package smileModified;
< 
< import java.lang.invoke.SerializedLambda;
< import java.lang.reflect.Array;
< import java.security.SecureRandom;
< import java.util.Arrays;
< import java.util.Iterator;
< import java.util.stream.IntStream;
< import java.util.stream.LongStream;
< import org.slf4j.Logger;
< import org.slf4j.LoggerFactory;
< 
< public class MathExModified {
<    private static final Logger logger = LoggerFactory.getLogger(MathExModified.class);
<    private static final MathExModified.FPU fpu = new MathExModified.FPU();
<    public static final double EPSILON;
<    public static final float FLOAT_EPSILON;
<    public static final int RADIX;
<    public static final int DIGITS;
<    public static final int FLOAT_DIGITS;
<    public static final int ROUND_STYLE;
<    public static final int MACHEP;
<    public static final int FLOAT_MACHEP;
<    public static final int NEGEP;
<    public static final int FLOAT_NEGEP;
<    private static final SecureRandom seedRNG;
<    private static final long[] DEFAULT_SEEDS;
<    private static int nextSeed;
<    private static final ThreadLocal<RandomModified> random;
<    private static final double LOG2;
< 
<    static {
<       EPSILON = fpu.EPSILON;
<       FLOAT_EPSILON = fpu.FLOAT_EPSILON;
<       RADIX = fpu.RADIX;
<       DIGITS = fpu.DIGITS;
<       FLOAT_DIGITS = fpu.FLOAT_DIGITS;
<       ROUND_STYLE = fpu.ROUND_STYLE;
<       MACHEP = fpu.MACHEP;
<       FLOAT_MACHEP = fpu.FLOAT_MACHEP;
<       NEGEP = fpu.NEGEP;
<       FLOAT_NEGEP = fpu.FLOAT_NEGEP;
<       seedRNG = new SecureRandom();
<       DEFAULT_SEEDS = new long[]{-4106602711295138952L, 7872020634117869514L, -1722503517109829138L, -3386820675908254116L, -1736715870046201019L, 3854590623768163340L, 4984519038350406438L, 831971085876758331L, 7131773007627236777L, -3609561992173376238L, -8759399602515137276L, 6192158663294695439L, -5656470009161653116L, -7984826214821970800L, -9113192788977418232L, -8979910231410580019L, -4619021025191354324L, -5082417586190057466L, -6554946940783144090L, -3610462176018822900L, 8959796931768911980L, -4251632352234989839L, 4922191169088134258L, -7282805902317830669L, 3869302430595840919L, 2517690626940415460L, 4056663221614950174L, 6429856319379397738L, 7298845553914383313L, 8179510284261677971L, 4282994537597585253L, 7300184601511783348L, 2596703774884172704L, 1089838915342514714L, 4323657609714862439L, 777826126579190548L, -1902743089794461140L, -2460431043688989882L, -3261708534465890932L, 4007861469505443778L, 8067600139237526646L, 5717273542173905853L, 2938568334013652889L, -2972203304739218305L, 6544901794394958069L, 7013723936758841449L, -4215598453287525312L, -1454689091401951913L, -5699280845313829011L, -9147984414924288540L, 5211986845656222459L, -1287642354429721659L, -1509334943513011620L, -9000043616528857326L, -2902817511399216571L, -742823064588229527L, -4937222449957498789L, -455679889440396397L, -6109470266907575296L, 5515435653880394376L, 5557224587324997029L, 8904139390487005840L, 6560726276686488510L, 6959949429287621625L, -6055733513105375650L, 5762016937143172332L, -9186652929482643329L, -1105816448554330895L, -8200377873547841359L, 9107473159863354619L, 3239950546973836199L, -8104429975176305012L, 3822949195131885242L, -5261390396129824777L, 9176101422921943895L, -5102541493993205418L, -1254710019595692814L, -6668066200971989826L, -2118519708589929546L, 5428466612765068681L, -6528627776941116598L, -5945449163896244174L, -3293290115918281076L, 6370347300411991230L, -7043881693953271167L, 8078993941165238212L, 6894961504641498099L, -8798276497942360228L, 2276271091333773917L, -7184141741385833013L, -4787502691178107481L, 1255068205351917608L, -8644146770023935609L, 5124094110137147339L, 4917075344795488880L, 3423242822219783102L, 1588924456880980404L, 8515495360312448868L, -5563691320675461929L, -2352238951654504517L, -7416919543420127888L, 631412478604690114L, 689144891258712875L, -9001615284848119152L, -6275065758899203088L, 8164387857252400515L, -4122060123604826739L, -2016541034210046261L, -7178335877193796678L, 3354303106860129181L, 5731595363486898779L, -2874315602397298018L, 5386746429707619069L, 9036622191596156315L, -7950190733284789459L, -5741691593792426169L, -8600462258998065159L, 5460142111961227035L, 276738899508534641L, 2358776514903881139L, -837649704945720257L, -3608906204977108245L, 2960825464614526243L, 7339056324843827739L, -5709958573878745135L, -5885403829221945248L, 6611935345917126768L, 2588814037559904539L};
<       nextSeed = -1;
<       random = new ThreadLocal<RandomModified>() {
<          protected RandomModified initialValue() {
<             synchronized(MathExModified.DEFAULT_SEEDS) {
<                if (MathExModified.nextSeed < 0) {
<                   MathExModified.nextSeed = 0;
<                   return new RandomModified();
<                } else if (MathExModified.nextSeed < MathExModified.DEFAULT_SEEDS.length) {
<                   long[] var10002 = MathExModified.DEFAULT_SEEDS;
<                   int var10003 = MathExModified.nextSeed;
<                   MathExModified.nextSeed = var10003 + 1;
<                   return new RandomModified(var10002[var10003]);
<                } else {
<                   return new RandomModified(MathExModified.generateSeed());
<                }
<             }
<          }
<       };
<       LOG2 = Math.log(2.0D);
<    }
< 
<    private MathExModified() {
<    }
< 
<    public static double log2(double x) {
<       return Math.log(x) / LOG2;
<    }
< 
<    public static double log(double x) {
<       double y = -690.7755D;
<       if (x > 1.0E-300D) {
<          y = Math.log(x);
<       }
< 
<       return y;
<    }
< 
<    public static double log1pe(double x) {
<       double y = x;
<       if (x <= 15.0D) {
<          y = Math.log1p(Math.exp(x));
<       }
< 
<       return y;
<    }
< 
<    public static boolean isInt(float x) {
<       return x == (float)Math.floor((double)x) && !Float.isInfinite(x);
<    }
< 
<    public static boolean isInt(double x) {
<       return x == Math.floor(x) && !Double.isInfinite(x);
<    }
< 
<    public static boolean equals(double a, double b) {
<       if (a == b) {
<          return true;
<       } else {
<          double absa = Math.abs(a);
<          double absb = Math.abs(b);
<          return Math.abs(a - b) <= Math.min(absa, absb) * 2.220446049250313E-16D;
<       }
<    }
< 
<    public static double sigmoid(double x) {
<       x = Math.max(-36.0D, Math.min(x, 36.0D));
<       return 1.0D / (1.0D + Math.exp(-x));
<    }
< 
<    public static double pow2(double x) {
<       return x * x;
<    }
< 
<    public static boolean isPower2(int x) {
<       return x > 0 && (x & x - 1) == 0;
<    }
< 
<    public static boolean isProbablePrime(long n, int k) {
<       return isProbablePrime(n, k, (RandomModified)random.get());
<    }
< 
<    private static boolean isProbablePrime(long n, int k, RandomModified rng) {
<       if (n > 1L && n != 4L) {
<          if (n <= 3L) {
<             return true;
<          } else {
<             int s = 0;
< 
<             long d;
<             for(d = n - 1L; d % 2L == 0L; d /= 2L) {
<                ++s;
<             }
< 
<             for(int i = 0; i < k; ++i) {
<                long a = 2L + rng.nextLong() % (n - 4L);
<                long x = power(a, d, n);
<                if (x != 1L && x != n - 1L) {
<                   int r;
<                   for(r = 0; r < s; ++r) {
<                      x = x * x % n;
<                      if (x == 1L) {
<                         return false;
<                      }
< 
<                      if (x == n - 1L) {
<                         break;
<                      }
<                   }
< 
<                   if (r == s) {
<                      return false;
<                   }
<                }
<             }
< 
<             return true;
<          }
<       } else {
<          return false;
<       }
<    }
< 
<    private static long power(long x, long y, long p) {
<       long res = 1L;
< 
<       for(x %= p; y > 0L; x = x * x % p) {
<          if ((y & 1L) == 1L) {
<             res = res * x % p;
<          }
< 
<          y >>= 1;
<       }
< 
<       return res;
<    }
< 
<    public static double round(double x, int decimal) {
<       return decimal < 0 ? (double)Math.round(x / Math.pow(10.0D, (double)(-decimal))) * Math.pow(10.0D, (double)(-decimal)) : (double)Math.round(x * Math.pow(10.0D, (double)decimal)) / Math.pow(10.0D, (double)decimal);
<    }
< 
<    public static double factorial(int n) {
<       if (n < 0) {
<          throw new IllegalArgumentException("n has to be non-negative.");
<       } else {
<          double f = 1.0D;
< 
<          for(int i = 2; i <= n; ++i) {
<             f *= (double)i;
<          }
< 
<          return f;
<       }
<    }
< 
<    public static double lfactorial(int n) {
<       if (n < 0) {
<          throw new IllegalArgumentException(String.format("n has to be non-negative: %d", n));
<       } else {
<          double f = 0.0D;
< 
<          for(int i = 2; i <= n; ++i) {
<             f += Math.log((double)i);
<          }
< 
<          return f;
<       }
<    }
< 
<    public static double choose(int n, int k) {
<       if (n >= 0 && k >= 0) {
<          return n < k ? 0.0D : Math.floor(0.5D + Math.exp(lchoose(n, k)));
<       } else {
<          throw new IllegalArgumentException(String.format("Invalid n = %d, k = %d", n, k));
<       }
<    }
< 
<    public static double lchoose(int n, int k) {
<       if (k >= 0 && k <= n) {
<          return lfactorial(n) - lfactorial(k) - lfactorial(n - k);
<       } else {
<          throw new IllegalArgumentException(String.format("Invalid n = %d, k = %d", n, k));
<       }
<    }
< 
<    public static long generateSeed() {
<       byte[] bytes = generateSeed(8);
<       long seed = 0L;
< 
<       for(int i = 0; i < 8; ++i) {
<          seed <<= 8;
<          seed |= (long)(bytes[i] & 255);
<       }
< 
<       return seed;
<    }
< 
<    public static byte[] generateSeed(int numBytes) {
<       synchronized(seedRNG) {
<          return seedRNG.generateSeed(numBytes);
<       }
<    }
< 
<    public static LongStream seeds() {
<       return LongStream.generate(MathExModified::generateSeed).sequential();
<    }
< 
<    public static void setSeed(long seed) {
<       ((RandomModified)random.get()).setSeed(seed);
<    }
< 
<    public static long probablePrime(long n, int k) {
<       return probablePrime(n, k, (RandomModified)random.get());
<    }
< 
<    private static long probablePrime(long n, int k, RandomModified rng) {
<       long seed = n + (long)rng.nextInt(899999963);
< 
<       for(int i = 0; i < 4096 && !isProbablePrime(seed, k, rng); ++i) {
<          seed = n + (long)rng.nextInt(899999963);
<       }
< 
<       return seed;
<    }
< 
<    public static int random(double[] prob) {
<       int[] ans = random(prob, 1);
<       return ans[0];
<    }
< 
<    public static int[] random(double[] prob, int n) {
<       double[] q = new double[prob.length];
< 
<       for(int i = 0; i < prob.length; ++i) {
<          q[i] = prob[i] * (double)prob.length;
<       }
< 
<       int[] a = new int[prob.length];
< 
<       for(int i = 0; i < prob.length; a[i] = i++) {
<       }
< 
<       int[] HL = new int[prob.length];
<       int head = 0;
<       int tail = prob.length - 1;
< 
<       int i;
<       for(i = 0; i < prob.length; ++i) {
<          if (q[i] >= 1.0D) {
<             HL[head++] = i;
<          } else {
<             HL[tail--] = i;
<          }
<       }
< 
<       int i;
<       while(head != 0 && tail != prob.length - 1) {
<          i = HL[tail + 1];
<          i = HL[head - 1];
<          a[i] = i;
<          q[i] += q[i] - 1.0D;
<          ++tail;
<          if (q[i] < 1.0D) {
<             HL[tail--] = i;
<             --head;
<          }
<       }
< 
<       int[] ans = new int[n];
< 
<       for(i = 0; i < n; ++i) {
<          double rU = random() * (double)prob.length;
<          int k = (int)rU;
<          rU -= (double)k;
<          if (rU < q[k]) {
<             ans[i] = k;
<          } else {
<             ans[i] = a[k];
<          }
<       }
< 
<       return ans;
<    }
< 
<    public static double random() {
<       return ((RandomModified)random.get()).nextDouble();
<    }
< 
<    public static double[] random(int n) {
<       double[] x = new double[n];
<       ((RandomModified)random.get()).nextDoubles(x);
<       return x;
<    }
< 
<    public static double random(double lo, double hi) {
<       return ((RandomModified)random.get()).nextDouble(lo, hi);
<    }
< 
<    public static double[] random(double lo, double hi, int n) {
<       double[] x = new double[n];
<       ((RandomModified)random.get()).nextDoubles(x, lo, hi);
<       return x;
<    }
< 
<    public static long randomLong() {
<       return ((RandomModified)random.get()).nextLong();
<    }
< 
<    public static int randomInt(int n) {
<       return ((RandomModified)random.get()).nextInt(n);
<    }
< 
<    public static int randomInt(int lo, int hi) {
<       int w = hi - lo;
<       return lo + ((RandomModified)random.get()).nextInt(w);
<    }
< 
<    public static int[] permutate(int n) {
<       return ((RandomModified)random.get()).permutate(n);
<    }
< 
<    public static void permutate(int[] x) {
<       ((RandomModified)random.get()).permutate(x);
<    }
< 
<    public static void permutate(float[] x) {
<       ((RandomModified)random.get()).permutate(x);
<    }
< 
<    public static void permutate(double[] x) {
<       ((RandomModified)random.get()).permutate(x);
<    }
< 
<    public static void permutate(Object[] x) {
<       ((RandomModified)random.get()).permutate(x);
<    }
< 
<    public static int softmax(double[] posteriori) {
<       return softmax(posteriori, posteriori.length);
<    }
< 
<    public static int softmax(double[] x, int k) {
<       int y = -1;
<       double max = Double.NEGATIVE_INFINITY;
< 
<       for(int i = 0; i < k; ++i) {
<          if (x[i] > max) {
<             max = x[i];
<             y = i;
<          }
<       }
< 
<       double Z = 0.0D;
< 
<       int i;
<       for(i = 0; i < k; ++i) {
<          double out = Math.exp(x[i] - max);
<          x[i] = out;
<          Z += out;
<       }
< 
<       for(i = 0; i < k; ++i) {
<          x[i] /= Z;
<       }
< 
<       return y;
<    }
< 
<    public static int[] c(int... x) {
<       return x;
<    }
< 
<    public static float[] c(float... x) {
<       return x;
<    }
< 
<    public static double[] c(double... x) {
<       return x;
<    }
< 
<    public static String[] c(String... x) {
<       return x;
<    }
< 
<    public static int[] c(int[]... list) {
<       int n = 0;
<       int[][] var5 = list;
<       int var4 = list.length;
< 
<       int[] y;
<       int pos;
<       for(pos = 0; pos < var4; ++pos) {
<          y = var5[pos];
<          n += y.length;
<       }
< 
<       y = new int[n];
<       pos = 0;
<       int[][] var7 = list;
<       int var6 = list.length;
< 
<       for(int var9 = 0; var9 < var6; ++var9) {
<          int[] x = var7[var9];
<          System.arraycopy(x, 0, y, pos, x.length);
<          pos += x.length;
<       }
< 
<       return y;
<    }
< 
<    public static float[] c(float[]... list) {
<       int n = 0;
<       float[][] var5 = list;
<       int var4 = list.length;
< 
<       float[] y;
<       int pos;
<       for(pos = 0; pos < var4; ++pos) {
<          y = var5[pos];
<          n += y.length;
<       }
< 
<       y = new float[n];
<       pos = 0;
<       float[][] var7 = list;
<       int var6 = list.length;
< 
<       for(int var9 = 0; var9 < var6; ++var9) {
<          float[] x = var7[var9];
<          System.arraycopy(x, 0, y, pos, x.length);
<          pos += x.length;
<       }
< 
<       return y;
<    }
< 
<    public static double[] c(double[]... list) {
<       int n = 0;
<       double[][] var5 = list;
<       int var4 = list.length;
< 
<       double[] y;
<       int pos;
<       for(pos = 0; pos < var4; ++pos) {
<          y = var5[pos];
<          n += y.length;
<       }
< 
<       y = new double[n];
<       pos = 0;
<       double[][] var7 = list;
<       int var6 = list.length;
< 
<       for(int var9 = 0; var9 < var6; ++var9) {
<          double[] x = var7[var9];
<          System.arraycopy(x, 0, y, pos, x.length);
<          pos += x.length;
<       }
< 
<       return y;
<    }
< 
<    public static String[] c(String[]... list) {
<       int n = 0;
<       String[][] var5 = list;
<       int var4 = list.length;
< 
<       String[] y;
<       int pos;
<       for(pos = 0; pos < var4; ++pos) {
<          y = var5[pos];
<          n += y.length;
<       }
< 
<       y = new String[n];
<       pos = 0;
<       String[][] var7 = list;
<       int var6 = list.length;
< 
<       for(int var9 = 0; var9 < var6; ++var9) {
<          String[] x = var7[var9];
<          System.arraycopy(x, 0, y, pos, x.length);
<          pos += x.length;
<       }
< 
<       return y;
<    }
< 
<    public static int[] cbind(int[]... x) {
<       return c(x);
<    }
< 
<    public static float[] cbind(float[]... x) {
<       return c(x);
<    }
< 
<    public static double[] cbind(double[]... x) {
<       return c(x);
<    }
< 
<    public static String[] cbind(String[]... x) {
<       return c(x);
<    }
< 
<    public static int[][] rbind(int[]... x) {
<       return x;
<    }
< 
<    public static float[][] rbind(float[]... x) {
<       return x;
<    }
< 
<    public static double[][] rbind(double[]... x) {
<       return x;
<    }
< 
<    public static String[][] rbind(String[]... x) {
<       return x;
<    }
< 
<    public static <E> E[] slice(E[] data, int[] index) {
<       int n = index.length;
<       Object[] x = (Object[])Array.newInstance(data.getClass().getComponentType(), n);
< 
<       for(int i = 0; i < n; ++i) {
<          x[i] = data[index[i]];
<       }
< 
<       return x;
<    }
< 
<    public static int[] slice(int[] data, int[] index) {
<       int n = index.length;
<       int[] x = new int[n];
< 
<       for(int i = 0; i < n; ++i) {
<          x[i] = data[index[i]];
<       }
< 
<       return x;
<    }
< 
<    public static float[] slice(float[] data, int[] index) {
<       int n = index.length;
<       float[] x = new float[n];
< 
<       for(int i = 0; i < n; ++i) {
<          x[i] = data[index[i]];
<       }
< 
<       return x;
<    }
< 
<    public static double[] slice(double[] data, int[] index) {
<       int n = index.length;
<       double[] x = new double[n];
< 
<       for(int i = 0; i < n; ++i) {
<          x[i] = data[index[i]];
<       }
< 
<       return x;
<    }
< 
<    public static boolean contains(double[][] polygon, double[] point) {
<       return contains(polygon, point[0], point[1]);
<    }
< 
<    public static boolean contains(double[][] polygon, double x, double y) {
<       if (polygon.length <= 2) {
<          return false;
<       } else {
<          int hits = 0;
<          int n = polygon.length;
<          double lastx = polygon[n - 1][0];
<          double lasty = polygon[n - 1][1];
< 
<          for(int i = 0; i < n; ++i) {
<             double curx = polygon[i][0];
<             double cury = polygon[i][1];
<             if (cury != lasty) {
<                label75: {
<                   double leftx;
<                   if (curx < lastx) {
<                      if (x >= lastx) {
<                         break label75;
<                      }
< 
<                      leftx = curx;
<                   } else {
<                      if (x >= curx) {
<                         break label75;
<                      }
< 
<                      leftx = lastx;
<                   }
< 
<                   double test1;
<                   double test2;
<                   if (cury < lasty) {
<                      if (y < cury || y >= lasty) {
<                         break label75;
<                      }
< 
<                      if (x < leftx) {
<                         ++hits;
<                         break label75;
<                      }
< 
<                      test1 = x - curx;
<                      test2 = y - cury;
<                   } else {
<                      if (y < lasty || y >= cury) {
<                         break label75;
<                      }
< 
<                      if (x < leftx) {
<                         ++hits;
<                         break label75;
<                      }
< 
<                      test1 = x - lastx;
<                      test2 = y - lasty;
<                   }
< 
<                   if (test1 < test2 / (lasty - cury) * (lastx - curx)) {
<                      ++hits;
<                   }
<                }
<             }
< 
<             lastx = curx;
<             lasty = cury;
<          }
< 
<          if ((hits & 1) != 0) {
<             return true;
<          } else {
<             return false;
<          }
<       }
<    }
< 
<    public static int[] omit(int[] a, int value) {
<       int n = 0;
<       int[] var6 = a;
<       int x = a.length;
< 
<       int x;
<       for(int var4 = 0; var4 < x; ++var4) {
<          x = var6[var4];
<          if (x != value) {
<             ++n;
<          }
<       }
< 
<       x = 0;
<       int[] b = new int[n];
<       int[] var8 = a;
<       int var7 = a.length;
< 
<       for(int var10 = 0; var10 < var7; ++var10) {
<          x = var8[var10];
<          if (x != value) {
<             b[x++] = x;
<          }
<       }
< 
<       return b;
<    }
< 
<    public static float[] omit(float[] a, float value) {
<       int n = 0;
<       float[] var6 = a;
<       int var5 = a.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          float x = var6[var4];
<          if (x != value) {
<             ++n;
<          }
<       }
< 
<       int i = 0;
<       float[] b = new float[n];
<       float[] var8 = a;
<       int var7 = a.length;
< 
<       for(int var12 = 0; var12 < var7; ++var12) {
<          float x = var8[var12];
<          if (x != value) {
<             b[i++] = x;
<          }
<       }
< 
<       return b;
<    }
< 
<    public static double[] omit(double[] a, double value) {
<       int n = 0;
<       double[] var8 = a;
<       int var7 = a.length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          double x = var8[var6];
<          if (x != value) {
<             ++n;
<          }
<       }
< 
<       int i = 0;
<       double[] b = new double[n];
<       double[] var10 = a;
<       int var9 = a.length;
< 
<       for(int var13 = 0; var13 < var9; ++var13) {
<          double x = var10[var13];
<          if (x != value) {
<             b[i++] = x;
<          }
<       }
< 
<       return b;
<    }
< 
<    public static float[] omitNaN(float[] a) {
<       int n = 0;
<       float[] var5 = a;
<       int var4 = a.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          float x = var5[var3];
<          if (!Float.isNaN(x)) {
<             ++n;
<          }
<       }
< 
<       int i = 0;
<       float[] b = new float[n];
<       float[] var7 = a;
<       int var6 = a.length;
< 
<       for(int var11 = 0; var11 < var6; ++var11) {
<          float x = var7[var11];
<          if (!Float.isNaN(x)) {
<             b[i++] = x;
<          }
<       }
< 
<       return b;
<    }
< 
<    public static double[] omitNaN(double[] a) {
<       int n = 0;
<       double[] var6 = a;
<       int var5 = a.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          double x = var6[var4];
<          if (!Double.isNaN(x)) {
<             ++n;
<          }
<       }
< 
<       int i = 0;
<       double[] b = new double[n];
<       double[] var8 = a;
<       int var7 = a.length;
< 
<       for(int var11 = 0; var11 < var7; ++var11) {
<          double x = var8[var11];
<          if (!Double.isNaN(x)) {
<             b[i++] = x;
<          }
<       }
< 
<       return b;
<    }
< 
<    public static void reverse(int[] a) {
<       int i = 0;
<       int j = a.length - 1;
< 
<       while(i < j) {
<          SortModified.swap(a, i++, j--);
<       }
< 
<    }
< 
<    public static void reverse(float[] a) {
<       int i = 0;
<       int j = a.length - 1;
< 
<       while(i < j) {
<          SortModified.swap(a, i++, j--);
<       }
< 
<    }
< 
<    public static void reverse(double[] a) {
<       int i = 0;
<       int j = a.length - 1;
< 
<       while(i < j) {
<          SortModified.swap(a, i++, j--);
<       }
< 
<    }
< 
<    public static <T> void reverse(T[] a) {
<       int i = 0;
<       int j = a.length - 1;
< 
<       while(i < j) {
<          SortModified.swap(a, i++, j--);
<       }
< 
<    }
< 
<    public static int mode(int[] a) {
<       Arrays.sort(a);
<       int mode = -1;
<       int count = 0;
<       int currentValue = a[0];
<       int currentCount = 1;
< 
<       for(int i = 1; i < a.length; ++i) {
<          if (a[i] != currentValue) {
<             if (currentCount > count) {
<                mode = currentValue;
<                count = currentCount;
<             }
< 
<             currentValue = a[i];
<             currentCount = 1;
<          } else {
<             ++currentCount;
<          }
<       }
< 
<       if (currentCount > count) {
<          mode = currentValue;
<       }
< 
<       return mode;
<    }
< 
<    public static int min(int a, int b, int c) {
<       return Math.min(Math.min(a, b), c);
<    }
< 
<    public static float min(float a, float b, float c) {
<       return Math.min(Math.min(a, b), c);
<    }
< 
<    public static double min(double a, double b, double c) {
<       return Math.min(Math.min(a, b), c);
<    }
< 
<    public static int min(int a, int b, int c, int d) {
<       return Math.min(Math.min(Math.min(a, b), c), d);
<    }
< 
<    public static float min(float a, float b, float c, float d) {
<       return Math.min(Math.min(Math.min(a, b), c), d);
<    }
< 
<    public static double min(double a, double b, double c, double d) {
<       return Math.min(Math.min(Math.min(a, b), c), d);
<    }
< 
<    public static int max(int a, int b, int c) {
<       return Math.max(Math.max(a, b), c);
<    }
< 
<    public static float max(float a, float b, float c) {
<       return Math.max(Math.max(a, b), c);
<    }
< 
<    public static double max(double a, double b, double c) {
<       return Math.max(Math.max(a, b), c);
<    }
< 
<    public static int max(int a, int b, int c, int d) {
<       return Math.max(Math.max(Math.max(a, b), c), d);
<    }
< 
<    public static float max(float a, float b, float c, float d) {
<       return Math.max(Math.max(Math.max(a, b), c), d);
<    }
< 
<    public static double max(double a, double b, double c, double d) {
<       return Math.max(Math.max(Math.max(a, b), c), d);
<    }
< 
<    public static int min(int[] x) {
<       int min = x[0];
<       int[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int n = var5[var3];
<          if (n < min) {
<             min = n;
<          }
<       }
< 
<       return min;
<    }
< 
<    public static float min(float[] x) {
<       float min = Float.POSITIVE_INFINITY;
<       float[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          float n = var5[var3];
<          if (n < min) {
<             min = n;
<          }
<       }
< 
<       return min;
<    }
< 
<    public static double min(double[] x) {
<       double min = Double.POSITIVE_INFINITY;
<       double[] var7 = x;
<       int var6 = x.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double n = var7[var5];
<          if (n < min) {
<             min = n;
<          }
<       }
< 
<       return min;
<    }
< 
<    public static int whichMin(int[] x) {
<       int min = x[0];
<       int which = 0;
< 
<       for(int i = 1; i < x.length; ++i) {
<          if (x[i] < min) {
<             min = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int whichMin(float[] x) {
<       float min = Float.POSITIVE_INFINITY;
<       int which = 0;
< 
<       for(int i = 0; i < x.length; ++i) {
<          if (x[i] < min) {
<             min = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int whichMin(double[] x) {
<       double min = Double.POSITIVE_INFINITY;
<       int which = 0;
< 
<       for(int i = 0; i < x.length; ++i) {
<          if (x[i] < min) {
<             min = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int max(int[] x) {
<       int max = x[0];
<       int[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int n = var5[var3];
<          if (n > max) {
<             max = n;
<          }
<       }
< 
<       return max;
<    }
< 
<    public static float max(float[] x) {
<       float max = Float.NEGATIVE_INFINITY;
<       float[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          float n = var5[var3];
<          if (n > max) {
<             max = n;
<          }
<       }
< 
<       return max;
<    }
< 
<    public static double max(double[] x) {
<       double max = Double.NEGATIVE_INFINITY;
<       double[] var7 = x;
<       int var6 = x.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double n = var7[var5];
<          if (n > max) {
<             max = n;
<          }
<       }
< 
<       return max;
<    }
< 
<    public static int whichMax(int[] x) {
<       int max = x[0];
<       int which = 0;
< 
<       for(int i = 1; i < x.length; ++i) {
<          if (x[i] > max) {
<             max = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int whichMax(float[] x) {
<       float max = Float.NEGATIVE_INFINITY;
<       int which = 0;
< 
<       for(int i = 0; i < x.length; ++i) {
<          if (x[i] > max) {
<             max = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int whichMax(double[] x) {
<       double max = Double.NEGATIVE_INFINITY;
<       int which = 0;
< 
<       for(int i = 0; i < x.length; ++i) {
<          if (x[i] > max) {
<             max = x[i];
<             which = i;
<          }
<       }
< 
<       return which;
<    }
< 
<    public static int min(int[][] matrix) {
<       int min = matrix[0][0];
<       int[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int[] x = var5[var3];
<          int[] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             int y = var9[var7];
<             if (min > y) {
<                min = y;
<             }
<          }
<       }
< 
<       return min;
<    }
< 
<    public static double min(double[][] matrix) {
<       double min = Double.POSITIVE_INFINITY;
<       double[][] var6 = matrix;
<       int var5 = matrix.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          double[] x = var6[var4];
<          double[] var11 = x;
<          int var10 = x.length;
< 
<          for(int var9 = 0; var9 < var10; ++var9) {
<             double y = var11[var9];
<             if (min > y) {
<                min = y;
<             }
<          }
<       }
< 
<       return min;
<    }
< 
<    public static int max(int[][] matrix) {
<       int max = matrix[0][0];
<       int[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int[] x = var5[var3];
<          int[] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             int y = var9[var7];
<             if (max < y) {
<                max = y;
<             }
<          }
<       }
< 
<       return max;
<    }
< 
<    public static double max(double[][] matrix) {
<       double max = Double.NEGATIVE_INFINITY;
<       double[][] var6 = matrix;
<       int var5 = matrix.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          double[] x = var6[var4];
<          double[] var11 = x;
<          int var10 = x.length;
< 
<          for(int var9 = 0; var9 < var10; ++var9) {
<             double y = var11[var9];
<             if (max < y) {
<                max = y;
<             }
<          }
<       }
< 
<       return max;
<    }
< 
<    public static IntPair whichMin(double[][] matrix) {
<       double min = Double.POSITIVE_INFINITY;
<       int whichRow = 0;
<       int whichCol = 0;
< 
<       for(int i = 0; i < matrix.length; ++i) {
<          for(int j = 0; j < matrix[i].length; ++j) {
<             if (matrix[i][j] < min) {
<                min = matrix[i][j];
<                whichRow = i;
<                whichCol = j;
<             }
<          }
<       }
< 
<       return new IntPair(whichRow, whichCol);
<    }
< 
<    public static IntPair whichMax(double[][] matrix) {
<       double max = Double.NEGATIVE_INFINITY;
<       int whichRow = 0;
<       int whichCol = 0;
< 
<       for(int i = 0; i < matrix.length; ++i) {
<          for(int j = 0; j < matrix[i].length; ++j) {
<             if (matrix[i][j] > max) {
<                max = matrix[i][j];
<                whichRow = i;
<                whichCol = j;
<             }
<          }
<       }
< 
<       return new IntPair(whichRow, whichCol);
<    }
< 
<    public static double[][] transpose(double[][] matrix) {
<       int m = matrix.length;
<       int n = matrix[0].length;
<       double[][] t = new double[n][m];
< 
<       for(int i = 0; i < m; ++i) {
<          for(int j = 0; j < n; ++j) {
<             t[j][i] = matrix[i][j];
<          }
<       }
< 
<       return t;
<    }
< 
<    public static int[] rowMin(int[][] matrix) {
<       int[] x = new int[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = min(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static int[] rowMax(int[][] matrix) {
<       int[] x = new int[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = max(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static long[] rowSums(int[][] matrix) {
<       long[] x = new long[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = sum(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static double[] rowMin(double[][] matrix) {
<       double[] x = new double[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = min(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static double[] rowMax(double[][] matrix) {
<       double[] x = new double[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = max(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static double[] rowSums(double[][] matrix) {
<       double[] x = new double[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = sum(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static double[] rowMeans(double[][] matrix) {
<       double[] x = new double[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = mean(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static double[] rowSds(double[][] matrix) {
<       double[] x = new double[matrix.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = sd(matrix[i]);
<       }
< 
<       return x;
<    }
< 
<    public static int[] colMin(int[][] matrix) {
<       int[] x = new int[matrix[0].length];
<       Arrays.fill(x, Integer.MAX_VALUE);
<       int[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int[] row = var5[var3];
< 
<          for(int j = 0; j < x.length; ++j) {
<             if (x[j] > row[j]) {
<                x[j] = row[j];
<             }
<          }
<       }
< 
<       return x;
<    }
< 
<    public static int[] colMax(int[][] matrix) {
<       int[] x = new int[matrix[0].length];
<       Arrays.fill(x, Integer.MIN_VALUE);
<       int[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int[] row = var5[var3];
< 
<          for(int j = 0; j < x.length; ++j) {
<             if (x[j] < row[j]) {
<                x[j] = row[j];
<             }
<          }
<       }
< 
<       return x;
<    }
< 
<    public static long[] colSums(int[][] matrix) {
<       long[] x = new long[matrix[0].length];
<       int[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int[] row = var5[var3];
< 
<          for(int j = 0; j < x.length; ++j) {
<             x[j] += (long)row[j];
<          }
<       }
< 
<       return x;
<    }
< 
<    public static double[] colMin(double[][] matrix) {
<       double[] x = new double[matrix[0].length];
<       Arrays.fill(x, Double.POSITIVE_INFINITY);
<       double[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          double[] row = var5[var3];
< 
<          for(int j = 0; j < x.length; ++j) {
<             if (x[j] > row[j]) {
<                x[j] = row[j];
<             }
<          }
<       }
< 
<       return x;
<    }
< 
<    public static double[] colMax(double[][] matrix) {
<       double[] x = new double[matrix[0].length];
<       Arrays.fill(x, Double.NEGATIVE_INFINITY);
<       double[][] var5 = matrix;
<       int var4 = matrix.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          double[] row = var5[var3];
< 
<          for(int j = 0; j < x.length; ++j) {
<             if (x[j] < row[j]) {
<                x[j] = row[j];
<             }
<          }
<       }
< 
<       return x;
<    }
< 
<    public static double[] colSums(double[][] matrix) {
<       double[] x = (double[])matrix[0].clone();
< 
<       for(int i = 1; i < matrix.length; ++i) {
<          for(int j = 0; j < x.length; ++j) {
<             x[j] += matrix[i][j];
<          }
<       }
< 
<       return x;
<    }
< 
<    public static double[] colMeans(double[][] matrix) {
<       double[] x = (double[])matrix[0].clone();
< 
<       for(int i = 1; i < matrix.length; ++i) {
<          for(int j = 0; j < x.length; ++j) {
<             x[j] += matrix[i][j];
<          }
<       }
< 
<       scale(1.0D / (double)matrix.length, x);
<       return x;
<    }
< 
<    public static double[] colSds(double[][] matrix) {
<       if (matrix.length < 2) {
<          throw new IllegalArgumentException("matrix length is less than 2.");
<       } else {
<          int p = matrix[0].length;
<          double[] sum = new double[p];
<          double[] sumsq = new double[p];
<          double[][] var7 = matrix;
<          int var6 = matrix.length;
< 
<          int i;
<          for(i = 0; i < var6; ++i) {
<             double[] row = var7[i];
< 
<             for(int i = 0; i < p; ++i) {
<                sum[i] += row[i];
<                sumsq[i] += row[i] * row[i];
<             }
<          }
< 
<          int n = matrix.length - 1;
< 
<          for(i = 0; i < p; ++i) {
<             sumsq[i] = Math.sqrt(sumsq[i] / (double)n - sum[i] / (double)matrix.length * (sum[i] / (double)n));
<          }
< 
<          return sumsq;
<       }
<    }
< 
<    public static int sum(byte[] x) {
<       int sum = 0;
<       byte[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          int n = var5[var3];
<          sum += n;
<       }
< 
<       return sum;
<    }
< 
<    public static long sum(int[] x) {
<       long sum = 0L;
<       int[] var6 = x;
<       int var5 = x.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          int n = var6[var4];
<          sum += (long)n;
<       }
< 
<       return (long)((int)sum);
<    }
< 
<    public static double sum(float[] x) {
<       double sum = 0.0D;
<       float[] var6 = x;
<       int var5 = x.length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          float n = var6[var4];
<          sum += (double)n;
<       }
< 
<       return sum;
<    }
< 
<    public static double sum(double[] x) {
<       double sum = 0.0D;
<       double[] var7 = x;
<       int var6 = x.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double n = var7[var5];
<          sum += n;
<       }
< 
<       return sum;
<    }
< 
<    public static int median(int[] x) {
<       return QuickSelectModified.median(x);
<    }
< 
<    public static float median(float[] x) {
<       return QuickSelectModified.median(x);
<    }
< 
<    public static double median(double[] x) {
<       return QuickSelectModified.median(x);
<    }
< 
<    public static <T extends Comparable<? super T>> T median(T[] x) {
<       return QuickSelectModified.median(x);
<    }
< 
<    public static int q1(int[] x) {
<       return QuickSelectModified.q1(x);
<    }
< 
<    public static float q1(float[] x) {
<       return QuickSelectModified.q1(x);
<    }
< 
<    public static double q1(double[] x) {
<       return QuickSelectModified.q1(x);
<    }
< 
<    public static <T extends Comparable<? super T>> T q1(T[] x) {
<       return QuickSelectModified.q1(x);
<    }
< 
<    public static int q3(int[] x) {
<       return QuickSelectModified.q3(x);
<    }
< 
<    public static float q3(float[] x) {
<       return QuickSelectModified.q3(x);
<    }
< 
<    public static double q3(double[] x) {
<       return QuickSelectModified.q3(x);
<    }
< 
<    public static <T extends Comparable<? super T>> T q3(T[] x) {
<       return QuickSelectModified.q3(x);
<    }
< 
<    public static double mean(int[] x) {
<       return (double)sum(x) / (double)x.length;
<    }
< 
<    public static double mean(float[] x) {
<       return sum(x) / (double)x.length;
<    }
< 
<    public static double mean(double[] x) {
<       return sum(x) / (double)x.length;
<    }
< 
<    public static double var(int[] x) {
<       if (x.length < 2) {
<          throw new IllegalArgumentException("Array length is less than 2.");
<       } else {
<          double sum = 0.0D;
<          double sumsq = 0.0D;
<          int[] var8 = x;
<          int var7 = x.length;
< 
<          int n;
<          for(int var6 = 0; var6 < var7; ++var6) {
<             n = var8[var6];
<             sum += (double)n;
<             sumsq += (double)(n * n);
<          }
< 
<          n = x.length - 1;
<          return sumsq / (double)n - sum / (double)x.length * (sum / (double)n);
<       }
<    }
< 
<    public static double var(float[] x) {
<       if (x.length < 2) {
<          throw new IllegalArgumentException("Array length is less than 2.");
<       } else {
<          double sum = 0.0D;
<          double sumsq = 0.0D;
<          float[] var8 = x;
<          int var7 = x.length;
< 
<          for(int var6 = 0; var6 < var7; ++var6) {
<             float xi = var8[var6];
<             sum += (double)xi;
<             sumsq += (double)(xi * xi);
<          }
< 
<          int n = x.length - 1;
<          return sumsq / (double)n - sum / (double)x.length * (sum / (double)n);
<       }
<    }
< 
<    public static double var(double[] x) {
<       if (x.length < 2) {
<          throw new IllegalArgumentException("Array length is less than 2.");
<       } else {
<          double sum = 0.0D;
<          double sumsq = 0.0D;
<          double[] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             double xi = var9[var7];
<             sum += xi;
<             sumsq += xi * xi;
<          }
< 
<          int n = x.length - 1;
<          return sumsq / (double)n - sum / (double)x.length * (sum / (double)n);
<       }
<    }
< 
<    public static double sd(int[] x) {
<       return Math.sqrt(var(x));
<    }
< 
<    public static double sd(float[] x) {
<       return Math.sqrt(var(x));
<    }
< 
<    public static double sd(double[] x) {
<       return Math.sqrt(var(x));
<    }
< 
<    public static double mad(int[] x) {
<       int m = median(x);
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = Math.abs(x[i] - m);
<       }
< 
<       return (double)median(x);
<    }
< 
<    public static double mad(float[] x) {
<       float m = median(x);
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = Math.abs(x[i] - m);
<       }
< 
<       return (double)median(x);
<    }
< 
<    public static double mad(double[] x) {
<       double m = median(x);
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] = Math.abs(x[i] - m);
<       }
< 
<       return median(x);
<    }
< 
<    public static double distance(int[] x, int[] y) {
<       return Math.sqrt(squaredDistance(x, y));
<    }
< 
<    public static double distance(float[] x, float[] y) {
<       return Math.sqrt(squaredDistance(x, y));
<    }
< 
<    public static double distance(double[] x, double[] y) {
<       return Math.sqrt(squaredDistance(x, y));
<    }
< 
<    public static double distance(SparseArrayModified x, SparseArrayModified y) {
<       return Math.sqrt(squaredDistance(x, y));
<    }
< 
<    public static double squaredDistance(int[] x, int[] y) {
<       double d = 0.0D;
<       int p1 = 0;
<       int p2 = 0;
< 
<       while(p1 < x.length && p2 < y.length) {
<          int i1 = x[p1];
<          int i2 = y[p2];
<          if (i1 == i2) {
<             ++p1;
<             ++p2;
<          } else if (i1 > i2) {
<             ++d;
<             ++p2;
<          } else {
<             ++d;
<             ++p1;
<          }
<       }
< 
<       d += (double)(x.length - p1);
<       d += (double)(y.length - p2);
<       return d;
<    }
< 
<    public static double squaredDistance(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          double sum;
<          double d1;
<          double d2;
<          switch(x.length) {
<          case 2:
<             sum = (double)x[0] - (double)y[0];
<             d1 = (double)x[1] - (double)y[1];
<             return sum * sum + d1 * d1;
<          case 3:
<             sum = (double)x[0] - (double)y[0];
<             d1 = (double)x[1] - (double)y[1];
<             d2 = (double)x[2] - (double)y[2];
<             return sum * sum + d1 * d1 + d2 * d2;
<          case 4:
<             sum = (double)x[0] - (double)y[0];
<             d1 = (double)x[1] - (double)y[1];
<             d2 = (double)x[2] - (double)y[2];
<             double d3 = (double)x[3] - (double)y[3];
<             return sum * sum + d1 * d1 + d2 * d2 + d3 * d3;
<          default:
<             sum = 0.0D;
< 
<             for(int i = 0; i < x.length; ++i) {
<                double d = (double)x[i] - (double)y[i];
<                sum += d * d;
<             }
< 
<             return sum;
<          }
<       }
<    }
< 
<    public static double squaredDistance(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          double sum;
<          double d1;
<          double d2;
<          switch(x.length) {
<          case 2:
<             sum = x[0] - y[0];
<             d1 = x[1] - y[1];
<             return sum * sum + d1 * d1;
<          case 3:
<             sum = x[0] - y[0];
<             d1 = x[1] - y[1];
<             d2 = x[2] - y[2];
<             return sum * sum + d1 * d1 + d2 * d2;
<          case 4:
<             sum = x[0] - y[0];
<             d1 = x[1] - y[1];
<             d2 = x[2] - y[2];
<             double d3 = x[3] - y[3];
<             return sum * sum + d1 * d1 + d2 * d2 + d3 * d3;
<          default:
<             sum = 0.0D;
< 
<             for(int i = 0; i < x.length; ++i) {
<                double d = x[i] - y[i];
<                sum += d * d;
<             }
< 
<             return sum;
<          }
<       }
<    }
< 
<    public static double squaredDistance(SparseArrayModified x, SparseArrayModified y) {
<       Iterator<SparseArrayModified.Entry> it1 = x.iterator();
<       Iterator<SparseArrayModified.Entry> it2 = y.iterator();
<       SparseArrayModified.Entry e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<       SparseArrayModified.Entry e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<       double sum = 0.0D;
< 
<       while(e1 != null && e2 != null) {
<          if (e1.i == e2.i) {
<             sum += pow2(e1.x - e2.x);
<             e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<             e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<          } else if (e1.i > e2.i) {
<             sum += pow2(e2.x);
<             e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<          } else {
<             sum += pow2(e1.x);
<             e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<          }
<       }
< 
<       double d;
<       while(it1.hasNext()) {
<          d = ((SparseArrayModified.Entry)it1.next()).x;
<          sum += d * d;
<       }
< 
<       while(it2.hasNext()) {
<          d = ((SparseArrayModified.Entry)it2.next()).x;
<          sum += d * d;
<       }
< 
<       return sum;
<    }
< 
<    public static double squaredDistanceWithMissingValues(double[] x, double[] y) {
<       int n = x.length;
<       int m = 0;
<       double dist = 0.0D;
< 
<       for(int i = 0; i < n; ++i) {
<          if (!Double.isNaN(x[i]) && !Double.isNaN(y[i])) {
<             ++m;
<             double d = x[i] - y[i];
<             dist += d * d;
<          }
<       }
< 
<       if (m == 0) {
<          dist = Double.MAX_VALUE;
<       } else {
<          dist = (double)n * dist / (double)m;
<       }
< 
<       return dist;
<    }
< 
<    public static MatrixModified pdist(int[][] x) {
<       return pdist(x, false);
<    }
< 
<    public static MatrixModified pdist(int[][] x, boolean squared) {
<       int n = x.length;
<       double[][] dist = new double[n][n];
<       pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
<       return MatrixModified.of(dist);
<    }
< 
<    public static MatrixModified pdist(float[][] x) {
<       return pdist(x, false);
<    }
< 
<    public static MatrixModified pdist(float[][] x, boolean squared) {
<       int n = x.length;
<       double[][] dist = new double[n][n];
<       pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
<       return MatrixModified.of(dist);
<    }
< 
<    public static MatrixModified pdist(double[][] x) {
<       return pdist(x, false);
<    }
< 
<    public static MatrixModified pdist(double[][] x, boolean squared) {
<       int n = x.length;
<       double[][] dist = new double[n][n];
<       pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
<       return MatrixModified.of(dist);
<    }
< 
<    public static MatrixModified pdist(SparseArrayModified[] x) {
<       return pdist(x, false);
<    }
< 
<    public static MatrixModified pdist(SparseArrayModified[] x, boolean squared) {
<       int n = x.length;
<       double[][] dist = new double[n][n];
<       pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
<       return MatrixModified.of(dist);
<    }
< 
<    public static <T> void pdist(T[] x, double[][] d, DistanceModified<T> distance) {
<       int n = x.length;
<       if (d[0].length < n) {
<          IntStream.range(0, n).parallel().forEach((i) -> {
<             T xi = x[i];
<             double[] di = d[i];
< 
<             for(int j = 0; j < i; ++j) {
<                di[j] = distance.d(xi, x[j]);
<             }
< 
<          });
<       } else {
<          IntStream.range(0, n).parallel().forEach((i) -> {
<             T xi = x[i];
<             double[] di = d[i];
< 
<             for(int j = 0; j < n; ++j) {
<                di[j] = distance.d(xi, x[j]);
<             }
< 
<          });
<       }
< 
<    }
< 
<    public static double entropy(double[] p) {
<       double h = 0.0D;
<       double[] var7 = p;
<       int var6 = p.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double pi = var7[var5];
<          if (pi > 0.0D) {
<             h -= pi * Math.log(pi);
<          }
<       }
< 
<       return h;
<    }
< 
<    public static double KullbackLeiblerDivergence(double[] p, double[] q) {
<       boolean intersection = false;
<       double kl = 0.0D;
< 
<       for(int i = 0; i < p.length; ++i) {
<          if (p[i] != 0.0D && q[i] != 0.0D) {
<             intersection = true;
<             kl += p[i] * Math.log(p[i] / q[i]);
<          }
<       }
< 
<       if (intersection) {
<          return kl;
<       } else {
<          return Double.POSITIVE_INFINITY;
<       }
<    }
< 
<    public static double KullbackLeiblerDivergence(SparseArrayModified p, SparseArrayModified q) {
<       if (p.isEmpty()) {
<          throw new IllegalArgumentException("p is empty.");
<       } else if (q.isEmpty()) {
<          throw new IllegalArgumentException("q is empty.");
<       } else {
<          Iterator<SparseArrayModified.Entry> pIter = p.iterator();
<          Iterator<SparseArrayModified.Entry> qIter = q.iterator();
<          SparseArrayModified.Entry a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<          SparseArrayModified.Entry b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
<          boolean intersection = false;
<          double kl = 0.0D;
< 
<          while(a != null && b != null) {
<             if (a.i < b.i) {
<                a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<             } else if (a.i > b.i) {
<                b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
<             } else {
<                intersection = true;
<                kl += a.x * Math.log(a.x / b.x);
<                a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<                b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
<             }
<          }
< 
<          return intersection ? kl : Double.POSITIVE_INFINITY;
<       }
<    }
< 
<    public static double KullbackLeiblerDivergence(double[] p, SparseArrayModified q) {
<       return KullbackLeiblerDivergence(q, p);
<    }
< 
<    public static double KullbackLeiblerDivergence(SparseArrayModified p, double[] q) {
<       if (p.isEmpty()) {
<          throw new IllegalArgumentException("p is empty.");
<       } else {
<          Iterator<SparseArrayModified.Entry> iter = p.iterator();
<          boolean intersection = false;
<          double kl = 0.0D;
< 
<          while(iter.hasNext()) {
<             SparseArrayModified.Entry b = (SparseArrayModified.Entry)iter.next();
<             int i = b.i;
<             if (q[i] > 0.0D) {
<                intersection = true;
<                kl += b.x * Math.log(b.x / q[i]);
<             }
<          }
< 
<          if (intersection) {
<             return kl;
<          } else {
<             return Double.POSITIVE_INFINITY;
<          }
<       }
<    }
< 
<    public static double JensenShannonDivergence(double[] p, double[] q) {
<       double[] m = new double[p.length];
< 
<       for(int i = 0; i < m.length; ++i) {
<          m[i] = (p[i] + q[i]) / 2.0D;
<       }
< 
<       return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2.0D;
<    }
< 
<    public static double JensenShannonDivergence(SparseArrayModified p, SparseArrayModified q) {
<       if (p.isEmpty()) {
<          throw new IllegalArgumentException("p is empty.");
<       } else if (q.isEmpty()) {
<          throw new IllegalArgumentException("q is empty.");
<       } else {
<          Iterator<SparseArrayModified.Entry> pIter = p.iterator();
<          Iterator<SparseArrayModified.Entry> qIter = q.iterator();
<          SparseArrayModified.Entry a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<          SparseArrayModified.Entry b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
<          double js = 0.0D;
< 
<          while(a != null && b != null) {
<             double mi;
<             if (a.i < b.i) {
<                mi = a.x / 2.0D;
<                js += a.x * Math.log(a.x / mi);
<                a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<             } else if (a.i > b.i) {
<                mi = b.x / 2.0D;
<                js += b.x * Math.log(b.x / mi);
<                b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
<             } else {
<                mi = (a.x + b.x) / 2.0D;
<                js += a.x * Math.log(a.x / mi) + b.x * Math.log(b.x / mi);
<                a = pIter.hasNext() ? (SparseArrayModified.Entry)pIter.next() : null;
<                b = qIter.hasNext() ? (SparseArrayModified.Entry)qIter.next() : null;
<             }
<          }
< 
<          return js / 2.0D;
<       }
<    }
< 
<    public static double JensenShannonDivergence(double[] p, SparseArrayModified q) {
<       return JensenShannonDivergence(q, p);
<    }
< 
<    public static double JensenShannonDivergence(SparseArrayModified p, double[] q) {
<       if (p.isEmpty()) {
<          throw new IllegalArgumentException("p is empty.");
<       } else {
<          Iterator<SparseArrayModified.Entry> iter = p.iterator();
<          double js = 0.0D;
< 
<          while(iter.hasNext()) {
<             SparseArrayModified.Entry b = (SparseArrayModified.Entry)iter.next();
<             int i = b.i;
<             double mi = (b.x + q[i]) / 2.0D;
<             js += b.x * Math.log(b.x / mi);
<             if (q[i] > 0.0D) {
<                js += q[i] * Math.log(q[i] / mi);
<             }
<          }
< 
<          return js / 2.0D;
<       }
<    }
< 
<    public static int dot(int[] x, int[] y) {
<       int sum = 0;
<       int p1 = 0;
<       int p2 = 0;
< 
<       while(p1 < x.length && p2 < y.length) {
<          int i1 = x[p1];
<          int i2 = y[p2];
<          if (i1 == i2) {
<             ++sum;
<             ++p1;
<             ++p2;
<          } else if (i1 > i2) {
<             ++p2;
<          } else {
<             ++p1;
<          }
<       }
< 
<       return sum;
<    }
< 
<    public static float dot(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else {
<          float sum = 0.0F;
< 
<          for(int i = 0; i < x.length; ++i) {
<             sum += x[i] * y[i];
<          }
< 
<          return sum;
<       }
<    }
< 
<    public static double dot(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else {
<          double sum = 0.0D;
< 
<          for(int i = 0; i < x.length; ++i) {
<             sum += x[i] * y[i];
<          }
< 
<          return sum;
<       }
<    }
< 
<    public static double dot(SparseArrayModified x, SparseArrayModified y) {
<       Iterator<SparseArrayModified.Entry> it1 = x.iterator();
<       Iterator<SparseArrayModified.Entry> it2 = y.iterator();
<       SparseArrayModified.Entry e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<       SparseArrayModified.Entry e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<       double sum = 0.0D;
< 
<       while(e1 != null && e2 != null) {
<          if (e1.i == e2.i) {
<             sum += e1.x * e2.x;
<             e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<             e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<          } else if (e1.i > e2.i) {
<             e2 = it2.hasNext() ? (SparseArrayModified.Entry)it2.next() : null;
<          } else {
<             e1 = it1.hasNext() ? (SparseArrayModified.Entry)it1.next() : null;
<          }
<       }
< 
<       return sum;
<    }
< 
<    public static MatrixModified pdot(int[][] x) {
<       int n = x.length;
<       MatrixModified matrix = new MatrixModified(n, n);
<       matrix.uplo(UPLOModified.LOWER);
<       IntStream.range(0, n).parallel().forEach((j) -> {
<          int[] xj = x[j];
< 
<          for(int i = 0; i < n; ++i) {
<             matrix.set(i, j, (double)dot(x[i], xj));
<          }
< 
<       });
<       return matrix;
<    }
< 
<    public static MatrixModified pdot(float[][] x) {
<       int n = x.length;
<       MatrixModified matrix = new MatrixModified(n, n);
<       matrix.uplo(UPLOModified.LOWER);
<       IntStream.range(0, n).parallel().forEach((j) -> {
<          float[] xj = x[j];
< 
<          for(int i = 0; i < n; ++i) {
<             matrix.set(i, j, (double)dot(x[i], xj));
<          }
< 
<       });
<       return matrix;
<    }
< 
<    public static MatrixModified pdot(double[][] x) {
<       int n = x.length;
<       MatrixModified matrix = new MatrixModified(n, n);
<       matrix.uplo(UPLOModified.LOWER);
<       IntStream.range(0, n).parallel().forEach((j) -> {
<          double[] xj = x[j];
< 
<          for(int i = 0; i < n; ++i) {
<             matrix.set(i, j, dot(x[i], xj));
<          }
< 
<       });
<       return matrix;
<    }
< 
<    public static MatrixModified pdot(SparseArrayModified[] x) {
<       int n = x.length;
<       MatrixModified matrix = new MatrixModified(n, n);
<       matrix.uplo(UPLOModified.LOWER);
<       IntStream.range(0, n).parallel().forEach((j) -> {
<          SparseArrayModified xj = x[j];
< 
<          for(int i = 0; i < n; ++i) {
<             matrix.set(i, j, dot(x[i], xj));
<          }
< 
<       });
<       return matrix;
<    }
< 
<    public static double cov(int[] x, int[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double mx = mean(x);
<          double my = mean(y);
<          double Sxy = 0.0D;
< 
<          for(int i = 0; i < x.length; ++i) {
<             double dx = (double)x[i] - mx;
<             double dy = (double)y[i] - my;
<             Sxy += dx * dy;
<          }
< 
<          return Sxy / (double)(x.length - 1);
<       }
<    }
< 
<    public static double cov(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double mx = mean(x);
<          double my = mean(y);
<          double Sxy = 0.0D;
< 
<          for(int i = 0; i < x.length; ++i) {
<             double dx = (double)x[i] - mx;
<             double dy = (double)y[i] - my;
<             Sxy += dx * dy;
<          }
< 
<          return Sxy / (double)(x.length - 1);
<       }
<    }
< 
<    public static double cov(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double mx = mean(x);
<          double my = mean(y);
<          double Sxy = 0.0D;
< 
<          for(int i = 0; i < x.length; ++i) {
<             double dx = x[i] - mx;
<             double dy = y[i] - my;
<             Sxy += dx * dy;
<          }
< 
<          return Sxy / (double)(x.length - 1);
<       }
<    }
< 
<    public static double[][] cov(double[][] data) {
<       return cov(data, colMeans(data));
<    }
< 
<    public static double[][] cov(double[][] data, double[] mu) {
<       double[][] sigma = new double[data[0].length][data[0].length];
<       double[][] var6 = data;
<       int k = data.length;
< 
<       int j;
<       for(j = 0; j < k; ++j) {
<          double[] datum = var6[j];
< 
<          for(int j = 0; j < mu.length; ++j) {
<             for(int k = 0; k <= j; ++k) {
<                sigma[j][k] += (datum[j] - mu[j]) * (datum[k] - mu[k]);
<             }
<          }
<       }
< 
<       int n = data.length - 1;
< 
<       for(j = 0; j < mu.length; ++j) {
<          for(k = 0; k <= j; ++k) {
<             sigma[j][k] /= (double)n;
<             sigma[k][j] = sigma[j][k];
<          }
<       }
< 
<       return sigma;
<    }
< 
<    public static double cor(int[] x, int[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double Sxy = cov(x, y);
<          double Sxx = var(x);
<          double Syy = var(y);
<          return Sxx != 0.0D && Syy != 0.0D ? Sxy / Math.sqrt(Sxx * Syy) : Double.NaN;
<       }
<    }
< 
<    public static double cor(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double Sxy = cov(x, y);
<          double Sxx = var(x);
<          double Syy = var(y);
<          return Sxx != 0.0D && Syy != 0.0D ? Sxy / Math.sqrt(Sxx * Syy) : Double.NaN;
<       }
<    }
< 
<    public static double cor(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Arrays have different length.");
<       } else if (x.length < 3) {
<          throw new IllegalArgumentException("array length has to be at least 3.");
<       } else {
<          double Sxy = cov(x, y);
<          double Sxx = var(x);
<          double Syy = var(y);
<          return Sxx != 0.0D && Syy != 0.0D ? Sxy / Math.sqrt(Sxx * Syy) : Double.NaN;
<       }
<    }
< 
<    public static double[][] cor(double[][] data) {
<       return cor(data, colMeans(data));
<    }
< 
<    public static double[][] cor(double[][] data, double[] mu) {
<       double[][] sigma = cov(data, mu);
<       int n = data[0].length;
<       double[] sd = new double[n];
< 
<       int i;
<       for(i = 0; i < n; ++i) {
<          sd[i] = Math.sqrt(sigma[i][i]);
<       }
< 
<       for(i = 0; i < n; ++i) {
<          for(int j = 0; j <= i; ++j) {
<             sigma[i][j] /= sd[i] * sd[j];
<             sigma[j][i] = sigma[i][j];
<          }
<       }
< 
<       return sigma;
<    }
< 
<    private static double crank(double[] w) {
<       int n = w.length;
<       double s = 0.0D;
<       int j = 1;
< 
<       while(true) {
<          while(j < n) {
<             if (w[j] != w[j - 1]) {
<                w[j - 1] = (double)j;
<                ++j;
<             } else {
<                int jt;
<                for(jt = j + 1; jt <= n && w[jt - 1] == w[j - 1]; ++jt) {
<                }
< 
<                double rank = 0.5D * (double)(j + jt - 1);
< 
<                for(int ji = j; ji <= jt - 1; ++ji) {
<                   w[ji - 1] = rank;
<                }
< 
<                double t = (double)(jt - j);
<                s += t * t * t - t;
<                j = jt;
<             }
<          }
< 
<          if (j == n) {
<             w[n - 1] = (double)n;
<          }
< 
<          return s;
<       }
<    }
< 
<    public static double spearman(int[] x, int[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          int n = x.length;
<          double[] wksp1 = new double[n];
<          double[] wksp2 = new double[n];
< 
<          for(int j = 0; j < n; ++j) {
<             wksp1[j] = (double)x[j];
<             wksp2[j] = (double)y[j];
<          }
< 
<          QuickSortModified.sort(wksp1, wksp2);
<          crank(wksp1);
<          QuickSortModified.sort(wksp2, wksp1);
<          crank(wksp2);
<          return cor(wksp1, wksp2);
<       }
<    }
< 
<    public static double spearman(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          int n = x.length;
<          double[] wksp1 = new double[n];
<          double[] wksp2 = new double[n];
< 
<          for(int j = 0; j < n; ++j) {
<             wksp1[j] = (double)x[j];
<             wksp2[j] = (double)y[j];
<          }
< 
<          QuickSortModified.sort(wksp1, wksp2);
<          crank(wksp1);
<          QuickSortModified.sort(wksp2, wksp1);
<          crank(wksp2);
<          return cor(wksp1, wksp2);
<       }
<    }
< 
<    public static double spearman(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          double[] wksp1 = (double[])x.clone();
<          double[] wksp2 = (double[])y.clone();
<          QuickSortModified.sort(wksp1, wksp2);
<          crank(wksp1);
<          QuickSortModified.sort(wksp2, wksp1);
<          crank(wksp2);
<          return cor(wksp1, wksp2);
<       }
<    }
< 
<    public static double kendall(int[] x, int[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          int is = 0;
<          int n2 = 0;
<          int n1 = 0;
<          int n = x.length;
< 
<          for(int j = 0; j < n - 1; ++j) {
<             for(int k = j + 1; k < n; ++k) {
<                double a1 = (double)(x[j] - x[k]);
<                double a2 = (double)(y[j] - y[k]);
<                double aa = a1 * a2;
<                if (aa != 0.0D) {
<                   ++n1;
<                   ++n2;
<                   if (aa > 0.0D) {
<                      ++is;
<                   } else {
<                      --is;
<                   }
<                } else {
<                   if (a1 != 0.0D) {
<                      ++n1;
<                   }
< 
<                   if (a2 != 0.0D) {
<                      ++n2;
<                   }
<                }
<             }
<          }
< 
<          return (double)is / (Math.sqrt((double)n1) * Math.sqrt((double)n2));
<       }
<    }
< 
<    public static double kendall(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          int is = 0;
<          int n2 = 0;
<          int n1 = 0;
<          int n = x.length;
< 
<          for(int j = 0; j < n - 1; ++j) {
<             for(int k = j + 1; k < n; ++k) {
<                double a1 = (double)(x[j] - x[k]);
<                double a2 = (double)(y[j] - y[k]);
<                double aa = a1 * a2;
<                if (aa != 0.0D) {
<                   ++n1;
<                   ++n2;
<                   if (aa > 0.0D) {
<                      ++is;
<                   } else {
<                      --is;
<                   }
<                } else {
<                   if (a1 != 0.0D) {
<                      ++n1;
<                   }
< 
<                   if (a2 != 0.0D) {
<                      ++n2;
<                   }
<                }
<             }
<          }
< 
<          return (double)is / (Math.sqrt((double)n1) * Math.sqrt((double)n2));
<       }
<    }
< 
<    public static double kendall(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException("Input vector sizes are different.");
<       } else {
<          int is = 0;
<          int n2 = 0;
<          int n1 = 0;
<          int n = x.length;
< 
<          for(int j = 0; j < n - 1; ++j) {
<             for(int k = j + 1; k < n; ++k) {
<                double a1 = x[j] - x[k];
<                double a2 = y[j] - y[k];
<                double aa = a1 * a2;
<                if (aa != 0.0D) {
<                   ++n1;
<                   ++n2;
<                   if (aa > 0.0D) {
<                      ++is;
<                   } else {
<                      --is;
<                   }
<                } else {
<                   if (a1 != 0.0D) {
<                      ++n1;
<                   }
< 
<                   if (a2 != 0.0D) {
<                      ++n2;
<                   }
<                }
<             }
<          }
< 
<          return (double)is / (Math.sqrt((double)n1) * Math.sqrt((double)n2));
<       }
<    }
< 
<    public static float norm1(float[] x) {
<       float norm = 0.0F;
<       float[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          float n = var5[var3];
<          norm += Math.abs(n);
<       }
< 
<       return norm;
<    }
< 
<    public static double norm1(double[] x) {
<       double norm = 0.0D;
<       double[] var7 = x;
<       int var6 = x.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double n = var7[var5];
<          norm += Math.abs(n);
<       }
< 
<       return norm;
<    }
< 
<    public static float norm2(float[] x) {
<       float norm = 0.0F;
<       float[] var5 = x;
<       int var4 = x.length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          float n = var5[var3];
<          norm += n * n;
<       }
< 
<       norm = (float)Math.sqrt((double)norm);
<       return norm;
<    }
< 
<    public static double norm2(double[] x) {
<       double norm = 0.0D;
<       double[] var7 = x;
<       int var6 = x.length;
< 
<       for(int var5 = 0; var5 < var6; ++var5) {
<          double n = var7[var5];
<          norm += n * n;
<       }
< 
<       norm = Math.sqrt(norm);
<       return norm;
<    }
< 
<    public static float normInf(float[] x) {
<       int n = x.length;
<       float f = Math.abs(x[0]);
< 
<       for(int i = 1; i < n; ++i) {
<          f = Math.max(f, Math.abs(x[i]));
<       }
< 
<       return f;
<    }
< 
<    public static double normInf(double[] x) {
<       int n = x.length;
<       double f = Math.abs(x[0]);
< 
<       for(int i = 1; i < n; ++i) {
<          f = Math.max(f, Math.abs(x[i]));
<       }
< 
<       return f;
<    }
< 
<    public static float norm(float[] x) {
<       return norm2(x);
<    }
< 
<    public static double norm(double[] x) {
<       return norm2(x);
<    }
< 
<    public static float cos(float[] x, float[] y) {
<       return dot(x, y) / (norm2(x) * norm2(y));
<    }
< 
<    public static double cos(double[] x, double[] y) {
<       return dot(x, y) / (norm2(x) * norm2(y));
<    }
< 
<    public static void standardize(double[] x) {
<       double mu = mean(x);
<       double sigma = sd(x);
<       if (isZero(sigma)) {
<          logger.warn("array has variance of 0.");
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             x[i] = (x[i] - mu) / sigma;
<          }
< 
<       }
<    }
< 
<    public static void scale(double[][] x) {
<       int n = x.length;
<       int p = x[0].length;
<       double[] min = colMin(x);
<       double[] max = colMax(x);
< 
<       for(int j = 0; j < p; ++j) {
<          double scale = max[j] - min[j];
<          int i;
<          if (!isZero(scale)) {
<             for(i = 0; i < n; ++i) {
<                x[i][j] = (x[i][j] - min[j]) / scale;
<             }
<          } else {
<             for(i = 0; i < n; ++i) {
<                x[i][j] = 0.5D;
<             }
<          }
<       }
< 
<    }
< 
<    public static void standardize(double[][] x) {
<       int n = x.length;
<       int p = x[0].length;
<       double[] center = colMeans(x);
< 
<       int j;
<       for(int i = 0; i < n; ++i) {
<          for(j = 0; j < p; ++j) {
<             x[i][j] -= center[j];
<          }
<       }
< 
<       double[] scale = new double[p];
< 
<       for(j = 0; j < p; ++j) {
<          double[][] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             double[] xi = var9[var7];
<             scale[j] += pow2(xi[j]);
<          }
< 
<          scale[j] = Math.sqrt(scale[j] / (double)(n - 1));
<          if (!isZero(scale[j])) {
<             for(int i = 0; i < n; ++i) {
<                x[i][j] /= scale[j];
<             }
<          }
<       }
< 
<    }
< 
<    public static void normalize(double[][] x) {
<       normalize(x, false);
<    }
< 
<    public static void normalize(double[][] x, boolean centerizing) {
<       int n = x.length;
<       int p = x[0].length;
<       double[] scale;
<       int i;
<       int j;
<       if (centerizing) {
<          scale = colMeans(x);
< 
<          for(i = 0; i < n; ++i) {
<             for(j = 0; j < p; ++j) {
<                x[i][j] -= scale[j];
<             }
<          }
<       }
< 
<       scale = new double[p];
< 
<       for(i = 0; i < p; ++i) {
<          double[][] var9 = x;
<          int var8 = x.length;
< 
<          for(int var7 = 0; var7 < var8; ++var7) {
<             double[] xi = var9[var7];
<             scale[i] += pow2(xi[i]);
<          }
< 
<          scale[i] = Math.sqrt(scale[i]);
<       }
< 
<       for(i = 0; i < n; ++i) {
<          for(j = 0; j < p; ++j) {
<             if (!isZero(scale[j])) {
<                x[i][j] /= scale[j];
<             }
<          }
<       }
< 
<    }
< 
<    public static void unitize(double[] x) {
<       unitize2(x);
<    }
< 
<    public static void unitize1(double[] x) {
<       double n = norm1(x);
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] /= n;
<       }
< 
<    }
< 
<    public static void unitize2(double[] x) {
<       double n = norm(x);
< 
<       for(int i = 0; i < x.length; ++i) {
<          x[i] /= n;
<       }
< 
<    }
< 
<    public static boolean equals(float[] x, float[] y) {
<       return equals(x, y, 1.0E-7F);
<    }
< 
<    public static boolean equals(float[] x, float[] y, float epsilon) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             if (Math.abs(x[i] - y[i]) > epsilon) {
<                return false;
<             }
<          }
< 
<          return true;
<       }
<    }
< 
<    public static boolean equals(double[] x, double[] y) {
<       return equals(x, y, 1.0E-10D);
<    }
< 
<    public static boolean equals(double[] x, double[] y, double epsilon) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else if (epsilon <= 0.0D) {
<          throw new IllegalArgumentException("Invalid epsilon: " + epsilon);
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             if (Math.abs(x[i] - y[i]) > epsilon) {
<                return false;
<             }
<          }
< 
<          return true;
<       }
<    }
< 
<    public static boolean equals(float[][] x, float[][] y) {
<       return equals(x, y, 1.0E-7F);
<    }
< 
<    public static boolean equals(float[][] x, float[][] y, float epsilon) {
<       if (x.length == y.length && x[0].length == y[0].length) {
<          for(int i = 0; i < x.length; ++i) {
<             for(int j = 0; j < x[i].length; ++j) {
<                if (Math.abs(x[i][j] - y[i][j]) > epsilon) {
<                   return false;
<                }
<             }
<          }
< 
<          return true;
<       } else {
<          throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
<       }
<    }
< 
<    public static boolean equals(double[][] x, double[][] y) {
<       return equals(x, y, 1.0E-10D);
<    }
< 
<    public static boolean equals(double[][] x, double[][] y, double epsilon) {
<       if (x.length == y.length && x[0].length == y[0].length) {
<          if (epsilon <= 0.0D) {
<             throw new IllegalArgumentException("Invalid epsilon: " + epsilon);
<          } else {
<             for(int i = 0; i < x.length; ++i) {
<                for(int j = 0; j < x[i].length; ++j) {
<                   if (Math.abs(x[i][j] - y[i][j]) > epsilon) {
<                      return false;
<                   }
<                }
<             }
< 
<             return true;
<          }
<       } else {
<          throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
<       }
<    }
< 
<    public static boolean isZero(float x) {
<       return isZero(x, FLOAT_EPSILON);
<    }
< 
<    public static boolean isZero(float x, float epsilon) {
<       return Math.abs(x) < epsilon;
<    }
< 
<    public static boolean isZero(double x) {
<       return isZero(x, EPSILON);
<    }
< 
<    public static boolean isZero(double x, double epsilon) {
<       return Math.abs(x) < epsilon;
<    }
< 
<    public static int[][] clone(int[][] x) {
<       int[][] matrix = new int[x.length][];
< 
<       for(int i = 0; i < x.length; ++i) {
<          matrix[i] = (int[])x[i].clone();
<       }
< 
<       return matrix;
<    }
< 
<    public static float[][] clone(float[][] x) {
<       float[][] matrix = new float[x.length][];
< 
<       for(int i = 0; i < x.length; ++i) {
<          matrix[i] = (float[])x[i].clone();
<       }
< 
<       return matrix;
<    }
< 
<    public static double[][] clone(double[][] x) {
<       double[][] matrix = new double[x.length][];
< 
<       for(int i = 0; i < x.length; ++i) {
<          matrix[i] = (double[])x[i].clone();
<       }
< 
<       return matrix;
<    }
< 
<    public static void swap(int[] x, int i, int j) {
<       int s = x[i];
<       x[i] = x[j];
<       x[j] = s;
<    }
< 
<    public static void swap(float[] x, int i, int j) {
<       float s = x[i];
<       x[i] = x[j];
<       x[j] = s;
<    }
< 
<    public static void swap(double[] x, int i, int j) {
<       double s = x[i];
<       x[i] = x[j];
<       x[j] = s;
<    }
< 
<    public static void swap(Object[] x, int i, int j) {
<       Object s = x[i];
<       x[i] = x[j];
<       x[j] = s;
<    }
< 
<    public static void swap(int[] x, int[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             int s = x[i];
<             x[i] = y[i];
<             y[i] = s;
<          }
< 
<       }
<    }
< 
<    public static void swap(float[] x, float[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             float s = x[i];
<             x[i] = y[i];
<             y[i] = s;
<          }
< 
<       }
<    }
< 
<    public static void swap(double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             double s = x[i];
<             x[i] = y[i];
<             y[i] = s;
<          }
< 
<       }
<    }
< 
<    public static <E> void swap(E[] x, E[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             E s = x[i];
<             x[i] = y[i];
<             y[i] = s;
<          }
< 
<       }
<    }
< 
<    public static void copy(int[][] x, int[][] y) {
<       if (x.length == y.length && x[0].length == y[0].length) {
<          for(int i = 0; i < x.length; ++i) {
<             System.arraycopy(x[i], 0, y[i], 0, x[i].length);
<          }
< 
<       } else {
<          throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
<       }
<    }
< 
<    public static void copy(float[][] x, float[][] y) {
<       if (x.length == y.length && x[0].length == y[0].length) {
<          for(int i = 0; i < x.length; ++i) {
<             System.arraycopy(x[i], 0, y[i], 0, x[i].length);
<          }
< 
<       } else {
<          throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
<       }
<    }
< 
<    public static void copy(double[][] x, double[][] y) {
<       if (x.length == y.length && x[0].length == y[0].length) {
<          for(int i = 0; i < x.length; ++i) {
<             System.arraycopy(x[i], 0, y[i], 0, x[i].length);
<          }
< 
<       } else {
<          throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", x.length, x[0].length, y.length, y[0].length));
<       }
<    }
< 
<    public static void add(double[] y, double[] x) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             y[i] += x[i];
<          }
< 
<       }
<    }
< 
<    public static void sub(double[] y, double[] x) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             y[i] -= x[i];
<          }
< 
<       }
<    }
< 
<    public static void scale(double a, double[] x) {
<       for(int i = 0; i < x.length; ++i) {
<          x[i] *= a;
<       }
< 
<    }
< 
<    public static void scale(double a, double[] x, double[] y) {
<       for(int i = 0; i < x.length; ++i) {
<          y[i] = a * x[i];
<       }
< 
<    }
< 
<    public static double[] axpy(double a, double[] x, double[] y) {
<       if (x.length != y.length) {
<          throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", x.length, y.length));
<       } else {
<          for(int i = 0; i < x.length; ++i) {
<             y[i] += a * x[i];
<          }
< 
<          return y;
<       }
<    }
< 
<    public static double[] pow(double[] x, double n) {
<       double[] y = new double[x.length];
< 
<       for(int i = 0; i < x.length; ++i) {
<          y[i] = Math.pow(x[i], n);
<       }
< 
<       return y;
<    }
< 
<    public static int[] unique(int[] x) {
<       return Arrays.stream(x).distinct().toArray();
<    }
< 
<    public static String[] unique(String[] x) {
<       return (String[])Arrays.stream(x).distinct().toArray((var0) -> {
<          return new String[var0];
<       });
<    }
< 
<    public static double[] solve(double[] a, double[] b, double[] c, double[] r) {
<       if (b[0] == 0.0D) {
<          throw new IllegalArgumentException("Invalid value of b[0] == 0. The equations should be rewritten as a set of order n - 1.");
<       } else {
<          int n = a.length;
<          double[] u = new double[n];
<          double[] gam = new double[n];
<          double bet = b[0];
<          u[0] = r[0] / bet;
< 
<          int j;
<          for(j = 1; j < n; ++j) {
<             gam[j] = c[j - 1] / bet;
<             bet = b[j] - a[j] * gam[j];
<             if (bet == 0.0D) {
<                throw new IllegalArgumentException("The tridagonal matrix is not of diagonal dominance.");
<             }
< 
<             u[j] = (r[j] - a[j] * u[j - 1]) / bet;
<          }
< 
<          for(j = n - 2; j >= 0; --j) {
<             u[j] -= gam[j + 1] * u[j + 1];
<          }
< 
<          return u;
<       }
<    }
< 
<    // $FF: synthetic method
<    private static Object $deserializeLambda$(SerializedLambda var0) {
<       String var1 = var0.getImplMethodName();
<       byte var2 = -1;
<       switch(var1.hashCode()) {
<       case -1421810692:
<          if (var1.equals("squaredDistance")) {
<             var2 = 0;
<          } else if (var1.equals("squaredDistance")) {
<             var2 = 0;
<          } else if (var1.equals("squaredDistance")) {
<             var2 = 0;
<          } else if (var1.equals("squaredDistance")) {
<             var2 = 0;
<          }
<          break;
<       case 288459765:
<          if (var1.equals("distance")) {
<             var2 = 1;
<          } else if (var1.equals("distance")) {
<             var2 = 1;
<          } else if (var1.equals("distance")) {
<             var2 = 1;
<          } else if (var1.equals("distance")) {
<             var2 = 1;
<          }
<       }
< 
<       switch(var2) {
<       case 0:
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([I[I)D")) {
<             return MathExModified::squaredDistance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([F[F)D")) {
<             return MathExModified::squaredDistance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([D[D)D")) {
<             return MathExModified::squaredDistance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("(LsmileModified/SparseArrayModified;LsmileModified/SparseArrayModified;)D")) {
<             return MathExModified::squaredDistance;
<          }
<          break;
<       case 1:
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([I[I)D")) {
<             return MathExModified::distance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([F[F)D")) {
<             return MathExModified::distance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("([D[D)D")) {
<             return MathExModified::distance;
<          }
< 
<          if (var0.getImplMethodKind() == 6 && var0.getFunctionalInterfaceClass().equals("smileModified/DistanceModified") && var0.getFunctionalInterfaceMethodName().equals("d") && var0.getFunctionalInterfaceMethodSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)D") && var0.getImplClass().equals("smileModified/MathExModified") && var0.getImplMethodSignature().equals("(LsmileModified/SparseArrayModified;LsmileModified/SparseArrayModified;)D")) {
<             return MathExModified::distance;
<          }
<       }
< 
<       throw new IllegalArgumentException("Invalid lambda deserialization");
<    }
< 
<    private static class FPU {
<       int RADIX;
<       int DIGITS;
<       int FLOAT_DIGITS = 24;
<       int ROUND_STYLE;
<       int MACHEP;
<       int FLOAT_MACHEP = -23;
<       int NEGEP;
<       int FLOAT_NEGEP = -24;
<       float FLOAT_EPSILON;
<       double EPSILON;
< 
<       FPU() {
<          this.FLOAT_EPSILON = (float)Math.pow(2.0D, (double)this.FLOAT_MACHEP);
<          double ONE = 1.0D;
<          double TWO = ONE + ONE;
<          double ZERO = ONE - ONE;
<          double a = ONE;
< 
<          double temp;
<          double temp1;
<          for(temp1 = ONE; temp1 - ONE == ZERO; temp1 = temp - a) {
<             a += a;
<             temp = a + ONE;
<          }
< 
<          double b = ONE;
< 
<          int itemp;
<          for(itemp = 0; itemp == 0; itemp = (int)(temp - a)) {
<             b += b;
<             temp = a + b;
<          }
< 
<          this.RADIX = itemp;
<          double beta = (double)this.RADIX;
<          this.DIGITS = 0;
<          b = ONE;
< 
<          for(temp1 = ONE; temp1 - ONE == ZERO; temp1 = temp - b) {
<             ++this.DIGITS;
<             b *= beta;
<             temp = b + ONE;
<          }
< 
<          this.ROUND_STYLE = 0;
<          double betah = beta / TWO;
<          temp = a + betah;
<          if (temp - a != ZERO) {
<             this.ROUND_STYLE = 1;
<          }
< 
<          double tempa = a + beta;
<          temp = tempa + betah;
<          if (this.ROUND_STYLE == 0 && temp - tempa != ZERO) {
<             this.ROUND_STYLE = 2;
<          }
< 
<          this.NEGEP = this.DIGITS + 3;
<          double betain = ONE / beta;
<          a = ONE;
< 
<          for(int i = 0; i < this.NEGEP; ++i) {
<             a *= betain;
<          }
< 
<          for(temp = ONE - a; temp - ONE == ZERO; temp = ONE - a) {
<             a *= beta;
<             --this.NEGEP;
<          }
< 
<          this.NEGEP = -this.NEGEP;
<          this.MACHEP = -this.DIGITS - 3;
<          a = a;
< 
<          for(temp = ONE + a; temp - ONE == ZERO; temp = ONE + a) {
<             a *= beta;
<             ++this.MACHEP;
<          }
< 
<          this.EPSILON = a;
<       }
<    }
< }
---
> /*      */ package smileModified;
> /*      */ 
> /*      */ import java.lang.invoke.SerializedLambda;
> /*      */ import java.lang.reflect.Array;
> /*      */ import java.security.SecureRandom;
> /*      */ import java.util.Arrays;
> /*      */ import java.util.Iterator;
> /*      */ import java.util.stream.IntStream;
> /*      */ import java.util.stream.LongStream;
> /*      */ import org.slf4j.Logger;
> /*      */ import org.slf4j.LoggerFactory;
> /*      */ 
> /*      */ public class MathExModified {
> /*   14 */   private static final Logger logger = LoggerFactory.getLogger(MathExModified.class);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*   19 */   private static final FPU fpu = new FPU();
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*   24 */   public static final double EPSILON = fpu.EPSILON;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*   29 */   public static final float FLOAT_EPSILON = fpu.FLOAT_EPSILON;
> /*      */ 
> /*      */ 
> /*      */   
> /*   33 */   public static final int RADIX = fpu.RADIX;
> /*      */ 
> /*      */ 
> /*      */   
> /*   37 */   public static final int DIGITS = fpu.DIGITS;
> /*      */ 
> /*      */ 
> /*      */   
> /*   41 */   public static final int FLOAT_DIGITS = fpu.FLOAT_DIGITS;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*   54 */   public static final int ROUND_STYLE = fpu.ROUND_STYLE;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*   59 */   public static final int MACHEP = fpu.MACHEP;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*   64 */   public static final int FLOAT_MACHEP = fpu.FLOAT_MACHEP;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*   69 */   public static final int NEGEP = fpu.NEGEP;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*   74 */   public static final int FLOAT_NEGEP = fpu.FLOAT_NEGEP;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*   81 */   private static final SecureRandom seedRNG = new SecureRandom();
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*   86 */   private static final long[] DEFAULT_SEEDS = new long[] { 
> /*   87 */       -4106602711295138952L, 7872020634117869514L, -1722503517109829138L, -3386820675908254116L, 
> /*   88 */       -1736715870046201019L, 3854590623768163340L, 4984519038350406438L, 831971085876758331L, 
> /*   89 */       7131773007627236777L, -3609561992173376238L, -8759399602515137276L, 6192158663294695439L, 
> /*   90 */       -5656470009161653116L, -7984826214821970800L, -9113192788977418232L, -8979910231410580019L, 
> /*   91 */       -4619021025191354324L, -5082417586190057466L, -6554946940783144090L, -3610462176018822900L, 
> /*   92 */       8959796931768911980L, -4251632352234989839L, 4922191169088134258L, -7282805902317830669L, 
> /*   93 */       3869302430595840919L, 2517690626940415460L, 4056663221614950174L, 6429856319379397738L, 
> /*   94 */       7298845553914383313L, 8179510284261677971L, 4282994537597585253L, 7300184601511783348L, 
> /*   95 */       2596703774884172704L, 1089838915342514714L, 4323657609714862439L, 777826126579190548L, 
> /*   96 */       -1902743089794461140L, -2460431043688989882L, -3261708534465890932L, 4007861469505443778L, 
> /*   97 */       8067600139237526646L, 5717273542173905853L, 2938568334013652889L, -2972203304739218305L, 
> /*   98 */       6544901794394958069L, 7013723936758841449L, -4215598453287525312L, -1454689091401951913L, 
> /*   99 */       -5699280845313829011L, -9147984414924288540L, 5211986845656222459L, -1287642354429721659L, 
> /*  100 */       -1509334943513011620L, -9000043616528857326L, -2902817511399216571L, -742823064588229527L, 
> /*  101 */       -4937222449957498789L, -455679889440396397L, -6109470266907575296L, 5515435653880394376L, 
> /*  102 */       5557224587324997029L, 8904139390487005840L, 6560726276686488510L, 6959949429287621625L, 
> /*  103 */       -6055733513105375650L, 5762016937143172332L, -9186652929482643329L, -1105816448554330895L, 
> /*  104 */       -8200377873547841359L, 9107473159863354619L, 3239950546973836199L, -8104429975176305012L, 
> /*  105 */       3822949195131885242L, -5261390396129824777L, 9176101422921943895L, -5102541493993205418L, 
> /*  106 */       -1254710019595692814L, -6668066200971989826L, -2118519708589929546L, 5428466612765068681L, 
> /*  107 */       -6528627776941116598L, -5945449163896244174L, -3293290115918281076L, 6370347300411991230L, 
> /*  108 */       -7043881693953271167L, 8078993941165238212L, 6894961504641498099L, -8798276497942360228L, 
> /*  109 */       2276271091333773917L, -7184141741385833013L, -4787502691178107481L, 1255068205351917608L, 
> /*  110 */       -8644146770023935609L, 5124094110137147339L, 4917075344795488880L, 3423242822219783102L, 
> /*  111 */       1588924456880980404L, 8515495360312448868L, -5563691320675461929L, -2352238951654504517L, 
> /*  112 */       -7416919543420127888L, 631412478604690114L, 689144891258712875L, -9001615284848119152L, 
> /*  113 */       -6275065758899203088L, 8164387857252400515L, -4122060123604826739L, -2016541034210046261L, 
> /*  114 */       -7178335877193796678L, 3354303106860129181L, 5731595363486898779L, -2874315602397298018L, 
> /*  115 */       5386746429707619069L, 9036622191596156315L, -7950190733284789459L, -5741691593792426169L, 
> /*  116 */       -8600462258998065159L, 5460142111961227035L, 276738899508534641L, 2358776514903881139L, 
> /*  117 */       -837649704945720257L, -3608906204977108245L, 2960825464614526243L, 7339056324843827739L, 
> /*  118 */       -5709958573878745135L, -5885403829221945248L, 6611935345917126768L, 2588814037559904539L };
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*  124 */   private static int nextSeed = -1;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*  129 */   private static final ThreadLocal<RandomModified> random = new ThreadLocal<RandomModified>() {
> /*      */       protected RandomModified initialValue() {
> /*  131 */         synchronized (MathExModified.DEFAULT_SEEDS) {
> /*      */           
> /*  133 */           if (MathExModified.nextSeed < 0) {
> /*  134 */             MathExModified.nextSeed = 0;
> /*  135 */             return new RandomModified();
> /*      */           } 
> /*  137 */           if (MathExModified.nextSeed < MathExModified.DEFAULT_SEEDS.length) {
> /*  138 */             MathExModified.nextSeed = MathExModified.nextSeed + 1; return new RandomModified(MathExModified.DEFAULT_SEEDS[MathExModified.nextSeed]);
> /*      */           } 
> /*  140 */           return new RandomModified(MathExModified.generateSeed());
> /*      */         } 
> /*      */       }
> /*      */     };
> /*      */ 
> /*      */   
> /*      */   private static class FPU
> /*      */   {
> /*      */     int RADIX;
> /*      */     
> /*      */     int DIGITS;
> /*      */     
> /*  152 */     int FLOAT_DIGITS = 24;
> /*      */     int ROUND_STYLE;
> /*      */     int MACHEP;
> /*  155 */     int FLOAT_MACHEP = -23;
> /*      */     int NEGEP;
> /*  157 */     int FLOAT_NEGEP = -24;
> /*  158 */     float FLOAT_EPSILON = (float)Math.pow(2.0D, this.FLOAT_MACHEP);
> /*      */ 
> /*      */     
> /*      */     double EPSILON;
> /*      */ 
> /*      */     
> /*      */     FPU() {
> /*  165 */       double ONE = 1.0D;
> /*  166 */       double TWO = ONE + ONE;
> /*  167 */       double ZERO = ONE - ONE;
> /*      */       
> /*  169 */       double a = ONE;
> /*  170 */       double temp1 = ONE;
> /*  171 */       while (temp1 - ONE == ZERO) {
> /*  172 */         a += a;
> /*  173 */         double d = a + ONE;
> /*  174 */         temp1 = d - a;
> /*      */       } 
> /*  176 */       double b = ONE;
> /*  177 */       int itemp = 0;
> /*  178 */       while (itemp == 0) {
> /*  179 */         b += b;
> /*  180 */         double d = a + b;
> /*  181 */         itemp = (int)(d - a);
> /*      */       } 
> /*  183 */       this.RADIX = itemp;
> /*  184 */       double beta = this.RADIX;
> /*      */       
> /*  186 */       this.DIGITS = 0;
> /*  187 */       b = ONE;
> /*  188 */       temp1 = ONE;
> /*  189 */       while (temp1 - ONE == ZERO) {
> /*  190 */         this.DIGITS++;
> /*  191 */         b *= beta;
> /*  192 */         double d = b + ONE;
> /*  193 */         temp1 = d - b;
> /*      */       } 
> /*  195 */       this.ROUND_STYLE = 0;
> /*  196 */       double betah = beta / TWO;
> /*  197 */       double temp = a + betah;
> /*  198 */       if (temp - a != ZERO) {
> /*  199 */         this.ROUND_STYLE = 1;
> /*      */       }
> /*  201 */       double tempa = a + beta;
> /*  202 */       temp = tempa + betah;
> /*  203 */       if (this.ROUND_STYLE == 0 && temp - tempa != ZERO) {
> /*  204 */         this.ROUND_STYLE = 2;
> /*      */       }
> /*      */       
> /*  207 */       this.NEGEP = this.DIGITS + 3;
> /*  208 */       double betain = ONE / beta;
> /*  209 */       a = ONE;
> /*  210 */       for (int i = 0; i < this.NEGEP; i++) {
> /*  211 */         a *= betain;
> /*      */       }
> /*  213 */       b = a;
> /*  214 */       temp = ONE - a;
> /*  215 */       while (temp - ONE == ZERO) {
> /*  216 */         a *= beta;
> /*  217 */         this.NEGEP--;
> /*  218 */         temp = ONE - a;
> /*      */       } 
> /*  220 */       this.NEGEP = -this.NEGEP;
> /*      */       
> /*  222 */       this.MACHEP = -this.DIGITS - 3;
> /*  223 */       a = b;
> /*  224 */       temp = ONE + a;
> /*  225 */       while (temp - ONE == ZERO) {
> /*  226 */         a *= beta;
> /*  227 */         this.MACHEP++;
> /*  228 */         temp = ONE + a;
> /*      */       } 
> /*  230 */       this.EPSILON = a;
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*  244 */   private static final double LOG2 = Math.log(2.0D);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double log2(double x) {
> /*  252 */     return Math.log(x) / LOG2;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double log(double x) {
> /*  261 */     double y = -690.7755D;
> /*  262 */     if (x > 1.0E-300D) {
> /*  263 */       y = Math.log(x);
> /*      */     }
> /*  265 */     return y;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double log1pe(double x) {
> /*  274 */     double y = x;
> /*  275 */     if (x <= 15.0D) {
> /*  276 */       y = Math.log1p(Math.exp(x));
> /*      */     }
> /*      */     
> /*  279 */     return y;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean isInt(float x) {
> /*  288 */     return (x == (float)Math.floor(x) && !Float.isInfinite(x));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean isInt(double x) {
> /*  297 */     return (x == Math.floor(x) && !Double.isInfinite(x));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean equals(double a, double b) {
> /*  307 */     if (a == b) {
> /*  308 */       return true;
> /*      */     }
> /*      */     
> /*  311 */     double absa = Math.abs(a);
> /*  312 */     double absb = Math.abs(b);
> /*  313 */     return (Math.abs(a - b) <= Math.min(absa, absb) * 2.220446049250313E-16D);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double sigmoid(double x) {
> /*  323 */     x = Math.max(-36.0D, Math.min(x, 36.0D));
> /*  324 */     return 1.0D / (1.0D + Math.exp(-x));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double pow2(double x) {
> /*  333 */     return x * x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean isPower2(int x) {
> /*  342 */     return (x > 0 && (x & x - 1) == 0);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean isProbablePrime(long n, int k) {
> /*  355 */     return isProbablePrime(n, k, random.get());
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   private static boolean isProbablePrime(long n, int k, RandomModified rng) {
> /*  369 */     if (n <= 1L || n == 4L)
> /*  370 */       return false; 
> /*  371 */     if (n <= 3L) {
> /*  372 */       return true;
> /*      */     }
> /*      */     
> /*  375 */     int s = 0;
> /*  376 */     long d = n - 1L;
> /*  377 */     while (d % 2L == 0L) {
> /*  378 */       s++;
> /*  379 */       d /= 2L;
> /*      */     } 
> /*      */     
> /*  382 */     for (int i = 0; i < k; i++) {
> /*  383 */       long a = 2L + rng.nextLong() % (n - 4L);
> /*  384 */       long x = power(a, d, n);
> /*  385 */       if (x != 1L && x != n - 1L) {
> /*      */ 
> /*      */         
> /*  388 */         int r = 0;
> /*  389 */         for (; r < s; r++) {
> /*  390 */           x = x * x % n;
> /*  391 */           if (x == 1L) return false; 
> /*  392 */           if (x == n - 1L) {
> /*      */             break;
> /*      */           }
> /*      */         } 
> /*  396 */         if (r == s) return false; 
> /*      */       } 
> /*  398 */     }  return true;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   private static long power(long x, long y, long p) {
> /*  410 */     long res = 1L;
> /*  411 */     x %= p;
> /*      */     
> /*  413 */     while (y > 0L) {
> /*      */       
> /*  415 */       if ((y & 0x1L) == 1L) res = res * x % p;
> /*      */ 
> /*      */       
> /*  418 */       y >>= 1L;
> /*  419 */       x = x * x % p;
> /*      */     } 
> /*  421 */     return res;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double round(double x, int decimal) {
> /*  432 */     if (decimal < 0) {
> /*  433 */       return Math.round(x / Math.pow(10.0D, -decimal)) * Math.pow(10.0D, -decimal);
> /*      */     }
> /*  435 */     return Math.round(x * Math.pow(10.0D, decimal)) / Math.pow(10.0D, decimal);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double factorial(int n) {
> /*  447 */     if (n < 0) {
> /*  448 */       throw new IllegalArgumentException("n has to be non-negative.");
> /*      */     }
> /*      */     
> /*  451 */     double f = 1.0D;
> /*  452 */     for (int i = 2; i <= n; i++) {
> /*  453 */       f *= i;
> /*      */     }
> /*      */     
> /*  456 */     return f;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double lfactorial(int n) {
> /*  466 */     if (n < 0) {
> /*  467 */       throw new IllegalArgumentException(String.format("n has to be non-negative: %d", new Object[] { Integer.valueOf(n) }));
> /*      */     }
> /*      */     
> /*  470 */     double f = 0.0D;
> /*  471 */     for (int i = 2; i <= n; i++) {
> /*  472 */       f += Math.log(i);
> /*      */     }
> /*      */     
> /*  475 */     return f;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double choose(int n, int k) {
> /*  485 */     if (n < 0 || k < 0) {
> /*  486 */       throw new IllegalArgumentException(String.format("Invalid n = %d, k = %d", new Object[] { Integer.valueOf(n), Integer.valueOf(k) }));
> /*      */     }
> /*      */     
> /*  489 */     if (n < k) {
> /*  490 */       return 0.0D;
> /*      */     }
> /*      */     
> /*  493 */     return Math.floor(0.5D + Math.exp(lchoose(n, k)));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double lchoose(int n, int k) {
> /*  503 */     if (k < 0 || k > n) {
> /*  504 */       throw new IllegalArgumentException(String.format("Invalid n = %d, k = %d", new Object[] { Integer.valueOf(n), Integer.valueOf(k) }));
> /*      */     }
> /*      */     
> /*  507 */     return lfactorial(n) - lfactorial(k) - lfactorial(n - k);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static long generateSeed() {
> /*  515 */     byte[] bytes = generateSeed(8);
> /*  516 */     long seed = 0L;
> /*  517 */     for (int i = 0; i < 8; i++) {
> /*  518 */       seed <<= 8L;
> /*  519 */       seed |= (bytes[i] & 0xFF);
> /*      */     } 
> /*  521 */     return seed;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static byte[] generateSeed(int numBytes) {
> /*  531 */     synchronized (seedRNG) {
> /*  532 */       return seedRNG.generateSeed(numBytes);
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static LongStream seeds() {
> /*  541 */     return LongStream.generate(MathExModified::generateSeed).sequential();
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void setSeed(long seed) {
> /*  549 */     ((RandomModified)random.get()).setSeed(seed);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static long probablePrime(long n, int k) {
> /*  561 */     return probablePrime(n, k, random.get());
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   private static long probablePrime(long n, int k, RandomModified rng) {
> /*  574 */     long seed = n + rng.nextInt(899999963);
> /*  575 */     for (int i = 0; i < 4096 && 
> /*  576 */       !isProbablePrime(seed, k, rng); i++) {
> /*  577 */       seed = n + rng.nextInt(899999963);
> /*      */     }
> /*      */     
> /*  580 */     return seed;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int random(double[] prob) {
> /*  593 */     int[] ans = random(prob, 1);
> /*  594 */     return ans[0];
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] random(double[] prob, int n) {
> /*  610 */     double[] q = new double[prob.length];
> /*  611 */     for (int i = 0; i < prob.length; i++) {
> /*  612 */       q[i] = prob[i] * prob.length;
> /*      */     }
> /*      */ 
> /*      */     
> /*  616 */     int[] a = new int[prob.length];
> /*  617 */     for (int j = 0; j < prob.length; j++) {
> /*  618 */       a[j] = j;
> /*      */     }
> /*      */ 
> /*      */     
> /*  622 */     int[] HL = new int[prob.length];
> /*  623 */     int head = 0;
> /*  624 */     int tail = prob.length - 1;
> /*  625 */     for (int k = 0; k < prob.length; k++) {
> /*  626 */       if (q[k] >= 1.0D) {
> /*  627 */         HL[head++] = k;
> /*      */       } else {
> /*  629 */         HL[tail--] = k;
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  633 */     while (head != 0 && tail != prob.length - 1) {
> /*  634 */       int i1 = HL[tail + 1];
> /*  635 */       int i2 = HL[head - 1];
> /*  636 */       a[i1] = i2;
> /*  637 */       q[i2] = q[i2] + q[i1] - 1.0D;
> /*  638 */       tail++;
> /*  639 */       if (q[i2] < 1.0D) {
> /*  640 */         HL[tail--] = i2;
> /*  641 */         head--;
> /*      */       } 
> /*      */     } 
> /*      */ 
> /*      */     
> /*  646 */     int[] ans = new int[n];
> /*  647 */     for (int m = 0; m < n; m++) {
> /*  648 */       double rU = random() * prob.length;
> /*      */       
> /*  650 */       int i1 = (int)rU;
> /*  651 */       rU -= i1;
> /*      */       
> /*  653 */       if (rU < q[i1]) {
> /*  654 */         ans[m] = i1;
> /*      */       } else {
> /*  656 */         ans[m] = a[i1];
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  660 */     return ans;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double random() {
> /*  668 */     return ((RandomModified)random.get()).nextDouble();
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] random(int n) {
> /*  677 */     double[] x = new double[n];
> /*  678 */     ((RandomModified)random.get()).nextDoubles(x);
> /*  679 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double random(double lo, double hi) {
> /*  690 */     return ((RandomModified)random.get()).nextDouble(lo, hi);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] random(double lo, double hi, int n) {
> /*  702 */     double[] x = new double[n];
> /*  703 */     ((RandomModified)random.get()).nextDoubles(x, lo, hi);
> /*  704 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static long randomLong() {
> /*  712 */     return ((RandomModified)random.get()).nextLong();
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int randomInt(int n) {
> /*  721 */     return ((RandomModified)random.get()).nextInt(n);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int randomInt(int lo, int hi) {
> /*  732 */     int w = hi - lo;
> /*  733 */     return lo + ((RandomModified)random.get()).nextInt(w);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] permutate(int n) {
> /*  743 */     return ((RandomModified)random.get()).permutate(n);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void permutate(int[] x) {
> /*  751 */     ((RandomModified)random.get()).permutate(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void permutate(float[] x) {
> /*  759 */     ((RandomModified)random.get()).permutate(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void permutate(double[] x) {
> /*  767 */     ((RandomModified)random.get()).permutate(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void permutate(Object[] x) {
> /*  775 */     ((RandomModified)random.get()).permutate(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int softmax(double[] posteriori) {
> /*  794 */     return softmax(posteriori, posteriori.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int softmax(double[] x, int k) {
> /*  814 */     int y = -1;
> /*  815 */     double max = Double.NEGATIVE_INFINITY;
> /*  816 */     for (int i = 0; i < k; i++) {
> /*  817 */       if (x[i] > max) {
> /*  818 */         max = x[i];
> /*  819 */         y = i;
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  823 */     double Z = 0.0D; int j;
> /*  824 */     for (j = 0; j < k; j++) {
> /*  825 */       double out = Math.exp(x[j] - max);
> /*  826 */       x[j] = out;
> /*  827 */       Z += out;
> /*      */     } 
> /*      */     
> /*  830 */     for (j = 0; j < k; j++) {
> /*  831 */       x[j] = x[j] / Z;
> /*      */     }
> /*      */     
> /*  834 */     return y;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] c(int... x) {
> /*  843 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float[] c(float... x) {
> /*  852 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] c(double... x) {
> /*  861 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static String[] c(String... x) {
> /*  870 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] c(int[]... list) {
> /*  879 */     int n = 0; byte b1; int i, arrayOfInt1[][];
> /*  880 */     for (i = (arrayOfInt1 = list).length, b1 = 0; b1 < i; ) { int[] x = arrayOfInt1[b1]; n += x.length; b1++; }
> /*  881 */      int[] y = new int[n];
> /*  882 */     int pos = 0; byte b2; int j, arrayOfInt2[][];
> /*  883 */     for (j = (arrayOfInt2 = list).length, b2 = 0; b2 < j; ) { int[] x = arrayOfInt2[b2];
> /*  884 */       System.arraycopy(x, 0, y, pos, x.length);
> /*  885 */       pos += x.length; b2++; }
> /*      */     
> /*  887 */     return y;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float[] c(float[]... list) {
> /*  896 */     int n = 0; byte b1; int i; float[][] arrayOfFloat1;
> /*  897 */     for (i = (arrayOfFloat1 = list).length, b1 = 0; b1 < i; ) { float[] x = arrayOfFloat1[b1]; n += x.length; b1++; }
> /*  898 */      float[] y = new float[n];
> /*  899 */     int pos = 0; byte b2; int j; float[][] arrayOfFloat2;
> /*  900 */     for (j = (arrayOfFloat2 = list).length, b2 = 0; b2 < j; ) { float[] x = arrayOfFloat2[b2];
> /*  901 */       System.arraycopy(x, 0, y, pos, x.length);
> /*  902 */       pos += x.length; b2++; }
> /*      */     
> /*  904 */     return y;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] c(double[]... list) {
> /*  913 */     int n = 0; byte b1; int i; double[][] arrayOfDouble1;
> /*  914 */     for (i = (arrayOfDouble1 = list).length, b1 = 0; b1 < i; ) { double[] x = arrayOfDouble1[b1]; n += x.length; b1++; }
> /*  915 */      double[] y = new double[n];
> /*  916 */     int pos = 0; byte b2; int j; double[][] arrayOfDouble2;
> /*  917 */     for (j = (arrayOfDouble2 = list).length, b2 = 0; b2 < j; ) { double[] x = arrayOfDouble2[b2];
> /*  918 */       System.arraycopy(x, 0, y, pos, x.length);
> /*  919 */       pos += x.length; b2++; }
> /*      */     
> /*  921 */     return y;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static String[] c(String[]... list) {
> /*  930 */     int n = 0; byte b1; int i; String[][] arrayOfString1;
> /*  931 */     for (i = (arrayOfString1 = list).length, b1 = 0; b1 < i; ) { String[] x = arrayOfString1[b1]; n += x.length; b1++; }
> /*  932 */      String[] y = new String[n];
> /*  933 */     int pos = 0; byte b2; int j; String[][] arrayOfString2;
> /*  934 */     for (j = (arrayOfString2 = list).length, b2 = 0; b2 < j; ) { String[] x = arrayOfString2[b2];
> /*  935 */       System.arraycopy(x, 0, y, pos, x.length);
> /*  936 */       pos += x.length; b2++; }
> /*      */     
> /*  938 */     return y;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] cbind(int[]... x) {
> /*  947 */     return c(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float[] cbind(float[]... x) {
> /*  956 */     return c(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] cbind(double[]... x) {
> /*  965 */     return c(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static String[] cbind(String[]... x) {
> /*  974 */     return c(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[][] rbind(int[]... x) {
> /*  983 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float[][] rbind(float[]... x) {
> /*  992 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[][] rbind(double[]... x) {
> /* 1001 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static String[][] rbind(String[]... x) {
> /* 1010 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <E> E[] slice(Object[] data, int[] index) {
> /* 1021 */     int n = index.length;
> /*      */ 
> /*      */     
> /* 1024 */     Object[] x = (Object[])Array.newInstance(data.getClass().getComponentType(), n);
> /*      */     
> /* 1026 */     for (int i = 0; i < n; i++) {
> /* 1027 */       x[i] = data[index[i]];
> /*      */     }
> /*      */     
> /* 1030 */     return (E[])x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] slice(int[] data, int[] index) {
> /* 1040 */     int n = index.length;
> /* 1041 */     int[] x = new int[n];
> /* 1042 */     for (int i = 0; i < n; i++) {
> /* 1043 */       x[i] = data[index[i]];
> /*      */     }
> /*      */     
> /* 1046 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float[] slice(float[] data, int[] index) {
> /* 1056 */     int n = index.length;
> /* 1057 */     float[] x = new float[n];
> /* 1058 */     for (int i = 0; i < n; i++) {
> /* 1059 */       x[i] = data[index[i]];
> /*      */     }
> /*      */     
> /* 1062 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] slice(double[] data, int[] index) {
> /* 1072 */     int n = index.length;
> /* 1073 */     double[] x = new double[n];
> /* 1074 */     for (int i = 0; i < n; i++) {
> /* 1075 */       x[i] = data[index[i]];
> /*      */     }
> /*      */     
> /* 1078 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean contains(double[][] polygon, double[] point) {
> /* 1089 */     return contains(polygon, point[0], point[1]);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean contains(double[][] polygon, double x, double y) {
> /* 1101 */     if (polygon.length <= 2) {
> /* 1102 */       return false;
> /*      */     }
> /*      */     
> /* 1105 */     int hits = 0;
> /*      */     
> /* 1107 */     int n = polygon.length;
> /* 1108 */     double lastx = polygon[n - 1][0];
> /* 1109 */     double lasty = polygon[n - 1][1];
> /*      */     
> /*      */     Object object1, object2;
> /*      */     
> /* 1113 */     for (int i = 0; i < n; object1 = SYNTHETIC_LOCAL_VARIABLE_11, object2 = SYNTHETIC_LOCAL_VARIABLE_13, i++) {
> /* 1114 */       Object object; double curx = polygon[i][0];
> /* 1115 */       double cury = polygon[i][1];
> /*      */       
> /* 1117 */       if (cury == object2) {
> /*      */         continue;
> /*      */       }
> /*      */ 
> /*      */       
> /* 1122 */       if (curx < object1) {
> /* 1123 */         if (x >= object1) {
> /*      */           continue;
> /*      */         }
> /* 1126 */         double leftx = curx;
> /*      */       } else {
> /* 1128 */         if (x >= curx) {
> /*      */           continue;
> /*      */         }
> /* 1131 */         object = object1;
> /*      */       } 
> /*      */ 
> /*      */       
> /* 1135 */       if (cury < object2)
> /* 1136 */       { if (y >= cury && y < object2)
> /*      */         {
> /*      */           
> /* 1139 */           if (x < object)
> /* 1140 */           { hits++; }
> /*      */           else
> /*      */           
> /* 1143 */           { double test1 = x - curx;
> /* 1144 */             double test2 = y - cury;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */             
> /* 1157 */             if (test1 < test2 / (object2 - cury) * (object1 - curx))
> /* 1158 */               hits++;  }  }  } else if (y >= object2 && y < cury) { if (x < object) { hits++; } else { double test1 = x - object1; double test2 = y - object2; if (test1 < test2 / (object2 - cury) * (object1 - curx)) hits++;  }
> /*      */          }
> /*      */        continue;
> /*      */     } 
> /* 1162 */     return ((hits & 0x1) != 0);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] omit(int[] a, int value) {
> /* 1172 */     int n = 0; byte b1; int j, arrayOfInt1[];
> /* 1173 */     for (j = (arrayOfInt1 = a).length, b1 = 0; b1 < j; ) { int x = arrayOfInt1[b1];
> /* 1174 */       if (x != value) n++; 
> /*      */       b1++; }
> /*      */     
> /* 1177 */     int i = 0;
> /* 1178 */     int[] b = new int[n]; byte b2; int k, arrayOfInt2[];
> /* 1179 */     for (k = (arrayOfInt2 = a).length, b2 = 0; b2 < k; ) { int x = arrayOfInt2[b2];
> /* 1180 */       if (x != value) b[i++] = x; 
> /*      */       b2++; }
> /*      */     
> /* 1183 */     return b;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float[] omit(float[] a, float value) {
> /* 1194 */     int n = 0; byte b1; int j; float[] arrayOfFloat1;
> /* 1195 */     for (j = (arrayOfFloat1 = a).length, b1 = 0; b1 < j; ) { float x = arrayOfFloat1[b1];
> /* 1196 */       if (x != value) n++; 
> /*      */       b1++; }
> /*      */     
> /* 1199 */     int i = 0;
> /* 1200 */     float[] b = new float[n]; byte b2; int k; float[] arrayOfFloat2;
> /* 1201 */     for (k = (arrayOfFloat2 = a).length, b2 = 0; b2 < k; ) { float x = arrayOfFloat2[b2];
> /* 1202 */       if (x != value) b[i++] = x; 
> /*      */       b2++; }
> /*      */     
> /* 1205 */     return b;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] omit(double[] a, double value) {
> /* 1215 */     int n = 0; byte b1; int j; double[] arrayOfDouble1;
> /* 1216 */     for (j = (arrayOfDouble1 = a).length, b1 = 0; b1 < j; ) { double x = arrayOfDouble1[b1];
> /* 1217 */       if (x != value) n++; 
> /*      */       b1++; }
> /*      */     
> /* 1220 */     int i = 0;
> /* 1221 */     double[] b = new double[n]; byte b2; int k; double[] arrayOfDouble2;
> /* 1222 */     for (k = (arrayOfDouble2 = a).length, b2 = 0; b2 < k; ) { double x = arrayOfDouble2[b2];
> /* 1223 */       if (x != value) b[i++] = x; 
> /*      */       b2++; }
> /*      */     
> /* 1226 */     return b;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float[] omitNaN(float[] a) {
> /* 1235 */     int n = 0; byte b1; int j; float[] arrayOfFloat1;
> /* 1236 */     for (j = (arrayOfFloat1 = a).length, b1 = 0; b1 < j; ) { float x = arrayOfFloat1[b1];
> /* 1237 */       if (!Float.isNaN(x)) n++; 
> /*      */       b1++; }
> /*      */     
> /* 1240 */     int i = 0;
> /* 1241 */     float[] b = new float[n]; byte b2; int k; float[] arrayOfFloat2;
> /* 1242 */     for (k = (arrayOfFloat2 = a).length, b2 = 0; b2 < k; ) { float x = arrayOfFloat2[b2];
> /* 1243 */       if (!Float.isNaN(x)) b[i++] = x; 
> /*      */       b2++; }
> /*      */     
> /* 1246 */     return b;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] omitNaN(double[] a) {
> /* 1255 */     int n = 0; byte b1; int j; double[] arrayOfDouble1;
> /* 1256 */     for (j = (arrayOfDouble1 = a).length, b1 = 0; b1 < j; ) { double x = arrayOfDouble1[b1];
> /* 1257 */       if (!Double.isNaN(x)) n++; 
> /*      */       b1++; }
> /*      */     
> /* 1260 */     int i = 0;
> /* 1261 */     double[] b = new double[n]; byte b2; int k; double[] arrayOfDouble2;
> /* 1262 */     for (k = (arrayOfDouble2 = a).length, b2 = 0; b2 < k; ) { double x = arrayOfDouble2[b2];
> /* 1263 */       if (!Double.isNaN(x)) b[i++] = x; 
> /*      */       b2++; }
> /*      */     
> /* 1266 */     return b;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void reverse(int[] a) {
> /* 1274 */     int i = 0, j = a.length - 1;
> /* 1275 */     while (i < j) {
> /* 1276 */       SortModified.swap(a, i++, j--);
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void reverse(float[] a) {
> /* 1285 */     int i = 0, j = a.length - 1;
> /* 1286 */     while (i < j) {
> /* 1287 */       SortModified.swap(a, i++, j--);
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void reverse(double[] a) {
> /* 1296 */     int i = 0, j = a.length - 1;
> /* 1297 */     while (i < j) {
> /* 1298 */       SortModified.swap(a, i++, j--);
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <T> void reverse(Object[] a) {
> /* 1308 */     int i = 0, j = a.length - 1;
> /* 1309 */     while (i < j) {
> /* 1310 */       SortModified.swap(a, i++, j--);
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int mode(int[] a) {
> /* 1322 */     Arrays.sort(a);
> /*      */     
> /* 1324 */     int mode = -1;
> /* 1325 */     int count = 0;
> /*      */     
> /* 1327 */     int currentValue = a[0];
> /* 1328 */     int currentCount = 1;
> /*      */     
> /* 1330 */     for (int i = 1; i < a.length; i++) {
> /* 1331 */       if (a[i] != currentValue) {
> /* 1332 */         if (currentCount > count) {
> /* 1333 */           mode = currentValue;
> /* 1334 */           count = currentCount;
> /*      */         } 
> /*      */         
> /* 1337 */         currentValue = a[i];
> /* 1338 */         currentCount = 1;
> /*      */       } else {
> /* 1340 */         currentCount++;
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1344 */     if (currentCount > count) {
> /* 1345 */       mode = currentValue;
> /*      */     }
> /*      */     
> /* 1348 */     return mode;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int min(int a, int b, int c) {
> /* 1359 */     return Math.min(Math.min(a, b), c);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float min(float a, float b, float c) {
> /* 1370 */     return Math.min(Math.min(a, b), c);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double min(double a, double b, double c) {
> /* 1381 */     return Math.min(Math.min(a, b), c);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int min(int a, int b, int c, int d) {
> /* 1393 */     return Math.min(Math.min(Math.min(a, b), c), d);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float min(float a, float b, float c, float d) {
> /* 1405 */     return Math.min(Math.min(Math.min(a, b), c), d);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double min(double a, double b, double c, double d) {
> /* 1417 */     return Math.min(Math.min(Math.min(a, b), c), d);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int max(int a, int b, int c) {
> /* 1428 */     return Math.max(Math.max(a, b), c);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float max(float a, float b, float c) {
> /* 1439 */     return Math.max(Math.max(a, b), c);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double max(double a, double b, double c) {
> /* 1450 */     return Math.max(Math.max(a, b), c);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int max(int a, int b, int c, int d) {
> /* 1462 */     return Math.max(Math.max(Math.max(a, b), c), d);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float max(float a, float b, float c, float d) {
> /* 1474 */     return Math.max(Math.max(Math.max(a, b), c), d);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double max(double a, double b, double c, double d) {
> /* 1486 */     return Math.max(Math.max(Math.max(a, b), c), d);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int min(int[] x) {
> /* 1495 */     int min = x[0]; byte b;
> /*      */     int i, arrayOfInt[];
> /* 1497 */     for (i = (arrayOfInt = x).length, b = 0; b < i; ) { int n = arrayOfInt[b];
> /* 1498 */       if (n < min) {
> /* 1499 */         min = n;
> /*      */       }
> /*      */       b++; }
> /*      */     
> /* 1503 */     return min;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float min(float[] x) {
> /* 1512 */     float min = Float.POSITIVE_INFINITY; byte b; int i;
> /*      */     float[] arrayOfFloat;
> /* 1514 */     for (i = (arrayOfFloat = x).length, b = 0; b < i; ) { float n = arrayOfFloat[b];
> /* 1515 */       if (n < min) {
> /* 1516 */         min = n;
> /*      */       }
> /*      */       b++; }
> /*      */     
> /* 1520 */     return min;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double min(double[] x) {
> /* 1529 */     double min = Double.POSITIVE_INFINITY; byte b; int i;
> /*      */     double[] arrayOfDouble;
> /* 1531 */     for (i = (arrayOfDouble = x).length, b = 0; b < i; ) { double n = arrayOfDouble[b];
> /* 1532 */       if (n < min) {
> /* 1533 */         min = n;
> /*      */       }
> /*      */       b++; }
> /*      */     
> /* 1537 */     return min;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int whichMin(int[] x) {
> /* 1546 */     int min = x[0];
> /* 1547 */     int which = 0;
> /*      */     
> /* 1549 */     for (int i = 1; i < x.length; i++) {
> /* 1550 */       if (x[i] < min) {
> /* 1551 */         min = x[i];
> /* 1552 */         which = i;
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1556 */     return which;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int whichMin(float[] x) {
> /* 1565 */     float min = Float.POSITIVE_INFINITY;
> /* 1566 */     int which = 0;
> /*      */     
> /* 1568 */     for (int i = 0; i < x.length; i++) {
> /* 1569 */       if (x[i] < min) {
> /* 1570 */         min = x[i];
> /* 1571 */         which = i;
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1575 */     return which;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int whichMin(double[] x) {
> /* 1584 */     double min = Double.POSITIVE_INFINITY;
> /* 1585 */     int which = 0;
> /*      */     
> /* 1587 */     for (int i = 0; i < x.length; i++) {
> /* 1588 */       if (x[i] < min) {
> /* 1589 */         min = x[i];
> /* 1590 */         which = i;
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1594 */     return which;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int max(int[] x) {
> /* 1603 */     int max = x[0]; byte b;
> /*      */     int i, arrayOfInt[];
> /* 1605 */     for (i = (arrayOfInt = x).length, b = 0; b < i; ) { int n = arrayOfInt[b];
> /* 1606 */       if (n > max) {
> /* 1607 */         max = n;
> /*      */       }
> /*      */       b++; }
> /*      */     
> /* 1611 */     return max;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float max(float[] x) {
> /* 1620 */     float max = Float.NEGATIVE_INFINITY; byte b; int i;
> /*      */     float[] arrayOfFloat;
> /* 1622 */     for (i = (arrayOfFloat = x).length, b = 0; b < i; ) { float n = arrayOfFloat[b];
> /* 1623 */       if (n > max) {
> /* 1624 */         max = n;
> /*      */       }
> /*      */       b++; }
> /*      */     
> /* 1628 */     return max;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double max(double[] x) {
> /* 1637 */     double max = Double.NEGATIVE_INFINITY; byte b; int i;
> /*      */     double[] arrayOfDouble;
> /* 1639 */     for (i = (arrayOfDouble = x).length, b = 0; b < i; ) { double n = arrayOfDouble[b];
> /* 1640 */       if (n > max) {
> /* 1641 */         max = n;
> /*      */       }
> /*      */       b++; }
> /*      */     
> /* 1645 */     return max;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int whichMax(int[] x) {
> /* 1654 */     int max = x[0];
> /* 1655 */     int which = 0;
> /*      */     
> /* 1657 */     for (int i = 1; i < x.length; i++) {
> /* 1658 */       if (x[i] > max) {
> /* 1659 */         max = x[i];
> /* 1660 */         which = i;
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1664 */     return which;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int whichMax(float[] x) {
> /* 1673 */     float max = Float.NEGATIVE_INFINITY;
> /* 1674 */     int which = 0;
> /*      */     
> /* 1676 */     for (int i = 0; i < x.length; i++) {
> /* 1677 */       if (x[i] > max) {
> /* 1678 */         max = x[i];
> /* 1679 */         which = i;
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1683 */     return which;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int whichMax(double[] x) {
> /* 1692 */     double max = Double.NEGATIVE_INFINITY;
> /* 1693 */     int which = 0;
> /*      */     
> /* 1695 */     for (int i = 0; i < x.length; i++) {
> /* 1696 */       if (x[i] > max) {
> /* 1697 */         max = x[i];
> /* 1698 */         which = i;
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1702 */     return which;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int min(int[][] matrix) {
> /* 1711 */     int min = matrix[0][0]; byte b;
> /*      */     int i, arrayOfInt[][];
> /* 1713 */     for (i = (arrayOfInt = matrix).length, b = 0; b < i; ) { int[] x = arrayOfInt[b]; byte b1; int j, arrayOfInt1[];
> /* 1714 */       for (j = (arrayOfInt1 = x).length, b1 = 0; b1 < j; ) { int y = arrayOfInt1[b1];
> /* 1715 */         if (min > y)
> /* 1716 */           min = y; 
> /*      */         b1++; }
> /*      */       
> /*      */       b++; }
> /*      */     
> /* 1721 */     return min;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double min(double[][] matrix) {
> /* 1730 */     double min = Double.POSITIVE_INFINITY; byte b; int i;
> /*      */     double[][] arrayOfDouble;
> /* 1732 */     for (i = (arrayOfDouble = matrix).length, b = 0; b < i; ) { double[] x = arrayOfDouble[b]; byte b1; int j; double[] arrayOfDouble1;
> /* 1733 */       for (j = (arrayOfDouble1 = x).length, b1 = 0; b1 < j; ) { double y = arrayOfDouble1[b1];
> /* 1734 */         if (min > y)
> /* 1735 */           min = y; 
> /*      */         b1++; }
> /*      */       
> /*      */       b++; }
> /*      */     
> /* 1740 */     return min;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int max(int[][] matrix) {
> /* 1749 */     int max = matrix[0][0]; byte b;
> /*      */     int i, arrayOfInt[][];
> /* 1751 */     for (i = (arrayOfInt = matrix).length, b = 0; b < i; ) { int[] x = arrayOfInt[b]; byte b1; int j, arrayOfInt1[];
> /* 1752 */       for (j = (arrayOfInt1 = x).length, b1 = 0; b1 < j; ) { int y = arrayOfInt1[b1];
> /* 1753 */         if (max < y)
> /* 1754 */           max = y; 
> /*      */         b1++; }
> /*      */       
> /*      */       b++; }
> /*      */     
> /* 1759 */     return max;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double max(double[][] matrix) {
> /* 1768 */     double max = Double.NEGATIVE_INFINITY; byte b; int i;
> /*      */     double[][] arrayOfDouble;
> /* 1770 */     for (i = (arrayOfDouble = matrix).length, b = 0; b < i; ) { double[] x = arrayOfDouble[b]; byte b1; int j; double[] arrayOfDouble1;
> /* 1771 */       for (j = (arrayOfDouble1 = x).length, b1 = 0; b1 < j; ) { double y = arrayOfDouble1[b1];
> /* 1772 */         if (max < y)
> /* 1773 */           max = y; 
> /*      */         b1++; }
> /*      */       
> /*      */       b++; }
> /*      */     
> /* 1778 */     return max;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static IntPair whichMin(double[][] matrix) {
> /* 1787 */     double min = Double.POSITIVE_INFINITY;
> /* 1788 */     int whichRow = 0;
> /* 1789 */     int whichCol = 0;
> /*      */     
> /* 1791 */     for (int i = 0; i < matrix.length; i++) {
> /* 1792 */       for (int j = 0; j < (matrix[i]).length; j++) {
> /* 1793 */         if (matrix[i][j] < min) {
> /* 1794 */           min = matrix[i][j];
> /* 1795 */           whichRow = i;
> /* 1796 */           whichCol = j;
> /*      */         } 
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1801 */     return new IntPair(whichRow, whichCol);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static IntPair whichMax(double[][] matrix) {
> /* 1810 */     double max = Double.NEGATIVE_INFINITY;
> /* 1811 */     int whichRow = 0;
> /* 1812 */     int whichCol = 0;
> /*      */     
> /* 1814 */     for (int i = 0; i < matrix.length; i++) {
> /* 1815 */       for (int j = 0; j < (matrix[i]).length; j++) {
> /* 1816 */         if (matrix[i][j] > max) {
> /* 1817 */           max = matrix[i][j];
> /* 1818 */           whichRow = i;
> /* 1819 */           whichCol = j;
> /*      */         } 
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1824 */     return new IntPair(whichRow, whichCol);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[][] transpose(double[][] matrix) {
> /* 1833 */     int m = matrix.length;
> /* 1834 */     int n = (matrix[0]).length;
> /*      */     
> /* 1836 */     double[][] t = new double[n][m];
> /* 1837 */     for (int i = 0; i < m; i++) {
> /* 1838 */       for (int j = 0; j < n; j++) {
> /* 1839 */         t[j][i] = matrix[i][j];
> /*      */       }
> /*      */     } 
> /*      */     
> /* 1843 */     return t;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] rowMin(int[][] matrix) {
> /* 1852 */     int[] x = new int[matrix.length];
> /*      */     
> /* 1854 */     for (int i = 0; i < x.length; i++) {
> /* 1855 */       x[i] = min(matrix[i]);
> /*      */     }
> /*      */     
> /* 1858 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] rowMax(int[][] matrix) {
> /* 1867 */     int[] x = new int[matrix.length];
> /*      */     
> /* 1869 */     for (int i = 0; i < x.length; i++) {
> /* 1870 */       x[i] = max(matrix[i]);
> /*      */     }
> /*      */     
> /* 1873 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static long[] rowSums(int[][] matrix) {
> /* 1882 */     long[] x = new long[matrix.length];
> /*      */     
> /* 1884 */     for (int i = 0; i < x.length; i++) {
> /* 1885 */       x[i] = sum(matrix[i]);
> /*      */     }
> /*      */     
> /* 1888 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] rowMin(double[][] matrix) {
> /* 1897 */     double[] x = new double[matrix.length];
> /*      */     
> /* 1899 */     for (int i = 0; i < x.length; i++) {
> /* 1900 */       x[i] = min(matrix[i]);
> /*      */     }
> /*      */     
> /* 1903 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] rowMax(double[][] matrix) {
> /* 1912 */     double[] x = new double[matrix.length];
> /*      */     
> /* 1914 */     for (int i = 0; i < x.length; i++) {
> /* 1915 */       x[i] = max(matrix[i]);
> /*      */     }
> /*      */     
> /* 1918 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] rowSums(double[][] matrix) {
> /* 1927 */     double[] x = new double[matrix.length];
> /*      */     
> /* 1929 */     for (int i = 0; i < x.length; i++) {
> /* 1930 */       x[i] = sum(matrix[i]);
> /*      */     }
> /*      */     
> /* 1933 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] rowMeans(double[][] matrix) {
> /* 1942 */     double[] x = new double[matrix.length];
> /*      */     
> /* 1944 */     for (int i = 0; i < x.length; i++) {
> /* 1945 */       x[i] = mean(matrix[i]);
> /*      */     }
> /*      */     
> /* 1948 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] rowSds(double[][] matrix) {
> /* 1957 */     double[] x = new double[matrix.length];
> /*      */     
> /* 1959 */     for (int i = 0; i < x.length; i++) {
> /* 1960 */       x[i] = sd(matrix[i]);
> /*      */     }
> /*      */     
> /* 1963 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] colMin(int[][] matrix) {
> /* 1972 */     int[] x = new int[(matrix[0]).length];
> /* 1973 */     Arrays.fill(x, 2147483647); byte b;
> /*      */     int i, arrayOfInt[][];
> /* 1975 */     for (i = (arrayOfInt = matrix).length, b = 0; b < i; ) { int[] row = arrayOfInt[b];
> /* 1976 */       for (int j = 0; j < x.length; j++) {
> /* 1977 */         if (x[j] > row[j]) {
> /* 1978 */           x[j] = row[j];
> /*      */         }
> /*      */       } 
> /*      */       b++; }
> /*      */     
> /* 1983 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] colMax(int[][] matrix) {
> /* 1992 */     int[] x = new int[(matrix[0]).length];
> /* 1993 */     Arrays.fill(x, -2147483648); byte b;
> /*      */     int i, arrayOfInt[][];
> /* 1995 */     for (i = (arrayOfInt = matrix).length, b = 0; b < i; ) { int[] row = arrayOfInt[b];
> /* 1996 */       for (int j = 0; j < x.length; j++) {
> /* 1997 */         if (x[j] < row[j]) {
> /* 1998 */           x[j] = row[j];
> /*      */         }
> /*      */       } 
> /*      */       b++; }
> /*      */     
> /* 2003 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static long[] colSums(int[][] matrix) {
> /* 2012 */     long[] x = new long[(matrix[0]).length]; byte b;
> /*      */     int i, arrayOfInt[][];
> /* 2014 */     for (i = (arrayOfInt = matrix).length, b = 0; b < i; ) { int[] row = arrayOfInt[b];
> /* 2015 */       for (int j = 0; j < x.length; j++) {
> /* 2016 */         x[j] = x[j] + row[j];
> /*      */       }
> /*      */       b++; }
> /*      */     
> /* 2020 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] colMin(double[][] matrix) {
> /* 2029 */     double[] x = new double[(matrix[0]).length];
> /* 2030 */     Arrays.fill(x, Double.POSITIVE_INFINITY); byte b; int i;
> /*      */     double[][] arrayOfDouble;
> /* 2032 */     for (i = (arrayOfDouble = matrix).length, b = 0; b < i; ) { double[] row = arrayOfDouble[b];
> /* 2033 */       for (int j = 0; j < x.length; j++) {
> /* 2034 */         if (x[j] > row[j]) {
> /* 2035 */           x[j] = row[j];
> /*      */         }
> /*      */       } 
> /*      */       b++; }
> /*      */     
> /* 2040 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] colMax(double[][] matrix) {
> /* 2049 */     double[] x = new double[(matrix[0]).length];
> /* 2050 */     Arrays.fill(x, Double.NEGATIVE_INFINITY); byte b; int i;
> /*      */     double[][] arrayOfDouble;
> /* 2052 */     for (i = (arrayOfDouble = matrix).length, b = 0; b < i; ) { double[] row = arrayOfDouble[b];
> /* 2053 */       for (int j = 0; j < x.length; j++) {
> /* 2054 */         if (x[j] < row[j]) {
> /* 2055 */           x[j] = row[j];
> /*      */         }
> /*      */       } 
> /*      */       b++; }
> /*      */     
> /* 2060 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] colSums(double[][] matrix) {
> /* 2069 */     double[] x = (double[])matrix[0].clone();
> /*      */     
> /* 2071 */     for (int i = 1; i < matrix.length; i++) {
> /* 2072 */       for (int j = 0; j < x.length; j++) {
> /* 2073 */         x[j] = x[j] + matrix[i][j];
> /*      */       }
> /*      */     } 
> /*      */     
> /* 2077 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] colMeans(double[][] matrix) {
> /* 2086 */     double[] x = (double[])matrix[0].clone();
> /*      */     
> /* 2088 */     for (int i = 1; i < matrix.length; i++) {
> /* 2089 */       for (int j = 0; j < x.length; j++) {
> /* 2090 */         x[j] = x[j] + matrix[i][j];
> /*      */       }
> /*      */     } 
> /*      */     
> /* 2094 */     scale(1.0D / matrix.length, x);
> /*      */     
> /* 2096 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] colSds(double[][] matrix) {
> /* 2105 */     if (matrix.length < 2) {
> /* 2106 */       throw new IllegalArgumentException("matrix length is less than 2.");
> /*      */     }
> /*      */     
> /* 2109 */     int p = (matrix[0]).length;
> /* 2110 */     double[] sum = new double[p];
> /* 2111 */     double[] sumsq = new double[p]; byte b; int j; double[][] arrayOfDouble;
> /* 2112 */     for (j = (arrayOfDouble = matrix).length, b = 0; b < j; ) { double[] row = arrayOfDouble[b];
> /* 2113 */       for (int k = 0; k < p; k++) {
> /* 2114 */         sum[k] = sum[k] + row[k];
> /* 2115 */         sumsq[k] = sumsq[k] + row[k] * row[k];
> /*      */       } 
> /*      */       b++; }
> /*      */     
> /* 2119 */     int n = matrix.length - 1;
> /* 2120 */     for (int i = 0; i < p; i++) {
> /* 2121 */       sumsq[i] = Math.sqrt(sumsq[i] / n - sum[i] / matrix.length * sum[i] / n);
> /*      */     }
> /*      */     
> /* 2124 */     return sumsq;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int sum(byte[] x) {
> /* 2133 */     int sum = 0; byte b; int i;
> /*      */     byte[] arrayOfByte;
> /* 2135 */     for (i = (arrayOfByte = x).length, b = 0; b < i; ) { int n = arrayOfByte[b];
> /* 2136 */       sum += n;
> /*      */       b++; }
> /*      */     
> /* 2139 */     return sum;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static long sum(int[] x) {
> /* 2148 */     long sum = 0L; byte b;
> /*      */     int i, arrayOfInt[];
> /* 2150 */     for (i = (arrayOfInt = x).length, b = 0; b < i; ) { int n = arrayOfInt[b];
> /* 2151 */       sum += n;
> /*      */       b++; }
> /*      */     
> /* 2154 */     return (int)sum;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double sum(float[] x) {
> /* 2163 */     double sum = 0.0D; byte b; int i;
> /*      */     float[] arrayOfFloat;
> /* 2165 */     for (i = (arrayOfFloat = x).length, b = 0; b < i; ) { float n = arrayOfFloat[b];
> /* 2166 */       sum += n;
> /*      */       b++; }
> /*      */     
> /* 2169 */     return sum;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double sum(double[] x) {
> /* 2178 */     double sum = 0.0D; byte b; int i;
> /*      */     double[] arrayOfDouble;
> /* 2180 */     for (i = (arrayOfDouble = x).length, b = 0; b < i; ) { double n = arrayOfDouble[b];
> /* 2181 */       sum += n;
> /*      */       b++; }
> /*      */     
> /* 2184 */     return sum;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int median(int[] x) {
> /* 2194 */     return QuickSelectModified.median(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float median(float[] x) {
> /* 2204 */     return QuickSelectModified.median(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double median(double[] x) {
> /* 2214 */     return QuickSelectModified.median(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <T extends Comparable<? super T>> T median(Comparable[] x) {
> /* 2225 */     return QuickSelectModified.median((T[])x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int q1(int[] x) {
> /* 2235 */     return QuickSelectModified.q1(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float q1(float[] x) {
> /* 2245 */     return QuickSelectModified.q1(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double q1(double[] x) {
> /* 2255 */     return QuickSelectModified.q1(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <T extends Comparable<? super T>> T q1(Comparable[] x) {
> /* 2266 */     return QuickSelectModified.q1((T[])x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int q3(int[] x) {
> /* 2276 */     return QuickSelectModified.q3(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float q3(float[] x) {
> /* 2286 */     return QuickSelectModified.q3(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double q3(double[] x) {
> /* 2296 */     return QuickSelectModified.q3(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <T extends Comparable<? super T>> T q3(Comparable[] x) {
> /* 2307 */     return QuickSelectModified.q3((T[])x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double mean(int[] x) {
> /* 2316 */     return sum(x) / x.length;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double mean(float[] x) {
> /* 2325 */     return sum(x) / x.length;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double mean(double[] x) {
> /* 2334 */     return sum(x) / x.length;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double var(int[] x) {
> /* 2343 */     if (x.length < 2) {
> /* 2344 */       throw new IllegalArgumentException("Array length is less than 2.");
> /*      */     }
> /*      */     
> /* 2347 */     double sum = 0.0D;
> /* 2348 */     double sumsq = 0.0D; byte b; int i, arrayOfInt[];
> /* 2349 */     for (i = (arrayOfInt = x).length, b = 0; b < i; ) { int xi = arrayOfInt[b];
> /* 2350 */       sum += xi;
> /* 2351 */       sumsq += (xi * xi);
> /*      */       b++; }
> /*      */     
> /* 2354 */     int n = x.length - 1;
> /* 2355 */     return sumsq / n - sum / x.length * sum / n;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double var(float[] x) {
> /* 2364 */     if (x.length < 2) {
> /* 2365 */       throw new IllegalArgumentException("Array length is less than 2.");
> /*      */     }
> /*      */     
> /* 2368 */     double sum = 0.0D;
> /* 2369 */     double sumsq = 0.0D; byte b; int i; float[] arrayOfFloat;
> /* 2370 */     for (i = (arrayOfFloat = x).length, b = 0; b < i; ) { float xi = arrayOfFloat[b];
> /* 2371 */       sum += xi;
> /* 2372 */       sumsq += (xi * xi);
> /*      */       b++; }
> /*      */     
> /* 2375 */     int n = x.length - 1;
> /* 2376 */     return sumsq / n - sum / x.length * sum / n;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double var(double[] x) {
> /* 2385 */     if (x.length < 2) {
> /* 2386 */       throw new IllegalArgumentException("Array length is less than 2.");
> /*      */     }
> /*      */     
> /* 2389 */     double sum = 0.0D;
> /* 2390 */     double sumsq = 0.0D; byte b; int i; double[] arrayOfDouble;
> /* 2391 */     for (i = (arrayOfDouble = x).length, b = 0; b < i; ) { double xi = arrayOfDouble[b];
> /* 2392 */       sum += xi;
> /* 2393 */       sumsq += xi * xi;
> /*      */       b++; }
> /*      */     
> /* 2396 */     int n = x.length - 1;
> /* 2397 */     return sumsq / n - sum / x.length * sum / n;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double sd(int[] x) {
> /* 2406 */     return Math.sqrt(var(x));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double sd(float[] x) {
> /* 2415 */     return Math.sqrt(var(x));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double sd(double[] x) {
> /* 2424 */     return Math.sqrt(var(x));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double mad(int[] x) {
> /* 2455 */     int m = median(x);
> /* 2456 */     for (int i = 0; i < x.length; i++) {
> /* 2457 */       x[i] = Math.abs(x[i] - m);
> /*      */     }
> /*      */     
> /* 2460 */     return median(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double mad(float[] x) {
> /* 2491 */     float m = median(x);
> /* 2492 */     for (int i = 0; i < x.length; i++) {
> /* 2493 */       x[i] = Math.abs(x[i] - m);
> /*      */     }
> /*      */     
> /* 2496 */     return median(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double mad(double[] x) {
> /* 2527 */     double m = median(x);
> /* 2528 */     for (int i = 0; i < x.length; i++) {
> /* 2529 */       x[i] = Math.abs(x[i] - m);
> /*      */     }
> /*      */     
> /* 2532 */     return median(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double distance(int[] x, int[] y) {
> /* 2544 */     return Math.sqrt(squaredDistance(x, y));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double distance(float[] x, float[] y) {
> /* 2555 */     return Math.sqrt(squaredDistance(x, y));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double distance(double[] x, double[] y) {
> /* 2566 */     return Math.sqrt(squaredDistance(x, y));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double distance(SparseArrayModified x, SparseArrayModified y) {
> /* 2577 */     return Math.sqrt(squaredDistance(x, y));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double squaredDistance(int[] x, int[] y) {
> /* 2589 */     double d = 0.0D;
> /*      */     
> /* 2591 */     int p1 = 0, p2 = 0;
> /* 2592 */     while (p1 < x.length && p2 < y.length) {
> /* 2593 */       int i1 = x[p1];
> /* 2594 */       int i2 = y[p2];
> /* 2595 */       if (i1 == i2) {
> /* 2596 */         p1++;
> /* 2597 */         p2++; continue;
> /* 2598 */       }  if (i1 > i2) {
> /* 2599 */         d++;
> /* 2600 */         p2++; continue;
> /*      */       } 
> /* 2602 */       d++;
> /* 2603 */       p1++;
> /*      */     } 
> /*      */ 
> /*      */     
> /* 2607 */     d += (x.length - p1);
> /* 2608 */     d += (y.length - p2);
> /*      */     
> /* 2610 */     return d;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double squaredDistance(float[] x, float[] y) {
> /*      */     double d0, d1, d2, d3;
> /* 2621 */     if (x.length != y.length) {
> /* 2622 */       throw new IllegalArgumentException("Input vector sizes are different.");
> /*      */     }
> /*      */     
> /* 2625 */     switch (x.length) {
> /*      */       case 2:
> /* 2627 */         d0 = x[0] - y[0];
> /* 2628 */         d1 = x[1] - y[1];
> /* 2629 */         return d0 * d0 + d1 * d1;
> /*      */ 
> /*      */       
> /*      */       case 3:
> /* 2633 */         d0 = x[0] - y[0];
> /* 2634 */         d1 = x[1] - y[1];
> /* 2635 */         d2 = x[2] - y[2];
> /* 2636 */         return d0 * d0 + d1 * d1 + d2 * d2;
> /*      */ 
> /*      */       
> /*      */       case 4:
> /* 2640 */         d0 = x[0] - y[0];
> /* 2641 */         d1 = x[1] - y[1];
> /* 2642 */         d2 = x[2] - y[2];
> /* 2643 */         d3 = x[3] - y[3];
> /* 2644 */         return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;
> /*      */     } 
> /*      */ 
> /*      */     
> /* 2648 */     double sum = 0.0D;
> /* 2649 */     for (int i = 0; i < x.length; i++) {
> /*      */       
> /* 2651 */       double d = x[i] - y[i];
> /* 2652 */       sum += d * d;
> /*      */     } 
> /*      */     
> /* 2655 */     return sum;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double squaredDistance(double[] x, double[] y) {
> /*      */     double d0, d1, d2, d3;
> /* 2666 */     if (x.length != y.length) {
> /* 2667 */       throw new IllegalArgumentException("Input vector sizes are different.");
> /*      */     }
> /*      */     
> /* 2670 */     switch (x.length) {
> /*      */       case 2:
> /* 2672 */         d0 = x[0] - y[0];
> /* 2673 */         d1 = x[1] - y[1];
> /* 2674 */         return d0 * d0 + d1 * d1;
> /*      */ 
> /*      */       
> /*      */       case 3:
> /* 2678 */         d0 = x[0] - y[0];
> /* 2679 */         d1 = x[1] - y[1];
> /* 2680 */         d2 = x[2] - y[2];
> /* 2681 */         return d0 * d0 + d1 * d1 + d2 * d2;
> /*      */ 
> /*      */       
> /*      */       case 4:
> /* 2685 */         d0 = x[0] - y[0];
> /* 2686 */         d1 = x[1] - y[1];
> /* 2687 */         d2 = x[2] - y[2];
> /* 2688 */         d3 = x[3] - y[3];
> /* 2689 */         return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;
> /*      */     } 
> /*      */ 
> /*      */     
> /* 2693 */     double sum = 0.0D;
> /* 2694 */     for (int i = 0; i < x.length; i++) {
> /* 2695 */       double d = x[i] - y[i];
> /* 2696 */       sum += d * d;
> /*      */     } 
> /*      */     
> /* 2699 */     return sum;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double squaredDistance(SparseArrayModified x, SparseArrayModified y) {
> /* 2710 */     Iterator<SparseArrayModified.Entry> it1 = x.iterator();
> /* 2711 */     Iterator<SparseArrayModified.Entry> it2 = y.iterator();
> /* 2712 */     SparseArrayModified.Entry e1 = it1.hasNext() ? it1.next() : null;
> /* 2713 */     SparseArrayModified.Entry e2 = it2.hasNext() ? it2.next() : null;
> /*      */     
> /* 2715 */     double sum = 0.0D;
> /* 2716 */     while (e1 != null && e2 != null) {
> /* 2717 */       if (e1.i == e2.i) {
> /* 2718 */         sum += pow2(e1.x - e2.x);
> /* 2719 */         e1 = it1.hasNext() ? it1.next() : null;
> /* 2720 */         e2 = it2.hasNext() ? it2.next() : null; continue;
> /* 2721 */       }  if (e1.i > e2.i) {
> /* 2722 */         sum += pow2(e2.x);
> /* 2723 */         e2 = it2.hasNext() ? it2.next() : null; continue;
> /*      */       } 
> /* 2725 */       sum += pow2(e1.x);
> /* 2726 */       e1 = it1.hasNext() ? it1.next() : null;
> /*      */     } 
> /*      */ 
> /*      */     
> /* 2730 */     while (it1.hasNext()) {
> /* 2731 */       double d = ((SparseArrayModified.Entry)it1.next()).x;
> /* 2732 */       sum += d * d;
> /*      */     } 
> /*      */     
> /* 2735 */     while (it2.hasNext()) {
> /* 2736 */       double d = ((SparseArrayModified.Entry)it2.next()).x;
> /* 2737 */       sum += d * d;
> /*      */     } 
> /*      */     
> /* 2740 */     return sum;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double squaredDistanceWithMissingValues(double[] x, double[] y) {
> /* 2755 */     int n = x.length;
> /* 2756 */     int m = 0;
> /* 2757 */     double dist = 0.0D;
> /*      */     
> /* 2759 */     for (int i = 0; i < n; i++) {
> /* 2760 */       if (!Double.isNaN(x[i]) && !Double.isNaN(y[i])) {
> /* 2761 */         m++;
> /* 2762 */         double d = x[i] - y[i];
> /* 2763 */         dist += d * d;
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 2767 */     if (m == 0) {
> /* 2768 */       dist = Double.MAX_VALUE;
> /*      */     } else {
> /* 2770 */       dist = n * dist / m;
> /*      */     } 
> /*      */     
> /* 2773 */     return dist;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdist(int[][] x) {
> /* 2783 */     return pdist(x, false);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdist(int[][] x, boolean squared) {
> /* 2794 */     int n = x.length;
> /* 2795 */     double[][] dist = new double[n][n];
> /*      */     
> /* 2797 */     pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
> /* 2798 */     return MatrixModified.of(dist);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdist(float[][] x) {
> /* 2807 */     return pdist(x, false);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdist(float[][] x, boolean squared) {
> /* 2817 */     int n = x.length;
> /* 2818 */     double[][] dist = new double[n][n];
> /*      */     
> /* 2820 */     pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
> /* 2821 */     return MatrixModified.of(dist);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdist(double[][] x) {
> /* 2830 */     return pdist(x, false);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdist(double[][] x, boolean squared) {
> /* 2840 */     int n = x.length;
> /* 2841 */     double[][] dist = new double[n][n];
> /*      */     
> /* 2843 */     pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
> /* 2844 */     return MatrixModified.of(dist);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdist(SparseArrayModified[] x) {
> /* 2853 */     return pdist(x, false);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdist(SparseArrayModified[] x, boolean squared) {
> /* 2863 */     int n = x.length;
> /* 2864 */     double[][] dist = new double[n][n];
> /*      */     
> /* 2866 */     pdist(x, dist, squared ? MathExModified::squaredDistance : MathExModified::distance);
> /* 2867 */     return MatrixModified.of(dist);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <T> void pdist(Object[] x, double[][] d, DistanceModified<T> distance) {
> /* 2878 */     int n = x.length;
> /*      */     
> /* 2880 */     if ((d[0]).length < n) {
> /* 2881 */       IntStream.range(0, n).parallel().forEach(i -> {
> /*      */             T xi = (T)paramArrayOfObject[i];
> /*      */             double[] di = paramArrayOfdouble[i];
> /*      */             for (int j = 0; j < i; j++) {
> /*      */               di[j] = paramDistanceModified.d(xi, (T)paramArrayOfObject[j]);
> /*      */             }
> /*      */           });
> /*      */     } else {
> /* 2889 */       IntStream.range(0, n).parallel().forEach(i -> {
> /*      */             T xi = (T)paramArrayOfObject[i];
> /*      */             double[] di = paramArrayOfdouble[i];
> /*      */             for (int j = 0; j < paramInt1; j++) {
> /*      */               di[j] = paramDistanceModified.d(xi, (T)paramArrayOfObject[j]);
> /*      */             }
> /*      */           });
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double entropy(double[] p) {
> /* 2905 */     double h = 0.0D; byte b; int i; double[] arrayOfDouble;
> /* 2906 */     for (i = (arrayOfDouble = p).length, b = 0; b < i; ) { double pi = arrayOfDouble[b];
> /* 2907 */       if (pi > 0.0D)
> /* 2908 */         h -= pi * Math.log(pi); 
> /*      */       b++; }
> /*      */     
> /* 2911 */     return h;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double KullbackLeiblerDivergence(double[] p, double[] q) {
> /* 2934 */     boolean intersection = false;
> /* 2935 */     double kl = 0.0D;
> /*      */     
> /* 2937 */     for (int i = 0; i < p.length; i++) {
> /* 2938 */       if (p[i] != 0.0D && q[i] != 0.0D) {
> /* 2939 */         intersection = true;
> /* 2940 */         kl += p[i] * Math.log(p[i] / q[i]);
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 2944 */     if (intersection) {
> /* 2945 */       return kl;
> /*      */     }
> /* 2947 */     return Double.POSITIVE_INFINITY;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double KullbackLeiblerDivergence(SparseArrayModified p, SparseArrayModified q) {
> /* 2971 */     if (p.isEmpty()) {
> /* 2972 */       throw new IllegalArgumentException("p is empty.");
> /*      */     }
> /*      */     
> /* 2975 */     if (q.isEmpty()) {
> /* 2976 */       throw new IllegalArgumentException("q is empty.");
> /*      */     }
> /*      */     
> /* 2979 */     Iterator<SparseArrayModified.Entry> pIter = p.iterator();
> /* 2980 */     Iterator<SparseArrayModified.Entry> qIter = q.iterator();
> /*      */     
> /* 2982 */     SparseArrayModified.Entry a = pIter.hasNext() ? pIter.next() : null;
> /* 2983 */     SparseArrayModified.Entry b = qIter.hasNext() ? qIter.next() : null;
> /*      */     
> /* 2985 */     boolean intersection = false;
> /* 2986 */     double kl = 0.0D;
> /*      */     
> /* 2988 */     while (a != null && b != null) {
> /* 2989 */       if (a.i < b.i) {
> /* 2990 */         a = pIter.hasNext() ? pIter.next() : null; continue;
> /* 2991 */       }  if (a.i > b.i) {
> /* 2992 */         b = qIter.hasNext() ? qIter.next() : null; continue;
> /*      */       } 
> /* 2994 */       intersection = true;
> /* 2995 */       kl += a.x * Math.log(a.x / b.x);
> /*      */       
> /* 2997 */       a = pIter.hasNext() ? pIter.next() : null;
> /* 2998 */       b = qIter.hasNext() ? qIter.next() : null;
> /*      */     } 
> /*      */ 
> /*      */     
> /* 3002 */     if (intersection) {
> /* 3003 */       return kl;
> /*      */     }
> /* 3005 */     return Double.POSITIVE_INFINITY;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double KullbackLeiblerDivergence(double[] p, SparseArrayModified q) {
> /* 3029 */     return KullbackLeiblerDivergence(q, p);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double KullbackLeiblerDivergence(SparseArrayModified p, double[] q) {
> /* 3052 */     if (p.isEmpty()) {
> /* 3053 */       throw new IllegalArgumentException("p is empty.");
> /*      */     }
> /*      */     
> /* 3056 */     Iterator<SparseArrayModified.Entry> iter = p.iterator();
> /*      */     
> /* 3058 */     boolean intersection = false;
> /* 3059 */     double kl = 0.0D;
> /* 3060 */     while (iter.hasNext()) {
> /* 3061 */       SparseArrayModified.Entry b = iter.next();
> /* 3062 */       int i = b.i;
> /* 3063 */       if (q[i] > 0.0D) {
> /* 3064 */         intersection = true;
> /* 3065 */         kl += b.x * Math.log(b.x / q[i]);
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 3069 */     if (intersection) {
> /* 3070 */       return kl;
> /*      */     }
> /* 3072 */     return Double.POSITIVE_INFINITY;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double JensenShannonDivergence(double[] p, double[] q) {
> /* 3090 */     double[] m = new double[p.length];
> /* 3091 */     for (int i = 0; i < m.length; i++) {
> /* 3092 */       m[i] = (p[i] + q[i]) / 2.0D;
> /*      */     }
> /*      */     
> /* 3095 */     return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2.0D;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double JensenShannonDivergence(SparseArrayModified p, SparseArrayModified q) {
> /* 3112 */     if (p.isEmpty()) {
> /* 3113 */       throw new IllegalArgumentException("p is empty.");
> /*      */     }
> /*      */     
> /* 3116 */     if (q.isEmpty()) {
> /* 3117 */       throw new IllegalArgumentException("q is empty.");
> /*      */     }
> /*      */     
> /* 3120 */     Iterator<SparseArrayModified.Entry> pIter = p.iterator();
> /* 3121 */     Iterator<SparseArrayModified.Entry> qIter = q.iterator();
> /*      */     
> /* 3123 */     SparseArrayModified.Entry a = pIter.hasNext() ? pIter.next() : null;
> /* 3124 */     SparseArrayModified.Entry b = qIter.hasNext() ? qIter.next() : null;
> /*      */     
> /* 3126 */     double js = 0.0D;
> /*      */     
> /* 3128 */     while (a != null && b != null) {
> /* 3129 */       if (a.i < b.i) {
> /* 3130 */         double d = a.x / 2.0D;
> /* 3131 */         js += a.x * Math.log(a.x / d);
> /* 3132 */         a = pIter.hasNext() ? pIter.next() : null; continue;
> /* 3133 */       }  if (a.i > b.i) {
> /* 3134 */         double d = b.x / 2.0D;
> /* 3135 */         js += b.x * Math.log(b.x / d);
> /* 3136 */         b = qIter.hasNext() ? qIter.next() : null; continue;
> /*      */       } 
> /* 3138 */       double mi = (a.x + b.x) / 2.0D;
> /* 3139 */       js += a.x * Math.log(a.x / mi) + b.x * Math.log(b.x / mi);
> /*      */       
> /* 3141 */       a = pIter.hasNext() ? pIter.next() : null;
> /* 3142 */       b = qIter.hasNext() ? qIter.next() : null;
> /*      */     } 
> /*      */ 
> /*      */     
> /* 3146 */     return js / 2.0D;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double JensenShannonDivergence(double[] p, SparseArrayModified q) {
> /* 3163 */     return JensenShannonDivergence(q, p);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double JensenShannonDivergence(SparseArrayModified p, double[] q) {
> /* 3180 */     if (p.isEmpty()) {
> /* 3181 */       throw new IllegalArgumentException("p is empty.");
> /*      */     }
> /*      */     
> /* 3184 */     Iterator<SparseArrayModified.Entry> iter = p.iterator();
> /*      */     
> /* 3186 */     double js = 0.0D;
> /* 3187 */     while (iter.hasNext()) {
> /* 3188 */       SparseArrayModified.Entry b = iter.next();
> /* 3189 */       int i = b.i;
> /* 3190 */       double mi = (b.x + q[i]) / 2.0D;
> /* 3191 */       js += b.x * Math.log(b.x / mi);
> /* 3192 */       if (q[i] > 0.0D) {
> /* 3193 */         js += q[i] * Math.log(q[i] / mi);
> /*      */       }
> /*      */     } 
> /*      */     
> /* 3197 */     return js / 2.0D;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int dot(int[] x, int[] y) {
> /* 3208 */     int sum = 0;
> /*      */     
> /* 3210 */     for (int p1 = 0, p2 = 0; p1 < x.length && p2 < y.length; ) {
> /* 3211 */       int i1 = x[p1];
> /* 3212 */       int i2 = y[p2];
> /* 3213 */       if (i1 == i2) {
> /* 3214 */         sum++;
> /* 3215 */         p1++;
> /* 3216 */         p2++; continue;
> /* 3217 */       }  if (i1 > i2) {
> /* 3218 */         p2++; continue;
> /*      */       } 
> /* 3220 */       p1++;
> /*      */     } 
> /*      */ 
> /*      */     
> /* 3224 */     return sum;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float dot(float[] x, float[] y) {
> /* 3234 */     if (x.length != y.length) {
> /* 3235 */       throw new IllegalArgumentException("Arrays have different length.");
> /*      */     }
> /*      */     
> /* 3238 */     float sum = 0.0F;
> /* 3239 */     for (int i = 0; i < x.length; i++) {
> /* 3240 */       sum += x[i] * y[i];
> /*      */     }
> /*      */     
> /* 3243 */     return sum;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double dot(double[] x, double[] y) {
> /* 3253 */     if (x.length != y.length) {
> /* 3254 */       throw new IllegalArgumentException("Arrays have different length.");
> /*      */     }
> /*      */     
> /* 3257 */     double sum = 0.0D;
> /* 3258 */     for (int i = 0; i < x.length; i++) {
> /* 3259 */       sum += x[i] * y[i];
> /*      */     }
> /*      */     
> /* 3262 */     return sum;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double dot(SparseArrayModified x, SparseArrayModified y) {
> /* 3272 */     Iterator<SparseArrayModified.Entry> it1 = x.iterator();
> /* 3273 */     Iterator<SparseArrayModified.Entry> it2 = y.iterator();
> /* 3274 */     SparseArrayModified.Entry e1 = it1.hasNext() ? it1.next() : null;
> /* 3275 */     SparseArrayModified.Entry e2 = it2.hasNext() ? it2.next() : null;
> /*      */     
> /* 3277 */     double sum = 0.0D;
> /* 3278 */     while (e1 != null && e2 != null) {
> /* 3279 */       if (e1.i == e2.i) {
> /* 3280 */         sum += e1.x * e2.x;
> /* 3281 */         e1 = it1.hasNext() ? it1.next() : null;
> /* 3282 */         e2 = it2.hasNext() ? it2.next() : null; continue;
> /* 3283 */       }  if (e1.i > e2.i) {
> /* 3284 */         e2 = it2.hasNext() ? it2.next() : null; continue;
> /*      */       } 
> /* 3286 */       e1 = it1.hasNext() ? it1.next() : null;
> /*      */     } 
> /*      */ 
> /*      */     
> /* 3290 */     return sum;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdot(int[][] x) {
> /* 3300 */     int n = x.length;
> /*      */     
> /* 3302 */     MatrixModified matrix = new MatrixModified(n, n);
> /* 3303 */     matrix.uplo(UPLOModified.LOWER);
> /* 3304 */     IntStream.range(0, n).parallel().forEach(j -> {
> /*      */           int[] xj = paramArrayOfint[j];
> /*      */           
> /*      */           for (int i = 0; i < paramInt1; i++) {
> /*      */             paramMatrixModified.set(i, j, dot(paramArrayOfint[i], xj));
> /*      */           }
> /*      */         });
> /* 3311 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdot(float[][] x) {
> /* 3320 */     int n = x.length;
> /*      */     
> /* 3322 */     MatrixModified matrix = new MatrixModified(n, n);
> /* 3323 */     matrix.uplo(UPLOModified.LOWER);
> /* 3324 */     IntStream.range(0, n).parallel().forEach(j -> {
> /*      */           float[] xj = paramArrayOffloat[j];
> /*      */           
> /*      */           for (int i = 0; i < paramInt1; i++) {
> /*      */             paramMatrixModified.set(i, j, dot(paramArrayOffloat[i], xj));
> /*      */           }
> /*      */         });
> /* 3331 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdot(double[][] x) {
> /* 3340 */     int n = x.length;
> /*      */     
> /* 3342 */     MatrixModified matrix = new MatrixModified(n, n);
> /* 3343 */     matrix.uplo(UPLOModified.LOWER);
> /* 3344 */     IntStream.range(0, n).parallel().forEach(j -> {
> /*      */           double[] xj = paramArrayOfdouble[j];
> /*      */           
> /*      */           for (int i = 0; i < paramInt1; i++) {
> /*      */             paramMatrixModified.set(i, j, dot(paramArrayOfdouble[i], xj));
> /*      */           }
> /*      */         });
> /* 3351 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified pdot(SparseArrayModified[] x) {
> /* 3360 */     int n = x.length;
> /*      */     
> /* 3362 */     MatrixModified matrix = new MatrixModified(n, n);
> /* 3363 */     matrix.uplo(UPLOModified.LOWER);
> /* 3364 */     IntStream.range(0, n).parallel().forEach(j -> {
> /*      */           SparseArrayModified xj = paramArrayOfSparseArrayModified[j];
> /*      */           
> /*      */           for (int i = 0; i < paramInt1; i++) {
> /*      */             paramMatrixModified.set(i, j, dot(paramArrayOfSparseArrayModified[i], xj));
> /*      */           }
> /*      */         });
> /* 3371 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double cov(int[] x, int[] y) {
> /* 3381 */     if (x.length != y.length) {
> /* 3382 */       throw new IllegalArgumentException("Arrays have different length.");
> /*      */     }
> /*      */     
> /* 3385 */     if (x.length < 3) {
> /* 3386 */       throw new IllegalArgumentException("array length has to be at least 3.");
> /*      */     }
> /*      */     
> /* 3389 */     double mx = mean(x);
> /* 3390 */     double my = mean(y);
> /*      */     
> /* 3392 */     double Sxy = 0.0D;
> /* 3393 */     for (int i = 0; i < x.length; i++) {
> /* 3394 */       double dx = x[i] - mx;
> /* 3395 */       double dy = y[i] - my;
> /* 3396 */       Sxy += dx * dy;
> /*      */     } 
> /*      */     
> /* 3399 */     return Sxy / (x.length - 1);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double cov(float[] x, float[] y) {
> /* 3409 */     if (x.length != y.length) {
> /* 3410 */       throw new IllegalArgumentException("Arrays have different length.");
> /*      */     }
> /*      */     
> /* 3413 */     if (x.length < 3) {
> /* 3414 */       throw new IllegalArgumentException("array length has to be at least 3.");
> /*      */     }
> /*      */     
> /* 3417 */     double mx = mean(x);
> /* 3418 */     double my = mean(y);
> /*      */     
> /* 3420 */     double Sxy = 0.0D;
> /* 3421 */     for (int i = 0; i < x.length; i++) {
> /* 3422 */       double dx = x[i] - mx;
> /* 3423 */       double dy = y[i] - my;
> /* 3424 */       Sxy += dx * dy;
> /*      */     } 
> /*      */     
> /* 3427 */     return Sxy / (x.length - 1);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double cov(double[] x, double[] y) {
> /* 3437 */     if (x.length != y.length) {
> /* 3438 */       throw new IllegalArgumentException("Arrays have different length.");
> /*      */     }
> /*      */     
> /* 3441 */     if (x.length < 3) {
> /* 3442 */       throw new IllegalArgumentException("array length has to be at least 3.");
> /*      */     }
> /*      */     
> /* 3445 */     double mx = mean(x);
> /* 3446 */     double my = mean(y);
> /*      */     
> /* 3448 */     double Sxy = 0.0D;
> /* 3449 */     for (int i = 0; i < x.length; i++) {
> /* 3450 */       double dx = x[i] - mx;
> /* 3451 */       double dy = y[i] - my;
> /* 3452 */       Sxy += dx * dy;
> /*      */     } 
> /*      */     
> /* 3455 */     return Sxy / (x.length - 1);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[][] cov(double[][] data) {
> /* 3464 */     return cov(data, colMeans(data));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[][] cov(double[][] data, double[] mu) {
> /* 3474 */     double[][] sigma = new double[(data[0]).length][(data[0]).length]; byte b; int i; double[][] arrayOfDouble1;
> /* 3475 */     for (i = (arrayOfDouble1 = data).length, b = 0; b < i; ) { double[] datum = arrayOfDouble1[b];
> /* 3476 */       for (int k = 0; k < mu.length; k++) {
> /* 3477 */         for (int m = 0; m <= k; m++) {
> /* 3478 */           sigma[k][m] = sigma[k][m] + (datum[k] - mu[k]) * (datum[m] - mu[m]);
> /*      */         }
> /*      */       } 
> /*      */       b++; }
> /*      */     
> /* 3483 */     int n = data.length - 1;
> /* 3484 */     for (int j = 0; j < mu.length; j++) {
> /* 3485 */       for (int k = 0; k <= j; k++) {
> /* 3486 */         sigma[j][k] = sigma[j][k] / n;
> /* 3487 */         sigma[k][j] = sigma[j][k];
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 3491 */     return sigma;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double cor(int[] x, int[] y) {
> /* 3501 */     if (x.length != y.length) {
> /* 3502 */       throw new IllegalArgumentException("Arrays have different length.");
> /*      */     }
> /*      */     
> /* 3505 */     if (x.length < 3) {
> /* 3506 */       throw new IllegalArgumentException("array length has to be at least 3.");
> /*      */     }
> /*      */     
> /* 3509 */     double Sxy = cov(x, y);
> /* 3510 */     double Sxx = var(x);
> /* 3511 */     double Syy = var(y);
> /*      */     
> /* 3513 */     if (Sxx == 0.0D || Syy == 0.0D) {
> /* 3514 */       return Double.NaN;
> /*      */     }
> /*      */     
> /* 3517 */     return Sxy / Math.sqrt(Sxx * Syy);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double cor(float[] x, float[] y) {
> /* 3527 */     if (x.length != y.length) {
> /* 3528 */       throw new IllegalArgumentException("Arrays have different length.");
> /*      */     }
> /*      */     
> /* 3531 */     if (x.length < 3) {
> /* 3532 */       throw new IllegalArgumentException("array length has to be at least 3.");
> /*      */     }
> /*      */     
> /* 3535 */     double Sxy = cov(x, y);
> /* 3536 */     double Sxx = var(x);
> /* 3537 */     double Syy = var(y);
> /*      */     
> /* 3539 */     if (Sxx == 0.0D || Syy == 0.0D) {
> /* 3540 */       return Double.NaN;
> /*      */     }
> /*      */     
> /* 3543 */     return Sxy / Math.sqrt(Sxx * Syy);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double cor(double[] x, double[] y) {
> /* 3553 */     if (x.length != y.length) {
> /* 3554 */       throw new IllegalArgumentException("Arrays have different length.");
> /*      */     }
> /*      */     
> /* 3557 */     if (x.length < 3) {
> /* 3558 */       throw new IllegalArgumentException("array length has to be at least 3.");
> /*      */     }
> /*      */     
> /* 3561 */     double Sxy = cov(x, y);
> /* 3562 */     double Sxx = var(x);
> /* 3563 */     double Syy = var(y);
> /*      */     
> /* 3565 */     if (Sxx == 0.0D || Syy == 0.0D) {
> /* 3566 */       return Double.NaN;
> /*      */     }
> /*      */     
> /* 3569 */     return Sxy / Math.sqrt(Sxx * Syy);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[][] cor(double[][] data) {
> /* 3578 */     return cor(data, colMeans(data));
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[][] cor(double[][] data, double[] mu) {
> /* 3588 */     double[][] sigma = cov(data, mu);
> /*      */     
> /* 3590 */     int n = (data[0]).length;
> /* 3591 */     double[] sd = new double[n]; int i;
> /* 3592 */     for (i = 0; i < n; i++) {
> /* 3593 */       sd[i] = Math.sqrt(sigma[i][i]);
> /*      */     }
> /*      */     
> /* 3596 */     for (i = 0; i < n; i++) {
> /* 3597 */       for (int j = 0; j <= i; j++) {
> /* 3598 */         sigma[i][j] = sigma[i][j] / sd[i] * sd[j];
> /* 3599 */         sigma[j][i] = sigma[i][j];
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 3603 */     return sigma;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   private static double crank(double[] w) {
> /* 3612 */     int n = w.length;
> /* 3613 */     double s = 0.0D;
> /* 3614 */     int j = 1;
> /* 3615 */     while (j < n) {
> /* 3616 */       if (w[j] != w[j - 1]) {
> /* 3617 */         w[j - 1] = j;
> /* 3618 */         j++; continue;
> /*      */       } 
> /* 3620 */       int jt = j + 1;
> /* 3621 */       while (jt <= n && w[jt - 1] == w[j - 1]) {
> /* 3622 */         jt++;
> /*      */       }
> /*      */       
> /* 3625 */       double rank = 0.5D * (j + jt - 1);
> /* 3626 */       for (int ji = j; ji <= jt - 1; ji++) {
> /* 3627 */         w[ji - 1] = rank;
> /*      */       }
> /*      */       
> /* 3630 */       double t = (jt - j);
> /* 3631 */       s += t * t * t - t;
> /* 3632 */       j = jt;
> /*      */     } 
> /*      */ 
> /*      */     
> /* 3636 */     if (j == n) {
> /* 3637 */       w[n - 1] = n;
> /*      */     }
> /*      */     
> /* 3640 */     return s;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double spearman(int[] x, int[] y) {
> /* 3653 */     if (x.length != y.length) {
> /* 3654 */       throw new IllegalArgumentException("Input vector sizes are different.");
> /*      */     }
> /*      */     
> /* 3657 */     int n = x.length;
> /* 3658 */     double[] wksp1 = new double[n];
> /* 3659 */     double[] wksp2 = new double[n];
> /* 3660 */     for (int j = 0; j < n; j++) {
> /* 3661 */       wksp1[j] = x[j];
> /* 3662 */       wksp2[j] = y[j];
> /*      */     } 
> /*      */     
> /* 3665 */     QuickSortModified.sort(wksp1, wksp2);
> /* 3666 */     crank(wksp1);
> /* 3667 */     QuickSortModified.sort(wksp2, wksp1);
> /* 3668 */     crank(wksp2);
> /*      */     
> /* 3670 */     return cor(wksp1, wksp2);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double spearman(float[] x, float[] y) {
> /* 3683 */     if (x.length != y.length) {
> /* 3684 */       throw new IllegalArgumentException("Input vector sizes are different.");
> /*      */     }
> /*      */     
> /* 3687 */     int n = x.length;
> /* 3688 */     double[] wksp1 = new double[n];
> /* 3689 */     double[] wksp2 = new double[n];
> /* 3690 */     for (int j = 0; j < n; j++) {
> /* 3691 */       wksp1[j] = x[j];
> /* 3692 */       wksp2[j] = y[j];
> /*      */     } 
> /*      */     
> /* 3695 */     QuickSortModified.sort(wksp1, wksp2);
> /* 3696 */     crank(wksp1);
> /* 3697 */     QuickSortModified.sort(wksp2, wksp1);
> /* 3698 */     crank(wksp2);
> /*      */     
> /* 3700 */     return cor(wksp1, wksp2);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double spearman(double[] x, double[] y) {
> /* 3713 */     if (x.length != y.length) {
> /* 3714 */       throw new IllegalArgumentException("Input vector sizes are different.");
> /*      */     }
> /*      */     
> /* 3717 */     double[] wksp1 = (double[])x.clone();
> /* 3718 */     double[] wksp2 = (double[])y.clone();
> /*      */     
> /* 3720 */     QuickSortModified.sort(wksp1, wksp2);
> /* 3721 */     crank(wksp1);
> /* 3722 */     QuickSortModified.sort(wksp2, wksp1);
> /* 3723 */     crank(wksp2);
> /*      */     
> /* 3725 */     return cor(wksp1, wksp2);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double kendall(int[] x, int[] y) {
> /* 3737 */     if (x.length != y.length) {
> /* 3738 */       throw new IllegalArgumentException("Input vector sizes are different.");
> /*      */     }
> /*      */     
> /* 3741 */     int is = 0, n2 = 0, n1 = 0, n = x.length;
> /*      */     
> /* 3743 */     for (int j = 0; j < n - 1; j++) {
> /* 3744 */       for (int k = j + 1; k < n; k++) {
> /* 3745 */         double a1 = (x[j] - x[k]);
> /* 3746 */         double a2 = (y[j] - y[k]);
> /* 3747 */         double aa = a1 * a2;
> /* 3748 */         if (aa != 0.0D) {
> /* 3749 */           n1++;
> /* 3750 */           n2++;
> /* 3751 */           if (aa > 0.0D) {
> /* 3752 */             is++;
> /*      */           } else {
> /* 3754 */             is--;
> /*      */           } 
> /*      */         } else {
> /*      */           
> /* 3758 */           if (a1 != 0.0D) {
> /* 3759 */             n1++;
> /*      */           }
> /* 3761 */           if (a2 != 0.0D) {
> /* 3762 */             n2++;
> /*      */           }
> /*      */         } 
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 3768 */     return is / Math.sqrt(n1) * Math.sqrt(n2);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double kendall(float[] x, float[] y) {
> /* 3780 */     if (x.length != y.length) {
> /* 3781 */       throw new IllegalArgumentException("Input vector sizes are different.");
> /*      */     }
> /*      */     
> /* 3784 */     int is = 0, n2 = 0, n1 = 0, n = x.length;
> /*      */     
> /* 3786 */     for (int j = 0; j < n - 1; j++) {
> /* 3787 */       for (int k = j + 1; k < n; k++) {
> /* 3788 */         double a1 = (x[j] - x[k]);
> /* 3789 */         double a2 = (y[j] - y[k]);
> /* 3790 */         double aa = a1 * a2;
> /* 3791 */         if (aa != 0.0D) {
> /* 3792 */           n1++;
> /* 3793 */           n2++;
> /* 3794 */           if (aa > 0.0D) {
> /* 3795 */             is++;
> /*      */           } else {
> /* 3797 */             is--;
> /*      */           } 
> /*      */         } else {
> /*      */           
> /* 3801 */           if (a1 != 0.0D) {
> /* 3802 */             n1++;
> /*      */           }
> /* 3804 */           if (a2 != 0.0D) {
> /* 3805 */             n2++;
> /*      */           }
> /*      */         } 
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 3811 */     return is / Math.sqrt(n1) * Math.sqrt(n2);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double kendall(double[] x, double[] y) {
> /* 3823 */     if (x.length != y.length) {
> /* 3824 */       throw new IllegalArgumentException("Input vector sizes are different.");
> /*      */     }
> /*      */     
> /* 3827 */     int is = 0, n2 = 0, n1 = 0, n = x.length;
> /*      */     
> /* 3829 */     for (int j = 0; j < n - 1; j++) {
> /* 3830 */       for (int k = j + 1; k < n; k++) {
> /* 3831 */         double a1 = x[j] - x[k];
> /* 3832 */         double a2 = y[j] - y[k];
> /* 3833 */         double aa = a1 * a2;
> /* 3834 */         if (aa != 0.0D) {
> /* 3835 */           n1++;
> /* 3836 */           n2++;
> /* 3837 */           if (aa > 0.0D) {
> /* 3838 */             is++;
> /*      */           } else {
> /* 3840 */             is--;
> /*      */           } 
> /*      */         } else {
> /*      */           
> /* 3844 */           if (a1 != 0.0D) {
> /* 3845 */             n1++;
> /*      */           }
> /* 3847 */           if (a2 != 0.0D) {
> /* 3848 */             n2++;
> /*      */           }
> /*      */         } 
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 3854 */     return is / Math.sqrt(n1) * Math.sqrt(n2);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float norm1(float[] x) {
> /* 3863 */     float norm = 0.0F; byte b; int i;
> /*      */     float[] arrayOfFloat;
> /* 3865 */     for (i = (arrayOfFloat = x).length, b = 0; b < i; ) { float n = arrayOfFloat[b];
> /* 3866 */       norm += Math.abs(n);
> /*      */       b++; }
> /*      */     
> /* 3869 */     return norm;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double norm1(double[] x) {
> /* 3878 */     double norm = 0.0D; byte b; int i;
> /*      */     double[] arrayOfDouble;
> /* 3880 */     for (i = (arrayOfDouble = x).length, b = 0; b < i; ) { double n = arrayOfDouble[b];
> /* 3881 */       norm += Math.abs(n);
> /*      */       b++; }
> /*      */     
> /* 3884 */     return norm;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float norm2(float[] x) {
> /* 3893 */     float norm = 0.0F; byte b; int i;
> /*      */     float[] arrayOfFloat;
> /* 3895 */     for (i = (arrayOfFloat = x).length, b = 0; b < i; ) { float n = arrayOfFloat[b];
> /* 3896 */       norm += n * n;
> /*      */       b++; }
> /*      */     
> /* 3899 */     norm = (float)Math.sqrt(norm);
> /*      */     
> /* 3901 */     return norm;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double norm2(double[] x) {
> /* 3910 */     double norm = 0.0D; byte b; int i;
> /*      */     double[] arrayOfDouble;
> /* 3912 */     for (i = (arrayOfDouble = x).length, b = 0; b < i; ) { double n = arrayOfDouble[b];
> /* 3913 */       norm += n * n;
> /*      */       b++; }
> /*      */     
> /* 3916 */     norm = Math.sqrt(norm);
> /*      */     
> /* 3918 */     return norm;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float normInf(float[] x) {
> /* 3927 */     int n = x.length;
> /*      */     
> /* 3929 */     float f = Math.abs(x[0]);
> /* 3930 */     for (int i = 1; i < n; i++) {
> /* 3931 */       f = Math.max(f, Math.abs(x[i]));
> /*      */     }
> /*      */     
> /* 3934 */     return f;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double normInf(double[] x) {
> /* 3943 */     int n = x.length;
> /*      */     
> /* 3945 */     double f = Math.abs(x[0]);
> /* 3946 */     for (int i = 1; i < n; i++) {
> /* 3947 */       f = Math.max(f, Math.abs(x[i]));
> /*      */     }
> /*      */     
> /* 3950 */     return f;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float norm(float[] x) {
> /* 3959 */     return norm2(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double norm(double[] x) {
> /* 3968 */     return norm2(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float cos(float[] x, float[] y) {
> /* 3978 */     return dot(x, y) / norm2(x) * norm2(y);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double cos(double[] x, double[] y) {
> /* 3988 */     return dot(x, y) / norm2(x) * norm2(y);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void standardize(double[] x) {
> /* 3996 */     double mu = mean(x);
> /* 3997 */     double sigma = sd(x);
> /*      */     
> /* 3999 */     if (isZero(sigma)) {
> /* 4000 */       logger.warn("array has variance of 0.");
> /*      */       
> /*      */       return;
> /*      */     } 
> /* 4004 */     for (int i = 0; i < x.length; i++) {
> /* 4005 */       x[i] = (x[i] - mu) / sigma;
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void scale(double[][] x) {
> /* 4014 */     int n = x.length;
> /* 4015 */     int p = (x[0]).length;
> /*      */     
> /* 4017 */     double[] min = colMin(x);
> /* 4018 */     double[] max = colMax(x);
> /*      */     
> /* 4020 */     for (int j = 0; j < p; j++) {
> /* 4021 */       double scale = max[j] - min[j];
> /* 4022 */       if (!isZero(scale)) {
> /* 4023 */         for (int i = 0; i < n; i++) {
> /* 4024 */           x[i][j] = (x[i][j] - min[j]) / scale;
> /*      */         }
> /*      */       } else {
> /* 4027 */         for (int i = 0; i < n; i++) {
> /* 4028 */           x[i][j] = 0.5D;
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void standardize(double[][] x) {
> /* 4039 */     int n = x.length;
> /* 4040 */     int p = (x[0]).length;
> /*      */     
> /* 4042 */     double[] center = colMeans(x);
> /* 4043 */     for (int i = 0; i < n; i++) {
> /* 4044 */       for (int k = 0; k < p; k++) {
> /* 4045 */         x[i][k] = x[i][k] - center[k];
> /*      */       }
> /*      */     } 
> /*      */     
> /* 4049 */     double[] scale = new double[p];
> /* 4050 */     for (int j = 0; j < p; j++) {
> /* 4051 */       byte b; int k; double[][] arrayOfDouble; for (k = (arrayOfDouble = x).length, b = 0; b < k; ) { double[] xi = arrayOfDouble[b];
> /* 4052 */         scale[j] = scale[j] + pow2(xi[j]); b++; }
> /*      */       
> /* 4054 */       scale[j] = Math.sqrt(scale[j] / (n - 1));
> /*      */       
> /* 4056 */       if (!isZero(scale[j])) {
> /* 4057 */         for (int m = 0; m < n; m++) {
> /* 4058 */           x[m][j] = x[m][j] / scale[j];
> /*      */         }
> /*      */       }
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void normalize(double[][] x) {
> /* 4069 */     normalize(x, false);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void normalize(double[][] x, boolean centerizing) {
> /* 4078 */     int n = x.length;
> /* 4079 */     int p = (x[0]).length;
> /*      */     
> /* 4081 */     if (centerizing) {
> /* 4082 */       double[] center = colMeans(x);
> /* 4083 */       for (int k = 0; k < n; k++) {
> /* 4084 */         for (int m = 0; m < p; m++) {
> /* 4085 */           x[k][m] = x[k][m] - center[m];
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 4090 */     double[] scale = new double[p];
> /* 4091 */     for (int j = 0; j < p; j++) {
> /* 4092 */       byte b; int k; double[][] arrayOfDouble; for (k = (arrayOfDouble = x).length, b = 0; b < k; ) { double[] xi = arrayOfDouble[b];
> /* 4093 */         scale[j] = scale[j] + pow2(xi[j]); b++; }
> /*      */       
> /* 4095 */       scale[j] = Math.sqrt(scale[j]);
> /*      */     } 
> /*      */     
> /* 4098 */     for (int i = 0; i < n; i++) {
> /* 4099 */       for (int k = 0; k < p; k++) {
> /* 4100 */         if (!isZero(scale[k])) {
> /* 4101 */           x[i][k] = x[i][k] / scale[k];
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void unitize(double[] x) {
> /* 4113 */     unitize2(x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void unitize1(double[] x) {
> /* 4122 */     double n = norm1(x);
> /*      */     
> /* 4124 */     for (int i = 0; i < x.length; i++) {
> /* 4125 */       x[i] = x[i] / n;
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void unitize2(double[] x) {
> /* 4135 */     double n = norm(x);
> /*      */     
> /* 4137 */     for (int i = 0; i < x.length; i++) {
> /* 4138 */       x[i] = x[i] / n;
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean equals(float[] x, float[] y) {
> /* 4149 */     return equals(x, y, 1.0E-7F);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean equals(float[] x, float[] y, float epsilon) {
> /* 4160 */     if (x.length != y.length) {
> /* 4161 */       throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", new Object[] { Integer.valueOf(x.length), Integer.valueOf(y.length) }));
> /*      */     }
> /*      */     
> /* 4164 */     for (int i = 0; i < x.length; i++) {
> /* 4165 */       if (Math.abs(x[i] - y[i]) > epsilon) {
> /* 4166 */         return false;
> /*      */       }
> /*      */     } 
> /*      */     
> /* 4170 */     return true;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean equals(double[] x, double[] y) {
> /* 4180 */     return equals(x, y, 1.0E-10D);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean equals(double[] x, double[] y, double epsilon) {
> /* 4191 */     if (x.length != y.length) {
> /* 4192 */       throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", new Object[] { Integer.valueOf(x.length), Integer.valueOf(y.length) }));
> /*      */     }
> /*      */     
> /* 4195 */     if (epsilon <= 0.0D) {
> /* 4196 */       throw new IllegalArgumentException("Invalid epsilon: " + epsilon);
> /*      */     }
> /*      */     
> /* 4199 */     for (int i = 0; i < x.length; i++) {
> /* 4200 */       if (Math.abs(x[i] - y[i]) > epsilon) {
> /* 4201 */         return false;
> /*      */       }
> /*      */     } 
> /*      */     
> /* 4205 */     return true;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean equals(float[][] x, float[][] y) {
> /* 4215 */     return equals(x, y, 1.0E-7F);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean equals(float[][] x, float[][] y, float epsilon) {
> /* 4226 */     if (x.length != y.length || (x[0]).length != (y[0]).length) {
> /* 4227 */       throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", new Object[] { Integer.valueOf(x.length), Integer.valueOf((x[0]).length), Integer.valueOf(y.length), Integer.valueOf((y[0]).length) }));
> /*      */     }
> /*      */     
> /* 4230 */     for (int i = 0; i < x.length; i++) {
> /* 4231 */       for (int j = 0; j < (x[i]).length; j++) {
> /* 4232 */         if (Math.abs(x[i][j] - y[i][j]) > epsilon) {
> /* 4233 */           return false;
> /*      */         }
> /*      */       } 
> /*      */     } 
> /* 4237 */     return true;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean equals(double[][] x, double[][] y) {
> /* 4247 */     return equals(x, y, 1.0E-10D);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean equals(double[][] x, double[][] y, double epsilon) {
> /* 4258 */     if (x.length != y.length || (x[0]).length != (y[0]).length) {
> /* 4259 */       throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", new Object[] { Integer.valueOf(x.length), Integer.valueOf((x[0]).length), Integer.valueOf(y.length), Integer.valueOf((y[0]).length) }));
> /*      */     }
> /*      */     
> /* 4262 */     if (epsilon <= 0.0D) {
> /* 4263 */       throw new IllegalArgumentException("Invalid epsilon: " + epsilon);
> /*      */     }
> /*      */     
> /* 4266 */     for (int i = 0; i < x.length; i++) {
> /* 4267 */       for (int j = 0; j < (x[i]).length; j++) {
> /* 4268 */         if (Math.abs(x[i][j] - y[i][j]) > epsilon) {
> /* 4269 */           return false;
> /*      */         }
> /*      */       } 
> /*      */     } 
> /* 4273 */     return true;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean isZero(float x) {
> /* 4282 */     return isZero(x, FLOAT_EPSILON);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean isZero(float x, float epsilon) {
> /* 4292 */     return (Math.abs(x) < epsilon);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean isZero(double x) {
> /* 4301 */     return isZero(x, EPSILON);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static boolean isZero(double x, double epsilon) {
> /* 4311 */     return (Math.abs(x) < epsilon);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[][] clone(int[][] x) {
> /* 4320 */     int[][] matrix = new int[x.length][];
> /* 4321 */     for (int i = 0; i < x.length; i++) {
> /* 4322 */       matrix[i] = (int[])x[i].clone();
> /*      */     }
> /*      */     
> /* 4325 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static float[][] clone(float[][] x) {
> /* 4334 */     float[][] matrix = new float[x.length][];
> /* 4335 */     for (int i = 0; i < x.length; i++) {
> /* 4336 */       matrix[i] = (float[])x[i].clone();
> /*      */     }
> /*      */     
> /* 4339 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[][] clone(double[][] x) {
> /* 4348 */     double[][] matrix = new double[x.length][];
> /* 4349 */     for (int i = 0; i < x.length; i++) {
> /* 4350 */       matrix[i] = (double[])x[i].clone();
> /*      */     }
> /*      */     
> /* 4353 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void swap(int[] x, int i, int j) {
> /* 4363 */     int s = x[i];
> /* 4364 */     x[i] = x[j];
> /* 4365 */     x[j] = s;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void swap(float[] x, int i, int j) {
> /* 4375 */     float s = x[i];
> /* 4376 */     x[i] = x[j];
> /* 4377 */     x[j] = s;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void swap(double[] x, int i, int j) {
> /* 4387 */     double s = x[i];
> /* 4388 */     x[i] = x[j];
> /* 4389 */     x[j] = s;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void swap(Object[] x, int i, int j) {
> /* 4399 */     Object s = x[i];
> /* 4400 */     x[i] = x[j];
> /* 4401 */     x[j] = s;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void swap(int[] x, int[] y) {
> /* 4410 */     if (x.length != y.length) {
> /* 4411 */       throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", new Object[] { Integer.valueOf(x.length), Integer.valueOf(y.length) }));
> /*      */     }
> /*      */     
> /* 4414 */     for (int i = 0; i < x.length; i++) {
> /* 4415 */       int s = x[i];
> /* 4416 */       x[i] = y[i];
> /* 4417 */       y[i] = s;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void swap(float[] x, float[] y) {
> /* 4427 */     if (x.length != y.length) {
> /* 4428 */       throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", new Object[] { Integer.valueOf(x.length), Integer.valueOf(y.length) }));
> /*      */     }
> /*      */     
> /* 4431 */     for (int i = 0; i < x.length; i++) {
> /* 4432 */       float s = x[i];
> /* 4433 */       x[i] = y[i];
> /* 4434 */       y[i] = s;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void swap(double[] x, double[] y) {
> /* 4444 */     if (x.length != y.length) {
> /* 4445 */       throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", new Object[] { Integer.valueOf(x.length), Integer.valueOf(y.length) }));
> /*      */     }
> /*      */     
> /* 4448 */     for (int i = 0; i < x.length; i++) {
> /* 4449 */       double s = x[i];
> /* 4450 */       x[i] = y[i];
> /* 4451 */       y[i] = s;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <E> void swap(Object[] x, Object[] y) {
> /* 4462 */     if (x.length != y.length) {
> /* 4463 */       throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", new Object[] { Integer.valueOf(x.length), Integer.valueOf(y.length) }));
> /*      */     }
> /*      */     
> /* 4466 */     for (int i = 0; i < x.length; i++) {
> /* 4467 */       E s = (E)x[i];
> /* 4468 */       x[i] = y[i];
> /* 4469 */       y[i] = s;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void copy(int[][] x, int[][] y) {
> /* 4479 */     if (x.length != y.length || (x[0]).length != (y[0]).length) {
> /* 4480 */       throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", new Object[] { Integer.valueOf(x.length), Integer.valueOf((x[0]).length), Integer.valueOf(y.length), Integer.valueOf((y[0]).length) }));
> /*      */     }
> /*      */     
> /* 4483 */     for (int i = 0; i < x.length; i++) {
> /* 4484 */       System.arraycopy(x[i], 0, y[i], 0, (x[i]).length);
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void copy(float[][] x, float[][] y) {
> /* 4494 */     if (x.length != y.length || (x[0]).length != (y[0]).length) {
> /* 4495 */       throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", new Object[] { Integer.valueOf(x.length), Integer.valueOf((x[0]).length), Integer.valueOf(y.length), Integer.valueOf((y[0]).length) }));
> /*      */     }
> /*      */     
> /* 4498 */     for (int i = 0; i < x.length; i++) {
> /* 4499 */       System.arraycopy(x[i], 0, y[i], 0, (x[i]).length);
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void copy(double[][] x, double[][] y) {
> /* 4509 */     if (x.length != y.length || (x[0]).length != (y[0]).length) {
> /* 4510 */       throw new IllegalArgumentException(String.format("Matrices have different rows: %d x %d vs %d x %d", new Object[] { Integer.valueOf(x.length), Integer.valueOf((x[0]).length), Integer.valueOf(y.length), Integer.valueOf((y[0]).length) }));
> /*      */     }
> /*      */     
> /* 4513 */     for (int i = 0; i < x.length; i++) {
> /* 4514 */       System.arraycopy(x[i], 0, y[i], 0, (x[i]).length);
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void add(double[] y, double[] x) {
> /* 4524 */     if (x.length != y.length) {
> /* 4525 */       throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", new Object[] { Integer.valueOf(x.length), Integer.valueOf(y.length) }));
> /*      */     }
> /*      */     
> /* 4528 */     for (int i = 0; i < x.length; i++) {
> /* 4529 */       y[i] = y[i] + x[i];
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sub(double[] y, double[] x) {
> /* 4539 */     if (x.length != y.length) {
> /* 4540 */       throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", new Object[] { Integer.valueOf(x.length), Integer.valueOf(y.length) }));
> /*      */     }
> /*      */     
> /* 4543 */     for (int i = 0; i < x.length; i++) {
> /* 4544 */       y[i] = y[i] - x[i];
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void scale(double a, double[] x) {
> /* 4554 */     for (int i = 0; i < x.length; i++) {
> /* 4555 */       x[i] = x[i] * a;
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void scale(double a, double[] x, double[] y) {
> /* 4566 */     for (int i = 0; i < x.length; i++) {
> /* 4567 */       y[i] = a * x[i];
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] axpy(double a, double[] x, double[] y) {
> /* 4579 */     if (x.length != y.length) {
> /* 4580 */       throw new IllegalArgumentException(String.format("Arrays have different length: x[%d], y[%d]", new Object[] { Integer.valueOf(x.length), Integer.valueOf(y.length) }));
> /*      */     }
> /*      */     
> /* 4583 */     for (int i = 0; i < x.length; i++) {
> /* 4584 */       y[i] = y[i] + a * x[i];
> /*      */     }
> /*      */     
> /* 4587 */     return y;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] pow(double[] x, double n) {
> /* 4597 */     double[] y = new double[x.length];
> /* 4598 */     for (int i = 0; i < x.length; ) { y[i] = Math.pow(x[i], n); i++; }
> /* 4599 */      return y;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] unique(int[] x) {
> /* 4608 */     return Arrays.stream(x).distinct().toArray();
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static String[] unique(String[] x) {
> /* 4617 */     return (String[])Arrays.<String>stream(x).distinct().toArray(paramInt -> new String[paramInt]);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static double[] solve(double[] a, double[] b, double[] c, double[] r) {
> /* 4651 */     if (b[0] == 0.0D) {
> /* 4652 */       throw new IllegalArgumentException("Invalid value of b[0] == 0. The equations should be rewritten as a set of order n - 1.");
> /*      */     }
> /*      */     
> /* 4655 */     int n = a.length;
> /* 4656 */     double[] u = new double[n];
> /* 4657 */     double[] gam = new double[n];
> /*      */     
> /* 4659 */     double bet = b[0];
> /* 4660 */     u[0] = r[0] / bet;
> /*      */     int j;
> /* 4662 */     for (j = 1; j < n; j++) {
> /* 4663 */       gam[j] = c[j - 1] / bet;
> /* 4664 */       bet = b[j] - a[j] * gam[j];
> /* 4665 */       if (bet == 0.0D) {
> /* 4666 */         throw new IllegalArgumentException("The tridagonal matrix is not of diagonal dominance.");
> /*      */       }
> /* 4668 */       u[j] = (r[j] - a[j] * u[j - 1]) / bet;
> /*      */     } 
> /*      */     
> /* 4671 */     for (j = n - 2; j >= 0; j--) {
> /* 4672 */       u[j] = u[j] - gam[j + 1] * u[j + 1];
> /*      */     }
> /*      */     
> /* 4675 */     return u;
> /*      */   }
> /*      */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/MathExModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/MatrixModified.java jd-gui/smileModified/MatrixModified.java
1,1768c1,2723
< package smileModified;
< 
< import java.io.Serializable;
< import java.nio.DoubleBuffer;
< import java.util.Arrays;
< import org.slf4j.Logger;
< import org.slf4j.LoggerFactory;
< 
< public class MatrixModified extends IMatrixModified {
<    private static final long serialVersionUID = 3L;
<    private static final Logger logger = LoggerFactory.getLogger(MatrixModified.class);
<    double[] A;
<    int ld;
<    int m;
<    int n;
<    UPLOModified uplo;
<    DiagModified diag;
< 
<    public MatrixModified(int m, int n) {
<       this(m, n, 0.0D);
<    }
< 
<    public MatrixModified(int m, int n, double a) {
<       if (m > 0 && n > 0) {
<          this.m = m;
<          this.n = n;
<          this.ld = ld(m);
<          this.A = new double[this.ld * n];
<          if (a != 0.0D) {
<             Arrays.fill(this.A, a);
<          }
< 
<       } else {
<          throw new IllegalArgumentException(String.format("Invalid matrix size: %d x %d", m, n));
<       }
<    }
< 
<    public MatrixModified(int m, int n, int ld, double[] A) {
<       if (this.layout() == LayoutModified.COL_MAJOR && ld < m) {
<          throw new IllegalArgumentException(String.format("Invalid leading dimension for COL_MAJOR: %d < %d", ld, m));
<       } else if (this.layout() == LayoutModified.ROW_MAJOR && ld < n) {
<          throw new IllegalArgumentException(String.format("Invalid leading dimension for ROW_MAJOR: %d < %d", ld, n));
<       } else {
<          this.m = m;
<          this.n = n;
<          this.ld = ld;
<          this.A = A;
<       }
<    }
< 
<    public static MatrixModified of(double[][] A) {
<       int m = A.length;
<       int n = A[0].length;
<       MatrixModified matrix = new MatrixModified(m, n);
< 
<       for(int i = 0; i < m; ++i) {
<          for(int j = 0; j < n; ++j) {
<             matrix.set(i, j, A[i][j]);
<          }
<       }
< 
<       return matrix;
<    }
< 
<    public static MatrixModified column(double[] A) {
<       return column(A, 0, A.length);
<    }
< 
<    public static MatrixModified column(double[] A, int offset, int length) {
<       MatrixModified matrix = new MatrixModified(length, 1, length, new double[length]);
<       System.arraycopy(A, offset, matrix.A, 0, length);
<       return matrix;
<    }
< 
<    public static MatrixModified row(double[] A) {
<       return row(A, 0, A.length);
<    }
< 
<    public static MatrixModified row(double[] A, int offset, int length) {
<       MatrixModified matrix = new MatrixModified(1, length, 1, new double[length]);
<       System.arraycopy(A, offset, matrix.A, 0, length);
<       return matrix;
<    }
< 
<    public static MatrixModified rand(int m, int n, DistributionModified distribution) {
<       MatrixModified matrix = new MatrixModified(m, n);
< 
<       for(int j = 0; j < n; ++j) {
<          for(int i = 0; i < m; ++i) {
<             matrix.set(i, j, distribution.rand());
<          }
<       }
< 
<       return matrix;
<    }
< 
<    public static MatrixModified randn(int m, int n) {
<       return rand(m, n, GaussianDistributionModified.getInstance());
<    }
< 
<    public static MatrixModified rand(int m, int n) {
<       MatrixModified matrix = new MatrixModified(m, n);
< 
<       for(int j = 0; j < n; ++j) {
<          for(int i = 0; i < m; ++i) {
<             matrix.set(i, j, MathExModified.random());
<          }
<       }
< 
<       return matrix;
<    }
< 
<    public static MatrixModified rand(int m, int n, double lo, double hi) {
<       MatrixModified matrix = new MatrixModified(m, n);
< 
<       for(int j = 0; j < n; ++j) {
<          for(int i = 0; i < m; ++i) {
<             matrix.set(i, j, MathExModified.random(lo, hi));
<          }
<       }
< 
<       return matrix;
<    }
< 
<    public static MatrixModified eye(int n) {
<       return diag(n, 1.0D);
<    }
< 
<    public static MatrixModified eye(int m, int n) {
<       return diag(m, n, 1.0D);
<    }
< 
<    public static MatrixModified diag(int n, double diag) {
<       return diag(n, n, diag);
<    }
< 
<    public static MatrixModified diag(int m, int n, double diag) {
<       MatrixModified D = new MatrixModified(m, n);
<       int k = Math.min(m, n);
< 
<       for(int i = 0; i < k; ++i) {
<          D.set(i, i, diag);
<       }
< 
<       return D;
<    }
< 
<    public static MatrixModified diag(double[] diag) {
<       int n = diag.length;
<       MatrixModified D = new MatrixModified(n, n);
< 
<       for(int i = 0; i < n; ++i) {
<          D.set(i, i, diag[i]);
<       }
< 
<       return D;
<    }
< 
<    public static MatrixModified toeplitz(double[] a) {
<       int n = a.length;
<       MatrixModified toeplitz = new MatrixModified(n, n);
<       toeplitz.uplo(UPLOModified.LOWER);
< 
<       for(int i = 0; i < n; ++i) {
<          int j;
<          for(j = 0; j < i; ++j) {
<             toeplitz.set(i, j, a[i - j]);
<          }
< 
<          for(j = i; j < n; ++j) {
<             toeplitz.set(i, j, a[j - i]);
<          }
<       }
< 
<       return toeplitz;
<    }
< 
<    public static MatrixModified toeplitz(double[] kl, double[] ku) {
<       if (kl.length != ku.length - 1) {
<          throw new IllegalArgumentException(String.format("Invalid sub-diagonals and super-diagonals size: %d != %d - 1", kl.length, ku.length));
<       } else {
<          int n = kl.length;
<          MatrixModified toeplitz = new MatrixModified(n, n);
< 
<          for(int i = 0; i < n; ++i) {
<             int j;
<             for(j = 0; j < i; ++j) {
<                toeplitz.set(i, j, kl[i - j]);
<             }
< 
<             for(j = i; j < n; ++j) {
<                toeplitz.set(i, j, ku[j - i]);
<             }
<          }
< 
<          return toeplitz;
<       }
<    }
< 
<    public int nrow() {
<       return this.m;
<    }
< 
<    public int ncol() {
<       return this.n;
<    }
< 
<    public long size() {
<       return (long)(this.m * this.n);
<    }
< 
<    public LayoutModified layout() {
<       return LayoutModified.COL_MAJOR;
<    }
< 
<    public int ld() {
<       return this.ld;
<    }
< 
<    public boolean isSymmetric() {
<       return this.uplo != null && this.diag == null;
<    }
< 
<    public MatrixModified uplo(UPLOModified uplo) {
<       if (this.m != this.n) {
<          throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
<       } else {
<          this.uplo = uplo;
<          return this;
<       }
<    }
< 
<    public UPLOModified uplo() {
<       return this.uplo;
<    }
< 
<    public MatrixModified triangular(DiagModified diag) {
<       if (this.m != this.n) {
<          throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
<       } else {
<          this.diag = diag;
<          return this;
<       }
<    }
< 
<    public DiagModified triangular() {
<       return this.diag;
<    }
< 
<    public MatrixModified clone() {
<       MatrixModified matrix;
<       if (this.layout() == LayoutModified.COL_MAJOR) {
<          matrix = new MatrixModified(this.m, this.n, this.ld, (double[])this.A.clone());
<       } else {
<          matrix = new MatrixModified(this.m, this.n);
< 
<          for(int j = 0; j < this.n; ++j) {
<             for(int i = 0; i < this.m; ++i) {
<                matrix.set(i, j, this.get(i, j));
<             }
<          }
<       }
< 
<       if (this.m == this.n) {
<          matrix.uplo(this.uplo);
<          matrix.triangular(this.diag);
<       }
< 
<       return matrix;
<    }
< 
<    public double[][] toArray() {
<       double[][] array = new double[this.m][this.n];
< 
<       for(int i = 0; i < this.m; ++i) {
<          for(int j = 0; j < this.n; ++j) {
<             array[i][j] = this.get(i, j);
<          }
<       }
< 
<       return array;
<    }
< 
<    public MatrixModified set(MatrixModified b) {
<       this.m = b.m;
<       this.n = b.n;
<       this.diag = b.diag;
<       this.uplo = b.uplo;
<       if (this.layout() == b.layout()) {
<          this.A = b.A;
<          this.ld = b.ld;
<       } else {
<          int j;
<          int i;
<          if (this.layout() == LayoutModified.COL_MAJOR) {
<             this.ld = ld(this.m);
<             this.A = new double[this.ld * this.n];
< 
<             for(j = 0; j < this.n; ++j) {
<                for(i = 0; i < this.m; ++i) {
<                   this.set(i, j, this.get(i, j));
<                }
<             }
<          } else {
<             this.ld = ld(this.n);
<             this.A = new double[this.ld * this.m];
< 
<             for(j = 0; j < this.m; ++j) {
<                for(i = 0; i < this.n; ++i) {
<                   this.set(j, i, this.get(j, i));
<                }
<             }
<          }
<       }
< 
<       return this;
<    }
< 
<    protected int index(int i, int j) {
<       return j * this.ld + i;
<    }
< 
<    public double get(int i, int j) {
<       return this.A[this.index(i, j)];
<    }
< 
<    public void set(int i, int j, double x) {
<       this.A[this.index(i, j)] = x;
<    }
< 
<    public MatrixModified get(int[] rows, int[] cols) {
<       MatrixModified sub = new MatrixModified(rows.length, cols.length);
< 
<       for(int j = 0; j < cols.length; ++j) {
<          int col = cols[j];
<          if (col < 0) {
<             col += this.n;
<          }
< 
<          for(int i = 0; i < rows.length; ++i) {
<             int row = rows[i];
<             if (row < 0) {
<                row += this.m;
<             }
< 
<             sub.set(i, j, this.get(row, col));
<          }
<       }
< 
<       return sub;
<    }
< 
<    public double[] row(int i) {
<       double[] x = new double[this.n];
<       if (i < 0) {
<          i += this.m;
<       }
< 
<       if (this.layout() == LayoutModified.COL_MAJOR) {
<          for(int j = 0; j < this.n; ++j) {
<             x[j] = this.get(i, j);
<          }
<       } else {
<          System.arraycopy(this.A, this.index(i, 0), x, 0, this.n);
<       }
< 
<       return x;
<    }
< 
<    public double[] col(int j) {
<       double[] x = new double[this.m];
<       if (j < 0) {
<          j += this.n;
<       }
< 
<       if (this.layout() == LayoutModified.COL_MAJOR) {
<          System.arraycopy(this.A, this.index(0, j), x, 0, this.m);
<       } else {
<          for(int i = 0; i < this.m; ++i) {
<             x[i] = this.get(i, j);
<          }
<       }
< 
<       return x;
<    }
< 
<    public MatrixModified rows(int... rows) {
<       MatrixModified x = new MatrixModified(rows.length, this.n);
< 
<       for(int i = 0; i < rows.length; ++i) {
<          int row = rows[i];
<          if (row < 0) {
<             row += this.m;
<          }
< 
<          if (this.layout() == LayoutModified.COL_MAJOR) {
<             for(int j = 0; j < this.n; ++j) {
<                x.set(i, j, this.get(row, j));
<             }
<          } else {
<             System.arraycopy(this.A, this.index(row, 0), x.A, x.index(i, 0), this.n);
<          }
<       }
< 
<       return x;
<    }
< 
<    public MatrixModified cols(int... cols) {
<       MatrixModified x = new MatrixModified(this.m, cols.length);
< 
<       for(int j = 0; j < cols.length; ++j) {
<          int col = cols[j];
<          if (col < 0) {
<             col += this.n;
<          }
< 
<          if (this.layout() == LayoutModified.COL_MAJOR) {
<             System.arraycopy(this.A, this.index(0, col), x.A, x.index(0, j), this.m);
<          } else {
<             for(int i = 0; i < this.m; ++i) {
<                x.set(i, j, this.get(i, col));
<             }
<          }
<       }
< 
<       return x;
<    }
< 
<    public MatrixModified submatrix(int i, int j, int k, int l) {
<       if (i >= 0 && i < this.m && k >= i && k < this.m && j >= 0 && j < this.n && l >= j && l < this.n) {
<          MatrixModified sub = new MatrixModified(k - i + 1, l - j + 1);
< 
<          for(int jj = j; jj <= l; ++jj) {
<             for(int ii = i; ii <= k; ++ii) {
<                sub.set(ii - i, jj - j, this.get(ii, jj));
<             }
<          }
< 
<          return sub;
<       } else {
<          throw new IllegalArgumentException(String.format("Invalid submatrix range (%d:%d, %d:%d) of %d x %d", i, k, j, l, this.m, this.n));
<       }
<    }
< 
<    public void fill(double x) {
<       Arrays.fill(this.A, x);
<    }
< 
<    public MatrixModified transpose() {
<       return this.transpose(true);
<    }
< 
<    public MatrixModified transpose(boolean share) {
<       Object matrix;
<       if (share) {
<          if (this.layout() == LayoutModified.ROW_MAJOR) {
<             matrix = new MatrixModified(this.n, this.m, this.ld, this.A);
<          } else {
<             matrix = new MatrixModified.RowMajor(this.n, this.m, this.ld, this.A);
<          }
<       } else {
<          matrix = new MatrixModified(this.n, this.m);
< 
<          for(int j = 0; j < this.m; ++j) {
<             for(int i = 0; i < this.n; ++i) {
<                ((MatrixModified)matrix).set(i, j, this.get(j, i));
<             }
<          }
<       }
< 
<       if (this.m == this.n) {
<          ((MatrixModified)matrix).uplo(this.uplo);
<          ((MatrixModified)matrix).triangular(this.diag);
<       }
< 
<       return (MatrixModified)matrix;
<    }
< 
<    public boolean equals(Object o) {
<       return !(o instanceof MatrixModified) ? false : this.equals((MatrixModified)o, 1.0E-10D);
<    }
< 
<    public boolean equals(MatrixModified o, double epsilon) {
<       if (this.m == o.m && this.n == o.n) {
<          for(int j = 0; j < this.n; ++j) {
<             for(int i = 0; i < this.m; ++i) {
<                if (!MathExModified.isZero(this.get(i, j) - o.get(i, j), epsilon)) {
<                   return false;
<                }
<             }
<          }
< 
<          return true;
<       } else {
<          return false;
<       }
<    }
< 
<    public double add(int i, int j, double b) {
<       double[] var10000 = this.A;
<       int var10001 = this.index(i, j);
<       return var10000[var10001] += b;
<    }
< 
<    public double sub(int i, int j, double b) {
<       double[] var10000 = this.A;
<       int var10001 = this.index(i, j);
<       return var10000[var10001] -= b;
<    }
< 
<    public double mul(int i, int j, double b) {
<       double[] var10000 = this.A;
<       int var10001 = this.index(i, j);
<       return var10000[var10001] *= b;
<    }
< 
<    public double div(int i, int j, double b) {
<       double[] var10000 = this.A;
<       int var10001 = this.index(i, j);
<       return var10000[var10001] /= b;
<    }
< 
<    public MatrixModified addDiag(double b) {
<       int l = Math.min(this.m, this.n);
< 
<       for(int i = 0; i < l; ++i) {
<          double[] var10000 = this.A;
<          int var10001 = this.index(i, i);
<          var10000[var10001] += b;
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified addDiag(double[] b) {
<       int l = Math.min(this.m, this.n);
<       if (b.length != l) {
<          throw new IllegalArgumentException("Invalid diagonal array size: " + b.length);
<       } else {
<          for(int i = 0; i < l; ++i) {
<             double[] var10000 = this.A;
<             int var10001 = this.index(i, i);
<             var10000[var10001] += b[i];
<          }
< 
<          return this;
<       }
<    }
< 
<    public MatrixModified add(double b) {
<       for(int i = 0; i < this.A.length; ++i) {
<          double[] var10000 = this.A;
<          var10000[i] += b;
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified sub(double b) {
<       for(int i = 0; i < this.A.length; ++i) {
<          double[] var10000 = this.A;
<          var10000[i] -= b;
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified mul(double b) {
<       for(int i = 0; i < this.A.length; ++i) {
<          double[] var10000 = this.A;
<          var10000[i] *= b;
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified div(double b) {
<       for(int i = 0; i < this.A.length; ++i) {
<          double[] var10000 = this.A;
<          var10000[i] /= b;
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified add(MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                double[] var10000 = this.A;
<                var10000[j] += B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.add(i, j, B.get(i, j));
<                }
<             }
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified sub(MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                double[] var10000 = this.A;
<                var10000[j] -= B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.sub(i, j, B.get(i, j));
<                }
<             }
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified mul(MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                double[] var10000 = this.A;
<                var10000[j] *= B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.mul(i, j, B.get(i, j));
<                }
<             }
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified div(MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                double[] var10000 = this.A;
<                var10000[j] /= B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.div(i, j, B.get(i, j));
<                }
<             }
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified add(double beta, MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                double[] var10000 = this.A;
<                var10000[j] += beta * B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.add(i, j, beta * B.get(i, j));
<                }
<             }
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified add(double alpha, double beta, MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                this.A[j] = alpha * this.A[j] + beta * B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.set(i, j, alpha * this.get(i, j) + beta * B.get(i, j));
<                }
<             }
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix B is not of same size.");
<       }
<    }
< 
<    public MatrixModified add2(double alpha, double beta, MatrixModified B) {
<       if (this.m == B.m && this.n == B.n) {
<          int j;
<          if (this.layout() == B.layout() && this.ld == B.ld) {
<             for(j = 0; j < this.A.length; ++j) {
<                this.A[j] = alpha * this.A[j] + beta * B.A[j] * B.A[j];
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(int i = 0; i < this.m; ++i) {
<                   this.set(i, j, alpha * this.get(i, j) + beta * B.get(i, j) * B.get(i, j));
<                }
<             }
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix B is not of same size.");
<       }
<    }
< 
<    public MatrixModified add(double alpha, MatrixModified A, double beta, MatrixModified B) {
<       if (this.m == A.m && this.n == A.n) {
<          if (this.m == B.m && this.n == B.n) {
<             int j;
<             if (this.layout() == A.layout() && this.layout() == B.layout() && this.ld == A.ld && this.ld == B.ld) {
<                for(j = 0; j < this.A.length; ++j) {
<                   this.A[j] = alpha * A.A[j] + beta * B.A[j];
<                }
<             } else {
<                for(j = 0; j < this.n; ++j) {
<                   for(int i = 0; i < this.m; ++i) {
<                      this.set(i, j, alpha * A.get(i, j) + beta * B.get(i, j));
<                   }
<                }
<             }
< 
<             return this;
<          } else {
<             throw new IllegalArgumentException("Matrix B is not of same size.");
<          }
<       } else {
<          throw new IllegalArgumentException("Matrix A is not of same size.");
<       }
<    }
< 
<    public MatrixModified add(double alpha, double[] x, double[] y) {
<       if (this.m == x.length && this.n == y.length) {
<          if (this.isSymmetric() && x == y) {
<             BLASModified.engine.syr(this.layout(), this.uplo, this.m, alpha, (double[])x, 1, (double[])this.A, this.ld);
<          } else {
<             BLASModified.engine.ger(this.layout(), this.m, this.n, alpha, (double[])x, 1, (double[])y, 1, (double[])this.A, this.ld);
<          }
< 
<          return this;
<       } else {
<          throw new IllegalArgumentException("Matrix is not of same size.");
<       }
<    }
< 
<    public MatrixModified replaceNaN(double x) {
<       for(int i = 0; i < this.A.length; ++i) {
<          if (Double.isNaN(this.A[i])) {
<             this.A[i] = x;
<          }
<       }
< 
<       return this;
<    }
< 
<    public double sum() {
<       double s = 0.0D;
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = 0; i < this.m; ++i) {
<             s += this.get(i, j);
<          }
<       }
< 
<       return s;
<    }
< 
<    public double norm1() {
<       double f = 0.0D;
< 
<       for(int j = 0; j < this.n; ++j) {
<          double s = 0.0D;
< 
<          for(int i = 0; i < this.m; ++i) {
<             s += Math.abs(this.get(i, j));
<          }
< 
<          f = Math.max(f, s);
<       }
< 
<       return f;
<    }
< 
<    public double norm2() {
<       return this.svd(false, false).s[0];
<    }
< 
<    public double norm() {
<       return this.norm2();
<    }
< 
<    public double normInf() {
<       double[] f = new double[this.m];
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = 0; i < this.m; ++i) {
<             f[i] += Math.abs(this.get(i, j));
<          }
<       }
< 
<       return MathExModified.max(f);
<    }
< 
<    public double normFro() {
<       double f = 0.0D;
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = 0; i < this.m; ++i) {
<             f = Math.hypot(f, this.get(i, j));
<          }
<       }
< 
<       return f;
<    }
< 
<    public double xAx(double[] x) {
<       if (this.m != this.n) {
<          throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
<       } else if (this.n != x.length) {
<          throw new IllegalArgumentException(String.format("Matrix: %d x %d, Vector: %d", this.m, this.n, x.length));
<       } else {
<          double[] Ax = this.mv(x);
<          return MathExModified.dot(x, Ax);
<       }
<    }
< 
<    public double[] rowSums() {
<       double[] x = new double[this.m];
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = 0; i < this.m; ++i) {
<             x[i] += this.get(i, j);
<          }
<       }
< 
<       return x;
<    }
< 
<    public double[] rowMeans() {
<       double[] x = this.rowSums();
< 
<       for(int i = 0; i < this.m; ++i) {
<          x[i] /= (double)this.n;
<       }
< 
<       return x;
<    }
< 
<    public double[] rowSds() {
<       double[] x = new double[this.m];
<       double[] x2 = new double[this.m];
< 
<       int i;
<       for(i = 0; i < this.n; ++i) {
<          for(int i = 0; i < this.m; ++i) {
<             double a = this.get(i, i);
<             x[i] += a;
<             x2[i] += a * a;
<          }
<       }
< 
<       for(i = 0; i < this.m; ++i) {
<          double mu = x[i] / (double)this.n;
<          x[i] = Math.sqrt(x2[i] / (double)this.n - mu * mu);
<       }
< 
<       return x;
<    }
< 
<    public double[] colSums() {
<       double[] x = new double[this.n];
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = 0; i < this.m; ++i) {
<             x[j] += this.get(i, j);
<          }
<       }
< 
<       return x;
<    }
< 
<    public double[] colMeans() {
<       double[] x = this.colSums();
< 
<       for(int j = 0; j < this.n; ++j) {
<          x[j] /= (double)this.m;
<       }
< 
<       return x;
<    }
< 
<    public double[] colSds() {
<       double[] x = new double[this.n];
< 
<       for(int j = 0; j < this.n; ++j) {
<          double mu = 0.0D;
<          double sumsq = 0.0D;
< 
<          for(int i = 0; i < this.m; ++i) {
<             double a = this.get(i, j);
<             mu += a;
<             sumsq += a * a;
<          }
< 
<          mu /= (double)this.m;
<          x[j] = Math.sqrt(sumsq / (double)this.m - mu * mu);
<       }
< 
<       return x;
<    }
< 
<    public MatrixModified standardize() {
<       double[] center = this.colMeans();
<       double[] scale = this.colSds();
<       return this.scale(center, scale);
<    }
< 
<    public MatrixModified scale(double[] center, double[] scale) {
<       if (center == null && scale == null) {
<          throw new IllegalArgumentException("Both center and scale are null");
<       } else {
<          MatrixModified matrix = new MatrixModified(this.m, this.n);
<          int j;
<          int i;
<          if (center == null) {
<             for(j = 0; j < this.n; ++j) {
<                for(i = 0; i < this.m; ++i) {
<                   matrix.set(i, j, this.get(i, j) / scale[j]);
<                }
<             }
<          } else if (scale == null) {
<             for(j = 0; j < this.n; ++j) {
<                for(i = 0; i < this.m; ++i) {
<                   matrix.set(i, j, this.get(i, j) - center[j]);
<                }
<             }
<          } else {
<             for(j = 0; j < this.n; ++j) {
<                for(i = 0; i < this.m; ++i) {
<                   matrix.set(i, j, (this.get(i, j) - center[j]) / scale[j]);
<                }
<             }
<          }
< 
<          return matrix;
<       }
<    }
< 
<    public MatrixModified inverse() {
<       if (this.m != this.n) {
<          throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
<       } else {
<          MatrixModified lu = this.clone();
<          MatrixModified inv = eye(this.n);
<          int[] ipiv = new int[this.n];
<          int info;
<          if (this.isSymmetric()) {
<             info = LAPACKModified.engine.sysv(lu.layout(), this.uplo, this.n, this.n, lu.A, lu.ld, ipiv, inv.A, inv.ld);
<             if (info != 0) {
<                throw new ArithmeticException("SYSV fails: " + info);
<             }
<          } else {
<             info = LAPACKModified.engine.gesv(lu.layout(), this.n, this.n, lu.A, lu.ld, ipiv, inv.A, inv.ld);
<             if (info != 0) {
<                throw new ArithmeticException("GESV fails: " + info);
<             }
<          }
< 
<          return inv;
<       }
<    }
< 
<    private void mv(TransposeModified trans, double alpha, DoubleBuffer x, double beta, DoubleBuffer y) {
<       DoubleBuffer A = DoubleBuffer.wrap(this.A);
<       if (this.uplo != null) {
<          if (this.diag != null) {
<             if (alpha == 1.0D && beta == 0.0D && x == y) {
<                BLASModified.engine.trmv(this.layout(), this.uplo, trans, this.diag, this.m, (DoubleBuffer)A, this.ld, (DoubleBuffer)y, 1);
<             } else {
<                BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, (DoubleBuffer)A, this.ld, (DoubleBuffer)x, 1, beta, (DoubleBuffer)y, 1);
<             }
<          } else {
<             BLASModified.engine.symv(this.layout(), this.uplo, this.m, alpha, (DoubleBuffer)A, this.ld, (DoubleBuffer)x, 1, beta, (DoubleBuffer)y, 1);
<          }
<       } else {
<          BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, (DoubleBuffer)A, this.ld, (DoubleBuffer)x, 1, beta, (DoubleBuffer)y, 1);
<       }
< 
<    }
< 
<    public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
<       if (this.uplo != null) {
<          if (this.diag != null) {
<             if (alpha == 1.0D && beta == 0.0D && x == y) {
<                BLASModified.engine.trmv(this.layout(), this.uplo, trans, this.diag, this.m, (double[])this.A, this.ld, (double[])y, 1);
<             } else {
<                BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, (double[])this.A, this.ld, (double[])x, 1, beta, (double[])y, 1);
<             }
<          } else {
<             BLASModified.engine.symv(this.layout(), this.uplo, this.m, alpha, (double[])this.A, this.ld, (double[])x, 1, beta, (double[])y, 1);
<          }
<       } else {
<          BLASModified.engine.gemv(this.layout(), trans, this.m, this.n, alpha, (double[])this.A, this.ld, (double[])x, 1, beta, (double[])y, 1);
<       }
< 
<    }
< 
<    public void mv(double[] work, int inputOffset, int outputOffset) {
<       DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.n);
<       DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.m);
<       this.mv(TransposeModified.NO_TRANSPOSE, 1.0D, xb, 0.0D, yb);
<    }
< 
<    public void tv(double[] work, int inputOffset, int outputOffset) {
<       DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.m);
<       DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.n);
<       this.mv(TransposeModified.TRANSPOSE, 1.0D, xb, 0.0D, yb);
<    }
< 
<    public MatrixModified mm(TransposeModified transA, MatrixModified A, TransposeModified transB, MatrixModified B) {
<       return this.mm(transA, A, transB, B, 1.0D, 0.0D);
<    }
< 
<    public MatrixModified mm(TransposeModified transA, MatrixModified A, TransposeModified transB, MatrixModified B, double alpha, double beta) {
<       if (A.isSymmetric() && transB == TransposeModified.NO_TRANSPOSE && B.layout() == this.layout()) {
<          BLASModified.engine.symm(this.layout(), SideModified.LEFT, A.uplo, this.m, this.n, alpha, A.A, A.ld, B.A, B.ld, beta, this.A, this.ld);
<       } else if (B.isSymmetric() && transA == TransposeModified.NO_TRANSPOSE && A.layout() == this.layout()) {
<          BLASModified.engine.symm(this.layout(), SideModified.RIGHT, B.uplo, this.m, this.n, alpha, B.A, B.ld, A.A, A.ld, beta, this.A, this.ld);
<       } else {
<          if (this.layout() != A.layout()) {
<             transA = flip(transA);
<             A = A.transpose();
<          }
< 
<          if (this.layout() != B.layout()) {
<             transB = flip(transB);
<             B = B.transpose();
<          }
< 
<          int k = transA == TransposeModified.NO_TRANSPOSE ? A.n : A.m;
<          BLASModified.engine.gemm(this.layout(), transA, transB, this.m, this.n, k, alpha, A.A, A.ld, B.A, B.ld, beta, this.A, this.ld);
<       }
< 
<       return this;
<    }
< 
<    public MatrixModified ata() {
<       MatrixModified C = new MatrixModified(this.n, this.n);
<       C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, this);
<       C.uplo(UPLOModified.LOWER);
<       return C;
<    }
< 
<    public MatrixModified aat() {
<       MatrixModified C = new MatrixModified(this.m, this.m);
<       C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.TRANSPOSE, this);
<       C.uplo(UPLOModified.LOWER);
<       return C;
<    }
< 
<    public static MatrixModified adb(TransposeModified transA, MatrixModified A, double[] D, TransposeModified transB, MatrixModified B) {
<       int m = A.m;
<       int n = A.n;
<       MatrixModified AD;
<       int j;
<       double dj;
<       int i;
<       if (transA == TransposeModified.NO_TRANSPOSE) {
<          AD = new MatrixModified(m, n);
< 
<          for(j = 0; j < n; ++j) {
<             dj = D[j];
< 
<             for(i = 0; i < m; ++i) {
<                AD.set(i, j, dj * A.get(i, j));
<             }
<          }
<       } else {
<          AD = new MatrixModified(n, m);
< 
<          for(j = 0; j < m; ++j) {
<             dj = D[j];
< 
<             for(i = 0; i < n; ++i) {
<                AD.set(i, j, dj * A.get(j, i));
<             }
<          }
<       }
< 
<       return transB == TransposeModified.NO_TRANSPOSE ? AD.mm(B) : AD.mt(B);
<    }
< 
<    public MatrixModified mm(MatrixModified B) {
<       if (this.n != B.m) {
<          throw new IllegalArgumentException(String.format("Matrix multiplication A * B: %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
<       } else {
<          MatrixModified C = new MatrixModified(this.m, B.n);
<          C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, B);
<          return C;
<       }
<    }
< 
<    public MatrixModified mt(MatrixModified B) {
<       if (this.n != B.n) {
<          throw new IllegalArgumentException(String.format("Matrix multiplication A * B': %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
<       } else {
<          MatrixModified C = new MatrixModified(this.m, B.m);
<          C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.TRANSPOSE, B);
<          return C;
<       }
<    }
< 
<    public MatrixModified tm(MatrixModified B) {
<       if (this.m != B.m) {
<          throw new IllegalArgumentException(String.format("Matrix multiplication A' * B: %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
<       } else {
<          MatrixModified C = new MatrixModified(this.n, B.n);
<          C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, B);
<          return C;
<       }
<    }
< 
<    public MatrixModified tt(MatrixModified B) {
<       if (this.m != B.n) {
<          throw new IllegalArgumentException(String.format("Matrix multiplication A' * B': %d x %d vs %d x %d", this.m, this.n, B.m, B.n));
<       } else {
<          MatrixModified C = new MatrixModified(this.n, B.m);
<          C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.TRANSPOSE, B);
<          return C;
<       }
<    }
< 
<    public MatrixModified.LU lu() {
<       return this.lu(false);
<    }
< 
<    public MatrixModified.LU lu(boolean overwrite) {
<       MatrixModified lu = overwrite ? this : this.clone();
<       int[] ipiv = new int[Math.min(this.m, this.n)];
<       int info = LAPACKModified.engine.getrf(lu.layout(), lu.m, lu.n, lu.A, lu.ld, ipiv);
<       if (info < 0) {
<          logger.error("LAPACK GETRF error code: {}", info);
<          throw new ArithmeticException("LAPACK GETRF error code: " + info);
<       } else {
<          lu.uplo = null;
<          return new MatrixModified.LU(lu, ipiv, info);
<       }
<    }
< 
<    public MatrixModified.Cholesky cholesky() {
<       return this.cholesky(false);
<    }
< 
<    public MatrixModified.Cholesky cholesky(boolean overwrite) {
<       if (this.uplo == null) {
<          throw new IllegalArgumentException("The matrix is not symmetric");
<       } else {
<          MatrixModified lu = overwrite ? this : this.clone();
<          int info = LAPACKModified.engine.potrf(lu.layout(), lu.uplo, lu.n, lu.A, lu.ld);
<          if (info != 0) {
<             logger.error("LAPACK GETRF error code: {}", info);
<             throw new ArithmeticException("LAPACK GETRF error code: " + info);
<          } else {
<             return new MatrixModified.Cholesky(lu);
<          }
<       }
<    }
< 
<    public MatrixModified.QR qr() {
<       return this.qr(false);
<    }
< 
<    public MatrixModified.QR qr(boolean overwrite) {
<       MatrixModified qr = overwrite ? this : this.clone();
<       double[] tau = new double[Math.min(this.m, this.n)];
<       int info = LAPACKModified.engine.geqrf(qr.layout(), qr.m, qr.n, qr.A, qr.ld, tau);
<       if (info != 0) {
<          logger.error("LAPACK GEQRF error code: {}", info);
<          throw new ArithmeticException("LAPACK GEQRF error code: " + info);
<       } else {
<          qr.uplo = null;
<          return new MatrixModified.QR(qr, tau);
<       }
<    }
< 
<    public MatrixModified.SVD svd() {
<       return this.svd(true, false);
<    }
< 
<    public MatrixModified.SVD svd(boolean vectors, boolean overwrite) {
<       int k = Math.min(this.m, this.n);
<       double[] s = new double[k];
<       MatrixModified W = overwrite ? this : this.clone();
<       MatrixModified U;
<       MatrixModified VT;
<       int info;
<       if (vectors) {
<          U = new MatrixModified(this.m, k);
<          VT = new MatrixModified(k, this.n);
<          info = LAPACKModified.engine.gesdd(W.layout(), SVDJobModified.COMPACT, W.m, W.n, W.A, W.ld, s, U.A, U.ld, VT.A, VT.ld);
<          if (info != 0) {
<             logger.error("LAPACK GESDD error code: {}", info);
<             throw new ArithmeticException("LAPACK GESDD error code: " + info);
<          } else {
<             return new MatrixModified.SVD(s, U, VT.transpose());
<          }
<       } else {
<          U = new MatrixModified(1, 1);
<          VT = new MatrixModified(1, 1);
<          info = LAPACKModified.engine.gesdd(W.layout(), SVDJobModified.NO_VECTORS, W.m, W.n, W.A, W.ld, s, U.A, U.ld, VT.A, VT.ld);
<          if (info != 0) {
<             logger.error("LAPACK GESDD error code: {}", info);
<             throw new ArithmeticException("LAPACK GESDD error code: " + info);
<          } else {
<             return new MatrixModified.SVD(this.m, this.n, s);
<          }
<       }
<    }
< 
<    public MatrixModified.EVD eigen() {
<       return this.eigen(false, true, false);
<    }
< 
<    public MatrixModified.EVD eigen(boolean vl, boolean vr, boolean overwrite) {
<       if (this.m != this.n) {
<          throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.m, this.n));
<       } else {
<          MatrixModified eig = overwrite ? this : this.clone();
<          double[] wr;
<          if (this.isSymmetric()) {
<             wr = new double[this.n];
<             int info = LAPACKModified.engine.syevd(eig.layout(), vr ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, eig.uplo, this.n, eig.A, eig.ld, wr);
<             if (info != 0) {
<                logger.error("LAPACK SYEV error code: {}", info);
<                throw new ArithmeticException("LAPACK SYEV error code: " + info);
<             } else {
<                eig.uplo = null;
<                return new MatrixModified.EVD(wr, vr ? eig : null);
<             }
<          } else {
<             wr = new double[this.n];
<             double[] wi = new double[this.n];
<             MatrixModified Vl = vl ? new MatrixModified(this.n, this.n) : new MatrixModified(1, 1);
<             MatrixModified Vr = vr ? new MatrixModified(this.n, this.n) : new MatrixModified(1, 1);
<             int info = LAPACKModified.engine.geev(eig.layout(), vl ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, vr ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, this.n, eig.A, eig.ld, wr, wi, Vl.A, Vl.ld, Vr.A, Vr.ld);
<             if (info != 0) {
<                logger.error("LAPACK GEEV error code: {}", info);
<                throw new ArithmeticException("LAPACK GEEV error code: " + info);
<             } else {
<                return new MatrixModified.EVD(wr, wi, vl ? Vl : null, vr ? Vr : null);
<             }
<          }
<       }
<    }
< 
<    public static class Cholesky implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final MatrixModified lu;
< 
<       public Cholesky(MatrixModified lu) {
<          if (lu.nrow() != lu.ncol()) {
<             throw new UnsupportedOperationException("Cholesky constructor on a non-square matrix");
<          } else {
<             this.lu = lu;
<          }
<       }
< 
<       public double det() {
<          int n = this.lu.n;
<          double d = 1.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             d *= this.lu.get(i, i);
<          }
< 
<          return d * d;
<       }
< 
<       public double logdet() {
<          int n = this.lu.n;
<          double d = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             d += Math.log(this.lu.get(i, i));
<          }
< 
<          return 2.0D * d;
<       }
< 
<       public MatrixModified inverse() {
<          MatrixModified inv = MatrixModified.eye(this.lu.n);
<          this.solve(inv);
<          return inv;
<       }
< 
<       public double[] solve(double[] b) {
<          MatrixModified x = MatrixModified.column(b);
<          this.solve(x);
<          return x.A;
<       }
< 
<       public void solve(MatrixModified B) {
<          if (B.m != this.lu.m) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.m, this.lu.n, B.m, B.n));
<          } else {
<             int info = LAPACKModified.engine.potrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.A, this.lu.ld, B.A, B.ld);
<             if (info != 0) {
<                MatrixModified.logger.error("LAPACK POTRS error code: {}", info);
<                throw new ArithmeticException("LAPACK POTRS error code: " + info);
<             }
<          }
<       }
<    }
< 
<    public static class EVD implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final double[] wr;
<       public final double[] wi;
<       public final MatrixModified Vl;
<       public final MatrixModified Vr;
< 
<       public EVD(double[] w, MatrixModified V) {
<          this.wr = w;
<          this.wi = null;
<          this.Vl = V;
<          this.Vr = V;
<       }
< 
<       public EVD(double[] wr, double[] wi, MatrixModified Vl, MatrixModified Vr) {
<          this.wr = wr;
<          this.wi = wi;
<          this.Vl = Vl;
<          this.Vr = Vr;
<       }
< 
<       public MatrixModified diag() {
<          MatrixModified D = MatrixModified.diag(this.wr);
<          if (this.wi != null) {
<             int n = this.wr.length;
< 
<             for(int i = 0; i < n; ++i) {
<                if (this.wi[i] > 0.0D) {
<                   D.set(i, i + 1, this.wi[i]);
<                } else if (this.wi[i] < 0.0D) {
<                   D.set(i, i - 1, this.wi[i]);
<                }
<             }
<          }
< 
<          return D;
<       }
< 
<       public MatrixModified.EVD sort() {
<          int n = this.wr.length;
<          double[] w = new double[n];
<          int i;
<          if (this.wi != null) {
<             for(i = 0; i < n; ++i) {
<                w[i] = -(this.wr[i] * this.wr[i] + this.wi[i] * this.wi[i]);
<             }
<          } else {
<             for(i = 0; i < n; ++i) {
<                w[i] = -(this.wr[i] * this.wr[i]);
<             }
<          }
< 
<          int[] index = QuickSortModified.sort(w);
<          double[] wr2 = new double[n];
< 
<          for(int j = 0; j < n; ++j) {
<             wr2[j] = this.wr[index[j]];
<          }
< 
<          double[] wi2 = null;
<          if (this.wi != null) {
<             wi2 = new double[n];
< 
<             for(int j = 0; j < n; ++j) {
<                wi2[j] = this.wi[index[j]];
<             }
<          }
< 
<          MatrixModified Vl2 = null;
<          int m;
<          int j;
<          if (this.Vl != null) {
<             int m = this.Vl.m;
<             Vl2 = new MatrixModified(m, n);
< 
<             for(m = 0; m < n; ++m) {
<                for(j = 0; j < m; ++j) {
<                   Vl2.set(j, m, this.Vl.get(j, index[m]));
<                }
<             }
<          }
< 
<          MatrixModified Vr2 = null;
<          if (this.Vr != null) {
<             m = this.Vr.m;
<             Vr2 = new MatrixModified(m, n);
< 
<             for(j = 0; j < n; ++j) {
<                for(int i = 0; i < m; ++i) {
<                   Vr2.set(i, j, this.Vr.get(i, index[j]));
<                }
<             }
<          }
< 
<          return new MatrixModified.EVD(wr2, wi2, Vl2, Vr2);
<       }
<    }
< 
<    public static class LU implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final MatrixModified lu;
<       public final int[] ipiv;
<       public final int info;
< 
<       public LU(MatrixModified lu, int[] ipiv, int info) {
<          this.lu = lu;
<          this.ipiv = ipiv;
<          this.info = info;
<       }
< 
<       public boolean isSingular() {
<          return this.info > 0;
<       }
< 
<       public double det() {
<          int m = this.lu.m;
<          int n = this.lu.n;
<          if (m != n) {
<             throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", m, n));
<          } else {
<             double d = 1.0D;
< 
<             int j;
<             for(j = 0; j < n; ++j) {
<                d *= this.lu.get(j, j);
<             }
< 
<             for(j = 0; j < n; ++j) {
<                if (j + 1 != this.ipiv[j]) {
<                   d = -d;
<                }
<             }
< 
<             return d;
<          }
<       }
< 
<       public MatrixModified inverse() {
<          MatrixModified inv = MatrixModified.eye(this.lu.n);
<          this.solve(inv);
<          return inv;
<       }
< 
<       public double[] solve(double[] b) {
<          MatrixModified x = MatrixModified.column(b);
<          this.solve(x);
<          return x.A;
<       }
< 
<       public void solve(MatrixModified B) {
<          if (this.lu.m != this.lu.n) {
<             throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", this.lu.m, this.lu.n));
<          } else if (B.m != this.lu.m) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.m, this.lu.n, B.m, B.n));
<          } else if (this.lu.layout() != B.layout()) {
<             throw new IllegalArgumentException("The matrix layout is inconsistent.");
<          } else if (this.info > 0) {
<             throw new RuntimeException("The matrix is singular.");
<          } else {
<             int ret = LAPACKModified.engine.getrs(this.lu.layout(), TransposeModified.NO_TRANSPOSE, this.lu.n, B.n, this.lu.A, this.lu.ld, this.ipiv, B.A, B.ld);
<             if (ret != 0) {
<                MatrixModified.logger.error("LAPACK GETRS error code: {}", ret);
<                throw new ArithmeticException("LAPACK GETRS error code: " + ret);
<             }
<          }
<       }
<    }
< 
<    public static class QR implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final MatrixModified qr;
<       public final double[] tau;
< 
<       public QR(MatrixModified qr, double[] tau) {
<          this.qr = qr;
<          this.tau = tau;
<       }
< 
<       public MatrixModified.Cholesky CholeskyOfAtA() {
<          int n = this.qr.n;
<          MatrixModified L = new MatrixModified(n, n);
< 
<          for(int i = 0; i < n; ++i) {
<             for(int j = 0; j <= i; ++j) {
<                L.set(i, j, this.qr.get(j, i));
<             }
<          }
< 
<          L.uplo(UPLOModified.LOWER);
<          return new MatrixModified.Cholesky(L);
<       }
< 
<       public MatrixModified R() {
<          int n = this.qr.n;
<          MatrixModified R = MatrixModified.diag(this.tau);
< 
<          for(int i = 0; i < n; ++i) {
<             for(int j = i; j < n; ++j) {
<                R.set(i, j, this.qr.get(i, j));
<             }
<          }
< 
<          return R;
<       }
< 
<       public MatrixModified Q() {
<          int m = this.qr.m;
<          int n = this.qr.n;
<          int k = Math.min(m, n);
<          MatrixModified Q = this.qr.clone();
<          int info = LAPACKModified.engine.orgqr(this.qr.layout(), m, n, k, Q.A, this.qr.ld, this.tau);
<          if (info != 0) {
<             MatrixModified.logger.error("LAPACK ORGRQ error code: {}", info);
<             throw new ArithmeticException("LAPACK ORGRQ error code: " + info);
<          } else {
<             return Q;
<          }
<       }
< 
<       public double[] solve(double[] b) {
<          if (b.length != this.qr.m) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x 1", this.qr.m, this.qr.n, b.length));
<          } else {
<             MatrixModified x = MatrixModified.column(b);
<             this.solve(x);
<             return Arrays.copyOf(x.A, this.qr.n);
<          }
<       }
< 
<       public void solve(MatrixModified B) {
<          if (B.m != this.qr.m) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.qr.nrow(), this.qr.nrow(), B.nrow(), B.ncol()));
<          } else {
<             int m = this.qr.m;
<             int n = this.qr.n;
<             int k = Math.min(m, n);
<             int info = LAPACKModified.engine.ormqr(this.qr.layout(), SideModified.LEFT, TransposeModified.TRANSPOSE, B.nrow(), B.ncol(), k, this.qr.A, this.qr.ld, this.tau, B.A, B.ld);
<             if (info != 0) {
<                MatrixModified.logger.error("LAPACK ORMQR error code: {}", info);
<                throw new IllegalArgumentException("LAPACK ORMQR error code: " + info);
<             } else {
<                info = LAPACKModified.engine.trtrs(this.qr.layout(), UPLOModified.UPPER, TransposeModified.NO_TRANSPOSE, DiagModified.NON_UNIT, this.qr.n, B.n, this.qr.A, this.qr.ld, B.A, B.ld);
<                if (info != 0) {
<                   MatrixModified.logger.error("LAPACK TRTRS error code: {}", info);
<                   throw new IllegalArgumentException("LAPACK TRTRS error code: " + info);
<                }
<             }
<          }
<       }
<    }
< 
<    private static class RowMajor extends MatrixModified {
<       RowMajor(int m, int n, int ld, double[] A) {
<          super(m, n, ld, A);
<       }
< 
<       public LayoutModified layout() {
<          return LayoutModified.ROW_MAJOR;
<       }
< 
<       protected int index(int i, int j) {
<          return i * this.ld + j;
<       }
<    }
< 
<    public static class SVD implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final int m;
<       public final int n;
<       public final double[] s;
<       public final MatrixModified U;
<       public final MatrixModified V;
<       private transient MatrixModified Ur;
< 
<       public SVD(int m, int n, double[] s) {
<          this.m = m;
<          this.n = n;
<          this.s = s;
<          this.U = null;
<          this.V = null;
<       }
< 
<       public SVD(double[] s, MatrixModified U, MatrixModified V) {
<          this.m = U.m;
<          this.n = V.m;
<          this.s = s;
<          this.U = U;
<          this.V = V;
<       }
< 
<       public MatrixModified diag() {
<          MatrixModified S = new MatrixModified(this.U.m, this.V.m);
< 
<          for(int i = 0; i < this.s.length; ++i) {
<             S.set(i, i, this.s[i]);
<          }
< 
<          return S;
<       }
< 
<       public double norm() {
<          return this.s[0];
<       }
< 
<       private double rcond() {
<          return 0.5D * Math.sqrt((double)(this.m + this.n + 1)) * this.s[0] * MathExModified.EPSILON;
<       }
< 
<       public int rank() {
<          if (this.s.length != Math.min(this.m, this.n)) {
<             throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
<          } else {
<             int r = 0;
<             double tol = this.rcond();
<             double[] var8;
<             int var7 = (var8 = this.s).length;
< 
<             for(int var6 = 0; var6 < var7; ++var6) {
<                double si = var8[var6];
<                if (si > tol) {
<                   ++r;
<                }
<             }
< 
<             return r;
<          }
<       }
< 
<       public int nullity() {
<          return Math.min(this.m, this.n) - this.rank();
<       }
< 
<       public double condition() {
<          if (this.s.length != Math.min(this.m, this.n)) {
<             throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
<          } else {
<             return !(this.s[0] <= 0.0D) && !(this.s[this.s.length - 1] <= 0.0D) ? this.s[0] / this.s[this.s.length - 1] : Double.POSITIVE_INFINITY;
<          }
<       }
< 
<       public MatrixModified range() {
<          if (this.s.length != Math.min(this.m, this.n)) {
<             throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
<          } else if (this.U == null) {
<             throw new IllegalStateException("The left singular vectors are not available.");
<          } else {
<             int r = this.rank();
<             if (r == 0) {
<                return null;
<             } else {
<                MatrixModified R = new MatrixModified(this.m, r);
< 
<                for(int j = 0; j < r; ++j) {
<                   for(int i = 0; i < this.m; ++i) {
<                      R.set(i, j, this.U.get(i, j));
<                   }
<                }
< 
<                return R;
<             }
<          }
<       }
< 
<       public MatrixModified nullspace() {
<          if (this.s.length != Math.min(this.m, this.n)) {
<             throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
<          } else if (this.V == null) {
<             throw new IllegalStateException("The right singular vectors are not available.");
<          } else {
<             int nr = this.nullity();
<             if (nr == 0) {
<                return null;
<             } else {
<                MatrixModified N = new MatrixModified(this.n, nr);
< 
<                for(int j = 0; j < nr; ++j) {
<                   for(int i = 0; i < this.n; ++i) {
<                      N.set(i, j, this.V.get(i, this.n - j - 1));
<                   }
<                }
< 
<                return N;
<             }
<          }
<       }
< 
<       public MatrixModified pinv() {
<          int k = this.s.length;
<          double[] sigma = new double[k];
<          int r = this.rank();
< 
<          for(int i = 0; i < r; ++i) {
<             sigma[i] = 1.0D / this.s[i];
<          }
< 
<          return MatrixModified.adb(TransposeModified.NO_TRANSPOSE, this.V, sigma, TransposeModified.TRANSPOSE, this.U);
<       }
< 
<       public double[] solve(double[] b) {
<          if (this.U != null && this.V != null) {
<             if (b.length != this.m) {
<                throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x 1", this.m, this.n, b.length));
<             } else {
<                int r = this.rank();
<                if (this.Ur == null) {
<                   this.Ur = r == this.U.ncol() ? this.U : this.U.submatrix(0, 0, this.m - 1, r - 1);
<                }
< 
<                double[] Utb = new double[this.s.length];
<                this.Ur.tv(b, Utb);
< 
<                for(int i = 0; i < r; ++i) {
<                   Utb[i] /= this.s[i];
<                }
< 
<                return this.V.mv(Utb);
<             }
<          } else {
<             throw new IllegalStateException("The singular vectors are not available.");
<          }
<       }
<    }
< }
---
> /*      */ package smileModified;
> /*      */ 
> /*      */ import java.io.Serializable;
> /*      */ import java.nio.DoubleBuffer;
> /*      */ import java.util.Arrays;
> /*      */ import org.slf4j.Logger;
> /*      */ import org.slf4j.LoggerFactory;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ public class MatrixModified
> /*      */   extends IMatrixModified
> /*      */ {
> /*      */   private static final long serialVersionUID = 3L;
> /*   32 */   private static final Logger logger = LoggerFactory.getLogger(MatrixModified.class);
> /*      */   double[] A;
> /*      */   int ld;
> /*      */   int m;
> /*      */   int n;
> /*      */   UPLOModified uplo;
> /*      */   DiagModified diag;
> /*      */   
> /*      */   private static class RowMajor
> /*      */     extends MatrixModified
> /*      */   {
> /*      */     RowMajor(int m, int n, int ld, double[] A) {
> /*   44 */       super(m, n, ld, A);
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     public LayoutModified layout() {
> /*   49 */       return LayoutModified.ROW_MAJOR;
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     protected int index(int i, int j) {
> /*   54 */       return i * this.ld + j;
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified(int m, int n) {
> /*   90 */     this(m, n, 0.0D);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified(int m, int n, double a) {
> /*  100 */     if (m <= 0 || n <= 0) {
> /*  101 */       throw new IllegalArgumentException(String.format("Invalid matrix size: %d x %d", new Object[] { Integer.valueOf(m), Integer.valueOf(n) }));
> /*      */     }
> /*      */     
> /*  104 */     this.m = m;
> /*  105 */     this.n = n;
> /*  106 */     this.ld = ld(m);
> /*      */     
> /*  108 */     this.A = new double[this.ld * n];
> /*  109 */     if (a != 0.0D) Arrays.fill(this.A, a);
> /*      */   
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified(int m, int n, int ld, double[] A) {
> /*  120 */     if (layout() == LayoutModified.COL_MAJOR && ld < m) {
> /*  121 */       throw new IllegalArgumentException(String.format("Invalid leading dimension for COL_MAJOR: %d < %d", new Object[] { Integer.valueOf(ld), Integer.valueOf(m) }));
> /*      */     }
> /*      */     
> /*  124 */     if (layout() == LayoutModified.ROW_MAJOR && ld < n) {
> /*  125 */       throw new IllegalArgumentException(String.format("Invalid leading dimension for ROW_MAJOR: %d < %d", new Object[] { Integer.valueOf(ld), Integer.valueOf(n) }));
> /*      */     }
> /*      */     
> /*  128 */     this.m = m;
> /*  129 */     this.n = n;
> /*  130 */     this.ld = ld;
> /*  131 */     this.A = A;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified of(double[][] A) {
> /*  140 */     int m = A.length;
> /*  141 */     int n = (A[0]).length;
> /*  142 */     MatrixModified matrix = new MatrixModified(m, n);
> /*      */     
> /*  144 */     for (int i = 0; i < m; i++) {
> /*  145 */       for (int j = 0; j < n; j++) {
> /*  146 */         matrix.set(i, j, A[i][j]);
> /*      */       }
> /*      */     } 
> /*      */     
> /*  150 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified column(double[] A) {
> /*  159 */     return column(A, 0, A.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified column(double[] A, int offset, int length) {
> /*  172 */     MatrixModified matrix = new MatrixModified(length, 1, length, new double[length]);
> /*  173 */     System.arraycopy(A, offset, matrix.A, 0, length);
> /*  174 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified row(double[] A) {
> /*  183 */     return row(A, 0, A.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified row(double[] A, int offset, int length) {
> /*  196 */     MatrixModified matrix = new MatrixModified(1, length, 1, new double[length]);
> /*  197 */     System.arraycopy(A, offset, matrix.A, 0, length);
> /*  198 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified rand(int m, int n, DistributionModified distribution) {
> /*  210 */     MatrixModified matrix = new MatrixModified(m, n);
> /*      */     
> /*  212 */     for (int j = 0; j < n; j++) {
> /*  213 */       for (int i = 0; i < m; i++) {
> /*  214 */         matrix.set(i, j, distribution.rand());
> /*      */       }
> /*      */     } 
> /*      */     
> /*  218 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified randn(int m, int n) {
> /*  228 */     return rand(m, n, GaussianDistributionModified.getInstance());
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified rand(int m, int n) {
> /*  239 */     MatrixModified matrix = new MatrixModified(m, n);
> /*      */     
> /*  241 */     for (int j = 0; j < n; j++) {
> /*  242 */       for (int i = 0; i < m; i++) {
> /*  243 */         matrix.set(i, j, MathExModified.random());
> /*      */       }
> /*      */     } 
> /*      */     
> /*  247 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified rand(int m, int n, double lo, double hi) {
> /*  260 */     MatrixModified matrix = new MatrixModified(m, n);
> /*      */     
> /*  262 */     for (int j = 0; j < n; j++) {
> /*  263 */       for (int i = 0; i < m; i++) {
> /*  264 */         matrix.set(i, j, MathExModified.random(lo, hi));
> /*      */       }
> /*      */     } 
> /*      */     
> /*  268 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified eye(int n) {
> /*  277 */     return diag(n, 1.0D);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified eye(int m, int n) {
> /*  287 */     return diag(m, n, 1.0D);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified diag(int n, double diag) {
> /*  298 */     return diag(n, n, diag);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified diag(int m, int n, double diag) {
> /*  310 */     MatrixModified D = new MatrixModified(m, n);
> /*  311 */     int k = Math.min(m, n);
> /*  312 */     for (int i = 0; i < k; i++) {
> /*  313 */       D.set(i, i, diag);
> /*      */     }
> /*  315 */     return D;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified diag(double[] diag) {
> /*  325 */     int n = diag.length;
> /*  326 */     MatrixModified D = new MatrixModified(n, n);
> /*  327 */     for (int i = 0; i < n; i++) {
> /*  328 */       D.set(i, i, diag[i]);
> /*      */     }
> /*  330 */     return D;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified toeplitz(double[] a) {
> /*  341 */     int n = a.length;
> /*  342 */     MatrixModified toeplitz = new MatrixModified(n, n);
> /*  343 */     toeplitz.uplo(UPLOModified.LOWER);
> /*      */     
> /*  345 */     for (int i = 0; i < n; i++) {
> /*  346 */       int j; for (j = 0; j < i; j++) {
> /*  347 */         toeplitz.set(i, j, a[i - j]);
> /*      */       }
> /*      */       
> /*  350 */       for (j = i; j < n; j++) {
> /*  351 */         toeplitz.set(i, j, a[j - i]);
> /*      */       }
> /*      */     } 
> /*      */     
> /*  355 */     return toeplitz;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified toeplitz(double[] kl, double[] ku) {
> /*  367 */     if (kl.length != ku.length - 1) {
> /*  368 */       throw new IllegalArgumentException(String.format("Invalid sub-diagonals and super-diagonals size: %d != %d - 1", new Object[] { Integer.valueOf(kl.length), Integer.valueOf(ku.length) }));
> /*      */     }
> /*      */     
> /*  371 */     int n = kl.length;
> /*  372 */     MatrixModified toeplitz = new MatrixModified(n, n);
> /*      */     
> /*  374 */     for (int i = 0; i < n; i++) {
> /*  375 */       int j; for (j = 0; j < i; j++) {
> /*  376 */         toeplitz.set(i, j, kl[i - j]);
> /*      */       }
> /*      */       
> /*  379 */       for (j = i; j < n; j++) {
> /*  380 */         toeplitz.set(i, j, ku[j - i]);
> /*      */       }
> /*      */     } 
> /*      */     
> /*  384 */     return toeplitz;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int nrow() {
> /*  389 */     return this.m;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ncol() {
> /*  394 */     return this.n;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public long size() {
> /*  399 */     return (this.m * this.n);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public LayoutModified layout() {
> /*  407 */     return LayoutModified.COL_MAJOR;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public int ld() {
> /*  415 */     return this.ld;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public boolean isSymmetric() {
> /*  423 */     return (this.uplo != null && this.diag == null);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified uplo(UPLOModified uplo) {
> /*  432 */     if (this.m != this.n) {
> /*  433 */       throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", new Object[] { Integer.valueOf(this.m), Integer.valueOf(this.n) }));
> /*      */     }
> /*      */     
> /*  436 */     this.uplo = uplo;
> /*  437 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public UPLOModified uplo() {
> /*  445 */     return this.uplo;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified triangular(DiagModified diag) {
> /*  454 */     if (this.m != this.n) {
> /*  455 */       throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", new Object[] { Integer.valueOf(this.m), Integer.valueOf(this.n) }));
> /*      */     }
> /*      */     
> /*  458 */     this.diag = diag;
> /*  459 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public DiagModified triangular() {
> /*  468 */     return this.diag;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified clone() {
> /*      */     MatrixModified matrix;
> /*  475 */     if (layout() == LayoutModified.COL_MAJOR) {
> /*  476 */       matrix = new MatrixModified(this.m, this.n, this.ld, (double[])this.A.clone());
> /*      */     } else {
> /*  478 */       matrix = new MatrixModified(this.m, this.n);
> /*  479 */       for (int j = 0; j < this.n; j++) {
> /*  480 */         for (int i = 0; i < this.m; i++) {
> /*  481 */           matrix.set(i, j, get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  486 */     if (this.m == this.n) {
> /*  487 */       matrix.uplo(this.uplo);
> /*  488 */       matrix.triangular(this.diag);
> /*      */     } 
> /*      */     
> /*  491 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double[][] toArray() {
> /*  499 */     double[][] array = new double[this.m][this.n];
> /*  500 */     for (int i = 0; i < this.m; i++) {
> /*  501 */       for (int j = 0; j < this.n; j++) {
> /*  502 */         array[i][j] = get(i, j);
> /*      */       }
> /*      */     } 
> /*  505 */     return array;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified set(MatrixModified b) {
> /*  515 */     this.m = b.m;
> /*  516 */     this.n = b.n;
> /*  517 */     this.diag = b.diag;
> /*  518 */     this.uplo = b.uplo;
> /*      */     
> /*  520 */     if (layout() == b.layout()) {
> /*  521 */       this.A = b.A;
> /*  522 */       this.ld = b.ld;
> /*      */     }
> /*  524 */     else if (layout() == LayoutModified.COL_MAJOR) {
> /*  525 */       this.ld = ld(this.m);
> /*  526 */       this.A = new double[this.ld * this.n];
> /*      */       
> /*  528 */       for (int j = 0; j < this.n; j++) {
> /*  529 */         for (int i = 0; i < this.m; i++) {
> /*  530 */           set(i, j, get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } else {
> /*  534 */       this.ld = ld(this.n);
> /*  535 */       this.A = new double[this.ld * this.m];
> /*      */       
> /*  537 */       for (int i = 0; i < this.m; i++) {
> /*  538 */         for (int j = 0; j < this.n; j++) {
> /*  539 */           set(i, j, get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */ 
> /*      */     
> /*  545 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   protected int index(int i, int j) {
> /*  555 */     return j * this.ld + i;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public double get(int i, int j) {
> /*  560 */     return this.A[index(i, j)];
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void set(int i, int j, double x) {
> /*  565 */     this.A[index(i, j)] = x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified get(int[] rows, int[] cols) {
> /*  577 */     MatrixModified sub = new MatrixModified(rows.length, cols.length);
> /*  578 */     for (int j = 0; j < cols.length; j++) {
> /*  579 */       int col = cols[j];
> /*  580 */       if (col < 0) col = this.n + col; 
> /*  581 */       for (int i = 0; i < rows.length; i++) {
> /*  582 */         int row = rows[i];
> /*  583 */         if (row < 0) row = this.m + row; 
> /*  584 */         sub.set(i, j, get(row, col));
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  588 */     return sub;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double[] row(int i) {
> /*  597 */     double[] x = new double[this.n];
> /*  598 */     if (i < 0) i = this.m + i;
> /*      */     
> /*  600 */     if (layout() == LayoutModified.COL_MAJOR) {
> /*  601 */       for (int j = 0; j < this.n; j++) {
> /*  602 */         x[j] = get(i, j);
> /*      */       }
> /*      */     } else {
> /*  605 */       System.arraycopy(this.A, index(i, 0), x, 0, this.n);
> /*      */     } 
> /*      */     
> /*  608 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double[] col(int j) {
> /*  617 */     double[] x = new double[this.m];
> /*  618 */     if (j < 0) j = this.n + j;
> /*      */     
> /*  620 */     if (layout() == LayoutModified.COL_MAJOR) {
> /*  621 */       System.arraycopy(this.A, index(0, j), x, 0, this.m);
> /*      */     } else {
> /*  623 */       for (int i = 0; i < this.m; i++) {
> /*  624 */         x[i] = get(i, j);
> /*      */       }
> /*      */     } 
> /*      */     
> /*  628 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified rows(int... rows) {
> /*  637 */     MatrixModified x = new MatrixModified(rows.length, this.n);
> /*      */     
> /*  639 */     for (int i = 0; i < rows.length; i++) {
> /*  640 */       int row = rows[i];
> /*  641 */       if (row < 0) row = this.m + row; 
> /*  642 */       if (layout() == LayoutModified.COL_MAJOR) {
> /*  643 */         for (int j = 0; j < this.n; j++) {
> /*  644 */           x.set(i, j, get(row, j));
> /*      */         }
> /*      */       } else {
> /*  647 */         System.arraycopy(this.A, index(row, 0), x.A, x.index(i, 0), this.n);
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  651 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified cols(int... cols) {
> /*  660 */     MatrixModified x = new MatrixModified(this.m, cols.length);
> /*      */     
> /*  662 */     for (int j = 0; j < cols.length; j++) {
> /*  663 */       int col = cols[j];
> /*  664 */       if (col < 0) col = this.n + col; 
> /*  665 */       if (layout() == LayoutModified.COL_MAJOR) {
> /*  666 */         System.arraycopy(this.A, index(0, col), x.A, x.index(0, j), this.m);
> /*      */       } else {
> /*  668 */         for (int i = 0; i < this.m; i++) {
> /*  669 */           x.set(i, j, get(i, col));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  674 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified submatrix(int i, int j, int k, int l) {
> /*  687 */     if (i < 0 || i >= this.m || k < i || k >= this.m || j < 0 || j >= this.n || l < j || l >= this.n) {
> /*  688 */       throw new IllegalArgumentException(String.format("Invalid submatrix range (%d:%d, %d:%d) of %d x %d", new Object[] { Integer.valueOf(i), Integer.valueOf(k), Integer.valueOf(j), Integer.valueOf(l), Integer.valueOf(this.m), Integer.valueOf(this.n) }));
> /*      */     }
> /*      */     
> /*  691 */     MatrixModified sub = new MatrixModified(k - i + 1, l - j + 1);
> /*  692 */     for (int jj = j; jj <= l; jj++) {
> /*  693 */       for (int ii = i; ii <= k; ii++) {
> /*  694 */         sub.set(ii - i, jj - j, get(ii, jj));
> /*      */       }
> /*      */     } 
> /*      */     
> /*  698 */     return sub;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public void fill(double x) {
> /*  706 */     Arrays.fill(this.A, x);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified transpose() {
> /*  717 */     return transpose(true);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified transpose(boolean share) {
> /*      */     MatrixModified matrix;
> /*  729 */     if (share) {
> /*  730 */       if (layout() == LayoutModified.ROW_MAJOR) {
> /*  731 */         matrix = new MatrixModified(this.n, this.m, this.ld, this.A);
> /*      */       } else {
> /*  733 */         matrix = new RowMajor(this.n, this.m, this.ld, this.A);
> /*      */       } 
> /*      */     } else {
> /*  736 */       matrix = new MatrixModified(this.n, this.m);
> /*  737 */       for (int j = 0; j < this.m; j++) {
> /*  738 */         for (int i = 0; i < this.n; i++) {
> /*  739 */           matrix.set(i, j, get(j, i));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  744 */     if (this.m == this.n) {
> /*  745 */       matrix.uplo(this.uplo);
> /*  746 */       matrix.triangular(this.diag);
> /*      */     } 
> /*      */     
> /*  749 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public boolean equals(Object o) {
> /*  754 */     if (!(o instanceof MatrixModified)) {
> /*  755 */       return false;
> /*      */     }
> /*      */     
> /*  758 */     return equals((MatrixModified)o, 1.0E-10D);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public boolean equals(MatrixModified o, double epsilon) {
> /*  769 */     if (this.m != o.m || this.n != o.n) {
> /*  770 */       return false;
> /*      */     }
> /*      */     
> /*  773 */     for (int j = 0; j < this.n; j++) {
> /*  774 */       for (int i = 0; i < this.m; i++) {
> /*  775 */         if (!MathExModified.isZero(get(i, j) - o.get(i, j), epsilon)) {
> /*  776 */           return false;
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  781 */     return true;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double add(int i, int j, double b) {
> /*  792 */     this.A[index(i, j)] = this.A[index(i, j)] + b; return this.A[index(i, j)] + b;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double sub(int i, int j, double b) {
> /*  803 */     this.A[index(i, j)] = this.A[index(i, j)] - b; return this.A[index(i, j)] - b;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double mul(int i, int j, double b) {
> /*  814 */     this.A[index(i, j)] = this.A[index(i, j)] * b; return this.A[index(i, j)] * b;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double div(int i, int j, double b) {
> /*  825 */     this.A[index(i, j)] = this.A[index(i, j)] / b; return this.A[index(i, j)] / b;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified addDiag(double b) {
> /*  834 */     int l = Math.min(this.m, this.n);
> /*  835 */     for (int i = 0; i < l; i++) {
> /*  836 */       this.A[index(i, i)] = this.A[index(i, i)] + b;
> /*      */     }
> /*      */     
> /*  839 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified addDiag(double[] b) {
> /*  848 */     int l = Math.min(this.m, this.n);
> /*  849 */     if (b.length != l) {
> /*  850 */       throw new IllegalArgumentException("Invalid diagonal array size: " + b.length);
> /*      */     }
> /*      */     
> /*  853 */     for (int i = 0; i < l; i++) {
> /*  854 */       this.A[index(i, i)] = this.A[index(i, i)] + b[i];
> /*      */     }
> /*      */     
> /*  857 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified add(double b) {
> /*  866 */     for (int i = 0; i < this.A.length; i++) {
> /*  867 */       this.A[i] = this.A[i] + b;
> /*      */     }
> /*      */     
> /*  870 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified sub(double b) {
> /*  880 */     for (int i = 0; i < this.A.length; i++) {
> /*  881 */       this.A[i] = this.A[i] - b;
> /*      */     }
> /*      */     
> /*  884 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified mul(double b) {
> /*  893 */     for (int i = 0; i < this.A.length; i++) {
> /*  894 */       this.A[i] = this.A[i] * b;
> /*      */     }
> /*      */     
> /*  897 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified div(double b) {
> /*  906 */     for (int i = 0; i < this.A.length; i++) {
> /*  907 */       this.A[i] = this.A[i] / b;
> /*      */     }
> /*      */     
> /*  910 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified add(MatrixModified B) {
> /*  919 */     if (this.m != B.m || this.n != B.n) {
> /*  920 */       throw new IllegalArgumentException("Matrix is not of same size.");
> /*      */     }
> /*      */     
> /*  923 */     if (layout() == B.layout() && this.ld == B.ld) {
> /*  924 */       for (int i = 0; i < this.A.length; i++) {
> /*  925 */         this.A[i] = this.A[i] + B.A[i];
> /*      */       }
> /*      */     } else {
> /*  928 */       for (int j = 0; j < this.n; j++) {
> /*  929 */         for (int i = 0; i < this.m; i++) {
> /*  930 */           add(i, j, B.get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  935 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified sub(MatrixModified B) {
> /*  944 */     if (this.m != B.m || this.n != B.n) {
> /*  945 */       throw new IllegalArgumentException("Matrix is not of same size.");
> /*      */     }
> /*      */     
> /*  948 */     if (layout() == B.layout() && this.ld == B.ld) {
> /*  949 */       for (int i = 0; i < this.A.length; i++) {
> /*  950 */         this.A[i] = this.A[i] - B.A[i];
> /*      */       }
> /*      */     } else {
> /*  953 */       for (int j = 0; j < this.n; j++) {
> /*  954 */         for (int i = 0; i < this.m; i++) {
> /*  955 */           sub(i, j, B.get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  960 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified mul(MatrixModified B) {
> /*  969 */     if (this.m != B.m || this.n != B.n) {
> /*  970 */       throw new IllegalArgumentException("Matrix is not of same size.");
> /*      */     }
> /*      */     
> /*  973 */     if (layout() == B.layout() && this.ld == B.ld) {
> /*  974 */       for (int i = 0; i < this.A.length; i++) {
> /*  975 */         this.A[i] = this.A[i] * B.A[i];
> /*      */       }
> /*      */     } else {
> /*  978 */       for (int j = 0; j < this.n; j++) {
> /*  979 */         for (int i = 0; i < this.m; i++) {
> /*  980 */           mul(i, j, B.get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /*  985 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified div(MatrixModified B) {
> /*  994 */     if (this.m != B.m || this.n != B.n) {
> /*  995 */       throw new IllegalArgumentException("Matrix is not of same size.");
> /*      */     }
> /*      */     
> /*  998 */     if (layout() == B.layout() && this.ld == B.ld) {
> /*  999 */       for (int i = 0; i < this.A.length; i++) {
> /* 1000 */         this.A[i] = this.A[i] / B.A[i];
> /*      */       }
> /*      */     } else {
> /* 1003 */       for (int j = 0; j < this.n; j++) {
> /* 1004 */         for (int i = 0; i < this.m; i++) {
> /* 1005 */           div(i, j, B.get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1010 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified add(double beta, MatrixModified B) {
> /* 1020 */     if (this.m != B.m || this.n != B.n) {
> /* 1021 */       throw new IllegalArgumentException("Matrix is not of same size.");
> /*      */     }
> /*      */     
> /* 1024 */     if (layout() == B.layout() && this.ld == B.ld) {
> /* 1025 */       for (int i = 0; i < this.A.length; i++) {
> /* 1026 */         this.A[i] = this.A[i] + beta * B.A[i];
> /*      */       }
> /*      */     } else {
> /* 1029 */       for (int j = 0; j < this.n; j++) {
> /* 1030 */         for (int i = 0; i < this.m; i++) {
> /* 1031 */           add(i, j, beta * B.get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1036 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified add(double alpha, double beta, MatrixModified B) {
> /* 1047 */     if (this.m != B.m || this.n != B.n) {
> /* 1048 */       throw new IllegalArgumentException("Matrix B is not of same size.");
> /*      */     }
> /*      */     
> /* 1051 */     if (layout() == B.layout() && this.ld == B.ld) {
> /* 1052 */       for (int i = 0; i < this.A.length; i++) {
> /* 1053 */         this.A[i] = alpha * this.A[i] + beta * B.A[i];
> /*      */       }
> /*      */     } else {
> /* 1056 */       for (int j = 0; j < this.n; j++) {
> /* 1057 */         for (int i = 0; i < this.m; i++) {
> /* 1058 */           set(i, j, alpha * get(i, j) + beta * B.get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1063 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified add2(double alpha, double beta, MatrixModified B) {
> /* 1074 */     if (this.m != B.m || this.n != B.n) {
> /* 1075 */       throw new IllegalArgumentException("Matrix B is not of same size.");
> /*      */     }
> /*      */     
> /* 1078 */     if (layout() == B.layout() && this.ld == B.ld) {
> /* 1079 */       for (int i = 0; i < this.A.length; i++) {
> /* 1080 */         this.A[i] = alpha * this.A[i] + beta * B.A[i] * B.A[i];
> /*      */       }
> /*      */     } else {
> /* 1083 */       for (int j = 0; j < this.n; j++) {
> /* 1084 */         for (int i = 0; i < this.m; i++) {
> /* 1085 */           set(i, j, alpha * get(i, j) + beta * B.get(i, j) * B.get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1090 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified add(double alpha, MatrixModified A, double beta, MatrixModified B) {
> /* 1102 */     if (this.m != A.m || this.n != A.n) {
> /* 1103 */       throw new IllegalArgumentException("Matrix A is not of same size.");
> /*      */     }
> /*      */     
> /* 1106 */     if (this.m != B.m || this.n != B.n) {
> /* 1107 */       throw new IllegalArgumentException("Matrix B is not of same size.");
> /*      */     }
> /*      */     
> /* 1110 */     if (layout() == A.layout() && layout() == B.layout() && this.ld == A.ld && this.ld == B.ld) {
> /* 1111 */       for (int i = 0; i < this.A.length; i++) {
> /* 1112 */         this.A[i] = alpha * A.A[i] + beta * B.A[i];
> /*      */       }
> /*      */     } else {
> /* 1115 */       for (int j = 0; j < this.n; j++) {
> /* 1116 */         for (int i = 0; i < this.m; i++) {
> /* 1117 */           set(i, j, alpha * A.get(i, j) + beta * B.get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1122 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified add(double alpha, double[] x, double[] y) {
> /* 1133 */     if (this.m != x.length || this.n != y.length) {
> /* 1134 */       throw new IllegalArgumentException("Matrix is not of same size.");
> /*      */     }
> /*      */     
> /* 1137 */     if (isSymmetric() && x == y) {
> /* 1138 */       BLASModified.engine.syr(layout(), this.uplo, this.m, alpha, x, 1, this.A, this.ld);
> /*      */     } else {
> /* 1140 */       BLASModified.engine.ger(layout(), this.m, this.n, alpha, x, 1, y, 1, this.A, this.ld);
> /*      */     } 
> /*      */     
> /* 1143 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified replaceNaN(double x) {
> /* 1152 */     for (int i = 0; i < this.A.length; i++) {
> /* 1153 */       if (Double.isNaN(this.A[i])) {
> /* 1154 */         this.A[i] = x;
> /*      */       }
> /*      */     } 
> /*      */     
> /* 1158 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double sum() {
> /* 1166 */     double s = 0.0D;
> /* 1167 */     for (int j = 0; j < this.n; j++) {
> /* 1168 */       for (int i = 0; i < this.m; i++) {
> /* 1169 */         s += get(i, j);
> /*      */       }
> /*      */     } 
> /*      */     
> /* 1173 */     return s;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double norm1() {
> /* 1181 */     double f = 0.0D;
> /* 1182 */     for (int j = 0; j < this.n; j++) {
> /* 1183 */       double s = 0.0D;
> /* 1184 */       for (int i = 0; i < this.m; i++) {
> /* 1185 */         s += Math.abs(get(i, j));
> /*      */       }
> /* 1187 */       f = Math.max(f, s);
> /*      */     } 
> /*      */     
> /* 1190 */     return f;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double norm2() {
> /* 1198 */     return (svd(false, false)).s[0];
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double norm() {
> /* 1206 */     return norm2();
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double normInf() {
> /* 1214 */     double[] f = new double[this.m];
> /* 1215 */     for (int j = 0; j < this.n; j++) {
> /* 1216 */       for (int i = 0; i < this.m; i++) {
> /* 1217 */         f[i] = f[i] + Math.abs(get(i, j));
> /*      */       }
> /*      */     } 
> /*      */     
> /* 1221 */     return MathExModified.max(f);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double normFro() {
> /* 1229 */     double f = 0.0D;
> /* 1230 */     for (int j = 0; j < this.n; j++) {
> /* 1231 */       for (int i = 0; i < this.m; i++) {
> /* 1232 */         f = Math.hypot(f, get(i, j));
> /*      */       }
> /*      */     } 
> /*      */     
> /* 1236 */     return f;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double xAx(double[] x) {
> /* 1247 */     if (this.m != this.n) {
> /* 1248 */       throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", new Object[] { Integer.valueOf(this.m), Integer.valueOf(this.n) }));
> /*      */     }
> /*      */     
> /* 1251 */     if (this.n != x.length) {
> /* 1252 */       throw new IllegalArgumentException(String.format("Matrix: %d x %d, Vector: %d", new Object[] { Integer.valueOf(this.m), Integer.valueOf(this.n), Integer.valueOf(x.length) }));
> /*      */     }
> /*      */     
> /* 1255 */     double[] Ax = mv(x);
> /* 1256 */     return MathExModified.dot(x, Ax);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double[] rowSums() {
> /* 1264 */     double[] x = new double[this.m];
> /*      */     
> /* 1266 */     for (int j = 0; j < this.n; j++) {
> /* 1267 */       for (int i = 0; i < this.m; i++) {
> /* 1268 */         x[i] = x[i] + get(i, j);
> /*      */       }
> /*      */     } 
> /*      */     
> /* 1272 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double[] rowMeans() {
> /* 1280 */     double[] x = rowSums();
> /*      */     
> /* 1282 */     for (int i = 0; i < this.m; i++) {
> /* 1283 */       x[i] = x[i] / this.n;
> /*      */     }
> /*      */     
> /* 1286 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double[] rowSds() {
> /* 1294 */     double[] x = new double[this.m];
> /* 1295 */     double[] x2 = new double[this.m];
> /*      */     
> /* 1297 */     for (int j = 0; j < this.n; j++) {
> /* 1298 */       for (int k = 0; k < this.m; k++) {
> /* 1299 */         double a = get(k, j);
> /* 1300 */         x[k] = x[k] + a;
> /* 1301 */         x2[k] = x2[k] + a * a;
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1305 */     for (int i = 0; i < this.m; i++) {
> /* 1306 */       double mu = x[i] / this.n;
> /* 1307 */       x[i] = Math.sqrt(x2[i] / this.n - mu * mu);
> /*      */     } 
> /*      */     
> /* 1310 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double[] colSums() {
> /* 1318 */     double[] x = new double[this.n];
> /*      */     
> /* 1320 */     for (int j = 0; j < this.n; j++) {
> /* 1321 */       for (int i = 0; i < this.m; i++) {
> /* 1322 */         x[j] = x[j] + get(i, j);
> /*      */       }
> /*      */     } 
> /*      */     
> /* 1326 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double[] colMeans() {
> /* 1334 */     double[] x = colSums();
> /*      */     
> /* 1336 */     for (int j = 0; j < this.n; j++) {
> /* 1337 */       x[j] = x[j] / this.m;
> /*      */     }
> /*      */     
> /* 1340 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public double[] colSds() {
> /* 1348 */     double[] x = new double[this.n];
> /*      */     
> /* 1350 */     for (int j = 0; j < this.n; j++) {
> /* 1351 */       double mu = 0.0D;
> /* 1352 */       double sumsq = 0.0D;
> /* 1353 */       for (int i = 0; i < this.m; i++) {
> /* 1354 */         double a = get(i, j);
> /* 1355 */         mu += a;
> /* 1356 */         sumsq += a * a;
> /*      */       } 
> /* 1358 */       mu /= this.m;
> /* 1359 */       x[j] = Math.sqrt(sumsq / this.m - mu * mu);
> /*      */     } 
> /*      */     
> /* 1362 */     return x;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified standardize() {
> /* 1370 */     double[] center = colMeans();
> /* 1371 */     double[] scale = colSds();
> /* 1372 */     return scale(center, scale);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified scale(double[] center, double[] scale) {
> /* 1382 */     if (center == null && scale == null) {
> /* 1383 */       throw new IllegalArgumentException("Both center and scale are null");
> /*      */     }
> /*      */     
> /* 1386 */     MatrixModified matrix = new MatrixModified(this.m, this.n);
> /*      */     
> /* 1388 */     if (center == null) {
> /* 1389 */       for (int j = 0; j < this.n; j++) {
> /* 1390 */         for (int i = 0; i < this.m; i++) {
> /* 1391 */           matrix.set(i, j, get(i, j) / scale[j]);
> /*      */         }
> /*      */       } 
> /* 1394 */     } else if (scale == null) {
> /* 1395 */       for (int j = 0; j < this.n; j++) {
> /* 1396 */         for (int i = 0; i < this.m; i++) {
> /* 1397 */           matrix.set(i, j, get(i, j) - center[j]);
> /*      */         }
> /*      */       } 
> /*      */     } else {
> /* 1401 */       for (int j = 0; j < this.n; j++) {
> /* 1402 */         for (int i = 0; i < this.m; i++) {
> /* 1403 */           matrix.set(i, j, (get(i, j) - center[j]) / scale[j]);
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1408 */     return matrix;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified inverse() {
> /* 1416 */     if (this.m != this.n) {
> /* 1417 */       throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", new Object[] { Integer.valueOf(this.m), Integer.valueOf(this.n) }));
> /*      */     }
> /*      */     
> /* 1420 */     MatrixModified lu = clone();
> /* 1421 */     MatrixModified inv = eye(this.n);
> /* 1422 */     int[] ipiv = new int[this.n];
> /* 1423 */     if (isSymmetric()) {
> /* 1424 */       int info = LAPACKModified.engine.sysv(lu.layout(), this.uplo, this.n, this.n, lu.A, lu.ld, ipiv, inv.A, inv.ld);
> /* 1425 */       if (info != 0) {
> /* 1426 */         throw new ArithmeticException("SYSV fails: " + info);
> /*      */       }
> /*      */     } else {
> /* 1429 */       int info = LAPACKModified.engine.gesv(lu.layout(), this.n, this.n, lu.A, lu.ld, ipiv, inv.A, inv.ld);
> /* 1430 */       if (info != 0) {
> /* 1431 */         throw new ArithmeticException("GESV fails: " + info);
> /*      */       }
> /*      */     } 
> /*      */     
> /* 1435 */     return inv;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   private void mv(TransposeModified trans, double alpha, DoubleBuffer x, double beta, DoubleBuffer y) {
> /* 1451 */     DoubleBuffer A = DoubleBuffer.wrap(this.A);
> /* 1452 */     if (this.uplo != null) {
> /* 1453 */       if (this.diag != null) {
> /* 1454 */         if (alpha == 1.0D && beta == 0.0D && x == y) {
> /* 1455 */           BLASModified.engine.trmv(layout(), this.uplo, trans, this.diag, this.m, A, this.ld, y, 1);
> /*      */         } else {
> /* 1457 */           BLASModified.engine.gemv(layout(), trans, this.m, this.n, alpha, A, this.ld, x, 1, beta, y, 1);
> /*      */         } 
> /*      */       } else {
> /* 1460 */         BLASModified.engine.symv(layout(), this.uplo, this.m, alpha, A, this.ld, x, 1, beta, y, 1);
> /*      */       } 
> /*      */     } else {
> /* 1463 */       BLASModified.engine.gemv(layout(), trans, this.m, this.n, alpha, A, this.ld, x, 1, beta, y, 1);
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
> /* 1469 */     if (this.uplo != null) {
> /* 1470 */       if (this.diag != null) {
> /* 1471 */         if (alpha == 1.0D && beta == 0.0D && x == y) {
> /* 1472 */           BLASModified.engine.trmv(layout(), this.uplo, trans, this.diag, this.m, this.A, this.ld, y, 1);
> /*      */         } else {
> /* 1474 */           BLASModified.engine.gemv(layout(), trans, this.m, this.n, alpha, this.A, this.ld, x, 1, beta, y, 1);
> /*      */         } 
> /*      */       } else {
> /* 1477 */         BLASModified.engine.symv(layout(), this.uplo, this.m, alpha, this.A, this.ld, x, 1, beta, y, 1);
> /*      */       } 
> /*      */     } else {
> /* 1480 */       BLASModified.engine.gemv(layout(), trans, this.m, this.n, alpha, this.A, this.ld, x, 1, beta, y, 1);
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void mv(double[] work, int inputOffset, int outputOffset) {
> /* 1486 */     DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.n);
> /* 1487 */     DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.m);
> /* 1488 */     mv(TransposeModified.NO_TRANSPOSE, 1.0D, xb, 0.0D, yb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void tv(double[] work, int inputOffset, int outputOffset) {
> /* 1493 */     DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.m);
> /* 1494 */     DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.n);
> /* 1495 */     mv(TransposeModified.TRANSPOSE, 1.0D, xb, 0.0D, yb);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified mm(TransposeModified transA, MatrixModified A, TransposeModified transB, MatrixModified B) {
> /* 1512 */     return mm(transA, A, transB, B, 1.0D, 0.0D);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified mm(TransposeModified transA, MatrixModified A, TransposeModified transB, MatrixModified B, double alpha, double beta) {
> /* 1531 */     if (A.isSymmetric() && transB == TransposeModified.NO_TRANSPOSE && B.layout() == layout()) {
> /* 1532 */       BLASModified.engine.symm(layout(), SideModified.LEFT, A.uplo, this.m, this.n, alpha, A.A, A.ld, B.A, B.ld, beta, this.A, this.ld);
> /* 1533 */     } else if (B.isSymmetric() && transA == TransposeModified.NO_TRANSPOSE && A.layout() == layout()) {
> /* 1534 */       BLASModified.engine.symm(layout(), SideModified.RIGHT, B.uplo, this.m, this.n, alpha, B.A, B.ld, A.A, A.ld, beta, this.A, this.ld);
> /*      */     } else {
> /* 1536 */       if (layout() != A.layout()) {
> /* 1537 */         transA = flip(transA);
> /* 1538 */         A = A.transpose();
> /*      */       } 
> /* 1540 */       if (layout() != B.layout()) {
> /* 1541 */         transB = flip(transB);
> /* 1542 */         B = B.transpose();
> /*      */       } 
> /* 1544 */       int k = (transA == TransposeModified.NO_TRANSPOSE) ? A.n : A.m;
> /*      */       
> /* 1546 */       BLASModified.engine.gemm(layout(), transA, transB, this.m, this.n, k, alpha, A.A, A.ld, B.A, B.ld, beta, this.A, this.ld);
> /*      */     } 
> /* 1548 */     return this;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified ata() {
> /* 1556 */     MatrixModified C = new MatrixModified(this.n, this.n);
> /* 1557 */     C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, this);
> /* 1558 */     C.uplo(UPLOModified.LOWER);
> /* 1559 */     return C;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified aat() {
> /* 1567 */     MatrixModified C = new MatrixModified(this.m, this.m);
> /* 1568 */     C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.TRANSPOSE, this);
> /* 1569 */     C.uplo(UPLOModified.LOWER);
> /* 1570 */     return C;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static MatrixModified adb(TransposeModified transA, MatrixModified A, double[] D, TransposeModified transB, MatrixModified B) {
> /*      */     MatrixModified AD;
> /* 1586 */     int m = A.m, n = A.n;
> /* 1587 */     if (transA == TransposeModified.NO_TRANSPOSE) {
> /* 1588 */       AD = new MatrixModified(m, n);
> /* 1589 */       for (int j = 0; j < n; j++) {
> /* 1590 */         double dj = D[j];
> /* 1591 */         for (int i = 0; i < m; i++) {
> /* 1592 */           AD.set(i, j, dj * A.get(i, j));
> /*      */         }
> /*      */       } 
> /*      */     } else {
> /* 1596 */       AD = new MatrixModified(n, m);
> /* 1597 */       for (int j = 0; j < m; j++) {
> /* 1598 */         double dj = D[j];
> /* 1599 */         for (int i = 0; i < n; i++) {
> /* 1600 */           AD.set(i, j, dj * A.get(j, i));
> /*      */         }
> /*      */       } 
> /*      */     } 
> /*      */     
> /* 1605 */     return (transB == TransposeModified.NO_TRANSPOSE) ? AD.mm(B) : AD.mt(B);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified mm(MatrixModified B) {
> /* 1614 */     if (this.n != B.m) {
> /* 1615 */       throw new IllegalArgumentException(String.format("Matrix multiplication A * B: %d x %d vs %d x %d", new Object[] { Integer.valueOf(this.m), Integer.valueOf(this.n), Integer.valueOf(B.m), Integer.valueOf(B.n) }));
> /*      */     }
> /*      */     
> /* 1618 */     MatrixModified C = new MatrixModified(this.m, B.n);
> /* 1619 */     C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, B);
> /* 1620 */     return C;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified mt(MatrixModified B) {
> /* 1629 */     if (this.n != B.n) {
> /* 1630 */       throw new IllegalArgumentException(String.format("Matrix multiplication A * B': %d x %d vs %d x %d", new Object[] { Integer.valueOf(this.m), Integer.valueOf(this.n), Integer.valueOf(B.m), Integer.valueOf(B.n) }));
> /*      */     }
> /*      */     
> /* 1633 */     MatrixModified C = new MatrixModified(this.m, B.m);
> /* 1634 */     C.mm(TransposeModified.NO_TRANSPOSE, this, TransposeModified.TRANSPOSE, B);
> /* 1635 */     return C;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified tm(MatrixModified B) {
> /* 1644 */     if (this.m != B.m) {
> /* 1645 */       throw new IllegalArgumentException(String.format("Matrix multiplication A' * B: %d x %d vs %d x %d", new Object[] { Integer.valueOf(this.m), Integer.valueOf(this.n), Integer.valueOf(B.m), Integer.valueOf(B.n) }));
> /*      */     }
> /*      */     
> /* 1648 */     MatrixModified C = new MatrixModified(this.n, B.n);
> /* 1649 */     C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.NO_TRANSPOSE, B);
> /* 1650 */     return C;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public MatrixModified tt(MatrixModified B) {
> /* 1659 */     if (this.m != B.n) {
> /* 1660 */       throw new IllegalArgumentException(String.format("Matrix multiplication A' * B': %d x %d vs %d x %d", new Object[] { Integer.valueOf(this.m), Integer.valueOf(this.n), Integer.valueOf(B.m), Integer.valueOf(B.n) }));
> /*      */     }
> /*      */     
> /* 1663 */     MatrixModified C = new MatrixModified(this.n, B.m);
> /* 1664 */     C.mm(TransposeModified.TRANSPOSE, this, TransposeModified.TRANSPOSE, B);
> /* 1665 */     return C;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public LU lu() {
> /* 1673 */     return lu(false);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public LU lu(boolean overwrite) {
> /* 1683 */     MatrixModified lu = overwrite ? this : clone();
> /* 1684 */     int[] ipiv = new int[Math.min(this.m, this.n)];
> /* 1685 */     int info = LAPACKModified.engine.getrf(lu.layout(), lu.m, lu.n, lu.A, lu.ld, ipiv);
> /* 1686 */     if (info < 0) {
> /* 1687 */       logger.error("LAPACK GETRF error code: {}", Integer.valueOf(info));
> /* 1688 */       throw new ArithmeticException("LAPACK GETRF error code: " + info);
> /*      */     } 
> /*      */     
> /* 1691 */     lu.uplo = null;
> /* 1692 */     return new LU(lu, ipiv, info);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public Cholesky cholesky() {
> /* 1702 */     return cholesky(false);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public Cholesky cholesky(boolean overwrite) {
> /* 1713 */     if (this.uplo == null) {
> /* 1714 */       throw new IllegalArgumentException("The matrix is not symmetric");
> /*      */     }
> /*      */     
> /* 1717 */     MatrixModified lu = overwrite ? this : clone();
> /* 1718 */     int info = LAPACKModified.engine.potrf(lu.layout(), lu.uplo, lu.n, lu.A, lu.ld);
> /* 1719 */     if (info != 0) {
> /* 1720 */       logger.error("LAPACK GETRF error code: {}", Integer.valueOf(info));
> /* 1721 */       throw new ArithmeticException("LAPACK GETRF error code: " + info);
> /*      */     } 
> /*      */     
> /* 1724 */     return new Cholesky(lu);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public QR qr() {
> /* 1732 */     return qr(false);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public QR qr(boolean overwrite) {
> /* 1742 */     MatrixModified qr = overwrite ? this : clone();
> /* 1743 */     double[] tau = new double[Math.min(this.m, this.n)];
> /* 1744 */     int info = LAPACKModified.engine.geqrf(qr.layout(), qr.m, qr.n, qr.A, qr.ld, tau);
> /* 1745 */     if (info != 0) {
> /* 1746 */       logger.error("LAPACK GEQRF error code: {}", Integer.valueOf(info));
> /* 1747 */       throw new ArithmeticException("LAPACK GEQRF error code: " + info);
> /*      */     } 
> /*      */     
> /* 1750 */     qr.uplo = null;
> /* 1751 */     return new QR(qr, tau);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public SVD svd() {
> /* 1770 */     return svd(true, false);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public SVD svd(boolean vectors, boolean overwrite) {
> /* 1792 */     int k = Math.min(this.m, this.n);
> /* 1793 */     double[] s = new double[k];
> /*      */     
> /* 1795 */     MatrixModified W = overwrite ? this : clone();
> /* 1796 */     if (vectors) {
> /* 1797 */       MatrixModified matrixModified1 = new MatrixModified(this.m, k);
> /* 1798 */       MatrixModified matrixModified2 = new MatrixModified(k, this.n);
> /*      */       
> /* 1800 */       int i = LAPACKModified.engine.gesdd(W.layout(), SVDJobModified.COMPACT, W.m, W.n, W.A, W.ld, s, matrixModified1.A, matrixModified1.ld, matrixModified2.A, matrixModified2.ld);
> /* 1801 */       if (i != 0) {
> /* 1802 */         logger.error("LAPACK GESDD error code: {}", Integer.valueOf(i));
> /* 1803 */         throw new ArithmeticException("LAPACK GESDD error code: " + i);
> /*      */       } 
> /*      */       
> /* 1806 */       return new SVD(s, matrixModified1, matrixModified2.transpose());
> /*      */     } 
> /* 1808 */     MatrixModified U = new MatrixModified(1, 1);
> /* 1809 */     MatrixModified VT = new MatrixModified(1, 1);
> /*      */     
> /* 1811 */     int info = LAPACKModified.engine.gesdd(W.layout(), SVDJobModified.NO_VECTORS, W.m, W.n, W.A, W.ld, s, U.A, U.ld, VT.A, VT.ld);
> /* 1812 */     if (info != 0) {
> /* 1813 */       logger.error("LAPACK GESDD error code: {}", Integer.valueOf(info));
> /* 1814 */       throw new ArithmeticException("LAPACK GESDD error code: " + info);
> /*      */     } 
> /*      */     
> /* 1817 */     return new SVD(this.m, this.n, s);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public EVD eigen() {
> /* 1832 */     return eigen(false, true, false);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public EVD eigen(boolean vl, boolean vr, boolean overwrite) {
> /* 1850 */     if (this.m != this.n) {
> /* 1851 */       throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", new Object[] { Integer.valueOf(this.m), Integer.valueOf(this.n) }));
> /*      */     }
> /*      */     
> /* 1854 */     MatrixModified eig = overwrite ? this : clone();
> /* 1855 */     if (isSymmetric()) {
> /* 1856 */       double[] w = new double[this.n];
> /* 1857 */       int i = LAPACKModified.engine.syevd(eig.layout(), vr ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, eig.uplo, this.n, eig.A, eig.ld, w);
> /* 1858 */       if (i != 0) {
> /* 1859 */         logger.error("LAPACK SYEV error code: {}", Integer.valueOf(i));
> /* 1860 */         throw new ArithmeticException("LAPACK SYEV error code: " + i);
> /*      */       } 
> /*      */       
> /* 1863 */       eig.uplo = null;
> /* 1864 */       return new EVD(w, vr ? eig : null);
> /*      */     } 
> /* 1866 */     double[] wr = new double[this.n];
> /* 1867 */     double[] wi = new double[this.n];
> /* 1868 */     MatrixModified Vl = vl ? new MatrixModified(this.n, this.n) : new MatrixModified(1, 1);
> /* 1869 */     MatrixModified Vr = vr ? new MatrixModified(this.n, this.n) : new MatrixModified(1, 1);
> /* 1870 */     int info = LAPACKModified.engine.geev(eig.layout(), vl ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, vr ? EVDJobModified.VECTORS : EVDJobModified.NO_VECTORS, this.n, eig.A, eig.ld, wr, wi, Vl.A, Vl.ld, Vr.A, Vr.ld);
> /* 1871 */     if (info != 0) {
> /* 1872 */       logger.error("LAPACK GEEV error code: {}", Integer.valueOf(info));
> /* 1873 */       throw new ArithmeticException("LAPACK GEEV error code: " + info);
> /*      */     } 
> /*      */     
> /* 1876 */     return new EVD(wr, wi, vl ? Vl : null, vr ? Vr : null);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static class SVD
> /*      */     implements Serializable
> /*      */   {
> /*      */     private static final long serialVersionUID = 2L;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final int m;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final int n;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final double[] s;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final MatrixModified U;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final MatrixModified V;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     private transient MatrixModified Ur;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public SVD(int m, int n, double[] s) {
> /* 1945 */       this.m = m;
> /* 1946 */       this.n = n;
> /* 1947 */       this.s = s;
> /* 1948 */       this.U = null;
> /* 1949 */       this.V = null;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public SVD(double[] s, MatrixModified U, MatrixModified V) {
> /* 1959 */       this.m = U.m;
> /* 1960 */       this.n = V.m;
> /* 1961 */       this.s = s;
> /* 1962 */       this.U = U;
> /* 1963 */       this.V = V;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public MatrixModified diag() {
> /* 1971 */       MatrixModified S = new MatrixModified(this.U.m, this.V.m);
> /*      */       
> /* 1973 */       for (int i = 0; i < this.s.length; i++) {
> /* 1974 */         S.set(i, i, this.s[i]);
> /*      */       }
> /*      */       
> /* 1977 */       return S;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public double norm() {
> /* 1985 */       return this.s[0];
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     private double rcond() {
> /* 1994 */       return 0.5D * Math.sqrt((this.m + this.n + 1)) * this.s[0] * MathExModified.EPSILON;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public int rank() {
> /* 2003 */       if (this.s.length != Math.min(this.m, this.n)) {
> /* 2004 */         throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
> /*      */       }
> /*      */       
> /* 2007 */       int r = 0;
> /* 2008 */       double tol = rcond(); byte b; int i;
> /*      */       double[] arrayOfDouble;
> /* 2010 */       for (i = (arrayOfDouble = this.s).length, b = 0; b < i; ) { double si = arrayOfDouble[b];
> /* 2011 */         if (si > tol)
> /* 2012 */           r++; 
> /*      */         b++; }
> /*      */       
> /* 2015 */       return r;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public int nullity() {
> /* 2024 */       return Math.min(this.m, this.n) - rank();
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public double condition() {
> /* 2045 */       if (this.s.length != Math.min(this.m, this.n)) {
> /* 2046 */         throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
> /*      */       }
> /*      */       
> /* 2049 */       return (this.s[0] <= 0.0D || this.s[this.s.length - 1] <= 0.0D) ? Double.POSITIVE_INFINITY : (this.s[0] / this.s[this.s.length - 1]);
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public MatrixModified range() {
> /* 2058 */       if (this.s.length != Math.min(this.m, this.n)) {
> /* 2059 */         throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
> /*      */       }
> /*      */       
> /* 2062 */       if (this.U == null) {
> /* 2063 */         throw new IllegalStateException("The left singular vectors are not available.");
> /*      */       }
> /*      */       
> /* 2066 */       int r = rank();
> /*      */       
> /* 2068 */       if (r == 0) {
> /* 2069 */         return null;
> /*      */       }
> /*      */       
> /* 2072 */       MatrixModified R = new MatrixModified(this.m, r);
> /* 2073 */       for (int j = 0; j < r; j++) {
> /* 2074 */         for (int i = 0; i < this.m; i++) {
> /* 2075 */           R.set(i, j, this.U.get(i, j));
> /*      */         }
> /*      */       } 
> /*      */       
> /* 2079 */       return R;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public MatrixModified nullspace() {
> /* 2088 */       if (this.s.length != Math.min(this.m, this.n)) {
> /* 2089 */         throw new UnsupportedOperationException("The operation cannot be called on a partial SVD.");
> /*      */       }
> /*      */       
> /* 2092 */       if (this.V == null) {
> /* 2093 */         throw new IllegalStateException("The right singular vectors are not available.");
> /*      */       }
> /*      */       
> /* 2096 */       int nr = nullity();
> /*      */       
> /* 2098 */       if (nr == 0) {
> /* 2099 */         return null;
> /*      */       }
> /*      */       
> /* 2102 */       MatrixModified N = new MatrixModified(this.n, nr);
> /* 2103 */       for (int j = 0; j < nr; j++) {
> /* 2104 */         for (int i = 0; i < this.n; i++) {
> /* 2105 */           N.set(i, j, this.V.get(i, this.n - j - 1));
> /*      */         }
> /*      */       } 
> /* 2108 */       return N;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public MatrixModified pinv() {
> /* 2116 */       int k = this.s.length;
> /* 2117 */       double[] sigma = new double[k];
> /* 2118 */       int r = rank();
> /* 2119 */       for (int i = 0; i < r; i++) {
> /* 2120 */         sigma[i] = 1.0D / this.s[i];
> /*      */       }
> /*      */       
> /* 2123 */       return MatrixModified.adb(TransposeModified.NO_TRANSPOSE, this.V, sigma, TransposeModified.TRANSPOSE, this.U);
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public double[] solve(double[] b) {
> /* 2133 */       if (this.U == null || this.V == null) {
> /* 2134 */         throw new IllegalStateException("The singular vectors are not available.");
> /*      */       }
> /*      */       
> /* 2137 */       if (b.length != this.m) {
> /* 2138 */         throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x 1", new Object[] { Integer.valueOf(this.m), Integer.valueOf(this.n), Integer.valueOf(b.length) }));
> /*      */       }
> /*      */       
> /* 2141 */       int r = rank();
> /* 2142 */       if (this.Ur == null) {
> /* 2143 */         this.Ur = (r == this.U.ncol()) ? this.U : this.U.submatrix(0, 0, this.m - 1, r - 1);
> /*      */       }
> /*      */       
> /* 2146 */       double[] Utb = new double[this.s.length];
> /* 2147 */       this.Ur.tv(b, Utb);
> /* 2148 */       for (int i = 0; i < r; i++) {
> /* 2149 */         Utb[i] = Utb[i] / this.s[i];
> /*      */       }
> /* 2151 */       return this.V.mv(Utb);
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static class EVD
> /*      */     implements Serializable
> /*      */   {
> /*      */     private static final long serialVersionUID = 2L;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final double[] wr;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final double[] wi;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final MatrixModified Vl;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final MatrixModified Vr;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public EVD(double[] w, MatrixModified V) {
> /* 2246 */       this.wr = w;
> /* 2247 */       this.wi = null;
> /* 2248 */       this.Vl = V;
> /* 2249 */       this.Vr = V;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public EVD(double[] wr, double[] wi, MatrixModified Vl, MatrixModified Vr) {
> /* 2261 */       this.wr = wr;
> /* 2262 */       this.wi = wi;
> /* 2263 */       this.Vl = Vl;
> /* 2264 */       this.Vr = Vr;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public MatrixModified diag() {
> /* 2274 */       MatrixModified D = MatrixModified.diag(this.wr);
> /*      */       
> /* 2276 */       if (this.wi != null) {
> /* 2277 */         int n = this.wr.length;
> /* 2278 */         for (int i = 0; i < n; i++) {
> /* 2279 */           if (this.wi[i] > 0.0D) {
> /* 2280 */             D.set(i, i + 1, this.wi[i]);
> /* 2281 */           } else if (this.wi[i] < 0.0D) {
> /* 2282 */             D.set(i, i - 1, this.wi[i]);
> /*      */           } 
> /*      */         } 
> /*      */       } 
> /*      */       
> /* 2287 */       return D;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public EVD sort() {
> /* 2296 */       int n = this.wr.length;
> /* 2297 */       double[] w = new double[n];
> /* 2298 */       if (this.wi != null) {
> /* 2299 */         for (int i = 0; i < n; i++) {
> /* 2300 */           w[i] = -(this.wr[i] * this.wr[i] + this.wi[i] * this.wi[i]);
> /*      */         }
> /*      */       } else {
> /* 2303 */         for (int i = 0; i < n; i++) {
> /* 2304 */           w[i] = -(this.wr[i] * this.wr[i]);
> /*      */         }
> /*      */       } 
> /*      */       
> /* 2308 */       int[] index = QuickSortModified.sort(w);
> /* 2309 */       double[] wr2 = new double[n];
> /* 2310 */       for (int j = 0; j < n; j++) {
> /* 2311 */         wr2[j] = this.wr[index[j]];
> /*      */       }
> /*      */       
> /* 2314 */       double[] wi2 = null;
> /* 2315 */       if (this.wi != null) {
> /* 2316 */         wi2 = new double[n];
> /* 2317 */         for (int i = 0; i < n; i++) {
> /* 2318 */           wi2[i] = this.wi[index[i]];
> /*      */         }
> /*      */       } 
> /*      */       
> /* 2322 */       MatrixModified Vl2 = null;
> /* 2323 */       if (this.Vl != null) {
> /* 2324 */         int m = this.Vl.m;
> /* 2325 */         Vl2 = new MatrixModified(m, n);
> /* 2326 */         for (int i = 0; i < n; i++) {
> /* 2327 */           for (int k = 0; k < m; k++) {
> /* 2328 */             Vl2.set(k, i, this.Vl.get(k, index[i]));
> /*      */           }
> /*      */         } 
> /*      */       } 
> /*      */       
> /* 2333 */       MatrixModified Vr2 = null;
> /* 2334 */       if (this.Vr != null) {
> /* 2335 */         int m = this.Vr.m;
> /* 2336 */         Vr2 = new MatrixModified(m, n);
> /* 2337 */         for (int i = 0; i < n; i++) {
> /* 2338 */           for (int k = 0; k < m; k++) {
> /* 2339 */             Vr2.set(k, i, this.Vr.get(k, index[i]));
> /*      */           }
> /*      */         } 
> /*      */       } 
> /*      */       
> /* 2344 */       return new EVD(wr2, wi2, Vl2, Vr2);
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static class LU
> /*      */     implements Serializable
> /*      */   {
> /*      */     private static final long serialVersionUID = 2L;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final MatrixModified lu;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final int[] ipiv;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final int info;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public LU(MatrixModified lu, int[] ipiv, int info) {
> /* 2389 */       this.lu = lu;
> /* 2390 */       this.ipiv = ipiv;
> /* 2391 */       this.info = info;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public boolean isSingular() {
> /* 2399 */       return (this.info > 0);
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public double det() {
> /* 2407 */       int m = this.lu.m;
> /* 2408 */       int n = this.lu.n;
> /*      */       
> /* 2410 */       if (m != n) {
> /* 2411 */         throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", new Object[] { Integer.valueOf(m), Integer.valueOf(n) }));
> /*      */       }
> /*      */       
> /* 2414 */       double d = 1.0D; int j;
> /* 2415 */       for (j = 0; j < n; j++) {
> /* 2416 */         d *= this.lu.get(j, j);
> /*      */       }
> /*      */       
> /* 2419 */       for (j = 0; j < n; j++) {
> /* 2420 */         if (j + 1 != this.ipiv[j]) {
> /* 2421 */           d = -d;
> /*      */         }
> /*      */       } 
> /*      */       
> /* 2425 */       return d;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public MatrixModified inverse() {
> /* 2433 */       MatrixModified inv = MatrixModified.eye(this.lu.n);
> /* 2434 */       solve(inv);
> /* 2435 */       return inv;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public double[] solve(double[] b) {
> /* 2445 */       MatrixModified x = MatrixModified.column(b);
> /* 2446 */       solve(x);
> /* 2447 */       return x.A;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public void solve(MatrixModified B) {
> /* 2457 */       if (this.lu.m != this.lu.n) {
> /* 2458 */         throw new IllegalArgumentException(String.format("The matrix is not square: %d x %d", new Object[] { Integer.valueOf(this.lu.m), Integer.valueOf(this.lu.n) }));
> /*      */       }
> /*      */       
> /* 2461 */       if (B.m != this.lu.m) {
> /* 2462 */         throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", new Object[] { Integer.valueOf(this.lu.m), Integer.valueOf(this.lu.n), Integer.valueOf(B.m), Integer.valueOf(B.n) }));
> /*      */       }
> /*      */       
> /* 2465 */       if (this.lu.layout() != B.layout()) {
> /* 2466 */         throw new IllegalArgumentException("The matrix layout is inconsistent.");
> /*      */       }
> /*      */       
> /* 2469 */       if (this.info > 0) {
> /* 2470 */         throw new RuntimeException("The matrix is singular.");
> /*      */       }
> /*      */       
> /* 2473 */       int ret = LAPACKModified.engine.getrs(this.lu.layout(), TransposeModified.NO_TRANSPOSE, this.lu.n, B.n, this.lu.A, this.lu.ld, this.ipiv, B.A, B.ld);
> /* 2474 */       if (ret != 0) {
> /* 2475 */         MatrixModified.logger.error("LAPACK GETRS error code: {}", Integer.valueOf(ret));
> /* 2476 */         throw new ArithmeticException("LAPACK GETRS error code: " + ret);
> /*      */       } 
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static class Cholesky
> /*      */     implements Serializable
> /*      */   {
> /*      */     private static final long serialVersionUID = 2L;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final MatrixModified lu;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public Cholesky(MatrixModified lu) {
> /* 2517 */       if (lu.nrow() != lu.ncol()) {
> /* 2518 */         throw new UnsupportedOperationException("Cholesky constructor on a non-square matrix");
> /*      */       }
> /* 2520 */       this.lu = lu;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public double det() {
> /* 2528 */       int n = this.lu.n;
> /* 2529 */       double d = 1.0D;
> /* 2530 */       for (int i = 0; i < n; i++) {
> /* 2531 */         d *= this.lu.get(i, i);
> /*      */       }
> /*      */       
> /* 2534 */       return d * d;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public double logdet() {
> /* 2542 */       int n = this.lu.n;
> /* 2543 */       double d = 0.0D;
> /* 2544 */       for (int i = 0; i < n; i++) {
> /* 2545 */         d += Math.log(this.lu.get(i, i));
> /*      */       }
> /*      */       
> /* 2548 */       return 2.0D * d;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public MatrixModified inverse() {
> /* 2556 */       MatrixModified inv = MatrixModified.eye(this.lu.n);
> /* 2557 */       solve(inv);
> /* 2558 */       return inv;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public double[] solve(double[] b) {
> /* 2567 */       MatrixModified x = MatrixModified.column(b);
> /* 2568 */       solve(x);
> /* 2569 */       return x.A;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public void solve(MatrixModified B) {
> /* 2578 */       if (B.m != this.lu.m) {
> /* 2579 */         throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", new Object[] { Integer.valueOf(this.lu.m), Integer.valueOf(this.lu.n), Integer.valueOf(B.m), Integer.valueOf(B.n) }));
> /*      */       }
> /*      */       
> /* 2582 */       int info = LAPACKModified.engine.potrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.A, this.lu.ld, B.A, B.ld);
> /* 2583 */       if (info != 0) {
> /* 2584 */         MatrixModified.logger.error("LAPACK POTRS error code: {}", Integer.valueOf(info));
> /* 2585 */         throw new ArithmeticException("LAPACK POTRS error code: " + info);
> /*      */       } 
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static class QR
> /*      */     implements Serializable
> /*      */   {
> /*      */     private static final long serialVersionUID = 2L;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final MatrixModified qr;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final double[] tau;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public QR(MatrixModified qr, double[] tau) {
> /* 2618 */       this.qr = qr;
> /* 2619 */       this.tau = tau;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public MatrixModified.Cholesky CholeskyOfAtA() {
> /* 2627 */       int n = this.qr.n;
> /* 2628 */       MatrixModified L = new MatrixModified(n, n);
> /* 2629 */       for (int i = 0; i < n; i++) {
> /* 2630 */         for (int j = 0; j <= i; j++) {
> /* 2631 */           L.set(i, j, this.qr.get(j, i));
> /*      */         }
> /*      */       } 
> /*      */       
> /* 2635 */       L.uplo(UPLOModified.LOWER);
> /* 2636 */       return new MatrixModified.Cholesky(L);
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public MatrixModified R() {
> /* 2644 */       int n = this.qr.n;
> /* 2645 */       MatrixModified R = MatrixModified.diag(this.tau);
> /* 2646 */       for (int i = 0; i < n; i++) {
> /* 2647 */         for (int j = i; j < n; j++) {
> /* 2648 */           R.set(i, j, this.qr.get(i, j));
> /*      */         }
> /*      */       } 
> /*      */       
> /* 2652 */       return R;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public MatrixModified Q() {
> /* 2660 */       int m = this.qr.m;
> /* 2661 */       int n = this.qr.n;
> /* 2662 */       int k = Math.min(m, n);
> /* 2663 */       MatrixModified Q = this.qr.clone();
> /* 2664 */       int info = LAPACKModified.engine.orgqr(this.qr.layout(), m, n, k, Q.A, this.qr.ld, this.tau);
> /* 2665 */       if (info != 0) {
> /* 2666 */         MatrixModified.logger.error("LAPACK ORGRQ error code: {}", Integer.valueOf(info));
> /* 2667 */         throw new ArithmeticException("LAPACK ORGRQ error code: " + info);
> /*      */       } 
> /* 2669 */       return Q;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public double[] solve(double[] b) {
> /* 2679 */       if (b.length != this.qr.m) {
> /* 2680 */         throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x 1", new Object[] { Integer.valueOf(this.qr.m), Integer.valueOf(this.qr.n), Integer.valueOf(b.length) }));
> /*      */       }
> /*      */       
> /* 2683 */       MatrixModified x = MatrixModified.column(b);
> /* 2684 */       solve(x);
> /* 2685 */       return Arrays.copyOf(x.A, this.qr.n);
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public void solve(MatrixModified B) {
> /* 2695 */       if (B.m != this.qr.m) {
> /* 2696 */         throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", new Object[] { Integer.valueOf(this.qr.nrow()), Integer.valueOf(this.qr.nrow()), Integer.valueOf(B.nrow()), Integer.valueOf(B.ncol()) }));
> /*      */       }
> /*      */       
> /* 2699 */       int m = this.qr.m;
> /* 2700 */       int n = this.qr.n;
> /* 2701 */       int k = Math.min(m, n);
> /*      */       
> /* 2703 */       int info = LAPACKModified.engine.ormqr(this.qr.layout(), SideModified.LEFT, TransposeModified.TRANSPOSE, B.nrow(), B.ncol(), k, this.qr.A, this.qr.ld, this.tau, B.A, B.ld);
> /* 2704 */       if (info != 0) {
> /* 2705 */         MatrixModified.logger.error("LAPACK ORMQR error code: {}", Integer.valueOf(info));
> /* 2706 */         throw new IllegalArgumentException("LAPACK ORMQR error code: " + info);
> /*      */       } 
> /*      */       
> /* 2709 */       info = LAPACKModified.engine.trtrs(this.qr.layout(), UPLOModified.UPPER, TransposeModified.NO_TRANSPOSE, DiagModified.NON_UNIT, this.qr.n, B.n, this.qr.A, this.qr.ld, B.A, B.ld);
> /*      */       
> /* 2711 */       if (info != 0) {
> /* 2712 */         MatrixModified.logger.error("LAPACK TRTRS error code: {}", Integer.valueOf(info));
> /* 2713 */         throw new IllegalArgumentException("LAPACK TRTRS error code: " + info);
> /*      */       } 
> /*      */     }
> /*      */   }
> /*      */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/MatrixModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/MersenneTwisterModified.java jd-gui/smileModified/MersenneTwisterModified.java
1,146c1,224
< package smileModified;
< 
< public class MersenneTwisterModified implements RandomNumberGeneratorModified {
<    private static final int UPPER_MASK = Integer.MIN_VALUE;
<    private static final int LOWER_MASK = Integer.MAX_VALUE;
<    private static final int N = 624;
<    private static final int M = 397;
<    private static final int[] MAGIC = new int[]{0, -1727483681};
<    private static final int MAGIC_FACTOR1 = 1812433253;
<    private static final int MAGIC_FACTOR2 = 1664525;
<    private static final int MAGIC_FACTOR3 = 1566083941;
<    private static final int MAGIC_MASK1 = -1658038656;
<    private static final int MAGIC_MASK2 = -272236544;
<    private static final int MAGIC_SEED = 19650218;
<    private final int[] mt;
<    private int mti;
< 
<    public MersenneTwisterModified() {
<       this(19650218);
<    }
< 
<    public MersenneTwisterModified(int seed) {
<       this.mt = new int[624];
<       this.setSeed(seed);
<    }
< 
<    public MersenneTwisterModified(long seed) {
<       this.mt = new int[624];
<       this.setSeed(seed);
<    }
< 
<    public void setSeed(long seed) {
<       this.setSeed((int)(seed % 2147483647L));
<    }
< 
<    public void setSeed(int seed) {
<       this.mt[0] = seed;
< 
<       for(this.mti = 1; this.mti < 624; ++this.mti) {
<          this.mt[this.mti] = 1812433253 * (this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30) + this.mti;
<       }
< 
<    }
< 
<    public void setSeed(int[] seed) {
<       this.setSeed(19650218);
<       if (seed != null && seed.length != 0) {
<          int i = 1;
<          int j = 0;
< 
<          int k;
<          for(k = Math.max(624, seed.length); k > 0; --k) {
<             this.mt[i] = (this.mt[i] ^ (this.mt[i - 1] ^ this.mt[i - 1] >>> 30) * 1664525) + seed[j] + j;
<             ++i;
<             ++j;
<             if (i >= 624) {
<                this.mt[0] = this.mt[623];
<                i = 1;
<             }
< 
<             if (j >= seed.length) {
<                j = 0;
<             }
<          }
< 
<          for(k = 623; k > 0; --k) {
<             this.mt[i] = (this.mt[i] ^ (this.mt[i - 1] ^ this.mt[i - 1] >>> 30) * 1566083941) - i;
<             ++i;
<             if (i >= 624) {
<                this.mt[0] = this.mt[623];
<                i = 1;
<             }
<          }
< 
<          int[] var10000 = this.mt;
<          var10000[0] |= Integer.MIN_VALUE;
<       }
<    }
< 
<    public int next(int numbits) {
<       return this.nextInt() >>> 32 - numbits;
<    }
< 
<    public double nextDouble() {
<       return (double)(this.nextInt() >>> 1) / 2.147483647E9D;
<    }
< 
<    public void nextDoubles(double[] d) {
<       int n = d.length;
< 
<       for(int i = 0; i < n; ++i) {
<          d[i] = this.nextDouble();
<       }
< 
<    }
< 
<    public int nextInt() {
<       int x;
<       if (this.mti >= 624) {
<          int i;
<          for(i = 0; i < 227; ++i) {
<             x = this.mt[i] & Integer.MIN_VALUE | this.mt[i + 1] & Integer.MAX_VALUE;
<             this.mt[i] = this.mt[i + 397] ^ x >>> 1 ^ MAGIC[x & 1];
<          }
< 
<          while(i < 623) {
<             x = this.mt[i] & Integer.MIN_VALUE | this.mt[i + 1] & Integer.MAX_VALUE;
<             this.mt[i] = this.mt[i + -227] ^ x >>> 1 ^ MAGIC[x & 1];
<             ++i;
<          }
< 
<          x = this.mt[623] & Integer.MIN_VALUE | this.mt[0] & Integer.MAX_VALUE;
<          this.mt[623] = this.mt[396] ^ x >>> 1 ^ MAGIC[x & 1];
<          this.mti = 0;
<       }
< 
<       x = this.mt[this.mti++];
<       x ^= x >>> 11;
<       x ^= x << 7 & -1658038656;
<       x ^= x << 15 & -272236544;
<       x ^= x >>> 18;
<       return x;
<    }
< 
<    public int nextInt(int n) {
<       if (n <= 0) {
<          throw new IllegalArgumentException("n must be positive");
<       } else if ((n & -n) == n) {
<          return (int)((long)n * (long)this.next(31) >> 31);
<       } else {
<          int bits;
<          int val;
<          do {
<             bits = this.next(31);
<             val = bits % n;
<          } while(bits - val + (n - 1) < 0);
< 
<          return val;
<       }
<    }
< 
<    public long nextLong() {
<       long x = (long)this.nextInt();
<       return x << 32 | (long)this.nextInt();
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class MersenneTwisterModified
> /*     */   implements RandomNumberGeneratorModified
> /*     */ {
> /*     */   private static final int UPPER_MASK = -2147483648;
> /*     */   private static final int LOWER_MASK = 2147483647;
> /*     */   private static final int N = 624;
> /*     */   private static final int M = 397;
> /*  53 */   private static final int[] MAGIC = new int[] { 0, -1727483681 };
> /*     */   
> /*     */   private static final int MAGIC_FACTOR1 = 1812433253;
> /*     */   
> /*     */   private static final int MAGIC_FACTOR2 = 1664525;
> /*     */   
> /*     */   private static final int MAGIC_FACTOR3 = 1566083941;
> /*     */   private static final int MAGIC_MASK1 = -1658038656;
> /*     */   private static final int MAGIC_MASK2 = -272236544;
> /*     */   private static final int MAGIC_SEED = 19650218;
> /*  63 */   private final int[] mt = new int[624];
> /*     */ 
> /*     */   
> /*     */   private int mti;
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public MersenneTwisterModified() {
> /*  71 */     this(19650218);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public MersenneTwisterModified(int seed) {
> /*  79 */     setSeed(seed);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public MersenneTwisterModified(long seed) {
> /*  87 */     setSeed(seed);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void setSeed(long seed) {
> /*  94 */     setSeed((int)(seed % 2147483647L));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void setSeed(int seed) {
> /* 102 */     this.mt[0] = seed;
> /* 103 */     for (this.mti = 1; this.mti < 624; this.mti++) {
> /* 104 */       this.mt[this.mti] = 1812433253 * (this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30) + this.mti;
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void setSeed(int[] seed) {
> /* 113 */     setSeed(19650218);
> /*     */     
> /* 115 */     if (seed == null || seed.length == 0) {
> /*     */       return;
> /*     */     }
> /*     */     
> /* 119 */     int i = 1, j = 0; int k;
> /* 120 */     for (k = Math.max(624, seed.length); k > 0; k--) {
> /* 121 */       this.mt[i] = (this.mt[i] ^ (this.mt[i - 1] ^ this.mt[i - 1] >>> 30) * 1664525) + seed[j] + j;
> /* 122 */       i++;
> /* 123 */       j++;
> /* 124 */       if (i >= 624) {
> /* 125 */         this.mt[0] = this.mt[623];
> /* 126 */         i = 1;
> /*     */       } 
> /* 128 */       if (j >= seed.length) {
> /* 129 */         j = 0;
> /*     */       }
> /*     */     } 
> /*     */     
> /* 133 */     for (k = 623; k > 0; k--) {
> /* 134 */       this.mt[i] = (this.mt[i] ^ (this.mt[i - 1] ^ this.mt[i - 1] >>> 30) * 1566083941) - i;
> /* 135 */       i++;
> /* 136 */       if (i >= 624) {
> /* 137 */         this.mt[0] = this.mt[623];
> /* 138 */         i = 1;
> /*     */       } 
> /*     */     } 
> /* 141 */     this.mt[0] = this.mt[0] | Integer.MIN_VALUE;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public int next(int numbits) {
> /* 146 */     return nextInt() >>> 32 - numbits;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double nextDouble() {
> /* 151 */     return (nextInt() >>> 1) / 2.147483647E9D;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void nextDoubles(double[] d) {
> /* 156 */     int n = d.length;
> /* 157 */     for (int i = 0; i < n; i++) {
> /* 158 */       d[i] = nextDouble();
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int nextInt() {
> /* 166 */     if (this.mti >= 624) {
> /*     */       int i;
> /* 168 */       for (i = 0; i < 227; i++) {
> /* 169 */         int k = this.mt[i] & Integer.MIN_VALUE | this.mt[i + 1] & Integer.MAX_VALUE;
> /* 170 */         this.mt[i] = this.mt[i + 397] ^ k >>> 1 ^ MAGIC[k & 0x1];
> /*     */       } 
> /* 172 */       for (; i < 623; i++) {
> /* 173 */         int k = this.mt[i] & Integer.MIN_VALUE | this.mt[i + 1] & Integer.MAX_VALUE;
> /* 174 */         this.mt[i] = this.mt[i + -227] ^ k >>> 1 ^ MAGIC[k & 0x1];
> /*     */       } 
> /* 176 */       int j = this.mt[623] & Integer.MIN_VALUE | this.mt[0] & Integer.MAX_VALUE;
> /* 177 */       this.mt[623] = this.mt[396] ^ j >>> 1 ^ MAGIC[j & 0x1];
> /*     */       
> /* 179 */       this.mti = 0;
> /*     */     } 
> /*     */     
> /* 182 */     int x = this.mt[this.mti++];
> /*     */ 
> /*     */     
> /* 185 */     x ^= x >>> 11;
> /* 186 */     x ^= x << 7 & 0x9D2C5680;
> /* 187 */     x ^= x << 15 & 0xEFC60000;
> /* 188 */     x ^= x >>> 18;
> /*     */     
> /* 190 */     return x;
> /*     */   }
> /*     */   public int nextInt(int n) {
> /*     */     int bits;
> /*     */     int val;
> /* 195 */     if (n <= 0) {
> /* 196 */       throw new IllegalArgumentException("n must be positive");
> /*     */     }
> /*     */ 
> /*     */     
> /* 200 */     if ((n & -n) == n) {
> /* 201 */       return (int)(n * next(31) >> 31L);
> /*     */     }
> /*     */ 
> /*     */     
> /*     */     do {
> /* 206 */       bits = next(31);
> /* 207 */       val = bits % n;
> /* 208 */     } while (bits - val + n - 1 < 0);
> /*     */     
> /* 210 */     return val;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public long nextLong() {
> /* 215 */     long x = nextInt();
> /* 216 */     return x << 32L | nextInt();
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/MersenneTwisterModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/MixtureModified.java jd-gui/smileModified/MixtureModified.java
1,219c1,257
< package smileModified;
< 
< import java.io.Serializable;
< import java.util.Arrays;
< import java.util.stream.Collectors;
< 
< public class MixtureModified extends AbstractDistributionModified {
<    private static final long serialVersionUID = 2L;
<    public final MixtureModified.Component[] components;
< 
<    public MixtureModified(MixtureModified.Component... components) {
<       if (components.length == 0) {
<          throw new IllegalStateException("Empty mixture!");
<       } else {
<          double sum = 0.0D;
<          MixtureModified.Component[] var7 = components;
<          int var6 = components.length;
< 
<          for(int var5 = 0; var5 < var6; ++var5) {
<             MixtureModified.Component component = var7[var5];
<             sum += component.priori;
<          }
< 
<          if (Math.abs(sum - 1.0D) > 0.001D) {
<             throw new IllegalArgumentException("The sum of priori is not equal to 1.");
<          } else {
<             this.components = components;
<          }
<       }
<    }
< 
<    public double[] posteriori(double x) {
<       int k = this.components.length;
<       double[] prob = new double[k];
< 
<       for(int i = 0; i < k; ++i) {
<          MixtureModified.Component c = this.components[i];
<          prob[i] = c.priori * c.distribution.p(x);
<       }
< 
<       double p = MathExModified.sum(prob);
< 
<       for(int i = 0; i < k; ++i) {
<          prob[i] /= p;
<       }
< 
<       return prob;
<    }
< 
<    public int map(double x) {
<       int k = this.components.length;
<       double[] prob = new double[k];
< 
<       for(int i = 0; i < k; ++i) {
<          MixtureModified.Component c = this.components[i];
<          prob[i] = c.priori * c.distribution.p(x);
<       }
< 
<       return MathExModified.whichMax(prob);
<    }
< 
<    public double mean() {
<       double mu = 0.0D;
<       MixtureModified.Component[] var6;
<       int var5 = (var6 = this.components).length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          MixtureModified.Component c = var6[var4];
<          mu += c.priori * c.distribution.mean();
<       }
< 
<       return mu;
<    }
< 
<    public double variance() {
<       double variance = 0.0D;
<       MixtureModified.Component[] var6;
<       int var5 = (var6 = this.components).length;
< 
<       for(int var4 = 0; var4 < var5; ++var4) {
<          MixtureModified.Component c = var6[var4];
<          variance += c.priori * c.priori * c.distribution.variance();
<       }
< 
<       return variance;
<    }
< 
<    public double entropy() {
<       throw new UnsupportedOperationException("Mixture does not support entropy()");
<    }
< 
<    public double p(double x) {
<       double p = 0.0D;
<       MixtureModified.Component[] var8;
<       int var7 = (var8 = this.components).length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          MixtureModified.Component c = var8[var6];
<          p += c.priori * c.distribution.p(x);
<       }
< 
<       return p;
<    }
< 
<    public double logp(double x) {
<       return Math.log(this.p(x));
<    }
< 
<    public double cdf(double x) {
<       double p = 0.0D;
<       MixtureModified.Component[] var8;
<       int var7 = (var8 = this.components).length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          MixtureModified.Component c = var8[var6];
<          p += c.priori * c.distribution.cdf(x);
<       }
< 
<       return p;
<    }
< 
<    public double rand() {
<       double r = MathExModified.random();
<       double p = 0.0D;
<       MixtureModified.Component[] var8;
<       int var7 = (var8 = this.components).length;
< 
<       for(int var6 = 0; var6 < var7; ++var6) {
<          MixtureModified.Component g = var8[var6];
<          p += g.priori;
<          if (r <= p) {
<             return g.distribution.rand();
<          }
<       }
< 
<       throw new IllegalStateException();
<    }
< 
<    public double quantile(double p) {
<       if (!(p < 0.0D) && !(p > 1.0D)) {
<          double inc = 1.0D;
<          double x = (double)((int)this.mean());
<          double xl;
<          double xu;
<          if (p < this.cdf(x)) {
<             do {
<                x -= inc;
<                inc *= 2.0D;
<             } while(p < this.cdf(x));
< 
<             xl = x;
<             xu = x + inc / 2.0D;
<          } else {
<             do {
<                x += inc;
<                inc *= 2.0D;
<             } while(p > this.cdf(x));
< 
<             xu = x;
<             xl = x - inc / 2.0D;
<          }
< 
<          return this.quantile(p, xl, xu);
<       } else {
<          throw new IllegalArgumentException("Invalid p: " + p);
<       }
<    }
< 
<    public int length() {
<       int length = this.components.length - 1;
<       MixtureModified.Component[] var5;
<       int var4 = (var5 = this.components).length;
< 
<       for(int var3 = 0; var3 < var4; ++var3) {
<          MixtureModified.Component component = var5[var3];
<          length += component.distribution.length();
<       }
< 
<       return length;
<    }
< 
<    public int size() {
<       return this.components.length;
<    }
< 
<    public double bic(double[] data) {
<       int n = data.length;
<       double logLikelihood = 0.0D;
<       double[] var9 = data;
<       int var8 = data.length;
< 
<       for(int var7 = 0; var7 < var8; ++var7) {
<          double x = var9[var7];
<          double p = this.p(x);
<          if (p > 0.0D) {
<             logLikelihood += Math.log(p);
<          }
<       }
< 
<       return logLikelihood - 0.5D * (double)this.length() * Math.log((double)n);
<    }
< 
<    public String toString() {
<       return (String)Arrays.stream(this.components).map((component) -> {
<          return String.format("%.2f x %s", component.priori, component.distribution);
<       }).collect(Collectors.joining(" + ", String.format("Mixture(%d)[", this.components.length), "]"));
<    }
< 
<    public static class Component implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final double priori;
<       public final DistributionModified distribution;
< 
<       public Component(double priori, DistributionModified distribution) {
<          this.priori = priori;
<          this.distribution = distribution;
<       }
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ import java.util.Arrays;
> /*     */ import java.util.stream.Collectors;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class MixtureModified
> /*     */   extends AbstractDistributionModified
> /*     */ {
> /*     */   private static final long serialVersionUID = 2L;
> /*     */   public final Component[] components;
> /*     */   
> /*     */   public static class Component
> /*     */     implements Serializable
> /*     */   {
> /*     */     private static final long serialVersionUID = 2L;
> /*     */     public final double priori;
> /*     */     public final DistributionModified distribution;
> /*     */     
> /*     */     public Component(double priori, DistributionModified distribution) {
> /*  49 */       this.priori = priori;
> /*  50 */       this.distribution = distribution;
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public MixtureModified(Component... components) {
> /*  62 */     if (components.length == 0) {
> /*  63 */       throw new IllegalStateException("Empty mixture!");
> /*     */     }
> /*     */     
> /*  66 */     double sum = 0.0D; byte b; int i; Component[] arrayOfComponent;
> /*  67 */     for (i = (arrayOfComponent = components).length, b = 0; b < i; ) { Component component = arrayOfComponent[b];
> /*  68 */       sum += component.priori;
> /*     */       b++; }
> /*     */     
> /*  71 */     if (Math.abs(sum - 1.0D) > 0.001D) {
> /*  72 */       throw new IllegalArgumentException("The sum of priori is not equal to 1.");
> /*     */     }
> /*     */     
> /*  75 */     this.components = components;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] posteriori(double x) {
> /*  84 */     int k = this.components.length;
> /*  85 */     double[] prob = new double[k];
> /*  86 */     for (int i = 0; i < k; i++) {
> /*  87 */       Component c = this.components[i];
> /*  88 */       prob[i] = c.priori * c.distribution.p(x);
> /*     */     } 
> /*     */     
> /*  91 */     double p = MathExModified.sum(prob);
> /*  92 */     for (int j = 0; j < k; j++) {
> /*  93 */       prob[j] = prob[j] / p;
> /*     */     }
> /*  95 */     return prob;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int map(double x) {
> /* 104 */     int k = this.components.length;
> /* 105 */     double[] prob = new double[k];
> /* 106 */     for (int i = 0; i < k; i++) {
> /* 107 */       Component c = this.components[i];
> /* 108 */       prob[i] = c.priori * c.distribution.p(x);
> /*     */     } 
> /*     */     
> /* 111 */     return MathExModified.whichMax(prob);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double mean() {
> /* 116 */     double mu = 0.0D; byte b; int i;
> /*     */     Component[] arrayOfComponent;
> /* 118 */     for (i = (arrayOfComponent = this.components).length, b = 0; b < i; ) { Component c = arrayOfComponent[b];
> /* 119 */       mu += c.priori * c.distribution.mean(); b++; }
> /*     */     
> /* 121 */     return mu;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double variance() {
> /* 126 */     double variance = 0.0D; byte b; int i;
> /*     */     Component[] arrayOfComponent;
> /* 128 */     for (i = (arrayOfComponent = this.components).length, b = 0; b < i; ) { Component c = arrayOfComponent[b];
> /* 129 */       variance += c.priori * c.priori * c.distribution.variance(); b++; }
> /*     */     
> /* 131 */     return variance;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double entropy() {
> /* 139 */     throw new UnsupportedOperationException("Mixture does not support entropy()");
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double p(double x) {
> /* 144 */     double p = 0.0D; byte b; int i;
> /*     */     Component[] arrayOfComponent;
> /* 146 */     for (i = (arrayOfComponent = this.components).length, b = 0; b < i; ) { Component c = arrayOfComponent[b];
> /* 147 */       p += c.priori * c.distribution.p(x); b++; }
> /*     */     
> /* 149 */     return p;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double logp(double x) {
> /* 154 */     return Math.log(p(x));
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double cdf(double x) {
> /* 159 */     double p = 0.0D; byte b; int i;
> /*     */     Component[] arrayOfComponent;
> /* 161 */     for (i = (arrayOfComponent = this.components).length, b = 0; b < i; ) { Component c = arrayOfComponent[b];
> /* 162 */       p += c.priori * c.distribution.cdf(x); b++; }
> /*     */     
> /* 164 */     return p;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double rand() {
> /* 169 */     double r = MathExModified.random();
> /*     */     
> /* 171 */     double p = 0.0D; byte b; int i; Component[] arrayOfComponent;
> /* 172 */     for (i = (arrayOfComponent = this.components).length, b = 0; b < i; ) { Component g = arrayOfComponent[b];
> /* 173 */       p += g.priori;
> /* 174 */       if (r <= p) {
> /* 175 */         return g.distribution.rand();
> /*     */       }
> /*     */       b++; }
> /*     */     
> /* 179 */     throw new IllegalStateException();
> /*     */   }
> /*     */   
> /*     */   public double quantile(double p) {
> /*     */     double xl, xu;
> /* 184 */     if (p < 0.0D || p > 1.0D) {
> /* 185 */       throw new IllegalArgumentException("Invalid p: " + p);
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */     
> /* 190 */     double inc = 1.0D;
> /* 191 */     double x = (int)mean();
> /* 192 */     if (p < cdf(x)) {
> /*     */       do {
> /* 194 */         x -= inc;
> /* 195 */         inc *= 2.0D;
> /* 196 */       } while (p < cdf(x));
> /* 197 */       xl = x;
> /* 198 */       xu = x + inc / 2.0D;
> /*     */     } else {
> /*     */       do {
> /* 201 */         x += inc;
> /* 202 */         inc *= 2.0D;
> /* 203 */       } while (p > cdf(x));
> /* 204 */       xu = x;
> /* 205 */       xl = x - inc / 2.0D;
> /*     */     } 
> /*     */     
> /* 208 */     return quantile(p, xl, xu);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public int length() {
> /* 213 */     int length = this.components.length - 1; byte b; int i; Component[] arrayOfComponent;
> /* 214 */     for (i = (arrayOfComponent = this.components).length, b = 0; b < i; ) { Component component = arrayOfComponent[b];
> /* 215 */       length += component.distribution.length(); b++; }
> /*     */     
> /* 217 */     return length;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int size() {
> /* 225 */     return this.components.length;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double bic(double[] data) {
> /* 234 */     int n = data.length;
> /*     */     
> /* 236 */     double logLikelihood = 0.0D; byte b; int i; double[] arrayOfDouble;
> /* 237 */     for (i = (arrayOfDouble = data).length, b = 0; b < i; ) { double x = arrayOfDouble[b];
> /* 238 */       double p = p(x);
> /* 239 */       if (p > 0.0D) logLikelihood += Math.log(p); 
> /*     */       b++; }
> /*     */     
> /* 242 */     return logLikelihood - 0.5D * length() * Math.log(n);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 247 */     return Arrays.<Component>stream(this.components)
> /* 248 */       .map(component -> String.format("%.2f x %s", new Object[] { Double.valueOf(component.priori), component.distribution
> /* 249 */           })).collect(Collectors.joining(" + ", String.format("Mixture(%d)[", new Object[] { Integer.valueOf(this.components.length) }), "]"));
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/MixtureModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/OpenBLASModified.java jd-gui/smileModified/OpenBLASModified.java
1,914c1,1168
< package smileModified;
< 
< import java.nio.DoubleBuffer;
< import java.nio.FloatBuffer;
< import java.nio.IntBuffer;
< import org.bytedeco.javacpp.DoublePointer;
< import org.bytedeco.javacpp.IntPointer;
< import org.bytedeco.openblas.global.openblas;
< 
< public class OpenBLASModified implements BLASModified, LAPACKModified {
<    public double asum(int n, double[] x, int incx) {
<       return openblas.cblas_dasum(n, x, incx);
<    }
< 
<    public float asum(int n, float[] x, int incx) {
<       return openblas.cblas_sasum(n, x, incx);
<    }
< 
<    public void axpy(int n, double alpha, double[] x, int incx, double[] y, int incy) {
<       openblas.cblas_daxpy(n, alpha, x, incx, y, incy);
<    }
< 
<    public void axpy(int n, float alpha, float[] x, int incx, float[] y, int incy) {
<       openblas.cblas_saxpy(n, alpha, x, incx, y, incy);
<    }
< 
<    public double dot(int n, double[] x, int incx, double[] y, int incy) {
<       return openblas.cblas_ddot(n, x, incx, y, incy);
<    }
< 
<    public float dot(int n, float[] x, int incx, float[] y, int incy) {
<       return openblas.cblas_sdot(n, x, incx, y, incy);
<    }
< 
<    public double nrm2(int n, double[] x, int incx) {
<       return openblas.cblas_dnrm2(n, x, incx);
<    }
< 
<    public float nrm2(int n, float[] x, int incx) {
<       return openblas.cblas_snrm2(n, x, incx);
<    }
< 
<    public void scal(int n, double alpha, double[] x, int incx) {
<       openblas.cblas_dscal(n, alpha, x, incx);
<    }
< 
<    public void scal(int n, float alpha, float[] x, int incx) {
<       openblas.cblas_sscal(n, alpha, x, incx);
<    }
< 
<    public void swap(int n, double[] x, int incx, double[] y, int incy) {
<       openblas.cblas_dswap(n, x, incx, y, incy);
<    }
< 
<    public void swap(int n, float[] x, int incx, float[] y, int incy) {
<       openblas.cblas_sswap(n, x, incx, y, incy);
<    }
< 
<    public long iamax(int n, double[] x, int incx) {
<       return openblas.cblas_idamax(n, x, incx);
<    }
< 
<    public long iamax(int n, float[] x, int incx) {
<       return openblas.cblas_isamax(n, x, incx);
<    }
< 
<    public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
<       openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
<       openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, double alpha, DoublePointer A, int lda, DoublePointer x, int incx, double beta, DoublePointer y, int incy) {
<       openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
<       openblas.cblas_sgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
<       openblas.cblas_sgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void symv(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
<       openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void symv(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
<       openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void symv(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoublePointer A, int lda, DoublePointer x, int incx, double beta, DoublePointer y, int incy) {
<       openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void symv(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
<       openblas.cblas_ssymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void symv(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
<       openblas.cblas_ssymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void spmv(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] A, double[] x, int incx, double beta, double[] y, int incy) {
<       openblas.cblas_dspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
<    }
< 
<    public void spmv(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer A, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
<       openblas.cblas_dspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
<    }
< 
<    public void spmv(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] A, float[] x, int incx, float beta, float[] y, int incy) {
<       openblas.cblas_sspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
<    }
< 
<    public void spmv(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer A, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
<       openblas.cblas_sspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
<    }
< 
<    public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, double[] A, int lda, double[] x, int incx) {
<       openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
<    }
< 
<    public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, DoubleBuffer A, int lda, DoubleBuffer x, int incx) {
<       openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
<    }
< 
<    public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, DoublePointer A, int lda, DoublePointer x, int incx) {
<       openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
<    }
< 
<    public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, float[] A, int lda, float[] x, int incx) {
<       openblas.cblas_strmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
<    }
< 
<    public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, FloatBuffer A, int lda, FloatBuffer x, int incx) {
<       openblas.cblas_strmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
<    }
< 
<    public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, double[] A, double[] x, int incx) {
<       openblas.cblas_dtpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
<    }
< 
<    public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, DoubleBuffer A, DoubleBuffer x, int incx) {
<       openblas.cblas_dtpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
<    }
< 
<    public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, float[] A, float[] x, int incx) {
<       openblas.cblas_stpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
<    }
< 
<    public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, FloatBuffer A, FloatBuffer x, int incx) {
<       openblas.cblas_stpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
<    }
< 
<    public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
<       openblas.cblas_dgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
<       openblas.cblas_dgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
<       openblas.cblas_sgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
<       openblas.cblas_sgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
<       openblas.cblas_dsbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
<       openblas.cblas_dsbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
<       openblas.cblas_ssbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
<       openblas.cblas_ssbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
<    }
< 
<    public void ger(LayoutModified layout, int m, int n, double alpha, double[] x, int incx, double[] y, int incy, double[] A, int lda) {
<       openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
<    }
< 
<    public void ger(LayoutModified layout, int m, int n, double alpha, DoubleBuffer x, int incx, DoubleBuffer y, int incy, DoubleBuffer A, int lda) {
<       openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
<    }
< 
<    public void ger(LayoutModified layout, int m, int n, double alpha, DoublePointer x, int incx, DoublePointer y, int incy, DoublePointer A, int lda) {
<       openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
<    }
< 
<    public void ger(LayoutModified layout, int m, int n, float alpha, float[] x, int incx, float[] y, int incy, float[] A, int lda) {
<       openblas.cblas_sger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
<    }
< 
<    public void ger(LayoutModified layout, int m, int n, float alpha, FloatBuffer x, int incx, FloatBuffer y, int incy, FloatBuffer A, int lda) {
<       openblas.cblas_sger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
<    }
< 
<    public void syr(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] x, int incx, double[] A, int lda) {
<       openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
<    }
< 
<    public void syr(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer x, int incx, DoubleBuffer A, int lda) {
<       openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
<    }
< 
<    public void syr(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoublePointer x, int incx, DoublePointer A, int lda) {
<       openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
<    }
< 
<    public void syr(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] x, int incx, float[] A, int lda) {
<       openblas.cblas_ssyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
<    }
< 
<    public void syr(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer x, int incx, FloatBuffer A, int lda) {
<       openblas.cblas_ssyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
<    }
< 
<    public void spr(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] x, int incx, double[] A) {
<       openblas.cblas_dspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
<    }
< 
<    public void spr(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer x, int incx, DoubleBuffer A) {
<       openblas.cblas_dspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
<    }
< 
<    public void spr(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] x, int incx, float[] A) {
<       openblas.cblas_sspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
<    }
< 
<    public void spr(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer x, int incx, FloatBuffer A) {
<       openblas.cblas_sspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
<    }
< 
<    public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, double alpha, double[] A, int lda, double[] B, int ldb, double beta, double[] C, int ldc) {
<       openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, double alpha, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, double beta, DoubleBuffer C, int ldc) {
<       openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, double alpha, DoublePointer A, int lda, DoublePointer B, int ldb, double beta, DoublePointer C, int ldc) {
<       openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, float alpha, float[] A, int lda, float[] B, int ldb, float beta, float[] C, int ldc) {
<       openblas.cblas_sgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, float alpha, FloatBuffer A, int lda, FloatBuffer B, int ldb, float beta, FloatBuffer C, int ldc) {
<       openblas.cblas_sgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, double alpha, double[] A, int lda, double[] B, int ldb, double beta, double[] C, int ldc) {
<       openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, double alpha, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, double beta, DoubleBuffer C, int ldc) {
<       openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, double alpha, DoublePointer A, int lda, DoublePointer B, int ldb, double beta, DoublePointer C, int ldc) {
<       openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, float alpha, float[] A, int lda, float[] B, int ldb, float beta, float[] C, int ldc) {
<       openblas.cblas_ssymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, float alpha, FloatBuffer A, int lda, FloatBuffer B, int ldb, float beta, FloatBuffer C, int ldc) {
<       openblas.cblas_ssymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
<    }
< 
<    public int gesv(LayoutModified layout, int n, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gesv(LayoutModified layout, int n, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gesv(LayoutModified layout, int n, int nrhs, DoublePointer A, int lda, IntPointer ipiv, DoublePointer B, int ldb) {
<       return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gesv(LayoutModified layout, int n, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_sgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gesv(LayoutModified layout, int n, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoublePointer A, int lda, IntPointer ipiv, DoublePointer B, int ldb) {
<       return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_ssysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_ssysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
<    }
< 
<    public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
<    }
< 
<    public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_sspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
<    }
< 
<    public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
<    }
< 
<    public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
<       return openblas.LAPACKE_dposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
<       return openblas.LAPACKE_sposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, double[] B, int ldb) {
<       return openblas.LAPACKE_dppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
<    }
< 
<    public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
<    }
< 
<    public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, float[] B, int ldb) {
<       return openblas.LAPACKE_sppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
<    }
< 
<    public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
<    }
< 
<    public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_sgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
<       return openblas.LAPACKE_dgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
<       return openblas.LAPACKE_sgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int gelsy(LayoutModified layout, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb, int[] jpvt, double rcond, int[] rank) {
<       return openblas.LAPACKE_dgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
<    }
< 
<    public int gelsy(LayoutModified layout, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, IntBuffer jpvt, double rcond, IntBuffer rank) {
<       return openblas.LAPACKE_dgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
<    }
< 
<    public int gelsy(LayoutModified layout, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb, int[] jpvt, float rcond, int[] rank) {
<       return openblas.LAPACKE_sgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
<    }
< 
<    public int gelsy(LayoutModified layout, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb, IntBuffer jpvt, float rcond, IntBuffer rank) {
<       return openblas.LAPACKE_sgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
<    }
< 
<    public int gelss(LayoutModified layout, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb, double[] s, double rcond, int[] rank) {
<       return openblas.LAPACKE_dgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelss(LayoutModified layout, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer s, double rcond, IntBuffer rank) {
<       return openblas.LAPACKE_dgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelss(LayoutModified layout, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb, float[] s, float rcond, int[] rank) {
<       return openblas.LAPACKE_sgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelss(LayoutModified layout, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer s, float rcond, IntBuffer rank) {
<       return openblas.LAPACKE_sgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelsd(LayoutModified layout, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb, double[] s, double rcond, int[] rank) {
<       return openblas.LAPACKE_dgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelsd(LayoutModified layout, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer s, double rcond, IntBuffer rank) {
<       return openblas.LAPACKE_dgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelsd(LayoutModified layout, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb, float[] s, float rcond, int[] rank) {
<       return openblas.LAPACKE_sgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gelsd(LayoutModified layout, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer s, float rcond, IntBuffer rank) {
<       return openblas.LAPACKE_sgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
<    }
< 
<    public int gglse(LayoutModified layout, int m, int n, int p, double[] A, int lda, double[] B, int ldb, double[] c, double[] d, double[] x) {
<       return openblas.LAPACKE_dgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
<    }
< 
<    public int gglse(LayoutModified layout, int m, int n, int p, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer c, DoubleBuffer d, DoubleBuffer x) {
<       return openblas.LAPACKE_dgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
<    }
< 
<    public int gglse(LayoutModified layout, int m, int n, int p, float[] A, int lda, float[] B, int ldb, float[] c, float[] d, float[] x) {
<       return openblas.LAPACKE_sgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
<    }
< 
<    public int gglse(LayoutModified layout, int m, int n, int p, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer c, FloatBuffer d, FloatBuffer x) {
<       return openblas.LAPACKE_sgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
<    }
< 
<    public int ggglm(LayoutModified layout, int n, int m, int p, double[] A, int lda, double[] B, int ldb, double[] d, double[] x, double[] y) {
<       return openblas.LAPACKE_dggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
<    }
< 
<    public int ggglm(LayoutModified layout, int n, int m, int p, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer d, DoubleBuffer x, DoubleBuffer y) {
<       return openblas.LAPACKE_dggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
<    }
< 
<    public int ggglm(LayoutModified layout, int n, int m, int p, float[] A, int lda, float[] B, int ldb, float[] d, float[] x, float[] y) {
<       return openblas.LAPACKE_sggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
<    }
< 
<    public int ggglm(LayoutModified layout, int n, int m, int p, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer d, FloatBuffer x, FloatBuffer y) {
<       return openblas.LAPACKE_sggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
<    }
< 
<    public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, double[] A, int lda, double[] wr, double[] wi, double[] Vl, int ldvl, double[] Vr, int ldvr) {
<       return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
<    }
< 
<    public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, DoubleBuffer A, int lda, DoubleBuffer wr, DoubleBuffer wi, DoubleBuffer Vl, int ldvl, DoubleBuffer Vr, int ldvr) {
<       return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
<    }
< 
<    public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, DoublePointer A, int lda, DoublePointer wr, DoublePointer wi, DoublePointer Vl, int ldvl, DoublePointer Vr, int ldvr) {
<       return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
<    }
< 
<    public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, float[] A, int lda, float[] wr, float[] wi, float[] Vl, int ldvl, float[] Vr, int ldvr) {
<       return openblas.LAPACKE_sgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
<    }
< 
<    public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, FloatBuffer A, int lda, FloatBuffer wr, FloatBuffer wi, FloatBuffer Vl, int ldvl, FloatBuffer Vr, int ldvr) {
<       return openblas.LAPACKE_sgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
<    }
< 
<    public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, double[] A, int lda, double[] w) {
<       return openblas.LAPACKE_dsyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, DoubleBuffer A, int lda, DoubleBuffer w) {
<       return openblas.LAPACKE_dsyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, float[] A, int lda, float[] w) {
<       return openblas.LAPACKE_ssyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, FloatBuffer A, int lda, FloatBuffer w) {
<       return openblas.LAPACKE_ssyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, double[] A, int lda, double[] w) {
<       return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, DoubleBuffer A, int lda, DoubleBuffer w) {
<       return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, DoublePointer A, int lda, DoublePointer w) {
<       return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, float[] A, int lda, float[] w) {
<       return openblas.LAPACKE_ssyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, FloatBuffer A, int lda, FloatBuffer w) {
<       return openblas.LAPACKE_ssyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
<    }
< 
<    public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, double[] A, int lda, double vl, double vu, int il, int iu, double abstol, int[] m, double[] w, double[] Z, int ldz, int[] isuppz) {
<       return openblas.LAPACKE_dsyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
<    }
< 
<    public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, DoubleBuffer A, int lda, double vl, double vu, int il, int iu, double abstol, IntBuffer m, DoubleBuffer w, DoubleBuffer Z, int ldz, IntBuffer isuppz) {
<       return openblas.LAPACKE_dsyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
<    }
< 
<    public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, float[] A, int lda, float vl, float vu, int il, int iu, float abstol, int[] m, float[] w, float[] Z, int ldz, int[] isuppz) {
<       return openblas.LAPACKE_ssyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
<    }
< 
<    public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, FloatBuffer A, int lda, float vl, float vu, int il, int iu, float abstol, IntBuffer m, FloatBuffer w, FloatBuffer Z, int ldz, IntBuffer isuppz) {
<       return openblas.LAPACKE_ssyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
<    }
< 
<    public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, double[] A, int lda, double[] s, double[] U, int ldu, double[] VT, int ldvt, double[] superb) {
<       return openblas.LAPACKE_dgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
<    }
< 
<    public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, DoubleBuffer A, int lda, DoubleBuffer s, DoubleBuffer U, int ldu, DoubleBuffer VT, int ldvt, DoubleBuffer superb) {
<       return openblas.LAPACKE_dgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
<    }
< 
<    public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, float[] A, int lda, float[] s, float[] U, int ldu, float[] VT, int ldvt, float[] superb) {
<       return openblas.LAPACKE_sgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
<    }
< 
<    public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, FloatBuffer A, int lda, FloatBuffer s, FloatBuffer U, int ldu, FloatBuffer VT, int ldvt, FloatBuffer superb) {
<       return openblas.LAPACKE_sgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
<    }
< 
<    public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, double[] A, int lda, double[] s, double[] U, int ldu, double[] VT, int ldvt) {
<       return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
<    }
< 
<    public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, DoubleBuffer A, int lda, DoubleBuffer s, DoubleBuffer U, int ldu, DoubleBuffer VT, int ldvt) {
<       return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
<    }
< 
<    public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, DoublePointer A, int lda, DoublePointer s, DoublePointer U, int ldu, DoublePointer VT, int ldvt) {
<       return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
<    }
< 
<    public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, float[] A, int lda, float[] s, float[] U, int ldu, float[] VT, int ldvt) {
<       return openblas.LAPACKE_sgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
<    }
< 
<    public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, FloatBuffer A, int lda, FloatBuffer s, FloatBuffer U, int ldu, FloatBuffer VT, int ldvt) {
<       return openblas.LAPACKE_sgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
<    }
< 
<    public int getrf(LayoutModified layout, int m, int n, double[] A, int lda, int[] ipiv) {
<       return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf(LayoutModified layout, int m, int n, DoubleBuffer A, int lda, IntBuffer ipiv) {
<       return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf(LayoutModified layout, int m, int n, DoublePointer A, int lda, IntPointer ipiv) {
<       return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf(LayoutModified layout, int m, int n, float[] A, int lda, int[] ipiv) {
<       return openblas.LAPACKE_sgetrf(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf(LayoutModified layout, int m, int n, FloatBuffer A, int lda, IntBuffer ipiv) {
<       return openblas.LAPACKE_sgetrf(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf2(LayoutModified layout, int m, int n, double[] A, int lda, int[] ipiv) {
<       return openblas.LAPACKE_dgetrf2(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf2(LayoutModified layout, int m, int n, DoubleBuffer A, int lda, IntBuffer ipiv) {
<       return openblas.LAPACKE_dgetrf2(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf2(LayoutModified layout, int m, int n, float[] A, int lda, int[] ipiv) {
<       return openblas.LAPACKE_sgetrf2(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int getrf2(LayoutModified layout, int m, int n, FloatBuffer A, int lda, IntBuffer ipiv) {
<       return openblas.LAPACKE_sgetrf2(layout.lapack(), m, n, A, lda, ipiv);
<    }
< 
<    public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, double[] AB, int ldab, int[] ipiv) {
<       return openblas.LAPACKE_dgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
<    }
< 
<    public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, DoubleBuffer AB, int ldab, IntBuffer ipiv) {
<       return openblas.LAPACKE_dgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
<    }
< 
<    public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, float[] AB, int ldab, int[] ipiv) {
<       return openblas.LAPACKE_sgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
<    }
< 
<    public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, FloatBuffer AB, int ldab, IntBuffer ipiv) {
<       return openblas.LAPACKE_sgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
<    }
< 
<    public int sptrf(LayoutModified layout, UPLOModified uplo, int n, double[] AP, int[] ipiv) {
<       return openblas.LAPACKE_dsptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
<    }
< 
<    public int sptrf(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer AP, IntBuffer ipiv) {
<       return openblas.LAPACKE_dsptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
<    }
< 
<    public int sptrf(LayoutModified layout, UPLOModified uplo, int n, float[] AP, int[] ipiv) {
<       return openblas.LAPACKE_ssptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
<    }
< 
<    public int sptrf(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer AP, IntBuffer ipiv) {
<       return openblas.LAPACKE_ssptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
<    }
< 
<    public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, DoublePointer A, int lda, IntPointer ipiv, DoublePointer B, int ldb) {
<       return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_sgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_sgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_sgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
<    }
< 
<    public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] AP, int[] ipiv, double[] B, int ldb) {
<       return openblas.LAPACKE_dsptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
<    }
< 
<    public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer AP, IntBuffer ipiv, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dsptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
<    }
< 
<    public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] AP, int[] ipiv, float[] B, int ldb) {
<       return openblas.LAPACKE_ssptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
<    }
< 
<    public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer AP, IntBuffer ipiv, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_ssptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
<    }
< 
<    public int potrf(LayoutModified layout, UPLOModified uplo, int n, double[] A, int lda) {
<       return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer A, int lda) {
<       return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf(LayoutModified layout, UPLOModified uplo, int n, DoublePointer A, int lda) {
<       return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf(LayoutModified layout, UPLOModified uplo, int n, float[] A, int lda) {
<       return openblas.LAPACKE_spotrf(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer A, int lda) {
<       return openblas.LAPACKE_spotrf(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf2(LayoutModified layout, UPLOModified uplo, int n, double[] A, int lda) {
<       return openblas.LAPACKE_dpotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf2(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer A, int lda) {
<       return openblas.LAPACKE_dpotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf2(LayoutModified layout, UPLOModified uplo, int n, float[] A, int lda) {
<       return openblas.LAPACKE_spotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int potrf2(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer A, int lda) {
<       return openblas.LAPACKE_spotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
<    }
< 
<    public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, double[] AB, int ldab) {
<       return openblas.LAPACKE_dpbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
<    }
< 
<    public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, DoubleBuffer AB, int ldab) {
<       return openblas.LAPACKE_dpbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
<    }
< 
<    public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, float[] AB, int ldab) {
<       return openblas.LAPACKE_spbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
<    }
< 
<    public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, FloatBuffer AB, int ldab) {
<       return openblas.LAPACKE_spbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
<    }
< 
<    public int pptrf(LayoutModified layout, UPLOModified uplo, int n, double[] AP) {
<       return openblas.LAPACKE_dpptrf(layout.lapack(), uplo.lapack(), n, AP);
<    }
< 
<    public int pptrf(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer AP) {
<       return openblas.LAPACKE_dpptrf(layout.lapack(), uplo.lapack(), n, AP);
<    }
< 
<    public int pptrf(LayoutModified layout, UPLOModified uplo, int n, float[] AP) {
<       return openblas.LAPACKE_spptrf(layout.lapack(), uplo.lapack(), n, AP);
<    }
< 
<    public int pptrf(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer AP) {
<       return openblas.LAPACKE_spptrf(layout.lapack(), uplo.lapack(), n, AP);
<    }
< 
<    public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
<       return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoublePointer A, int lda, DoublePointer B, int ldb) {
<       return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
<       return openblas.LAPACKE_spotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_spotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, double[] AB, int ldab, double[] B, int ldb) {
<       return openblas.LAPACKE_dpbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
<    }
< 
<    public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, DoubleBuffer AB, int ldab, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dpbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
<    }
< 
<    public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, float[] AB, int ldab, float[] B, int ldb) {
<       return openblas.LAPACKE_spbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
<    }
< 
<    public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, FloatBuffer AB, int ldab, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_spbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
<    }
< 
<    public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] AP, double[] B, int ldb) {
<       return openblas.LAPACKE_dpptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
<    }
< 
<    public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer AP, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dpptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
<    }
< 
<    public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] AP, float[] B, int ldb) {
<       return openblas.LAPACKE_spptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
<    }
< 
<    public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer AP, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_spptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
<    }
< 
<    public int geqrf(LayoutModified layout, int m, int n, double[] A, int lda, double[] tau) {
<       return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
<    }
< 
<    public int geqrf(LayoutModified layout, int m, int n, DoubleBuffer A, int lda, DoubleBuffer tau) {
<       return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
<    }
< 
<    public int geqrf(LayoutModified layout, int m, int n, DoublePointer A, int lda, DoublePointer tau) {
<       return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
<    }
< 
<    public int geqrf(LayoutModified layout, int m, int n, float[] A, int lda, float[] tau) {
<       return openblas.LAPACKE_sgeqrf(layout.lapack(), m, n, A, lda, tau);
<    }
< 
<    public int geqrf(LayoutModified layout, int m, int n, FloatBuffer A, int lda, FloatBuffer tau) {
<       return openblas.LAPACKE_sgeqrf(layout.lapack(), m, n, A, lda, tau);
<    }
< 
<    public int orgqr(LayoutModified layout, int m, int n, int k, double[] A, int lda, double[] tau) {
<       return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
<    }
< 
<    public int orgqr(LayoutModified layout, int m, int n, int k, DoubleBuffer A, int lda, DoubleBuffer tau) {
<       return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
<    }
< 
<    public int orgqr(LayoutModified layout, int m, int n, int k, DoublePointer A, int lda, DoublePointer tau) {
<       return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
<    }
< 
<    public int orgqr(LayoutModified layout, int m, int n, int k, float[] A, int lda, float[] tau) {
<       return openblas.LAPACKE_sorgqr(layout.lapack(), m, n, k, A, lda, tau);
<    }
< 
<    public int orgqr(LayoutModified layout, int m, int n, int k, FloatBuffer A, int lda, FloatBuffer tau) {
<       return openblas.LAPACKE_sorgqr(layout.lapack(), m, n, k, A, lda, tau);
<    }
< 
<    public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, double[] A, int lda, double[] tau, double[] C, int ldc) {
<       return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
<    }
< 
<    public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, DoubleBuffer A, int lda, DoubleBuffer tau, DoubleBuffer C, int ldc) {
<       return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
<    }
< 
<    public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, DoublePointer A, int lda, DoublePointer tau, DoublePointer C, int ldc) {
<       return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
<    }
< 
<    public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, float[] A, int lda, float[] tau, float[] C, int ldc) {
<       return openblas.LAPACKE_sormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
<    }
< 
<    public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, FloatBuffer A, int lda, FloatBuffer tau, FloatBuffer C, int ldc) {
<       return openblas.LAPACKE_sormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
<    }
< 
<    public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
<       return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
<       return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, DoublePointer A, int lda, DoublePointer B, int ldb) {
<       return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
<       return openblas.LAPACKE_strtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< 
<    public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
<       return openblas.LAPACKE_strtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
<    }
< }
---
> /*      */ package smileModified;
> /*      */ 
> /*      */ import java.nio.DoubleBuffer;
> /*      */ import java.nio.FloatBuffer;
> /*      */ import java.nio.IntBuffer;
> /*      */ import org.bytedeco.javacpp.DoublePointer;
> /*      */ import org.bytedeco.javacpp.IntPointer;
> /*      */ import org.bytedeco.openblas.global.openblas;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ public class OpenBLASModified
> /*      */   implements BLASModified, LAPACKModified
> /*      */ {
> /*      */   public double asum(int n, double[] x, int incx) {
> /*   35 */     return openblas.cblas_dasum(n, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public float asum(int n, float[] x, int incx) {
> /*   40 */     return openblas.cblas_sasum(n, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void axpy(int n, double alpha, double[] x, int incx, double[] y, int incy) {
> /*   45 */     openblas.cblas_daxpy(n, alpha, x, incx, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void axpy(int n, float alpha, float[] x, int incx, float[] y, int incy) {
> /*   50 */     openblas.cblas_saxpy(n, alpha, x, incx, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public double dot(int n, double[] x, int incx, double[] y, int incy) {
> /*   55 */     return openblas.cblas_ddot(n, x, incx, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public float dot(int n, float[] x, int incx, float[] y, int incy) {
> /*   60 */     return openblas.cblas_sdot(n, x, incx, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public double nrm2(int n, double[] x, int incx) {
> /*   65 */     return openblas.cblas_dnrm2(n, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public float nrm2(int n, float[] x, int incx) {
> /*   70 */     return openblas.cblas_snrm2(n, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void scal(int n, double alpha, double[] x, int incx) {
> /*   75 */     openblas.cblas_dscal(n, alpha, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void scal(int n, float alpha, float[] x, int incx) {
> /*   80 */     openblas.cblas_sscal(n, alpha, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void swap(int n, double[] x, int incx, double[] y, int incy) {
> /*   85 */     openblas.cblas_dswap(n, x, incx, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void swap(int n, float[] x, int incx, float[] y, int incy) {
> /*   90 */     openblas.cblas_sswap(n, x, incx, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public long iamax(int n, double[] x, int incx) {
> /*   95 */     return openblas.cblas_idamax(n, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public long iamax(int n, float[] x, int incx) {
> /*  100 */     return openblas.cblas_isamax(n, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
> /*  105 */     openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
> /*  110 */     openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, double alpha, DoublePointer A, int lda, DoublePointer x, int incx, double beta, DoublePointer y, int incy) {
> /*  115 */     openblas.cblas_dgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
> /*  120 */     openblas.cblas_sgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gemv(LayoutModified layout, TransposeModified trans, int m, int n, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
> /*  125 */     openblas.cblas_sgemv(layout.blas(), trans.blas(), m, n, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void symv(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
> /*  130 */     openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void symv(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
> /*  135 */     openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void symv(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoublePointer A, int lda, DoublePointer x, int incx, double beta, DoublePointer y, int incy) {
> /*  140 */     openblas.cblas_dsymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void symv(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
> /*  145 */     openblas.cblas_ssymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void symv(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
> /*  150 */     openblas.cblas_ssymv(layout.blas(), uplo.blas(), n, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void spmv(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] A, double[] x, int incx, double beta, double[] y, int incy) {
> /*  155 */     openblas.cblas_dspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void spmv(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer A, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
> /*  160 */     openblas.cblas_dspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void spmv(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] A, float[] x, int incx, float beta, float[] y, int incy) {
> /*  165 */     openblas.cblas_sspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void spmv(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer A, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
> /*  170 */     openblas.cblas_sspmv(layout.blas(), uplo.blas(), n, alpha, A, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, double[] A, int lda, double[] x, int incx) {
> /*  175 */     openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, DoubleBuffer A, int lda, DoubleBuffer x, int incx) {
> /*  180 */     openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, DoublePointer A, int lda, DoublePointer x, int incx) {
> /*  185 */     openblas.cblas_dtrmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, float[] A, int lda, float[] x, int incx) {
> /*  190 */     openblas.cblas_strmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void trmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, FloatBuffer A, int lda, FloatBuffer x, int incx) {
> /*  195 */     openblas.cblas_strmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, lda, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, double[] A, double[] x, int incx) {
> /*  200 */     openblas.cblas_dtpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, DoubleBuffer A, DoubleBuffer x, int incx) {
> /*  205 */     openblas.cblas_dtpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, float[] A, float[] x, int incx) {
> /*  210 */     openblas.cblas_stpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void tpmv(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, FloatBuffer A, FloatBuffer x, int incx) {
> /*  215 */     openblas.cblas_stpmv(layout.blas(), uplo.blas(), trans.blas(), diag.blas(), n, A, x, incx);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
> /*  220 */     openblas.cblas_dgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
> /*  225 */     openblas.cblas_dgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
> /*  230 */     openblas.cblas_sgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gbmv(LayoutModified layout, TransposeModified trans, int m, int n, int kl, int ku, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
> /*  235 */     openblas.cblas_sgbmv(layout.blas(), trans.blas(), m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, double alpha, double[] A, int lda, double[] x, int incx, double beta, double[] y, int incy) {
> /*  240 */     openblas.cblas_dsbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, double alpha, DoubleBuffer A, int lda, DoubleBuffer x, int incx, double beta, DoubleBuffer y, int incy) {
> /*  245 */     openblas.cblas_dsbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, float alpha, float[] A, int lda, float[] x, int incx, float beta, float[] y, int incy) {
> /*  250 */     openblas.cblas_ssbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void sbmv(LayoutModified layout, UPLOModified uplo, int n, int k, float alpha, FloatBuffer A, int lda, FloatBuffer x, int incx, float beta, FloatBuffer y, int incy) {
> /*  255 */     openblas.cblas_ssbmv(layout.blas(), uplo.blas(), n, k, alpha, A, lda, x, incx, beta, y, incy);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void ger(LayoutModified layout, int m, int n, double alpha, double[] x, int incx, double[] y, int incy, double[] A, int lda) {
> /*  260 */     openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void ger(LayoutModified layout, int m, int n, double alpha, DoubleBuffer x, int incx, DoubleBuffer y, int incy, DoubleBuffer A, int lda) {
> /*  265 */     openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void ger(LayoutModified layout, int m, int n, double alpha, DoublePointer x, int incx, DoublePointer y, int incy, DoublePointer A, int lda) {
> /*  270 */     openblas.cblas_dger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void ger(LayoutModified layout, int m, int n, float alpha, float[] x, int incx, float[] y, int incy, float[] A, int lda) {
> /*  275 */     openblas.cblas_sger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void ger(LayoutModified layout, int m, int n, float alpha, FloatBuffer x, int incx, FloatBuffer y, int incy, FloatBuffer A, int lda) {
> /*  280 */     openblas.cblas_sger(layout.blas(), m, n, alpha, x, incx, y, incy, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void syr(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] x, int incx, double[] A, int lda) {
> /*  285 */     openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void syr(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer x, int incx, DoubleBuffer A, int lda) {
> /*  290 */     openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void syr(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoublePointer x, int incx, DoublePointer A, int lda) {
> /*  295 */     openblas.cblas_dsyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void syr(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] x, int incx, float[] A, int lda) {
> /*  300 */     openblas.cblas_ssyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void syr(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer x, int incx, FloatBuffer A, int lda) {
> /*  305 */     openblas.cblas_ssyr(layout.blas(), uplo.blas(), n, alpha, x, incx, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void spr(LayoutModified layout, UPLOModified uplo, int n, double alpha, double[] x, int incx, double[] A) {
> /*  310 */     openblas.cblas_dspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void spr(LayoutModified layout, UPLOModified uplo, int n, double alpha, DoubleBuffer x, int incx, DoubleBuffer A) {
> /*  315 */     openblas.cblas_dspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void spr(LayoutModified layout, UPLOModified uplo, int n, float alpha, float[] x, int incx, float[] A) {
> /*  320 */     openblas.cblas_sspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void spr(LayoutModified layout, UPLOModified uplo, int n, float alpha, FloatBuffer x, int incx, FloatBuffer A) {
> /*  325 */     openblas.cblas_sspr(layout.blas(), uplo.blas(), n, alpha, x, incx, A);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, double alpha, double[] A, int lda, double[] B, int ldb, double beta, double[] C, int ldc) {
> /*  330 */     openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, double alpha, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, double beta, DoubleBuffer C, int ldc) {
> /*  335 */     openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, double alpha, DoublePointer A, int lda, DoublePointer B, int ldb, double beta, DoublePointer C, int ldc) {
> /*  340 */     openblas.cblas_dgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, float alpha, float[] A, int lda, float[] B, int ldb, float beta, float[] C, int ldc) {
> /*  345 */     openblas.cblas_sgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void gemm(LayoutModified layout, TransposeModified transA, TransposeModified transB, int m, int n, int k, float alpha, FloatBuffer A, int lda, FloatBuffer B, int ldb, float beta, FloatBuffer C, int ldc) {
> /*  350 */     openblas.cblas_sgemm(layout.blas(), transA.blas(), transB.blas(), m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, double alpha, double[] A, int lda, double[] B, int ldb, double beta, double[] C, int ldc) {
> /*  355 */     openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, double alpha, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, double beta, DoubleBuffer C, int ldc) {
> /*  360 */     openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, double alpha, DoublePointer A, int lda, DoublePointer B, int ldb, double beta, DoublePointer C, int ldc) {
> /*  365 */     openblas.cblas_dsymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, float alpha, float[] A, int lda, float[] B, int ldb, float beta, float[] C, int ldc) {
> /*  370 */     openblas.cblas_ssymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void symm(LayoutModified layout, SideModified side, UPLOModified uplo, int m, int n, float alpha, FloatBuffer A, int lda, FloatBuffer B, int ldb, float beta, FloatBuffer C, int ldc) {
> /*  375 */     openblas.cblas_ssymm(layout.blas(), side.blas(), uplo.blas(), m, n, alpha, A, lda, B, ldb, beta, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesv(LayoutModified layout, int n, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
> /*  380 */     return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesv(LayoutModified layout, int n, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
> /*  385 */     return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesv(LayoutModified layout, int n, int nrhs, DoublePointer A, int lda, IntPointer ipiv, DoublePointer B, int ldb) {
> /*  390 */     return openblas.LAPACKE_dgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesv(LayoutModified layout, int n, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
> /*  395 */     return openblas.LAPACKE_sgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesv(LayoutModified layout, int n, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
> /*  400 */     return openblas.LAPACKE_sgesv(layout.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
> /*  405 */     return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
> /*  410 */     return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoublePointer A, int lda, IntPointer ipiv, DoublePointer B, int ldb) {
> /*  415 */     return openblas.LAPACKE_dsysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
> /*  420 */     return openblas.LAPACKE_ssysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sysv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
> /*  425 */     return openblas.LAPACKE_ssysv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int[] ipiv, double[] B, int ldb) {
> /*  430 */     return openblas.LAPACKE_dspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, IntBuffer ipiv, DoubleBuffer B, int ldb) {
> /*  435 */     return openblas.LAPACKE_dspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int[] ipiv, float[] B, int ldb) {
> /*  440 */     return openblas.LAPACKE_sspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int spsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, IntBuffer ipiv, FloatBuffer B, int ldb) {
> /*  445 */     return openblas.LAPACKE_sspsv(layout.lapack(), uplo.lapack(), n, nrhs, A, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
> /*  450 */     return openblas.LAPACKE_dposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
> /*  455 */     return openblas.LAPACKE_dposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
> /*  460 */     return openblas.LAPACKE_sposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int posv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
> /*  465 */     return openblas.LAPACKE_sposv(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, double[] B, int ldb) {
> /*  470 */     return openblas.LAPACKE_dppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, DoubleBuffer B, int ldb) {
> /*  475 */     return openblas.LAPACKE_dppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, float[] B, int ldb) {
> /*  480 */     return openblas.LAPACKE_sppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ppsv(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, FloatBuffer B, int ldb) {
> /*  485 */     return openblas.LAPACKE_sppsv(layout.lapack(), uplo.lapack(), n, nrhs, A, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
> /*  490 */     return openblas.LAPACKE_dgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
> /*  495 */     return openblas.LAPACKE_dgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
> /*  500 */     return openblas.LAPACKE_sgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbsv(LayoutModified layout, int n, int kl, int ku, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
> /*  505 */     return openblas.LAPACKE_sgbsv(layout.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
> /*  510 */     return openblas.LAPACKE_dgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
> /*  515 */     return openblas.LAPACKE_dgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
> /*  520 */     return openblas.LAPACKE_sgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gels(LayoutModified layout, TransposeModified trans, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
> /*  525 */     return openblas.LAPACKE_sgels(layout.lapack(), trans.lapack(), m, n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelsy(LayoutModified layout, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb, int[] jpvt, double rcond, int[] rank) {
> /*  530 */     return openblas.LAPACKE_dgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelsy(LayoutModified layout, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, IntBuffer jpvt, double rcond, IntBuffer rank) {
> /*  535 */     return openblas.LAPACKE_dgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelsy(LayoutModified layout, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb, int[] jpvt, float rcond, int[] rank) {
> /*  540 */     return openblas.LAPACKE_sgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelsy(LayoutModified layout, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb, IntBuffer jpvt, float rcond, IntBuffer rank) {
> /*  545 */     return openblas.LAPACKE_sgelsy(layout.lapack(), m, n, nrhs, A, lda, B, ldb, jpvt, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelss(LayoutModified layout, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb, double[] s, double rcond, int[] rank) {
> /*  550 */     return openblas.LAPACKE_dgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelss(LayoutModified layout, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer s, double rcond, IntBuffer rank) {
> /*  555 */     return openblas.LAPACKE_dgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelss(LayoutModified layout, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb, float[] s, float rcond, int[] rank) {
> /*  560 */     return openblas.LAPACKE_sgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelss(LayoutModified layout, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer s, float rcond, IntBuffer rank) {
> /*  565 */     return openblas.LAPACKE_sgelss(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelsd(LayoutModified layout, int m, int n, int nrhs, double[] A, int lda, double[] B, int ldb, double[] s, double rcond, int[] rank) {
> /*  570 */     return openblas.LAPACKE_dgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelsd(LayoutModified layout, int m, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer s, double rcond, IntBuffer rank) {
> /*  575 */     return openblas.LAPACKE_dgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelsd(LayoutModified layout, int m, int n, int nrhs, float[] A, int lda, float[] B, int ldb, float[] s, float rcond, int[] rank) {
> /*  580 */     return openblas.LAPACKE_sgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gelsd(LayoutModified layout, int m, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer s, float rcond, IntBuffer rank) {
> /*  585 */     return openblas.LAPACKE_sgelsd(layout.lapack(), m, n, nrhs, A, lda, B, ldb, s, rcond, rank);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gglse(LayoutModified layout, int m, int n, int p, double[] A, int lda, double[] B, int ldb, double[] c, double[] d, double[] x) {
> /*  590 */     return openblas.LAPACKE_dgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gglse(LayoutModified layout, int m, int n, int p, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer c, DoubleBuffer d, DoubleBuffer x) {
> /*  595 */     return openblas.LAPACKE_dgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gglse(LayoutModified layout, int m, int n, int p, float[] A, int lda, float[] B, int ldb, float[] c, float[] d, float[] x) {
> /*  600 */     return openblas.LAPACKE_sgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gglse(LayoutModified layout, int m, int n, int p, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer c, FloatBuffer d, FloatBuffer x) {
> /*  605 */     return openblas.LAPACKE_sgglse(layout.lapack(), m, n, p, A, lda, B, ldb, c, d, x);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ggglm(LayoutModified layout, int n, int m, int p, double[] A, int lda, double[] B, int ldb, double[] d, double[] x, double[] y) {
> /*  610 */     return openblas.LAPACKE_dggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ggglm(LayoutModified layout, int n, int m, int p, DoubleBuffer A, int lda, DoubleBuffer B, int ldb, DoubleBuffer d, DoubleBuffer x, DoubleBuffer y) {
> /*  615 */     return openblas.LAPACKE_dggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ggglm(LayoutModified layout, int n, int m, int p, float[] A, int lda, float[] B, int ldb, float[] d, float[] x, float[] y) {
> /*  620 */     return openblas.LAPACKE_sggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ggglm(LayoutModified layout, int n, int m, int p, FloatBuffer A, int lda, FloatBuffer B, int ldb, FloatBuffer d, FloatBuffer x, FloatBuffer y) {
> /*  625 */     return openblas.LAPACKE_sggglm(layout.lapack(), n, m, p, A, lda, B, ldb, d, x, y);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, double[] A, int lda, double[] wr, double[] wi, double[] Vl, int ldvl, double[] Vr, int ldvr) {
> /*  630 */     return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, DoubleBuffer A, int lda, DoubleBuffer wr, DoubleBuffer wi, DoubleBuffer Vl, int ldvl, DoubleBuffer Vr, int ldvr) {
> /*  635 */     return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, DoublePointer A, int lda, DoublePointer wr, DoublePointer wi, DoublePointer Vl, int ldvl, DoublePointer Vr, int ldvr) {
> /*  640 */     return openblas.LAPACKE_dgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, float[] A, int lda, float[] wr, float[] wi, float[] Vl, int ldvl, float[] Vr, int ldvr) {
> /*  645 */     return openblas.LAPACKE_sgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int geev(LayoutModified layout, EVDJobModified jobvl, EVDJobModified jobvr, int n, FloatBuffer A, int lda, FloatBuffer wr, FloatBuffer wi, FloatBuffer Vl, int ldvl, FloatBuffer Vr, int ldvr) {
> /*  650 */     return openblas.LAPACKE_sgeev(layout.lapack(), jobvl.lapack(), jobvr.lapack(), n, A, lda, wr, wi, Vl, ldvl, Vr, ldvr);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, double[] A, int lda, double[] w) {
> /*  655 */     return openblas.LAPACKE_dsyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, DoubleBuffer A, int lda, DoubleBuffer w) {
> /*  660 */     return openblas.LAPACKE_dsyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, float[] A, int lda, float[] w) {
> /*  665 */     return openblas.LAPACKE_ssyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syev(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, FloatBuffer A, int lda, FloatBuffer w) {
> /*  670 */     return openblas.LAPACKE_ssyev(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, double[] A, int lda, double[] w) {
> /*  675 */     return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, DoubleBuffer A, int lda, DoubleBuffer w) {
> /*  680 */     return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, DoublePointer A, int lda, DoublePointer w) {
> /*  685 */     return openblas.LAPACKE_dsyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, float[] A, int lda, float[] w) {
> /*  690 */     return openblas.LAPACKE_ssyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syevd(LayoutModified layout, EVDJobModified jobz, UPLOModified uplo, int n, FloatBuffer A, int lda, FloatBuffer w) {
> /*  695 */     return openblas.LAPACKE_ssyevd(layout.lapack(), jobz.lapack(), uplo.lapack(), n, A, lda, w);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, double[] A, int lda, double vl, double vu, int il, int iu, double abstol, int[] m, double[] w, double[] Z, int ldz, int[] isuppz) {
> /*  700 */     return openblas.LAPACKE_dsyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, DoubleBuffer A, int lda, double vl, double vu, int il, int iu, double abstol, IntBuffer m, DoubleBuffer w, DoubleBuffer Z, int ldz, IntBuffer isuppz) {
> /*  705 */     return openblas.LAPACKE_dsyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, float[] A, int lda, float vl, float vu, int il, int iu, float abstol, int[] m, float[] w, float[] Z, int ldz, int[] isuppz) {
> /*  710 */     return openblas.LAPACKE_ssyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int syevr(LayoutModified layout, EVDJobModified jobz, EigenRangeModified range, UPLOModified uplo, int n, FloatBuffer A, int lda, float vl, float vu, int il, int iu, float abstol, IntBuffer m, FloatBuffer w, FloatBuffer Z, int ldz, IntBuffer isuppz) {
> /*  715 */     return openblas.LAPACKE_ssyevr(layout.lapack(), jobz.lapack(), range.lapack(), uplo.lapack(), n, A, lda, vl, vu, il, iu, abstol, m, w, Z, ldz, isuppz);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, double[] A, int lda, double[] s, double[] U, int ldu, double[] VT, int ldvt, double[] superb) {
> /*  720 */     return openblas.LAPACKE_dgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, DoubleBuffer A, int lda, DoubleBuffer s, DoubleBuffer U, int ldu, DoubleBuffer VT, int ldvt, DoubleBuffer superb) {
> /*  725 */     return openblas.LAPACKE_dgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, float[] A, int lda, float[] s, float[] U, int ldu, float[] VT, int ldvt, float[] superb) {
> /*  730 */     return openblas.LAPACKE_sgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesvd(LayoutModified layout, SVDJobModified jobu, SVDJobModified jobvt, int m, int n, FloatBuffer A, int lda, FloatBuffer s, FloatBuffer U, int ldu, FloatBuffer VT, int ldvt, FloatBuffer superb) {
> /*  735 */     return openblas.LAPACKE_sgesvd(layout.lapack(), jobu.lapack(), jobvt.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt, superb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, double[] A, int lda, double[] s, double[] U, int ldu, double[] VT, int ldvt) {
> /*  740 */     return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, DoubleBuffer A, int lda, DoubleBuffer s, DoubleBuffer U, int ldu, DoubleBuffer VT, int ldvt) {
> /*  745 */     return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, DoublePointer A, int lda, DoublePointer s, DoublePointer U, int ldu, DoublePointer VT, int ldvt) {
> /*  750 */     return openblas.LAPACKE_dgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, float[] A, int lda, float[] s, float[] U, int ldu, float[] VT, int ldvt) {
> /*  755 */     return openblas.LAPACKE_sgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gesdd(LayoutModified layout, SVDJobModified jobz, int m, int n, FloatBuffer A, int lda, FloatBuffer s, FloatBuffer U, int ldu, FloatBuffer VT, int ldvt) {
> /*  760 */     return openblas.LAPACKE_sgesdd(layout.lapack(), jobz.lapack(), m, n, A, lda, s, U, ldu, VT, ldvt);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrf(LayoutModified layout, int m, int n, double[] A, int lda, int[] ipiv) {
> /*  765 */     return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrf(LayoutModified layout, int m, int n, DoubleBuffer A, int lda, IntBuffer ipiv) {
> /*  770 */     return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrf(LayoutModified layout, int m, int n, DoublePointer A, int lda, IntPointer ipiv) {
> /*  775 */     return openblas.LAPACKE_dgetrf(layout.lapack(), m, n, A, lda, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrf(LayoutModified layout, int m, int n, float[] A, int lda, int[] ipiv) {
> /*  780 */     return openblas.LAPACKE_sgetrf(layout.lapack(), m, n, A, lda, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrf(LayoutModified layout, int m, int n, FloatBuffer A, int lda, IntBuffer ipiv) {
> /*  785 */     return openblas.LAPACKE_sgetrf(layout.lapack(), m, n, A, lda, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrf2(LayoutModified layout, int m, int n, double[] A, int lda, int[] ipiv) {
> /*  790 */     return openblas.LAPACKE_dgetrf2(layout.lapack(), m, n, A, lda, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrf2(LayoutModified layout, int m, int n, DoubleBuffer A, int lda, IntBuffer ipiv) {
> /*  795 */     return openblas.LAPACKE_dgetrf2(layout.lapack(), m, n, A, lda, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrf2(LayoutModified layout, int m, int n, float[] A, int lda, int[] ipiv) {
> /*  800 */     return openblas.LAPACKE_sgetrf2(layout.lapack(), m, n, A, lda, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrf2(LayoutModified layout, int m, int n, FloatBuffer A, int lda, IntBuffer ipiv) {
> /*  805 */     return openblas.LAPACKE_sgetrf2(layout.lapack(), m, n, A, lda, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, double[] AB, int ldab, int[] ipiv) {
> /*  810 */     return openblas.LAPACKE_dgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, DoubleBuffer AB, int ldab, IntBuffer ipiv) {
> /*  815 */     return openblas.LAPACKE_dgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, float[] AB, int ldab, int[] ipiv) {
> /*  820 */     return openblas.LAPACKE_sgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbtrf(LayoutModified layout, int m, int n, int kl, int ku, FloatBuffer AB, int ldab, IntBuffer ipiv) {
> /*  825 */     return openblas.LAPACKE_sgbtrf(layout.lapack(), m, n, kl, ku, AB, ldab, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sptrf(LayoutModified layout, UPLOModified uplo, int n, double[] AP, int[] ipiv) {
> /*  830 */     return openblas.LAPACKE_dsptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sptrf(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer AP, IntBuffer ipiv) {
> /*  835 */     return openblas.LAPACKE_dsptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sptrf(LayoutModified layout, UPLOModified uplo, int n, float[] AP, int[] ipiv) {
> /*  840 */     return openblas.LAPACKE_ssptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sptrf(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer AP, IntBuffer ipiv) {
> /*  845 */     return openblas.LAPACKE_ssptrf(layout.lapack(), uplo.lapack(), n, AP, ipiv);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
> /*  850 */     return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
> /*  855 */     return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, DoublePointer A, int lda, IntPointer ipiv, DoublePointer B, int ldb) {
> /*  860 */     return openblas.LAPACKE_dgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
> /*  865 */     return openblas.LAPACKE_sgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int getrs(LayoutModified layout, TransposeModified trans, int n, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
> /*  870 */     return openblas.LAPACKE_sgetrs(layout.lapack(), trans.lapack(), n, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, double[] A, int lda, int[] ipiv, double[] B, int ldb) {
> /*  875 */     return openblas.LAPACKE_dgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, DoubleBuffer A, int lda, IntBuffer ipiv, DoubleBuffer B, int ldb) {
> /*  880 */     return openblas.LAPACKE_dgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, float[] A, int lda, int[] ipiv, float[] B, int ldb) {
> /*  885 */     return openblas.LAPACKE_sgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int gbtrs(LayoutModified layout, TransposeModified trans, int n, int kl, int ku, int nrhs, FloatBuffer A, int lda, IntBuffer ipiv, FloatBuffer B, int ldb) {
> /*  890 */     return openblas.LAPACKE_sgbtrs(layout.lapack(), trans.lapack(), n, kl, ku, nrhs, A, lda, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] AP, int[] ipiv, double[] B, int ldb) {
> /*  895 */     return openblas.LAPACKE_dsptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer AP, IntBuffer ipiv, DoubleBuffer B, int ldb) {
> /*  900 */     return openblas.LAPACKE_dsptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] AP, int[] ipiv, float[] B, int ldb) {
> /*  905 */     return openblas.LAPACKE_ssptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int sptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer AP, IntBuffer ipiv, FloatBuffer B, int ldb) {
> /*  910 */     return openblas.LAPACKE_ssptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, ipiv, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrf(LayoutModified layout, UPLOModified uplo, int n, double[] A, int lda) {
> /*  915 */     return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrf(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer A, int lda) {
> /*  920 */     return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrf(LayoutModified layout, UPLOModified uplo, int n, DoublePointer A, int lda) {
> /*  925 */     return openblas.LAPACKE_dpotrf(layout.lapack(), uplo.lapack(), n, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrf(LayoutModified layout, UPLOModified uplo, int n, float[] A, int lda) {
> /*  930 */     return openblas.LAPACKE_spotrf(layout.lapack(), uplo.lapack(), n, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrf(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer A, int lda) {
> /*  935 */     return openblas.LAPACKE_spotrf(layout.lapack(), uplo.lapack(), n, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrf2(LayoutModified layout, UPLOModified uplo, int n, double[] A, int lda) {
> /*  940 */     return openblas.LAPACKE_dpotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrf2(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer A, int lda) {
> /*  945 */     return openblas.LAPACKE_dpotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrf2(LayoutModified layout, UPLOModified uplo, int n, float[] A, int lda) {
> /*  950 */     return openblas.LAPACKE_spotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrf2(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer A, int lda) {
> /*  955 */     return openblas.LAPACKE_spotrf2(layout.lapack(), uplo.lapack(), n, A, lda);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, double[] AB, int ldab) {
> /*  960 */     return openblas.LAPACKE_dpbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, DoubleBuffer AB, int ldab) {
> /*  965 */     return openblas.LAPACKE_dpbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, float[] AB, int ldab) {
> /*  970 */     return openblas.LAPACKE_spbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pbtrf(LayoutModified layout, UPLOModified uplo, int n, int kd, FloatBuffer AB, int ldab) {
> /*  975 */     return openblas.LAPACKE_spbtrf(layout.lapack(), uplo.lapack(), n, kd, AB, ldab);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pptrf(LayoutModified layout, UPLOModified uplo, int n, double[] AP) {
> /*  980 */     return openblas.LAPACKE_dpptrf(layout.lapack(), uplo.lapack(), n, AP);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pptrf(LayoutModified layout, UPLOModified uplo, int n, DoubleBuffer AP) {
> /*  985 */     return openblas.LAPACKE_dpptrf(layout.lapack(), uplo.lapack(), n, AP);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pptrf(LayoutModified layout, UPLOModified uplo, int n, float[] AP) {
> /*  990 */     return openblas.LAPACKE_spptrf(layout.lapack(), uplo.lapack(), n, AP);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pptrf(LayoutModified layout, UPLOModified uplo, int n, FloatBuffer AP) {
> /*  995 */     return openblas.LAPACKE_spptrf(layout.lapack(), uplo.lapack(), n, AP);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
> /* 1000 */     return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
> /* 1005 */     return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoublePointer A, int lda, DoublePointer B, int ldb) {
> /* 1010 */     return openblas.LAPACKE_dpotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
> /* 1015 */     return openblas.LAPACKE_spotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int potrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
> /* 1020 */     return openblas.LAPACKE_spotrs(layout.lapack(), uplo.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, double[] AB, int ldab, double[] B, int ldb) {
> /* 1025 */     return openblas.LAPACKE_dpbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, DoubleBuffer AB, int ldab, DoubleBuffer B, int ldb) {
> /* 1030 */     return openblas.LAPACKE_dpbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, float[] AB, int ldab, float[] B, int ldb) {
> /* 1035 */     return openblas.LAPACKE_spbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pbtrs(LayoutModified layout, UPLOModified uplo, int n, int kd, int nrhs, FloatBuffer AB, int ldab, FloatBuffer B, int ldb) {
> /* 1040 */     return openblas.LAPACKE_spbtrs(layout.lapack(), uplo.lapack(), n, kd, nrhs, AB, ldab, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, double[] AP, double[] B, int ldb) {
> /* 1045 */     return openblas.LAPACKE_dpptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, DoubleBuffer AP, DoubleBuffer B, int ldb) {
> /* 1050 */     return openblas.LAPACKE_dpptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, float[] AP, float[] B, int ldb) {
> /* 1055 */     return openblas.LAPACKE_spptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int pptrs(LayoutModified layout, UPLOModified uplo, int n, int nrhs, FloatBuffer AP, FloatBuffer B, int ldb) {
> /* 1060 */     return openblas.LAPACKE_spptrs(layout.lapack(), uplo.lapack(), n, nrhs, AP, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int geqrf(LayoutModified layout, int m, int n, double[] A, int lda, double[] tau) {
> /* 1065 */     return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int geqrf(LayoutModified layout, int m, int n, DoubleBuffer A, int lda, DoubleBuffer tau) {
> /* 1070 */     return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int geqrf(LayoutModified layout, int m, int n, DoublePointer A, int lda, DoublePointer tau) {
> /* 1075 */     return openblas.LAPACKE_dgeqrf(layout.lapack(), m, n, A, lda, tau);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int geqrf(LayoutModified layout, int m, int n, float[] A, int lda, float[] tau) {
> /* 1080 */     return openblas.LAPACKE_sgeqrf(layout.lapack(), m, n, A, lda, tau);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int geqrf(LayoutModified layout, int m, int n, FloatBuffer A, int lda, FloatBuffer tau) {
> /* 1085 */     return openblas.LAPACKE_sgeqrf(layout.lapack(), m, n, A, lda, tau);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int orgqr(LayoutModified layout, int m, int n, int k, double[] A, int lda, double[] tau) {
> /* 1090 */     return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int orgqr(LayoutModified layout, int m, int n, int k, DoubleBuffer A, int lda, DoubleBuffer tau) {
> /* 1095 */     return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int orgqr(LayoutModified layout, int m, int n, int k, DoublePointer A, int lda, DoublePointer tau) {
> /* 1100 */     return openblas.LAPACKE_dorgqr(layout.lapack(), m, n, k, A, lda, tau);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int orgqr(LayoutModified layout, int m, int n, int k, float[] A, int lda, float[] tau) {
> /* 1105 */     return openblas.LAPACKE_sorgqr(layout.lapack(), m, n, k, A, lda, tau);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int orgqr(LayoutModified layout, int m, int n, int k, FloatBuffer A, int lda, FloatBuffer tau) {
> /* 1110 */     return openblas.LAPACKE_sorgqr(layout.lapack(), m, n, k, A, lda, tau);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, double[] A, int lda, double[] tau, double[] C, int ldc) {
> /* 1115 */     return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, DoubleBuffer A, int lda, DoubleBuffer tau, DoubleBuffer C, int ldc) {
> /* 1120 */     return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, DoublePointer A, int lda, DoublePointer tau, DoublePointer C, int ldc) {
> /* 1125 */     return openblas.LAPACKE_dormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, float[] A, int lda, float[] tau, float[] C, int ldc) {
> /* 1130 */     return openblas.LAPACKE_sormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int ormqr(LayoutModified layout, SideModified side, TransposeModified trans, int m, int n, int k, FloatBuffer A, int lda, FloatBuffer tau, FloatBuffer C, int ldc) {
> /* 1135 */     return openblas.LAPACKE_sormqr(layout.lapack(), side.lapack(), trans.lapack(), m, n, k, A, lda, tau, C, ldc);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, double[] A, int lda, double[] B, int ldb) {
> /* 1140 */     return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, DoubleBuffer A, int lda, DoubleBuffer B, int ldb) {
> /* 1145 */     return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, DoublePointer A, int lda, DoublePointer B, int ldb) {
> /* 1150 */     return openblas.LAPACKE_dtrtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, float[] A, int lda, float[] B, int ldb) {
> /* 1155 */     return openblas.LAPACKE_strtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public int trtrs(LayoutModified layout, UPLOModified uplo, TransposeModified trans, DiagModified diag, int n, int nrhs, FloatBuffer A, int lda, FloatBuffer B, int ldb) {
> /* 1160 */     return openblas.LAPACKE_strtrs(layout.lapack(), uplo.lapack(), trans.lapack(), diag.lapack(), n, nrhs, A, lda, B, ldb);
> /*      */   }
> /*      */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/OpenBLASModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/QuickSelectModified.java jd-gui/smileModified/QuickSelectModified.java
1,291c1,382
< package smileModified;
< 
< public interface QuickSelectModified {
<    static int select(int[] x, int k) {
<       int n = x.length;
<       int l = 0;
<       int ir = n - 1;
< 
<       while(ir > l + 1) {
<          int mid = l + ir >> 1;
<          SortModified.swap(x, mid, l + 1);
<          if (x[l] > x[ir]) {
<             SortModified.swap(x, l, ir);
<          }
< 
<          if (x[l + 1] > x[ir]) {
<             SortModified.swap(x, l + 1, ir);
<          }
< 
<          if (x[l] > x[l + 1]) {
<             SortModified.swap(x, l, l + 1);
<          }
< 
<          int i = l + 1;
<          int j = ir;
<          int a = x[l + 1];
< 
<          while(true) {
<             do {
<                ++i;
<             } while(x[i] < a);
< 
<             do {
<                --j;
<             } while(x[j] > a);
< 
<             if (j < i) {
<                x[l + 1] = x[j];
<                x[j] = a;
<                if (j >= k) {
<                   ir = j - 1;
<                }
< 
<                if (j <= k) {
<                   l = i;
<                }
<                break;
<             }
< 
<             SortModified.swap(x, i, j);
<          }
<       }
< 
<       if (ir == l + 1 && x[ir] < x[l]) {
<          SortModified.swap(x, l, ir);
<       }
< 
<       return x[k];
<    }
< 
<    static float select(float[] x, int k) {
<       int n = x.length;
<       int l = 0;
<       int ir = n - 1;
< 
<       while(ir > l + 1) {
<          int mid = l + ir >> 1;
<          SortModified.swap(x, mid, l + 1);
<          if (x[l] > x[ir]) {
<             SortModified.swap(x, l, ir);
<          }
< 
<          if (x[l + 1] > x[ir]) {
<             SortModified.swap(x, l + 1, ir);
<          }
< 
<          if (x[l] > x[l + 1]) {
<             SortModified.swap(x, l, l + 1);
<          }
< 
<          int i = l + 1;
<          int j = ir;
<          float a = x[l + 1];
< 
<          while(true) {
<             do {
<                ++i;
<             } while(x[i] < a);
< 
<             do {
<                --j;
<             } while(x[j] > a);
< 
<             if (j < i) {
<                x[l + 1] = x[j];
<                x[j] = a;
<                if (j >= k) {
<                   ir = j - 1;
<                }
< 
<                if (j <= k) {
<                   l = i;
<                }
<                break;
<             }
< 
<             SortModified.swap(x, i, j);
<          }
<       }
< 
<       if (ir == l + 1 && x[ir] < x[l]) {
<          SortModified.swap(x, l, ir);
<       }
< 
<       return x[k];
<    }
< 
<    static double select(double[] x, int k) {
<       int n = x.length;
<       int l = 0;
<       int ir = n - 1;
< 
<       while(ir > l + 1) {
<          int mid = l + ir >> 1;
<          SortModified.swap(x, mid, l + 1);
<          if (x[l] > x[ir]) {
<             SortModified.swap(x, l, ir);
<          }
< 
<          if (x[l + 1] > x[ir]) {
<             SortModified.swap(x, l + 1, ir);
<          }
< 
<          if (x[l] > x[l + 1]) {
<             SortModified.swap(x, l, l + 1);
<          }
< 
<          int i = l + 1;
<          int j = ir;
<          double a = x[l + 1];
< 
<          while(true) {
<             do {
<                ++i;
<             } while(x[i] < a);
< 
<             do {
<                --j;
<             } while(x[j] > a);
< 
<             if (j < i) {
<                x[l + 1] = x[j];
<                x[j] = a;
<                if (j >= k) {
<                   ir = j - 1;
<                }
< 
<                if (j <= k) {
<                   l = i;
<                }
<                break;
<             }
< 
<             SortModified.swap(x, i, j);
<          }
<       }
< 
<       if (ir == l + 1 && x[ir] < x[l]) {
<          SortModified.swap(x, l, ir);
<       }
< 
<       return x[k];
<    }
< 
<    static <T extends Comparable<? super T>> T select(T[] x, int k) {
<       int n = x.length;
<       int l = 0;
<       int ir = n - 1;
< 
<       while(ir > l + 1) {
<          int mid = l + ir >> 1;
<          SortModified.swap((Object[])x, mid, l + 1);
<          if (x[l].compareTo(x[ir]) > 0) {
<             SortModified.swap((Object[])x, l, ir);
<          }
< 
<          if (x[l + 1].compareTo(x[ir]) > 0) {
<             SortModified.swap((Object[])x, l + 1, ir);
<          }
< 
<          if (x[l].compareTo(x[l + 1]) > 0) {
<             SortModified.swap((Object[])x, l, l + 1);
<          }
< 
<          int i = l + 1;
<          int j = ir;
<          Comparable a = x[l + 1];
< 
<          while(true) {
<             do {
<                ++i;
<             } while(x[i].compareTo(a) < 0);
< 
<             do {
<                --j;
<             } while(x[j].compareTo(a) > 0);
< 
<             if (j < i) {
<                x[l + 1] = x[j];
<                x[j] = a;
<                if (j >= k) {
<                   ir = j - 1;
<                }
< 
<                if (j <= k) {
<                   l = i;
<                }
<                break;
<             }
< 
<             SortModified.swap((Object[])x, i, j);
<          }
<       }
< 
<       if (ir == l + 1 && x[ir].compareTo(x[l]) < 0) {
<          SortModified.swap((Object[])x, l, ir);
<       }
< 
<       return x[k];
<    }
< 
<    static int median(int[] x) {
<       int k = x.length / 2;
<       return select(x, k);
<    }
< 
<    static float median(float[] x) {
<       int k = x.length / 2;
<       return select(x, k);
<    }
< 
<    static double median(double[] x) {
<       int k = x.length / 2;
<       return select(x, k);
<    }
< 
<    static <T extends Comparable<? super T>> T median(T[] x) {
<       int k = x.length / 2;
<       return select(x, k);
<    }
< 
<    static int q1(int[] x) {
<       int k = x.length / 4;
<       return select(x, k);
<    }
< 
<    static float q1(float[] x) {
<       int k = x.length / 4;
<       return select(x, k);
<    }
< 
<    static double q1(double[] x) {
<       int k = x.length / 4;
<       return select(x, k);
<    }
< 
<    static <T extends Comparable<? super T>> T q1(T[] x) {
<       int k = x.length / 4;
<       return select(x, k);
<    }
< 
<    static int q3(int[] x) {
<       int k = 3 * x.length / 4;
<       return select(x, k);
<    }
< 
<    static float q3(float[] x) {
<       int k = 3 * x.length / 4;
<       return select(x, k);
<    }
< 
<    static double q3(double[] x) {
<       int k = 3 * x.length / 4;
<       return select(x, k);
<    }
< 
<    static <T extends Comparable<? super T>> T q3(T[] x) {
<       int k = 3 * x.length / 4;
<       return select(x, k);
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public interface QuickSelectModified
> /*     */ {
> /*     */   static int select(int[] x, int k) {
> /*  16 */     int n = x.length;
> /*  17 */     int l = 0;
> /*  18 */     int ir = n - 1;
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     while (true) {
> /*  23 */       if (ir <= l + 1) {
> /*  24 */         if (ir == l + 1 && x[ir] < x[l]) {
> /*  25 */           SortModified.swap(x, l, ir);
> /*     */         }
> /*  27 */         return x[k];
> /*     */       } 
> /*  29 */       int mid = l + ir >> 1;
> /*  30 */       SortModified.swap(x, mid, l + 1);
> /*  31 */       if (x[l] > x[ir]) {
> /*  32 */         SortModified.swap(x, l, ir);
> /*     */       }
> /*  34 */       if (x[l + 1] > x[ir]) {
> /*  35 */         SortModified.swap(x, l + 1, ir);
> /*     */       }
> /*  37 */       if (x[l] > x[l + 1]) {
> /*  38 */         SortModified.swap(x, l, l + 1);
> /*     */       }
> /*  40 */       int i = l + 1;
> /*  41 */       int j = ir;
> /*  42 */       int a = x[l + 1];
> /*     */       
> /*     */       while (true) {
> /*  45 */         i++;
> /*  46 */         if (x[i] >= a) {
> /*     */           do {
> /*  48 */             j--;
> /*  49 */           } while (x[j] > a);
> /*  50 */           if (j < i) {
> /*     */             break;
> /*     */           }
> /*  53 */           SortModified.swap(x, i, j);
> /*     */         } 
> /*  55 */       }  x[l + 1] = x[j];
> /*  56 */       x[j] = a;
> /*  57 */       if (j >= k) {
> /*  58 */         ir = j - 1;
> /*     */       }
> /*  60 */       if (j <= k) {
> /*  61 */         l = i;
> /*     */       }
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static float select(float[] x, int k) {
> /*  78 */     int n = x.length;
> /*  79 */     int l = 0;
> /*  80 */     int ir = n - 1;
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     while (true) {
> /*  85 */       if (ir <= l + 1) {
> /*  86 */         if (ir == l + 1 && x[ir] < x[l]) {
> /*  87 */           SortModified.swap(x, l, ir);
> /*     */         }
> /*  89 */         return x[k];
> /*     */       } 
> /*  91 */       int mid = l + ir >> 1;
> /*  92 */       SortModified.swap(x, mid, l + 1);
> /*  93 */       if (x[l] > x[ir]) {
> /*  94 */         SortModified.swap(x, l, ir);
> /*     */       }
> /*  96 */       if (x[l + 1] > x[ir]) {
> /*  97 */         SortModified.swap(x, l + 1, ir);
> /*     */       }
> /*  99 */       if (x[l] > x[l + 1]) {
> /* 100 */         SortModified.swap(x, l, l + 1);
> /*     */       }
> /* 102 */       int i = l + 1;
> /* 103 */       int j = ir;
> /* 104 */       float a = x[l + 1];
> /*     */       
> /*     */       while (true) {
> /* 107 */         i++;
> /* 108 */         if (x[i] >= a) {
> /*     */           do {
> /* 110 */             j--;
> /* 111 */           } while (x[j] > a);
> /* 112 */           if (j < i) {
> /*     */             break;
> /*     */           }
> /* 115 */           SortModified.swap(x, i, j);
> /*     */         } 
> /* 117 */       }  x[l + 1] = x[j];
> /* 118 */       x[j] = a;
> /* 119 */       if (j >= k) {
> /* 120 */         ir = j - 1;
> /*     */       }
> /* 122 */       if (j <= k) {
> /* 123 */         l = i;
> /*     */       }
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static double select(double[] x, int k) {
> /* 140 */     int n = x.length;
> /* 141 */     int l = 0;
> /* 142 */     int ir = n - 1;
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     while (true) {
> /* 147 */       if (ir <= l + 1) {
> /* 148 */         if (ir == l + 1 && x[ir] < x[l]) {
> /* 149 */           SortModified.swap(x, l, ir);
> /*     */         }
> /* 151 */         return x[k];
> /*     */       } 
> /* 153 */       int mid = l + ir >> 1;
> /* 154 */       SortModified.swap(x, mid, l + 1);
> /* 155 */       if (x[l] > x[ir]) {
> /* 156 */         SortModified.swap(x, l, ir);
> /*     */       }
> /* 158 */       if (x[l + 1] > x[ir]) {
> /* 159 */         SortModified.swap(x, l + 1, ir);
> /*     */       }
> /* 161 */       if (x[l] > x[l + 1]) {
> /* 162 */         SortModified.swap(x, l, l + 1);
> /*     */       }
> /* 164 */       int i = l + 1;
> /* 165 */       int j = ir;
> /* 166 */       double a = x[l + 1];
> /*     */       
> /*     */       while (true) {
> /* 169 */         i++;
> /* 170 */         if (x[i] >= a) {
> /*     */           do {
> /* 172 */             j--;
> /* 173 */           } while (x[j] > a);
> /* 174 */           if (j < i) {
> /*     */             break;
> /*     */           }
> /* 177 */           SortModified.swap(x, i, j);
> /*     */         } 
> /* 179 */       }  x[l + 1] = x[j];
> /* 180 */       x[j] = a;
> /* 181 */       if (j >= k) {
> /* 182 */         ir = j - 1;
> /*     */       }
> /* 184 */       if (j <= k) {
> /* 185 */         l = i;
> /*     */       }
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static <T extends Comparable<? super T>> T select(Comparable[] x, int k) {
> /* 203 */     int n = x.length;
> /* 204 */     int l = 0;
> /* 205 */     int ir = n - 1;
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     while (true) {
> /* 210 */       if (ir <= l + 1) {
> /* 211 */         if (ir == l + 1 && x[ir].compareTo(x[l]) < 0) {
> /* 212 */           SortModified.swap((Object[])x, l, ir);
> /*     */         }
> /* 214 */         return (T)x[k];
> /*     */       } 
> /* 216 */       int mid = l + ir >> 1;
> /* 217 */       SortModified.swap((Object[])x, mid, l + 1);
> /* 218 */       if (x[l].compareTo(x[ir]) > 0) {
> /* 219 */         SortModified.swap((Object[])x, l, ir);
> /*     */       }
> /* 221 */       if (x[l + 1].compareTo(x[ir]) > 0) {
> /* 222 */         SortModified.swap((Object[])x, l + 1, ir);
> /*     */       }
> /* 224 */       if (x[l].compareTo(x[l + 1]) > 0) {
> /* 225 */         SortModified.swap((Object[])x, l, l + 1);
> /*     */       }
> /* 227 */       int i = l + 1;
> /* 228 */       int j = ir;
> /* 229 */       Comparable comparable = x[l + 1];
> /*     */       
> /*     */       while (true) {
> /* 232 */         i++;
> /* 233 */         if (x[i].compareTo(comparable) >= 0) {
> /*     */           do {
> /* 235 */             j--;
> /* 236 */           } while (x[j].compareTo(comparable) > 0);
> /* 237 */           if (j < i) {
> /*     */             break;
> /*     */           }
> /* 240 */           SortModified.swap((Object[])x, i, j);
> /*     */         } 
> /* 242 */       }  x[l + 1] = x[j];
> /* 243 */       x[j] = comparable;
> /* 244 */       if (j >= k) {
> /* 245 */         ir = j - 1;
> /*     */       }
> /* 247 */       if (j <= k) {
> /* 248 */         l = i;
> /*     */       }
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static int median(int[] x) {
> /* 260 */     int k = x.length / 2;
> /* 261 */     return select(x, k);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static float median(float[] x) {
> /* 270 */     int k = x.length / 2;
> /* 271 */     return select(x, k);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static double median(double[] x) {
> /* 280 */     int k = x.length / 2;
> /* 281 */     return select(x, k);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static <T extends Comparable<? super T>> T median(Comparable[] x) {
> /* 291 */     int k = x.length / 2;
> /* 292 */     return select((T[])x, k);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static int q1(int[] x) {
> /* 301 */     int k = x.length / 4;
> /* 302 */     return select(x, k);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static float q1(float[] x) {
> /* 311 */     int k = x.length / 4;
> /* 312 */     return select(x, k);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static double q1(double[] x) {
> /* 321 */     int k = x.length / 4;
> /* 322 */     return select(x, k);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static <T extends Comparable<? super T>> T q1(Comparable[] x) {
> /* 332 */     int k = x.length / 4;
> /* 333 */     return select((T[])x, k);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static int q3(int[] x) {
> /* 342 */     int k = 3 * x.length / 4;
> /* 343 */     return select(x, k);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static float q3(float[] x) {
> /* 352 */     int k = 3 * x.length / 4;
> /* 353 */     return select(x, k);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static double q3(double[] x) {
> /* 362 */     int k = 3 * x.length / 4;
> /* 363 */     return select(x, k);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static <T extends Comparable<? super T>> T q3(Comparable[] x) {
> /* 373 */     int k = 3 * x.length / 4;
> /* 374 */     return select((T[])x, k);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/QuickSelectModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/QuickSortModified.java jd-gui/smileModified/QuickSortModified.java
1,1211c1,1303
< package smileModified;
< 
< import java.util.Comparator;
< 
< public class QuickSortModified {
<    private static final int M = 7;
<    private static final int NSTACK = 64;
< 
<    private QuickSortModified() {
<    }
< 
<    public static int[] sort(int[] x) {
<       int[] order = new int[x.length];
< 
<       for(int i = 0; i < order.length; order[i] = i++) {
<       }
< 
<       sort(x, order);
<       return order;
<    }
< 
<    public static void sort(int[] x, int[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(int[] x, int[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          int a;
<          int b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && x[i] > a; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(int[] x, double[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(int[] x, double[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          int a;
<          double b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && x[i] > a; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(int[] x, Object[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(int[] x, Object[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          int a;
<          Object b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && x[i] > a; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static int[] sort(float[] x) {
<       int[] order = new int[x.length];
< 
<       for(int i = 0; i < order.length; order[i] = i++) {
<       }
< 
<       sort(x, order);
<       return order;
<    }
< 
<    public static void sort(float[] x, int[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(float[] x, int[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          float a;
<          int b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(float[] x, float[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(float[] x, float[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          float a;
<          float b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(float[] x, Object[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(float[] x, Object[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          float a;
<          Object b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static int[] sort(double[] x) {
<       int[] order = new int[x.length];
< 
<       for(int i = 0; i < order.length; order[i] = i++) {
<       }
< 
<       sort(x, order);
<       return order;
<    }
< 
<    public static void sort(double[] x, int[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(double[] x, int[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          double a;
<          int b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(double[] x, double[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(double[] x, double[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          double a;
<          double b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static void sort(double[] x, Object[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static void sort(double[] x, Object[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          double a;
<          Object b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l] > x[ir]) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1] > x[ir]) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l] > x[l + 1]) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i] < a);
< 
<                do {
<                   --j;
<                } while(x[j] > a);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && !(x[i] <= a); --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static <T extends Comparable<? super T>> int[] sort(T[] x) {
<       int[] order = new int[x.length];
< 
<       for(int i = 0; i < order.length; order[i] = i++) {
<       }
< 
<       sort(x, order);
<       return order;
<    }
< 
<    public static <T extends Comparable<? super T>> void sort(T[] x, int[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static <T extends Comparable<? super T>> void sort(T[] x, int[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          Comparable a;
<          int b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap((Object[])x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l].compareTo(x[ir]) > 0) {
<                SortModified.swap((Object[])x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1].compareTo(x[ir]) > 0) {
<                SortModified.swap((Object[])x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l].compareTo(x[l + 1]) > 0) {
<                SortModified.swap((Object[])x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i].compareTo(a) < 0);
< 
<                do {
<                   --j;
<                } while(x[j].compareTo(a) > 0);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap((Object[])x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && x[i].compareTo(a) > 0; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static <T> void sort(T[] x, int[] y, int n, Comparator<T> comparator) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          Object a;
<          int b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap(x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (comparator.compare(x[l], x[ir]) > 0) {
<                SortModified.swap(x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (comparator.compare(x[l + 1], x[ir]) > 0) {
<                SortModified.swap(x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (comparator.compare(x[l], x[l + 1]) > 0) {
<                SortModified.swap(x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(comparator.compare(x[i], a) < 0);
< 
<                do {
<                   --j;
<                } while(comparator.compare(x[j], a) > 0);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap(x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && comparator.compare(x[i], a) > 0; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< 
<    public static <T extends Comparable<? super T>> void sort(T[] x, Object[] y) {
<       sort(x, y, x.length);
<    }
< 
<    public static <T extends Comparable<? super T>> void sort(T[] x, Object[] y, int n) {
<       int jstack = -1;
<       int l = 0;
<       int[] istack = new int[64];
<       int ir = n - 1;
< 
<       while(true) {
<          int i;
<          int j;
<          Comparable a;
<          Object b;
<          while(ir - l >= 7) {
<             int k = l + ir >> 1;
<             SortModified.swap((Object[])x, k, l + 1);
<             SortModified.swap(y, k, l + 1);
<             if (x[l].compareTo(x[ir]) > 0) {
<                SortModified.swap((Object[])x, l, ir);
<                SortModified.swap(y, l, ir);
<             }
< 
<             if (x[l + 1].compareTo(x[ir]) > 0) {
<                SortModified.swap((Object[])x, l + 1, ir);
<                SortModified.swap(y, l + 1, ir);
<             }
< 
<             if (x[l].compareTo(x[l + 1]) > 0) {
<                SortModified.swap((Object[])x, l, l + 1);
<                SortModified.swap(y, l, l + 1);
<             }
< 
<             i = l + 1;
<             j = ir;
<             a = x[l + 1];
<             b = y[l + 1];
< 
<             while(true) {
<                do {
<                   ++i;
<                } while(x[i].compareTo(a) < 0);
< 
<                do {
<                   --j;
<                } while(x[j].compareTo(a) > 0);
< 
<                if (j < i) {
<                   x[l + 1] = x[j];
<                   x[j] = a;
<                   y[l + 1] = y[j];
<                   y[j] = b;
<                   jstack += 2;
<                   if (jstack >= 64) {
<                      throw new IllegalStateException("NSTACK too small in SortModified.");
<                   }
< 
<                   if (ir - i + 1 >= j - l) {
<                      istack[jstack] = ir;
<                      istack[jstack - 1] = i;
<                      ir = j - 1;
<                   } else {
<                      istack[jstack] = j - 1;
<                      istack[jstack - 1] = l;
<                      l = i;
<                   }
<                   break;
<                }
< 
<                SortModified.swap((Object[])x, i, j);
<                SortModified.swap(y, i, j);
<             }
<          }
< 
<          for(j = l + 1; j <= ir; ++j) {
<             a = x[j];
<             b = y[j];
< 
<             for(i = j - 1; i >= l && x[i].compareTo(a) > 0; --i) {
<                x[i + 1] = x[i];
<                y[i + 1] = y[i];
<             }
< 
<             x[i + 1] = a;
<             y[i + 1] = b;
<          }
< 
<          if (jstack < 0) {
<             return;
<          }
< 
<          ir = istack[jstack--];
<          l = istack[jstack--];
<       }
<    }
< }
---
> /*      */ package smileModified;
> /*      */ 
> /*      */ import java.util.Comparator;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ public class QuickSortModified
> /*      */ {
> /*      */   private static final int M = 7;
> /*      */   private static final int NSTACK = 64;
> /*      */   
> /*      */   public static int[] sort(int[] x) {
> /*   22 */     int[] order = new int[x.length];
> /*   23 */     for (int i = 0; i < order.length; i++) {
> /*   24 */       order[i] = i;
> /*      */     }
> /*   26 */     sort(x, order);
> /*   27 */     return order;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(int[] x, int[] y) {
> /*   37 */     sort(x, y, x.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(int[] x, int[] y, int n) {
> /*   49 */     int jstack = -1;
> /*   50 */     int l = 0;
> /*   51 */     int[] istack = new int[64];
> /*   52 */     int ir = n - 1;
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /*   56 */       while (ir - l < 7) {
> /*   57 */         for (int m = l + 1; m <= ir; m++) {
> /*   58 */           int i2 = x[m];
> /*   59 */           int i3 = y[m]; int i1;
> /*   60 */           for (i1 = m - 1; i1 >= l && 
> /*   61 */             x[i1] > i2; i1--) {
> /*      */ 
> /*      */             
> /*   64 */             x[i1 + 1] = x[i1];
> /*   65 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /*   67 */           x[i1 + 1] = i2;
> /*   68 */           y[i1 + 1] = i3;
> /*      */         } 
> /*   70 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /*   73 */           ir = istack[jstack--];
> /*   74 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /*   76 */       }  int k = l + ir >> 1;
> /*   77 */       SortModified.swap(x, k, l + 1);
> /*   78 */       SortModified.swap(y, k, l + 1);
> /*   79 */       if (x[l] > x[ir]) {
> /*   80 */         SortModified.swap(x, l, ir);
> /*   81 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /*   83 */       if (x[l + 1] > x[ir]) {
> /*   84 */         SortModified.swap(x, l + 1, ir);
> /*   85 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /*   87 */       if (x[l] > x[l + 1]) {
> /*   88 */         SortModified.swap(x, l, l + 1);
> /*   89 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /*   91 */       int i = l + 1;
> /*   92 */       int j = ir;
> /*   93 */       int a = x[l + 1];
> /*   94 */       int b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /*   97 */         i++;
> /*   98 */         if (x[i] >= a) {
> /*      */           do {
> /*  100 */             j--;
> /*  101 */           } while (x[j] > a);
> /*  102 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /*  105 */           SortModified.swap(x, i, j);
> /*  106 */           SortModified.swap(y, i, j);
> /*      */         } 
> /*  108 */       }  x[l + 1] = x[j];
> /*  109 */       x[j] = a;
> /*  110 */       y[l + 1] = y[j];
> /*  111 */       y[j] = b;
> /*  112 */       jstack += 2;
> /*      */       
> /*  114 */       if (jstack >= 64) {
> /*  115 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /*  118 */       if (ir - i + 1 >= j - l) {
> /*  119 */         istack[jstack] = ir;
> /*  120 */         istack[jstack - 1] = i;
> /*  121 */         ir = j - 1; continue;
> /*      */       } 
> /*  123 */       istack[jstack] = j - 1;
> /*  124 */       istack[jstack - 1] = l;
> /*  125 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(int[] x, double[] y) {
> /*  138 */     sort(x, y, x.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(int[] x, double[] y, int n) {
> /*  150 */     int jstack = -1;
> /*  151 */     int l = 0;
> /*  152 */     int[] istack = new int[64];
> /*  153 */     int ir = n - 1;
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /*  158 */       while (ir - l < 7) {
> /*  159 */         for (int m = l + 1; m <= ir; m++) {
> /*  160 */           int i2 = x[m];
> /*  161 */           double d = y[m]; int i1;
> /*  162 */           for (i1 = m - 1; i1 >= l && 
> /*  163 */             x[i1] > i2; i1--) {
> /*      */ 
> /*      */             
> /*  166 */             x[i1 + 1] = x[i1];
> /*  167 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /*  169 */           x[i1 + 1] = i2;
> /*  170 */           y[i1 + 1] = d;
> /*      */         } 
> /*  172 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /*  175 */           ir = istack[jstack--];
> /*  176 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /*  178 */       }  int k = l + ir >> 1;
> /*  179 */       SortModified.swap(x, k, l + 1);
> /*  180 */       SortModified.swap(y, k, l + 1);
> /*  181 */       if (x[l] > x[ir]) {
> /*  182 */         SortModified.swap(x, l, ir);
> /*  183 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /*  185 */       if (x[l + 1] > x[ir]) {
> /*  186 */         SortModified.swap(x, l + 1, ir);
> /*  187 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /*  189 */       if (x[l] > x[l + 1]) {
> /*  190 */         SortModified.swap(x, l, l + 1);
> /*  191 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /*  193 */       int i = l + 1;
> /*  194 */       int j = ir;
> /*  195 */       int a = x[l + 1];
> /*  196 */       double b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /*  199 */         i++;
> /*  200 */         if (x[i] >= a) {
> /*      */           do {
> /*  202 */             j--;
> /*  203 */           } while (x[j] > a);
> /*  204 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /*  207 */           SortModified.swap(x, i, j);
> /*  208 */           SortModified.swap(y, i, j);
> /*      */         } 
> /*  210 */       }  x[l + 1] = x[j];
> /*  211 */       x[j] = a;
> /*  212 */       y[l + 1] = y[j];
> /*  213 */       y[j] = b;
> /*  214 */       jstack += 2;
> /*      */       
> /*  216 */       if (jstack >= 64) {
> /*  217 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /*  220 */       if (ir - i + 1 >= j - l) {
> /*  221 */         istack[jstack] = ir;
> /*  222 */         istack[jstack - 1] = i;
> /*  223 */         ir = j - 1; continue;
> /*      */       } 
> /*  225 */       istack[jstack] = j - 1;
> /*  226 */       istack[jstack - 1] = l;
> /*  227 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(int[] x, Object[] y) {
> /*  240 */     sort(x, y, x.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(int[] x, Object[] y, int n) {
> /*  252 */     int jstack = -1;
> /*  253 */     int l = 0;
> /*  254 */     int[] istack = new int[64];
> /*  255 */     int ir = n - 1;
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /*  260 */       while (ir - l < 7) {
> /*  261 */         for (int m = l + 1; m <= ir; m++) {
> /*  262 */           int i2 = x[m];
> /*  263 */           Object object = y[m]; int i1;
> /*  264 */           for (i1 = m - 1; i1 >= l && 
> /*  265 */             x[i1] > i2; i1--) {
> /*      */ 
> /*      */             
> /*  268 */             x[i1 + 1] = x[i1];
> /*  269 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /*  271 */           x[i1 + 1] = i2;
> /*  272 */           y[i1 + 1] = object;
> /*      */         } 
> /*  274 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /*  277 */           ir = istack[jstack--];
> /*  278 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /*  280 */       }  int k = l + ir >> 1;
> /*  281 */       SortModified.swap(x, k, l + 1);
> /*  282 */       SortModified.swap(y, k, l + 1);
> /*  283 */       if (x[l] > x[ir]) {
> /*  284 */         SortModified.swap(x, l, ir);
> /*  285 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /*  287 */       if (x[l + 1] > x[ir]) {
> /*  288 */         SortModified.swap(x, l + 1, ir);
> /*  289 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /*  291 */       if (x[l] > x[l + 1]) {
> /*  292 */         SortModified.swap(x, l, l + 1);
> /*  293 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /*  295 */       int i = l + 1;
> /*  296 */       int j = ir;
> /*  297 */       int a = x[l + 1];
> /*  298 */       Object b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /*  301 */         i++;
> /*  302 */         if (x[i] >= a) {
> /*      */           do {
> /*  304 */             j--;
> /*  305 */           } while (x[j] > a);
> /*  306 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /*  309 */           SortModified.swap(x, i, j);
> /*  310 */           SortModified.swap(y, i, j);
> /*      */         } 
> /*  312 */       }  x[l + 1] = x[j];
> /*  313 */       x[j] = a;
> /*  314 */       y[l + 1] = y[j];
> /*  315 */       y[j] = b;
> /*  316 */       jstack += 2;
> /*      */       
> /*  318 */       if (jstack >= 64) {
> /*  319 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /*  322 */       if (ir - i + 1 >= j - l) {
> /*  323 */         istack[jstack] = ir;
> /*  324 */         istack[jstack - 1] = i;
> /*  325 */         ir = j - 1; continue;
> /*      */       } 
> /*  327 */       istack[jstack] = j - 1;
> /*  328 */       istack[jstack - 1] = l;
> /*  329 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] sort(float[] x) {
> /*  341 */     int[] order = new int[x.length];
> /*  342 */     for (int i = 0; i < order.length; i++) {
> /*  343 */       order[i] = i;
> /*      */     }
> /*  345 */     sort(x, order);
> /*  346 */     return order;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(float[] x, int[] y) {
> /*  356 */     sort(x, y, x.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(float[] x, int[] y, int n) {
> /*  368 */     int jstack = -1;
> /*  369 */     int l = 0;
> /*  370 */     int[] istack = new int[64];
> /*  371 */     int ir = n - 1;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /*  377 */       while (ir - l < 7) {
> /*  378 */         for (int m = l + 1; m <= ir; m++) {
> /*  379 */           float f = x[m];
> /*  380 */           int i2 = y[m]; int i1;
> /*  381 */           for (i1 = m - 1; i1 >= l && 
> /*  382 */             x[i1] > f; i1--) {
> /*      */ 
> /*      */             
> /*  385 */             x[i1 + 1] = x[i1];
> /*  386 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /*  388 */           x[i1 + 1] = f;
> /*  389 */           y[i1 + 1] = i2;
> /*      */         } 
> /*  391 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /*  394 */           ir = istack[jstack--];
> /*  395 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /*  397 */       }  int k = l + ir >> 1;
> /*  398 */       SortModified.swap(x, k, l + 1);
> /*  399 */       SortModified.swap(y, k, l + 1);
> /*  400 */       if (x[l] > x[ir]) {
> /*  401 */         SortModified.swap(x, l, ir);
> /*  402 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /*  404 */       if (x[l + 1] > x[ir]) {
> /*  405 */         SortModified.swap(x, l + 1, ir);
> /*  406 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /*  408 */       if (x[l] > x[l + 1]) {
> /*  409 */         SortModified.swap(x, l, l + 1);
> /*  410 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /*  412 */       int i = l + 1;
> /*  413 */       int j = ir;
> /*  414 */       float a = x[l + 1];
> /*  415 */       int b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /*  418 */         i++;
> /*  419 */         if (x[i] >= a) {
> /*      */           do {
> /*  421 */             j--;
> /*  422 */           } while (x[j] > a);
> /*  423 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /*  426 */           SortModified.swap(x, i, j);
> /*  427 */           SortModified.swap(y, i, j);
> /*      */         } 
> /*  429 */       }  x[l + 1] = x[j];
> /*  430 */       x[j] = a;
> /*  431 */       y[l + 1] = y[j];
> /*  432 */       y[j] = b;
> /*  433 */       jstack += 2;
> /*      */       
> /*  435 */       if (jstack >= 64) {
> /*  436 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /*  439 */       if (ir - i + 1 >= j - l) {
> /*  440 */         istack[jstack] = ir;
> /*  441 */         istack[jstack - 1] = i;
> /*  442 */         ir = j - 1; continue;
> /*      */       } 
> /*  444 */       istack[jstack] = j - 1;
> /*  445 */       istack[jstack - 1] = l;
> /*  446 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(float[] x, float[] y) {
> /*  459 */     sort(x, y, x.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(float[] x, float[] y, int n) {
> /*  471 */     int jstack = -1;
> /*  472 */     int l = 0;
> /*  473 */     int[] istack = new int[64];
> /*  474 */     int ir = n - 1;
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /*  479 */       while (ir - l < 7) {
> /*  480 */         for (int m = l + 1; m <= ir; m++) {
> /*  481 */           float f1 = x[m];
> /*  482 */           float f2 = y[m]; int i1;
> /*  483 */           for (i1 = m - 1; i1 >= l && 
> /*  484 */             x[i1] > f1; i1--) {
> /*      */ 
> /*      */             
> /*  487 */             x[i1 + 1] = x[i1];
> /*  488 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /*  490 */           x[i1 + 1] = f1;
> /*  491 */           y[i1 + 1] = f2;
> /*      */         } 
> /*  493 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /*  496 */           ir = istack[jstack--];
> /*  497 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /*  499 */       }  int k = l + ir >> 1;
> /*  500 */       SortModified.swap(x, k, l + 1);
> /*  501 */       SortModified.swap(y, k, l + 1);
> /*  502 */       if (x[l] > x[ir]) {
> /*  503 */         SortModified.swap(x, l, ir);
> /*  504 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /*  506 */       if (x[l + 1] > x[ir]) {
> /*  507 */         SortModified.swap(x, l + 1, ir);
> /*  508 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /*  510 */       if (x[l] > x[l + 1]) {
> /*  511 */         SortModified.swap(x, l, l + 1);
> /*  512 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /*  514 */       int i = l + 1;
> /*  515 */       int j = ir;
> /*  516 */       float a = x[l + 1];
> /*  517 */       float b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /*  520 */         i++;
> /*  521 */         if (x[i] >= a) {
> /*      */           do {
> /*  523 */             j--;
> /*  524 */           } while (x[j] > a);
> /*  525 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /*  528 */           SortModified.swap(x, i, j);
> /*  529 */           SortModified.swap(y, i, j);
> /*      */         } 
> /*  531 */       }  x[l + 1] = x[j];
> /*  532 */       x[j] = a;
> /*  533 */       y[l + 1] = y[j];
> /*  534 */       y[j] = b;
> /*  535 */       jstack += 2;
> /*      */       
> /*  537 */       if (jstack >= 64) {
> /*  538 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /*  541 */       if (ir - i + 1 >= j - l) {
> /*  542 */         istack[jstack] = ir;
> /*  543 */         istack[jstack - 1] = i;
> /*  544 */         ir = j - 1; continue;
> /*      */       } 
> /*  546 */       istack[jstack] = j - 1;
> /*  547 */       istack[jstack - 1] = l;
> /*  548 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(float[] x, Object[] y) {
> /*  561 */     sort(x, y, x.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(float[] x, Object[] y, int n) {
> /*  573 */     int jstack = -1;
> /*  574 */     int l = 0;
> /*  575 */     int[] istack = new int[64];
> /*  576 */     int ir = n - 1;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /*  582 */       while (ir - l < 7) {
> /*  583 */         for (int m = l + 1; m <= ir; m++) {
> /*  584 */           float f = x[m];
> /*  585 */           Object object = y[m]; int i1;
> /*  586 */           for (i1 = m - 1; i1 >= l && 
> /*  587 */             x[i1] > f; i1--) {
> /*      */ 
> /*      */             
> /*  590 */             x[i1 + 1] = x[i1];
> /*  591 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /*  593 */           x[i1 + 1] = f;
> /*  594 */           y[i1 + 1] = object;
> /*      */         } 
> /*  596 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /*  599 */           ir = istack[jstack--];
> /*  600 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /*  602 */       }  int k = l + ir >> 1;
> /*  603 */       SortModified.swap(x, k, l + 1);
> /*  604 */       SortModified.swap(y, k, l + 1);
> /*  605 */       if (x[l] > x[ir]) {
> /*  606 */         SortModified.swap(x, l, ir);
> /*  607 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /*  609 */       if (x[l + 1] > x[ir]) {
> /*  610 */         SortModified.swap(x, l + 1, ir);
> /*  611 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /*  613 */       if (x[l] > x[l + 1]) {
> /*  614 */         SortModified.swap(x, l, l + 1);
> /*  615 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /*  617 */       int i = l + 1;
> /*  618 */       int j = ir;
> /*  619 */       float a = x[l + 1];
> /*  620 */       Object b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /*  623 */         i++;
> /*  624 */         if (x[i] >= a) {
> /*      */           do {
> /*  626 */             j--;
> /*  627 */           } while (x[j] > a);
> /*  628 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /*  631 */           SortModified.swap(x, i, j);
> /*  632 */           SortModified.swap(y, i, j);
> /*      */         } 
> /*  634 */       }  x[l + 1] = x[j];
> /*  635 */       x[j] = a;
> /*  636 */       y[l + 1] = y[j];
> /*  637 */       y[j] = b;
> /*  638 */       jstack += 2;
> /*      */       
> /*  640 */       if (jstack >= 64) {
> /*  641 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /*  644 */       if (ir - i + 1 >= j - l) {
> /*  645 */         istack[jstack] = ir;
> /*  646 */         istack[jstack - 1] = i;
> /*  647 */         ir = j - 1; continue;
> /*      */       } 
> /*  649 */       istack[jstack] = j - 1;
> /*  650 */       istack[jstack - 1] = l;
> /*  651 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static int[] sort(double[] x) {
> /*  663 */     int[] order = new int[x.length];
> /*  664 */     for (int i = 0; i < order.length; i++) {
> /*  665 */       order[i] = i;
> /*      */     }
> /*  667 */     sort(x, order);
> /*  668 */     return order;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(double[] x, int[] y) {
> /*  678 */     sort(x, y, x.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(double[] x, int[] y, int n) {
> /*  690 */     int jstack = -1;
> /*  691 */     int l = 0;
> /*  692 */     int[] istack = new int[64];
> /*  693 */     int ir = n - 1;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /*  699 */       while (ir - l < 7) {
> /*  700 */         for (int m = l + 1; m <= ir; m++) {
> /*  701 */           double d = x[m];
> /*  702 */           int i2 = y[m]; int i1;
> /*  703 */           for (i1 = m - 1; i1 >= l && 
> /*  704 */             x[i1] > d; i1--) {
> /*      */ 
> /*      */             
> /*  707 */             x[i1 + 1] = x[i1];
> /*  708 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /*  710 */           x[i1 + 1] = d;
> /*  711 */           y[i1 + 1] = i2;
> /*      */         } 
> /*  713 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /*  716 */           ir = istack[jstack--];
> /*  717 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /*  719 */       }  int k = l + ir >> 1;
> /*  720 */       SortModified.swap(x, k, l + 1);
> /*  721 */       SortModified.swap(y, k, l + 1);
> /*  722 */       if (x[l] > x[ir]) {
> /*  723 */         SortModified.swap(x, l, ir);
> /*  724 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /*  726 */       if (x[l + 1] > x[ir]) {
> /*  727 */         SortModified.swap(x, l + 1, ir);
> /*  728 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /*  730 */       if (x[l] > x[l + 1]) {
> /*  731 */         SortModified.swap(x, l, l + 1);
> /*  732 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /*  734 */       int i = l + 1;
> /*  735 */       int j = ir;
> /*  736 */       double a = x[l + 1];
> /*  737 */       int b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /*  740 */         i++;
> /*  741 */         if (x[i] >= a) {
> /*      */           do {
> /*  743 */             j--;
> /*  744 */           } while (x[j] > a);
> /*  745 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /*  748 */           SortModified.swap(x, i, j);
> /*  749 */           SortModified.swap(y, i, j);
> /*      */         } 
> /*  751 */       }  x[l + 1] = x[j];
> /*  752 */       x[j] = a;
> /*  753 */       y[l + 1] = y[j];
> /*  754 */       y[j] = b;
> /*  755 */       jstack += 2;
> /*      */       
> /*  757 */       if (jstack >= 64) {
> /*  758 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /*  761 */       if (ir - i + 1 >= j - l) {
> /*  762 */         istack[jstack] = ir;
> /*  763 */         istack[jstack - 1] = i;
> /*  764 */         ir = j - 1; continue;
> /*      */       } 
> /*  766 */       istack[jstack] = j - 1;
> /*  767 */       istack[jstack - 1] = l;
> /*  768 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(double[] x, double[] y) {
> /*  782 */     sort(x, y, x.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(double[] x, double[] y, int n) {
> /*  794 */     int jstack = -1;
> /*  795 */     int l = 0;
> /*  796 */     int[] istack = new int[64];
> /*  797 */     int ir = n - 1;
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /*  802 */       while (ir - l < 7) {
> /*  803 */         for (int m = l + 1; m <= ir; m++) {
> /*  804 */           double d1 = x[m];
> /*  805 */           double d2 = y[m]; int i1;
> /*  806 */           for (i1 = m - 1; i1 >= l && 
> /*  807 */             x[i1] > d1; i1--) {
> /*      */ 
> /*      */             
> /*  810 */             x[i1 + 1] = x[i1];
> /*  811 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /*  813 */           x[i1 + 1] = d1;
> /*  814 */           y[i1 + 1] = d2;
> /*      */         } 
> /*  816 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /*  819 */           ir = istack[jstack--];
> /*  820 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /*  822 */       }  int k = l + ir >> 1;
> /*  823 */       SortModified.swap(x, k, l + 1);
> /*  824 */       SortModified.swap(y, k, l + 1);
> /*  825 */       if (x[l] > x[ir]) {
> /*  826 */         SortModified.swap(x, l, ir);
> /*  827 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /*  829 */       if (x[l + 1] > x[ir]) {
> /*  830 */         SortModified.swap(x, l + 1, ir);
> /*  831 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /*  833 */       if (x[l] > x[l + 1]) {
> /*  834 */         SortModified.swap(x, l, l + 1);
> /*  835 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /*  837 */       int i = l + 1;
> /*  838 */       int j = ir;
> /*  839 */       double a = x[l + 1];
> /*  840 */       double b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /*  843 */         i++;
> /*  844 */         if (x[i] >= a) {
> /*      */           do {
> /*  846 */             j--;
> /*  847 */           } while (x[j] > a);
> /*  848 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /*  851 */           SortModified.swap(x, i, j);
> /*  852 */           SortModified.swap(y, i, j);
> /*      */         } 
> /*  854 */       }  x[l + 1] = x[j];
> /*  855 */       x[j] = a;
> /*  856 */       y[l + 1] = y[j];
> /*  857 */       y[j] = b;
> /*  858 */       jstack += 2;
> /*      */       
> /*  860 */       if (jstack >= 64) {
> /*  861 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /*  864 */       if (ir - i + 1 >= j - l) {
> /*  865 */         istack[jstack] = ir;
> /*  866 */         istack[jstack - 1] = i;
> /*  867 */         ir = j - 1; continue;
> /*      */       } 
> /*  869 */       istack[jstack] = j - 1;
> /*  870 */       istack[jstack - 1] = l;
> /*  871 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(double[] x, Object[] y) {
> /*  884 */     sort(x, y, x.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static void sort(double[] x, Object[] y, int n) {
> /*  896 */     int jstack = -1;
> /*  897 */     int l = 0;
> /*  898 */     int[] istack = new int[64];
> /*  899 */     int ir = n - 1;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /*  905 */       while (ir - l < 7) {
> /*  906 */         for (int m = l + 1; m <= ir; m++) {
> /*  907 */           double d = x[m];
> /*  908 */           Object object = y[m]; int i1;
> /*  909 */           for (i1 = m - 1; i1 >= l && 
> /*  910 */             x[i1] > d; i1--) {
> /*      */ 
> /*      */             
> /*  913 */             x[i1 + 1] = x[i1];
> /*  914 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /*  916 */           x[i1 + 1] = d;
> /*  917 */           y[i1 + 1] = object;
> /*      */         } 
> /*  919 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /*  922 */           ir = istack[jstack--];
> /*  923 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /*  925 */       }  int k = l + ir >> 1;
> /*  926 */       SortModified.swap(x, k, l + 1);
> /*  927 */       SortModified.swap(y, k, l + 1);
> /*  928 */       if (x[l] > x[ir]) {
> /*  929 */         SortModified.swap(x, l, ir);
> /*  930 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /*  932 */       if (x[l + 1] > x[ir]) {
> /*  933 */         SortModified.swap(x, l + 1, ir);
> /*  934 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /*  936 */       if (x[l] > x[l + 1]) {
> /*  937 */         SortModified.swap(x, l, l + 1);
> /*  938 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /*  940 */       int i = l + 1;
> /*  941 */       int j = ir;
> /*  942 */       double a = x[l + 1];
> /*  943 */       Object b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /*  946 */         i++;
> /*  947 */         if (x[i] >= a) {
> /*      */           do {
> /*  949 */             j--;
> /*  950 */           } while (x[j] > a);
> /*  951 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /*  954 */           SortModified.swap(x, i, j);
> /*  955 */           SortModified.swap(y, i, j);
> /*      */         } 
> /*  957 */       }  x[l + 1] = x[j];
> /*  958 */       x[j] = a;
> /*  959 */       y[l + 1] = y[j];
> /*  960 */       y[j] = b;
> /*  961 */       jstack += 2;
> /*      */       
> /*  963 */       if (jstack >= 64) {
> /*  964 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /*  967 */       if (ir - i + 1 >= j - l) {
> /*  968 */         istack[jstack] = ir;
> /*  969 */         istack[jstack - 1] = i;
> /*  970 */         ir = j - 1; continue;
> /*      */       } 
> /*  972 */       istack[jstack] = j - 1;
> /*  973 */       istack[jstack - 1] = l;
> /*  974 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <T extends Comparable<? super T>> int[] sort(Comparable[] x) {
> /*  987 */     int[] order = new int[x.length];
> /*  988 */     for (int i = 0; i < order.length; i++) {
> /*  989 */       order[i] = i;
> /*      */     }
> /*  991 */     sort(x, order);
> /*  992 */     return order;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <T extends Comparable<? super T>> void sort(Comparable[] x, int[] y) {
> /* 1003 */     sort(x, y, x.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <T extends Comparable<? super T>> void sort(Comparable[] x, int[] y, int n) {
> /* 1016 */     int jstack = -1;
> /* 1017 */     int l = 0;
> /* 1018 */     int[] istack = new int[64];
> /* 1019 */     int ir = n - 1;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /* 1025 */       while (ir - l < 7) {
> /* 1026 */         for (int m = l + 1; m <= ir; m++) {
> /* 1027 */           Comparable comparable1 = x[m];
> /* 1028 */           int i2 = y[m]; int i1;
> /* 1029 */           for (i1 = m - 1; i1 >= l && 
> /* 1030 */             x[i1].compareTo(comparable1) > 0; i1--) {
> /*      */ 
> /*      */             
> /* 1033 */             x[i1 + 1] = x[i1];
> /* 1034 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /* 1036 */           x[i1 + 1] = comparable1;
> /* 1037 */           y[i1 + 1] = i2;
> /*      */         } 
> /* 1039 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /* 1042 */           ir = istack[jstack--];
> /* 1043 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /* 1045 */       }  int k = l + ir >> 1;
> /* 1046 */       SortModified.swap((Object[])x, k, l + 1);
> /* 1047 */       SortModified.swap(y, k, l + 1);
> /* 1048 */       if (x[l].compareTo(x[ir]) > 0) {
> /* 1049 */         SortModified.swap((Object[])x, l, ir);
> /* 1050 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /* 1052 */       if (x[l + 1].compareTo(x[ir]) > 0) {
> /* 1053 */         SortModified.swap((Object[])x, l + 1, ir);
> /* 1054 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /* 1056 */       if (x[l].compareTo(x[l + 1]) > 0) {
> /* 1057 */         SortModified.swap((Object[])x, l, l + 1);
> /* 1058 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /* 1060 */       int i = l + 1;
> /* 1061 */       int j = ir;
> /* 1062 */       Comparable comparable = x[l + 1];
> /* 1063 */       int b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /* 1066 */         i++;
> /* 1067 */         if (x[i].compareTo(comparable) >= 0) {
> /*      */           do {
> /* 1069 */             j--;
> /* 1070 */           } while (x[j].compareTo(comparable) > 0);
> /* 1071 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /* 1074 */           SortModified.swap((Object[])x, i, j);
> /* 1075 */           SortModified.swap(y, i, j);
> /*      */         } 
> /* 1077 */       }  x[l + 1] = x[j];
> /* 1078 */       x[j] = comparable;
> /* 1079 */       y[l + 1] = y[j];
> /* 1080 */       y[j] = b;
> /* 1081 */       jstack += 2;
> /*      */       
> /* 1083 */       if (jstack >= 64) {
> /* 1084 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /* 1087 */       if (ir - i + 1 >= j - l) {
> /* 1088 */         istack[jstack] = ir;
> /* 1089 */         istack[jstack - 1] = i;
> /* 1090 */         ir = j - 1; continue;
> /*      */       } 
> /* 1092 */       istack[jstack] = j - 1;
> /* 1093 */       istack[jstack - 1] = l;
> /* 1094 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <T> void sort(Object[] x, int[] y, int n, Comparator<T> comparator) {
> /* 1111 */     int jstack = -1;
> /* 1112 */     int l = 0;
> /* 1113 */     int[] istack = new int[64];
> /* 1114 */     int ir = n - 1;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /* 1120 */       while (ir - l < 7) {
> /* 1121 */         for (int m = l + 1; m <= ir; m++) {
> /* 1122 */           T t = (T)x[m];
> /* 1123 */           int i2 = y[m]; int i1;
> /* 1124 */           for (i1 = m - 1; i1 >= l && 
> /* 1125 */             comparator.compare((T)x[i1], t) > 0; i1--) {
> /*      */ 
> /*      */             
> /* 1128 */             x[i1 + 1] = x[i1];
> /* 1129 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /* 1131 */           x[i1 + 1] = t;
> /* 1132 */           y[i1 + 1] = i2;
> /*      */         } 
> /* 1134 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /* 1137 */           ir = istack[jstack--];
> /* 1138 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /* 1140 */       }  int k = l + ir >> 1;
> /* 1141 */       SortModified.swap(x, k, l + 1);
> /* 1142 */       SortModified.swap(y, k, l + 1);
> /* 1143 */       if (comparator.compare((T)x[l], (T)x[ir]) > 0) {
> /* 1144 */         SortModified.swap(x, l, ir);
> /* 1145 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /* 1147 */       if (comparator.compare((T)x[l + 1], (T)x[ir]) > 0) {
> /* 1148 */         SortModified.swap(x, l + 1, ir);
> /* 1149 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /* 1151 */       if (comparator.compare((T)x[l], (T)x[l + 1]) > 0) {
> /* 1152 */         SortModified.swap(x, l, l + 1);
> /* 1153 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /* 1155 */       int i = l + 1;
> /* 1156 */       int j = ir;
> /* 1157 */       T a = (T)x[l + 1];
> /* 1158 */       int b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /* 1161 */         i++;
> /* 1162 */         if (comparator.compare((T)x[i], a) >= 0) {
> /*      */           do {
> /* 1164 */             j--;
> /* 1165 */           } while (comparator.compare((T)x[j], a) > 0);
> /* 1166 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /* 1169 */           SortModified.swap(x, i, j);
> /* 1170 */           SortModified.swap(y, i, j);
> /*      */         } 
> /* 1172 */       }  x[l + 1] = x[j];
> /* 1173 */       x[j] = a;
> /* 1174 */       y[l + 1] = y[j];
> /* 1175 */       y[j] = b;
> /* 1176 */       jstack += 2;
> /*      */       
> /* 1178 */       if (jstack >= 64) {
> /* 1179 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /* 1182 */       if (ir - i + 1 >= j - l) {
> /* 1183 */         istack[jstack] = ir;
> /* 1184 */         istack[jstack - 1] = i;
> /* 1185 */         ir = j - 1; continue;
> /*      */       } 
> /* 1187 */       istack[jstack] = j - 1;
> /* 1188 */       istack[jstack - 1] = l;
> /* 1189 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <T extends Comparable<? super T>> void sort(Comparable[] x, Object[] y) {
> /* 1203 */     sort(x, y, x.length);
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static <T extends Comparable<? super T>> void sort(Comparable[] x, Object[] y, int n) {
> /* 1216 */     int jstack = -1;
> /* 1217 */     int l = 0;
> /* 1218 */     int[] istack = new int[64];
> /* 1219 */     int ir = n - 1;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     while (true) {
> /* 1225 */       while (ir - l < 7) {
> /* 1226 */         for (int m = l + 1; m <= ir; m++) {
> /* 1227 */           Comparable comparable1 = x[m];
> /* 1228 */           Object object = y[m]; int i1;
> /* 1229 */           for (i1 = m - 1; i1 >= l && 
> /* 1230 */             x[i1].compareTo(comparable1) > 0; i1--) {
> /*      */ 
> /*      */             
> /* 1233 */             x[i1 + 1] = x[i1];
> /* 1234 */             y[i1 + 1] = y[i1];
> /*      */           } 
> /* 1236 */           x[i1 + 1] = comparable1;
> /* 1237 */           y[i1 + 1] = object;
> /*      */         } 
> /* 1239 */         if (jstack >= 0) {
> /*      */ 
> /*      */           
> /* 1242 */           ir = istack[jstack--];
> /* 1243 */           l = istack[jstack--]; continue;
> /*      */         }  return;
> /* 1245 */       }  int k = l + ir >> 1;
> /* 1246 */       SortModified.swap((Object[])x, k, l + 1);
> /* 1247 */       SortModified.swap(y, k, l + 1);
> /* 1248 */       if (x[l].compareTo(x[ir]) > 0) {
> /* 1249 */         SortModified.swap((Object[])x, l, ir);
> /* 1250 */         SortModified.swap(y, l, ir);
> /*      */       } 
> /* 1252 */       if (x[l + 1].compareTo(x[ir]) > 0) {
> /* 1253 */         SortModified.swap((Object[])x, l + 1, ir);
> /* 1254 */         SortModified.swap(y, l + 1, ir);
> /*      */       } 
> /* 1256 */       if (x[l].compareTo(x[l + 1]) > 0) {
> /* 1257 */         SortModified.swap((Object[])x, l, l + 1);
> /* 1258 */         SortModified.swap(y, l, l + 1);
> /*      */       } 
> /* 1260 */       int i = l + 1;
> /* 1261 */       int j = ir;
> /* 1262 */       Comparable comparable = x[l + 1];
> /* 1263 */       Object b = y[l + 1];
> /*      */       
> /*      */       while (true) {
> /* 1266 */         i++;
> /* 1267 */         if (x[i].compareTo(comparable) >= 0) {
> /*      */           do {
> /* 1269 */             j--;
> /* 1270 */           } while (x[j].compareTo(comparable) > 0);
> /* 1271 */           if (j < i) {
> /*      */             break;
> /*      */           }
> /* 1274 */           SortModified.swap((Object[])x, i, j);
> /* 1275 */           SortModified.swap(y, i, j);
> /*      */         } 
> /* 1277 */       }  x[l + 1] = x[j];
> /* 1278 */       x[j] = comparable;
> /* 1279 */       y[l + 1] = y[j];
> /* 1280 */       y[j] = b;
> /* 1281 */       jstack += 2;
> /*      */       
> /* 1283 */       if (jstack >= 64) {
> /* 1284 */         throw new IllegalStateException("NSTACK too small in SortModified.");
> /*      */       }
> /*      */       
> /* 1287 */       if (ir - i + 1 >= j - l) {
> /* 1288 */         istack[jstack] = ir;
> /* 1289 */         istack[jstack - 1] = i;
> /* 1290 */         ir = j - 1; continue;
> /*      */       } 
> /* 1292 */       istack[jstack] = j - 1;
> /* 1293 */       istack[jstack - 1] = l;
> /* 1294 */       l = i;
> /*      */     } 
> /*      */   }
> /*      */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/QuickSortModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/RandomModified.java jd-gui/smileModified/RandomModified.java
1,96c1,188
< package smileModified;
< 
< import java.util.stream.IntStream;
< 
< public class RandomModified {
<    private final UniversalGeneratorModified real;
<    private final MersenneTwisterModified twister;
< 
<    public RandomModified() {
<       this.real = new UniversalGeneratorModified();
<       this.twister = new MersenneTwisterModified();
<    }
< 
<    public RandomModified(long seed) {
<       this.real = new UniversalGeneratorModified(seed);
<       this.twister = new MersenneTwisterModified(seed);
<    }
< 
<    public void setSeed(long seed) {
<       this.real.setSeed(seed);
<       this.twister.setSeed(seed);
<    }
< 
<    public double nextDouble() {
<       return this.real.nextDouble();
<    }
< 
<    public void nextDoubles(double[] d) {
<       this.real.nextDoubles(d);
<    }
< 
<    public double nextDouble(double lo, double hi) {
<       return lo + (hi - lo) * this.nextDouble();
<    }
< 
<    public void nextDoubles(double[] d, double lo, double hi) {
<       this.real.nextDoubles(d);
<       double l = hi - lo;
<       int n = d.length;
< 
<       for(int i = 0; i < n; ++i) {
<          d[i] = lo + l * d[i];
<       }
< 
<    }
< 
<    public int nextInt() {
<       return this.twister.nextInt();
<    }
< 
<    public int nextInt(int n) {
<       return this.twister.nextInt(n);
<    }
< 
<    public long nextLong() {
<       return this.twister.nextLong();
<    }
< 
<    public int[] permutate(int n) {
<       int[] x = IntStream.range(0, n).toArray();
<       this.permutate(x);
<       return x;
<    }
< 
<    public void permutate(int[] x) {
<       for(int i = 0; i < x.length; ++i) {
<          int j = i + this.nextInt(x.length - i);
<          MathExModified.swap(x, i, j);
<       }
< 
<    }
< 
<    public void permutate(float[] x) {
<       for(int i = 0; i < x.length; ++i) {
<          int j = i + this.nextInt(x.length - i);
<          MathExModified.swap(x, i, j);
<       }
< 
<    }
< 
<    public void permutate(double[] x) {
<       for(int i = 0; i < x.length; ++i) {
<          int j = i + this.nextInt(x.length - i);
<          MathExModified.swap(x, i, j);
<       }
< 
<    }
< 
<    public void permutate(Object[] x) {
<       for(int i = 0; i < x.length; ++i) {
<          int j = i + this.nextInt(x.length - i);
<          MathExModified.swap(x, i, j);
<       }
< 
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.util.stream.IntStream;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class RandomModified
> /*     */ {
> /*     */   private final UniversalGeneratorModified real;
> /*     */   private final MersenneTwisterModified twister;
> /*     */   
> /*     */   public RandomModified() {
> /*  38 */     this.real = new UniversalGeneratorModified();
> /*  39 */     this.twister = new MersenneTwisterModified();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public RandomModified(long seed) {
> /*  47 */     this.real = new UniversalGeneratorModified(seed);
> /*  48 */     this.twister = new MersenneTwisterModified(seed);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void setSeed(long seed) {
> /*  56 */     this.real.setSeed(seed);
> /*  57 */     this.twister.setSeed(seed);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double nextDouble() {
> /*  65 */     return this.real.nextDouble();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void nextDoubles(double[] d) {
> /*  73 */     this.real.nextDoubles(d);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double nextDouble(double lo, double hi) {
> /*  83 */     return lo + (hi - lo) * nextDouble();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void nextDoubles(double[] d, double lo, double hi) {
> /*  93 */     this.real.nextDoubles(d);
> /*     */     
> /*  95 */     double l = hi - lo;
> /*  96 */     int n = d.length;
> /*  97 */     for (int i = 0; i < n; i++) {
> /*  98 */       d[i] = lo + l * d[i];
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int nextInt() {
> /* 107 */     return this.twister.nextInt();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int nextInt(int n) {
> /* 116 */     return this.twister.nextInt(n);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public long nextLong() {
> /* 124 */     return this.twister.nextLong();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int[] permutate(int n) {
> /* 134 */     int[] x = IntStream.range(0, n).toArray();
> /* 135 */     permutate(x);
> /* 136 */     return x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void permutate(int[] x) {
> /* 144 */     for (int i = 0; i < x.length; i++) {
> /* 145 */       int j = i + nextInt(x.length - i);
> /* 146 */       MathExModified.swap(x, i, j);
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void permutate(float[] x) {
> /* 155 */     for (int i = 0; i < x.length; i++) {
> /* 156 */       int j = i + nextInt(x.length - i);
> /* 157 */       MathExModified.swap(x, i, j);
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void permutate(double[] x) {
> /* 166 */     for (int i = 0; i < x.length; i++) {
> /* 167 */       int j = i + nextInt(x.length - i);
> /* 168 */       MathExModified.swap(x, i, j);
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void permutate(Object[] x) {
> /* 177 */     for (int i = 0; i < x.length; i++) {
> /* 178 */       int j = i + nextInt(x.length - i);
> /* 179 */       MathExModified.swap(x, i, j);
> /*     */     } 
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/RandomModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/RandomNumberGeneratorModified.java jd-gui/smileModified/RandomNumberGeneratorModified.java
4,12c4,17
<    void setSeed(long var1);
< 
<    int next(int var1);
< 
<    int nextInt();
< 
<    int nextInt(int var1);
< 
<    long nextLong();
---
>   void setSeed(long paramLong);
>   
>   int next(int paramInt);
>   
>   int nextInt();
>   
>   int nextInt(int paramInt);
>   
>   long nextLong();
>   
>   double nextDouble();
>   
>   void nextDoubles(double[] paramArrayOfdouble);
> }
14d18
<    double nextDouble();
16,17c20,23
<    void nextDoubles(double[] var1);
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/RandomNumberGeneratorModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/SideModified.java jd-gui/smileModified/SideModified.java
1c1,53
< package smileModified;
---
> /*    */ package smileModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public enum SideModified
> /*    */ {
> /* 25 */   LEFT(
> /* 26 */     141, (byte)76),
> /* 27 */   RIGHT(
> /* 28 */     142, (byte)82);
> /*    */ 
> /*    */   
> /*    */   private final int blas;
> /*    */   
> /*    */   private final byte lapack;
> /*    */ 
> /*    */   
> /*    */   SideModified(int blas, byte lapack) {
> /* 37 */     this.blas = blas;
> /* 38 */     this.lapack = lapack;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public int blas() {
> /* 45 */     return this.blas;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public byte lapack() {
> /* 51 */     return this.lapack;
> /*    */   }
> /*    */ }
3,5d54
< public enum SideModified {
<    LEFT(141, (byte)76),
<    RIGHT(142, (byte)82);
7,22c56,59
<    private final int blas;
<    private final byte lapack;
< 
<    private SideModified(int blas, byte lapack) {
<       this.blas = blas;
<       this.lapack = lapack;
<    }
< 
<    public int blas() {
<       return this.blas;
<    }
< 
<    public byte lapack() {
<       return this.lapack;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/SideModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/SortModified.java jd-gui/smileModified/SortModified.java
1,135c1,245
< package smileModified;
< 
< public interface SortModified {
<    static void swap(int[] x, int i, int j) {
<       int a = x[i];
<       x[i] = x[j];
<       x[j] = a;
<    }
< 
<    static void swap(float[] x, int i, int j) {
<       float a = x[i];
<       x[i] = x[j];
<       x[j] = a;
<    }
< 
<    static void swap(double[] x, int i, int j) {
<       double a = x[i];
<       x[i] = x[j];
<       x[j] = a;
<    }
< 
<    static void swap(Object[] x, int i, int j) {
<       Object a = x[i];
<       x[i] = x[j];
<       x[j] = a;
<    }
< 
<    static void siftUp(int[] x, int k) {
<       while(k > 1 && x[k / 2] < x[k]) {
<          swap(x, k, k / 2);
<          k /= 2;
<       }
< 
<    }
< 
<    static void siftUp(float[] x, int k) {
<       while(k > 1 && x[k / 2] < x[k]) {
<          swap(x, k, k / 2);
<          k /= 2;
<       }
< 
<    }
< 
<    static void siftUp(double[] x, int k) {
<       while(k > 1 && x[k / 2] < x[k]) {
<          swap(x, k, k / 2);
<          k /= 2;
<       }
< 
<    }
< 
<    static <T extends Comparable<? super T>> void siftUp(T[] x, int k) {
<       while(k > 1 && x[k / 2].compareTo(x[k]) < 0) {
<          swap((Object[])x, k, k / 2);
<          k /= 2;
<       }
< 
<    }
< 
<    static void siftDown(int[] x, int k, int n) {
<       while(true) {
<          if (2 * k <= n) {
<             int j = 2 * k;
<             if (j < n && x[j] < x[j + 1]) {
<                ++j;
<             }
< 
<             if (x[k] < x[j]) {
<                swap(x, k, j);
<                k = j;
<                continue;
<             }
<          }
< 
<          return;
<       }
<    }
< 
<    static void siftDown(float[] x, int k, int n) {
<       while(true) {
<          if (2 * k <= n) {
<             int j = 2 * k;
<             if (j < n && x[j] < x[j + 1]) {
<                ++j;
<             }
< 
<             if (!(x[k] >= x[j])) {
<                swap(x, k, j);
<                k = j;
<                continue;
<             }
<          }
< 
<          return;
<       }
<    }
< 
<    static void siftDown(double[] x, int k, int n) {
<       while(true) {
<          if (2 * k <= n) {
<             int j = 2 * k;
<             if (j < n && x[j] < x[j + 1]) {
<                ++j;
<             }
< 
<             if (!(x[k] >= x[j])) {
<                swap(x, k, j);
<                k = j;
<                continue;
<             }
<          }
< 
<          return;
<       }
<    }
< 
<    static <T extends Comparable<? super T>> void siftDown(T[] x, int k, int n) {
<       while(true) {
<          if (2 * k <= n) {
<             int j = 2 * k;
<             if (j < n && x[j].compareTo(x[j + 1]) < 0) {
<                ++j;
<             }
< 
<             if (x[k].compareTo(x[j]) < 0) {
<                swap((Object[])x, k, j);
<                k = j;
<                continue;
<             }
<          }
< 
<          return;
<       }
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public interface SortModified
> /*     */ {
> /*     */   static void swap(int[] x, int i, int j) {
> /*  35 */     int a = x[i];
> /*  36 */     x[i] = x[j];
> /*  37 */     x[j] = a;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static void swap(float[] x, int i, int j) {
> /*  47 */     float a = x[i];
> /*  48 */     x[i] = x[j];
> /*  49 */     x[j] = a;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static void swap(double[] x, int i, int j) {
> /*  60 */     double a = x[i];
> /*  61 */     x[i] = x[j];
> /*  62 */     x[j] = a;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static void swap(Object[] x, int i, int j) {
> /*  73 */     Object a = x[i];
> /*  74 */     x[i] = x[j];
> /*  75 */     x[j] = a;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static void siftUp(int[] x, int k) {
> /*  87 */     while (k > 1 && x[k / 2] < x[k]) {
> /*  88 */       swap(x, k, k / 2);
> /*  89 */       k /= 2;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static void siftUp(float[] x, int k) {
> /* 102 */     while (k > 1 && x[k / 2] < x[k]) {
> /* 103 */       swap(x, k, k / 2);
> /* 104 */       k /= 2;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static void siftUp(double[] x, int k) {
> /* 117 */     while (k > 1 && x[k / 2] < x[k]) {
> /* 118 */       swap(x, k, k / 2);
> /* 119 */       k /= 2;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static <T extends Comparable<? super T>> void siftUp(Comparable[] x, int k) {
> /* 133 */     while (k > 1 && x[k / 2].compareTo(x[k]) < 0) {
> /* 134 */       swap((Object[])x, k, k / 2);
> /* 135 */       k /= 2;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static void siftDown(int[] x, int k, int n) {
> /* 151 */     while (2 * k <= n) {
> /* 152 */       int j = 2 * k;
> /* 153 */       if (j < n && x[j] < x[j + 1]) {
> /* 154 */         j++;
> /*     */       }
> /* 156 */       if (x[k] >= x[j]) {
> /*     */         break;
> /*     */       }
> /* 159 */       swap(x, k, j);
> /* 160 */       k = j;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static void siftDown(float[] x, int k, int n) {
> /* 176 */     while (2 * k <= n) {
> /* 177 */       int j = 2 * k;
> /* 178 */       if (j < n && x[j] < x[j + 1]) {
> /* 179 */         j++;
> /*     */       }
> /* 181 */       if (x[k] >= x[j]) {
> /*     */         break;
> /*     */       }
> /* 184 */       swap(x, k, j);
> /* 185 */       k = j;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static void siftDown(double[] x, int k, int n) {
> /* 201 */     while (2 * k <= n) {
> /* 202 */       int j = 2 * k;
> /* 203 */       if (j < n && x[j] < x[j + 1]) {
> /* 204 */         j++;
> /*     */       }
> /* 206 */       if (x[k] >= x[j]) {
> /*     */         break;
> /*     */       }
> /* 209 */       swap(x, k, j);
> /* 210 */       k = j;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static <T extends Comparable<? super T>> void siftDown(Comparable[] x, int k, int n) {
> /* 227 */     while (2 * k <= n) {
> /* 228 */       int j = 2 * k;
> /* 229 */       if (j < n && x[j].compareTo(x[j + 1]) < 0) {
> /* 230 */         j++;
> /*     */       }
> /* 232 */       if (x[k].compareTo(x[j]) >= 0) {
> /*     */         break;
> /*     */       }
> /* 235 */       swap((Object[])x, k, j);
> /* 236 */       k = j;
> /*     */     } 
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/SortModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/SparseArrayModified.java jd-gui/smileModified/SparseArrayModified.java
1,154c1,244
< package smileModified;
< 
< import java.io.Serializable;
< import java.util.Iterator;
< import java.util.List;
< import java.util.stream.Collectors;
< import java.util.stream.IntStream;
< import java.util.stream.Stream;
< 
< public class SparseArrayModified implements Iterable<SparseArrayModified.Entry>, Serializable {
<    private static final long serialVersionUID = 2L;
<    private final IntArrayListModified index;
<    private final DoubleArrayListModified value;
< 
<    public SparseArrayModified() {
<       this(10);
<    }
< 
<    public SparseArrayModified(int initialCapacity) {
<       this.index = new IntArrayListModified(initialCapacity);
<       this.value = new DoubleArrayListModified(initialCapacity);
<    }
< 
<    public SparseArrayModified(List<SparseArrayModified.Entry> entries) {
<       this.index = new IntArrayListModified(entries.size());
<       this.value = new DoubleArrayListModified(entries.size());
<       Iterator var3 = entries.iterator();
< 
<       while(var3.hasNext()) {
<          SparseArrayModified.Entry e = (SparseArrayModified.Entry)var3.next();
<          this.index.add(e.i);
<          this.value.add(e.x);
<       }
< 
<    }
< 
<    public SparseArrayModified(Stream<SparseArrayModified.Entry> stream) {
<       this((List)stream.collect(Collectors.toList()));
<    }
< 
<    public String toString() {
<       return (String)this.stream().map(SparseArrayModified.Entry::toString).collect(Collectors.joining(", ", "[", "]"));
<    }
< 
<    public int size() {
<       return this.index.size();
<    }
< 
<    public boolean isEmpty() {
<       return this.index.isEmpty();
<    }
< 
<    public Iterator<SparseArrayModified.Entry> iterator() {
<       return new Iterator<SparseArrayModified.Entry>() {
<          int i = 0;
< 
<          public boolean hasNext() {
<             return this.i < SparseArrayModified.this.size();
<          }
< 
<          public SparseArrayModified.Entry next() {
<             return SparseArrayModified.this.new Entry(this.i++, (SparseArrayModified.Entry)null);
<          }
<       };
<    }
< 
<    public Stream<SparseArrayModified.Entry> stream() {
<       return IntStream.range(0, this.size()).mapToObj((var1) -> {
<          return this.new Entry(var1, (SparseArrayModified.Entry)null);
<       });
<    }
< 
<    public void sort() {
<       QuickSortModified.sort(this.index.data, this.value.data, this.size());
<    }
< 
<    public double get(int i) {
<       int length = this.size();
< 
<       for(int k = 0; k < length; ++k) {
<          if (this.index.get(k) == i) {
<             return this.value.get(k);
<          }
<       }
< 
<       return 0.0D;
<    }
< 
<    public boolean set(int i, double x) {
<       if (x == 0.0D) {
<          this.remove(i);
<          return false;
<       } else {
<          int length = this.size();
< 
<          for(int k = 0; k < length; ++k) {
<             if (this.index.get(k) == i) {
<                this.value.set(k, x);
<                return false;
<             }
<          }
< 
<          this.index.add(i);
<          this.value.add(x);
<          return true;
<       }
<    }
< 
<    public void append(int i, double x) {
<       if (x != 0.0D) {
<          this.index.add(i);
<          this.value.add(x);
<       }
< 
<    }
< 
<    public void remove(int i) {
<       int length = this.size();
< 
<       for(int k = 0; k < length; ++k) {
<          if (this.index.get(k) == i) {
<             this.index.remove(k);
<             this.value.remove(k);
<             return;
<          }
<       }
< 
<    }
< 
<    public class Entry {
<       public final int i;
<       public final double x;
<       private final int index;
< 
<       private Entry(int index) {
<          this.i = SparseArrayModified.this.index.get(index);
<          this.x = SparseArrayModified.this.value.get(index);
<          this.index = index;
<       }
< 
<       public void update(double x) {
<          SparseArrayModified.this.value.set(this.index, x);
<       }
< 
<       public String toString() {
<          return String.format("%d:%s", this.i, StringsModified.format(this.x));
<       }
< 
<       // $FF: synthetic method
<       Entry(int var2, SparseArrayModified.Entry var3) {
<          this(var2);
<       }
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ import java.util.Iterator;
> /*     */ import java.util.List;
> /*     */ import java.util.stream.Collector;
> /*     */ import java.util.stream.Collectors;
> /*     */ import java.util.stream.IntStream;
> /*     */ import java.util.stream.Stream;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class SparseArrayModified
> /*     */   implements Iterable<SparseArrayModified.Entry>, Serializable
> /*     */ {
> /*     */   private static final long serialVersionUID = 2L;
> /*     */   private final IntArrayListModified index;
> /*     */   private final DoubleArrayListModified value;
> /*     */   
> /*     */   public class Entry
> /*     */   {
> /*     */     public final int i;
> /*     */     public final double x;
> /*     */     private final int index;
> /*     */     
> /*     */     private Entry(int index) {
> /*  63 */       this.i = SparseArrayModified.this.index.get(index);
> /*  64 */       this.x = SparseArrayModified.this.value.get(index);
> /*  65 */       this.index = index;
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public void update(double x) {
> /*  74 */       SparseArrayModified.this.value.set(this.index, x);
> /*     */     }
> /*     */ 
> /*     */     
> /*     */     public String toString() {
> /*  79 */       return String.format("%d:%s", new Object[] { Integer.valueOf(this.i), StringsModified.format(this.x) });
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SparseArrayModified() {
> /*  87 */     this(10);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SparseArrayModified(int initialCapacity) {
> /*  95 */     this.index = new IntArrayListModified(initialCapacity);
> /*  96 */     this.value = new DoubleArrayListModified(initialCapacity);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SparseArrayModified(List<Entry> entries) {
> /* 104 */     this.index = new IntArrayListModified(entries.size());
> /* 105 */     this.value = new DoubleArrayListModified(entries.size());
> /*     */     
> /* 107 */     for (Entry e : entries) {
> /* 108 */       this.index.add(e.i);
> /* 109 */       this.value.add(e.x);
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SparseArrayModified(Stream<Entry> stream) {
> /* 118 */     this(stream.collect((Collector)Collectors.toList()));
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 123 */     return stream().<CharSequence>map(Entry::toString).collect(Collectors.joining(", ", "[", "]"));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int size() {
> /* 131 */     return this.index.size();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean isEmpty() {
> /* 139 */     return this.index.isEmpty();
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public Iterator<Entry> iterator() {
> /* 144 */     return new Iterator<Entry>() {
> /* 145 */         int i = 0;
> /*     */         
> /*     */         public boolean hasNext() {
> /* 148 */           return (this.i < SparseArrayModified.this.size());
> /*     */         }
> /*     */ 
> /*     */         
> /*     */         public SparseArrayModified.Entry next() {
> /* 153 */           return new SparseArrayModified.Entry(this.i++, null);
> /*     */         }
> /*     */       };
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Stream<Entry> stream() {
> /* 163 */     return IntStream.range(0, size()).mapToObj(paramInt -> new Entry(paramInt, null));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void sort() {
> /* 170 */     QuickSortModified.sort(this.index.data, this.value.data, size());
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double get(int i) {
> /* 179 */     int length = size();
> /* 180 */     for (int k = 0; k < length; k++) {
> /* 181 */       if (this.index.get(k) == i) return this.value.get(k); 
> /*     */     } 
> /* 183 */     return 0.0D;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean set(int i, double x) {
> /* 193 */     if (x == 0.0D) {
> /* 194 */       remove(i);
> /* 195 */       return false;
> /*     */     } 
> /*     */     
> /* 198 */     int length = size();
> /* 199 */     for (int k = 0; k < length; k++) {
> /* 200 */       if (this.index.get(k) == i) {
> /* 201 */         this.value.set(k, x);
> /* 202 */         return false;
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 206 */     this.index.add(i);
> /* 207 */     this.value.add(x);
> /* 208 */     return true;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void append(int i, double x) {
> /* 218 */     if (x != 0.0D) {
> /* 219 */       this.index.add(i);
> /* 220 */       this.value.add(x);
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void remove(int i) {
> /* 229 */     int length = size();
> /* 230 */     for (int k = 0; k < length; k++) {
> /* 231 */       if (this.index.get(k) == i) {
> /* 232 */         this.index.remove(k);
> /* 233 */         this.value.remove(k);
> /*     */         return;
> /*     */       } 
> /*     */     } 
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/SparseArrayModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/SparseMatrixModified.java jd-gui/smileModified/SparseMatrixModified.java
1,656c1,778
< package smileModified;
< 
< import java.io.IOException;
< import java.io.InputStream;
< import java.nio.file.Files;
< import java.nio.file.Path;
< import java.util.Arrays;
< import java.util.Iterator;
< import java.util.Scanner;
< import java.util.Spliterator;
< import java.util.Spliterators;
< import java.util.stream.Stream;
< import java.util.stream.StreamSupport;
< import org.slf4j.Logger;
< import org.slf4j.LoggerFactory;
< 
< public class SparseMatrixModified extends IMatrixModified implements Iterable<SparseMatrixModified.Entry> {
<    private static final Logger logger = LoggerFactory.getLogger(SparseMatrixModified.class);
<    private static final long serialVersionUID = 2L;
<    private final int m;
<    private final int n;
<    private final int[] colIndex;
<    private final int[] rowIndex;
<    private final double[] nonzeros;
< 
<    private SparseMatrixModified(int m, int n, int nvals) {
<       this.m = m;
<       this.n = n;
<       this.rowIndex = new int[nvals];
<       this.colIndex = new int[n + 1];
<       this.nonzeros = new double[nvals];
<    }
< 
<    public SparseMatrixModified(int m, int n, double[] nonzeros, int[] rowIndex, int[] colIndex) {
<       this.m = m;
<       this.n = n;
<       this.rowIndex = rowIndex;
<       this.colIndex = colIndex;
<       this.nonzeros = nonzeros;
<    }
< 
<    public SparseMatrixModified(double[][] A) {
<       this(A, 100.0D * MathExModified.EPSILON);
<    }
< 
<    public SparseMatrixModified(double[][] A, double tol) {
<       this.m = A.length;
<       this.n = A[0].length;
<       int nvals = 0;
< 
<       int k;
<       int j;
<       for(k = 0; k < this.m; ++k) {
<          for(j = 0; j < this.n; ++j) {
<             if (Math.abs(A[k][j]) >= tol) {
<                ++nvals;
<             }
<          }
<       }
< 
<       this.nonzeros = new double[nvals];
<       this.rowIndex = new int[nvals];
<       this.colIndex = new int[this.n + 1];
<       this.colIndex[this.n] = nvals;
<       k = 0;
< 
<       for(j = 0; j < this.n; ++j) {
<          this.colIndex[j] = k;
< 
<          for(int i = 0; i < this.m; ++i) {
<             if (Math.abs(A[i][j]) >= tol) {
<                this.rowIndex[k] = i;
<                this.nonzeros[k] = A[i][j];
<                ++k;
<             }
<          }
<       }
< 
<    }
< 
<    public SparseMatrixModified clone() {
<       return new SparseMatrixModified(this.m, this.n, (double[])this.nonzeros.clone(), (int[])this.rowIndex.clone(), (int[])this.colIndex.clone());
<    }
< 
<    public int nrow() {
<       return this.m;
<    }
< 
<    public int ncol() {
<       return this.n;
<    }
< 
<    public long size() {
<       return (long)this.colIndex[this.n];
<    }
< 
<    public Stream<SparseMatrixModified.Entry> nonzeros() {
<       Spliterator<SparseMatrixModified.Entry> spliterator = Spliterators.spliterator(this.iterator(), this.size(), 1104);
<       return StreamSupport.stream(spliterator, false);
<    }
< 
<    public Stream<SparseMatrixModified.Entry> nonzeros(int beginColumn, int endColumn) {
<       Spliterator<SparseMatrixModified.Entry> spliterator = Spliterators.spliterator(this.iterator(beginColumn, endColumn), (long)(this.colIndex[endColumn] - this.colIndex[beginColumn]), 1104);
<       return StreamSupport.stream(spliterator, false);
<    }
< 
<    public Iterator<SparseMatrixModified.Entry> iterator() {
<       return this.iterator(0, this.n);
<    }
< 
<    public Iterator<SparseMatrixModified.Entry> iterator(int beginColumn, final int endColumn) {
<       if (beginColumn >= 0 && beginColumn < this.n) {
<          if (endColumn > beginColumn && endColumn <= this.n) {
<             return new Iterator<SparseMatrixModified.Entry>(beginColumn) {
<                int k;
<                int j;
< 
<                {
<                   this.k = SparseMatrixModified.this.colIndex[var2];
<                   this.j = var2;
<                }
< 
<                public boolean hasNext() {
<                   return this.k < SparseMatrixModified.this.colIndex[endColumn];
<                }
< 
<                public SparseMatrixModified.Entry next() {
<                   int i;
<                   for(i = SparseMatrixModified.this.rowIndex[this.k]; this.k >= SparseMatrixModified.this.colIndex[this.j + 1]; ++this.j) {
<                   }
< 
<                   return SparseMatrixModified.this.new Entry(i, this.j, this.k++, (SparseMatrixModified.Entry)null);
<                }
<             };
<          } else {
<             throw new IllegalArgumentException("Invalid end column: " + endColumn);
<          }
<       } else {
<          throw new IllegalArgumentException("Invalid begin column: " + beginColumn);
<       }
<    }
< 
<    public void forEachNonZero(DoubleConsumerModified consumer) {
<       for(int j = 0; j < this.n; ++j) {
<          for(int k = this.colIndex[j]; k < this.colIndex[j + 1]; ++k) {
<             int i = this.rowIndex[k];
<             consumer.accept(i, j, this.nonzeros[k]);
<          }
<       }
< 
<    }
< 
<    public void forEachNonZero(int beginColumn, int endColumn, DoubleConsumerModified consumer) {
<       if (beginColumn >= 0 && beginColumn < this.n) {
<          if (endColumn > beginColumn && endColumn <= this.n) {
<             for(int j = beginColumn; j < endColumn; ++j) {
<                for(int k = this.colIndex[j]; k < this.colIndex[j + 1]; ++k) {
<                   int i = this.rowIndex[k];
<                   consumer.accept(i, j, this.nonzeros[k]);
<                }
<             }
< 
<          } else {
<             throw new IllegalArgumentException("Invalid end column: " + endColumn);
<          }
<       } else {
<          throw new IllegalArgumentException("Invalid begin column: " + beginColumn);
<       }
<    }
< 
<    public double get(int index) {
<       return this.nonzeros[index];
<    }
< 
<    public void set(int index, double value) {
<       this.nonzeros[index] = value;
<    }
< 
<    public double get(int i, int j) {
<       if (i >= 0 && i < this.m && j >= 0 && j < this.n) {
<          for(int k = this.colIndex[j]; k < this.colIndex[j + 1]; ++k) {
<             if (this.rowIndex[k] == i) {
<                return this.nonzeros[k];
<             }
<          }
< 
<          return 0.0D;
<       } else {
<          throw new IllegalArgumentException("Invalid index: row = " + i + " col = " + j);
<       }
<    }
< 
<    public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
<       int k = trans == TransposeModified.NO_TRANSPOSE ? this.m : this.n;
<       double[] ax = y;
<       if (beta == 0.0D) {
<          Arrays.fill(y, 0.0D);
<       } else {
<          ax = new double[k];
<       }
< 
<       int i;
<       int i;
<       if (trans == TransposeModified.NO_TRANSPOSE) {
<          for(i = 0; i < this.n; ++i) {
<             for(i = this.colIndex[i]; i < this.colIndex[i + 1]; ++i) {
<                int var10001 = this.rowIndex[i];
<                ax[var10001] += this.nonzeros[i] * x[i];
<             }
<          }
<       } else {
<          for(i = 0; i < this.n; ++i) {
<             for(i = this.colIndex[i]; i < this.colIndex[i + 1]; ++i) {
<                ax[i] += this.nonzeros[i] * x[this.rowIndex[i]];
<             }
<          }
<       }
< 
<       if (beta != 0.0D || alpha != 1.0D) {
<          for(i = 0; i < k; ++i) {
<             y[i] = alpha * ax[i] + beta * y[i];
<          }
<       }
< 
<    }
< 
<    public void mv(double[] work, int inputOffset, int outputOffset) {
<       Arrays.fill(work, outputOffset, outputOffset + this.m, 0.0D);
< 
<       for(int j = 0; j < this.n; ++j) {
<          for(int i = this.colIndex[j]; i < this.colIndex[j + 1]; ++i) {
<             int var10001 = outputOffset + this.rowIndex[i];
<             work[var10001] += this.nonzeros[i] * work[inputOffset + j];
<          }
<       }
< 
<    }
< 
<    public void tv(double[] work, int inputOffset, int outputOffset) {
<       Arrays.fill(work, outputOffset, outputOffset + this.n, 0.0D);
< 
<       for(int i = 0; i < this.n; ++i) {
<          for(int j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
<             work[outputOffset + i] += this.nonzeros[j] * work[inputOffset + this.rowIndex[j]];
<          }
<       }
< 
<    }
< 
<    public SparseMatrixModified transpose() {
<       SparseMatrixModified trans = new SparseMatrixModified(this.n, this.m, this.nonzeros.length);
<       int[] count = new int[this.m];
< 
<       int var10002;
<       int i;
<       int j;
<       int k;
<       for(i = 0; i < this.n; ++i) {
<          for(j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
<             k = this.rowIndex[j];
<             var10002 = count[k]++;
<          }
<       }
< 
<       for(i = 0; i < this.m; ++i) {
<          trans.colIndex[i + 1] = trans.colIndex[i] + count[i];
<       }
< 
<       Arrays.fill(count, 0);
< 
<       for(i = 0; i < this.n; ++i) {
<          for(j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
<             k = this.rowIndex[j];
<             int index = trans.colIndex[k] + count[k];
<             trans.rowIndex[index] = i;
<             trans.nonzeros[index] = this.nonzeros[j];
<             var10002 = count[k]++;
<          }
<       }
< 
<       return trans;
<    }
< 
<    public SparseMatrixModified mm(SparseMatrixModified B) {
<       if (this.n != B.m) {
<          throw new IllegalArgumentException(String.format("Matrix dimensions do not match for matrix multiplication: %d x %d vs %d x %d", this.nrow(), this.ncol(), B.nrow(), B.ncol()));
<       } else {
<          int n = B.n;
<          int anz = this.colIndex[n];
<          int[] Bp = B.colIndex;
<          int[] Bi = B.rowIndex;
<          double[] Bx = B.nonzeros;
<          int bnz = Bp[n];
<          int[] w = new int[this.m];
<          double[] abj = new double[this.m];
<          int nzmax = Math.max(anz + bnz, this.m);
<          SparseMatrixModified C = new SparseMatrixModified(this.m, n, nzmax);
<          int[] Cp = C.colIndex;
<          int[] Ci = C.rowIndex;
<          double[] Cx = C.nonzeros;
<          int nz = 0;
< 
<          for(int j = 0; j < n; ++j) {
<             if (nz + this.m > nzmax) {
<                nzmax = 2 * nzmax + this.m;
<                double[] Cx2 = new double[nzmax];
<                int[] Ci2 = new int[nzmax];
<                System.arraycopy(Ci, 0, Ci2, 0, nz);
<                System.arraycopy(Cx, 0, Cx2, 0, nz);
<                Ci = Ci2;
<                Cx = Cx2;
<                C = new SparseMatrixModified(this.m, n, Cx2, Ci2, Cp);
<             }
< 
<             Cp[j] = nz;
< 
<             int p;
<             for(p = Bp[j]; p < Bp[j + 1]; ++p) {
<                nz = scatter(this, Bi[p], Bx[p], w, abj, j + 1, C, nz);
<             }
< 
<             for(p = Cp[j]; p < nz; ++p) {
<                Cx[p] = abj[Ci[p]];
<             }
<          }
< 
<          Cp[n] = nz;
<          return C;
<       }
<    }
< 
<    private static int scatter(SparseMatrixModified A, int j, double beta, int[] w, double[] x, int mark, SparseMatrixModified C, int nz) {
<       int[] Ap = A.colIndex;
<       int[] Ai = A.rowIndex;
<       double[] Ax = A.nonzeros;
<       int[] Ci = C.rowIndex;
< 
<       for(int p = Ap[j]; p < Ap[j + 1]; ++p) {
<          int i = Ai[p];
<          if (w[i] < mark) {
<             w[i] = mark;
<             Ci[nz++] = i;
<             x[i] = beta * Ax[p];
<          } else {
<             x[i] += beta * Ax[p];
<          }
<       }
< 
<       return nz;
<    }
< 
<    public SparseMatrixModified ata() {
<       SparseMatrixModified AT = this.transpose();
<       return AT.aat(this);
<    }
< 
<    public SparseMatrixModified aat() {
<       SparseMatrixModified AT = this.transpose();
<       return this.aat(AT);
<    }
< 
<    private SparseMatrixModified aat(SparseMatrixModified AT) {
<       int[] done = new int[this.m];
< 
<       int nvals;
<       for(nvals = 0; nvals < this.m; ++nvals) {
<          done[nvals] = -1;
<       }
< 
<       nvals = 0;
< 
<       int j;
<       int i;
<       int j;
<       int k;
<       for(int j = 0; j < this.m; ++j) {
<          for(j = AT.colIndex[j]; j < AT.colIndex[j + 1]; ++j) {
<             i = AT.rowIndex[j];
< 
<             for(j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
<                k = this.rowIndex[j];
<                if (done[k] != j) {
<                   done[k] = j;
<                   ++nvals;
<                }
<             }
<          }
<       }
< 
<       SparseMatrixModified aat = new SparseMatrixModified(this.m, this.m, nvals);
<       nvals = 0;
< 
<       for(j = 0; j < this.m; ++j) {
<          done[j] = -1;
<       }
< 
<       int l;
<       for(j = 0; j < this.m; ++j) {
<          aat.colIndex[j] = nvals;
< 
<          for(i = AT.colIndex[j]; i < AT.colIndex[j + 1]; ++i) {
<             j = AT.rowIndex[i];
< 
<             for(k = this.colIndex[j]; k < this.colIndex[j + 1]; ++k) {
<                l = this.rowIndex[k];
<                if (done[l] != j) {
<                   done[l] = j;
<                   aat.rowIndex[nvals] = l;
<                   ++nvals;
<                }
<             }
<          }
<       }
< 
<       aat.colIndex[this.m] = nvals;
< 
<       for(j = 0; j < this.m; ++j) {
<          if (aat.colIndex[j + 1] - aat.colIndex[j] > 1) {
<             Arrays.sort(aat.rowIndex, aat.colIndex[j], aat.colIndex[j + 1]);
<          }
<       }
< 
<       double[] temp = new double[this.m];
< 
<       for(i = 0; i < this.m; ++i) {
<          for(j = AT.colIndex[i]; j < AT.colIndex[i + 1]; ++j) {
<             k = AT.rowIndex[j];
< 
<             for(l = this.colIndex[k]; l < this.colIndex[k + 1]; ++l) {
<                int h = this.rowIndex[l];
<                temp[h] += AT.nonzeros[j] * this.nonzeros[l];
<             }
<          }
< 
<          for(j = aat.colIndex[i]; j < aat.colIndex[i + 1]; ++j) {
<             k = aat.rowIndex[j];
<             aat.nonzeros[j] = temp[k];
<             temp[k] = 0.0D;
<          }
<       }
< 
<       return aat;
<    }
< 
<    public double[] diag() {
<       int n = Math.min(this.nrow(), this.ncol());
<       double[] d = new double[n];
< 
<       for(int i = 0; i < n; ++i) {
<          for(int j = this.colIndex[i]; j < this.colIndex[i + 1]; ++j) {
<             if (this.rowIndex[j] == i) {
<                d[i] = this.nonzeros[j];
<                break;
<             }
<          }
<       }
< 
<       return d;
<    }
< 
<    public static SparseMatrixModified harwell(Path path) throws IOException {
<       logger.info("Reads sparse matrix file '{}'", path.toAbsolutePath());
<       Throwable var1 = null;
<       Object var2 = null;
< 
<       try {
<          InputStream stream = Files.newInputStream(path);
< 
<          SparseMatrixModified var10000;
<          try {
<             Scanner scanner = new Scanner(stream);
< 
<             try {
<                String line = scanner.nextLine();
<                logger.info(line);
<                line = scanner.nextLine().trim();
<                logger.info(line);
<                String[] tokens = line.split("\\s+");
<                int RHSCRD = Integer.parseInt(tokens[4]);
<                line = scanner.nextLine().trim();
<                logger.info(line);
<                if (!line.startsWith("R")) {
<                   throw new UnsupportedOperationException("SparseMatrix supports only real-valued matrix.");
<                }
< 
<                tokens = line.split("\\s+");
<                int nrow = Integer.parseInt(tokens[1]);
<                int ncol = Integer.parseInt(tokens[2]);
<                int nz = Integer.parseInt(tokens[3]);
<                line = scanner.nextLine();
<                logger.info(line);
<                if (RHSCRD > 0) {
<                   line = scanner.nextLine();
<                   logger.info(line);
<                }
< 
<                int[] colIndex = new int[ncol + 1];
<                int[] rowIndex = new int[nz];
<                double[] data = new double[nz];
< 
<                int i;
<                for(i = 0; i <= ncol; ++i) {
<                   colIndex[i] = scanner.nextInt() - 1;
<                }
< 
<                for(i = 0; i < nz; ++i) {
<                   rowIndex[i] = scanner.nextInt() - 1;
<                }
< 
<                for(i = 0; i < nz; ++i) {
<                   data[i] = scanner.nextDouble();
<                }
< 
<                var10000 = new SparseMatrixModified(nrow, ncol, data, rowIndex, colIndex);
<             } finally {
<                if (scanner != null) {
<                   scanner.close();
<                }
< 
<             }
<          } catch (Throwable var25) {
<             if (var1 == null) {
<                var1 = var25;
<             } else if (var1 != var25) {
<                var1.addSuppressed(var25);
<             }
< 
<             if (stream != null) {
<                stream.close();
<             }
< 
<             throw var1;
<          }
< 
<          if (stream != null) {
<             stream.close();
<          }
< 
<          return var10000;
<       } catch (Throwable var26) {
<          if (var1 == null) {
<             var1 = var26;
<          } else if (var1 != var26) {
<             var1.addSuppressed(var26);
<          }
< 
<          throw var1;
<       }
<    }
< 
<    public static SparseMatrixModified rutherford(Path path) throws IOException {
<       return harwell(path);
<    }
< 
<    public static SparseMatrixModified text(Path path) throws IOException {
<       Throwable var1 = null;
<       Object var2 = null;
< 
<       try {
<          InputStream stream = Files.newInputStream(path);
< 
<          SparseMatrixModified var10000;
<          try {
<             Scanner scanner = new Scanner(stream);
< 
<             try {
<                int nrow = scanner.nextInt();
<                int ncol = scanner.nextInt();
<                int nz = scanner.nextInt();
<                int[] colIndex = new int[ncol + 1];
<                int[] rowIndex = new int[nz];
<                double[] data = new double[nz];
< 
<                int i;
<                for(i = 0; i <= ncol; ++i) {
<                   colIndex[i] = scanner.nextInt() - 1;
<                }
< 
<                for(i = 0; i < nz; ++i) {
<                   rowIndex[i] = scanner.nextInt() - 1;
<                }
< 
<                i = 0;
< 
<                while(true) {
<                   if (i >= nz) {
<                      var10000 = new SparseMatrixModified(nrow, ncol, data, rowIndex, colIndex);
<                      break;
<                   }
< 
<                   data[i] = scanner.nextDouble();
<                   ++i;
<                }
<             } finally {
<                if (scanner != null) {
<                   scanner.close();
<                }
< 
<             }
<          } catch (Throwable var22) {
<             if (var1 == null) {
<                var1 = var22;
<             } else if (var1 != var22) {
<                var1.addSuppressed(var22);
<             }
< 
<             if (stream != null) {
<                stream.close();
<             }
< 
<             throw var1;
<          }
< 
<          if (stream != null) {
<             stream.close();
<          }
< 
<          return var10000;
<       } catch (Throwable var23) {
<          if (var1 == null) {
<             var1 = var23;
<          } else if (var1 != var23) {
<             var1.addSuppressed(var23);
<          }
< 
<          throw var1;
<       }
<    }
< 
<    public class Entry {
<       public final int i;
<       public final int j;
<       public final double x;
<       public final int index;
< 
<       private Entry(int i, int j, int index) {
<          this.i = i;
<          this.j = j;
<          this.x = SparseMatrixModified.this.nonzeros[index];
<          this.index = index;
<       }
< 
<       public void update(double value) {
<          SparseMatrixModified.this.nonzeros[this.index] = value;
<       }
< 
<       public String toString() {
<          return String.format("(%d, %d):%s", this.i, this.j, StringsModified.format(this.x));
<       }
< 
<       // $FF: synthetic method
<       Entry(int var2, int var3, int var4, SparseMatrixModified.Entry var5) {
<          this(var2, var3, var4);
<       }
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.io.IOException;
> /*     */ import java.nio.file.Path;
> /*     */ import java.util.Arrays;
> /*     */ import java.util.Iterator;
> /*     */ import java.util.Spliterator;
> /*     */ import java.util.Spliterators;
> /*     */ import java.util.stream.Stream;
> /*     */ import java.util.stream.StreamSupport;
> /*     */ import org.slf4j.Logger;
> /*     */ import org.slf4j.LoggerFactory;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class SparseMatrixModified
> /*     */   extends IMatrixModified
> /*     */   implements Iterable<SparseMatrixModified.Entry>
> /*     */ {
> /*  61 */   private static final Logger logger = LoggerFactory.getLogger(SparseMatrixModified.class);
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private static final long serialVersionUID = 2L;
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private final int m;
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private final int n;
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private final int[] colIndex;
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private final int[] rowIndex;
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private final double[] nonzeros;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public class Entry
> /*     */   {
> /*     */     public final int i;
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public final int j;
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public final double x;
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public final int index;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     private Entry(int i, int j, int index) {
> /* 110 */       this.i = i;
> /* 111 */       this.j = j;
> /* 112 */       this.x = SparseMatrixModified.this.nonzeros[index];
> /* 113 */       this.index = index;
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public void update(double value) {
> /* 122 */       SparseMatrixModified.this.nonzeros[this.index] = value;
> /*     */     }
> /*     */ 
> /*     */     
> /*     */     public String toString() {
> /* 127 */       return String.format("(%d, %d):%s", new Object[] { Integer.valueOf(this.i), Integer.valueOf(this.j), StringsModified.format(this.x) });
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private SparseMatrixModified(int m, int n, int nvals) {
> /* 138 */     this.m = m;
> /* 139 */     this.n = n;
> /* 140 */     this.rowIndex = new int[nvals];
> /* 141 */     this.colIndex = new int[n + 1];
> /* 142 */     this.nonzeros = new double[nvals];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SparseMatrixModified(int m, int n, double[] nonzeros, int[] rowIndex, int[] colIndex) {
> /* 154 */     this.m = m;
> /* 155 */     this.n = n;
> /* 156 */     this.rowIndex = rowIndex;
> /* 157 */     this.colIndex = colIndex;
> /* 158 */     this.nonzeros = nonzeros;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SparseMatrixModified(double[][] A) {
> /* 166 */     this(A, 100.0D * MathExModified.EPSILON);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SparseMatrixModified(double[][] A, double tol) {
> /* 175 */     this.m = A.length;
> /* 176 */     this.n = (A[0]).length;
> /*     */     
> /* 178 */     int nvals = 0;
> /* 179 */     for (int i = 0; i < this.m; i++) {
> /* 180 */       for (int m = 0; m < this.n; m++) {
> /* 181 */         if (Math.abs(A[i][m]) >= tol) {
> /* 182 */           nvals++;
> /*     */         }
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 187 */     this.nonzeros = new double[nvals];
> /* 188 */     this.rowIndex = new int[nvals];
> /* 189 */     this.colIndex = new int[this.n + 1];
> /* 190 */     this.colIndex[this.n] = nvals;
> /*     */     
> /* 192 */     int k = 0;
> /* 193 */     for (int j = 0; j < this.n; j++) {
> /* 194 */       this.colIndex[j] = k;
> /* 195 */       for (int m = 0; m < this.m; m++) {
> /* 196 */         if (Math.abs(A[m][j]) >= tol) {
> /* 197 */           this.rowIndex[k] = m;
> /* 198 */           this.nonzeros[k] = A[m][j];
> /* 199 */           k++;
> /*     */         } 
> /*     */       } 
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public SparseMatrixModified clone() {
> /* 207 */     return new SparseMatrixModified(this.m, this.n, (double[])this.nonzeros.clone(), (int[])this.rowIndex.clone(), (int[])this.colIndex.clone());
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public int nrow() {
> /* 212 */     return this.m;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public int ncol() {
> /* 217 */     return this.n;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public long size() {
> /* 222 */     return this.colIndex[this.n];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Stream<Entry> nonzeros() {
> /* 230 */     Spliterator<Entry> spliterator = Spliterators.spliterator(iterator(), size(), 1104);
> /* 231 */     return StreamSupport.stream(spliterator, false);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Stream<Entry> nonzeros(int beginColumn, int endColumn) {
> /* 242 */     Spliterator<Entry> spliterator = Spliterators.spliterator(iterator(beginColumn, endColumn), (this.colIndex[endColumn] - this.colIndex[beginColumn]), 1104);
> /* 243 */     return StreamSupport.stream(spliterator, false);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Iterator<Entry> iterator() {
> /* 252 */     return iterator(0, this.n);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Iterator<Entry> iterator(int beginColumn, final int endColumn) {
> /* 262 */     if (beginColumn < 0 || beginColumn >= this.n) {
> /* 263 */       throw new IllegalArgumentException("Invalid begin column: " + beginColumn);
> /*     */     }
> /*     */     
> /* 266 */     if (endColumn <= beginColumn || endColumn > this.n) {
> /* 267 */       throw new IllegalArgumentException("Invalid end column: " + endColumn);
> /*     */     }
> /*     */     
> /* 270 */     return new Iterator<Entry>(beginColumn)
> /*     */       {
> /*     */         int k;
> /*     */         int j;
> /*     */         
> /*     */         public boolean hasNext() {
> /* 276 */           return (this.k < SparseMatrixModified.this.colIndex[endColumn]);
> /*     */         }
> /*     */ 
> /*     */         
> /*     */         public SparseMatrixModified.Entry next() {
> /* 281 */           int i = SparseMatrixModified.this.rowIndex[this.k];
> /* 282 */           for (; this.k >= SparseMatrixModified.this.colIndex[this.j + 1]; this.j++);
> /* 283 */           return new SparseMatrixModified.Entry(i, this.j, this.k++, null);
> /*     */         }
> /*     */       };
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void forEachNonZero(DoubleConsumerModified consumer) {
> /* 299 */     for (int j = 0; j < this.n; j++) {
> /* 300 */       for (int k = this.colIndex[j]; k < this.colIndex[j + 1]; k++) {
> /* 301 */         int i = this.rowIndex[k];
> /* 302 */         consumer.accept(i, j, this.nonzeros[k]);
> /*     */       } 
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void forEachNonZero(int beginColumn, int endColumn, DoubleConsumerModified consumer) {
> /* 320 */     if (beginColumn < 0 || beginColumn >= this.n) {
> /* 321 */       throw new IllegalArgumentException("Invalid begin column: " + beginColumn);
> /*     */     }
> /*     */     
> /* 324 */     if (endColumn <= beginColumn || endColumn > this.n) {
> /* 325 */       throw new IllegalArgumentException("Invalid end column: " + endColumn);
> /*     */     }
> /*     */     
> /* 328 */     for (int j = beginColumn; j < endColumn; j++) {
> /* 329 */       for (int k = this.colIndex[j]; k < this.colIndex[j + 1]; k++) {
> /* 330 */         int i = this.rowIndex[k];
> /* 331 */         consumer.accept(i, j, this.nonzeros[k]);
> /*     */       } 
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double get(int index) {
> /* 342 */     return this.nonzeros[index];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void set(int index, double value) {
> /* 351 */     this.nonzeros[index] = value;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double get(int i, int j) {
> /* 356 */     if (i < 0 || i >= this.m || j < 0 || j >= this.n) {
> /* 357 */       throw new IllegalArgumentException("Invalid index: row = " + i + " col = " + j);
> /*     */     }
> /*     */     
> /* 360 */     for (int k = this.colIndex[j]; k < this.colIndex[j + 1]; k++) {
> /* 361 */       if (this.rowIndex[k] == i) {
> /* 362 */         return this.nonzeros[k];
> /*     */       }
> /*     */     } 
> /*     */     
> /* 366 */     return 0.0D;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
> /* 371 */     int k = (trans == TransposeModified.NO_TRANSPOSE) ? this.m : this.n;
> /* 372 */     double[] ax = y;
> /* 373 */     if (beta == 0.0D) {
> /* 374 */       Arrays.fill(y, 0.0D);
> /*     */     } else {
> /* 376 */       ax = new double[k];
> /*     */     } 
> /*     */     
> /* 379 */     if (trans == TransposeModified.NO_TRANSPOSE) {
> /* 380 */       for (int j = 0; j < this.n; j++) {
> /* 381 */         for (int i = this.colIndex[j]; i < this.colIndex[j + 1]; i++) {
> /* 382 */           ax[this.rowIndex[i]] = ax[this.rowIndex[i]] + this.nonzeros[i] * x[j];
> /*     */         }
> /*     */       } 
> /*     */     } else {
> /* 386 */       for (int i = 0; i < this.n; i++) {
> /* 387 */         for (int j = this.colIndex[i]; j < this.colIndex[i + 1]; j++) {
> /* 388 */           ax[i] = ax[i] + this.nonzeros[j] * x[this.rowIndex[j]];
> /*     */         }
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 393 */     if (beta != 0.0D || alpha != 1.0D) {
> /* 394 */       for (int i = 0; i < k; i++) {
> /* 395 */         y[i] = alpha * ax[i] + beta * y[i];
> /*     */       }
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void mv(double[] work, int inputOffset, int outputOffset) {
> /* 402 */     Arrays.fill(work, outputOffset, outputOffset + this.m, 0.0D);
> /*     */     
> /* 404 */     for (int j = 0; j < this.n; j++) {
> /* 405 */       for (int i = this.colIndex[j]; i < this.colIndex[j + 1]; i++) {
> /* 406 */         work[outputOffset + this.rowIndex[i]] = work[outputOffset + this.rowIndex[i]] + this.nonzeros[i] * work[inputOffset + j];
> /*     */       }
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void tv(double[] work, int inputOffset, int outputOffset) {
> /* 413 */     Arrays.fill(work, outputOffset, outputOffset + this.n, 0.0D);
> /*     */     
> /* 415 */     for (int i = 0; i < this.n; i++) {
> /* 416 */       for (int j = this.colIndex[i]; j < this.colIndex[i + 1]; j++) {
> /* 417 */         work[outputOffset + i] = work[outputOffset + i] + this.nonzeros[j] * work[inputOffset + this.rowIndex[j]];
> /*     */       }
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SparseMatrixModified transpose() {
> /* 427 */     SparseMatrixModified trans = new SparseMatrixModified(this.n, this.m, this.nonzeros.length);
> /*     */     
> /* 429 */     int[] count = new int[this.m];
> /* 430 */     for (int k = 0; k < this.n; k++) {
> /* 431 */       for (int m = this.colIndex[k]; m < this.colIndex[k + 1]; m++) {
> /* 432 */         int n = this.rowIndex[m];
> /* 433 */         count[n] = count[n] + 1;
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 437 */     for (int j = 0; j < this.m; j++) {
> /* 438 */       trans.colIndex[j + 1] = trans.colIndex[j] + count[j];
> /*     */     }
> /*     */     
> /* 441 */     Arrays.fill(count, 0);
> /* 442 */     for (int i = 0; i < this.n; i++) {
> /* 443 */       for (int m = this.colIndex[i]; m < this.colIndex[i + 1]; m++) {
> /* 444 */         int n = this.rowIndex[m];
> /* 445 */         int index = trans.colIndex[n] + count[n];
> /* 446 */         trans.rowIndex[index] = i;
> /* 447 */         trans.nonzeros[index] = this.nonzeros[m];
> /* 448 */         count[n] = count[n] + 1;
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 452 */     return trans;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SparseMatrixModified mm(SparseMatrixModified B) {
> /* 461 */     if (this.n != B.m) {
> /* 462 */       throw new IllegalArgumentException(String.format("Matrix dimensions do not match for matrix multiplication: %d x %d vs %d x %d", new Object[] { Integer.valueOf(nrow()), Integer.valueOf(ncol()), Integer.valueOf(B.nrow()), Integer.valueOf(B.ncol()) }));
> /*     */     }
> /*     */     
> /* 465 */     int n = B.n;
> /* 466 */     int anz = this.colIndex[n];
> /* 467 */     int[] Bp = B.colIndex;
> /* 468 */     int[] Bi = B.rowIndex;
> /* 469 */     double[] Bx = B.nonzeros;
> /* 470 */     int bnz = Bp[n];
> /*     */     
> /* 472 */     int[] w = new int[this.m];
> /* 473 */     double[] abj = new double[this.m];
> /*     */     
> /* 475 */     int nzmax = Math.max(anz + bnz, this.m);
> /*     */     
> /* 477 */     SparseMatrixModified C = new SparseMatrixModified(this.m, n, nzmax);
> /* 478 */     int[] Cp = C.colIndex;
> /* 479 */     int[] Ci = C.rowIndex;
> /* 480 */     double[] Cx = C.nonzeros;
> /*     */     
> /* 482 */     int nz = 0;
> /* 483 */     for (int j = 0; j < n; j++) {
> /* 484 */       if (nz + this.m > nzmax) {
> /* 485 */         nzmax = 2 * nzmax + this.m;
> /* 486 */         double[] Cx2 = new double[nzmax];
> /* 487 */         int[] Ci2 = new int[nzmax];
> /* 488 */         System.arraycopy(Ci, 0, Ci2, 0, nz);
> /* 489 */         System.arraycopy(Cx, 0, Cx2, 0, nz);
> /* 490 */         Ci = Ci2;
> /* 491 */         Cx = Cx2;
> /* 492 */         C = new SparseMatrixModified(this.m, n, Cx2, Ci2, Cp);
> /*     */       } 
> /*     */ 
> /*     */       
> /* 496 */       Cp[j] = nz;
> /*     */       int p;
> /* 498 */       for (p = Bp[j]; p < Bp[j + 1]; p++) {
> /* 499 */         nz = scatter(this, Bi[p], Bx[p], w, abj, j + 1, C, nz);
> /*     */       }
> /*     */       
> /* 502 */       for (p = Cp[j]; p < nz; p++) {
> /* 503 */         Cx[p] = abj[Ci[p]];
> /*     */       }
> /*     */     } 
> /*     */ 
> /*     */     
> /* 508 */     Cp[n] = nz;
> /*     */     
> /* 510 */     return C;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private static int scatter(SparseMatrixModified A, int j, double beta, int[] w, double[] x, int mark, SparseMatrixModified C, int nz) {
> /* 517 */     int[] Ap = A.colIndex;
> /* 518 */     int[] Ai = A.rowIndex;
> /* 519 */     double[] Ax = A.nonzeros;
> /*     */     
> /* 521 */     int[] Ci = C.rowIndex;
> /* 522 */     for (int p = Ap[j]; p < Ap[j + 1]; p++) {
> /* 523 */       int i = Ai[p];
> /* 524 */       if (w[i] < mark) {
> /* 525 */         w[i] = mark;
> /* 526 */         Ci[nz++] = i;
> /* 527 */         x[i] = beta * Ax[p];
> /*     */       } else {
> /* 529 */         x[i] = x[i] + beta * Ax[p];
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 533 */     return nz;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SparseMatrixModified ata() {
> /* 541 */     SparseMatrixModified AT = transpose();
> /* 542 */     return AT.aat(this);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SparseMatrixModified aat() {
> /* 550 */     SparseMatrixModified AT = transpose();
> /* 551 */     return aat(AT);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   private SparseMatrixModified aat(SparseMatrixModified AT) {
> /* 556 */     int[] done = new int[this.m];
> /* 557 */     for (int i = 0; i < this.m; i++) {
> /* 558 */       done[i] = -1;
> /*     */     }
> /*     */ 
> /*     */     
> /* 562 */     int nvals = 0;
> /*     */     
> /* 564 */     for (int j = 0; j < this.m; j++) {
> /* 565 */       for (int i1 = AT.colIndex[j]; i1 < AT.colIndex[j + 1]; i1++) {
> /* 566 */         int i2 = AT.rowIndex[i1];
> /* 567 */         for (int l = this.colIndex[i2]; l < this.colIndex[i2 + 1]; l++) {
> /* 568 */           int h = this.rowIndex[l];
> /*     */           
> /* 570 */           if (done[h] != j) {
> /* 571 */             done[h] = j;
> /* 572 */             nvals++;
> /*     */           } 
> /*     */         } 
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 578 */     SparseMatrixModified aat = new SparseMatrixModified(this.m, this.m, nvals);
> /*     */     
> /* 580 */     nvals = 0;
> /* 581 */     for (int m = 0; m < this.m; m++) {
> /* 582 */       done[m] = -1;
> /*     */     }
> /*     */     
> /*     */     int k;
> /*     */     
> /* 587 */     for (k = 0; k < this.m; k++) {
> /* 588 */       aat.colIndex[k] = nvals;
> /* 589 */       for (int i1 = AT.colIndex[k]; i1 < AT.colIndex[k + 1]; i1++) {
> /* 590 */         int i2 = AT.rowIndex[i1];
> /* 591 */         for (int l = this.colIndex[i2]; l < this.colIndex[i2 + 1]; l++) {
> /* 592 */           int h = this.rowIndex[l];
> /* 593 */           if (done[h] != k) {
> /* 594 */             done[h] = k;
> /* 595 */             aat.rowIndex[nvals] = h;
> /* 596 */             nvals++;
> /*     */           } 
> /*     */         } 
> /*     */       } 
> /*     */     } 
> /*     */ 
> /*     */     
> /* 603 */     aat.colIndex[this.m] = nvals;
> /*     */ 
> /*     */     
> /* 606 */     for (k = 0; k < this.m; k++) {
> /* 607 */       if (aat.colIndex[k + 1] - aat.colIndex[k] > 1) {
> /* 608 */         Arrays.sort(aat.rowIndex, aat.colIndex[k], aat.colIndex[k + 1]);
> /*     */       }
> /*     */     } 
> /*     */     
> /* 612 */     double[] temp = new double[this.m];
> /* 613 */     for (int n = 0; n < this.m; n++) {
> /* 614 */       int i1; for (i1 = AT.colIndex[n]; i1 < AT.colIndex[n + 1]; i1++) {
> /* 615 */         int i2 = AT.rowIndex[i1];
> /* 616 */         for (int l = this.colIndex[i2]; l < this.colIndex[i2 + 1]; l++) {
> /* 617 */           int h = this.rowIndex[l];
> /* 618 */           temp[h] = temp[h] + AT.nonzeros[i1] * this.nonzeros[l];
> /*     */         } 
> /*     */       } 
> /*     */       
> /* 622 */       for (i1 = aat.colIndex[n]; i1 < aat.colIndex[n + 1]; i1++) {
> /* 623 */         int i2 = aat.rowIndex[i1];
> /* 624 */         aat.nonzeros[i1] = temp[i2];
> /* 625 */         temp[i2] = 0.0D;
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 629 */     return aat;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double[] diag() {
> /* 634 */     int n = Math.min(nrow(), ncol());
> /* 635 */     double[] d = new double[n];
> /*     */     
> /* 637 */     for (int i = 0; i < n; i++) {
> /* 638 */       for (int j = this.colIndex[i]; j < this.colIndex[i + 1]; j++) {
> /* 639 */         if (this.rowIndex[j] == i) {
> /* 640 */           d[i] = this.nonzeros[j];
> /*     */           
> /*     */           break;
> /*     */         } 
> /*     */       } 
> /*     */     } 
> /* 646 */     return d;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static SparseMatrixModified harwell(Path path) throws IOException {
> /* 662 */     logger.info("Reads sparse matrix file '{}'", path.toAbsolutePath());
> /* 663 */     Exception exception1 = null, exception2 = null;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     try {
> /*     */     
> /*     */     } finally {
> /* 707 */       exception2 = null; if (exception1 == null) { exception1 = exception2; } else if (exception1 != exception2) { exception1.addSuppressed(exception2); }
> /*     */     
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static SparseMatrixModified rutherford(Path path) throws IOException {
> /* 729 */     return harwell(path);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static SparseMatrixModified text(Path path) throws IOException {
> /* 748 */     Exception exception1 = null, exception2 = null;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     try {
> /*     */     
> /*     */     } finally {
> /* 768 */       exception2 = null; if (exception1 == null) { exception1 = exception2; } else if (exception1 != exception2) { exception1.addSuppressed(exception2); }
> /*     */     
> /*     */     } 
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/SparseMatrixModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/StringsModified.java jd-gui/smileModified/StringsModified.java
1,178c1,278
< package smileModified;
< 
< import java.text.DecimalFormat;
< import java.util.Arrays;
< 
< public interface StringsModified {
<    DecimalFormat DECIMAL_FORMAT = new DecimalFormat("#.####");
< 
<    static boolean isNullOrEmpty(String s) {
<       return s == null || s.isEmpty();
<    }
< 
<    static String unescape(String s) {
<       StringBuilder sb = new StringBuilder(s.length());
< 
<       for(int i = 0; i < s.length(); ++i) {
<          char ch = s.charAt(i);
<          if (ch == '\\') {
<             char nextChar = i == s.length() - 1 ? 92 : s.charAt(i + 1);
<             if (nextChar >= '0' && nextChar <= '7') {
<                String code = String.valueOf(nextChar);
<                ++i;
<                if (i < s.length() - 1 && s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '7') {
<                   code = code + s.charAt(i + 1);
<                   ++i;
<                   if (i < s.length() - 1 && s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '7') {
<                      code = code + s.charAt(i + 1);
<                      ++i;
<                   }
<                }
< 
<                sb.append((char)Integer.parseInt(code, 8));
<                continue;
<             }
< 
<             switch(nextChar) {
<             case '"':
<                ch = '"';
<                break;
<             case '\'':
<                ch = '\'';
<                break;
<             case '\\':
<                ch = '\\';
<                break;
<             case 'b':
<                ch = '\b';
<                break;
<             case 'f':
<                ch = '\f';
<                break;
<             case 'n':
<                ch = '\n';
<                break;
<             case 'r':
<                ch = '\r';
<                break;
<             case 't':
<                ch = '\t';
<                break;
<             case 'u':
<                if (i < s.length() - 5) {
<                   int code = Integer.parseInt(s.substring(i + 2, i + 6), 16);
<                   sb.append(Character.toChars(code));
<                   i += 5;
<                   continue;
<                }
< 
<                ch = 'u';
<             }
< 
<             ++i;
<          }
< 
<          sb.append(ch);
<       }
< 
<       return sb.toString();
<    }
< 
<    static String ordinal(int i) {
<       String[] suffixes = new String[]{"th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th"};
<       switch(i % 100) {
<       case 11:
<       case 12:
<       case 13:
<          return i + "th";
<       default:
<          return i + suffixes[i % 10];
<       }
<    }
< 
<    static String leftPad(String s, int size, char padChar) {
<       if (s == null) {
<          return null;
<       } else {
<          int pads = size - s.length();
<          return pads <= 0 ? s : fill(padChar, pads).concat(s);
<       }
<    }
< 
<    static String rightPad(String s, int size, char padChar) {
<       if (s == null) {
<          return null;
<       } else {
<          int pads = size - s.length();
<          return pads <= 0 ? s : s.concat(fill(padChar, pads));
<       }
<    }
< 
<    static String fill(char ch, int len) {
<       char[] chars = new char[len];
<       Arrays.fill(chars, ch);
<       return new String(chars);
<    }
< 
<    static String format(float x) {
<       return format(x, false);
<    }
< 
<    static String format(float x, boolean trailingZeros) {
<       if (MathExModified.isZero(x, 1.0E-7F)) {
<          return trailingZeros ? "0.0000" : "0";
<       } else {
<          float ax = Math.abs(x);
<          if (ax >= 0.001F && ax < 1.0E7F) {
<             return trailingZeros ? String.format("%.4f", x) : DECIMAL_FORMAT.format((double)x);
<          } else {
<             return String.format("%.4e", x);
<          }
<       }
<    }
< 
<    static String format(double x) {
<       return format(x, false);
<    }
< 
<    static String format(double x, boolean trailingZeros) {
<       if (MathExModified.isZero(x, 1.0E-14D)) {
<          return trailingZeros ? "0.0000" : "0";
<       } else {
<          double ax = Math.abs(x);
<          if (ax >= 0.001D && ax < 1.0E7D) {
<             return trailingZeros ? String.format("%.4f", x) : DECIMAL_FORMAT.format(x);
<          } else {
<             return String.format("%.4e", x);
<          }
<       }
<    }
< 
<    static int[] parseIntArray(String s) {
<       if (isNullOrEmpty(s)) {
<          return null;
<       } else {
<          s = s.trim();
<          if (s.startsWith("[") && s.endsWith("]")) {
<             String[] tokens = s.substring(1, s.length() - 1).split(",");
<             return Arrays.stream(tokens).map(String::trim).mapToInt(Integer::parseInt).toArray();
<          } else {
<             throw new IllegalArgumentException("Invalid string: " + s);
<          }
<       }
<    }
< 
<    static double[] parseDoubleArray(String s) {
<       if (isNullOrEmpty(s)) {
<          return null;
<       } else {
<          s = s.trim();
<          if (s.startsWith("[") && s.endsWith("]")) {
<             String[] tokens = s.substring(1, s.length() - 1).split(",");
<             return Arrays.stream(tokens).map(String::trim).mapToDouble(Double::parseDouble).toArray();
<          } else {
<             throw new IllegalArgumentException("Invalid string: " + s);
<          }
<       }
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.text.DecimalFormat;
> /*     */ import java.util.Arrays;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public interface StringsModified
> /*     */ {
> /*  30 */   public static final DecimalFormat DECIMAL_FORMAT = new DecimalFormat("#.####");
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static boolean isNullOrEmpty(String s) {
> /*  38 */     return !(s != null && !s.isEmpty());
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static String unescape(String s) {
> /*  47 */     StringBuilder sb = new StringBuilder(s.length());
> /*     */     
> /*  49 */     for (int i = 0; i < s.length(); i++) {
> /*  50 */       char ch = s.charAt(i);
> /*  51 */       if (ch == '\\')
> /*  52 */       { char nextChar = (i == s.length() - 1) ? '\\' : s.charAt(i + 1);
> /*     */         
> /*  54 */         if (nextChar >= '0' && nextChar <= '7')
> /*  55 */         { String code = String.valueOf(nextChar);
> /*  56 */           i++;
> /*  57 */           if (i < s.length() - 1 && s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '7') {
> /*  58 */             code = String.valueOf(code) + s.charAt(i + 1);
> /*  59 */             i++;
> /*  60 */             if (i < s.length() - 1 && s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '7') {
> /*  61 */               code = String.valueOf(code) + s.charAt(i + 1);
> /*  62 */               i++;
> /*     */             } 
> /*     */           } 
> /*  65 */           sb.append((char)Integer.parseInt(code, 8)); }
> /*     */         
> /*     */         else
> /*     */         
> /*  69 */         { switch (nextChar)
> /*     */           { case '\\':
> /*  71 */               ch = '\\';
> /*     */             
> /*     */             case 'b':
> /*  74 */               ch = '\b';
> /*     */             
> /*     */             case 'f':
> /*  77 */               ch = '\f';
> /*     */             
> /*     */             case 'n':
> /*  80 */               ch = '\n';
> /*     */             
> /*     */             case 'r':
> /*  83 */               ch = '\r';
> /*     */             
> /*     */             case 't':
> /*  86 */               ch = '\t';
> /*     */             
> /*     */             case '"':
> /*  89 */               ch = '"';
> /*     */             
> /*     */             case '\'':
> /*  92 */               ch = '\'';
> /*     */ 
> /*     */             
> /*     */             case 'u':
> /*  96 */               if (i >= s.length() - 5) {
> /*  97 */                 ch = 'u';
> /*     */               } else {
> /*     */                 
> /* 100 */                 int code = Integer.parseInt(s.substring(i + 2, i + 6), 16);
> /* 101 */                 sb.append(Character.toChars(code));
> /* 102 */                 i += 5; break;
> /*     */               } 
> /*     */             default:
> /* 105 */               i++;
> /*     */               
> /* 107 */               sb.append(ch); break; }  }  continue; }  sb.append(ch); break;
> /*     */     } 
> /* 109 */     return sb.toString();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static String ordinal(int i) {
> /* 118 */     String[] suffixes = { "th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th" };
> /* 119 */     switch (i % 100) {
> /*     */       case 11:
> /*     */       case 12:
> /*     */       case 13:
> /* 123 */         return String.valueOf(i) + "th";
> /*     */     } 
> /* 125 */     return String.valueOf(i) + suffixes[i % 10];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static String leftPad(String s, int size, char padChar) {
> /* 139 */     if (s == null) {
> /* 140 */       return null;
> /*     */     }
> /* 142 */     int pads = size - s.length();
> /* 143 */     if (pads <= 0) {
> /* 144 */       return s;
> /*     */     }
> /* 146 */     return fill(padChar, pads).concat(s);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static String rightPad(String s, int size, char padChar) {
> /* 159 */     if (s == null) {
> /* 160 */       return null;
> /*     */     }
> /* 162 */     int pads = size - s.length();
> /* 163 */     if (pads <= 0) {
> /* 164 */       return s;
> /*     */     }
> /* 166 */     return s.concat(fill(padChar, pads));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static String fill(char ch, int len) {
> /* 176 */     char[] chars = new char[len];
> /* 177 */     Arrays.fill(chars, ch);
> /* 178 */     return new String(chars);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static String format(float x) {
> /* 187 */     return format(x, false);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static String format(float x, boolean trailingZeros) {
> /* 197 */     if (MathExModified.isZero(x, 1.0E-7F)) {
> /* 198 */       return trailingZeros ? "0.0000" : "0";
> /*     */     }
> /*     */     
> /* 201 */     float ax = Math.abs(x);
> /* 202 */     if (ax >= 0.001F && ax < 1.0E7F) {
> /* 203 */       return trailingZeros ? String.format("%.4f", new Object[] { Float.valueOf(x) }) : DECIMAL_FORMAT.format(x);
> /*     */     }
> /*     */     
> /* 206 */     return String.format("%.4e", new Object[] { Float.valueOf(x) });
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static String format(double x) {
> /* 215 */     return format(x, false);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static String format(double x, boolean trailingZeros) {
> /* 225 */     if (MathExModified.isZero(x, 1.0E-14D)) {
> /* 226 */       return trailingZeros ? "0.0000" : "0";
> /*     */     }
> /*     */     
> /* 229 */     double ax = Math.abs(x);
> /* 230 */     if (ax >= 0.001D && ax < 1.0E7D) {
> /* 231 */       return trailingZeros ? String.format("%.4f", new Object[] { Double.valueOf(x) }) : DECIMAL_FORMAT.format(x);
> /*     */     }
> /*     */     
> /* 234 */     return String.format("%.4e", new Object[] { Double.valueOf(x) });
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static int[] parseIntArray(String s) {
> /* 244 */     if (isNullOrEmpty(s)) return null;
> /*     */     
> /* 246 */     s = s.trim();
> /* 247 */     if (!s.startsWith("[") || !s.endsWith("]")) {
> /* 248 */       throw new IllegalArgumentException("Invalid string: " + s);
> /*     */     }
> /*     */     
> /* 251 */     String[] tokens = s.substring(1, s.length() - 1).split(",");
> /* 252 */     return Arrays.<String>stream(tokens).map(String::trim).mapToInt(Integer::parseInt).toArray();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   static double[] parseDoubleArray(String s) {
> /* 262 */     if (isNullOrEmpty(s)) return null;
> /*     */     
> /* 264 */     s = s.trim();
> /* 265 */     if (!s.startsWith("[") || !s.endsWith("]")) {
> /* 266 */       throw new IllegalArgumentException("Invalid string: " + s);
> /*     */     }
> /*     */     
> /* 269 */     String[] tokens = s.substring(1, s.length() - 1).split(",");
> /* 270 */     return Arrays.<String>stream(tokens).map(String::trim).mapToDouble(Double::parseDouble).toArray();
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/StringsModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/SVDJobModified.java jd-gui/smileModified/SVDJobModified.java
1c1,45
< package smileModified;
---
> /*    */ package smileModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public enum SVDJobModified
> /*    */ {
> /* 22 */   ALL((byte)
> /* 23 */     65),
> /* 24 */   COMPACT((byte)
> /* 25 */     83),
> /* 26 */   OVERWRITE((byte)
> /* 27 */     79),
> /* 28 */   NO_VECTORS((byte)
> /* 29 */     78);
> /*    */ 
> /*    */   
> /*    */   private final byte lapack;
> /*    */ 
> /*    */   
> /*    */   SVDJobModified(byte lapack) {
> /* 36 */     this.lapack = lapack;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public byte lapack() {
> /* 43 */     return this.lapack;
> /*    */   }
> /*    */ }
3,7d46
< public enum SVDJobModified {
<    ALL((byte)65),
<    COMPACT((byte)83),
<    OVERWRITE((byte)79),
<    NO_VECTORS((byte)78);
9,18c48,51
<    private final byte lapack;
< 
<    private SVDJobModified(byte lapack) {
<       this.lapack = lapack;
<    }
< 
<    public byte lapack() {
<       return this.lapack;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/SVDJobModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/SymmMatrixModified.java jd-gui/smileModified/SymmMatrixModified.java
1,295c1,482
< package smileModified;
< 
< import java.io.Serializable;
< import java.nio.DoubleBuffer;
< import org.slf4j.Logger;
< import org.slf4j.LoggerFactory;
< 
< public class SymmMatrixModified extends IMatrixModified {
<    private static final long serialVersionUID = 2L;
<    private static final Logger logger = LoggerFactory.getLogger(SymmMatrixModified.class);
<    final double[] AP;
<    final int n;
<    final UPLOModified uplo;
< 
<    public SymmMatrixModified(UPLOModified uplo, int n) {
<       if (uplo == null) {
<          throw new NullPointerException("UPLO is null");
<       } else {
<          this.uplo = uplo;
<          this.n = n;
<          this.AP = new double[n * (n + 1) / 2];
<       }
<    }
< 
<    public SymmMatrixModified(UPLOModified uplo, double[][] AP) {
<       this(uplo, AP.length);
<       int i;
<       int j;
<       if (uplo == UPLOModified.LOWER) {
<          for(i = 0; i < this.n; ++i) {
<             for(j = 0; j <= i; ++j) {
<                this.AP[i + (2 * this.n - j - 1) * j / 2] = AP[i][j];
<             }
<          }
<       } else {
<          for(i = 0; i < this.n; ++i) {
<             for(j = i; j < this.n; ++j) {
<                this.AP[i + j * (j + 1) / 2] = AP[i][j];
<             }
<          }
<       }
< 
<    }
< 
<    public SymmMatrixModified clone() {
<       SymmMatrixModified matrix = new SymmMatrixModified(this.uplo, this.n);
<       System.arraycopy(this.AP, 0, matrix.AP, 0, this.AP.length);
<       return matrix;
<    }
< 
<    public int nrow() {
<       return this.n;
<    }
< 
<    public int ncol() {
<       return this.n;
<    }
< 
<    public long size() {
<       return (long)this.AP.length;
<    }
< 
<    public LayoutModified layout() {
<       return LayoutModified.COL_MAJOR;
<    }
< 
<    public UPLOModified uplo() {
<       return this.uplo;
<    }
< 
<    public boolean equals(Object o) {
<       return !(o instanceof SymmMatrixModified) ? false : this.equals((SymmMatrixModified)o, 1.0E-10D);
<    }
< 
<    public boolean equals(SymmMatrixModified o, double epsilon) {
<       if (this.n != o.n) {
<          return false;
<       } else {
<          for(int j = 0; j < this.n; ++j) {
<             for(int i = 0; i < this.n; ++i) {
<                if (!MathExModified.isZero(this.get(i, j) - o.get(i, j), epsilon)) {
<                   return false;
<                }
<             }
<          }
< 
<          return true;
<       }
<    }
< 
<    public double get(int i, int j) {
<       int tmp;
<       if (this.uplo == UPLOModified.LOWER) {
<          if (j > i) {
<             tmp = i;
<             i = j;
<             j = tmp;
<          }
< 
<          return this.AP[i + (2 * this.n - j - 1) * j / 2];
<       } else {
<          if (i > j) {
<             tmp = i;
<             i = j;
<             j = tmp;
<          }
< 
<          return this.AP[i + j * (j + 1) / 2];
<       }
<    }
< 
<    public void set(int i, int j, double x) {
<       int tmp;
<       if (this.uplo == UPLOModified.LOWER) {
<          if (j > i) {
<             tmp = i;
<             i = j;
<             j = tmp;
<          }
< 
<          this.AP[i + (2 * this.n - j - 1) * j / 2] = x;
<       } else {
<          if (i > j) {
<             tmp = i;
<             i = j;
<             j = tmp;
<          }
< 
<          this.AP[i + j * (j + 1) / 2] = x;
<       }
< 
<    }
< 
<    public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
<       BLASModified.engine.spmv(this.layout(), this.uplo, this.n, alpha, (double[])this.AP, (double[])x, 1, beta, (double[])y, 1);
<    }
< 
<    public void mv(double[] work, int inputOffset, int outputOffset) {
<       DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.n);
<       DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.n);
<       BLASModified.engine.spmv(this.layout(), this.uplo, this.n, 1.0D, (DoubleBuffer)DoubleBuffer.wrap(this.AP), (DoubleBuffer)xb, 1, 0.0D, (DoubleBuffer)yb, 1);
<    }
< 
<    public void tv(double[] work, int inputOffset, int outputOffset) {
<       this.mv(work, inputOffset, outputOffset);
<    }
< 
<    public SymmMatrixModified.BunchKaufman bk() {
<       SymmMatrixModified lu = this.clone();
<       int[] ipiv = new int[this.n];
<       int info = LAPACKModified.engine.sptrf(lu.layout(), lu.uplo, lu.n, lu.AP, ipiv);
<       if (info < 0) {
<          logger.error("LAPACK SPTRF error code: {}", info);
<          throw new ArithmeticException("LAPACK SPTRF error code: " + info);
<       } else {
<          return new SymmMatrixModified.BunchKaufman(lu, ipiv, info);
<       }
<    }
< 
<    public SymmMatrixModified.Cholesky cholesky() {
<       if (this.uplo == null) {
<          throw new IllegalArgumentException("The matrix is not symmetric");
<       } else {
<          SymmMatrixModified lu = this.clone();
<          int info = LAPACKModified.engine.pptrf(lu.layout(), lu.uplo, lu.n, lu.AP);
<          if (info != 0) {
<             logger.error("LAPACK PPTRF error code: {}", info);
<             throw new ArithmeticException("LAPACK PPTRF error code: " + info);
<          } else {
<             return new SymmMatrixModified.Cholesky(lu);
<          }
<       }
<    }
< 
<    public static class BunchKaufman implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final SymmMatrixModified lu;
<       public final int[] ipiv;
<       public final int info;
< 
<       public BunchKaufman(SymmMatrixModified lu, int[] ipiv, int info) {
<          this.lu = lu;
<          this.ipiv = ipiv;
<          this.info = info;
<       }
< 
<       public boolean isSingular() {
<          return this.info > 0;
<       }
< 
<       public double det() {
<          int n = this.lu.n;
<          double d = 1.0D;
< 
<          int j;
<          for(j = 0; j < n; ++j) {
<             d *= this.lu.get(j, j);
<          }
< 
<          for(j = 0; j < n; ++j) {
<             if (j + 1 != this.ipiv[j]) {
<                d = -d;
<             }
<          }
< 
<          return d;
<       }
< 
<       public MatrixModified inverse() {
<          MatrixModified inv = MatrixModified.eye(this.lu.n);
<          this.solve(inv);
<          return inv;
<       }
< 
<       public double[] solve(double[] b) {
<          MatrixModified x = MatrixModified.column(b);
<          this.solve(x);
<          return x.A;
<       }
< 
<       public void solve(MatrixModified B) {
<          if (B.m != this.lu.n) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.n, this.lu.n, B.m, B.n));
<          } else if (this.lu.layout() != B.layout()) {
<             throw new IllegalArgumentException("The matrix layout is inconsistent.");
<          } else if (this.info > 0) {
<             throw new RuntimeException("The matrix is singular.");
<          } else {
<             int ret = LAPACKModified.engine.sptrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.AP, this.ipiv, B.A, B.ld);
<             if (ret != 0) {
<                SymmMatrixModified.logger.error("LAPACK GETRS error code: {}", ret);
<                throw new ArithmeticException("LAPACK GETRS error code: " + ret);
<             }
<          }
<       }
<    }
< 
<    public static class Cholesky implements Serializable {
<       private static final long serialVersionUID = 2L;
<       public final SymmMatrixModified lu;
< 
<       public Cholesky(SymmMatrixModified lu) {
<          if (lu.nrow() != lu.ncol()) {
<             throw new UnsupportedOperationException("Cholesky constructor on a non-square matrix");
<          } else {
<             this.lu = lu;
<          }
<       }
< 
<       public double det() {
<          double d = 1.0D;
< 
<          for(int i = 0; i < this.lu.n; ++i) {
<             d *= this.lu.get(i, i);
<          }
< 
<          return d * d;
<       }
< 
<       public double logdet() {
<          int n = this.lu.n;
<          double d = 0.0D;
< 
<          for(int i = 0; i < n; ++i) {
<             d += Math.log(this.lu.get(i, i));
<          }
< 
<          return 2.0D * d;
<       }
< 
<       public MatrixModified inverse() {
<          MatrixModified inv = MatrixModified.eye(this.lu.n);
<          this.solve(inv);
<          return inv;
<       }
< 
<       public double[] solve(double[] b) {
<          MatrixModified x = MatrixModified.column(b);
<          this.solve(x);
<          return x.A;
<       }
< 
<       public void solve(MatrixModified B) {
<          if (B.m != this.lu.n) {
<             throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", this.lu.n, this.lu.n, B.m, B.n));
<          } else {
<             int info = LAPACKModified.engine.pptrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.AP, B.A, B.ld);
<             if (info != 0) {
<                SymmMatrixModified.logger.error("LAPACK POTRS error code: {}", info);
<                throw new ArithmeticException("LAPACK POTRS error code: " + info);
<             }
<          }
<       }
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ import java.nio.DoubleBuffer;
> /*     */ import org.slf4j.Logger;
> /*     */ import org.slf4j.LoggerFactory;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class SymmMatrixModified
> /*     */   extends IMatrixModified
> /*     */ {
> /*     */   private static final long serialVersionUID = 2L;
> /*  31 */   private static final Logger logger = LoggerFactory.getLogger(SymmMatrixModified.class);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   final double[] AP;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   final int n;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   final UPLOModified uplo;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SymmMatrixModified(UPLOModified uplo, int n) {
> /*  52 */     if (uplo == null) {
> /*  53 */       throw new NullPointerException("UPLO is null");
> /*     */     }
> /*     */     
> /*  56 */     this.uplo = uplo;
> /*  57 */     this.n = n;
> /*  58 */     this.AP = new double[n * (n + 1) / 2];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public SymmMatrixModified(UPLOModified uplo, double[][] AP) {
> /*  67 */     this(uplo, AP.length);
> /*     */     
> /*  69 */     if (uplo == UPLOModified.LOWER) {
> /*  70 */       for (int i = 0; i < this.n; i++) {
> /*  71 */         for (int j = 0; j <= i; j++) {
> /*  72 */           this.AP[i + (2 * this.n - j - 1) * j / 2] = AP[i][j];
> /*     */         }
> /*     */       } 
> /*     */     } else {
> /*  76 */       for (int i = 0; i < this.n; i++) {
> /*  77 */         for (int j = i; j < this.n; j++) {
> /*  78 */           this.AP[i + j * (j + 1) / 2] = AP[i][j];
> /*     */         }
> /*     */       } 
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public SymmMatrixModified clone() {
> /*  86 */     SymmMatrixModified matrix = new SymmMatrixModified(this.uplo, this.n);
> /*  87 */     System.arraycopy(this.AP, 0, matrix.AP, 0, this.AP.length);
> /*  88 */     return matrix;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public int nrow() {
> /*  93 */     return this.n;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public int ncol() {
> /*  98 */     return this.n;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public long size() {
> /* 103 */     return this.AP.length;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public LayoutModified layout() {
> /* 111 */     return LayoutModified.COL_MAJOR;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public UPLOModified uplo() {
> /* 119 */     return this.uplo;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object o) {
> /* 124 */     if (!(o instanceof SymmMatrixModified)) {
> /* 125 */       return false;
> /*     */     }
> /*     */     
> /* 128 */     return equals((SymmMatrixModified)o, 1.0E-10D);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(SymmMatrixModified o, double epsilon) {
> /* 139 */     if (this.n != o.n) {
> /* 140 */       return false;
> /*     */     }
> /*     */     
> /* 143 */     for (int j = 0; j < this.n; j++) {
> /* 144 */       for (int i = 0; i < this.n; i++) {
> /* 145 */         if (!MathExModified.isZero(get(i, j) - o.get(i, j), epsilon)) {
> /* 146 */           return false;
> /*     */         }
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 151 */     return true;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double get(int i, int j) {
> /* 156 */     if (this.uplo == UPLOModified.LOWER) {
> /* 157 */       if (j > i) {
> /* 158 */         int tmp = i;
> /* 159 */         i = j;
> /* 160 */         j = tmp;
> /*     */       } 
> /* 162 */       return this.AP[i + (2 * this.n - j - 1) * j / 2];
> /*     */     } 
> /* 164 */     if (i > j) {
> /* 165 */       int tmp = i;
> /* 166 */       i = j;
> /* 167 */       j = tmp;
> /*     */     } 
> /* 169 */     return this.AP[i + j * (j + 1) / 2];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void set(int i, int j, double x) {
> /* 175 */     if (this.uplo == UPLOModified.LOWER) {
> /* 176 */       if (j > i) {
> /* 177 */         int tmp = i;
> /* 178 */         i = j;
> /* 179 */         j = tmp;
> /*     */       } 
> /* 181 */       this.AP[i + (2 * this.n - j - 1) * j / 2] = x;
> /*     */     } else {
> /* 183 */       if (i > j) {
> /* 184 */         int tmp = i;
> /* 185 */         i = j;
> /* 186 */         j = tmp;
> /*     */       } 
> /* 188 */       this.AP[i + j * (j + 1) / 2] = x;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void mv(TransposeModified trans, double alpha, double[] x, double beta, double[] y) {
> /* 194 */     BLASModified.engine.spmv(layout(), this.uplo, this.n, alpha, this.AP, x, 1, beta, y, 1);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void mv(double[] work, int inputOffset, int outputOffset) {
> /* 199 */     DoubleBuffer xb = DoubleBuffer.wrap(work, inputOffset, this.n);
> /* 200 */     DoubleBuffer yb = DoubleBuffer.wrap(work, outputOffset, this.n);
> /* 201 */     BLASModified.engine.spmv(layout(), this.uplo, this.n, 1.0D, DoubleBuffer.wrap(this.AP), xb, 1, 0.0D, yb, 1);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void tv(double[] work, int inputOffset, int outputOffset) {
> /* 206 */     mv(work, inputOffset, outputOffset);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public BunchKaufman bk() {
> /* 214 */     SymmMatrixModified lu = clone();
> /* 215 */     int[] ipiv = new int[this.n];
> /* 216 */     int info = LAPACKModified.engine.sptrf(lu.layout(), lu.uplo, lu.n, lu.AP, ipiv);
> /* 217 */     if (info < 0) {
> /* 218 */       logger.error("LAPACK SPTRF error code: {}", Integer.valueOf(info));
> /* 219 */       throw new ArithmeticException("LAPACK SPTRF error code: " + info);
> /*     */     } 
> /*     */     
> /* 222 */     return new BunchKaufman(lu, ipiv, info);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Cholesky cholesky() {
> /* 232 */     if (this.uplo == null) {
> /* 233 */       throw new IllegalArgumentException("The matrix is not symmetric");
> /*     */     }
> /*     */     
> /* 236 */     SymmMatrixModified lu = clone();
> /* 237 */     int info = LAPACKModified.engine.pptrf(lu.layout(), lu.uplo, lu.n, lu.AP);
> /* 238 */     if (info != 0) {
> /* 239 */       logger.error("LAPACK PPTRF error code: {}", Integer.valueOf(info));
> /* 240 */       throw new ArithmeticException("LAPACK PPTRF error code: " + info);
> /*     */     } 
> /*     */     
> /* 243 */     return new Cholesky(lu);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static class BunchKaufman
> /*     */     implements Serializable
> /*     */   {
> /*     */     private static final long serialVersionUID = 2L;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public final SymmMatrixModified lu;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public final int[] ipiv;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public final int info;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public BunchKaufman(SymmMatrixModified lu, int[] ipiv, int info) {
> /* 287 */       this.lu = lu;
> /* 288 */       this.ipiv = ipiv;
> /* 289 */       this.info = info;
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public boolean isSingular() {
> /* 297 */       return (this.info > 0);
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public double det() {
> /* 305 */       int n = this.lu.n;
> /* 306 */       double d = 1.0D; int j;
> /* 307 */       for (j = 0; j < n; j++) {
> /* 308 */         d *= this.lu.get(j, j);
> /*     */       }
> /*     */       
> /* 311 */       for (j = 0; j < n; j++) {
> /* 312 */         if (j + 1 != this.ipiv[j]) {
> /* 313 */           d = -d;
> /*     */         }
> /*     */       } 
> /*     */       
> /* 317 */       return d;
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public MatrixModified inverse() {
> /* 325 */       MatrixModified inv = MatrixModified.eye(this.lu.n);
> /* 326 */       solve(inv);
> /* 327 */       return inv;
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public double[] solve(double[] b) {
> /* 337 */       MatrixModified x = MatrixModified.column(b);
> /* 338 */       solve(x);
> /* 339 */       return x.A;
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public void solve(MatrixModified B) {
> /* 349 */       if (B.m != this.lu.n) {
> /* 350 */         throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", new Object[] { Integer.valueOf(this.lu.n), Integer.valueOf(this.lu.n), Integer.valueOf(B.m), Integer.valueOf(B.n) }));
> /*     */       }
> /*     */       
> /* 353 */       if (this.lu.layout() != B.layout()) {
> /* 354 */         throw new IllegalArgumentException("The matrix layout is inconsistent.");
> /*     */       }
> /*     */       
> /* 357 */       if (this.info > 0) {
> /* 358 */         throw new RuntimeException("The matrix is singular.");
> /*     */       }
> /*     */       
> /* 361 */       int ret = LAPACKModified.engine.sptrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.AP, this.ipiv, B.A, B.ld);
> /* 362 */       if (ret != 0) {
> /* 363 */         SymmMatrixModified.logger.error("LAPACK GETRS error code: {}", Integer.valueOf(ret));
> /* 364 */         throw new ArithmeticException("LAPACK GETRS error code: " + ret);
> /*     */       } 
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static class Cholesky
> /*     */     implements Serializable
> /*     */   {
> /*     */     private static final long serialVersionUID = 2L;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public final SymmMatrixModified lu;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public Cholesky(SymmMatrixModified lu) {
> /* 405 */       if (lu.nrow() != lu.ncol()) {
> /* 406 */         throw new UnsupportedOperationException("Cholesky constructor on a non-square matrix");
> /*     */       }
> /* 408 */       this.lu = lu;
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public double det() {
> /* 416 */       double d = 1.0D;
> /* 417 */       for (int i = 0; i < this.lu.n; i++) {
> /* 418 */         d *= this.lu.get(i, i);
> /*     */       }
> /*     */       
> /* 421 */       return d * d;
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public double logdet() {
> /* 429 */       int n = this.lu.n;
> /* 430 */       double d = 0.0D;
> /* 431 */       for (int i = 0; i < n; i++) {
> /* 432 */         d += Math.log(this.lu.get(i, i));
> /*     */       }
> /*     */       
> /* 435 */       return 2.0D * d;
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public MatrixModified inverse() {
> /* 443 */       MatrixModified inv = MatrixModified.eye(this.lu.n);
> /* 444 */       solve(inv);
> /* 445 */       return inv;
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public double[] solve(double[] b) {
> /* 454 */       MatrixModified x = MatrixModified.column(b);
> /* 455 */       solve(x);
> /* 456 */       return x.A;
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     public void solve(MatrixModified B) {
> /* 465 */       if (B.m != this.lu.n) {
> /* 466 */         throw new IllegalArgumentException(String.format("Row dimensions do not agree: A is %d x %d, but B is %d x %d", new Object[] { Integer.valueOf(this.lu.n), Integer.valueOf(this.lu.n), Integer.valueOf(B.m), Integer.valueOf(B.n) }));
> /*     */       }
> /*     */       
> /* 469 */       int info = LAPACKModified.engine.pptrs(this.lu.layout(), this.lu.uplo, this.lu.n, B.n, this.lu.AP, B.A, B.ld);
> /* 470 */       if (info != 0) {
> /* 471 */         SymmMatrixModified.logger.error("LAPACK POTRS error code: {}", Integer.valueOf(info));
> /* 472 */         throw new ArithmeticException("LAPACK POTRS error code: " + info);
> /*     */       } 
> /*     */     }
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/SymmMatrixModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/TransposeModified.java jd-gui/smileModified/TransposeModified.java
1c1,52
< package smileModified;
---
> /*    */ package smileModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public enum TransposeModified
> /*    */ {
> /* 22 */   NO_TRANSPOSE(
> /* 23 */     111, (byte)78),
> /* 24 */   TRANSPOSE(
> /* 25 */     112, (byte)84),
> /* 26 */   CONJUGATE_TRANSPOSE(
> /* 27 */     113, (byte)67);
> /*    */ 
> /*    */   
> /*    */   private final int blas;
> /*    */   
> /*    */   private final byte lapack;
> /*    */ 
> /*    */   
> /*    */   TransposeModified(int blas, byte lapack) {
> /* 36 */     this.blas = blas;
> /* 37 */     this.lapack = lapack;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public int blas() {
> /* 44 */     return this.blas;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public byte lapack() {
> /* 50 */     return this.lapack;
> /*    */   }
> /*    */ }
3,6d53
< public enum TransposeModified {
<    NO_TRANSPOSE(111, (byte)78),
<    TRANSPOSE(112, (byte)84),
<    CONJUGATE_TRANSPOSE(113, (byte)67);
8,23c55,58
<    private final int blas;
<    private final byte lapack;
< 
<    private TransposeModified(int blas, byte lapack) {
<       this.blas = blas;
<       this.lapack = lapack;
<    }
< 
<    public int blas() {
<       return this.blas;
<    }
< 
<    public byte lapack() {
<       return this.lapack;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/TransposeModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/UniversalGeneratorModified.java jd-gui/smileModified/UniversalGeneratorModified.java
1,147c1,209
< package smileModified;
< 
< public class UniversalGeneratorModified implements RandomNumberGeneratorModified {
<    private static final int DEFAULT_SEED = 54217137;
<    private static final int BIG_PRIME = 899999963;
<    private double c;
<    private double cd;
<    private double cm;
<    private double[] u;
<    private int i97;
<    private int j97;
< 
<    public UniversalGeneratorModified() {
<       this.setSeed(54217137L);
<    }
< 
<    public UniversalGeneratorModified(int seed) {
<       this.setSeed((long)seed);
<    }
< 
<    public UniversalGeneratorModified(long seed) {
<       this.setSeed(seed);
<    }
< 
<    public void setSeed(long seed) {
<       this.u = new double[97];
<       int ijkl = Math.abs((int)(seed % 899999963L));
<       int ij = ijkl / 30082;
<       int kl = ijkl % 30082;
<       if (ij < 0 || ij > 31328 || kl < 0 || kl > 30081) {
<          ij %= 31329;
<          kl %= 30082;
<       }
< 
<       int i = ij / 177 % 177 + 2;
<       int j = ij % 177 + 2;
<       int k = kl / 169 % 178 + 1;
<       int l = kl % 169;
< 
<       for(int ii = 0; ii < 97; ++ii) {
<          double s = 0.0D;
<          double t = 0.5D;
< 
<          for(int jj = 0; jj < 24; ++jj) {
<             int m = i * j % 179 * k % 179;
<             i = j;
<             j = k;
<             k = m;
<             l = (53 * l + 1) % 169;
<             if (l * m % 64 >= 32) {
<                s += t;
<             }
< 
<             t *= 0.5D;
<          }
< 
<          this.u[ii] = s;
<       }
< 
<       this.c = 0.021602869033813477D;
<       this.cd = 0.45623308420181274D;
<       this.cm = 0.9999998211860657D;
<       this.i97 = 96;
<       this.j97 = 32;
<    }
< 
<    public double nextDouble() {
<       double uni = this.u[this.i97] - this.u[this.j97];
<       if (uni < 0.0D) {
<          ++uni;
<       }
< 
<       this.u[this.i97] = uni;
<       if (--this.i97 < 0) {
<          this.i97 = 96;
<       }
< 
<       if (--this.j97 < 0) {
<          this.j97 = 96;
<       }
< 
<       this.c -= this.cd;
<       if (this.c < 0.0D) {
<          this.c += this.cm;
<       }
< 
<       uni -= this.c;
<       if (uni < 0.0D) {
<          ++uni;
<       }
< 
<       return uni;
<    }
< 
<    public void nextDoubles(double[] d) {
<       int n = d.length;
< 
<       for(int i = 0; i < n; ++i) {
<          double uni = this.u[this.i97] - this.u[this.j97];
<          if (uni < 0.0D) {
<             ++uni;
<          }
< 
<          this.u[this.i97] = uni;
<          if (--this.i97 < 0) {
<             this.i97 = 96;
<          }
< 
<          if (--this.j97 < 0) {
<             this.j97 = 96;
<          }
< 
<          this.c -= this.cd;
<          if (this.c < 0.0D) {
<             this.c += this.cm;
<          }
< 
<          uni -= this.c;
<          if (uni < 0.0D) {
<             ++uni;
<          }
< 
<          d[i] = uni;
<       }
< 
<    }
< 
<    public int next(int numbits) {
<       return this.nextInt() >>> 32 - numbits;
<    }
< 
<    public int nextInt() {
<       return (int)Math.floor(2.147483647E9D * (2.0D * this.nextDouble() - 1.0D));
<    }
< 
<    public int nextInt(int n) {
<       if (n <= 0) {
<          throw new IllegalArgumentException("n must be positive");
<       } else {
<          return (int)(this.nextDouble() * (double)n);
<       }
<    }
< 
<    public long nextLong() {
<       return (long)Math.floor(9.223372036854776E18D * (2.0D * this.nextDouble() - 1.0D));
<    }
< }
---
> /*     */ package smileModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class UniversalGeneratorModified
> /*     */   implements RandomNumberGeneratorModified
> /*     */ {
> /*     */   private static final int DEFAULT_SEED = 54217137;
> /*     */   private static final int BIG_PRIME = 899999963;
> /*     */   private double c;
> /*     */   private double cd;
> /*     */   private double cm;
> /*     */   private double[] u;
> /*     */   private int i97;
> /*     */   private int j97;
> /*     */   
> /*     */   public UniversalGeneratorModified() {
> /*  53 */     setSeed(54217137L);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public UniversalGeneratorModified(int seed) {
> /*  61 */     setSeed(seed);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public UniversalGeneratorModified(long seed) {
> /*  69 */     setSeed(seed);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void setSeed(long seed) {
> /*  74 */     this.u = new double[97];
> /*     */     
> /*  76 */     int ijkl = Math.abs((int)(seed % 899999963L));
> /*  77 */     int ij = ijkl / 30082;
> /*  78 */     int kl = ijkl % 30082;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*  83 */     if (ij < 0 || ij > 31328 || kl < 0 || kl > 30081) {
> /*  84 */       ij %= 31329;
> /*  85 */       kl %= 30082;
> /*     */     } 
> /*     */     
> /*  88 */     int i = ij / 177 % 177 + 2;
> /*  89 */     int j = ij % 177 + 2;
> /*  90 */     int k = kl / 169 % 178 + 1;
> /*  91 */     int l = kl % 169;
> /*     */ 
> /*     */ 
> /*     */     
> /*  95 */     for (int ii = 0; ii < 97; ii++) {
> /*  96 */       double s = 0.0D;
> /*  97 */       double t = 0.5D;
> /*  98 */       for (int jj = 0; jj < 24; jj++) {
> /*  99 */         int m = i * j % 179 * k % 179;
> /* 100 */         i = j;
> /* 101 */         j = k;
> /* 102 */         k = m;
> /* 103 */         l = (53 * l + 1) % 169;
> /* 104 */         if (l * m % 64 >= 32) {
> /* 105 */           s += t;
> /*     */         }
> /* 107 */         t *= 0.5D;
> /*     */       } 
> /* 109 */       this.u[ii] = s;
> /*     */     } 
> /*     */     
> /* 112 */     this.c = 0.021602869033813477D;
> /* 113 */     this.cd = 0.45623308420181274D;
> /* 114 */     this.cm = 0.9999998211860657D;
> /* 115 */     this.i97 = 96;
> /* 116 */     this.j97 = 32;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double nextDouble() {
> /* 123 */     double uni = this.u[this.i97] - this.u[this.j97];
> /* 124 */     if (uni < 0.0D) {
> /* 125 */       uni++;
> /*     */     }
> /*     */     
> /* 128 */     this.u[this.i97] = uni;
> /* 129 */     if (--this.i97 < 0) {
> /* 130 */       this.i97 = 96;
> /*     */     }
> /*     */     
> /* 133 */     if (--this.j97 < 0) {
> /* 134 */       this.j97 = 96;
> /*     */     }
> /*     */     
> /* 137 */     this.c -= this.cd;
> /* 138 */     if (this.c < 0.0D) {
> /* 139 */       this.c += this.cm;
> /*     */     }
> /*     */     
> /* 142 */     uni -= this.c;
> /* 143 */     if (uni < 0.0D) {
> /* 144 */       uni++;
> /*     */     }
> /*     */     
> /* 147 */     return uni;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void nextDoubles(double[] d) {
> /* 152 */     int n = d.length;
> /*     */ 
> /*     */ 
> /*     */     
> /* 156 */     for (int i = 0; i < n; i++) {
> /* 157 */       double uni = this.u[this.i97] - this.u[this.j97];
> /* 158 */       if (uni < 0.0D) {
> /* 159 */         uni++;
> /*     */       }
> /* 161 */       this.u[this.i97] = uni;
> /* 162 */       if (--this.i97 < 0) {
> /* 163 */         this.i97 = 96;
> /*     */       }
> /* 165 */       if (--this.j97 < 0) {
> /* 166 */         this.j97 = 96;
> /*     */       }
> /* 168 */       this.c -= this.cd;
> /* 169 */       if (this.c < 0.0D) {
> /* 170 */         this.c += this.cm;
> /*     */       }
> /* 172 */       uni -= this.c;
> /* 173 */       if (uni < 0.0D) {
> /* 174 */         uni++;
> /*     */       }
> /* 176 */       d[i] = uni;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public int next(int numbits) {
> /* 182 */     return nextInt() >>> 32 - numbits;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public int nextInt() {
> /* 187 */     return (int)Math.floor(2.147483647E9D * (2.0D * nextDouble() - 1.0D));
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public int nextInt(int n) {
> /* 192 */     if (n <= 0) {
> /* 193 */       throw new IllegalArgumentException("n must be positive");
> /*     */     }
> /*     */     
> /* 196 */     return (int)(nextDouble() * n);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public long nextLong() {
> /* 201 */     return (long)Math.floor(9.223372036854776E18D * (2.0D * nextDouble() - 1.0D));
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/UniversalGeneratorModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/smileModified/UPLOModified.java jd-gui/smileModified/UPLOModified.java
1c1,68
< package smileModified;
---
> /*    */ package smileModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public enum UPLOModified
> /*    */ {
> /* 28 */   UPPER(
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */     
> /* 35 */     121, (byte)85),
> /* 36 */   LOWER(
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */     
> /* 43 */     122, (byte)76);
> /*    */ 
> /*    */   
> /*    */   private final int blas;
> /*    */   
> /*    */   private final byte lapack;
> /*    */ 
> /*    */   
> /*    */   UPLOModified(int blas, byte lapack) {
> /* 52 */     this.blas = blas;
> /* 53 */     this.lapack = lapack;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public int blas() {
> /* 60 */     return this.blas;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public byte lapack() {
> /* 66 */     return this.lapack;
> /*    */   }
> /*    */ }
3,5d69
< public enum UPLOModified {
<    UPPER(121, (byte)85),
<    LOWER(122, (byte)76);
7,22c71,74
<    private final int blas;
<    private final byte lapack;
< 
<    private UPLOModified(int blas, byte lapack) {
<       this.blas = blas;
<       this.lapack = lapack;
<    }
< 
<    public int blas() {
<       return this.blas;
<    }
< 
<    public byte lapack() {
<       return this.lapack;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/smileModified/UPLOModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: SPTBatch_$1$1.java
Only in jd-gui: SPTBatch_$1$2.java
Only in jd-gui: SPTBatch_$1$3.java
Only in jd-gui: SPTBatch_$1$4.java
Only in jd-gui: SPTBatch_$1$5.java
Only in jd-gui: SPTBatch_$1.java
Only in jd-gui: SPTBatch_$2.java
Only in jd-gui: SPTBatch_$Branch.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$10.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$11.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$12.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$13.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$1.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$2.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$3.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$4.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$5.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$6.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$7.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$8.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel$9.java
Only in jd-gui: SPTBatch_$ChooserWizardPanel.java
Only in jd-gui: SPTBatch_$EdgeSourceSpotFrameComparator.java
Only in jd-gui: SPTBatch_$FirstWizardPanel.java
Only in jd-gui: SPTBatch_$LabelWizardPanel$1.java
Only in jd-gui: SPTBatch_$LabelWizardPanel.java
Only in jd-gui: SPTBatch_$LastWizardPanel.java
Only in jd-gui: SPTBatch_$NSpotPerFrameDataset.java
Only in jd-gui: SPTBatch_$OptionWizardPanel.java
diff -r TrackAnalyzer_/SPTBatch_.java jd-gui/SPTBatch_.java
1,4276c1,4983
< import checkable.CheckableItem;
< import checkable.CheckedComboBox;
< import fiji.plugin.trackmate.Dimension;
< import fiji.plugin.trackmate.FeatureModel;
< import fiji.plugin.trackmate.Logger;
< import fiji.plugin.trackmate.Model;
< import fiji.plugin.trackmate.SelectionModel;
< import fiji.plugin.trackmate.Settings;
< import fiji.plugin.trackmate.Spot;
< import fiji.plugin.trackmate.SpotCollection;
< import fiji.plugin.trackmate.SpotRoi;
< import fiji.plugin.trackmate.TrackMate;
< import fiji.plugin.trackmate.action.PlotNSpotsVsTimeAction;
< import fiji.plugin.trackmate.detection.DogDetectorFactory;
< import fiji.plugin.trackmate.detection.LogDetectorFactory;
< import fiji.plugin.trackmate.features.EdgeCollectionDataset;
< import fiji.plugin.trackmate.features.FeatureFilter;
< import fiji.plugin.trackmate.features.FeatureUtils;
< import fiji.plugin.trackmate.features.ModelDataset;
< import fiji.plugin.trackmate.features.SpotCollectionDataset;
< import fiji.plugin.trackmate.features.TrackCollectionDataset;
< import fiji.plugin.trackmate.graph.ConvexBranchesDecomposition;
< import fiji.plugin.trackmate.graph.TimeDirectedNeighborIndex;
< import fiji.plugin.trackmate.graph.ConvexBranchesDecomposition.TrackBranchDecomposition;
< import fiji.plugin.trackmate.gui.Fonts;
< import fiji.plugin.trackmate.gui.displaysettings.Colormap;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettingsIO;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings.TrackDisplayMode;
< import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings.TrackMateObject;
< import fiji.plugin.trackmate.io.TmXmlReader;
< import fiji.plugin.trackmate.tracking.LAPUtils;
< import fiji.plugin.trackmate.tracking.ManualTrackerFactory;
< import fiji.plugin.trackmate.tracking.kalman.KalmanTrackerFactory;
< import fiji.plugin.trackmate.tracking.sparselap.SimpleSparseLAPTrackerFactory;
< import fiji.plugin.trackmate.tracking.sparselap.SparseLAPTrackerFactory;
< import fiji.plugin.trackmate.util.ExportableChartPanel;
< import fiji.plugin.trackmate.util.TMUtils;
< import fiji.plugin.trackmate.visualization.FeatureColorGenerator;
< import fiji.plugin.trackmate.visualization.PerTrackFeatureColorGenerator;
< import fiji.plugin.trackmate.visualization.hyperstack.HyperStackDisplayer;
< import fiji.plugin.trackmate.visualization.hyperstack.SpotOverlay;
< import fiji.plugin.trackmate.visualization.hyperstack.TrackOverlay;
< import fiji.plugin.trackmate.visualization.table.TablePanel;
< import ij.IJ;
< import ij.ImagePlus;
< import ij.ImageStack;
< import ij.gui.OvalRoi;
< import ij.gui.Overlay;
< import ij.gui.PolygonRoi;
< import ij.gui.Roi;
< import ij.gui.ShapeRoi;
< import ij.measure.Calibration;
< import ij.measure.ResultsTable;
< import ij.plugin.ZProjector;
< import ij.plugin.frame.RoiManager;
< import ij.process.ColorProcessor;
< import ij.process.ImageProcessor;
< import inra.ijpb.morphology.Morphology;
< import inra.ijpb.morphology.Strel.Shape;
< import java.awt.BorderLayout;
< import java.awt.Button;
< import java.awt.Color;
< import java.awt.Component;
< import java.awt.FlowLayout;
< import java.awt.Font;
< import java.awt.Graphics2D;
< import java.awt.GridBagConstraints;
< import java.awt.GridBagLayout;
< import java.awt.GridLayout;
< import java.awt.Image;
< import java.awt.Insets;
< import java.awt.Panel;
< import java.awt.Rectangle;
< import java.awt.RenderingHints;
< import java.awt.TextField;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.ItemEvent;
< import java.awt.event.ItemListener;
< import java.awt.event.MouseAdapter;
< import java.awt.event.MouseEvent;
< import java.awt.image.BufferedImage;
< import java.awt.image.ImageObserver;
< import java.io.File;
< import java.io.FileWriter;
< import java.io.IOException;
< import java.net.URL;
< import java.text.DecimalFormat;
< import java.text.NumberFormat;
< import java.util.ArrayList;
< import java.util.Arrays;
< import java.util.Collections;
< import java.util.Comparator;
< import java.util.HashMap;
< import java.util.HashSet;
< import java.util.Iterator;
< import java.util.LinkedHashSet;
< import java.util.List;
< import java.util.Map;
< import java.util.Set;
< import java.util.function.BiConsumer;
< import java.util.function.BiFunction;
< import java.util.function.Function;
< import java.util.function.Supplier;
< import java.util.prefs.Preferences;
< import java.util.stream.Collectors;
< import java.util.stream.Stream;
< import javax.swing.BorderFactory;
< import javax.swing.Box;
< import javax.swing.BoxLayout;
< import javax.swing.ButtonGroup;
< import javax.swing.DefaultComboBoxModel;
< import javax.swing.Icon;
< import javax.swing.ImageIcon;
< import javax.swing.JButton;
< import javax.swing.JCheckBox;
< import javax.swing.JComboBox;
< import javax.swing.JComponent;
< import javax.swing.JFrame;
< import javax.swing.JLabel;
< import javax.swing.JOptionPane;
< import javax.swing.JPanel;
< import javax.swing.JProgressBar;
< import javax.swing.JScrollPane;
< import javax.swing.JSeparator;
< import javax.swing.JTabbedPane;
< import javax.swing.JTable;
< import javax.swing.JTextArea;
< import javax.swing.JTextField;
< import javax.swing.SwingUtilities;
< import javax.swing.UIManager;
< import javax.swing.UnsupportedLookAndFeelException;
< import javax.swing.UIManager.LookAndFeelInfo;
< import javax.swing.table.DefaultTableModel;
< import javax.swing.text.DefaultCaret;
< import javax.xml.parsers.DocumentBuilder;
< import javax.xml.parsers.DocumentBuilderFactory;
< import javax.xml.parsers.ParserConfigurationException;
< import javax.xml.xpath.XPath;
< import javax.xml.xpath.XPathConstants;
< import javax.xml.xpath.XPathExpression;
< import javax.xml.xpath.XPathExpressionException;
< import javax.xml.xpath.XPathFactory;
< import jwizardcomponent.JWizardComponents;
< import jwizardcomponent.JWizardPanel;
< import jwizardcomponent.Utilities;
< import jwizardcomponent.frame.JWizardFrame;
< import loci.plugins.in.DisplayHandler;
< import loci.plugins.in.ImportProcess;
< import loci.plugins.in.ImporterOptions;
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartUtils;
< import org.jfree.chart.JFreeChart;
< import org.jfree.chart.axis.NumberAxis;
< import org.jfree.chart.labels.CategoryItemLabelGenerator;
< import org.jfree.chart.labels.StandardCategoryItemLabelGenerator;
< import org.jfree.chart.plot.CategoryPlot;
< import org.jfree.chart.plot.PlotOrientation;
< import org.jfree.chart.plot.XYPlot;
< import org.jfree.chart.renderer.category.CategoryItemRenderer;
< import org.jfree.chart.renderer.xy.XYItemRenderer;
< import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
< import org.jfree.chart.ui.RectangleInsets;
< import org.jfree.data.category.DefaultCategoryDataset;
< import org.jfree.data.xy.DefaultXYDataset;
< import org.jgrapht.graph.DefaultEdge;
< import org.jgrapht.graph.DefaultWeightedEdge;
< import org.jgrapht.graph.SimpleDirectedGraph;
< import org.w3c.dom.Document;
< import org.w3c.dom.Node;
< import org.w3c.dom.NodeList;
< import org.xml.sax.SAXException;
< import smileModified.GaussianMixtureModified;
< 
< public class SPTBatch_ {
<    static String csvPath;
<    static String imgTitle;
<    static String RADIUS;
<    private String imagesPath;
<    private String zstart;
<    private String zend;
<    private String ystart;
<    private String yend;
<    private String xstart;
<    private String xend;
<    private String tstart;
<    private String tend;
<    private String THRESHOLD;
<    private String TARGET_CHANNEL;
<    private String DO_SUBPIXEL_LOCALIZATION;
<    private String DO_MEDIAN_FILTERING;
<    private String DETECTOR_NAME;
<    private String NSPLIT;
<    private String DOWNSAMPLE_FACTOR;
<    private String initialSpotFilter;
<    private String TRACKER_NAME;
<    private String CUTOFF_PERCENTILE;
<    private String ALTERNATIVE_LINKING_COST_FACTOR;
<    private String LINKING_MAX_DISTANCE;
<    private String MAX_FRAME_GAP;
<    private String MAX_DISTANCE;
<    private String ALLOW_GAP_CLOSING;
<    private String SPLITTING_MAX_DISTANCE;
<    private String ALLOW_TRACK_SPLITTING;
<    private String MERGING_MAX_DISTANCE;
<    private String ALLOW_TRACK_MERGING;
<    private String BLOCKING_VALUE;
<    private String TransfPath;
<    private String enableImages;
<    private String enableLog;
<    private String enableXML;
<    private String enableRois;
<    private String xmlPath;
<    private String checkEnable;
<    private String enableCsv;
<    private String TRACKMATE_TRANSF_PATH;
<    private String TRACKMATE_IMAGES_PATH;
<    private String TRACKMATE_CSV_PATH;
<    private String TRACKMATE_XML_PATH;
<    private String TRACKMATE_TXT_PATH;
<    private String TRACKMATE_OUT_PATH;
<    private String xSelectedSpot;
<    private String ySelectedSpot;
<    private String xSelectedLink;
<    private String ySelectedLink;
<    private String xSelectedTrack;
<    private String ySelectedTrack;
<    private String enablePlotF;
<    private String enableSql;
<    private String enableST;
<    private String enableSpotTable;
<    private String enableLinkTable;
<    private String enableTrackTable;
<    private String enableBranchTable;
<    private String enablePlot;
<    private String titleExportLink;
<    private String titleExportTrack;
<    private String linkingNames;
<    private String linkingValues;
<    private String initialFilterFeature;
<    private String initialFilterValue;
<    private String initialFilterAbove;
<    private String selectedOption = "N";
<    private String enableCovariance;
<    private String enableRegression;
<    private String enableKalman;
<    private String trackFilterFeature;
<    private String trackFilterValue;
<    private String trackFilterAbove;
<    private String TRACKMATE_MIN_SPOT;
<    private String TRACKMATE_MAX_SPOT;
<    private String TRACKMATE_LENGTH_TH;
<    private String TRACKMATE_DIFF_TH;
<    public static String TRACKMATE_MIN_TRACK;
<    public static String TRACKMATE_WINDOW;
<    public static String TRACKMATE_MIN_SEGMENT;
<    public static String TRACKMATE_COLUMN_PARAM;
<    String[] columnsMovements = new String[]{"Total Tracks.", "Long Tracks", "Long Confined", "Long Unidirectional Ballistic", "Long Free.", "Long Direct.", "Immob"};
<    private int[] dims;
<    private JFreeChart chart;
<    private JFrame frameChartNS;
<    private Map<String, Double> hm;
<    public static Thread mainProcess;
<    public static final int PANEL_FIRST = 0;
<    public static final int PANEL_CHOOSER = 1;
<    public static final int PANEL_OPTION_A = 2;
<    public static final int PANEL_OPTION_B = 3;
<    public static final int PANEL_LAST = 4;
<    private ImagePlus imp;
<    private ImagePlus capture;
<    private JWizardPanel panel;
<    private JButton nextButton;
<    private JButton backButton;
<    private JButton cancelButton;
<    private JButton finishButton;
<    private JButton buttonCsv;
<    private JButton trajButton;
<    private JButton summaryButton;
<    private CheckedComboBox comboP;
<    public static JCheckBox checkbox2;
<    public static JCheckBox checkbox3;
<    public static JCheckBox checkbox4;
<    public static JCheckBox checkboxRoi;
<    public static JCheckBox checkboxPlot;
<    public static JCheckBox checkPlot;
<    public static JCheckBox checkboxAnalysis;
<    public static JCheckBox checkboxST;
<    public static JCheckBox ESP;
<    public static JCheckBox ELP;
<    public static JCheckBox ETP;
<    public static JCheckBox checkbox1;
<    public static JCheckBox checkboxDiff;
<    public static JCheckBox checkboxSP;
<    public static JCheckBox checkboxMSD;
<    public static JCheckBox checkDispSpots;
<    public static JCheckBox checkDispSpotName;
<    public static JCheckBox checkDispTracks;
<    public static JCheckBox checkSummary;
<    public static JCheckBox checkPBS;
<    public static JCheckBox checkCluster;
<    public static JCheckBox checkMonomer;
<    public static JCheckBox checkTracks;
<    public static JCheckBox checkboxSubBg;
<    public static JCheckBox checkExcludeTracks;
<    private int itemCheckPlot;
<    private Button buttonXMLL;
<    private Button buttonImg;
<    public static Preferences pref1;
<    private Settings settings;
<    public static int a;
<    public static int minTracksJTF;
<    public static int maxTracksJTF;
<    public static int thLengthJTF;
<    public static int i;
<    private double thD14JTF;
<    private JFrame f;
<    private JWizardFrame wizard;
<    private TrackMate trackmate;
<    private Logger loggers;
<    private ResultsTable spotTable;
<    private ResultsTable linkTable;
<    private ResultsTable trackTable;
<    private ResultsTable rtSpot;
<    private ResultsTable rtLink;
<    private ResultsTable rtTrack;
<    private final String SPOT_TABLE_NAME = "Spots in tracks statistics";
<    private final String EDGE_TABLE_NAME = "Links in tracks statistics";
<    private final String TRACK_TABLE_NAME = "Track statistics";
<    private final String ID_COLUMN = "ID";
<    private Spot[] source;
<    public static Model model;
<    public static SelectionModel selectionModel;
<    public static ImagePlus imps;
<    public static ImagePlus impsSubBg;
<    public ImagePlus impsNano;
<    private HyperStackDisplayer displayer;
<    private String[] imageTitles;
<    private Set<Spot> track;
<    private static final String TRACK_ID_COLUMN = "TRACK_ID";
<    private PlotNSpotsVsTimeAction plot;
<    private JFreeChart chartSpot;
<    private JFreeChart chartLink;
<    private JFreeChart chartTrack;
<    private int itemPlot2;
<    private int totalTracksDef;
<    private int longTracksDef;
<    private int longConfinedDef;
<    private int longUniBalDef;
<    private int longFreeDef;
<    private int longDirectDef;
<    private int immobDef;
<    private int shortTracksDef;
<    private int shortConfinedDef;
<    private int shortAnomDef;
<    private int shortFreeDef;
<    private int shortDirectDef;
<    public static File directImages;
<    public static File directChemo;
<    public static File directDiff;
<    public static File directMSS;
<    public static File directCluster;
<    private JProgressBar progressBar;
<    public static File directSummary;
<    public static File fileXmlInitial;
<    public static File directPBS;
<    public static File directSPT;
<    static JTextArea taskOutput;
<    private JComboBox comboSpotsX;
<    private JComboBox comboSpotsY;
<    private JComboBox comboLinkX;
<    private JComboBox comboLinkY;
<    private JComboBox comboTrackX;
<    private JComboBox comboTrackY;
<    private JComboBox comboSubBg;
<    private JComboBox comboDispTracks;
<    PerTrackFeatureColorGenerator tcg;
<    Calibration calibration;
<    static JTable trackJTable;
<    static JTable linkJTable;
<    public ImagePlus[] lifs;
<    ArrayList<Float> xPosition;
<    ArrayList<Float> yPosition;
<    ArrayList<Integer> tracksID;
<    ArrayList<Integer> framePosition;
<    static JTextField chemoScaling;
<    static JTextField minTracks;
<    static JTextField maxTracks;
<    static JTextField thLength;
<    static JTextField thD14;
<    static JTextField monomerField;
<    public static RoiManager roiManager;
<    public static ImagePlus impMaxProject;
<    public static ImagePlus impMainRoi;
<    public static ImagePlus[] slices;
<    public static double[] slicesIntensityBg;
<    public static double[] slicesIntensitySpot;
<    static JTable tableSpot = null;
<    static String[] columnNamesTrack;
<    static String[] columnNamesSpot;
<    List<List<List<String>>> dataAllItemsDef = new ArrayList();
<    ArrayList<Integer> indexes;
<    static List<Integer> nOfTracks;
<    List<String> selectedItems = null;
<    static double fps;
<    ResultsTable[] rtSpots = null;
<    ResultsTable[] rtLinks = null;
<    ResultsTable[] rtTracks = null;
<    List<Boolean> excludeTrack;
<    DisplaySettings ds;
<    ResultsTable rtTrackPerImage;
<    private static final String TRACK_ID = "TRACK_ID";
<    private static final String N_PREDECESSORS = "N_PREDECESSORS";
<    private static final String N_SUCCESSORS = "N_SUCCESSORS";
<    private static final String DELTA_T = "DELTA_T";
<    private static final String DISTANCE = "DISTANCE";
<    private static final String MEAN_VELOCITY = "MEAN_VELOCITY";
<    private static final String FIRST = "FIRST";
<    private static final String LAST = "LAST";
<    private static final List<String> BRANCH_FEATURES = Arrays.asList("TRACK_ID", "N_PREDECESSORS", "N_SUCCESSORS", "DELTA_T", "DISTANCE", "MEAN_VELOCITY", "FIRST", "LAST");
<    private static final Map<String, String> BRANCH_FEATURES_NAMES = new HashMap();
<    private static final Map<String, String> BRANCH_FEATURES_SHORTNAMES = new HashMap();
<    private static final Map<String, Boolean> BRANCH_FEATURES_ISINTS = new HashMap();
<    private static final Map<String, Dimension> BRANCH_FEATURES_DIMENSIONS = new HashMap();
< 
<    static {
<       BRANCH_FEATURES_NAMES.put("TRACK_ID", "Track ID");
<       BRANCH_FEATURES_SHORTNAMES.put("TRACK_ID", "Track ID");
<       BRANCH_FEATURES_ISINTS.put("TRACK_ID", Boolean.TRUE);
<       BRANCH_FEATURES_DIMENSIONS.put("TRACK_ID", Dimension.NONE);
<       BRANCH_FEATURES_NAMES.put("N_PREDECESSORS", "Track ID");
<       BRANCH_FEATURES_SHORTNAMES.put("N_PREDECESSORS", "N predecessors");
<       BRANCH_FEATURES_ISINTS.put("N_PREDECESSORS", Boolean.TRUE);
<       BRANCH_FEATURES_DIMENSIONS.put("N_PREDECESSORS", Dimension.NONE);
<       BRANCH_FEATURES_NAMES.put("N_SUCCESSORS", "Track ID");
<       BRANCH_FEATURES_SHORTNAMES.put("N_SUCCESSORS", "N successors");
<       BRANCH_FEATURES_ISINTS.put("N_SUCCESSORS", Boolean.TRUE);
<       BRANCH_FEATURES_DIMENSIONS.put("N_SUCCESSORS", Dimension.NONE);
<       BRANCH_FEATURES_NAMES.put("DELTA_T", "Branch duration");
<       BRANCH_FEATURES_SHORTNAMES.put("DELTA_T", "Delta T");
<       BRANCH_FEATURES_ISINTS.put("DELTA_T", Boolean.FALSE);
<       BRANCH_FEATURES_DIMENSIONS.put("DELTA_T", Dimension.TIME);
<       BRANCH_FEATURES_NAMES.put("DISTANCE", "Distance traveled");
<       BRANCH_FEATURES_SHORTNAMES.put("DISTANCE", "Dist");
<       BRANCH_FEATURES_ISINTS.put("DISTANCE", Boolean.FALSE);
<       BRANCH_FEATURES_DIMENSIONS.put("DISTANCE", Dimension.LENGTH);
<       BRANCH_FEATURES_NAMES.put("MEAN_VELOCITY", "Mean velocity");
<       BRANCH_FEATURES_SHORTNAMES.put("MEAN_VELOCITY", "Mean V");
<       BRANCH_FEATURES_ISINTS.put("MEAN_VELOCITY", Boolean.FALSE);
<       BRANCH_FEATURES_DIMENSIONS.put("MEAN_VELOCITY", Dimension.VELOCITY);
<       BRANCH_FEATURES_NAMES.put("FIRST", "First spot ID");
<       BRANCH_FEATURES_SHORTNAMES.put("FIRST", "First ID");
<       BRANCH_FEATURES_ISINTS.put("FIRST", Boolean.TRUE);
<       BRANCH_FEATURES_DIMENSIONS.put("FIRST", Dimension.NONE);
<       BRANCH_FEATURES_NAMES.put("LAST", "Last spot ID");
<       BRANCH_FEATURES_SHORTNAMES.put("LAST", "Last ID");
<       BRANCH_FEATURES_ISINTS.put("LAST", Boolean.TRUE);
<       BRANCH_FEATURES_DIMENSIONS.put("LAST", Dimension.NONE);
<    }
< 
<    public SPTBatch_(String xmlPath, String imagesPath) {
<       this.xmlPath = xmlPath;
<       this.imagesPath = imagesPath;
<    }
< 
<    public void run(String arg) {
<       this.TRACKMATE_TRANSF_PATH = "transf_path";
<       this.TRACKMATE_IMAGES_PATH = "images_path";
<       this.TRACKMATE_CSV_PATH = "csv_path";
<       this.TRACKMATE_XML_PATH = "xml_path";
<       this.TRACKMATE_TXT_PATH = "txt_path";
<       this.TRACKMATE_OUT_PATH = "out_path";
<       this.TRACKMATE_MIN_SPOT = "min_spot";
<       this.TRACKMATE_MAX_SPOT = "max_spot";
<       this.TRACKMATE_LENGTH_TH = "length_th";
<       this.TRACKMATE_DIFF_TH = "diff_th";
<       TRACKMATE_MIN_TRACK = "min_track";
<       TRACKMATE_WINDOW = "window";
<       TRACKMATE_MIN_SEGMENT = "min_segment";
<       TRACKMATE_COLUMN_PARAM = "column_param";
<       pref1 = Preferences.userRoot();
<       JFrame.setDefaultLookAndFeelDecorated(true);
< 
<       try {
<          LookAndFeelInfo[] var5;
<          int var4 = (var5 = UIManager.getInstalledLookAndFeels()).length;
< 
<          for(int var3 = 0; var3 < var4; ++var3) {
<             LookAndFeelInfo info = var5[var3];
<             if ("Nimbus".equals(info.getName())) {
<                UIManager.setLookAndFeel(info.getClassName());
<                break;
<             }
<          }
<       } catch (UnsupportedLookAndFeelException var6) {
<       } catch (ClassNotFoundException var7) {
<       } catch (InstantiationException var8) {
<       } catch (IllegalAccessException var9) {
<       }
< 
<       this.wizard = new JWizardFrame();
<       this.wizard.setTitle("SPT-Batch");
<       this.panel = new SPTBatch_.FirstWizardPanel(this.wizard.getWizardComponents());
<       this.wizard.getWizardComponents().addWizardPanel(0, this.panel);
<       this.panel = new SPTBatch_.ChooserWizardPanel(this.wizard.getWizardComponents());
<       this.wizard.getWizardComponents().addWizardPanel(1, this.panel);
<       this.panel = new SPTBatch_.OptionWizardPanel(this.wizard.getWizardComponents(), "A");
<       this.wizard.getWizardComponents().addWizardPanel(2, this.panel);
<       this.panel = new SPTBatch_.OptionWizardPanel(this.wizard.getWizardComponents(), "B");
<       this.wizard.getWizardComponents().addWizardPanel(3, this.panel);
<       this.panel = new SPTBatch_.LastWizardPanel(this.wizard.getWizardComponents());
<       this.wizard.getWizardComponents().addWizardPanel(4, this.panel);
<       this.wizard.getWizardComponents().removeWizardPanel(0);
<       this.wizard.setSize(550, 700);
<       Utilities.centerComponentOnScreen(this.wizard);
<       this.wizard.setResizable(false);
<       this.wizard.setVisible(true);
<       mainProcess = new Thread(new Runnable() {
<          public void run() {
<             SPTBatch_.this.xSelectedSpot = SPTBatch_.this.comboSpotsX.getSelectedItem().toString();
<             SPTBatch_.this.ySelectedSpot = SPTBatch_.this.comboSpotsY.getSelectedItem().toString();
<             SPTBatch_.this.xSelectedLink = SPTBatch_.this.comboLinkX.getSelectedItem().toString();
<             SPTBatch_.this.ySelectedLink = SPTBatch_.this.comboLinkY.getSelectedItem().toString();
<             SPTBatch_.this.xSelectedTrack = SPTBatch_.this.comboTrackX.getSelectedItem().toString();
<             SPTBatch_.this.ySelectedTrack = SPTBatch_.this.comboTrackY.getSelectedItem().toString();
<             SPTBatch_.fileXmlInitial = new File(SPTBatch_.this.xmlPath);
<             File imageFolder = new File(SPTBatch_.this.imagesPath);
<             final File[] listOfFiles = imageFolder.listFiles();
<             SPTBatch_.this.imageTitles = new String[listOfFiles.length];
<             File[] filesXML = new File[listOfFiles.length];
< 
<             for(int u = 0; u < filesXML.length; ++u) {
<                filesXML[u] = new File(SPTBatch_.this.xmlPath);
<             }
< 
<             Object[] columHeadersFinalSpot = new Object[]{"IMAGE_TITLE", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MEAN_INTENSITY", "MEDIAN_INTENSITY", "MIN_INTENSITY", "MAX_INTENSITY", "TOTAL_INTENSITY", "STANDARD_DEVIATION", "CONTRAST", "SNR", "ESTIMATED_DIAMETER", "MORPHOLOGY", "ELLIPSOIDFIT_SEMIAXISLENGTH_C", "ELLIPSOIDFIT_SEMIAXISLENGTH_B", "ELLIPSOIDFIT_SEMIAXISLENGTH_A", "ELLIPSOIDFIT_AXISPHI_C", "ELLIPSOIDFIT_AXISPHI_B", "ELLIPSOIDFIT_AXISPHI_A", "ELLIPSOIDFIT_AXISTHETA_C", "ELLIPSOIDFIT_AXISTHETA_B", "ELLIPSOIDFIT_AXISTHETA_A"};
<             Object[] columHeadersFinalLink = new Object[]{"IMAGE_TITLE", "LINK_COST", "EDGE_TIME", "EDGE_X_LOCATION", "EDGE_Y_LOCATION", "EDGE_Z_LOCATION", "VELOCITY", "DISPLACEMENT"};
<             Object[] columHeadersFinalTrack = new Object[]{"IMAGE_TITLE", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_INDEX", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "NUMBER_SPOTS", "NUMBER_GAPS", "LONGEST_GAP", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "TRACK_MEAN_QUALITY", "TRACK_MAX_QUALITY", "TRACK_MIN_QUALITY", "TRACK_MEDIAN_QUALITY", "TRACK_STD_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "TOTAL_ABSOLUTE_ANGLE_XY", "TOTAL_ABSOLUTE_ANGLE_YZ", "TOTAL_ABSOLUTE_ANGLE_ZX", "CONFINMENT_RATIO"};
<             SPTBatch_.this.rtSpot = new ResultsTable(SPTBatch_.this.imageTitles.length);
<             SPTBatch_.this.rtLink = new ResultsTable(SPTBatch_.this.imageTitles.length);
<             SPTBatch_.this.rtTrack = new ResultsTable(SPTBatch_.this.imageTitles.length);
<             SPTBatch_.this.rtSpots = new ResultsTable[listOfFiles.length];
<             SPTBatch_.this.rtLinks = new ResultsTable[listOfFiles.length];
<             SPTBatch_.this.rtTracks = new ResultsTable[listOfFiles.length];
< 
<             int MAX;
<             for(MAX = 0; MAX < columHeadersFinalSpot.length; ++MAX) {
<                SPTBatch_.this.rtSpot.setHeading(MAX, (String)columHeadersFinalSpot[MAX]);
<             }
< 
<             for(MAX = 0; MAX < columHeadersFinalLink.length; ++MAX) {
<                SPTBatch_.this.rtLink.setHeading(MAX, (String)columHeadersFinalLink[MAX]);
<             }
< 
<             for(MAX = 0; MAX < columHeadersFinalTrack.length; ++MAX) {
<                SPTBatch_.this.rtTrack.setHeading(MAX, (String)columHeadersFinalTrack[MAX]);
<             }
< 
<             MAX = listOfFiles.length;
<             JFrame frameAnalyzer = new JFrame("Analyzing...");
<             final JProgressBar pb = new JProgressBar();
<             pb.setMinimum(0);
<             pb.setMaximum(MAX);
<             pb.setStringPainted(true);
<             SPTBatch_.taskOutput = new JTextArea(5, 20);
<             SPTBatch_.taskOutput.setMargin(new Insets(5, 5, 5, 5));
<             SPTBatch_.taskOutput.setEditable(false);
<             DefaultCaret caret = (DefaultCaret)SPTBatch_.taskOutput.getCaret();
<             caret.setUpdatePolicy(2);
<             JPanel panel = new JPanel();
<             panel.setLayout(new BoxLayout(panel, 1));
<             panel.add(pb);
<             panel.add(Box.createVerticalStrut(5));
<             panel.add(new JScrollPane(SPTBatch_.taskOutput), "Center");
<             panel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));
<             frameAnalyzer.getContentPane().add(panel);
<             frameAnalyzer.setDefaultCloseOperation(2);
<             frameAnalyzer.setSize(550, 500);
<             frameAnalyzer.setVisible(true);
<             SPTBatch_.this.selectedItems = new ArrayList();
<             final int i;
<             if (SPTBatch_.checkSummary.isSelected()) {
<                if (summaryColsWindow.combo.getSelectedIndex() == 0) {
<                   for(i = 0; i < summaryColsWindow.itemsSpots.length; ++i) {
<                      if (summaryColsWindow.itemsSpots[i].isSelected()) {
<                         SPTBatch_.this.selectedItems.add(summaryColsWindow.itemsSpots[i].text);
<                      }
<                   }
<                }
< 
<                if (summaryColsWindow.combo.getSelectedIndex() == 1) {
<                   for(i = 0; i < summaryColsWindow.itemsLinks.length; ++i) {
<                      if (summaryColsWindow.itemsLinks[i].isSelected()) {
<                         SPTBatch_.this.selectedItems.add(summaryColsWindow.itemsLinks[i].text);
<                      }
<                   }
<                }
< 
<                if (summaryColsWindow.combo.getSelectedIndex() == 2) {
<                   for(i = 0; i < summaryColsWindow.itemsTracks.length; ++i) {
<                      if (summaryColsWindow.itemsTracks[i].isSelected()) {
<                         SPTBatch_.this.selectedItems.add(summaryColsWindow.itemsTracks[i].text);
<                      }
<                   }
<                }
<             }
< 
<             for(SPTBatch_.i = 0; SPTBatch_.i < listOfFiles.length; ++SPTBatch_.i) {
<                if (SPTBatch_.imps != null) {
<                   SPTBatch_.imps.hide();
<                }
< 
<                if (listOfFiles[SPTBatch_.i].isFile()) {
<                   SPTBatch_.this.imageTitles[SPTBatch_.i] = listOfFiles[SPTBatch_.i].getName();
<                   SPTBatch_.imgTitle = SPTBatch_.this.imageTitles[SPTBatch_.i];
<                }
< 
<                i = SPTBatch_.i + 1;
< 
<                try {
<                   SwingUtilities.invokeLater(new Runnable() {
<                      public void run() {
<                         pb.setValue(i);
<                         SPTBatch_.taskOutput.append(String.format("Completed %f%% of task.\n", (double)i * 100.0D / (double)listOfFiles.length));
<                      }
<                   });
<                   Thread.sleep(100L);
<                } catch (InterruptedException var158) {
<                   JOptionPane.showMessageDialog(frameAnalyzer, var158.getMessage());
<                }
< 
<                if (listOfFiles[SPTBatch_.i].getName().contains(".lif")) {
<                   SPTBatch_.this.lifs = SPTBatch_.openBF(SPTBatch_.this.imagesPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i], false, false, false, false, false, true);
< 
<                   for(int x = 0; x < SPTBatch_.this.lifs.length; ++x) {
<                      SPTBatch_.imps = new ImagePlus(SPTBatch_.this.imagesPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]);
<                   }
<                }
< 
<                if (!listOfFiles[SPTBatch_.i].getName().contains(".lif")) {
<                   SPTBatch_.imps = new ImagePlus(SPTBatch_.this.imagesPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]);
<                }
< 
<                IJ.resetMinAndMax(SPTBatch_.imps);
<                SPTBatch_.this.dims = SPTBatch_.imps.getDimensions();
<                SPTBatch_.this.calibration = SPTBatch_.imps.getCalibration();
<                SPTBatch_.fps = SPTBatch_.imps.getFileInfo().frameInterval;
<                if (SPTBatch_.this.dims[4] == 1 && SPTBatch_.this.dims[3] > 1) {
<                   SPTBatch_.imps.setDimensions(SPTBatch_.this.dims[2], SPTBatch_.this.dims[4], SPTBatch_.this.dims[3]);
<                   SPTBatch_.this.calibration.frameInterval = SPTBatch_.this.calibration.frameInterval;
<                   SPTBatch_.this.loggers = Logger.IJ_LOGGER;
<                }
< 
<                SPTBatch_.impsSubBg = SPTBatch_.imps.duplicate();
<                SPTBatch_.impsSubBg.setCalibration(SPTBatch_.this.calibration);
<                SPTBatch_.directImages = new File(SPTBatch_.csvPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", ""));
<                boolean resultx;
<                if (!SPTBatch_.directImages.exists()) {
<                   SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directImages.getName());
<                   resultx = false;
< 
<                   try {
<                      SPTBatch_.directImages.mkdir();
<                      resultx = true;
<                   } catch (SecurityException var157) {
<                   }
< 
<                   if (resultx) {
<                      SPTBatch_.taskOutput.append("DIR created");
<                   }
<                }
< 
<                SPTBatch_.directSummary = new File(SPTBatch_.csvPath + File.separator + "Summary_Analysis");
<                if (!SPTBatch_.directSummary.exists()) {
<                   resultx = false;
< 
<                   try {
<                      SPTBatch_.directSummary.mkdir();
<                      resultx = true;
<                   } catch (SecurityException var156) {
<                   }
< 
<                   if (resultx) {
<                      SPTBatch_.taskOutput.append("DIR created-Summary_Analysis");
<                   }
<                }
< 
<                SPTBatch_.directSPT = new File(SPTBatch_.csvPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", "") + File.separator + "SPT_Analysis");
<                if (!SPTBatch_.directSPT.exists()) {
<                   resultx = false;
< 
<                   try {
<                      SPTBatch_.directSPT.mkdir();
<                      resultx = true;
<                   } catch (SecurityException var155) {
<                   }
< 
<                   if (resultx) {
<                      SPTBatch_.taskOutput.append("DIR created-SPT_Analysis");
<                   }
<                }
< 
<                SPTBatch_.directPBS = new File(SPTBatch_.csvPath + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", "") + File.separator + "Photobleaching_Analysis");
<                if (SPTBatch_.checkPBS.isSelected() && !SPTBatch_.directPBS.exists()) {
<                   resultx = false;
< 
<                   try {
<                      SPTBatch_.directPBS.mkdir();
<                      resultx = true;
<                   } catch (SecurityException var154) {
<                   }
< 
<                   if (resultx) {
<                      SPTBatch_.taskOutput.append("DIR created-Photobleching_Analysis");
<                   }
<                }
< 
<                if (SPTBatch_.checkboxMSD.isSelected() == Boolean.TRUE) {
<                   SPTBatch_.directMSS = new File(SPTBatch_.directImages.getAbsolutePath() + File.separator + "MSS_Analysis");
<                   if (!SPTBatch_.directMSS.exists()) {
<                      SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directMSS.getName());
<                      resultx = false;
< 
<                      try {
<                         SPTBatch_.directMSS.mkdir();
<                         resultx = true;
<                      } catch (SecurityException var153) {
<                      }
< 
<                      if (resultx) {
<                         SPTBatch_.taskOutput.append(SPTBatch_.directMSS.getName() + "  DIR created");
<                      }
<                   }
<                }
< 
<                if (SPTBatch_.checkCluster.isSelected() == Boolean.TRUE) {
<                   SPTBatch_.directCluster = new File(SPTBatch_.directImages.getAbsolutePath() + File.separator + "Cluster_Size_Analysis");
<                   if (!SPTBatch_.directCluster.exists()) {
<                      SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directCluster.getName());
<                      resultx = false;
< 
<                      try {
<                         SPTBatch_.directCluster.mkdir();
<                         resultx = true;
<                      } catch (SecurityException var152) {
<                      }
< 
<                      if (resultx) {
<                         SPTBatch_.taskOutput.append(SPTBatch_.directCluster.getName() + "  DIR created");
<                      }
<                   }
<                }
< 
<                new TmXmlReader(SPTBatch_.fileXmlInitial);
<                DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
<                DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
<                DocumentBuilder builder = null;
< 
<                try {
<                   builder = factory.newDocumentBuilder();
<                } catch (ParserConfigurationException var151) {
<                   var151.printStackTrace();
<                }
< 
<                Document doc = null;
< 
<                try {
<                   doc = builder.parse(SPTBatch_.fileXmlInitial);
<                } catch (SAXException var149) {
<                   var149.printStackTrace();
<                } catch (IOException var150) {
<                   var150.printStackTrace();
<                }
< 
<                XPathFactory xPathfactory = XPathFactory.newInstance();
<                XPath xpath = xPathfactory.newXPath();
<                XPathExpression exprBasicSettings = null;
<                XPathExpression exprDetectorSettings = null;
<                XPathExpression exprInitialSpotFilter = null;
<                XPathExpression exprFilter = null;
<                XPathExpression exprTrackerSettings = null;
<                XPathExpression exprLinking = null;
<                XPathExpression exprGapClosing = null;
<                XPathExpression exprSplitting = null;
<                XPathExpression exprMerging = null;
<                XPathExpression exprTrackFilter = null;
<                XPathExpression exprLinkingP = null;
< 
<                try {
<                   exprBasicSettings = xpath.compile("//Settings/BasicSettings[@zstart]");
<                } catch (XPathExpressionException var148) {
<                   var148.printStackTrace();
<                }
< 
<                try {
<                   exprLinkingP = xpath.compile("//Linking/FeaturePenalties[@MEAN_INTENSITY]");
<                } catch (XPathExpressionException var147) {
<                   var147.printStackTrace();
<                }
< 
<                try {
<                   exprDetectorSettings = xpath.compile("//Settings/DetectorSettings[@RADIUS]");
<                } catch (XPathExpressionException var146) {
<                   var146.printStackTrace();
<                }
< 
<                try {
<                   exprInitialSpotFilter = xpath.compile("//Settings/InitialSpotFilter[@feature]");
<                } catch (XPathExpressionException var145) {
<                   var145.printStackTrace();
<                }
< 
<                try {
<                   exprFilter = xpath.compile("//SpotFilterCollection/Filter[@feature]");
<                } catch (XPathExpressionException var144) {
<                   var144.printStackTrace();
<                }
< 
<                try {
<                   exprTrackerSettings = xpath.compile("//Settings/TrackerSettings[@TRACKER_NAME]");
<                } catch (XPathExpressionException var143) {
<                   var143.printStackTrace();
<                }
< 
<                try {
<                   exprLinking = xpath.compile("//TrackerSettings/Linking[@LINKING_MAX_DISTANCE]");
<                } catch (XPathExpressionException var142) {
<                   var142.printStackTrace();
<                }
< 
<                try {
<                   exprGapClosing = xpath.compile("//TrackerSettings/GapClosing[@MAX_FRAME_GAP]");
<                } catch (XPathExpressionException var141) {
<                   var141.printStackTrace();
<                }
< 
<                try {
<                   exprSplitting = xpath.compile("//TrackerSettings/TrackSplitting[@SPLITTING_MAX_DISTANCE]");
<                } catch (XPathExpressionException var140) {
<                   var140.printStackTrace();
<                }
< 
<                try {
<                   exprMerging = xpath.compile("//TrackerSettings/TrackMerging[@MERGING_MAX_DISTANCE]");
<                } catch (XPathExpressionException var139) {
<                   var139.printStackTrace();
<                }
< 
<                try {
<                   exprTrackFilter = xpath.compile("//TrackFilterCollection/Filter[@feature]");
<                } catch (XPathExpressionException var138) {
<                   var138.printStackTrace();
<                }
< 
<                NodeList nlBasicSettings = null;
<                NodeList nlDetectorSettings = null;
<                NodeList nlInitialSpotFilter = null;
<                NodeList nlFilter = null;
<                NodeList nlTrackerSettings = null;
<                NodeList nlLinking = null;
<                NodeList nlGapClosing = null;
<                NodeList nlSplitting = null;
<                NodeList nlMerging = null;
<                NodeList nlTrackFilter = null;
<                NodeList nlLinkingP = null;
< 
<                try {
<                   nlBasicSettings = (NodeList)exprBasicSettings.evaluate(doc, XPathConstants.NODESET);
<                   nlDetectorSettings = (NodeList)exprDetectorSettings.evaluate(doc, XPathConstants.NODESET);
<                   nlInitialSpotFilter = (NodeList)exprInitialSpotFilter.evaluate(doc, XPathConstants.NODESET);
<                   nlFilter = (NodeList)exprFilter.evaluate(doc, XPathConstants.NODESET);
<                   nlTrackerSettings = (NodeList)exprTrackerSettings.evaluate(doc, XPathConstants.NODESET);
<                   nlLinking = (NodeList)exprLinking.evaluate(doc, XPathConstants.NODESET);
<                   nlGapClosing = (NodeList)exprGapClosing.evaluate(doc, XPathConstants.NODESET);
<                   nlSplitting = (NodeList)exprSplitting.evaluate(doc, XPathConstants.NODESET);
<                   nlMerging = (NodeList)exprMerging.evaluate(doc, XPathConstants.NODESET);
<                   nlTrackFilter = (NodeList)exprTrackFilter.evaluate(doc, XPathConstants.NODESET);
<                   nlLinkingP = (NodeList)exprLinkingP.evaluate(doc, XPathConstants.NODESET);
<                } catch (XPathExpressionException var137) {
<                   var137.printStackTrace();
<                }
< 
<                int j;
<                Node currentItem;
<                for(j = 0; j < nlBasicSettings.getLength(); ++j) {
<                   currentItem = nlBasicSettings.item(j);
<                   SPTBatch_.this.zstart = currentItem.getAttributes().getNamedItem("zstart").getNodeValue();
<                   SPTBatch_.this.zend = currentItem.getAttributes().getNamedItem("zend").getNodeValue();
<                   SPTBatch_.this.ystart = currentItem.getAttributes().getNamedItem("ystart").getNodeValue();
<                   SPTBatch_.this.yend = currentItem.getAttributes().getNamedItem("yend").getNodeValue();
<                   SPTBatch_.this.xstart = currentItem.getAttributes().getNamedItem("xstart").getNodeValue();
<                   SPTBatch_.this.xend = currentItem.getAttributes().getNamedItem("xend").getNodeValue();
<                   SPTBatch_.this.tstart = currentItem.getAttributes().getNamedItem("tstart").getNodeValue();
<                   SPTBatch_.this.tend = currentItem.getAttributes().getNamedItem("tend").getNodeValue();
<                }
< 
<                for(j = 0; j < nlDetectorSettings.getLength(); ++j) {
<                   currentItem = nlDetectorSettings.item(j);
<                   SPTBatch_.RADIUS = currentItem.getAttributes().getNamedItem("RADIUS").getNodeValue();
<                   SPTBatch_.this.THRESHOLD = currentItem.getAttributes().getNamedItem("THRESHOLD").getNodeValue();
<                   SPTBatch_.this.TARGET_CHANNEL = currentItem.getAttributes().getNamedItem("TARGET_CHANNEL").getNodeValue();
<                   SPTBatch_.this.DO_SUBPIXEL_LOCALIZATION = currentItem.getAttributes().getNamedItem("DO_SUBPIXEL_LOCALIZATION").getNodeValue();
<                   SPTBatch_.this.DO_MEDIAN_FILTERING = currentItem.getAttributes().getNamedItem("DO_MEDIAN_FILTERING").getNodeValue();
<                   SPTBatch_.this.DETECTOR_NAME = currentItem.getAttributes().getNamedItem("DETECTOR_NAME").getNodeValue();
<                   if (SPTBatch_.this.DETECTOR_NAME.equals("BLOCK_LOG_DETECTOR")) {
<                      SPTBatch_.this.NSPLIT = currentItem.getAttributes().getNamedItem("NSPLIT").getNodeValue();
<                   }
< 
<                   if (SPTBatch_.this.DETECTOR_NAME.equals("DOWNSAMLE_LOG_DETECTOR")) {
<                      SPTBatch_.this.DOWNSAMPLE_FACTOR = currentItem.getAttributes().getNamedItem("DOWNSAMPLE_FACTOR").getNodeValue();
<                   }
<                }
< 
<                for(j = 0; j < nlLinkingP.getLength(); ++j) {
<                   SPTBatch_.this.linkingNames = nlLinkingP.item(j).getAttributes().item(j).getNodeName();
<                   SPTBatch_.this.linkingValues = nlLinkingP.item(j).getAttributes().item(j).getNodeValue();
<                }
< 
<                for(j = 0; j < nlInitialSpotFilter.getLength(); ++j) {
<                   currentItem = nlInitialSpotFilter.item(j);
<                   SPTBatch_.this.initialSpotFilter = currentItem.getAttributes().getNamedItem("value").getNodeValue();
<                }
< 
<                List<String> spotFilterFeature = new ArrayList();
<                List<String> spotFilterValue = new ArrayList();
<                List<String> spotFilterAbove = new ArrayList();
< 
<                for(int jx = 0; jx < nlFilter.getLength(); ++jx) {
<                   Node currentItemx = nlFilter.item(jx);
<                   spotFilterFeature.add(currentItemx.getAttributes().getNamedItem("feature").getNodeValue());
<                   spotFilterValue.add(currentItemx.getAttributes().getNamedItem("value").getNodeValue());
<                   spotFilterAbove.add(currentItemx.getAttributes().getNamedItem("isabove").getNodeValue());
<                }
< 
<                List<String> trackFilterFeature = new ArrayList();
<                List<String> trackFilterValue = new ArrayList();
<                List<String> trackFilterAbove = new ArrayList();
< 
<                int jxx;
<                Node currentItemxx;
<                for(jxx = 0; jxx < nlTrackFilter.getLength(); ++jxx) {
<                   currentItemxx = nlTrackFilter.item(jxx);
<                   trackFilterFeature.add(currentItemxx.getAttributes().getNamedItem("feature").getNodeValue());
<                   trackFilterValue.add(currentItemxx.getAttributes().getNamedItem("value").getNodeValue());
<                   trackFilterAbove.add(currentItemxx.getAttributes().getNamedItem("isabove").getNodeValue());
<                }
< 
<                for(jxx = 0; jxx < nlTrackerSettings.getLength(); ++jxx) {
<                   currentItemxx = nlTrackerSettings.item(jxx);
<                   SPTBatch_.this.TRACKER_NAME = currentItemxx.getAttributes().getNamedItem("TRACKER_NAME").getNodeValue();
<                   SPTBatch_.this.CUTOFF_PERCENTILE = currentItemxx.getAttributes().getNamedItem("CUTOFF_PERCENTILE").getNodeValue();
<                   SPTBatch_.this.BLOCKING_VALUE = currentItemxx.getAttributes().getNamedItem("BLOCKING_VALUE").getNodeValue();
<                   SPTBatch_.this.ALTERNATIVE_LINKING_COST_FACTOR = currentItemxx.getAttributes().getNamedItem("ALTERNATIVE_LINKING_COST_FACTOR").getNodeValue();
<                }
< 
<                for(jxx = 0; jxx < nlLinking.getLength(); ++jxx) {
<                   currentItemxx = nlLinking.item(jxx);
<                   SPTBatch_.this.LINKING_MAX_DISTANCE = currentItemxx.getAttributes().getNamedItem("LINKING_MAX_DISTANCE").getNodeValue();
<                }
< 
<                for(jxx = 0; jxx < nlGapClosing.getLength(); ++jxx) {
<                   currentItemxx = nlGapClosing.item(jxx);
<                   SPTBatch_.this.MAX_FRAME_GAP = currentItemxx.getAttributes().getNamedItem("MAX_FRAME_GAP").getNodeValue();
<                   SPTBatch_.this.MAX_DISTANCE = currentItemxx.getAttributes().getNamedItem("GAP_CLOSING_MAX_DISTANCE").getNodeValue();
<                   SPTBatch_.this.ALLOW_GAP_CLOSING = currentItemxx.getAttributes().getNamedItem("ALLOW_GAP_CLOSING").getNodeValue();
<                }
< 
<                for(jxx = 0; jxx < nlSplitting.getLength(); ++jxx) {
<                   currentItemxx = nlSplitting.item(jxx);
<                   SPTBatch_.this.SPLITTING_MAX_DISTANCE = currentItemxx.getAttributes().getNamedItem("SPLITTING_MAX_DISTANCE").getNodeValue();
<                   SPTBatch_.this.ALLOW_TRACK_SPLITTING = currentItemxx.getAttributes().getNamedItem("ALLOW_TRACK_SPLITTING").getNodeValue();
<                }
< 
<                for(jxx = 0; jxx < nlMerging.getLength(); ++jxx) {
<                   currentItemxx = nlMerging.item(jxx);
<                   SPTBatch_.this.MERGING_MAX_DISTANCE = currentItemxx.getAttributes().getNamedItem("MERGING_MAX_DISTANCE").getNodeValue();
<                   SPTBatch_.this.ALLOW_TRACK_MERGING = currentItemxx.getAttributes().getNamedItem("ALLOW_TRACK_MERGING").getNodeValue();
<                }
< 
<                SPTBatch_.this.settings = new Settings(SPTBatch_.imps);
<                SPTBatch_.taskOutput.append(SPTBatch_.this.settings.toStringImageInfo());
<                if (SPTBatch_.this.DETECTOR_NAME.equals("LOG_DETECTOR")) {
<                   SPTBatch_.this.settings.detectorFactory = new LogDetectorFactory();
<                   SPTBatch_.this.settings.detectorSettings = SPTBatch_.this.settings.detectorFactory.getDefaultSettings();
<                   SPTBatch_.this.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", Boolean.parseBoolean(SPTBatch_.this.DO_SUBPIXEL_LOCALIZATION));
<                   SPTBatch_.this.settings.detectorSettings.put("RADIUS", Double.parseDouble(SPTBatch_.RADIUS));
<                   SPTBatch_.this.settings.detectorSettings.put("TARGET_CHANNEL", Integer.parseInt(SPTBatch_.this.TARGET_CHANNEL));
<                   SPTBatch_.this.settings.detectorSettings.put("THRESHOLD", Double.parseDouble(SPTBatch_.this.THRESHOLD));
<                   SPTBatch_.this.settings.detectorSettings.put("DO_MEDIAN_FILTERING", Boolean.parseBoolean(SPTBatch_.this.DO_MEDIAN_FILTERING));
<                   if (SPTBatch_.this.initialSpotFilter != null) {
<                      SPTBatch_.this.settings.initialSpotFilterValue = Double.parseDouble(SPTBatch_.this.initialSpotFilter);
<                   }
<                }
< 
<                if (SPTBatch_.this.DETECTOR_NAME.equals("DOG_DETECTOR")) {
<                   SPTBatch_.this.settings.detectorFactory = new DogDetectorFactory();
<                   SPTBatch_.this.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", Boolean.parseBoolean(SPTBatch_.this.DO_SUBPIXEL_LOCALIZATION));
<                   SPTBatch_.this.settings.detectorSettings.put("RADIUS", Double.parseDouble(SPTBatch_.RADIUS));
<                   SPTBatch_.this.settings.detectorSettings.put("TARGET_CHANNEL", Integer.parseInt(SPTBatch_.this.TARGET_CHANNEL));
<                   SPTBatch_.this.settings.detectorSettings.put("THRESHOLD", Double.parseDouble(SPTBatch_.this.THRESHOLD));
<                   SPTBatch_.this.settings.detectorSettings.put("DO_MEDIAN_FILTERING", Double.parseDouble(SPTBatch_.this.DO_MEDIAN_FILTERING));
<                   if (SPTBatch_.this.initialSpotFilter != null) {
<                      SPTBatch_.this.settings.initialSpotFilterValue = Double.parseDouble(SPTBatch_.this.initialSpotFilter);
<                   }
<                }
< 
<                List<FeatureFilter> spotFilters = new ArrayList();
< 
<                int jxxxxx;
<                for(jxxxxx = 0; jxxxxx < spotFilterFeature.size(); ++jxxxxx) {
<                   spotFilters.add(new FeatureFilter((String)spotFilterFeature.get(jxxxxx), Double.valueOf((String)spotFilterValue.get(jxxxxx)), Boolean.valueOf((String)spotFilterAbove.get(jxxxxx))));
<                }
< 
<                for(jxxxxx = 0; jxxxxx < spotFilters.size(); ++jxxxxx) {
<                   SPTBatch_.this.settings.addSpotFilter((FeatureFilter)spotFilters.get(jxxxxx));
<                }
< 
<                if (SPTBatch_.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
<                   SPTBatch_.this.settings.trackerFactory = new ManualTrackerFactory();
<                   SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                }
< 
<                if (SPTBatch_.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
<                   SPTBatch_.this.settings.trackerFactory = new ManualTrackerFactory();
<                   SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                }
< 
<                if (SPTBatch_.this.TRACKER_NAME.equals("KALMAN_TRACKER")) {
<                   SPTBatch_.this.settings.trackerFactory = new KalmanTrackerFactory();
<                   SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                   SPTBatch_.this.settings.trackerSettings.put("KALMAN_SEARCH_RADIUS", Double.parseDouble(SPTBatch_.RADIUS));
<                }
< 
<                if (SPTBatch_.this.TRACKER_NAME.equals("SIMPLE_SPARSE_LAP_TRACKER")) {
<                   SPTBatch_.this.settings.trackerFactory = new SimpleSparseLAPTrackerFactory();
<                   SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                   SPTBatch_.this.settings.trackerSettings.put("LINKING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.LINKING_MAX_DISTANCE));
<                   SPTBatch_.this.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.MAX_DISTANCE));
<                   SPTBatch_.this.settings.trackerSettings.put("MAX_FRAME_GAP", Double.parseDouble(SPTBatch_.this.MAX_FRAME_GAP));
<                }
< 
<                if (SPTBatch_.this.TRACKER_NAME.equals("SPARSE_LAP_TRACKER")) {
<                   SPTBatch_.this.settings.trackerFactory = new SparseLAPTrackerFactory();
<                   SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
<                   SPTBatch_.this.settings.trackerSettings.put("LINKING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.LINKING_MAX_DISTANCE));
<                   Map<String, Double> linkingPenalty = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((datax) -> {
<                      return (String)datax[0];
<                   }, (datax) -> {
<                      return (Double)datax[1];
<                   }));
<                   SPTBatch_.this.settings.trackerSettings.put("ALLOW_GAP_CLOSING", Boolean.parseBoolean(SPTBatch_.this.ALLOW_GAP_CLOSING));
<                   Map var50;
<                   if (Boolean.parseBoolean(SPTBatch_.this.ALLOW_GAP_CLOSING)) {
<                      SPTBatch_.this.settings.trackerSettings.put("MAX_FRAME_GAP", Integer.parseInt(SPTBatch_.this.MAX_FRAME_GAP));
<                      SPTBatch_.this.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.MAX_DISTANCE));
<                      var50 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((datax) -> {
<                         return (String)datax[0];
<                      }, (datax) -> {
<                         return (Double)datax[1];
<                      }));
<                   }
< 
<                   SPTBatch_.this.settings.trackerSettings.put("ALLOW_TRACK_SPLITTING", Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_SPLITTING));
<                   if (Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_SPLITTING)) {
<                      SPTBatch_.this.settings.trackerSettings.put("SPLITTING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.SPLITTING_MAX_DISTANCE));
<                      var50 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((datax) -> {
<                         return (String)datax[0];
<                      }, (datax) -> {
<                         return (Double)datax[1];
<                      }));
<                   }
< 
<                   SPTBatch_.this.settings.trackerSettings.put("ALLOW_TRACK_MERGING", Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_MERGING));
<                   if (Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_MERGING)) {
<                      SPTBatch_.this.settings.trackerSettings.put("MERGING_MAX_DISTANCE", Double.parseDouble(SPTBatch_.this.MERGING_MAX_DISTANCE));
<                      var50 = (Map)Stream.of(new Object[]{"MEAN_INTENSITY", 1.0D}, new Object[]{"QUALITY", 1.0D}).collect(Collectors.toMap((datax) -> {
<                         return (String)datax[0];
<                      }, (datax) -> {
<                         return (Double)datax[1];
<                      }));
<                   }
<                }
< 
<                List<FeatureFilter> trackFilters = new ArrayList();
< 
<                int jxxxxxx;
<                for(jxxxxxx = 0; jxxxxxx < trackFilterFeature.size(); ++jxxxxxx) {
<                   trackFilters.add(new FeatureFilter((String)trackFilterFeature.get(jxxxxxx), Double.valueOf((String)trackFilterValue.get(jxxxxxx)), Boolean.valueOf((String)trackFilterAbove.get(jxxxxxx))));
<                }
< 
<                for(jxxxxxx = 0; jxxxxxx < trackFilters.size(); ++jxxxxxx) {
<                   SPTBatch_.this.settings.addTrackFilter((FeatureFilter)trackFilters.get(jxxxxxx));
<                }
< 
<                boolean result;
<                if (SPTBatch_.checkboxSubBg.isSelected()) {
<                   SPTBatch_.slices = SPTBatch_.stack2images(SPTBatch_.impsSubBg);
<                   SPTBatch_.slicesIntensityBg = new double[SPTBatch_.slices.length];
<                   SPTBatch_.slicesIntensitySpot = new double[SPTBatch_.slices.length];
<                   if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 0) {
<                      SPTBatch_.impMaxProject = ZProjector.run(SPTBatch_.impsSubBg.duplicate(), "max");
<                      SPTBatch_.impMaxProject.show();
<                      SPTBatch_.roiManager = RoiManager.getInstance();
<                      if (SPTBatch_.roiManager == null) {
<                         SPTBatch_.roiManager = new RoiManager();
<                      }
< 
<                      SPTBatch_.roiManager.reset();
<                      SPTBatch_.impMaxProject.getCanvas().addMouseListener(new MouseAdapter() {
<                         public void mouseClicked(MouseEvent e) {
<                            if (e.getClickCount() == 2) {
<                               Roi roi = new Roi(SPTBatch_.impMaxProject.getCanvas().offScreenX(e.getX()), SPTBatch_.impMaxProject.getCanvas().offScreenY(e.getY()), 5, 5);
<                               SPTBatch_.impMaxProject.setRoi(roi);
<                               SPTBatch_.roiManager.runCommand(SPTBatch_.impMaxProject, "Show All with labels");
<                               SPTBatch_.roiManager.addRoi(roi);
<                            }
< 
<                         }
<                      });
<                      Dialog4BgSub0 userDialog = new Dialog4BgSub0("Action Required", "Please select manually areas to measure background.");
<                      userDialog.show();
<                   }
< 
<                   ImagePlus slicesCell;
<                   Roi roiCell;
<                   double meanInv;
<                   if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 2) {
<                      for(jxxxxxx = 0; jxxxxxx < SPTBatch_.slices.length; ++jxxxxxx) {
<                         slicesCell = SPTBatch_.slices[jxxxxxx].duplicate();
<                         IJ.run(slicesCell, "Auto Threshold", "method=Otsu ignore_black white");
<                         slicesCell = new ImagePlus(slicesCell.getTitle(), Morphology.dilation(slicesCell.getProcessor(), Shape.DISK.fromRadius(2)));
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Fill Holes", "");
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Create Selection", "");
<                         roiCell = slicesCell.getRoi();
<                         IJ.run(slicesCell, "Make Inverse", "");
<                         Roi roiToMeasureInvx = slicesCell.getRoi();
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiCell);
<                         double meanDirectx = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiToMeasureInvx);
<                         meanInv = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         if (meanDirectx > meanInv) {
<                            SPTBatch_.slicesIntensitySpot[jxxxxxx] = meanDirectx;
<                         } else {
<                            SPTBatch_.slicesIntensitySpot[jxxxxxx] = meanInv;
<                         }
<                      }
<                   }
< 
<                   if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 3) {
<                      for(jxxxxxx = 0; jxxxxxx < SPTBatch_.slices.length; ++jxxxxxx) {
<                         slicesCell = SPTBatch_.slices[jxxxxxx].duplicate();
<                         IJ.run(slicesCell, "Auto Threshold", "method=Otsu ignore_black white");
<                         slicesCell = new ImagePlus(slicesCell.getTitle(), Morphology.dilation(slicesCell.getProcessor(), Shape.DISK.fromRadius(2)));
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Fill Holes", "");
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Create Selection", "");
<                         roiCell = slicesCell.getRoi();
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiCell);
<                         double meanDirect = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         IJ.run(slicesCell, "Make Inverse", "");
<                         Roi roiCellInv = slicesCell.getRoi();
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiCellInv);
<                         meanInv = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         if (meanDirect > meanInv) {
<                            roiCell = roiCell;
<                         } else {
<                            roiCell = roiCellInv;
<                         }
< 
<                         ImagePlus slicesSpot = SPTBatch_.slices[jxxxxxx].duplicate();
<                         String value = String.valueOf(Double.valueOf(SPTBatch_.RADIUS) / SPTBatch_.imps.getCalibration().pixelWidth);
<                         if (value.contains(",")) {
<                            value = value.replaceAll(",", ".");
<                         }
< 
<                         IJ.run(slicesSpot, "Subtract Background...", String.format("rolling=%s", value));
<                         IJ.run(slicesSpot, "Auto Threshold", "method=Otsu ignore_black white");
<                         IJ.run(slicesSpot, "Create Selection", "");
<                         Roi roiSpots = slicesSpot.getRoi();
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiSpots);
<                         double meanDirectSpots = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         IJ.run(slicesSpot, "Make Inverse", "");
<                         Roi roiSpotInv = slicesCell.getRoi();
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiCellInv);
<                         double meanInvSpots = SPTBatch_.slices[jxxxxxx].getStatistics().mean;
<                         if (meanDirect > meanInv) {
<                            roiSpots = roiSpots;
<                         } else {
<                            roiSpots = roiSpotInv;
<                         }
< 
<                         Roi roiToMeasurex = (new ShapeRoi(roiCell)).xor(new ShapeRoi(roiSpots));
<                         SPTBatch_.slices[jxxxxxx].setRoi(roiToMeasurex);
<                         SPTBatch_.slicesIntensitySpot[jxxxxxx] = SPTBatch_.slices[jxxxxxx].getStatistics().mean - SPTBatch_.slices[jxxxxxx].getStatistics().stdDev;
<                      }
<                   }
< 
<                   if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 4) {
<                      for(jxxxxxx = 0; jxxxxxx < SPTBatch_.slices.length; ++jxxxxxx) {
<                         slicesCell = SPTBatch_.slices[jxxxxxx].duplicate();
<                         IJ.run(slicesCell, "Auto Threshold", "method=Otsu ignore_black white");
<                         slicesCell = new ImagePlus(slicesCell.getTitle(), Morphology.dilation(slicesCell.getProcessor(), Shape.DISK.fromRadius(2)));
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Fill Holes", "");
<                         IJ.run(slicesCell, "Invert LUT", "");
<                         IJ.run(slicesCell, "Create Selection", "");
<                         roiCell = slicesCell.getRoi();
<                         ImagePlus sliceDup2 = SPTBatch_.slices[jxxxxxx].duplicate();
<                         sliceDup2.setRoi(roiCell);
<                         IJ.run(sliceDup2, "Clear Outside", "");
<                         BackgroundSubtracter bgSubt = new BackgroundSubtracter();
<                         ImageProcessor ip = sliceDup2.getProcessor();
<                         sliceDup2.getProcessor().resetMinAndMax();
<                         boolean isRGB = sliceDup2.getProcessor() instanceof ColorProcessor;
<                         boolean calledAsPlugin = true;
<                         double radius = Double.valueOf(SPTBatch_.RADIUS) / SPTBatch_.imps.getCalibration().pixelWidth;
<                         boolean lightBackground = false;
<                         boolean separateColors = false;
<                         boolean createBackground = false;
<                         boolean useParaboloid = false;
<                         boolean doPresmooth = false;
<                         result = false;
<                         boolean correctCorners = true;
<                         SPTBatch_.slicesIntensitySpot[jxxxxxx] = bgSubt.rollingBallBackground(ip, radius, createBackground, lightBackground, useParaboloid, doPresmooth, correctCorners);
<                      }
<                   }
<                }
< 
<                SPTBatch_.this.settings.addAllAnalyzers();
<                SPTBatch_.model = new Model();
<                SPTBatch_.this.trackmate = new TrackMate(SPTBatch_.model, SPTBatch_.this.settings);
<                Boolean ok = SPTBatch_.this.trackmate.checkInput();
<                if (ok != Boolean.TRUE) {
<                   SPTBatch_.taskOutput.append(SPTBatch_.this.trackmate.getErrorMessage());
<                }
< 
<                ok = SPTBatch_.this.trackmate.process();
<                SPTBatch_.selectionModel = new SelectionModel(SPTBatch_.model);
<                SPTBatch_.model.setLogger(Logger.IJ_LOGGER);
<                SpotCollection spots = SPTBatch_.model.getSpots();
<                SPTBatch_.taskOutput.append(spots.toString());
<                FeatureModel fm = SPTBatch_.model.getFeatureModel();
<                SPTBatch_.this.tcg = new PerTrackFeatureColorGenerator(SPTBatch_.model, "TRACK_INDEX", (Color)null, (Color)null, Colormap.Turbo, 0.0D, 1.0D);
<                SPTBatch_.taskOutput.append("\n\nSETTINGS:");
<                SPTBatch_.taskOutput.append(SPTBatch_.this.settings.toString());
<                SPTBatch_.taskOutput.append(SPTBatch_.model.toString());
<                SPTBatch_.taskOutput.append("Found" + SPTBatch_.model.getTrackModel().nTracks(true) + " tracks.");
<                SPTBatch_.taskOutput.append(SPTBatch_.this.settings.toStringFeatureAnalyzersInfo());
<                Integer firstFrame = null;
<                Integer lastFrame = null;
<                SPTBatch_.this.ds = DisplaySettingsIO.readUserDefault();
<                SPTBatch_.this.ds.setSpotShowName(SPTBatch_.checkDispSpotName.isSelected());
<                SPTBatch_.this.ds.setSpotVisible(SPTBatch_.checkDispSpots.isSelected());
<                SPTBatch_.this.ds.setSpotColorBy(TrackMateObject.TRACKS, "TRACK_INDEX");
<                SPTBatch_.this.ds.setTrackVisible(SPTBatch_.checkDispTracks.isSelected());
<                SPTBatch_.this.ds.setTrackColorBy(TrackMateObject.TRACKS, "TRACK_INDEX");
<                if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 0) {
<                   SPTBatch_.this.ds.setTrackDisplayMode(TrackDisplayMode.FULL);
<                }
< 
<                if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 1) {
<                   SPTBatch_.this.ds.setTrackDisplayMode(TrackDisplayMode.LOCAL);
<                }
< 
<                if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 2) {
<                   SPTBatch_.this.ds.setTrackDisplayMode(TrackDisplayMode.LOCAL_BACKWARD);
<                }
< 
<                if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 3) {
<                   SPTBatch_.this.ds.setTrackDisplayMode(TrackDisplayMode.LOCAL_FORWARD);
<                }
< 
<                SPTBatch_.this.displayer = new HyperStackDisplayer(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.imps, SPTBatch_.this.ds);
<                SPTBatch_.this.displayer.render();
<                SPTBatch_.this.displayer.refresh();
<                if (SPTBatch_.imps.getNFrames() > 1) {
<                   firstFrame = Math.max(1, Math.min(SPTBatch_.imps.getNFrames(), 1));
<                   lastFrame = Math.min(SPTBatch_.imps.getNFrames(), Math.max(SPTBatch_.imps.getNFrames(), 1));
<                }
< 
<                if (SPTBatch_.imps.getNSlices() > 1) {
<                   firstFrame = Math.max(1, Math.min(SPTBatch_.imps.getNSlices(), 1));
<                   lastFrame = Math.min(SPTBatch_.imps.getNSlices(), Math.max(SPTBatch_.imps.getNSlices(), 1));
<                }
< 
<                SPTBatch_.taskOutput.append("Capturing TrackMate overlay from frame " + firstFrame + " to " + lastFrame + ".\n");
<                Rectangle bounds = SPTBatch_.this.displayer.getImp().getCanvas().getBounds();
<                Integer width = bounds.width;
<                Integer height = bounds.height;
<                Integer nCaptures = lastFrame - firstFrame + 1;
<                ImageStack stack = new ImageStack(width, height);
<                Integer channel = SPTBatch_.this.displayer.getImp().getChannel();
<                Integer slice = SPTBatch_.this.displayer.getImp().getSlice();
<                SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(true);
< 
<                BufferedImage bi;
<                ColorProcessor cp;
<                Integer index;
<                int frame;
<                for(frame = firstFrame; frame <= lastFrame; ++frame) {
<                   SPTBatch_.this.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
<                   bi = new BufferedImage(width, height, 2);
<                   SPTBatch_.this.displayer.getImp().getCanvas().paint(bi.getGraphics());
<                   cp = new ColorProcessor(bi);
<                   index = SPTBatch_.this.displayer.getImp().getStackIndex(channel, slice, frame);
<                   stack.addSlice(SPTBatch_.this.displayer.getImp().getImageStack().getSliceLabel(index), cp);
<                }
< 
<                SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(false);
<                SPTBatch_.this.capture = new ImagePlus("TrackMate capture of " + SPTBatch_.this.displayer.getImp().getShortTitle(), stack);
<                SPTBatch_.transferCalibration(SPTBatch_.this.displayer.getImp(), SPTBatch_.this.capture);
<                SPTBatch_.taskOutput.append(" done.\n");
<                RoiManager trackx;
<                ArrayList framesByTrack;
<                int n;
<                int y;
<                int counter10;
<                if (SPTBatch_.checkboxRoi.isSelected() == Boolean.TRUE) {
<                   double dx = SPTBatch_.imps.getCalibration().pixelWidth;
<                   double dy = SPTBatch_.imps.getCalibration().pixelHeight;
<                   double dz = SPTBatch_.imps.getCalibration().pixelDepth;
<                   trackx = RoiManager.getInstance();
<                   if (trackx == null) {
<                      trackx = new RoiManager();
<                   }
< 
<                   trackx.reset();
<                   framesByTrack = new ArrayList(SPTBatch_.this.trackmate.getModel().getSpots().getNSpots(true));
<                   Iterator var74 = SPTBatch_.this.trackmate.getModel().getTrackModel().trackIDs(true).iterator();
< 
<                   while(var74.hasNext()) {
<                      Integer trackIDxxx = (Integer)var74.next();
<                      framesByTrack.addAll(SPTBatch_.this.trackmate.getModel().getTrackModel().trackSpots(trackIDxxx));
<                   }
< 
<                   for(n = 0; n < framesByTrack.size(); ++n) {
<                      SpotRoi sroi = ((Spot)framesByTrack.get(n)).getRoi();
<                      Object roi;
<                      if (sroi != null) {
<                         double[] xs = sroi.toPolygonX(dx, 0.0D, ((Spot)framesByTrack.get(n)).getDoublePosition(0), 1.0D);
<                         double[] ys = sroi.toPolygonY(dy, 0.0D, ((Spot)framesByTrack.get(n)).getDoublePosition(1), 1.0D);
<                         float[] xp = SPTBatch_.toFloat(xs);
<                         float[] yp = SPTBatch_.toFloat(ys);
<                         roi = new PolygonRoi(xp, yp, 2);
<                      } else {
<                         double diameter = 2.0D * ((Spot)framesByTrack.get(n)).getFeature("RADIUS") / dx;
<                         double xsx = ((Spot)framesByTrack.get(n)).getDoublePosition(0) / dx - diameter / 2.0D + 0.5D;
<                         double ysx = ((Spot)framesByTrack.get(n)).getDoublePosition(1) / dy - diameter / 2.0D + 0.5D;
<                         roi = new OvalRoi(xsx, ysx, diameter, diameter);
<                      }
< 
<                      y = 1 + (int)Math.round(((Spot)framesByTrack.get(n)).getDoublePosition(2) / dz);
<                      counter10 = 1 + ((Spot)framesByTrack.get(n)).getFeature("FRAME").intValue();
<                      ((Roi)roi).setPosition(0, y, counter10);
<                      ((Roi)roi).setName(((Spot)framesByTrack.get(n)).getName());
<                      trackx.addRoi((Roi)roi);
<                   }
< 
<                   if (trackx.getRoisAsArray().length != 0) {
<                      trackx.runCommand("Save", SPTBatch_.directSPT + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "RoiSet.zip");
<                   }
< 
<                   trackx.close();
<                }
< 
<                if (SPTBatch_.checkbox2.isSelected() == Boolean.TRUE) {
<                   SPTBatch_.taskOutput.append(SPTBatch_.model.toString());
<                   ISBIChallengeExporterModified.exportToFile(SPTBatch_.model, SPTBatch_.this.settings, new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + "TrackMate_" + SPTBatch_.imps.getShortTitle() + ".xml"));
<                   SPTBatch_.taskOutput.append("\nDone.");
<                }
< 
<                int counter1;
<                int maxFrame;
<                SpotCollection chart;
<                int counter4;
<                String xAxisLabelx;
<                if (SPTBatch_.this.enableST == "ST") {
<                   Model model = SPTBatch_.this.trackmate.getModel();
<                   Settings settings = SPTBatch_.this.trackmate.getSettings();
<                   chart = model.getSpots();
<                   counter1 = chart.keySet().size();
<                   double[][] data = new double[2][counter1];
<                   maxFrame = 0;
< 
<                   for(Iterator var237 = chart.keySet().iterator(); var237.hasNext(); ++maxFrame) {
<                      counter4 = (Integer)var237.next();
<                      data[1][maxFrame] = (double)chart.getNSpots(counter4, true);
<                      if (data[1][maxFrame] > 0.0D) {
<                         data[0][maxFrame] = ((Spot)chart.iterable(counter4, false).iterator().next()).getFeature("POSITION_T");
<                      } else {
<                         data[0][maxFrame] = (double)counter4 * settings.dt;
<                      }
<                   }
< 
<                   String xAxisLabel = "Time (" + SPTBatch_.this.trackmate.getModel().getTimeUnits() + ")";
<                   xAxisLabelx = "N spots";
<                   String title = "Nspots vs Time for " + SPTBatch_.this.trackmate.getSettings().imp.getShortTitle();
<                   DefaultXYDataset dataset = new DefaultXYDataset();
<                   dataset.addSeries("Nspots", data);
<                   SPTBatch_.this.chart = ChartFactory.createXYLineChart(title, xAxisLabel, xAxisLabelx, dataset, PlotOrientation.VERTICAL, true, true, false);
<                   SPTBatch_.this.chart.getTitle().setFont(Fonts.FONT);
<                   SPTBatch_.this.chart.getLegend().setItemFont(Fonts.SMALL_FONT);
<                   new ExportableChartPanel(SPTBatch_.this.chart);
<                }
< 
<                TablePanel chartx;
<                Set chartxxx;
<                int counter;
<                ArrayList framesByTrackx;
<                int framex;
<                ArrayList framesByTrackSort;
<                int jxxxx;
<                if (SPTBatch_.checkbox1.isSelected() == Boolean.TRUE) {
<                   TablePanel branchTable;
<                   if (SPTBatch_.this.enableSpotTable.equals("spotTable")) {
<                      branchTable = SPTBatch_.this.createSpotTable(SPTBatch_.model, SPTBatch_.this.ds);
<                      JTable spotJTablex = branchTable.getTable();
<                      chartx = SPTBatch_.this.createTrackTable(SPTBatch_.model, SPTBatch_.this.ds);
<                      SPTBatch_.trackJTable = chartx.getTable();
<                      SPTBatch_.nOfTracks = new ArrayList();
< 
<                      for(maxFrame = 0; maxFrame < SPTBatch_.trackJTable.getModel().getRowCount(); ++maxFrame) {
<                         SPTBatch_.nOfTracks.add(Integer.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(maxFrame, 2).toString()));
<                      }
< 
<                      SPTBatch_.this.indexes = new ArrayList();
<                      chartxxx = SPTBatch_.model.getTrackModel().trackIDs(true);
<                      trackx = null;
<                      counter = 0;
< 
<                      for(n = 0; n < SPTBatch_.nOfTracks.size(); ++n) {
<                         framesByTrackx = new ArrayList();
<                         framesByTrackSort = new ArrayList();
< 
<                         for(y = 0; y < spotJTablex.getRowCount(); ++y) {
<                            if (spotJTablex.getModel().getValueAt(y, 2).toString().equals(String.valueOf((Integer)SPTBatch_.nOfTracks.get(n)))) {
<                               framesByTrackx.add(Float.valueOf(spotJTablex.getModel().getValueAt(y, 8).toString()));
<                               framesByTrackSort.add(Float.valueOf(spotJTablex.getModel().getValueAt(y, 8).toString()));
<                            }
<                         }
< 
<                         Collections.sort(framesByTrackSort);
< 
<                         for(y = 0; y < framesByTrackSort.size(); ++y) {
<                            ++counter;
<                            if (n == 0) {
<                               SPTBatch_.this.indexes.add(framesByTrackx.indexOf(framesByTrackSort.get(y)));
<                            }
< 
<                            if (n != 0) {
<                               SPTBatch_.this.indexes.add(counter - 1 + framesByTrackx.indexOf(framesByTrackSort.get(y)) - y);
<                            }
<                         }
<                      }
< 
<                      String[][] rowDataSpot;
<                      ResultsTable rtSpotPerImage;
<                      if (SPTBatch_.checkboxSubBg.isSelected()) {
<                         SPTBatch_.columnNamesSpot = new String[]{"LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1", "Intensity-Bg Subtract"};
<                         rowDataSpot = new String[SPTBatch_.this.indexes.size()][SPTBatch_.columnNamesSpot.length];
<                         framex = 0;
< 
<                         while(true) {
<                            if (framex >= SPTBatch_.this.indexes.size()) {
<                               if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 1) {
<                                  for(framex = 0; framex < rowDataSpot.length; ++framex) {
<                                     rowDataSpot[framex][SPTBatch_.columnNamesSpot.length - 1] = String.valueOf(Double.valueOf(rowDataSpot[framex][12].toString()) - Double.valueOf(rowDataSpot[framex][19].toString()) * Double.valueOf(rowDataSpot[framex][17].toString()));
<                                  }
< 
<                                  DefaultTableModel tableModel = new DefaultTableModel(rowDataSpot, SPTBatch_.columnNamesSpot);
<                                  SPTBatch_.tableSpot = new JTable(tableModel);
<                               }
< 
<                               if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 0 || SPTBatch_.this.comboSubBg.getSelectedIndex() == 2 || SPTBatch_.this.comboSubBg.getSelectedIndex() == 3 || SPTBatch_.this.comboSubBg.getSelectedIndex() == 4) {
<                                  for(framex = 0; framex < spotJTablex.getModel().getRowCount(); ++framex) {
<                                     for(jxxxx = 0; jxxxx < SPTBatch_.slicesIntensitySpot.length; ++jxxxx) {
<                                        if (Integer.valueOf(rowDataSpot[framex][8].toString()).equals(jxxxx) == Boolean.TRUE) {
<                                           rowDataSpot[framex][SPTBatch_.columnNamesSpot.length - 1] = String.valueOf(Double.valueOf(rowDataSpot[framex][12].toString()) - Double.valueOf(SPTBatch_.slicesIntensitySpot[jxxxx]));
<                                        }
<                                     }
<                                  }
< 
<                                  SPTBatch_.tableSpot = new JTable(rowDataSpot, SPTBatch_.columnNamesSpot);
<                               }
< 
<                               SPTBatch_.this.exportToCSV(rowDataSpot, SPTBatch_.columnNamesSpot, new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Spots in tracks statistics" + ".csv"));
<                               rtSpotPerImage = new ResultsTable();
< 
<                               for(jxxxx = 0; jxxxx < rowDataSpot.length; ++jxxxx) {
<                                  for(y = 0; y < rowDataSpot[jxxxx].length; ++y) {
<                                     rtSpotPerImage.setValue(SPTBatch_.columnNamesSpot[y], jxxxx, rowDataSpot[jxxxx][y]);
<                                  }
<                               }
< 
<                               SPTBatch_.this.rtSpots[SPTBatch_.i] = rtSpotPerImage;
<                               break;
<                            }
< 
<                            rowDataSpot[framex][SPTBatch_.columnNamesSpot.length - 1] = "";
< 
<                            for(jxxxx = 0; jxxxx < spotJTablex.getModel().getColumnCount(); ++jxxxx) {
<                               rowDataSpot[framex][jxxxx] = String.valueOf(spotJTablex.getModel().getValueAt((Integer)SPTBatch_.this.indexes.get(framex), jxxxx));
<                            }
< 
<                            ++framex;
<                         }
<                      }
< 
<                      if (!SPTBatch_.checkboxSubBg.isSelected()) {
<                         SPTBatch_.columnNamesSpot = new String[]{"LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1"};
<                         rowDataSpot = new String[SPTBatch_.this.indexes.size()][SPTBatch_.columnNamesSpot.length];
< 
<                         for(framex = 0; framex < SPTBatch_.this.indexes.size(); ++framex) {
<                            for(jxxxx = 0; jxxxx < spotJTablex.getModel().getColumnCount(); ++jxxxx) {
<                               rowDataSpot[framex][jxxxx] = String.valueOf(spotJTablex.getModel().getValueAt((Integer)SPTBatch_.this.indexes.get(framex), jxxxx));
<                            }
<                         }
< 
<                         SPTBatch_.tableSpot = new JTable(rowDataSpot, SPTBatch_.columnNamesSpot);
<                         SPTBatch_.this.exportToCSV(rowDataSpot, SPTBatch_.columnNamesSpot, new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Spots in tracks statistics" + ".csv"));
<                         rtSpotPerImage = new ResultsTable();
< 
<                         for(jxxxx = 0; jxxxx < rowDataSpot.length; ++jxxxx) {
<                            for(y = 0; y < rowDataSpot[jxxxx].length; ++y) {
<                               rtSpotPerImage.setValue(SPTBatch_.columnNamesSpot[y], jxxxx, rowDataSpot[jxxxx][y]);
<                            }
<                         }
< 
<                         SPTBatch_.this.rtSpots[SPTBatch_.i] = rtSpotPerImage;
<                      }
<                   }
< 
<                   if (SPTBatch_.this.enableLinkTable.equals("linkTable")) {
<                      branchTable = SPTBatch_.this.createEdgeTable(SPTBatch_.model, SPTBatch_.this.ds);
<                      SPTBatch_.linkJTable = branchTable.getTable();
< 
<                      try {
<                         branchTable.exportToCsv(new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Links in tracks statistics" + ".csv"));
<                      } catch (IOException var136) {
<                         var136.printStackTrace();
<                      }
<                   }
< 
<                   if (SPTBatch_.checkExcludeTracks.isSelected()) {
<                      SPTBatch_.this.excludeTrack = new ArrayList();
<                      SPTBatch_.impMainRoi = ZProjector.run(SPTBatch_.impsSubBg.duplicate(), "max");
<                      ImagePlus impToMeasure = SPTBatch_.impMainRoi.duplicate();
<                      IJ.run(SPTBatch_.impMainRoi, "Auto Threshold", "method=Otsu ignore_black white");
<                      SPTBatch_.impMainRoi = new ImagePlus(SPTBatch_.impMainRoi.getTitle(), Morphology.dilation(SPTBatch_.impMainRoi.getProcessor(), Shape.DISK.fromRadius(2)));
<                      IJ.run(SPTBatch_.impMainRoi, "Invert LUT", "");
<                      IJ.run(SPTBatch_.impMainRoi, "Fill Holes", "");
<                      IJ.run(SPTBatch_.impMainRoi, "Invert LUT", "");
<                      IJ.run(SPTBatch_.impMainRoi, "Create Selection", "");
<                      Roi roiToMeasure = SPTBatch_.impMainRoi.getRoi();
<                      IJ.run(SPTBatch_.impMainRoi, "Make Inverse", "");
<                      Roi roiToMeasureInv = SPTBatch_.impMainRoi.getRoi();
<                      impToMeasure.setRoi(roiToMeasure);
<                      double meanDirectxx = SPTBatch_.impMainRoi.getStatistics().mean;
<                      impToMeasure.setRoi(roiToMeasureInv);
<                      double meanInvx = SPTBatch_.impMainRoi.getStatistics().mean;
<                      Roi mainRoi;
<                      if (meanDirectxx > meanInvx) {
<                         mainRoi = roiToMeasure;
<                      } else {
<                         mainRoi = roiToMeasureInv;
<                      }
< 
<                      for(jxxxx = 0; jxxxx < SPTBatch_.trackJTable.getRowCount(); ++jxxxx) {
<                         if (mainRoi.contains((int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(SPTBatch_.trackJTable.getModel().getValueAt(jxxxx, SPTBatch_.trackJTable.convertColumnIndexToModel(13)).toString())), (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(SPTBatch_.trackJTable.getModel().getValueAt(jxxxx, SPTBatch_.trackJTable.convertColumnIndexToModel(14)).toString()))) == Boolean.TRUE) {
<                            SPTBatch_.this.excludeTrack.add(true);
<                         } else {
<                            SPTBatch_.this.excludeTrack.add(false);
<                         }
<                      }
<                   }
< 
<                   if (SPTBatch_.this.enableTrackTable.equals("trackTable")) {
<                      Thread tracksThread = new Thread(new Runnable() {
<                         public void run() {
<                            TablePanel trackTable;
<                            int r;
<                            int t;
<                            int rxx;
<                            int j;
<                            String var10001;
<                            int rxxx;
<                            int y;
<                            if (SPTBatch_.checkboxSubBg.isSelected()) {
<                               trackTable = SPTBatch_.this.createTrackTable(SPTBatch_.model, SPTBatch_.this.ds);
<                               SPTBatch_.trackJTable = trackTable.getTable();
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                                  SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + ")", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                                  SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + ")", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement", "Track within Cell"};
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                                  SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                                  SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement", "Track within Cell"};
<                               }
< 
<                               String[][] rowDataTrack = new String[SPTBatch_.trackJTable.getRowCount()][SPTBatch_.columnNamesTrack.length];
< 
<                               for(r = 0; r < SPTBatch_.trackJTable.getRowCount(); ++r) {
<                                  rowDataTrack[r][SPTBatch_.columnNamesTrack.length - 1] = "";
< 
<                                  for(t = 0; t < SPTBatch_.trackJTable.getColumnCount(); ++t) {
<                                     rowDataTrack[r][t] = String.valueOf(SPTBatch_.trackJTable.getValueAt(r, t));
<                                  }
<                               }
< 
<                               List<Integer> nOfTracks = new ArrayList();
< 
<                               for(t = 0; t < SPTBatch_.trackJTable.getRowCount(); ++t) {
<                                  nOfTracks.add(Integer.valueOf(SPTBatch_.trackJTable.getValueAt(t, 2).toString()));
<                               }
< 
<                               List<Double> allTracks = new ArrayList();
<                               List<Double> allTracksDef = new ArrayList();
< 
<                               for(rxx = 0; rxx < nOfTracks.size(); ++rxx) {
<                                  int counter = false;
<                                  List<Double> perTrack = new ArrayList();
<                                  List<Double> perTrackDef = new ArrayList();
< 
<                                  for(j = 0; j < SPTBatch_.tableSpot.getRowCount(); ++j) {
<                                     if (Integer.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(j, 2).toString()).equals(nOfTracks.get(rxx)) == Boolean.TRUE) {
<                                        perTrack.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(j, SPTBatch_.tableSpot.getColumnCount() - 1).toString()));
<                                     }
<                                  }
< 
<                                  if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE) {
<                                     for(j = SPTBatch_.minTracksJTF; j < SPTBatch_.maxTracksJTF; ++j) {
<                                        perTrackDef.add((Double)perTrack.get(j));
<                                     }
<                                  }
< 
<                                  if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE && perTrackDef.size() != 0) {
<                                     allTracksDef.add(perTrackDef.stream().mapToDouble((a) -> {
<                                        return a;
<                                     }).average().getAsDouble());
<                                  }
< 
<                                  if (perTrack.size() != 0) {
<                                     allTracks.add(perTrack.stream().mapToDouble((a) -> {
<                                        return a;
<                                     }).average().getAsDouble());
<                                  }
<                               }
< 
<                               ComputeMSD values = new ComputeMSD();
<                               values.Compute(nOfTracks, SPTBatch_.this.rtSpots[SPTBatch_.i]);
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                                  for(rxxx = 0; rxxx < SPTBatch_.trackJTable.getRowCount(); ++rxxx) {
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 13] = String.valueOf(((Double)ComputeMSD.msd1Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 12] = String.valueOf(((Double)ComputeMSD.msd2Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)ComputeMSD.msd3Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 10] = String.valueOf(((Double)ComputeMSD.msdValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 9] = String.valueOf(((Double)allTracks.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 8] = String.valueOf(((Double)ComputeMSD.diffValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString());
<                                     if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(rxxx, 3).toString()) >= Double.valueOf((double)SPTBatch_.thLengthJTF)) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Long");
<                                     } else {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Short");
<                                     }
< 
<                                     if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "Diff") {
<                                        if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) <= SPTBatch_.this.thD14JTF) {
<                                           rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Immobile");
<                                        }
< 
<                                        if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) > SPTBatch_.this.thD14JTF) {
<                                           rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Mobile");
<                                        }
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString());
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.6D && Double.valueOf(ComputeMSD.alphaValues.toString()) >= 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Confined");
<                                     }
< 
<                                     if (Double.valueOf(ComputeMSD.alphaValues.toString()) < 0.9D && Double.valueOf(ComputeMSD.alphaValues.toString()) >= 0.6D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Anomalous");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 1.1D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.9D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Free");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 1.1D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Directed");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = String.valueOf(ComputeMSD.mssValues.get(rxxx));
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Unidirectional Ballistic";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Immobile";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) >= 0.45D && (Double)ComputeMSD.mssValues.get(rxxx) <= 0.55D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Free";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.0D && (Double)ComputeMSD.mssValues.get(rxxx) < 0.45D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Confined";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.55D && (Double)ComputeMSD.mssValues.get(rxxx) < 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Directed";
<                                     }
<                                  }
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                                  for(rxxx = 0; rxxx < SPTBatch_.trackJTable.getRowCount(); ++rxxx) {
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 14] = String.valueOf(((Double)ComputeMSD.msd1Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 13] = String.valueOf(((Double)ComputeMSD.msd2Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 12] = String.valueOf(((Double)ComputeMSD.msd3Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)ComputeMSD.msdValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 10] = String.valueOf(((Double)allTracks.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 9] = String.valueOf(((Double)ComputeMSD.diffValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 8] = String.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString());
<                                     if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(rxxx, 3).toString()) >= Double.valueOf((double)SPTBatch_.thLengthJTF)) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf("Long");
<                                     } else {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf("Short");
<                                     }
< 
<                                     if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "Diff") {
<                                        if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) <= SPTBatch_.this.thD14JTF) {
<                                           rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Immobile");
<                                        }
< 
<                                        if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) > SPTBatch_.this.thD14JTF) {
<                                           rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Mobile");
<                                        }
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString());
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.6D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Confined");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.9D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.6D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Anomalous");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 1.1D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.9D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Free");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 1.1D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Directed");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf(ComputeMSD.mssValues.get(rxxx));
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Unidirectional Ballistic";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Immobile";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) >= 0.45D && (Double)ComputeMSD.mssValues.get(rxxx) <= 0.55D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Free";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.0D && (Double)ComputeMSD.mssValues.get(rxxx) < 0.45D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Confined";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.55D && (Double)ComputeMSD.mssValues.get(rxxx) < 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Directed";
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = ((Boolean)SPTBatch_.this.excludeTrack.get(rxxx)).toString();
<                                  }
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                                  for(rxxx = 0; rxxx < SPTBatch_.trackJTable.getRowCount(); ++rxxx) {
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 14] = String.valueOf(((Double)ComputeMSD.msd1Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 13] = String.valueOf(((Double)ComputeMSD.msd2Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 12] = String.valueOf(((Double)ComputeMSD.msd3Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)ComputeMSD.msdValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)ComputeMSD.msdValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 10] = String.valueOf(((Double)allTracks.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 9] = String.valueOf(((Double)allTracksDef.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 8] = String.valueOf(((Double)ComputeMSD.diffValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString());
<                                     if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(rxxx, 3).toString()) >= Double.valueOf((double)SPTBatch_.thLengthJTF)) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Long");
<                                     } else {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Short");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) <= SPTBatch_.this.thD14JTF) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Immobile");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) > SPTBatch_.this.thD14JTF) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Mobile");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString());
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.6D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Confined");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.9D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.6D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Anomalous");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 1.1D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.9D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Free");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 1.1D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Directed");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = String.valueOf(ComputeMSD.mssValues.get(rxxx));
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Unidirectional Ballistic";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Immobile";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) >= 0.45D && (Double)ComputeMSD.mssValues.get(rxxx) <= 0.55D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Free";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.0D && (Double)ComputeMSD.mssValues.get(rxxx) < 0.45D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Confined";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.55D && (Double)ComputeMSD.mssValues.get(rxxx) < 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = "Directed";
<                                     }
<                                  }
<                               }
< 
<                               if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE && SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                                  SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + ")", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement", "Track within Cell"};
< 
<                                  for(rxxx = 0; rxxx < SPTBatch_.trackJTable.getRowCount(); ++rxxx) {
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 15] = String.valueOf(((Double)ComputeMSD.msd1Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 14] = String.valueOf(((Double)ComputeMSD.msd2Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 13] = String.valueOf(((Double)ComputeMSD.msd3Values.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 12] = String.valueOf(((Double)ComputeMSD.msdValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)allTracks.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 10] = String.valueOf(((Double)allTracksDef.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 9] = String.valueOf(((Double)ComputeMSD.diffValues.get(rxxx)).toString());
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 8] = String.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString());
<                                     if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(rxxx, 3).toString()) >= Double.valueOf((double)SPTBatch_.thLengthJTF)) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf("Long");
<                                     } else {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf("Short");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) <= SPTBatch_.this.thD14JTF) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Immobile");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rxxx)).toString()) > SPTBatch_.this.thD14JTF) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Mobile");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString());
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.6D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Confined");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 0.9D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.6D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Anomalous");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) < 1.1D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 0.9D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Free");
<                                     }
< 
<                                     if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rxxx)).toString()) >= 1.1D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf("Directed");
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf(ComputeMSD.mssValues.get(rxxx));
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Unidirectional Ballistic";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) == 0.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Immobile";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) >= 0.45D && (Double)ComputeMSD.mssValues.get(rxxx) <= 0.55D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Free";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.0D && (Double)ComputeMSD.mssValues.get(rxxx) < 0.45D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Confined";
<                                     }
< 
<                                     if ((Double)ComputeMSD.mssValues.get(rxxx) > 0.55D && (Double)ComputeMSD.mssValues.get(rxxx) < 1.0D) {
<                                        rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 2] = "Directed";
<                                     }
< 
<                                     rowDataTrack[rxxx][SPTBatch_.columnNamesTrack.length - 1] = ((Boolean)SPTBatch_.this.excludeTrack.get(rxxx)).toString();
<                                  }
<                               }
< 
<                               SPTBatch_.this.rtTrackPerImage = new ResultsTable();
< 
<                               for(rxxx = 0; rxxx < rowDataTrack.length; ++rxxx) {
<                                  for(y = 0; y < rowDataTrack[rxxx].length; ++y) {
<                                     var10001 = SPTBatch_.columnNamesTrack[y];
<                                     SPTBatch_.this.rtTrackPerImage.setValue(var10001, rxxx, rowDataTrack[rxxx][y]);
<                                  }
<                               }
< 
<                               try {
<                                  SPTBatch_.this.rtTrackPerImage.saveAs(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Tracks statistics" + ".csv");
<                               } catch (IOException var19) {
<                                  var19.printStackTrace();
<                               }
< 
<                               SPTBatch_.this.rtTracks[SPTBatch_.i] = SPTBatch_.this.rtTrackPerImage;
<                            }
< 
<                            int rx;
<                            if (!SPTBatch_.checkboxSubBg.isSelected()) {
<                               trackTable = SPTBatch_.this.createTrackTable(SPTBatch_.model, SPTBatch_.this.ds);
<                               ComputeMSD valuesx = new ComputeMSD();
<                               valuesx.Compute(SPTBatch_.nOfTracks, SPTBatch_.this.rtSpots[SPTBatch_.i]);
<                               JTable trackJTable = trackTable.getTable();
<                               SPTBatch_.columnNamesTrack = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<                               String[][] rowDataTrackx = new String[trackJTable.getModel().getRowCount()][SPTBatch_.columnNamesTrack.length];
< 
<                               for(rx = 0; rx < trackJTable.getModel().getRowCount(); ++rx) {
<                                  for(rxx = 0; rxx < trackJTable.getModel().getColumnCount(); ++rxx) {
<                                     rowDataTrackx[rx][rxx] = String.valueOf(trackJTable.getModel().getValueAt(rx, rxx));
<                                  }
<                               }
< 
<                               for(rx = 0; rx < trackJTable.getModel().getRowCount(); ++rx) {
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 12] = String.valueOf(((Double)ComputeMSD.msd1Values.get(rx)).toString());
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 11] = String.valueOf(((Double)ComputeMSD.msd2Values.get(rx)).toString());
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 10] = String.valueOf(((Double)ComputeMSD.msd3Values.get(rx)).toString());
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 9] = String.valueOf(((Double)ComputeMSD.msdValues.get(rx)).toString());
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 8] = String.valueOf(((Double)ComputeMSD.diffValues.get(rx)).toString());
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 7] = String.valueOf(((Double)ComputeMSD.d14Values.get(rx)).toString());
<                                  if (Double.valueOf(trackJTable.getModel().getValueAt(rx, 3).toString()) >= Double.valueOf((double)SPTBatch_.thLengthJTF)) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Long");
<                                  } else {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Short");
<                                  }
< 
<                                  if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rx)).toString()) <= SPTBatch_.this.thD14JTF) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Immobile");
<                                  }
< 
<                                  if (Double.valueOf(((Double)ComputeMSD.d14Values.get(rx)).toString()) > SPTBatch_.this.thD14JTF) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Mobile");
<                                  }
< 
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 4] = String.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString());
<                                  if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) < 0.6D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) >= 0.0D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Confined");
<                                  }
< 
<                                  if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) < 0.9D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) >= 0.6D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Anomalous");
<                                  }
< 
<                                  if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) < 1.1D && Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) >= 0.9D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Free");
<                                  }
< 
<                                  if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(rx)).toString()) >= 1.1D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Directed");
<                                  }
< 
<                                  rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 2] = String.valueOf(ComputeMSD.mssValues.get(rx));
<                                  if ((Double)ComputeMSD.mssValues.get(rx) == 1.0D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 1] = "Unidirectional Ballistic";
<                                  }
< 
<                                  if ((Double)ComputeMSD.mssValues.get(rx) == 0.0D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 1] = "Immobile";
<                                  }
< 
<                                  if ((Double)ComputeMSD.mssValues.get(rx) >= 0.45D && (Double)ComputeMSD.mssValues.get(rx) <= 0.55D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 1] = "Free";
<                                  }
< 
<                                  if ((Double)ComputeMSD.mssValues.get(rx) > 0.0D && (Double)ComputeMSD.mssValues.get(rx) < 0.45D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 1] = "Confined";
<                                  }
< 
<                                  if ((Double)ComputeMSD.mssValues.get(rx) > 0.55D && (Double)ComputeMSD.mssValues.get(rx) < 1.0D) {
<                                     rowDataTrackx[rx][SPTBatch_.columnNamesTrack.length - 1] = "Directed";
<                                  }
<                               }
< 
<                               SPTBatch_.this.rtTrackPerImage = new ResultsTable();
< 
<                               for(rx = 0; rx < rowDataTrackx.length; ++rx) {
<                                  for(rxx = 0; rxx < rowDataTrackx[rx].length; ++rxx) {
<                                     var10001 = SPTBatch_.columnNamesTrack[rxx];
<                                     SPTBatch_.this.rtTrackPerImage.setValue(var10001, rx, rowDataTrackx[rx][rxx]);
<                                  }
<                               }
< 
<                               try {
<                                  SPTBatch_.this.rtTrackPerImage.saveAs(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Tracks statistics" + ".csv");
<                               } catch (IOException var18) {
<                                  var18.printStackTrace();
<                               }
< 
<                               SPTBatch_.this.rtTracks[SPTBatch_.i] = SPTBatch_.this.rtTrackPerImage;
<                            }
< 
<                            String[][] rowData = new String[4][SPTBatch_.this.columnsMovements.length];
<                            int totalTracks = false;
<                            r = 0;
<                            t = 0;
<                            rx = 0;
<                            rxx = 0;
<                            rxxx = 0;
<                            y = 0;
<                            int shortTracks = 0;
<                            j = 0;
<                            int shortAnom = 0;
<                            int shortFree = 0;
<                            int shortDirect = 0;
< 
<                            for(int rxxxx = 0; rxxxx < SPTBatch_.this.rtTrackPerImage.size(); ++rxxxx) {
<                               if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Long")) {
<                                     ++r;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Short")) {
<                                     ++shortTracks;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx).equals("Confined") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Long")) {
<                                     ++t;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx).equals("Confined") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Short")) {
<                                     ++j;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx).equals("Unidirectional Ballistic") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Long")) {
<                                     ++rx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx).equals("Anomalous") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Short")) {
<                                     ++shortAnom;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx).equals("Free") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Long")) {
<                                     ++rxx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx).equals("Free") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Short")) {
<                                     ++shortFree;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn(), rxxxx).equals("Directed") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Long")) {
<                                     ++rxxx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 2, rxxxx).equals("Directed") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Short")) {
<                                     ++shortDirect;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 4, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 4, rxxxx).equals("Immobile")) {
<                                     ++y;
<                                  }
<                               }
< 
<                               if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Long")) {
<                                     ++r;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Short")) {
<                                     ++shortTracks;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx).equals("Confined") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Long")) {
<                                     ++t;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx).equals("Confined") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Short")) {
<                                     ++j;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx).equals("Unidirectional Ballistic") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Long")) {
<                                     ++rx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx).equals("Anomalous") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Short")) {
<                                     ++shortAnom;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx).equals("Free") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Long")) {
<                                     ++rxx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx).equals("Free") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Short")) {
<                                     ++shortFree;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 1, rxxxx).equals("Directed") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Long")) {
<                                     ++rxxx;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 3, rxxxx).equals("Directed") && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 6, rxxxx).equals("Short")) {
<                                     ++shortDirect;
<                                  }
< 
<                                  if (SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx) != null && SPTBatch_.this.rtTrackPerImage.getStringValue(SPTBatch_.this.rtTrackPerImage.getLastColumn() - 5, rxxxx).equals("Immobile")) {
<                                     ++y;
<                                  }
<                               }
<                            }
< 
<                            SPTBatch_ var10000 = SPTBatch_.this;
<                            var10000.totalTracksDef = var10000.totalTracksDef + SPTBatch_.this.rtTrackPerImage.size();
<                            var10000 = SPTBatch_.this;
<                            var10000.longTracksDef = var10000.longTracksDef + r;
<                            var10000 = SPTBatch_.this;
<                            var10000.longConfinedDef = var10000.longConfinedDef + t;
<                            var10000 = SPTBatch_.this;
<                            var10000.longUniBalDef = var10000.longUniBalDef + rx;
<                            var10000 = SPTBatch_.this;
<                            var10000.longFreeDef = var10000.longFreeDef + rxx;
<                            var10000 = SPTBatch_.this;
<                            var10000.longDirectDef = var10000.longDirectDef + rxxx;
<                            var10000 = SPTBatch_.this;
<                            var10000.shortTracksDef = var10000.shortTracksDef + shortTracks;
<                            var10000 = SPTBatch_.this;
<                            var10000.shortConfinedDef = var10000.shortConfinedDef + j;
<                            var10000 = SPTBatch_.this;
<                            var10000.shortAnomDef = var10000.shortAnomDef + shortAnom;
<                            var10000 = SPTBatch_.this;
<                            var10000.shortFreeDef = var10000.shortFreeDef + shortFree;
<                            var10000 = SPTBatch_.this;
<                            var10000.shortDirectDef = var10000.shortDirectDef + shortDirect;
<                            var10000 = SPTBatch_.this;
<                            var10000.immobDef = var10000.immobDef + y;
<                            rowData[0][0] = String.valueOf(SPTBatch_.this.rtTrackPerImage.size());
<                            rowData[1][0] = String.valueOf("");
<                            rowData[2][0] = String.valueOf("");
<                            rowData[3][0] = String.valueOf("");
<                            rowData[0][1] = String.valueOf(r);
<                            rowData[1][1] = String.valueOf(" ");
<                            rowData[2][1] = String.valueOf("Short Tracks");
<                            rowData[3][1] = String.valueOf(shortTracks);
<                            rowData[0][2] = String.valueOf(t);
<                            rowData[1][2] = String.valueOf(" ");
<                            rowData[2][2] = String.valueOf("Short Confined");
<                            rowData[3][2] = String.valueOf(j);
<                            rowData[0][3] = String.valueOf(rx);
<                            rowData[1][3] = String.valueOf(" ");
<                            rowData[2][3] = String.valueOf("Short Anomalous");
<                            rowData[3][3] = String.valueOf(shortAnom);
<                            rowData[0][4] = String.valueOf(rxx);
<                            rowData[1][4] = String.valueOf(" ");
<                            rowData[2][4] = String.valueOf("Short Free");
<                            rowData[3][4] = String.valueOf(shortFree);
<                            rowData[0][5] = String.valueOf(rxxx);
<                            rowData[1][5] = String.valueOf(" ");
<                            rowData[2][5] = String.valueOf("Short Direct");
<                            rowData[3][5] = String.valueOf(shortDirect);
<                            rowData[0][6] = String.valueOf(y);
<                            rowData[1][6] = String.valueOf("");
<                            rowData[2][6] = String.valueOf("");
<                            rowData[3][6] = String.valueOf("");
<                            ResultsTable rtTrackSum = new ResultsTable();
< 
<                            for(int rxxxxx = 0; rxxxxx < rowData.length; ++rxxxxx) {
<                               for(int c = 0; c < rowData[rxxxxx].length; ++c) {
<                                  rtTrackSum.setValue(SPTBatch_.this.columnsMovements[c], rxxxxx, rowData[rxxxxx][c]);
<                               }
<                            }
< 
<                            try {
<                               rtTrackSum.saveAs(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "SummaryTracks" + ".csv");
<                            } catch (IOException var17) {
<                               var17.printStackTrace();
<                            }
< 
<                            if (SPTBatch_.checkPBS.isSelected()) {
<                               (new PhotobleachingSpotPlot()).Compute();
<                            }
< 
<                         }
<                      });
<                      tracksThread.start();
<                   }
< 
<                   if (SPTBatch_.this.enableBranchTable.equals("branchTable")) {
<                      branchTable = SPTBatch_.createBranchTable(SPTBatch_.model, SPTBatch_.selectionModel);
< 
<                      try {
<                         branchTable.exportToCsv(new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Branch analysis" + ".csv"));
<                      } catch (IOException var135) {
<                         var135.printStackTrace();
<                      }
<                   }
<                }
< 
<                ArrayList edges;
<                if (SPTBatch_.checkboxSP.isSelected() == Boolean.TRUE) {
<                   SPTBatch_.directChemo = new File(SPTBatch_.directImages.getAbsolutePath() + File.separator + "Chemotaxis_Analysis");
<                   if (!SPTBatch_.directChemo.exists()) {
<                      SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directChemo.getName());
<                      result = false;
< 
<                      try {
<                         SPTBatch_.directChemo.mkdir();
<                         result = true;
<                      } catch (SecurityException var134) {
<                      }
< 
<                      if (result) {
<                         SPTBatch_.taskOutput.append("DIR created");
<                      }
<                   }
< 
<                   TablePanel<Spot> spotTable = SPTBatch_.this.createSpotTable(SPTBatch_.model, SPTBatch_.this.ds);
<                   JTable spotJTable = spotTable.getTable();
<                   edges = new ArrayList();
<                   Set<Integer> trackIDs = SPTBatch_.model.getTrackModel().trackIDs(true);
<                   chartx = null;
<                   Iterator var242 = trackIDs.iterator();
< 
<                   while(true) {
<                      if (!var242.hasNext()) {
<                         Chemotaxis_ToolModified chemotool = new Chemotaxis_ToolModified(edges);
<                         chemotool.run("");
<                         break;
<                      }
< 
<                      Integer id = (Integer)var242.next();
<                      Set<Spot> track = SPTBatch_.model.getTrackModel().trackSpots(id);
<                      framesByTrack = new ArrayList();
<                      ArrayList<Float> xByTrack = new ArrayList();
<                      framesByTrackx = new ArrayList();
<                      framesByTrackSort = new ArrayList();
<                      new ArrayList();
<                      new ArrayList();
<                      ArrayList<Float> trackIDxxxx = new ArrayList();
<                      ArrayList<Integer> indexes = new ArrayList();
<                      Iterator var81 = track.iterator();
< 
<                      while(var81.hasNext()) {
<                         Spot spot = (Spot)var81.next();
<                         trackIDxxxx.add(Float.valueOf((float)id) + Float.valueOf("1.0"));
<                         framesByTrack.add(Float.valueOf(spot.getFeature("FRAME").toString()));
<                         xByTrack.add(Float.valueOf(spot.getFeature("POSITION_X").toString()));
<                         framesByTrackx.add(Float.valueOf(spot.getFeature("POSITION_Y").toString()));
<                         framesByTrackSort.add(Float.valueOf(spot.getFeature("FRAME").toString()));
<                      }
< 
<                      Collections.sort(framesByTrackSort);
< 
<                      int yx;
<                      for(yx = 0; yx < framesByTrackSort.size(); ++yx) {
<                         indexes.add(framesByTrack.indexOf(framesByTrackSort.get(yx)));
<                      }
< 
<                      for(yx = 0; yx < indexes.size(); ++yx) {
<                         edges.add((Float)trackIDxxxx.get(yx));
<                         edges.add((Float)framesByTrackSort.get(yx) + Float.valueOf("1.0"));
<                         edges.add((Float)xByTrack.get((Integer)indexes.get(yx)));
<                         edges.add((Float)framesByTrackx.get((Integer)indexes.get(yx)));
<                      }
<                   }
<                }
< 
<                if (SPTBatch_.checkboxDiff.isSelected() == Boolean.TRUE) {
<                   SPTBatch_.directDiff = new File(SPTBatch_.directImages.getAbsolutePath() + File.separator + "Trajectory_Classifier");
<                   if (!SPTBatch_.directDiff.exists()) {
<                      SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directDiff.getName());
<                      result = false;
< 
<                      try {
<                         SPTBatch_.directDiff.mkdir();
<                         result = true;
<                      } catch (SecurityException var133) {
<                      }
< 
<                      if (result) {
<                         SPTBatch_.taskOutput.append("DIR created");
<                      }
<                   }
< 
<                   TraJClassifierTest_ tc = new TraJClassifierTest_();
<                   tc.run("");
<                }
< 
<                if (SPTBatch_.checkboxMSD.isSelected() == Boolean.TRUE) {
<                   TrackProcessorMSD_Modified msdPlot = new TrackProcessorMSD_Modified();
<                   msdPlot.Compute(SPTBatch_.nOfTracks, SPTBatch_.this.rtSpots[SPTBatch_.i]);
<                }
< 
<                if (SPTBatch_.checkCluster.isSelected() == Boolean.TRUE) {
<                   ClusterSizeAnalysis clusterAnal = new ClusterSizeAnalysis();
<                   DefaultCategoryDataset barDatasetCount = new DefaultCategoryDataset();
<                   DefaultCategoryDataset barDatasetPercet = new DefaultCategoryDataset();
<                   counter1 = 0;
<                   int counter2 = 0;
<                   maxFrame = 0;
<                   counter4 = 0;
<                   counter = 0;
<                   n = 0;
<                   framex = 0;
<                   jxxxx = 0;
<                   y = 0;
<                   counter10 = 0;
<                   int r = 0;
< 
<                   while(true) {
<                      if (r >= SPTBatch_.nOfTracks.size()) {
<                         barDatasetCount.setValue((double)counter1, "receptors/particle", "1");
<                         barDatasetCount.setValue((double)counter2, "receptors/particle", "2");
<                         barDatasetCount.setValue((double)maxFrame, "receptors/particle", "3");
<                         barDatasetCount.setValue((double)counter4, "receptors/particle", "4");
<                         barDatasetCount.setValue((double)counter, "receptors/particle", "5");
<                         barDatasetCount.setValue((double)n, "receptors/particle", "6");
<                         barDatasetCount.setValue((double)framex, "receptors/particle", "7");
<                         barDatasetCount.setValue((double)jxxxx, "receptors/particle", "8");
<                         barDatasetCount.setValue((double)y, "receptors/particle", "9");
<                         barDatasetCount.setValue((double)counter10, "receptors/particle", "10");
<                         JFreeChart chartCount = ChartFactory.createBarChart("Count of receptors/particle", "receptors/particle", "Count", barDatasetCount, PlotOrientation.VERTICAL, false, true, false);
<                         if (SPTBatch_.nOfTracks.size() != 0) {
<                            barDatasetPercet.setValue((double)(counter1 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "1");
<                            barDatasetPercet.setValue((double)(counter2 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "2");
<                            barDatasetPercet.setValue((double)(maxFrame * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "3");
<                            barDatasetPercet.setValue((double)(counter4 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "4");
<                            barDatasetPercet.setValue((double)(counter * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "5");
<                            barDatasetPercet.setValue((double)(n * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "6");
<                            barDatasetPercet.setValue((double)(framex * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "7");
<                            barDatasetPercet.setValue((double)(jxxxx * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "8");
<                            barDatasetPercet.setValue((double)(y * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "9");
<                            barDatasetPercet.setValue((double)(counter10 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "10");
<                         }
< 
<                         if (SPTBatch_.nOfTracks.size() != 0) {
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "1");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "2");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "3");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "4");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "5");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "6");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "7");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "8");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "9");
<                            barDatasetPercet.setValue(0.0D, "receptors/particle", "10");
<                         }
< 
<                         JFreeChart chartPercet = ChartFactory.createBarChart("Percentage of receptors/particle", "receptors/particle", "Percentage-(%)", barDatasetPercet, PlotOrientation.VERTICAL, false, true, false);
<                         DecimalFormat pctFormat = new DecimalFormat("##.00%");
<                         pctFormat.setMultiplier(1);
<                         NumberFormat percent = NumberFormat.getPercentInstance();
<                         percent.setMaximumFractionDigits(2);
<                         CategoryItemLabelGenerator generatorCount = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getInstance(), percent);
<                         CategoryItemLabelGenerator generatorPercent = new StandardCategoryItemLabelGenerator("{2}", pctFormat);
<                         CategoryPlot plotCount = chartCount.getCategoryPlot();
<                         CategoryPlot plotPercent = chartPercet.getCategoryPlot();
<                         CategoryItemRenderer rendererCount = plotCount.getRenderer();
<                         CategoryItemRenderer rendererPercent = plotPercent.getRenderer();
<                         NumberAxis rangeAxisCount = (NumberAxis)plotCount.getRangeAxis();
<                         NumberAxis rangeAxisPercent = (NumberAxis)plotPercent.getRangeAxis();
<                         rangeAxisPercent.setNumberFormatOverride(pctFormat);
<                         rangeAxisCount.setAutoRangeIncludesZero(true);
<                         rangeAxisPercent.setAutoRangeIncludesZero(true);
<                         rendererCount.setDefaultItemLabelGenerator(generatorCount);
<                         rendererCount.setDefaultItemLabelFont(new Font("SansSerif", 0, 12));
<                         rendererCount.setDefaultItemLabelsVisible(true);
<                         rendererPercent.setDefaultItemLabelGenerator(generatorPercent);
<                         rendererPercent.setDefaultItemLabelFont(new Font("SansSerif", 0, 12));
<                         rendererPercent.setDefaultItemLabelsVisible(true);
< 
<                         try {
<                            ChartUtils.saveChartAsPNG(new File(SPTBatch_.directCluster.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_ReceptorsPerParticle_Count" + ".png"), chartCount, 500, 400);
<                         } catch (IOException var132) {
<                            var132.printStackTrace();
<                         }
< 
<                         try {
<                            ChartUtils.saveChartAsPNG(new File(SPTBatch_.directCluster.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_ReceptorsPerParticle_Percentage" + ".png"), chartPercet, 500, 400);
<                         } catch (IOException var131) {
<                            var131.printStackTrace();
<                         }
<                         break;
<                      }
< 
<                      int counterx = false;
<                      List<Double> perTrack = new ArrayList();
< 
<                      for(int t = 0; t < SPTBatch_.tableSpot.getRowCount(); ++t) {
<                         if (Integer.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t, 2).toString()).equals(SPTBatch_.nOfTracks.get(r)) == Boolean.TRUE) {
<                            perTrack.add(Double.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t, SPTBatch_.tableSpot.getColumnCount() - 1).toString()));
<                         }
<                      }
< 
<                      clusterAnal.Compute(perTrack, (Integer)SPTBatch_.nOfTracks.get(r));
<                      double[] values = new double[perTrack.size()];
< 
<                      for(int jxxx = 0; jxxx < perTrack.size(); ++jxxx) {
<                         values[jxxx] = (Double)perTrack.get(jxxx);
<                      }
< 
<                      GaussianMixtureModified gm2 = GaussianMixtureModified.fit(values);
<                      if (gm2.components.length == 1) {
<                         ++counter1;
<                      }
< 
<                      if (gm2.components.length == 2) {
<                         ++counter2;
<                      }
< 
<                      if (gm2.components.length == 3) {
<                         ++maxFrame;
<                      }
< 
<                      if (gm2.components.length == 4) {
<                         ++counter4;
<                      }
< 
<                      if (gm2.components.length == 5) {
<                         ++counter;
<                      }
< 
<                      if (gm2.components.length == 6) {
<                         ++n;
<                      }
< 
<                      if (gm2.components.length == 7) {
<                         ++framex;
<                      }
< 
<                      if (gm2.components.length == 8) {
<                         ++jxxxx;
<                      }
< 
<                      if (gm2.components.length == 9) {
<                         ++y;
<                      }
< 
<                      if (gm2.components.length == 10) {
<                         ++counter10;
<                      }
< 
<                      ++r;
<                   }
<                }
< 
<                if (SPTBatch_.checkboxPlot.isSelected() == Boolean.TRUE) {
<                   List<Spot> spots1 = new ArrayList(SPTBatch_.this.trackmate.getModel().getSpots().getNSpots(true));
<                   Set<String> ySelectedSpotSet = new HashSet();
<                   ySelectedSpotSet.add(SPTBatch_.this.ySelectedSpot);
<                   Iterator var223 = SPTBatch_.this.trackmate.getModel().getTrackModel().trackIDs(true).iterator();
< 
<                   while(var223.hasNext()) {
<                      Integer trackIDx = (Integer)var223.next();
<                      spots1.addAll(SPTBatch_.this.trackmate.getModel().getTrackModel().trackSpots(trackIDx));
<                   }
< 
<                   String yAxisLabelx;
<                   if (SPTBatch_.ESP.isSelected() && SPTBatch_.this.xSelectedSpot != null && ySelectedSpotSet != null) {
<                      chart = null;
<                      XYPlot plot = null;
<                      Dimension xDimension = (Dimension)SPTBatch_.model.getFeatureModel().getSpotFeatureDimensions().get(SPTBatch_.this.xSelectedSpot);
<                      Map<String, Dimension> yDimensions = SPTBatch_.model.getFeatureModel().getSpotFeatureDimensions();
<                      Map<String, String> featureNames = SPTBatch_.model.getFeatureModel().getSpotFeatureNames();
<                      xAxisLabelx = (String)featureNames.get(SPTBatch_.this.xSelectedSpot) + " (" + TMUtils.getUnitsFor(xDimension, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits()) + ")";
<                      Set<Dimension> dimensions = SPTBatch_.this.getUniqueValues(ySelectedSpotSet, yDimensions);
<                      new ArrayList(dimensions.size());
<                      Iterator var288 = dimensions.iterator();
< 
<                      while(var288.hasNext()) {
<                         Dimension dimensionxx = (Dimension)var288.next();
<                         String yAxisLabel = TMUtils.getUnitsFor(dimensionxx, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits());
<                         List<String> featuresThisDimension = SPTBatch_.getCommonKeys(dimensionxx, ySelectedSpotSet, yDimensions);
<                         yAxisLabelx = SPTBatch_.this.buildPlotTitle(featuresThisDimension, featureNames, SPTBatch_.this.xSelectedSpot);
<                         ModelDataset datasetxx = new SpotCollectionDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, SPTBatch_.this.xSelectedSpot, featuresThisDimension, spots1, true);
<                         XYItemRenderer renderer = datasetxx.getRenderer();
<                         JFreeChart chartxx = ChartFactory.createXYLineChart(yAxisLabelx, xAxisLabelx, yAxisLabel, datasetxx, PlotOrientation.VERTICAL, true, true, false);
<                         chartxx.getTitle().setFont(Fonts.FONT);
<                         chartxx.getLegend().setItemFont(Fonts.SMALL_FONT);
<                         chartxx.setBackgroundPaint(new Color(220, 220, 220));
<                         chartxx.setBorderVisible(false);
<                         chartxx.getLegend().setBackgroundPaint(new Color(220, 220, 220));
<                         plot = chartxx.getXYPlot();
<                         plot.setRenderer(renderer);
<                         plot.getRangeAxis().setLabelFont(Fonts.FONT);
<                         plot.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plot.getDomainAxis().setLabelFont(Fonts.FONT);
<                         plot.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plot.setOutlineVisible(false);
<                         plot.setDomainCrosshairVisible(false);
<                         plot.setDomainGridlinesVisible(false);
<                         plot.setRangeCrosshairVisible(false);
<                         plot.setRangeGridlinesVisible(false);
<                         plot.setBackgroundAlpha(0.0F);
<                         ((NumberAxis)plot.getRangeAxis()).setAutoRangeIncludesZero(false);
<                         plot.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
<                         plot.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
<                      }
< 
<                      try {
<                         ChartUtils.saveChartAsPNG(new File(SPTBatch_.directSPT + File.separator + SPTBatch_.imps.getShortTitle() + "_" + SPTBatch_.this.xSelectedSpot + "-" + SPTBatch_.this.ySelectedSpot + ".png"), plot.getChart(), 500, 270);
<                      } catch (IOException var130) {
<                         var130.printStackTrace();
<                      }
<                   }
< 
<                   edges = new ArrayList();
<                   Set<String> ySelectedLinkSet = new HashSet();
<                   ySelectedLinkSet.add(SPTBatch_.this.ySelectedLink);
<                   Iterator var248 = SPTBatch_.this.trackmate.getModel().getTrackModel().trackIDs(true).iterator();
< 
<                   while(var248.hasNext()) {
<                      Integer trackIDxx = (Integer)var248.next();
<                      edges.addAll(SPTBatch_.this.trackmate.getModel().getTrackModel().trackEdges(trackIDxx));
<                   }
< 
<                   Map yDimensionsxx;
<                   if (SPTBatch_.ELP.isSelected() && SPTBatch_.this.xSelectedLink != null && ySelectedLinkSet != null) {
<                      chartx = null;
<                      XYPlot plotx = null;
<                      Dimension xDimensionx = (Dimension)SPTBatch_.model.getFeatureModel().getEdgeFeatureDimensions().get(SPTBatch_.this.xSelectedLink);
<                      Map<String, Dimension> yDimensionsx = SPTBatch_.model.getFeatureModel().getEdgeFeatureDimensions();
<                      yDimensionsxx = SPTBatch_.model.getFeatureModel().getEdgeFeatureNames();
<                      String xAxisLabelxx = (String)yDimensionsxx.get(SPTBatch_.this.xSelectedLink) + " (" + TMUtils.getUnitsFor(xDimensionx, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits()) + ")";
<                      Set<Dimension> dimensionsxxx = SPTBatch_.this.getUniqueValues(ySelectedLinkSet, yDimensionsx);
<                      new ArrayList(dimensionsxxx.size());
<                      Iterator var290 = dimensionsxxx.iterator();
< 
<                      while(var290.hasNext()) {
<                         Dimension dimension = (Dimension)var290.next();
<                         yAxisLabelx = TMUtils.getUnitsFor(dimension, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits());
<                         List<String> featuresThisDimensionx = SPTBatch_.getCommonKeys(dimension, ySelectedLinkSet, yDimensionsx);
<                         String titlex = SPTBatch_.this.buildPlotTitle(featuresThisDimensionx, yDimensionsxx, SPTBatch_.this.xSelectedLink);
<                         ModelDataset datasetxxx = new EdgeCollectionDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, SPTBatch_.this.xSelectedLink, featuresThisDimensionx, edges, true);
<                         XYItemRenderer rendererx = datasetxxx.getRenderer();
<                         JFreeChart chartxxxx = ChartFactory.createXYLineChart(titlex, xAxisLabelxx, yAxisLabelx, datasetxxx, PlotOrientation.VERTICAL, true, true, false);
<                         chartxxxx.getTitle().setFont(Fonts.FONT);
<                         chartxxxx.getLegend().setItemFont(Fonts.SMALL_FONT);
<                         chartxxxx.setBackgroundPaint(new Color(220, 220, 220));
<                         chartxxxx.setBorderVisible(false);
<                         chartxxxx.getLegend().setBackgroundPaint(new Color(220, 220, 220));
<                         plotx = chartxxxx.getXYPlot();
<                         plotx.setRenderer(rendererx);
<                         plotx.getRangeAxis().setLabelFont(Fonts.FONT);
<                         plotx.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plotx.getDomainAxis().setLabelFont(Fonts.FONT);
<                         plotx.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plotx.setOutlineVisible(false);
<                         plotx.setDomainCrosshairVisible(false);
<                         plotx.setDomainGridlinesVisible(false);
<                         plotx.setRangeCrosshairVisible(false);
<                         plotx.setRangeGridlinesVisible(false);
<                         plotx.setBackgroundAlpha(0.0F);
<                         ((NumberAxis)plotx.getRangeAxis()).setAutoRangeIncludesZero(false);
<                         plotx.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
<                         plotx.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
<                      }
< 
<                      try {
<                         ChartUtils.saveChartAsPNG(new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + SPTBatch_.this.xSelectedLink + "-" + SPTBatch_.this.ySelectedLink + ".png"), plotx.getChart(), 500, 270);
<                      } catch (IOException var129) {
<                         var129.printStackTrace();
<                      }
<                   }
< 
<                   Set<String> ySelectedTrackSet = new HashSet();
<                   ySelectedTrackSet.add(SPTBatch_.this.ySelectedTrack);
<                   String yFeature;
<                   if (SPTBatch_.ETP.isSelected() && SPTBatch_.this.xSelectedTrack != null && ySelectedTrackSet != null) {
<                      SPTBatch_.this.tracksID = new ArrayList(SPTBatch_.this.trackmate.getModel().getTrackModel().unsortedTrackIDs(true));
<                      chartxxx = null;
<                      XYPlot plotxx = null;
<                      Dimension xDimensionxx = (Dimension)SPTBatch_.model.getFeatureModel().getTrackFeatureDimensions().get(SPTBatch_.this.xSelectedTrack);
<                      yDimensionsxx = SPTBatch_.model.getFeatureModel().getTrackFeatureDimensions();
<                      Map<String, String> featureNamesx = SPTBatch_.model.getFeatureModel().getTrackFeatureNames();
<                      yFeature = (String)featureNamesx.get(SPTBatch_.this.xSelectedTrack) + " (" + TMUtils.getUnitsFor(xDimensionxx, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits()) + ")";
<                      Set<Dimension> dimensionsx = SPTBatch_.this.getUniqueValues(ySelectedTrackSet, yDimensionsxx);
<                      new ArrayList(dimensionsx.size());
<                      Iterator var295 = dimensionsx.iterator();
< 
<                      while(var295.hasNext()) {
<                         Dimension dimensionx = (Dimension)var295.next();
<                         String yAxisLabelxx = TMUtils.getUnitsFor(dimensionx, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits());
<                         List<String> featuresThisDimensionxx = SPTBatch_.getCommonKeys(dimensionx, ySelectedTrackSet, yDimensionsxx);
<                         String titlexx = SPTBatch_.this.buildPlotTitle(featuresThisDimensionxx, featureNamesx, SPTBatch_.this.xSelectedTrack);
<                         ModelDataset datasetxxxx = new TrackCollectionDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, SPTBatch_.this.xSelectedTrack, featuresThisDimensionxx, SPTBatch_.this.tracksID);
<                         XYItemRenderer rendererxx = datasetxxxx.getRenderer();
<                         JFreeChart chartxxxxx = ChartFactory.createXYLineChart(titlexx, yFeature, yAxisLabelxx, datasetxxxx, PlotOrientation.VERTICAL, true, true, false);
<                         chartxxxxx.getTitle().setFont(Fonts.FONT);
<                         chartxxxxx.getLegend().setItemFont(Fonts.SMALL_FONT);
<                         chartxxxxx.setBackgroundPaint(new Color(220, 220, 220));
<                         chartxxxxx.setBorderVisible(false);
<                         chartxxxxx.getLegend().setBackgroundPaint(new Color(220, 220, 220));
<                         plotxx = chartxxxxx.getXYPlot();
<                         plotxx.setRenderer(rendererxx);
<                         plotxx.getRangeAxis().setLabelFont(Fonts.FONT);
<                         plotxx.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plotxx.getDomainAxis().setLabelFont(Fonts.FONT);
<                         plotxx.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                         plotxx.setOutlineVisible(false);
<                         plotxx.setDomainCrosshairVisible(false);
<                         plotxx.setDomainGridlinesVisible(false);
<                         plotxx.setRangeCrosshairVisible(false);
<                         plotxx.setRangeGridlinesVisible(false);
<                         plotxx.setBackgroundAlpha(0.0F);
<                         ((NumberAxis)plotxx.getRangeAxis()).setAutoRangeIncludesZero(false);
<                         plotxx.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
<                         plotxx.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
<                      }
< 
<                      try {
<                         ChartUtils.saveChartAsPNG(new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + SPTBatch_.this.xSelectedTrack + "-" + SPTBatch_.this.ySelectedTrack + ".png"), plotxx.getChart(), 500, 270);
<                      } catch (IOException var128) {
<                         var128.printStackTrace();
<                      }
<                   }
< 
<                   maxFrame = spots.keySet().stream().mapToInt(Integer::intValue).max().getAsInt();
<                   int[] nSpots = new int[maxFrame + 1];
<                   double[] time = new double[maxFrame + 1];
<                   XYPlot plotxxx = null;
< 
<                   for(framex = 0; framex <= maxFrame; ++framex) {
<                      nSpots[framex] = spots.getNSpots(framex, true);
<                      time[framex] = (double)framex * SPTBatch_.this.settings.dt;
<                   }
< 
<                   SPTBatch_.NSpotPerFrameDataset datasetx = new SPTBatch_.NSpotPerFrameDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, time, nSpots);
<                   yFeature = "N spots";
<                   Map<String, Dimension> dimMap = new HashMap(2);
<                   dimMap.put("N spots", Dimension.NONE);
<                   dimMap.put("POSITION_T", Dimension.TIME);
<                   Map<String, String> nameMap = new HashMap(2);
<                   nameMap.put("N spots", "N spots");
<                   nameMap.put("POSITION_T", "T");
<                   String xAxisLabelxxx = (String)nameMap.get("POSITION_T") + " (" + TMUtils.getUnitsFor(Dimension.TIME, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits()) + ")";
<                   Set<Dimension> dimensionsxx = SPTBatch_.this.getUniqueValues(Collections.singletonList("N spots"), dimMap);
<                   new ArrayList(dimensionsxx.size());
<                   Iterator var322 = dimensionsxx.iterator();
< 
<                   while(var322.hasNext()) {
<                      Dimension dimensionxxx = (Dimension)var322.next();
<                      String yAxisLabelxxx = TMUtils.getUnitsFor(dimensionxxx, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits());
<                      List<String> featuresThisDimensionxxx = SPTBatch_.getCommonKeys(dimensionxxx, Collections.singletonList("N spots"), dimMap);
<                      String titlexxx = SPTBatch_.this.buildPlotTitle(featuresThisDimensionxxx, nameMap, "POSITION_T");
<                      XYItemRenderer rendererxxx = datasetx.getRenderer();
<                      JFreeChart chartxxxxxx = ChartFactory.createXYLineChart(titlexxx, xAxisLabelxxx, yAxisLabelxxx, datasetx, PlotOrientation.VERTICAL, true, true, false);
<                      chartxxxxxx.getTitle().setFont(Fonts.FONT);
<                      chartxxxxxx.getLegend().setItemFont(Fonts.SMALL_FONT);
<                      chartxxxxxx.setBackgroundPaint(new Color(220, 220, 220));
<                      chartxxxxxx.setBorderVisible(false);
<                      chartxxxxxx.getLegend().setBackgroundPaint(new Color(220, 220, 220));
<                      plotxxx = chartxxxxxx.getXYPlot();
<                      plotxxx.setRenderer(rendererxxx);
<                      plotxxx.getRangeAxis().setLabelFont(Fonts.FONT);
<                      plotxxx.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                      plotxxx.getDomainAxis().setLabelFont(Fonts.FONT);
<                      plotxxx.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
<                      plotxxx.setOutlineVisible(false);
<                      plotxxx.setDomainCrosshairVisible(false);
<                      plotxxx.setDomainGridlinesVisible(false);
<                      plotxxx.setRangeCrosshairVisible(false);
<                      plotxxx.setRangeGridlinesVisible(false);
<                      plotxxx.setBackgroundAlpha(0.0F);
<                      ((NumberAxis)plotxxx.getRangeAxis()).setAutoRangeIncludesZero(false);
<                      plotxxx.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
<                      plotxxx.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
<                   }
< 
<                   try {
<                      ChartUtils.saveChartAsPNG(new File(SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "Nspotsvs.Time" + ".png"), plotxxx.getChart(), 500, 270);
<                   } catch (IOException var127) {
<                      var127.printStackTrace();
<                   }
<                }
< 
<                if (SPTBatch_.checkbox4.isSelected() == Boolean.TRUE) {
<                   if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE) {
<                      IJ.saveAs(SPTBatch_.this.capture, "Tiff", SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]);
<                   }
< 
<                   if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE) {
<                      for(frame = 0; frame < SPTBatch_.this.excludeTrack.size(); ++frame) {
<                         int trackID = Integer.parseInt(SPTBatch_.trackJTable.getValueAt(frame, 2).toString());
<                         SPTBatch_.this.trackmate.getModel().beginUpdate();
< 
<                         try {
<                            SPTBatch_.this.trackmate.getModel().setTrackVisibility(trackID, (Boolean)SPTBatch_.this.excludeTrack.get(frame));
<                         } finally {
<                            SPTBatch_.this.trackmate.getModel().endUpdate();
<                         }
< 
<                         SPTBatch_.this.displayer.render();
<                         SPTBatch_.this.displayer.refresh();
<                      }
< 
<                      if (SPTBatch_.imps.getNFrames() > 1) {
<                         firstFrame = Math.max(1, Math.min(SPTBatch_.imps.getNFrames(), 1));
<                         lastFrame = Math.min(SPTBatch_.imps.getNFrames(), Math.max(SPTBatch_.imps.getNFrames(), 1));
<                      }
< 
<                      if (SPTBatch_.imps.getNSlices() > 1) {
<                         firstFrame = Math.max(1, Math.min(SPTBatch_.imps.getNSlices(), 1));
<                         lastFrame = Math.min(SPTBatch_.imps.getNSlices(), Math.max(SPTBatch_.imps.getNSlices(), 1));
<                      }
< 
<                      SPTBatch_.taskOutput.append("Capturing TrackMate overlay from frame " + firstFrame + " to " + lastFrame + ".\n");
<                      bounds = SPTBatch_.this.displayer.getImp().getCanvas().getBounds();
<                      width = bounds.width;
<                      height = bounds.height;
<                      nCaptures = lastFrame - firstFrame + 1;
<                      stack = new ImageStack(width, height);
<                      channel = SPTBatch_.this.displayer.getImp().getChannel();
<                      slice = SPTBatch_.this.displayer.getImp().getSlice();
<                      SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(true);
< 
<                      for(frame = firstFrame; frame <= lastFrame; ++frame) {
<                         SPTBatch_.this.displayer.getImp().setPositionWithoutUpdate(channel, slice, frame);
<                         bi = new BufferedImage(width, height, 2);
<                         SPTBatch_.this.displayer.getImp().getCanvas().paint(bi.getGraphics());
<                         cp = new ColorProcessor(bi);
<                         index = SPTBatch_.this.displayer.getImp().getStackIndex(channel, slice, frame);
<                         stack.addSlice(SPTBatch_.this.displayer.getImp().getImageStack().getSliceLabel(index), cp);
<                      }
< 
<                      SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(false);
<                      SPTBatch_.this.capture = new ImagePlus("TrackMate capture of " + SPTBatch_.this.displayer.getImp().getShortTitle(), stack);
<                      SPTBatch_.transferCalibration(SPTBatch_.this.displayer.getImp(), SPTBatch_.this.capture);
<                      IJ.saveAs(SPTBatch_.this.capture, "Tiff", SPTBatch_.directSPT.getAbsolutePath() + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]);
<                   }
<                }
< 
<                if (SPTBatch_.checkbox3.isSelected() == Boolean.TRUE) {
<                   try {
<                      FileWriter writer = new FileWriter(SPTBatch_.directSPT.getAbsolutePath() + File.separator + "Log" + "_" + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", "") + ".txt");
<                      SPTBatch_.taskOutput.write(writer);
<                      writer.close();
<                   } catch (IOException var125) {
<                   }
<                }
< 
<                SPTBatch_.imps.hide();
<             }
< 
<             Thread trackSummaryCols;
<             if (SPTBatch_.this.enableTrackTable.equals("trackTable")) {
<                trackSummaryCols = new Thread(new Runnable() {
<                   public void run() {
<                      String[][] rowDataDef = new String[4][SPTBatch_.this.columnsMovements.length];
<                      rowDataDef[0][0] = String.valueOf(SPTBatch_.this.totalTracksDef);
<                      rowDataDef[1][0] = String.valueOf("");
<                      rowDataDef[2][0] = String.valueOf("");
<                      rowDataDef[3][0] = String.valueOf("");
<                      rowDataDef[0][1] = String.valueOf(SPTBatch_.this.longTracksDef);
<                      rowDataDef[1][1] = String.valueOf(" ");
<                      rowDataDef[2][1] = String.valueOf("Short Tracks");
<                      rowDataDef[3][1] = String.valueOf(SPTBatch_.this.shortTracksDef);
<                      rowDataDef[0][2] = String.valueOf(SPTBatch_.this.longConfinedDef);
<                      rowDataDef[1][2] = String.valueOf(" ");
<                      rowDataDef[2][2] = String.valueOf("Short Confined");
<                      rowDataDef[3][2] = String.valueOf(SPTBatch_.this.shortConfinedDef);
<                      rowDataDef[0][3] = String.valueOf(SPTBatch_.this.longUniBalDef);
<                      rowDataDef[1][3] = String.valueOf(" ");
<                      rowDataDef[2][3] = String.valueOf("Short Anomalous");
<                      rowDataDef[3][3] = String.valueOf(SPTBatch_.this.shortAnomDef);
<                      rowDataDef[0][4] = String.valueOf(SPTBatch_.this.longFreeDef);
<                      rowDataDef[1][4] = String.valueOf(" ");
<                      rowDataDef[2][4] = String.valueOf("Short Free");
<                      rowDataDef[3][4] = String.valueOf(SPTBatch_.this.shortFreeDef);
<                      rowDataDef[0][5] = String.valueOf(SPTBatch_.this.longDirectDef);
<                      rowDataDef[1][5] = String.valueOf(" ");
<                      rowDataDef[2][5] = String.valueOf("Short Direct");
<                      rowDataDef[3][5] = String.valueOf(SPTBatch_.this.shortDirectDef);
<                      rowDataDef[0][6] = String.valueOf(SPTBatch_.this.immobDef);
<                      rowDataDef[1][6] = String.valueOf("");
<                      rowDataDef[2][6] = String.valueOf("");
<                      rowDataDef[3][6] = String.valueOf("");
<                      ResultsTable rtTrackSummary = new ResultsTable();
< 
<                      for(int r = 0; r < rowDataDef.length; ++r) {
<                         for(int c = 0; c < rowDataDef[r].length; ++c) {
<                            rtTrackSummary.setValue(SPTBatch_.this.columnsMovements[c], r, rowDataDef[r][c]);
<                         }
<                      }
< 
<                      try {
<                         rtTrackSummary.saveAs(SPTBatch_.directSummary.getAbsolutePath() + File.separator + "SummaryTracks_Condition" + ".csv");
<                      } catch (IOException var5) {
<                         var5.printStackTrace();
<                      }
< 
<                   }
<                });
<                trackSummaryCols.start();
<             }
< 
<             if (SPTBatch_.checkSummary.isSelected()) {
<                trackSummaryCols = new Thread(new Runnable() {
<                   public void run() {
<                      for(int x = 0; x < SPTBatch_.this.selectedItems.size(); ++x) {
<                         ResultsTable rtTrackSum;
<                         int y;
<                         int z;
<                         if (summaryColsWindow.combo.getSelectedIndex() == 0) {
<                            rtTrackSum = new ResultsTable();
<                            y = 0;
< 
<                            while(true) {
<                               if (y >= SPTBatch_.this.rtSpots.length) {
<                                  try {
<                                     rtTrackSum.saveAs(SPTBatch_.directSummary.getAbsolutePath() + File.separator + (String)SPTBatch_.this.selectedItems.get(x) + "_" + "SummaryCols_Spots" + ".csv");
<                                  } catch (IOException var5) {
<                                     var5.printStackTrace();
<                                  }
<                                  break;
<                               }
< 
<                               for(z = 0; z < SPTBatch_.this.rtSpots[y].size(); ++z) {
<                                  rtTrackSum.setValue(listOfFiles[y].getName(), z, SPTBatch_.this.rtSpots[y].getStringValue(Arrays.asList(summaryColsWindow.columnNamesSpot).indexOf(SPTBatch_.this.selectedItems.get(x)), z));
<                               }
< 
<                               ++y;
<                            }
<                         }
< 
<                         if (summaryColsWindow.combo.getSelectedIndex() == 1) {
<                            rtTrackSum = new ResultsTable();
<                            y = 0;
< 
<                            while(true) {
<                               if (y >= SPTBatch_.this.rtLinks.length) {
<                                  try {
<                                     rtTrackSum.saveAs(SPTBatch_.directSummary.getAbsolutePath() + File.separator + (String)SPTBatch_.this.selectedItems.get(x) + "_" + "SummaryCols_Links" + ".csv");
<                                  } catch (IOException var7) {
<                                     var7.printStackTrace();
<                                  }
<                                  break;
<                               }
< 
<                               for(z = 0; z < SPTBatch_.this.rtLinks[y].size(); ++z) {
<                                  rtTrackSum.setValue(listOfFiles[y].getName(), z, SPTBatch_.this.rtLinks[y].getStringValue(Arrays.asList(summaryColsWindow.columnNamesLinks).indexOf(SPTBatch_.this.selectedItems.get(x)), z));
<                               }
< 
<                               ++y;
<                            }
<                         }
< 
<                         if (summaryColsWindow.combo.getSelectedIndex() == 2) {
<                            rtTrackSum = new ResultsTable();
< 
<                            for(y = 0; y < SPTBatch_.this.rtTracks.length; ++y) {
<                               for(z = 0; z < SPTBatch_.this.rtTracks[y].size(); ++z) {
<                                  rtTrackSum.setValue(listOfFiles[y].getName(), z, SPTBatch_.this.rtTracks[y].getStringValue(Arrays.asList(summaryColsWindow.columnNamesTracks).indexOf(SPTBatch_.this.selectedItems.get(x)), z));
<                               }
<                            }
< 
<                            try {
<                               rtTrackSum.saveAs(SPTBatch_.directSummary.getAbsolutePath() + File.separator + (String)SPTBatch_.this.selectedItems.get(x) + "_" + "SummaryCols_Tracks" + ".csv");
<                            } catch (IOException var6) {
<                               var6.printStackTrace();
<                            }
<                         }
<                      }
< 
<                   }
<                });
<                trackSummaryCols.start();
<             }
< 
<             SPTBatch_.this.enableSpotTable.equals("spotTable");
<             SPTBatch_.this.enableLinkTable.equals("linkTable");
<             SPTBatch_.this.enableTrackTable.equals("trackTable");
<             SPTBatch_.taskOutput.append("              FINISHED!!!");
<             frameAnalyzer.setVisible(false);
<          }
<       });
<       this.finishButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent event) {
<             if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE) {
<                SPTBatch_.minTracksJTF = Integer.valueOf(SPTBatch_.minTracks.getText());
<                SPTBatch_.maxTracksJTF = Integer.valueOf(SPTBatch_.maxTracks.getText());
<                SPTBatch_.thLengthJTF = Integer.valueOf(SPTBatch_.thLength.getText());
<                if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "DIff") {
<                   SPTBatch_.this.thD14JTF = Double.valueOf(SPTBatch_.thD14.getText());
<                }
<             }
< 
<             SPTBatch_.mainProcess.start();
<          }
<       });
<    }
< 
<    private static final void transferCalibration(ImagePlus from, ImagePlus to) {
<       Calibration fc = from.getCalibration();
<       Calibration tc = to.getCalibration();
<       tc.setUnit(fc.getUnit());
<       tc.setTimeUnit(fc.getTimeUnit());
<       tc.frameInterval = fc.frameInterval;
<       double mag = from.getCanvas().getMagnification();
<       tc.pixelWidth = fc.pixelWidth / mag;
<       tc.pixelHeight = fc.pixelHeight / mag;
<       tc.pixelDepth = fc.pixelDepth;
<    }
< 
<    protected ImageIcon createImageIcon(String path) {
<       URL imgURL = this.getClass().getResource(path);
<       if (imgURL != null) {
<          return new ImageIcon(imgURL);
<       } else {
<          System.err.println("Couldn't find file: " + path);
<          return null;
<       }
<    }
< 
<    private Image getScaledImage(Image srcImg, int w, int h) {
<       BufferedImage resizedImg = new BufferedImage(w, h, 1);
<       Graphics2D g2 = resizedImg.createGraphics();
<       g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
<       g2.drawImage(srcImg, 0, 0, w, h, (ImageObserver)null);
<       g2.dispose();
<       return resizedImg;
<    }
< 
<    protected JComponent makeTextPanel(String text) {
<       JPanel panel = new JPanel(false);
<       JLabel filler = new JLabel(text);
<       filler.setHorizontalAlignment(0);
<       panel.setLayout(new GridLayout(1, 1));
<       panel.add(filler);
<       return panel;
<    }
< 
<    public static ImagePlus[] openBF(String multiSeriesFileName, boolean splitC, boolean splitT, boolean splitZ, boolean autoScale, boolean crop, boolean allSeries) {
<       ImagePlus[] imps = null;
< 
<       try {
<          ImporterOptions options = new ImporterOptions();
<          options.setId(multiSeriesFileName);
<          options.setSplitChannels(splitC);
<          options.setSplitTimepoints(splitT);
<          options.setSplitFocalPlanes(splitZ);
<          options.setAutoscale(autoScale);
<          options.setStackFormat("Hyperstack");
<          options.setStackOrder("XYCZT");
<          options.setCrop(crop);
<          options.setOpenAllSeries(allSeries);
<          ImportProcess process = new ImportProcess(options);
<          if (!process.execute()) {
<             return null;
<          } else {
<             DisplayHandler displayHandler = new DisplayHandler(process);
<             if (options != null && options.isShowOMEXML()) {
<                displayHandler.displayOMEXML();
<             }
< 
<             List<ImagePlus> impsList = (new ImagePlusReaderModified(process)).readImages(false);
<             imps = (ImagePlus[])impsList.toArray(new ImagePlus[0]);
<             if (options != null && options.showROIs()) {
<                displayHandler.displayROIs(imps);
<             }
< 
<             if (!options.isVirtual()) {
<                process.getReader().close();
<             }
< 
<             return imps;
<          }
<       } catch (Exception var12) {
<          return null;
<       }
<    }
< 
<    private final TablePanel<Spot> createSpotTable(Model model, DisplaySettings ds) {
<       List<Spot> objects = new ArrayList();
<       Iterator var5 = model.getTrackModel().unsortedTrackIDs(true).iterator();
< 
<       while(var5.hasNext()) {
<          Integer trackID = (Integer)var5.next();
<          objects.addAll(model.getTrackModel().trackSpots(trackID));
<       }
< 
<       List<String> features = new ArrayList(model.getFeatureModel().getSpotFeatures());
<       Map<String, String> featureNames = model.getFeatureModel().getSpotFeatureNames();
<       Map<String, String> featureShortNames = model.getFeatureModel().getSpotFeatureShortNames();
<       Map<String, String> featureUnits = new HashMap();
<       Iterator var9 = features.iterator();
< 
<       while(var9.hasNext()) {
<          String feature = (String)var9.next();
<          Dimension dimension = (Dimension)model.getFeatureModel().getSpotFeatureDimensions().get(feature);
<          String units = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
<          featureUnits.put(feature, units);
<       }
< 
<       Map<String, Boolean> isInts = model.getFeatureModel().getSpotFeatureIsInt();
<       Map<String, String> infoTexts = new HashMap();
<       Function<Spot, String> labelGenerator = (spot) -> {
<          return spot.getName();
<       };
<       BiConsumer<Spot, String> labelSetter = (spot, label) -> {
<          spot.setName(label);
<       };
<       String SPOT_ID = "ID";
<       features.add(0, "ID");
<       featureNames.put("ID", "Spot ID");
<       featureShortNames.put("ID", "Spot ID");
<       featureUnits.put("ID", "");
<       isInts.put("ID", Boolean.TRUE);
<       infoTexts.put("ID", "The id of the spot.");
<       String TRACK_ID = "TRACK_ID";
<       features.add(1, "TRACK_ID");
<       featureNames.put("TRACK_ID", "Track ID");
<       featureShortNames.put("TRACK_ID", "Track ID");
<       featureUnits.put("TRACK_ID", "");
<       isInts.put("TRACK_ID", Boolean.TRUE);
<       infoTexts.put("TRACK_ID", "The id of the track this spot belongs to.");
<       BiFunction<Spot, String, Double> featureFun = (spot, featurex) -> {
<          if (featurex.equals("TRACK_ID")) {
<             Integer trackID = model.getTrackModel().trackIDOf(spot);
<             return trackID == null ? null : trackID.doubleValue();
<          } else {
<             return featurex.equals("ID") ? (double)spot.ID() : spot.getFeature(featurex);
<          }
<       };
<       BiConsumer<Spot, Color> colorSetter = (spot, color) -> {
<          spot.putFeature("MANUAL_SPOT_COLOR", (double)color.getRGB());
<       };
<       Supplier<FeatureColorGenerator<Spot>> coloring = () -> {
<          return FeatureUtils.createSpotColorGenerator(model, ds);
<       };
<       TablePanel<Spot> table = new TablePanel(objects, features, featureFun, featureNames, featureShortNames, featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter, "MANUAL_SPOT_COLOR", colorSetter);
<       return table;
<    }
< 
<    private final TablePanel<DefaultWeightedEdge> createEdgeTable(Model model, DisplaySettings ds) {
<       List<DefaultWeightedEdge> objects = new ArrayList();
<       Iterator var5 = model.getTrackModel().unsortedTrackIDs(true).iterator();
< 
<       while(var5.hasNext()) {
<          Integer trackID = (Integer)var5.next();
<          objects.addAll(model.getTrackModel().trackEdges(trackID));
<       }
< 
<       List<String> features = new ArrayList(model.getFeatureModel().getEdgeFeatures());
<       Map<String, String> featureNames = model.getFeatureModel().getEdgeFeatureNames();
<       Map<String, String> featureShortNames = model.getFeatureModel().getEdgeFeatureShortNames();
<       Map<String, String> featureUnits = new HashMap();
<       Iterator var9 = features.iterator();
< 
<       String labelSetter;
<       while(var9.hasNext()) {
<          String feature = (String)var9.next();
<          Dimension dimension = (Dimension)model.getFeatureModel().getEdgeFeatureDimensions().get(feature);
<          labelSetter = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
<          featureUnits.put(feature, labelSetter);
<       }
< 
<       Map<String, Boolean> isInts = model.getFeatureModel().getEdgeFeatureIsInt();
<       Map<String, String> infoTexts = new HashMap();
<       Function<DefaultWeightedEdge, String> labelGenerator = (edge) -> {
<          return String.format("%s  %s", model.getTrackModel().getEdgeSource(edge).getName(), model.getTrackModel().getEdgeTarget(edge).getName());
<       };
<       labelSetter = null;
<       String TRACK_ID = "TRACK_ID";
<       features.add(0, "TRACK_ID");
<       featureNames.put("TRACK_ID", "Track ID");
<       featureShortNames.put("TRACK_ID", "Track ID");
<       featureUnits.put("TRACK_ID", "");
<       isInts.put("TRACK_ID", Boolean.TRUE);
<       infoTexts.put("TRACK_ID", "The id of the track this spot belongs to.");
<       BiFunction<DefaultWeightedEdge, String, Double> featureFun = (edge, featurex) -> {
<          if (featurex.equals("TRACK_ID")) {
<             Integer trackID = model.getTrackModel().trackIDOf(edge);
<             return trackID == null ? null : trackID.doubleValue();
<          } else {
<             return model.getFeatureModel().getEdgeFeature(edge, featurex);
<          }
<       };
<       BiConsumer<DefaultWeightedEdge, Color> colorSetter = (edge, color) -> {
<          model.getFeatureModel().putEdgeFeature(edge, "MANUAL_EGE_COLOR", (double)color.getRGB());
<       };
<       Supplier<FeatureColorGenerator<DefaultWeightedEdge>> coloring = () -> {
<          return FeatureUtils.createTrackColorGenerator(model, ds);
<       };
<       TablePanel<DefaultWeightedEdge> table = new TablePanel(objects, features, featureFun, featureNames, featureShortNames, featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter, "MANUAL_EGE_COLOR", colorSetter);
<       return table;
<    }
< 
<    private final TablePanel<Integer> createTrackTable(Model model, DisplaySettings ds) {
<       List<Integer> objects = new ArrayList(model.getTrackModel().trackIDs(true));
<       List<String> features = new ArrayList(model.getFeatureModel().getTrackFeatures());
<       BiFunction<Integer, String, Double> featureFun = (trackID, featurex) -> {
<          return model.getFeatureModel().getTrackFeature(trackID, featurex);
<       };
<       Map<String, String> featureNames = model.getFeatureModel().getTrackFeatureNames();
<       Map<String, String> featureShortNames = model.getFeatureModel().getTrackFeatureShortNames();
<       Map<String, String> featureUnits = new HashMap();
<       Iterator var10 = features.iterator();
< 
<       while(var10.hasNext()) {
<          String feature = (String)var10.next();
<          Dimension dimension = (Dimension)model.getFeatureModel().getTrackFeatureDimensions().get(feature);
<          String units = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
<          featureUnits.put(feature, units);
<       }
< 
<       Map<String, Boolean> isInts = model.getFeatureModel().getTrackFeatureIsInt();
<       Map<String, String> infoTexts = new HashMap();
<       Function<Integer, String> labelGenerator = (id) -> {
<          return model.getTrackModel().name(id);
<       };
<       BiConsumer<Integer, String> labelSetter = (id, label) -> {
<          model.getTrackModel().setName(id, label);
<       };
<       Supplier<FeatureColorGenerator<Integer>> coloring = () -> {
<          return FeatureUtils.createWholeTrackColorGenerator(model, ds);
<       };
<       TablePanel<Integer> table = new TablePanel(objects, features, featureFun, featureNames, featureShortNames, featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter);
<       return table;
<    }
< 
<    public static final TablePanel<SPTBatch_.Branch> createBranchTable(Model model, SelectionModel selectionModel) {
<       Logger logger = model.getLogger();
<       taskOutput.append("Generating track branches analysis.\n");
<       int ntracks = model.getTrackModel().nTracks(true);
<       if (ntracks == 0) {
<          taskOutput.append("No visible track found. Aborting.\n");
<       }
< 
<       TimeDirectedNeighborIndex neighborIndex = model.getTrackModel().getDirectedNeighborIndex();
<       List<SPTBatch_.Branch> brs = new ArrayList();
<       Iterator var7 = model.getTrackModel().unsortedTrackIDs(true).iterator();
< 
<       HashMap predecessorMap;
<       while(var7.hasNext()) {
<          Integer trackID = (Integer)var7.next();
<          TrackBranchDecomposition branchDecomposition = ConvexBranchesDecomposition.processTrack(trackID, model.getTrackModel(), neighborIndex, true, false);
<          SimpleDirectedGraph<List<Spot>, DefaultEdge> branchGraph = ConvexBranchesDecomposition.buildBranchGraph(branchDecomposition);
<          Map<SPTBatch_.Branch, Set<List<Spot>>> successorMap = new HashMap();
<          predecessorMap = new HashMap();
<          Map<List<Spot>, SPTBatch_.Branch> branchMap = new HashMap();
<          Iterator var14 = branchGraph.vertexSet().iterator();
< 
<          while(var14.hasNext()) {
<             List<Spot> branch = (List)var14.next();
<             SPTBatch_.Branch br = new SPTBatch_.Branch();
<             branchMap.put(branch, br);
<             br.trackName = model.getTrackModel().name(trackID);
<             br.putFeature("TRACK_ID", (double)trackID);
<             Spot first = (Spot)branch.get(0);
<             br.first = first;
<             br.putFeature("FIRST", (double)first.ID());
<             Spot last = (Spot)branch.get(branch.size() - 1);
<             br.last = last;
<             br.putFeature("LAST", (double)last.ID());
<             br.putFeature("DELTA_T", br.dt());
<             double distanceTraveled = Math.sqrt(br.last.squareDistanceTo(br.first));
<             br.putFeature("DISTANCE", distanceTraveled);
<             double meanV;
<             if (branch.size() < 2) {
<                meanV = Double.NaN;
<             } else {
<                Iterator<Spot> it = branch.iterator();
<                Spot previous = (Spot)it.next();
< 
<                double sum;
<                Spot next;
<                for(sum = 0.0D; it.hasNext(); previous = next) {
<                   next = (Spot)it.next();
<                   double dr = Math.sqrt(next.squareDistanceTo(previous));
<                   sum += dr;
<                }
< 
<                meanV = sum / (double)(branch.size() - 1);
<             }
< 
<             br.putFeature("MEAN_VELOCITY", meanV);
<             Set<DefaultEdge> incomingEdges = branchGraph.incomingEdgesOf(branch);
<             Set<List<Spot>> predecessors = new HashSet(incomingEdges.size());
<             Iterator var25 = incomingEdges.iterator();
< 
<             while(var25.hasNext()) {
<                DefaultEdge edge = (DefaultEdge)var25.next();
<                List<Spot> predecessorBranch = (List)branchGraph.getEdgeSource(edge);
<                predecessors.add(predecessorBranch);
<             }
< 
<             Set<DefaultEdge> outgoingEdges = branchGraph.outgoingEdgesOf(branch);
<             Set<List<Spot>> successors = new HashSet(outgoingEdges.size());
<             Iterator var51 = outgoingEdges.iterator();
< 
<             while(var51.hasNext()) {
<                DefaultEdge edge = (DefaultEdge)var51.next();
<                List<Spot> successorBranch = (List)branchGraph.getEdgeTarget(edge);
<                successors.add(successorBranch);
<             }
< 
<             successorMap.put(br, successors);
<             predecessorMap.put(br, predecessors);
<          }
< 
<          var14 = successorMap.keySet().iterator();
< 
<          while(var14.hasNext()) {
<             SPTBatch_.Branch br = (SPTBatch_.Branch)var14.next();
<             Set<List<Spot>> succs = (Set)successorMap.get(br);
<             Set<SPTBatch_.Branch> succBrs = new HashSet(succs.size());
<             Iterator var40 = succs.iterator();
< 
<             while(var40.hasNext()) {
<                List<Spot> branch = (List)var40.next();
<                SPTBatch_.Branch succBr = (SPTBatch_.Branch)branchMap.get(branch);
<                succBrs.add(succBr);
<             }
< 
<             br.successors = succBrs;
<             br.putFeature("N_SUCCESSORS", (double)succBrs.size());
<             Set<List<Spot>> preds = (Set)predecessorMap.get(br);
<             Set<SPTBatch_.Branch> predBrs = new HashSet(preds.size());
<             Iterator var43 = preds.iterator();
< 
<             while(var43.hasNext()) {
<                List<Spot> branch = (List)var43.next();
<                SPTBatch_.Branch predBr = (SPTBatch_.Branch)branchMap.get(branch);
<                predBrs.add(predBr);
<             }
< 
<             br.predecessors = predBrs;
<             br.putFeature("N_PREDECESSORS", (double)predBrs.size());
<          }
< 
<          brs.addAll(successorMap.keySet());
<       }
< 
<       Collections.sort(brs);
<       BiFunction<SPTBatch_.Branch, String, Double> featureFun = (brx, feature) -> {
<          return brx.getFeature(feature);
<       };
<       Map<String, String> featureUnits = new HashMap();
<       BRANCH_FEATURES_DIMENSIONS.forEach((f, d) -> {
<          featureUnits.put(f, TMUtils.getUnitsFor(d, model.getSpaceUnits(), model.getTimeUnits()));
<       });
<       Map<String, String> infoTexts = new HashMap();
<       Function<SPTBatch_.Branch, String> labelGenerator = (b) -> {
<          return b.toString();
<       };
<       predecessorMap = null;
<       Supplier<FeatureColorGenerator<SPTBatch_.Branch>> colorSupplier = () -> {
<          return (b) -> {
<             return Color.WHITE;
<          };
<       };
<       TablePanel<SPTBatch_.Branch> table = new TablePanel(brs, BRANCH_FEATURES, featureFun, BRANCH_FEATURES_NAMES, BRANCH_FEATURES_SHORTNAMES, featureUnits, BRANCH_FEATURES_ISINTS, infoTexts, colorSupplier, labelGenerator, predecessorMap);
<       return table;
<    }
< 
<    private final <K, V> Set<V> getUniqueValues(Iterable<K> keys, Map<K, V> map) {
<       Set<V> mapping = new LinkedHashSet();
<       Iterator var5 = keys.iterator();
< 
<       while(var5.hasNext()) {
<          K key = (Object)var5.next();
<          mapping.add(map.get(key));
<       }
< 
<       return mapping;
<    }
< 
<    private static final <K, V> List<K> getCommonKeys(V targetValue, Iterable<K> keys, Map<K, V> map) {
<       ArrayList<K> foundKeys = new ArrayList();
<       Iterator var5 = keys.iterator();
< 
<       while(var5.hasNext()) {
<          K key = (Object)var5.next();
<          if (map.get(key).equals(targetValue)) {
<             foundKeys.add(key);
<          }
<       }
< 
<       return foundKeys;
<    }
< 
<    private final String buildPlotTitle(Iterable<String> lYFeatures, Map<String, String> featureNames, String xSelectedSpot) {
<       StringBuilder sb = new StringBuilder("Plot of ");
<       Iterator<String> it = lYFeatures.iterator();
<       sb.append((String)featureNames.get(it.next()));
< 
<       while(it.hasNext()) {
<          sb.append(", ");
<          sb.append((String)featureNames.get(it.next()));
<       }
< 
<       sb.append(" vs ");
<       sb.append((String)featureNames.get(xSelectedSpot));
<       sb.append(".");
<       return sb.toString();
<    }
< 
<    private static final float[] toFloat(double[] d) {
<       float[] f = new float[d.length];
< 
<       for(int i = 0; i < f.length; ++i) {
<          f[i] = (float)d[i];
<       }
< 
<       return f;
<    }
< 
<    public ImagePlus renderND(HyperStackDisplayer displayer, DisplaySettings ds) {
<       Roi initialROI = displayer.getImp().getRoi();
<       if (initialROI != null) {
<          displayer.getImp().killRoi();
<       }
< 
<       Overlay overlay = displayer.getImp().getOverlay();
<       if (overlay == null) {
<          overlay = new Overlay();
<          displayer.getImp().setOverlay(overlay);
<       }
< 
<       overlay.clear();
<       if (initialROI != null) {
<          displayer.getImp().getOverlay().add(initialROI);
<       }
< 
<       if (displayer != null) {
<          displayer.getImp().updateAndDraw();
<       }
< 
<       displayer.getImp().setOpenAsHyperStack(true);
<       displayer.getImp().getOverlay().add(new SpotOverlay(model, displayer.getImp(), ds));
<       displayer.getImp().getOverlay().add(new TrackOverlay(model, displayer.getImp(), ds));
<       displayer.getImp().updateAndDraw();
<       return displayer.getImp();
<    }
< 
<    public static ImagePlus[] stack2images(ImagePlus imp) {
<       String sLabel = imp.getTitle();
<       String sImLabel = "";
<       ImageStack stack = imp.getStack();
<       int sz = stack.getSize();
<       int currentSlice = imp.getCurrentSlice();
<       DecimalFormat df = new DecimalFormat("0000");
<       ImagePlus[] arrayOfImages = new ImagePlus[imp.getStack().getSize()];
< 
<       for(int n = 1; n <= sz; ++n) {
<          imp.setSlice(n);
<          ImageProcessor ip = imp.getProcessor();
<          ImageProcessor newip = ip.createProcessor(ip.getWidth(), ip.getHeight());
<          newip.setPixels(ip.getPixelsCopy());
<          sImLabel = imp.getStack().getSliceLabel(n);
<          if (sImLabel == null || sImLabel.length() < 1) {
<             sImLabel = "slice" + df.format((long)n) + "_" + sLabel;
<          }
< 
<          ImagePlus im = new ImagePlus(sImLabel, newip);
<          im.setCalibration(imp.getCalibration());
<          arrayOfImages[n - 1] = im;
<       }
< 
<       imp.setSlice(currentSlice);
<       if (imp.isProcessor()) {
<          ImageProcessor ip = imp.getProcessor();
<          ip.setPixels(ip.getPixels());
<       }
< 
<       imp.setSlice(currentSlice);
<       return arrayOfImages;
<    }
< 
<    public void exportToCSV(String[][] rowData, String[] titles, File file) {
<       try {
<          try {
<             FileWriter excel = new FileWriter(file);
< 
<             int i;
<             for(i = 0; i < titles.length; ++i) {
<                excel.write(titles[i] + ",");
<             }
< 
<             excel.write("\n");
< 
<             for(i = 0; i < rowData.length; ++i) {
<                for(int j = 0; j < rowData[i].length; ++j) {
<                   if (j == 11) {
<                      excel.write(" ,");
<                   }
< 
<                   if (j != 11) {
<                      if (rowData[i][j].toString() != null || rowData[i][j].toString() != " ") {
<                         excel.write(rowData[i][j].toString() + ",");
<                      }
< 
<                      if (rowData[i][j].toString() == null || rowData[i][j].toString() == " ") {
<                         excel.write(" ,");
<                      }
<                   }
<                }
< 
<                excel.write("\n");
<             }
< 
<             excel.close();
<          } catch (IOException var7) {
<          }
<       } catch (NullPointerException var8) {
<       }
< 
<    }
< 
<    public static class Branch implements Comparable<SPTBatch_.Branch> {
<       private final Map<String, Double> features = new HashMap();
<       private String trackName;
<       private Spot first;
<       private Spot last;
<       private Set<SPTBatch_.Branch> predecessors;
<       private Set<SPTBatch_.Branch> successors;
< 
<       public String toString() {
<          return this.trackName + ": " + this.first + "  " + this.last;
<       }
< 
<       double dt() {
<          return this.last.diffTo(this.first, "POSITION_T");
<       }
< 
<       public final Double getFeature(String feature) {
<          return (Double)this.features.get(feature);
<       }
< 
<       public final void putFeature(String feature, Double value) {
<          this.features.put(feature, value);
<       }
< 
<       public int compareTo(SPTBatch_.Branch o) {
<          if (this.predecessors.size() != o.predecessors.size()) {
<             return this.predecessors.size() - o.predecessors.size();
<          } else if (this.successors.size() != o.successors.size()) {
<             return this.successors.size() - o.successors.size();
<          } else {
<             return this.first.getName().compareTo(o.first.getName()) != 0 ? this.first.getName().compareTo(o.first.getName()) : this.last.getName().compareTo(o.last.getName());
<          }
<       }
<    }
< 
<    class ChooserWizardPanel extends JWizardPanel {
<       private ButtonGroup bg;
< 
<       public ChooserWizardPanel(JWizardComponents wizardComponents) {
<          super(wizardComponents, "");
<          this.init();
<       }
< 
<       private void init() {
<          this.setLayout(new GridBagLayout());
<          CheckableItem[] items = new CheckableItem[]{new CheckableItem("Spots", true), new CheckableItem("Links", true), new CheckableItem("Tracks", true), new CheckableItem("Branch Analysis", true)};
<          SPTBatch_.checkbox1 = new JCheckBox("  Analysis/Statistics Results. ");
<          SPTBatch_.checkbox1.setSelected(true);
<          SPTBatch_.checkboxDiff = new JCheckBox("  TraJ: Trajectory Classifier. ");
<          SPTBatch_.checkboxDiff.setSelected(true);
<          SPTBatch_.this.trajButton = new JButton("Tune Parameters");
<          SPTBatch_.checkboxSubBg = new JCheckBox(" Subtract Background :  ");
<          SPTBatch_.checkboxSubBg.setSelected(false);
<          SPTBatch_.checkExcludeTracks = new JCheckBox(" Exclude tracks outside cell  ");
<          SPTBatch_.checkExcludeTracks.setSelected(false);
<          SPTBatch_.checkPBS = new JCheckBox("Photobleaching step Analysis.");
<          SPTBatch_.checkPBS.setSelected(true);
<          SPTBatch_.checkSummary = new JCheckBox("");
<          SPTBatch_.checkSummary.setSelected(true);
<          SPTBatch_.this.summaryButton = new JButton("Summary Outputs");
<          JPanel summPanel = new JPanel(new FlowLayout(0));
<          summPanel.add(SPTBatch_.checkSummary);
<          summPanel.add(SPTBatch_.this.summaryButton);
<          JPanel panelPBS = new JPanel(new FlowLayout(0));
<          panelPBS.add(SPTBatch_.checkPBS);
<          SPTBatch_.this.comboSubBg = new JComboBox();
<          SPTBatch_.this.comboSubBg = new JComboBox();
<          SPTBatch_.this.comboSubBg.addItem("Subtract Bg 1");
<          SPTBatch_.this.comboSubBg.addItem("Subtract Bg 2");
<          SPTBatch_.this.comboSubBg.addItem("Subtract Bg 3");
<          SPTBatch_.this.comboSubBg.addItem("Subtract Bg 4");
<          SPTBatch_.this.comboSubBg.addItem("Subtract Bg 5");
<          SPTBatch_.this.comboSubBg.setEnabled(false);
<          SPTBatch_.checkboxMSD = new JCheckBox("  MSD and MSS Plots ");
<          SPTBatch_.checkboxMSD.setSelected(true);
<          SPTBatch_.checkCluster = new JCheckBox(" Cluster Size Analysis ");
<          SPTBatch_.checkCluster.setSelected(true);
<          SPTBatch_.checkMonomer = new JCheckBox(" Monomeric Protein Intensity ");
<          SPTBatch_.checkMonomer.setSelected(true);
<          SPTBatch_.checkbox2 = new JCheckBox();
<          SPTBatch_.checkbox2.setText(" Tracks to .XML file ");
<          SPTBatch_.checkbox2.setSelected(true);
<          SPTBatch_.checkbox3 = new JCheckBox();
<          SPTBatch_.checkbox3.setText("  Log to .TXT file ");
<          SPTBatch_.checkbox3.setSelected(true);
<          SPTBatch_.checkbox4 = new JCheckBox();
<          SPTBatch_.checkbox4.setText("  Track-Overlays as .TIF images");
<          SPTBatch_.checkbox4.setSelected(true);
<          SPTBatch_.checkboxRoi = new JCheckBox();
<          SPTBatch_.checkboxRoi.setText("  Track-Rois as RoiSet.zip");
<          SPTBatch_.checkboxRoi.setSelected(true);
<          SPTBatch_.checkboxPlot = new JCheckBox();
<          SPTBatch_.checkboxPlot.setText("  Plots as .PNG file");
<          SPTBatch_.checkboxPlot.setSelected(true);
<          SPTBatch_.checkboxSP = new JCheckBox();
<          SPTBatch_.checkboxSP.setText("  Chemotaxis Analysis Data");
<          SPTBatch_.checkboxSP.setSelected(true);
<          SPTBatch_.chemoScaling = new JTextField("Set Axis Scaling...");
<          SPTBatch_.chemoScaling.setEnabled(true);
<          SPTBatch_.monomerField = new JTextField("value...");
<          SPTBatch_.monomerField.setEnabled(true);
<          SPTBatch_.this.comboP = new CheckedComboBox(new DefaultComboBoxModel(items));
<          SPTBatch_.this.comboP.setOpaque(true);
<          SPTBatch_.this.comboP.setToolTipText("Select an analysis for export csv file");
<          SPTBatch_.this.comboP.setSelectedItem(items[0]);
<          if (items[0].isSelected()) {
<             SPTBatch_.this.enableSpotTable = "spotTable";
<          }
< 
<          if (items[1].isSelected()) {
<             SPTBatch_.this.enableLinkTable = "linkTable";
<          }
< 
<          if (items[2].isSelected()) {
<             SPTBatch_.this.enableTrackTable = "trackTable";
<          }
< 
<          if (items[3].isSelected()) {
<             SPTBatch_.this.enableBranchTable = "branchTable";
<          }
< 
<          this.removeAll();
<          final TextField textCsv = new TextField(20);
<          textCsv.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_CSV_PATH, ""));
<          SPTBatch_.csvPath = textCsv.getText();
<          GridBagLayout layoutCsv = (GridBagLayout)this.getLayout();
<          GridBagConstraints constraintsCsv = layoutCsv.getConstraints(textCsv);
<          SPTBatch_.this.buttonCsv = new JButton("");
<          ImageIcon iconCsv = SPTBatch_.this.createImageIcon("browse.png");
<          Icon iconCsvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(15, 15, 4));
<          SPTBatch_.this.buttonCsv.setIcon(iconCsvCell);
<          DirectoryListener listenerCsv = new DirectoryListener("Browse for ", textCsv, 2);
<          SPTBatch_.this.buttonCsv.addActionListener(listenerCsv);
<          final Panel panelCsv = new Panel();
<          panelCsv.setLayout(new FlowLayout(0, 0, 0));
<          layoutCsv.setConstraints(panelCsv, constraintsCsv);
<          panelCsv.add(SPTBatch_.checkbox1);
<          panelCsv.add(SPTBatch_.this.comboP);
<          JPanel panelBox = new JPanel();
<          JPanel panelOptions = new JPanel(new FlowLayout(0));
<          JPanel panelOptions1 = new JPanel(new FlowLayout(0));
<          panelOptions.add(Box.createHorizontalStrut(35));
<          panelOptions1.add(Box.createHorizontalStrut(35));
<          panelBox.setLayout(new BoxLayout(panelBox, 1));
<          SPTBatch_.checkTracks = new JCheckBox("Spot Range in Track: ");
<          SPTBatch_.checkTracks.setSelected(false);
<          SPTBatch_.minTracks = new JTextField("Min", 3);
<          SPTBatch_.minTracks.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_MIN_SPOT, ""));
<          SPTBatch_.minTracks.setEnabled(false);
<          SPTBatch_.maxTracks = new JTextField("Max", 3);
<          SPTBatch_.maxTracks.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_MAX_SPOT, ""));
<          SPTBatch_.maxTracks.setEnabled(false);
<          panelOptions1.add(SPTBatch_.checkTracks);
<          panelOptions1.add(SPTBatch_.minTracks);
<          panelOptions1.add(new JLabel("-"));
<          panelOptions1.add(SPTBatch_.maxTracks);
<          SPTBatch_.checkDispSpots = new JCheckBox("Spots Visible ");
<          SPTBatch_.checkDispSpots.setSelected(true);
<          SPTBatch_.checkDispSpotName = new JCheckBox("Spots Name Visible ");
<          SPTBatch_.checkDispSpotName.setSelected(true);
<          SPTBatch_.checkDispTracks = new JCheckBox("Tracks Visible: ");
<          SPTBatch_.checkDispTracks.setSelected(true);
<          SPTBatch_.this.comboDispTracks = new JComboBox();
<          SPTBatch_.this.comboDispTracks.addItem("FULL");
<          SPTBatch_.this.comboDispTracks.addItem("LOCAL");
<          SPTBatch_.this.comboDispTracks.addItem("LOCAL_BACKWARD");
<          SPTBatch_.this.comboDispTracks.addItem("LOCAL_FORWARD");
<          SPTBatch_.this.comboDispTracks.setSelectedIndex(0);
<          JPanel panelSpotTrackDisp = new JPanel(new FlowLayout(0));
<          panelSpotTrackDisp.add(SPTBatch_.checkDispSpots);
<          panelSpotTrackDisp.add(SPTBatch_.checkDispSpotName);
<          panelSpotTrackDisp.add(SPTBatch_.checkDispTracks);
<          panelSpotTrackDisp.add(SPTBatch_.this.comboDispTracks);
<          JLabel thLengthLabel = new JLabel("-Length Threshold: ");
<          SPTBatch_.thLength = new JTextField("Length", 3);
<          SPTBatch_.thLength.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_LENGTH_TH, ""));
<          JLabel thD14Label = new JLabel("-Diff.Threshold: ");
<          SPTBatch_.thD14 = new JTextField("Diff", 3);
<          SPTBatch_.thD14.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_DIFF_TH, ""));
<          JPanel panelLengthD14 = new JPanel(new FlowLayout(0));
<          panelLengthD14.add(thLengthLabel);
<          panelLengthD14.add(SPTBatch_.thLength);
<          panelLengthD14.add(thD14Label);
<          panelLengthD14.add(SPTBatch_.thD14);
<          JPanel panelSubBg = new JPanel(new FlowLayout(0, 0, 0));
<          panelSubBg.add(SPTBatch_.checkboxSubBg);
<          panelSubBg.add(SPTBatch_.this.comboSubBg);
<          panelSubBg.add(SPTBatch_.checkExcludeTracks);
<          panelBox.add(panelOptions);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(panelOptions1);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(panelLengthD14);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(panelSpotTrackDisp);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(panelPBS);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(panelSubBg);
<          panelBox.add(Box.createVerticalStrut(3));
<          panelBox.add(summPanel);
<          Panel panelOut = new Panel();
<          panelOut.setLayout(new FlowLayout(0, 0, 0));
<          panelOut.add(SPTBatch_.checkbox4);
<          GridBagLayout layoutXMLL = (GridBagLayout)this.getLayout();
<          Panel panelXMLL = new Panel();
<          panelXMLL.setLayout(new FlowLayout(0, 0, 0));
<          panelXMLL.add(SPTBatch_.checkbox2);
<          GridBagLayout layoutTxt = (GridBagLayout)this.getLayout();
<          Panel panelTxt = new Panel();
<          panelTxt.setLayout(new FlowLayout(0, 0, 0));
<          panelTxt.add(SPTBatch_.checkbox3);
<          final JPanel panelExport = new JPanel();
<          JLabel labelExport = new JLabel();
<          labelExport.setText(" Choose a directory to export files:    ");
<          labelExport.setFont(new Font("Verdana", 1, 12));
<          panelExport.setLayout(new FlowLayout(0, 0, 0));
<          panelExport.add(labelExport);
<          panelExport.add(textCsv);
<          panelExport.add(SPTBatch_.this.buttonCsv);
<          JPanel panelDiff = new JPanel(new FlowLayout(0, 0, 0));
<          panelDiff.add(SPTBatch_.checkboxDiff);
<          panelDiff.add(SPTBatch_.this.trajButton);
<          JPanel panelMSD = new JPanel(new FlowLayout(0, 0, 0));
<          panelMSD.add(SPTBatch_.checkboxMSD);
<          JPanel panelCluster = new JPanel(new FlowLayout(0, 0, 0));
<          panelCluster.add(SPTBatch_.checkCluster);
<          panelCluster.add(SPTBatch_.checkMonomer);
<          panelCluster.add(SPTBatch_.monomerField);
<          JPanel panelExport2 = new JPanel(new BorderLayout());
<          panelExport2.add(panelExport, "East");
<          Panel panelRoi = new Panel();
<          panelRoi.setLayout(new FlowLayout(0, 0, 0));
<          panelRoi.add(SPTBatch_.checkboxRoi);
<          Panel panelPlot = new Panel();
<          panelPlot.setLayout(new FlowLayout(0, 0, 0));
<          panelPlot.add(SPTBatch_.checkboxPlot);
<          Panel panelSP = new Panel();
<          panelSP.setLayout(new FlowLayout(0, 0, 0));
<          panelSP.add(SPTBatch_.checkboxSP);
<          panelSP.add(SPTBatch_.chemoScaling);
<          JLabel labelExport1 = new JLabel("   Tuneable Options: ");
<          labelExport1.setFont(new Font("Verdana", 1, 12));
<          JPanel panelExport1 = new JPanel(new FlowLayout(0));
<          panelExport1.add(labelExport1);
<          JPanel mainPanel2 = new JPanel();
<          mainPanel2.setBorder(BorderFactory.createTitledBorder(""));
<          mainPanel2.setLayout(new BoxLayout(mainPanel2, 1));
<          mainPanel2.add(Box.createVerticalStrut(3));
<          mainPanel2.add(new JSeparator(0));
<          mainPanel2.add(panelExport1);
<          mainPanel2.add(new JSeparator(0));
<          mainPanel2.add(Box.createVerticalStrut(8));
<          mainPanel2.add(panelCsv);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(Box.createHorizontalStrut(15));
<          mainPanel2.add(panelBox);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelDiff);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelMSD);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelCluster);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelXMLL);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelTxt);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelOut);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelRoi);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelPlot);
<          mainPanel2.add(Box.createVerticalStrut(5));
<          mainPanel2.add(panelSP);
<          mainPanel2.add(Box.createVerticalStrut(15));
<          mainPanel2.add(new JSeparator(0));
<          mainPanel2.add(Box.createVerticalStrut(3));
<          mainPanel2.add(panelExport2);
<          mainPanel2.setBorder(BorderFactory.createTitledBorder(""));
<          SPTBatch_.this.comboP.setEnabled(true);
<          textCsv.setEnabled(true);
<          SPTBatch_.this.buttonCsv.setEnabled(true);
<          panelExport2.setEnabled(true);
<          SPTBatch_.checkbox4.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.checkExcludeTracks.setSelected(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.checkExcludeTracks.setSelected(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkDispSpots.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.checkDispSpotName.setSelected(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.checkDispSpotName.setSelected(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkSummary.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.this.summaryButton.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.this.summaryButton.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkboxDiff.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.this.trajButton.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.this.trajButton.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkDispTracks.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.this.comboDispTracks.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.this.comboDispTracks.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkTracks.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.minTracks.setEnabled(true);
<                   SPTBatch_.maxTracks.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.minTracks.setEnabled(false);
<                   SPTBatch_.maxTracks.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkMonomer.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.monomerField.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.monomerField.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkboxSubBg.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.this.comboSubBg.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.this.comboSubBg.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.checkbox1.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                Component[] com = panelCsv.getComponents();
<                Component[] comExport = panelExport.getComponents();
<                int a;
<                if (e.getStateChange() == 1) {
<                   for(a = 1; a < com.length; ++a) {
<                      com[a].setEnabled(true);
<                   }
< 
<                   for(a = 0; a < comExport.length; ++a) {
<                      comExport[a].setEnabled(true);
<                   }
<                }
< 
<                if (e.getStateChange() == 2) {
<                   for(a = 1; a < com.length; ++a) {
<                      com[a].setEnabled(false);
<                   }
<                }
< 
<             }
<          });
<          SPTBatch_.checkboxSP.addItemListener(new ItemListener() {
<             public void itemStateChanged(ItemEvent e) {
<                if (e.getStateChange() == 1) {
<                   SPTBatch_.chemoScaling.setEnabled(true);
<                }
< 
<                if (e.getStateChange() == 2) {
<                   SPTBatch_.chemoScaling.setEnabled(false);
<                }
< 
<             }
<          });
<          SPTBatch_.this.summaryButton.addActionListener(new ActionListener() {
<             public void actionPerformed(ActionEvent event) {
<                if (SPTBatch_.checkSummary.isSelected()) {
<                   if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE) {
<                      SPTBatch_.minTracksJTF = Integer.valueOf(SPTBatch_.minTracks.getText());
<                      SPTBatch_.maxTracksJTF = Integer.valueOf(SPTBatch_.maxTracks.getText());
<                      SPTBatch_.thLengthJTF = Integer.valueOf(SPTBatch_.thLength.getText());
<                      if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "DIff") {
<                         SPTBatch_.this.thD14JTF = Double.valueOf(SPTBatch_.thD14.getText());
<                      }
<                   }
< 
<                   (new summaryColsWindow()).run("");
<                }
< 
<             }
<          });
<          SPTBatch_.this.trajButton.addActionListener(new ActionListener() {
<             public void actionPerformed(ActionEvent event) {
<                if (SPTBatch_.checkboxDiff.isSelected()) {
<                   (new traJParametersWindow()).run("");
<                }
< 
<             }
<          });
<          SPTBatch_.this.finishButton.addActionListener(new ActionListener() {
<             public void actionPerformed(ActionEvent event) {
<                SPTBatch_.csvPath = textCsv.getText();
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_CSV_PATH, textCsv.getText());
<             }
<          });
<          this.add(mainPanel2);
<       }
< 
<       public void update() {
<          if (SPTBatch_.checkboxPlot.isSelected() == Boolean.FALSE) {
<             this.setNextButtonEnabled(false);
<          }
< 
<          if (SPTBatch_.checkboxPlot.isSelected() == Boolean.TRUE) {
<             this.setNextButtonEnabled(true);
<          }
< 
<          this.setFinishButtonEnabled(true);
<          this.setBackButtonEnabled(false);
<       }
< 
<       public void next() {
<          this.switchPanel(3);
<       }
< 
<       public void back() {
<          this.switchPanel(4);
<       }
<    }
< 
<    private static final class EdgeSourceSpotFrameComparator implements Comparator<DefaultWeightedEdge> {
<       private final Model model;
< 
<       public EdgeSourceSpotFrameComparator(Model model) {
<          this.model = model;
<       }
< 
<       public int compare(DefaultWeightedEdge e1, DefaultWeightedEdge e2) {
<          double t1 = this.model.getTrackModel().getEdgeSource(e1).getFeature("FRAME");
<          double t2 = this.model.getTrackModel().getEdgeSource(e2).getFeature("FRAME");
<          if (t1 < t2) {
<             return -1;
<          } else {
<             return t1 > t2 ? 1 : 0;
<          }
<       }
<    }
< 
<    class FirstWizardPanel extends SPTBatch_.LabelWizardPanel {
<       public FirstWizardPanel(JWizardComponents wizardComponents) {
<          super(wizardComponents, "");
<       }
<    }
< 
<    class LabelWizardPanel extends JWizardPanel {
<       public LabelWizardPanel(JWizardComponents wizardComponents, String label) {
<          super(wizardComponents);
<          SPTBatch_.this.backButton = wizardComponents.getBackButton();
<          SPTBatch_.this.backButton.setText("");
<          ImageIcon iconBack = SPTBatch_.this.createImageIcon("img_71224.png");
<          Icon iconBackCell = new ImageIcon(iconBack.getImage().getScaledInstance(12, 12, 4));
<          SPTBatch_.this.backButton.setIcon(iconBackCell);
<          SPTBatch_.this.backButton.setToolTipText("Click chemotool button to back the previous wizard.");
<          SPTBatch_.this.nextButton = wizardComponents.getNextButton();
<          SPTBatch_.this.nextButton.setText("");
<          ImageIcon iconNext = SPTBatch_.this.createImageIcon("img_174455.png");
<          Icon iconNextCell = new ImageIcon(iconNext.getImage().getScaledInstance(12, 12, 4));
<          SPTBatch_.this.nextButton.setIcon(iconNextCell);
<          SPTBatch_.this.nextButton.setToolTipText("Click chemotool button to go to the next wizard.");
<          SPTBatch_.this.finishButton = wizardComponents.getFinishButton();
<          SPTBatch_.this.finishButton.setText("");
<          ImageIcon iconFinish = SPTBatch_.this.createImageIcon("ojala.png");
<          Icon iconFinishCell = new ImageIcon(iconFinish.getImage().getScaledInstance(12, 12, 4));
<          SPTBatch_.this.finishButton.setIcon(iconFinishCell);
<          SPTBatch_.this.finishButton.setToolTipText("Click chemotool button to finish your settings selection.");
<          JButton cancelButton = wizardComponents.getCancelButton();
<          cancelButton.setText("");
<          ImageIcon iconCancel = SPTBatch_.this.createImageIcon("delete.png");
<          Icon iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(12, 12, 4));
<          cancelButton.setIcon(iconCancelCell);
<          cancelButton.setToolTipText("Click chemotool button to cancel chemotool process.");
<          this.setLayout(new GridBagLayout());
<          this.add(new JLabel(label), new GridBagConstraints(0, 0, 1, 1, 0.0D, 0.0D, 10, 1, new Insets(0, 0, 0, 0), 0, 0));
<          final TextField textXML = new TextField(20);
<          textXML.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_TRANSF_PATH, ""));
<          GridBagLayout layoutXML = (GridBagLayout)this.getLayout();
<          GridBagConstraints constraintsXML = layoutXML.getConstraints(textXML);
<          JButton buttonXML = new JButton("");
<          ImageIcon iconXML = SPTBatch_.this.createImageIcon("browse.png");
<          Icon iconXMLCell = new ImageIcon(iconXML.getImage().getScaledInstance(15, 15, 4));
<          buttonXML.setIcon(iconXMLCell);
<          ImageIcon iconBrowse = SPTBatch_.this.createImageIcon("browse.png");
<          Icon iconBrowseCell = new ImageIcon(iconBrowse.getImage().getScaledInstance(15, 15, 4));
<          buttonXML.setIcon(iconBrowseCell);
<          DirectoryListener listenerXML = new DirectoryListener("Browse for " + label, textXML, 2);
<          buttonXML.addActionListener(listenerXML);
<          Panel panelXML = new Panel();
<          panelXML.setLayout(new FlowLayout(0));
<          JLabel loadLabel = new JLabel("  Load TrackMate .XML file: ");
<          loadLabel.setFont(new Font("Verdana", 1, 12));
<          panelXML.add(loadLabel);
<          panelXML.add(textXML);
<          panelXML.add(buttonXML);
<          layoutXML.setConstraints(panelXML, constraintsXML);
<          final TextField textImg = new TextField(20);
<          textImg.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_IMAGES_PATH, ""));
<          GridBagLayout layoutImg = (GridBagLayout)this.getLayout();
<          GridBagConstraints constraintsImg = layoutImg.getConstraints(textImg);
<          JButton buttonImg = new JButton("");
<          ImageIcon iconIM = SPTBatch_.this.createImageIcon("browse.png");
<          Icon iconIMCell = new ImageIcon(iconIM.getImage().getScaledInstance(15, 15, 4));
<          buttonImg.setIcon(iconIMCell);
<          ImageIcon iconB = SPTBatch_.this.createImageIcon("browse.png");
<          Icon iconBCell = new ImageIcon(iconB.getImage().getScaledInstance(15, 15, 4));
<          buttonImg.setIcon(iconBCell);
<          DirectoryListener listenerImg = new DirectoryListener("Browse for " + label, textImg, 2);
<          buttonImg.addActionListener(listenerImg);
<          Panel panelImg = new Panel();
<          panelImg.setLayout(new FlowLayout(0));
<          JLabel directLabel = new JLabel("  Movie Files Directory:   ");
<          directLabel.setFont(new Font("Verdana", 1, 12));
<          panelImg.add(directLabel);
<          panelImg.add(textImg);
<          panelImg.add(buttonImg);
<          layoutImg.setConstraints(panelImg, constraintsImg);
<          JPanel mainPanel = new JPanel();
<          mainPanel.setLayout(new BoxLayout(mainPanel, 1));
<          mainPanel.add(Box.createVerticalStrut(15));
<          mainPanel.add(panelXML);
<          mainPanel.add(Box.createVerticalStrut(20));
<          mainPanel.add(panelImg);
<          mainPanel.add(Box.createVerticalStrut(15));
<          mainPanel.setBorder(BorderFactory.createTitledBorder(""));
<          this.add(mainPanel);
<          this.setPanelTitle("");
<          SPTBatch_.this.nextButton.addActionListener(new ActionListener() {
<             public void actionPerformed(ActionEvent event) {
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_TRANSF_PATH, textXML.getText());
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_IMAGES_PATH, textImg.getText());
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_MIN_SPOT, SPTBatch_.minTracks.getText());
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_MAX_SPOT, SPTBatch_.maxTracks.getText());
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_LENGTH_TH, SPTBatch_.thLength.getText());
<                SPTBatch_.pref1.put(SPTBatch_.this.TRACKMATE_DIFF_TH, SPTBatch_.thD14.getText());
<                if (SPTBatch_.checkboxDiff.isSelected()) {
<                   SPTBatch_.pref1.put(SPTBatch_.TRACKMATE_MIN_TRACK, traJParametersWindow.minLengthText.getText());
<                   SPTBatch_.pref1.put(SPTBatch_.TRACKMATE_WINDOW, traJParametersWindow.windowText.getText());
<                   SPTBatch_.pref1.put(SPTBatch_.TRACKMATE_MIN_SEGMENT, traJParametersWindow.minSegText.getText());
<                }
< 
<             }
<          });
<       }
<    }
< 
<    class LastWizardPanel extends SPTBatch_.LabelWizardPanel {
<       public LastWizardPanel(JWizardComponents wizardComponents) {
<          super(wizardComponents, "");
<          this.setPanelTitle("");
<          this.update();
<          this.removeAll();
<          JTabbedPane tabbedPane = new JTabbedPane();
<          ImageIcon iconSpot = SPTBatch_.this.createImageIcon("5441165-point-of-light-png-104-images-in-collection-page-1-point-of-light-png-320_320_preview.png");
<          Icon iconSpotCell = new ImageIcon(iconSpot.getImage().getScaledInstance(12, 12, 4));
<          ImageIcon iconLink = SPTBatch_.this.createImageIcon("link.png");
<          Icon iconLinkCell = new ImageIcon(iconLink.getImage().getScaledInstance(16, 16, 4));
<          ImageIcon iconTrack = SPTBatch_.this.createImageIcon("track.jpg");
<          Icon iconTrackCell = new ImageIcon(iconTrack.getImage().getScaledInstance(16, 16, 4));
<          JComponent panel1 = SPTBatch_.this.makeTextPanel("");
<          JComponent panelX = SPTBatch_.this.makeTextPanel("");
<          JComponent panelY = SPTBatch_.this.makeTextPanel("");
<          panelY.setLayout(new FlowLayout(0));
<          JLabel xSpot = new JLabel();
<          xSpot.setText(" Spot-Feature for X axis:   ");
<          xSpot.setFont(new Font("Verdana", 1, 12));
<          JLabel ySpot = new JLabel();
<          ySpot.setText(" Spot-Feature for Y axis:   ");
<          ySpot.setFont(new Font("Verdana", 1, 12));
<          SPTBatch_.this.comboSpotsX = new JComboBox();
<          SPTBatch_.this.comboSpotsY = new JComboBox();
<          Object[] spotItems = null;
<          spotItems = new Object[]{"QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T\tFRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1"};
< 
<          for(int ixx = 0; ixx < spotItems.length; ++ixx) {
<             SPTBatch_.this.comboSpotsX.addItem(spotItems[ixx]);
<             SPTBatch_.this.comboSpotsY.addItem(spotItems[ixx]);
<          }
< 
<          panelX.setLayout(new FlowLayout(0));
<          panelX.add(Box.createVerticalStrut(10));
<          panelX.add(xSpot);
<          panelX.add(Box.createVerticalStrut(5));
<          panelX.add(SPTBatch_.this.comboSpotsX);
<          panelY.add(ySpot);
<          panelY.add(Box.createVerticalStrut(5));
<          panelY.add(SPTBatch_.this.comboSpotsY);
<          panel1.setLayout(new BoxLayout(panel1, 1));
<          panel1.add(panelX);
<          panel1.add(panelY);
<          JPanel panelESP = new JPanel(new FlowLayout(1));
<          panelESP.setBorder(BorderFactory.createLoweredBevelBorder());
<          SPTBatch_.ESP = new JCheckBox("  Export User-Defined Spot Plot.");
<          panelESP.add(SPTBatch_.ESP);
<          panel1.add(Box.createVerticalStrut(15));
<          panel1.add(panelESP);
<          panel1.setBorder(BorderFactory.createTitledBorder(""));
<          tabbedPane.addTab("Spots", iconSpotCell, panel1, "Select the X-Y Spot features to plot.");
<          tabbedPane.setMnemonicAt(0, 49);
<          JComponent panel2 = SPTBatch_.this.makeTextPanel("");
<          JComponent panelLinkX = SPTBatch_.this.makeTextPanel("");
<          JComponent panelLinkY = SPTBatch_.this.makeTextPanel("");
<          panelLinkX.setLayout(new FlowLayout(0));
<          panelLinkY.setLayout(new FlowLayout(0));
<          JLabel xLink = new JLabel();
<          xLink.setText(" Link-Feature for X axis:   ");
<          xLink.setFont(new Font("Verdana", 1, 12));
<          JLabel yLink = new JLabel();
<          yLink.setText(" Link-Feature for Y axis:   ");
<          yLink.setFont(new Font("Verdana", 1, 12));
<          SPTBatch_.this.comboLinkX = new JComboBox();
<          SPTBatch_.this.comboLinkY = new JComboBox();
<          Object[] edgeItems = new Object[]{"SPOT_SOURCE_ID", "SPOT_TARGET_ID", "LINK_COST", "DIRECTIONAL_CHANGE_RATE", "SPEED", "DISPLACEMENT", "EDGE_TIME", "EDGE_X_LOCATION", "EDGE_Y_LOCATION", "EDGE_Z_LOCATION"};
< 
<          for(int i = 0; i < edgeItems.length; ++i) {
<             SPTBatch_.this.comboLinkX.addItem(edgeItems[i]);
<             SPTBatch_.this.comboLinkY.addItem(edgeItems[i]);
<          }
< 
<          panelLinkX.setLayout(new FlowLayout(0));
<          panelLinkX.add(Box.createVerticalStrut(10));
<          panelLinkX.add(xLink);
<          panelLinkX.add(Box.createVerticalStrut(5));
<          panelLinkX.add(SPTBatch_.this.comboLinkX);
<          panelLinkY.add(yLink);
<          panelLinkY.add(Box.createVerticalStrut(5));
<          panelLinkY.add(SPTBatch_.this.comboLinkY);
<          panel2.setLayout(new BoxLayout(panel2, 1));
<          panel2.add(panelLinkX);
<          panel2.add(panelLinkY);
<          JPanel panelELP = new JPanel(new FlowLayout(1));
<          panelELP.setBorder(BorderFactory.createLoweredBevelBorder());
<          SPTBatch_.ELP = new JCheckBox("  Export User-Defined Links Plot.");
<          panelELP.add(SPTBatch_.ELP);
<          panel2.add(Box.createVerticalStrut(15));
<          panel2.add(panelELP);
<          panel2.setBorder(BorderFactory.createTitledBorder(""));
<          tabbedPane.addTab("Links", iconLinkCell, panel2, "Select the  X-Y Link features to plot.");
<          tabbedPane.setMnemonicAt(1, 50);
<          JComponent panel3 = SPTBatch_.this.makeTextPanel("");
<          JComponent panelTrackX = SPTBatch_.this.makeTextPanel("");
<          JComponent panelTrackY = SPTBatch_.this.makeTextPanel("");
<          panelTrackX.setLayout(new FlowLayout(0));
<          panelTrackY.setLayout(new FlowLayout(0));
<          JLabel xTrack = new JLabel();
<          xTrack.setText(" Track-Feature for X axis:   ");
<          xTrack.setFont(new Font("Verdana", 1, 12));
<          JLabel yTrack = new JLabel();
<          yTrack.setText(" Track-Feature for Y axis:   ");
<          yTrack.setFont(new Font("Verdana", 1, 12));
<          SPTBatch_.this.comboTrackX = new JComboBox();
<          SPTBatch_.this.comboTrackY = new JComboBox();
<          Object[] trackItems = null;
<          trackItems = new Object[]{"TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE"};
< 
<          for(int ix = 0; ix < trackItems.length; ++ix) {
<             SPTBatch_.this.comboTrackX.addItem(trackItems[ix]);
<             SPTBatch_.this.comboTrackY.addItem(trackItems[ix]);
<          }
< 
<          panelTrackX.setLayout(new FlowLayout(0));
<          panelTrackX.add(Box.createVerticalStrut(10));
<          panelTrackX.add(xTrack);
<          panelTrackX.add(Box.createVerticalStrut(5));
<          panelTrackX.add(SPTBatch_.this.comboTrackX);
<          panelTrackY.add(yTrack);
<          panelTrackY.add(Box.createVerticalStrut(5));
<          panelTrackY.add(SPTBatch_.this.comboTrackY);
<          panel3.setLayout(new BoxLayout(panel3, 1));
<          panel3.add(panelTrackX);
<          panel3.add(panelTrackY);
<          JPanel panelETP = new JPanel(new FlowLayout(1));
<          panelETP.setBorder(BorderFactory.createLoweredBevelBorder());
<          SPTBatch_.ETP = new JCheckBox("  Export User-Defined Tracks Plot.");
<          panelETP.add(SPTBatch_.ETP);
<          panel3.add(Box.createVerticalStrut(15));
<          panel3.add(panelETP);
<          panel3.setBorder(BorderFactory.createTitledBorder(""));
<          tabbedPane.addTab("Tracks", iconTrackCell, panel3, "Select the  X-Y Track features to plot.");
<          tabbedPane.setMnemonicAt(2, 51);
<          tabbedPane.setPreferredSize(new java.awt.Dimension(450, 250));
<          this.add(tabbedPane);
<          tabbedPane.setTabLayoutPolicy(1);
<       }
< 
<       public void update() {
<          this.setNextButtonEnabled(false);
<          if (SPTBatch_.this.itemCheckPlot == 1) {
<             this.setNextButtonEnabled(false);
<          }
< 
<          this.setFinishButtonEnabled(true);
<          this.setBackButtonEnabled(true);
<       }
< 
<       public void next() {
<       }
< 
<       public void back() {
<          this.switchPanel(0);
<       }
< 
<       public void finish() {
<          this.switchPanel(2);
<       }
<    }
< 
<    private static class NSpotPerFrameDataset extends ModelDataset {
<       private static final long serialVersionUID = 1L;
<       private final double[] time;
<       private final int[] nspots;
< 
<       public NSpotPerFrameDataset(Model model, SelectionModel selectionModel, DisplaySettings ds, double[] time, int[] nspots) {
<          super(model, selectionModel, ds, "POSITION_T", Collections.singletonList("N spots"));
<          this.time = time;
<          this.nspots = nspots;
<       }
< 
<       public int getItemCount(int series) {
<          return this.nspots.length;
<       }
< 
<       public Number getX(int series, int item) {
<          return this.time[item];
<       }
< 
<       public Number getY(int series, int item) {
<          return (double)this.nspots[item];
<       }
< 
<       public String getSeriesKey(int series) {
<          return (String)this.yFeatures.get(series);
<       }
< 
<       public String getItemLabel(int item) {
<          return "" + item;
<       }
< 
<       public void setItemLabel(int item, String label) {
<       }
< 
<       public XYItemRenderer getRenderer() {
<          return new XYLineAndShapeRenderer(true, true);
<       }
<    }
< 
<    class OptionWizardPanel extends SPTBatch_.LabelWizardPanel {
<       public OptionWizardPanel(JWizardComponents wizardComponents, String option) {
<          super(wizardComponents, "");
<          this.setPanelTitle("  Check options to export Tracking results");
<       }
< 
<       public void update1() {
<          this.setNextButtonEnabled(false);
<          this.setFinishButtonEnabled(true);
<          this.setBackButtonEnabled(true);
<       }
< 
<       public void next() {
<          this.switchPanel(4);
<       }
< 
<       public void back() {
<          this.switchPanel(1);
<          if (SPTBatch_.this.itemCheckPlot == 1) {
<             this.switchPanel(4);
<          }
< 
<          if (SPTBatch_.this.itemPlot2 == 1) {
<             this.switchPanel(4);
<          }
< 
<          if (SPTBatch_.this.itemPlot2 == 1 && SPTBatch_.this.itemCheckPlot == 1) {
<             this.switchPanel(4);
<          }
< 
<       }
< 
<       public void finish() {
<          this.switchPanel(2);
<       }
<    }
< }
---
> /*      */ import checkable.CheckableItem;
> /*      */ import checkable.CheckedComboBox;
> /*      */ import fiji.plugin.trackmate.Dimension;
> /*      */ import fiji.plugin.trackmate.FeatureModel;
> /*      */ import fiji.plugin.trackmate.Logger;
> /*      */ import fiji.plugin.trackmate.Model;
> /*      */ import fiji.plugin.trackmate.SelectionModel;
> /*      */ import fiji.plugin.trackmate.Settings;
> /*      */ import fiji.plugin.trackmate.Spot;
> /*      */ import fiji.plugin.trackmate.SpotCollection;
> /*      */ import fiji.plugin.trackmate.SpotRoi;
> /*      */ import fiji.plugin.trackmate.TrackMate;
> /*      */ import fiji.plugin.trackmate.action.PlotNSpotsVsTimeAction;
> /*      */ import fiji.plugin.trackmate.detection.DogDetectorFactory;
> /*      */ import fiji.plugin.trackmate.detection.LogDetectorFactory;
> /*      */ import fiji.plugin.trackmate.detection.SpotDetectorFactoryBase;
> /*      */ import fiji.plugin.trackmate.features.EdgeCollectionDataset;
> /*      */ import fiji.plugin.trackmate.features.FeatureFilter;
> /*      */ import fiji.plugin.trackmate.features.FeatureUtils;
> /*      */ import fiji.plugin.trackmate.features.ModelDataset;
> /*      */ import fiji.plugin.trackmate.features.SpotCollectionDataset;
> /*      */ import fiji.plugin.trackmate.features.TrackCollectionDataset;
> /*      */ import fiji.plugin.trackmate.graph.ConvexBranchesDecomposition;
> /*      */ import fiji.plugin.trackmate.graph.TimeDirectedNeighborIndex;
> /*      */ import fiji.plugin.trackmate.gui.Fonts;
> /*      */ import fiji.plugin.trackmate.gui.displaysettings.Colormap;
> /*      */ import fiji.plugin.trackmate.gui.displaysettings.DisplaySettings;
> /*      */ import fiji.plugin.trackmate.gui.displaysettings.DisplaySettingsIO;
> /*      */ import fiji.plugin.trackmate.io.TmXmlReader;
> /*      */ import fiji.plugin.trackmate.tracking.LAPUtils;
> /*      */ import fiji.plugin.trackmate.tracking.ManualTrackerFactory;
> /*      */ import fiji.plugin.trackmate.tracking.SpotTrackerFactory;
> /*      */ import fiji.plugin.trackmate.tracking.kalman.KalmanTrackerFactory;
> /*      */ import fiji.plugin.trackmate.tracking.sparselap.SimpleSparseLAPTrackerFactory;
> /*      */ import fiji.plugin.trackmate.tracking.sparselap.SparseLAPTrackerFactory;
> /*      */ import fiji.plugin.trackmate.util.ExportableChartPanel;
> /*      */ import fiji.plugin.trackmate.util.TMUtils;
> /*      */ import fiji.plugin.trackmate.visualization.FeatureColorGenerator;
> /*      */ import fiji.plugin.trackmate.visualization.PerTrackFeatureColorGenerator;
> /*      */ import fiji.plugin.trackmate.visualization.hyperstack.HyperStackDisplayer;
> /*      */ import fiji.plugin.trackmate.visualization.hyperstack.SpotOverlay;
> /*      */ import fiji.plugin.trackmate.visualization.hyperstack.TrackOverlay;
> /*      */ import fiji.plugin.trackmate.visualization.table.TablePanel;
> /*      */ import ij.IJ;
> /*      */ import ij.ImagePlus;
> /*      */ import ij.ImageStack;
> /*      */ import ij.gui.OvalRoi;
> /*      */ import ij.gui.Overlay;
> /*      */ import ij.gui.PolygonRoi;
> /*      */ import ij.gui.Roi;
> /*      */ import ij.gui.ShapeRoi;
> /*      */ import ij.measure.Calibration;
> /*      */ import ij.measure.ResultsTable;
> /*      */ import ij.plugin.ZProjector;
> /*      */ import ij.plugin.frame.RoiManager;
> /*      */ import ij.process.ColorProcessor;
> /*      */ import ij.process.ImageProcessor;
> /*      */ import inra.ijpb.morphology.Morphology;
> /*      */ import inra.ijpb.morphology.Strel;
> /*      */ import java.awt.BorderLayout;
> /*      */ import java.awt.Button;
> /*      */ import java.awt.Color;
> /*      */ import java.awt.Component;
> /*      */ import java.awt.Dimension;
> /*      */ import java.awt.FlowLayout;
> /*      */ import java.awt.Font;
> /*      */ import java.awt.Graphics2D;
> /*      */ import java.awt.GridBagConstraints;
> /*      */ import java.awt.GridBagLayout;
> /*      */ import java.awt.GridLayout;
> /*      */ import java.awt.Image;
> /*      */ import java.awt.Insets;
> /*      */ import java.awt.Panel;
> /*      */ import java.awt.Rectangle;
> /*      */ import java.awt.RenderingHints;
> /*      */ import java.awt.TextField;
> /*      */ import java.awt.event.ActionEvent;
> /*      */ import java.awt.event.ActionListener;
> /*      */ import java.awt.event.ItemEvent;
> /*      */ import java.awt.event.ItemListener;
> /*      */ import java.awt.event.MouseAdapter;
> /*      */ import java.awt.event.MouseEvent;
> /*      */ import java.awt.image.BufferedImage;
> /*      */ import java.io.File;
> /*      */ import java.io.FileWriter;
> /*      */ import java.io.IOException;
> /*      */ import java.net.URL;
> /*      */ import java.text.DecimalFormat;
> /*      */ import java.text.NumberFormat;
> /*      */ import java.util.ArrayList;
> /*      */ import java.util.Arrays;
> /*      */ import java.util.Collections;
> /*      */ import java.util.Comparator;
> /*      */ import java.util.HashMap;
> /*      */ import java.util.HashSet;
> /*      */ import java.util.Iterator;
> /*      */ import java.util.LinkedHashSet;
> /*      */ import java.util.List;
> /*      */ import java.util.Map;
> /*      */ import java.util.Set;
> /*      */ import java.util.function.BiConsumer;
> /*      */ import java.util.function.BiFunction;
> /*      */ import java.util.function.Function;
> /*      */ import java.util.function.Supplier;
> /*      */ import java.util.prefs.Preferences;
> /*      */ import java.util.stream.Collectors;
> /*      */ import java.util.stream.Stream;
> /*      */ import javax.swing.BorderFactory;
> /*      */ import javax.swing.Box;
> /*      */ import javax.swing.BoxLayout;
> /*      */ import javax.swing.ButtonGroup;
> /*      */ import javax.swing.DefaultComboBoxModel;
> /*      */ import javax.swing.Icon;
> /*      */ import javax.swing.ImageIcon;
> /*      */ import javax.swing.JButton;
> /*      */ import javax.swing.JCheckBox;
> /*      */ import javax.swing.JComboBox;
> /*      */ import javax.swing.JComponent;
> /*      */ import javax.swing.JFrame;
> /*      */ import javax.swing.JLabel;
> /*      */ import javax.swing.JOptionPane;
> /*      */ import javax.swing.JPanel;
> /*      */ import javax.swing.JProgressBar;
> /*      */ import javax.swing.JScrollPane;
> /*      */ import javax.swing.JSeparator;
> /*      */ import javax.swing.JTabbedPane;
> /*      */ import javax.swing.JTable;
> /*      */ import javax.swing.JTextArea;
> /*      */ import javax.swing.JTextField;
> /*      */ import javax.swing.SwingUtilities;
> /*      */ import javax.swing.UIManager;
> /*      */ import javax.swing.UnsupportedLookAndFeelException;
> /*      */ import javax.swing.table.DefaultTableModel;
> /*      */ import javax.swing.text.DefaultCaret;
> /*      */ import javax.xml.parsers.DocumentBuilder;
> /*      */ import javax.xml.parsers.DocumentBuilderFactory;
> /*      */ import javax.xml.parsers.ParserConfigurationException;
> /*      */ import javax.xml.xpath.XPath;
> /*      */ import javax.xml.xpath.XPathConstants;
> /*      */ import javax.xml.xpath.XPathExpression;
> /*      */ import javax.xml.xpath.XPathExpressionException;
> /*      */ import javax.xml.xpath.XPathFactory;
> /*      */ import jwizardcomponent.JWizardComponents;
> /*      */ import jwizardcomponent.JWizardPanel;
> /*      */ import jwizardcomponent.Utilities;
> /*      */ import jwizardcomponent.frame.JWizardFrame;
> /*      */ import loci.plugins.in.DisplayHandler;
> /*      */ import loci.plugins.in.ImportProcess;
> /*      */ import loci.plugins.in.ImporterOptions;
> /*      */ import net.imglib2.RealLocalizable;
> /*      */ import org.jfree.chart.ChartFactory;
> /*      */ import org.jfree.chart.ChartUtils;
> /*      */ import org.jfree.chart.JFreeChart;
> /*      */ import org.jfree.chart.axis.NumberAxis;
> /*      */ import org.jfree.chart.labels.CategoryItemLabelGenerator;
> /*      */ import org.jfree.chart.labels.StandardCategoryItemLabelGenerator;
> /*      */ import org.jfree.chart.plot.CategoryPlot;
> /*      */ import org.jfree.chart.plot.PlotOrientation;
> /*      */ import org.jfree.chart.plot.XYPlot;
> /*      */ import org.jfree.chart.renderer.category.CategoryItemRenderer;
> /*      */ import org.jfree.chart.renderer.xy.XYItemRenderer;
> /*      */ import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
> /*      */ import org.jfree.chart.ui.RectangleInsets;
> /*      */ import org.jfree.data.category.CategoryDataset;
> /*      */ import org.jfree.data.category.DefaultCategoryDataset;
> /*      */ import org.jfree.data.xy.DefaultXYDataset;
> /*      */ import org.jfree.data.xy.XYDataset;
> /*      */ import org.jgrapht.graph.DefaultEdge;
> /*      */ import org.jgrapht.graph.DefaultWeightedEdge;
> /*      */ import org.jgrapht.graph.SimpleDirectedGraph;
> /*      */ import org.w3c.dom.Document;
> /*      */ import org.w3c.dom.Node;
> /*      */ import org.w3c.dom.NodeList;
> /*      */ import org.xml.sax.SAXException;
> /*      */ import smileModified.GaussianMixtureModified;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ public class SPTBatch_
> /*      */ {
> /*      */   static String csvPath;
> /*      */   static String imgTitle;
> /*      */   static String RADIUS;
> /*      */   private String imagesPath;
> /*      */   private String zstart;
> /*      */   private String zend;
> /*      */   private String ystart;
> /*      */   private String yend;
> /*      */   private String xstart;
> /*      */   private String xend;
> /*      */   private String tstart;
> /*      */   private String tend;
> /*      */   private String THRESHOLD;
> /*      */   private String TARGET_CHANNEL;
> /*      */   private String DO_SUBPIXEL_LOCALIZATION;
> /*      */   private String DO_MEDIAN_FILTERING;
> /*      */   private String DETECTOR_NAME;
> /*      */   private String NSPLIT;
> /*      */   private String DOWNSAMPLE_FACTOR;
> /*      */   private String initialSpotFilter;
> /*      */   private String TRACKER_NAME;
> /*      */   private String CUTOFF_PERCENTILE;
> /*      */   private String ALTERNATIVE_LINKING_COST_FACTOR;
> /*      */   private String LINKING_MAX_DISTANCE;
> /*      */   private String MAX_FRAME_GAP;
> /*      */   private String MAX_DISTANCE;
> /*      */   private String ALLOW_GAP_CLOSING;
> /*      */   private String SPLITTING_MAX_DISTANCE;
> /*      */   private String ALLOW_TRACK_SPLITTING;
> /*      */   private String MERGING_MAX_DISTANCE;
> /*      */   private String ALLOW_TRACK_MERGING;
> /*      */   private String BLOCKING_VALUE;
> /*      */   private String TransfPath;
> /*      */   private String enableImages;
> /*      */   private String enableLog;
> /*      */   private String enableXML;
> /*      */   private String enableRois;
> /*      */   private String xmlPath;
> /*      */   private String checkEnable;
> /*      */   private String enableCsv;
> /*      */   private String TRACKMATE_TRANSF_PATH;
> /*      */   private String TRACKMATE_IMAGES_PATH;
> /*      */   private String TRACKMATE_CSV_PATH;
> /*      */   private String TRACKMATE_XML_PATH;
> /*      */   private String TRACKMATE_TXT_PATH;
> /*      */   private String TRACKMATE_OUT_PATH;
> /*      */   private String xSelectedSpot;
> /*      */   private String ySelectedSpot;
> /*      */   private String xSelectedLink;
> /*      */   private String ySelectedLink;
> /*      */   private String xSelectedTrack;
> /*      */   private String ySelectedTrack;
> /*      */   private String enablePlotF;
> /*      */   private String enableSql;
> /*      */   private String enableST;
> /*      */   private String enableSpotTable;
> /*      */   private String enableLinkTable;
> /*      */   private String enableTrackTable;
> /*      */   private String enableBranchTable;
> /*      */   private String enablePlot;
> /*      */   private String titleExportLink;
> /*      */   private String titleExportTrack;
> /*      */   private String linkingNames;
> /*      */   private String linkingValues;
> /*      */   private String initialFilterFeature;
> /*      */   private String initialFilterValue;
> /*      */   private String initialFilterAbove;
> /*  343 */   private String selectedOption = "N"; private String enableCovariance; private String enableRegression; private String enableKalman; private String trackFilterFeature; private String trackFilterValue; private String trackFilterAbove; private String TRACKMATE_MIN_SPOT; private String TRACKMATE_MAX_SPOT; private String TRACKMATE_LENGTH_TH; private String TRACKMATE_DIFF_TH; public static String TRACKMATE_MIN_TRACK;
> /*      */   public static String TRACKMATE_WINDOW;
> /*      */   public static String TRACKMATE_MIN_SEGMENT;
> /*      */   public static String TRACKMATE_COLUMN_PARAM;
> /*  347 */   String[] columnsMovements = new String[] { "Total Tracks.", "Long Tracks", "Long Confined", 
> /*  348 */       "Long Unidirectional Ballistic", "Long Free.", "Long Direct.", "Immob" }; private int[] dims; private JFreeChart chart; private JFrame frameChartNS; private Map<String, Double> hm; public static Thread mainProcess; public static final int PANEL_FIRST = 0; public static final int PANEL_CHOOSER = 1; public static final int PANEL_OPTION_A = 2;
> /*      */   public static final int PANEL_OPTION_B = 3;
> /*      */   public static final int PANEL_LAST = 4;
> /*      */   private ImagePlus imp;
> /*      */   private ImagePlus capture;
> /*      */   private JWizardPanel panel;
> /*      */   private JButton nextButton;
> /*      */   private JButton backButton;
> /*      */   private JButton cancelButton;
> /*      */   private JButton finishButton;
> /*      */   private JButton buttonCsv;
> /*      */   private JButton trajButton;
> /*      */   private JButton summaryButton;
> /*      */   private CheckedComboBox comboP;
> /*      */   public static JCheckBox checkbox2;
> /*      */   public static JCheckBox checkbox3;
> /*      */   public static JCheckBox checkbox4;
> /*      */   public static JCheckBox checkboxRoi;
> /*      */   public static JCheckBox checkboxPlot;
> /*      */   public static JCheckBox checkPlot;
> /*      */   public static JCheckBox checkboxAnalysis;
> /*      */   public static JCheckBox checkboxST;
> /*      */   public static JCheckBox ESP;
> /*      */   public static JCheckBox ELP;
> /*      */   public static JCheckBox ETP;
> /*      */   public static JCheckBox checkbox1;
> /*  374 */   private final String SPOT_TABLE_NAME = "Spots in tracks statistics", EDGE_TABLE_NAME = "Links in tracks statistics"; public static JCheckBox checkboxDiff; public static JCheckBox checkboxSP; public static JCheckBox checkboxMSD; public static JCheckBox checkDispSpots; public static JCheckBox checkDispSpotName; public static JCheckBox checkDispTracks; public static JCheckBox checkSummary; public static JCheckBox checkPBS; public static JCheckBox checkCluster; public static JCheckBox checkMonomer; public static JCheckBox checkTracks; public static JCheckBox checkboxSubBg; public static JCheckBox checkExcludeTracks; private int itemCheckPlot; private Button buttonXMLL; private Button buttonImg; public static Preferences pref1; private Settings settings; public static int a; public static int minTracksJTF; public static int maxTracksJTF; public static int thLengthJTF; public static int i; private double thD14JTF; private JFrame f; private JWizardFrame wizard; private TrackMate trackmate; private Logger loggers; private ResultsTable spotTable; private ResultsTable linkTable; private ResultsTable trackTable; private ResultsTable rtSpot; private ResultsTable rtLink; private ResultsTable rtTrack;
> /*  375 */   private final String TRACK_TABLE_NAME = "Track statistics"; private final String ID_COLUMN = "ID"; private Spot[] source; public static Model model; public static SelectionModel selectionModel; public static ImagePlus imps; public static ImagePlus impsSubBg; public ImagePlus impsNano; private HyperStackDisplayer displayer; private String[] imageTitles; private Set<Spot> track; private static final String TRACK_ID_COLUMN = "TRACK_ID"; private PlotNSpotsVsTimeAction plot; private JFreeChart chartSpot; private JFreeChart chartLink; private JFreeChart chartTrack; private int itemPlot2; private int totalTracksDef; private int longTracksDef; private int longConfinedDef; private int longUniBalDef; private int longFreeDef; private int longDirectDef; private int immobDef; private int shortTracksDef; private int shortConfinedDef; private int shortAnomDef; private int shortFreeDef; private int shortDirectDef; public static File directImages; public static File directChemo; public static File directDiff; public static File directMSS; public static File directCluster; private JProgressBar progressBar; public static File directSummary; public static File fileXmlInitial; public static File directPBS;
> /*      */   public static File directSPT;
> /*      */   static JTextArea taskOutput;
> /*      */   private JComboBox comboSpotsX;
> /*      */   private JComboBox comboSpotsY;
> /*      */   private JComboBox comboLinkX;
> /*      */   private JComboBox comboLinkY;
> /*      */   private JComboBox comboTrackX;
> /*      */   private JComboBox comboTrackY;
> /*      */   private JComboBox comboSubBg;
> /*      */   private JComboBox comboDispTracks;
> /*      */   PerTrackFeatureColorGenerator tcg;
> /*      */   Calibration calibration;
> /*      */   static JTable trackJTable;
> /*      */   static JTable linkJTable;
> /*      */   public ImagePlus[] lifs;
> /*      */   ArrayList<Float> xPosition;
> /*      */   ArrayList<Float> yPosition;
> /*      */   ArrayList<Integer> tracksID;
> /*      */   ArrayList<Integer> framePosition;
> /*      */   static JTextField chemoScaling;
> /*      */   static JTextField minTracks;
> /*      */   static JTextField maxTracks;
> /*      */   static JTextField thLength;
> /*      */   static JTextField thD14;
> /*      */   static JTextField monomerField;
> /*      */   public static RoiManager roiManager;
> /*      */   public static ImagePlus impMaxProject;
> /*      */   public static ImagePlus impMainRoi;
> /*      */   public static ImagePlus[] slices;
> /*      */   public static double[] slicesIntensityBg;
> /*      */   public static double[] slicesIntensitySpot;
> /*  407 */   static JTable tableSpot = null; static String[] columnNamesTrack;
> /*      */   static String[] columnNamesSpot;
> /*  409 */   List<List<List<String>>> dataAllItemsDef = new ArrayList<>();
> /*      */   ArrayList<Integer> indexes;
> /*      */   static List<Integer> nOfTracks;
> /*  412 */   List<String> selectedItems = null;
> /*      */   static double fps;
> /*  414 */   ResultsTable[] rtSpots = null; ResultsTable[] rtLinks = null; ResultsTable[] rtTracks = null; List<Boolean> excludeTrack; DisplaySettings ds; ResultsTable rtTrackPerImage; private static final String TRACK_ID = "TRACK_ID"; private static final String N_PREDECESSORS = "N_PREDECESSORS"; private static final String N_SUCCESSORS = "N_SUCCESSORS"; private static final String DELTA_T = "DELTA_T";
> /*      */   private static final String DISTANCE = "DISTANCE";
> /*      */   private static final String MEAN_VELOCITY = "MEAN_VELOCITY";
> /*      */   private static final String FIRST = "FIRST";
> /*      */   private static final String LAST = "LAST";
> /*      */   
> /*      */   public SPTBatch_(String xmlPath, String imagesPath) {
> /*  421 */     this.xmlPath = xmlPath;
> /*  422 */     this.imagesPath = imagesPath;
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public void run(String arg) {
> /*  428 */     this.TRACKMATE_TRANSF_PATH = "transf_path";
> /*  429 */     this.TRACKMATE_IMAGES_PATH = "images_path";
> /*  430 */     this.TRACKMATE_CSV_PATH = "csv_path";
> /*  431 */     this.TRACKMATE_XML_PATH = "xml_path";
> /*  432 */     this.TRACKMATE_TXT_PATH = "txt_path";
> /*  433 */     this.TRACKMATE_OUT_PATH = "out_path";
> /*  434 */     this.TRACKMATE_MIN_SPOT = "min_spot";
> /*  435 */     this.TRACKMATE_MAX_SPOT = "max_spot";
> /*  436 */     this.TRACKMATE_LENGTH_TH = "length_th";
> /*  437 */     this.TRACKMATE_DIFF_TH = "diff_th";
> /*  438 */     TRACKMATE_MIN_TRACK = "min_track";
> /*  439 */     TRACKMATE_WINDOW = "window";
> /*  440 */     TRACKMATE_MIN_SEGMENT = "min_segment";
> /*  441 */     TRACKMATE_COLUMN_PARAM = "column_param";
> /*  442 */     pref1 = Preferences.userRoot();
> /*  443 */     JFrame.setDefaultLookAndFeelDecorated(true); try {
> /*      */       byte b; int i; UIManager.LookAndFeelInfo[] arrayOfLookAndFeelInfo;
> /*  445 */       for (i = (arrayOfLookAndFeelInfo = UIManager.getInstalledLookAndFeels()).length, b = 0; b < i; ) { UIManager.LookAndFeelInfo info = arrayOfLookAndFeelInfo[b];
> /*  446 */         if ("Nimbus".equals(info.getName())) {
> /*  447 */           UIManager.setLookAndFeel(info.getClassName()); break;
> /*      */         } 
> /*      */         b++; }
> /*      */     
> /*  451 */     } catch (UnsupportedLookAndFeelException unsupportedLookAndFeelException) {
> /*      */     
> /*  453 */     } catch (ClassNotFoundException classNotFoundException) {
> /*      */     
> /*  455 */     } catch (InstantiationException instantiationException) {
> /*      */     
> /*  457 */     } catch (IllegalAccessException illegalAccessException) {}
> /*      */ 
> /*      */     
> /*  460 */     this.wizard = new JWizardFrame();
> /*  461 */     this.wizard.setTitle("SPT-Batch");
> /*      */     
> /*  463 */     this.panel = new FirstWizardPanel(this.wizard.getWizardComponents());
> /*  464 */     this.wizard.getWizardComponents().addWizardPanel(0, this.panel);
> /*      */     
> /*  466 */     this.panel = new ChooserWizardPanel(this.wizard.getWizardComponents());
> /*  467 */     this.wizard.getWizardComponents().addWizardPanel(1, this.panel);
> /*      */     
> /*  469 */     this.panel = new OptionWizardPanel(this.wizard.getWizardComponents(), "A");
> /*  470 */     this.wizard.getWizardComponents().addWizardPanel(2, this.panel);
> /*      */     
> /*  472 */     this.panel = new OptionWizardPanel(this.wizard.getWizardComponents(), "B");
> /*  473 */     this.wizard.getWizardComponents().addWizardPanel(3, this.panel);
> /*      */     
> /*  475 */     this.panel = new LastWizardPanel(this.wizard.getWizardComponents());
> /*  476 */     this.wizard.getWizardComponents().addWizardPanel(4, this.panel);
> /*      */     
> /*  478 */     this.wizard.getWizardComponents().removeWizardPanel(0);
> /*      */     
> /*  480 */     this.wizard.setSize(550, 700);
> /*  481 */     Utilities.centerComponentOnScreen((Component)this.wizard);
> /*  482 */     this.wizard.setResizable(false);
> /*  483 */     this.wizard.setVisible(true);
> /*      */     
> /*  485 */     mainProcess = new Thread(new Runnable()
> /*      */         {
> /*      */           public void run()
> /*      */           {
> /*  489 */             SPTBatch_.this.xSelectedSpot = SPTBatch_.this.comboSpotsX.getSelectedItem().toString();
> /*  490 */             SPTBatch_.this.ySelectedSpot = SPTBatch_.this.comboSpotsY.getSelectedItem().toString();
> /*      */ 
> /*      */             
> /*  493 */             SPTBatch_.this.xSelectedLink = SPTBatch_.this.comboLinkX.getSelectedItem().toString();
> /*  494 */             SPTBatch_.this.ySelectedLink = SPTBatch_.this.comboLinkY.getSelectedItem().toString();
> /*      */ 
> /*      */             
> /*  497 */             SPTBatch_.this.xSelectedTrack = SPTBatch_.this.comboTrackX.getSelectedItem().toString();
> /*  498 */             SPTBatch_.this.ySelectedTrack = SPTBatch_.this.comboTrackY.getSelectedItem().toString();
> /*      */             
> /*  500 */             SPTBatch_.fileXmlInitial = new File(SPTBatch_.this.xmlPath);
> /*  501 */             File imageFolder = new File(SPTBatch_.this.imagesPath);
> /*  502 */             final File[] listOfFiles = imageFolder.listFiles();
> /*  503 */             SPTBatch_.this.imageTitles = new String[listOfFiles.length];
> /*  504 */             File[] filesXML = new File[listOfFiles.length];
> /*  505 */             for (int u = 0; u < filesXML.length; u++)
> /*  506 */               filesXML[u] = new File(SPTBatch_.this.xmlPath); 
> /*  507 */             Object[] columHeadersFinalSpot = { "IMAGE_TITLE", "QUALITY", "POSITION_X", "POSITION_Y", 
> /*  508 */                 "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MEAN_INTENSITY", 
> /*  509 */                 "MEDIAN_INTENSITY", "MIN_INTENSITY", "MAX_INTENSITY", "TOTAL_INTENSITY", "STANDARD_DEVIATION", 
> /*  510 */                 "CONTRAST", "SNR", "ESTIMATED_DIAMETER", "MORPHOLOGY", "ELLIPSOIDFIT_SEMIAXISLENGTH_C", 
> /*  511 */                 "ELLIPSOIDFIT_SEMIAXISLENGTH_B", "ELLIPSOIDFIT_SEMIAXISLENGTH_A", "ELLIPSOIDFIT_AXISPHI_C", 
> /*  512 */                 "ELLIPSOIDFIT_AXISPHI_B", "ELLIPSOIDFIT_AXISPHI_A", "ELLIPSOIDFIT_AXISTHETA_C", 
> /*  513 */                 "ELLIPSOIDFIT_AXISTHETA_B", "ELLIPSOIDFIT_AXISTHETA_A" };
> /*  514 */             Object[] columHeadersFinalLink = { "IMAGE_TITLE", "LINK_COST", "EDGE_TIME", 
> /*  515 */                 "EDGE_X_LOCATION", "EDGE_Y_LOCATION", "EDGE_Z_LOCATION", "VELOCITY", "DISPLACEMENT" };
> /*  516 */             Object[] columHeadersFinalTrack = { "IMAGE_TITLE", "TRACK_DURATION", "TRACK_START", 
> /*  517 */                 "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", 
> /*  518 */                 "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_INDEX", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", 
> /*  519 */                 "TRACK_Z_LOCATION", "NUMBER_SPOTS", "NUMBER_GAPS", "LONGEST_GAP", "NUMBER_SPLITS", 
> /*  520 */                 "NUMBER_MERGES", "NUMBER_COMPLEX", "TRACK_MEAN_QUALITY", "TRACK_MAX_QUALITY", 
> /*  521 */                 "TRACK_MIN_QUALITY", "TRACK_MEDIAN_QUALITY", "TRACK_STD_QUALITY", "TOTAL_DISTANCE_TRAVELED", 
> /*  522 */                 "MAX_DISTANCE_TRAVELED", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", 
> /*  523 */                 "TOTAL_ABSOLUTE_ANGLE_XY", "TOTAL_ABSOLUTE_ANGLE_YZ", "TOTAL_ABSOLUTE_ANGLE_ZX", 
> /*  524 */                 "CONFINMENT_RATIO" };
> /*  525 */             SPTBatch_.this.rtSpot = new ResultsTable(Integer.valueOf(SPTBatch_.this.imageTitles.length));
> /*  526 */             SPTBatch_.this.rtLink = new ResultsTable(Integer.valueOf(SPTBatch_.this.imageTitles.length));
> /*  527 */             SPTBatch_.this.rtTrack = new ResultsTable(Integer.valueOf(SPTBatch_.this.imageTitles.length));
> /*  528 */             SPTBatch_.this.rtSpots = new ResultsTable[listOfFiles.length];
> /*  529 */             SPTBatch_.this.rtLinks = new ResultsTable[listOfFiles.length];
> /*  530 */             SPTBatch_.this.rtTracks = new ResultsTable[listOfFiles.length]; int y;
> /*  531 */             for (y = 0; y < columHeadersFinalSpot.length; y++)
> /*  532 */               SPTBatch_.this.rtSpot.setHeading(y, (String)columHeadersFinalSpot[y]); 
> /*  533 */             for (y = 0; y < columHeadersFinalLink.length; y++)
> /*  534 */               SPTBatch_.this.rtLink.setHeading(y, (String)columHeadersFinalLink[y]); 
> /*  535 */             for (y = 0; y < columHeadersFinalTrack.length; y++) {
> /*  536 */               SPTBatch_.this.rtTrack.setHeading(y, (String)columHeadersFinalTrack[y]);
> /*      */             }
> /*  538 */             int MAX = listOfFiles.length;
> /*  539 */             JFrame frameAnalyzer = new JFrame("Analyzing...");
> /*  540 */             final JProgressBar pb = new JProgressBar();
> /*  541 */             pb.setMinimum(0);
> /*  542 */             pb.setMaximum(MAX);
> /*  543 */             pb.setStringPainted(true);
> /*  544 */             SPTBatch_.taskOutput = new JTextArea(5, 20);
> /*  545 */             SPTBatch_.taskOutput.setMargin(new Insets(5, 5, 5, 5));
> /*  546 */             SPTBatch_.taskOutput.setEditable(false);
> /*  547 */             DefaultCaret caret = (DefaultCaret)SPTBatch_.taskOutput.getCaret();
> /*  548 */             caret.setUpdatePolicy(2);
> /*  549 */             JPanel panel = new JPanel();
> /*  550 */             panel.setLayout(new BoxLayout(panel, 1));
> /*  551 */             panel.add(pb);
> /*  552 */             panel.add(Box.createVerticalStrut(5));
> /*  553 */             panel.add(new JScrollPane(SPTBatch_.taskOutput), "Center");
> /*  554 */             panel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));
> /*  555 */             frameAnalyzer.getContentPane().add(panel);
> /*  556 */             frameAnalyzer.setDefaultCloseOperation(2);
> /*  557 */             frameAnalyzer.setSize(550, 500);
> /*  558 */             frameAnalyzer.setVisible(true);
> /*  559 */             SPTBatch_.this.selectedItems = new ArrayList<>();
> /*      */             
> /*  561 */             if (SPTBatch_.checkSummary.isSelected()) {
> /*  562 */               if (summaryColsWindow.combo.getSelectedIndex() == 0)
> /*  563 */                 for (int i = 0; i < summaryColsWindow.itemsSpots.length; i++) {
> /*  564 */                   if (summaryColsWindow.itemsSpots[i].isSelected())
> /*  565 */                     SPTBatch_.this.selectedItems.add((summaryColsWindow.itemsSpots[i]).text); 
> /*      */                 }  
> /*  567 */               if (summaryColsWindow.combo.getSelectedIndex() == 1)
> /*  568 */                 for (int i = 0; i < summaryColsWindow.itemsLinks.length; i++) {
> /*  569 */                   if (summaryColsWindow.itemsLinks[i].isSelected())
> /*  570 */                     SPTBatch_.this.selectedItems.add((summaryColsWindow.itemsLinks[i]).text); 
> /*      */                 }  
> /*  572 */               if (summaryColsWindow.combo.getSelectedIndex() == 2)
> /*  573 */                 for (int i = 0; i < summaryColsWindow.itemsTracks.length; i++) {
> /*  574 */                   if (summaryColsWindow.itemsTracks[i].isSelected())
> /*  575 */                     SPTBatch_.this.selectedItems.add((summaryColsWindow.itemsTracks[i]).text); 
> /*      */                 }  
> /*      */             } 
> /*  578 */             for (SPTBatch_.i = 0; SPTBatch_.i < listOfFiles.length; SPTBatch_.i++) {
> /*  579 */               if (SPTBatch_.imps != null) {
> /*  580 */                 SPTBatch_.imps.hide();
> /*      */               }
> /*  582 */               if (listOfFiles[SPTBatch_.i].isFile()) {
> /*  583 */                 SPTBatch_.this.imageTitles[SPTBatch_.i] = listOfFiles[SPTBatch_.i].getName();
> /*  584 */                 SPTBatch_.imgTitle = SPTBatch_.this.imageTitles[SPTBatch_.i];
> /*      */               } 
> /*  586 */               final int currentValue = SPTBatch_.i + 1;
> /*      */               
> /*      */               try {
> /*  589 */                 SwingUtilities.invokeLater(new Runnable() {
> /*      */                       public void run() {
> /*  591 */                         pb.setValue(currentValue);
> /*  592 */                         SPTBatch_.taskOutput.append(String.format("Completed %f%% of task.\n", new Object[] {
> /*  593 */                                 Double.valueOf(this.val$currentValue * 100.0D / this.val$listOfFiles.length) }));
> /*      */                       }
> /*      */                     });
> /*  596 */                 Thread.sleep(100L);
> /*  597 */               } catch (InterruptedException var69) {
> /*  598 */                 JOptionPane.showMessageDialog(frameAnalyzer, var69.getMessage());
> /*      */               } 
> /*  600 */               if (listOfFiles[SPTBatch_.i].getName().contains(".lif")) {
> /*  601 */                 SPTBatch_.this.lifs = SPTBatch_.openBF(String.valueOf(SPTBatch_.this.imagesPath) + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i], false, false, false, false, false, 
> /*  602 */                     true);
> /*  603 */                 for (int x = 0; x < SPTBatch_.this.lifs.length; x++) {
> /*  604 */                   SPTBatch_.imps = new ImagePlus(String.valueOf(SPTBatch_.this.imagesPath) + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]);
> /*      */                 }
> /*      */               } 
> /*  607 */               if (!listOfFiles[SPTBatch_.i].getName().contains(".lif"))
> /*  608 */                 SPTBatch_.imps = new ImagePlus(String.valueOf(SPTBatch_.this.imagesPath) + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]); 
> /*  609 */               IJ.resetMinAndMax(SPTBatch_.imps);
> /*  610 */               SPTBatch_.this.dims = SPTBatch_.imps.getDimensions();
> /*  611 */               SPTBatch_.this.calibration = SPTBatch_.imps.getCalibration();
> /*  612 */               SPTBatch_.fps = (SPTBatch_.imps.getFileInfo()).frameInterval;
> /*  613 */               if (SPTBatch_.this.dims[4] == 1 && SPTBatch_.this.dims[3] > 1) {
> /*      */                 
> /*  615 */                 SPTBatch_.imps.setDimensions(SPTBatch_.this.dims[2], SPTBatch_.this.dims[4], SPTBatch_.this.dims[3]);
> /*  616 */                 SPTBatch_.this.calibration.frameInterval = SPTBatch_.this.calibration.frameInterval;
> /*  617 */                 SPTBatch_.this.loggers = Logger.IJ_LOGGER;
> /*      */               } 
> /*      */               
> /*  620 */               SPTBatch_.impsSubBg = SPTBatch_.imps.duplicate();
> /*  621 */               SPTBatch_.impsSubBg.setCalibration(SPTBatch_.this.calibration);
> /*  622 */               SPTBatch_.directImages = new File(String.valueOf(SPTBatch_.csvPath) + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", ""));
> /*      */               
> /*  624 */               if (!SPTBatch_.directImages.exists()) {
> /*  625 */                 SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directImages.getName());
> /*  626 */                 boolean result = false;
> /*      */                 
> /*      */                 try {
> /*  629 */                   SPTBatch_.directImages.mkdir();
> /*  630 */                   result = true;
> /*  631 */                 } catch (SecurityException securityException) {}
> /*      */ 
> /*      */                 
> /*  634 */                 if (result) {
> /*  635 */                   SPTBatch_.taskOutput.append("DIR created");
> /*      */                 }
> /*      */               } 
> /*      */               
> /*  639 */               SPTBatch_.directSummary = new File(String.valueOf(SPTBatch_.csvPath) + File.separator + "Summary_Analysis");
> /*      */               
> /*  641 */               if (!SPTBatch_.directSummary.exists()) {
> /*  642 */                 boolean result = false;
> /*      */                 
> /*      */                 try {
> /*  645 */                   SPTBatch_.directSummary.mkdir();
> /*  646 */                   result = true;
> /*  647 */                 } catch (SecurityException securityException) {}
> /*      */ 
> /*      */                 
> /*  650 */                 if (result) {
> /*  651 */                   SPTBatch_.taskOutput.append("DIR created-Summary_Analysis");
> /*      */                 }
> /*      */               } 
> /*  654 */               SPTBatch_.directSPT = new File(String.valueOf(SPTBatch_.csvPath) + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", "") + 
> /*  655 */                   File.separator + "SPT_Analysis");
> /*      */               
> /*  657 */               if (!SPTBatch_.directSPT.exists()) {
> /*  658 */                 boolean result = false;
> /*      */                 
> /*      */                 try {
> /*  661 */                   SPTBatch_.directSPT.mkdir();
> /*  662 */                   result = true;
> /*  663 */                 } catch (SecurityException securityException) {}
> /*      */ 
> /*      */                 
> /*  666 */                 if (result) {
> /*  667 */                   SPTBatch_.taskOutput.append("DIR created-SPT_Analysis");
> /*      */                 }
> /*      */               } 
> /*      */               
> /*  671 */               SPTBatch_.directPBS = new File(String.valueOf(SPTBatch_.csvPath) + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", "") + 
> /*  672 */                   File.separator + "Photobleaching_Analysis");
> /*  673 */               if (SPTBatch_.checkPBS.isSelected())
> /*      */               {
> /*  675 */                 if (!SPTBatch_.directPBS.exists()) {
> /*  676 */                   boolean result = false;
> /*      */                   
> /*      */                   try {
> /*  679 */                     SPTBatch_.directPBS.mkdir();
> /*  680 */                     result = true;
> /*  681 */                   } catch (SecurityException securityException) {}
> /*      */ 
> /*      */                   
> /*  684 */                   if (result) {
> /*  685 */                     SPTBatch_.taskOutput.append("DIR created-Photobleching_Analysis");
> /*      */                   }
> /*      */                 } 
> /*      */               }
> /*      */               
> /*  690 */               if (SPTBatch_.checkboxMSD.isSelected() == Boolean.TRUE.booleanValue()) {
> /*  691 */                 SPTBatch_.directMSS = new File(String.valueOf(SPTBatch_.directImages.getAbsolutePath()) + File.separator + "MSS_Analysis");
> /*      */                 
> /*  693 */                 if (!SPTBatch_.directMSS.exists()) {
> /*  694 */                   SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directMSS.getName());
> /*  695 */                   boolean result = false;
> /*      */                   
> /*      */                   try {
> /*  698 */                     SPTBatch_.directMSS.mkdir();
> /*  699 */                     result = true;
> /*  700 */                   } catch (SecurityException securityException) {}
> /*      */ 
> /*      */                   
> /*  703 */                   if (result) {
> /*  704 */                     SPTBatch_.taskOutput.append(String.valueOf(SPTBatch_.directMSS.getName()) + "  DIR created");
> /*      */                   }
> /*      */                 } 
> /*      */               } 
> /*  708 */               if (SPTBatch_.checkCluster.isSelected() == Boolean.TRUE.booleanValue()) {
> /*  709 */                 SPTBatch_.directCluster = new File(
> /*  710 */                     String.valueOf(SPTBatch_.directImages.getAbsolutePath()) + File.separator + "Cluster_Size_Analysis");
> /*      */                 
> /*  712 */                 if (!SPTBatch_.directCluster.exists()) {
> /*  713 */                   SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directCluster.getName());
> /*  714 */                   boolean result = false;
> /*      */                   
> /*      */                   try {
> /*  717 */                     SPTBatch_.directCluster.mkdir();
> /*  718 */                     result = true;
> /*  719 */                   } catch (SecurityException securityException) {}
> /*      */ 
> /*      */                   
> /*  722 */                   if (result) {
> /*  723 */                     SPTBatch_.taskOutput.append(String.valueOf(SPTBatch_.directCluster.getName()) + "  DIR created");
> /*      */                   }
> /*      */                 } 
> /*      */               } 
> /*  727 */               TmXmlReader reader = new TmXmlReader(SPTBatch_.fileXmlInitial);
> /*  728 */               DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
> /*  729 */               DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
> /*  730 */               DocumentBuilder builder = null;
> /*      */               try {
> /*  732 */                 builder = factory.newDocumentBuilder();
> /*  733 */               } catch (ParserConfigurationException e) {
> /*      */                 
> /*  735 */                 e.printStackTrace();
> /*      */               } 
> /*      */               
> /*  738 */               Document doc = null;
> /*      */               
> /*      */               try {
> /*  741 */                 doc = builder.parse(SPTBatch_.fileXmlInitial);
> /*  742 */               } catch (SAXException e) {
> /*      */                 
> /*  744 */                 e.printStackTrace();
> /*  745 */               } catch (IOException e) {
> /*      */                 
> /*  747 */                 e.printStackTrace();
> /*      */               } 
> /*  749 */               XPathFactory xPathfactory = XPathFactory.newInstance();
> /*  750 */               XPath xpath = xPathfactory.newXPath();
> /*      */               
> /*  752 */               XPathExpression exprBasicSettings = null;
> /*  753 */               XPathExpression exprDetectorSettings = null;
> /*  754 */               XPathExpression exprInitialSpotFilter = null;
> /*  755 */               XPathExpression exprFilter = null;
> /*  756 */               XPathExpression exprTrackerSettings = null;
> /*  757 */               XPathExpression exprLinking = null;
> /*  758 */               XPathExpression exprGapClosing = null;
> /*  759 */               XPathExpression exprSplitting = null;
> /*  760 */               XPathExpression exprMerging = null;
> /*  761 */               XPathExpression exprTrackFilter = null;
> /*  762 */               XPathExpression exprLinkingP = null;
> /*      */ 
> /*      */               
> /*      */               try {
> /*  766 */                 exprBasicSettings = xpath.compile("//Settings/BasicSettings[@zstart]");
> /*  767 */               } catch (XPathExpressionException e) {
> /*      */                 
> /*  769 */                 e.printStackTrace();
> /*      */               } 
> /*      */               
> /*      */               try {
> /*  773 */                 exprLinkingP = xpath.compile("//Linking/FeaturePenalties[@MEAN_INTENSITY]");
> /*  774 */               } catch (XPathExpressionException e) {
> /*      */                 
> /*  776 */                 e.printStackTrace();
> /*      */               } 
> /*      */               
> /*      */               try {
> /*  780 */                 exprDetectorSettings = xpath.compile("//Settings/DetectorSettings[@RADIUS]");
> /*  781 */               } catch (XPathExpressionException e) {
> /*      */                 
> /*  783 */                 e.printStackTrace();
> /*      */               } 
> /*      */               
> /*      */               try {
> /*  787 */                 exprInitialSpotFilter = xpath
> /*  788 */                   .compile("//Settings/InitialSpotFilter[@feature]");
> /*  789 */               } catch (XPathExpressionException e) {
> /*      */                 
> /*  791 */                 e.printStackTrace();
> /*      */               } 
> /*      */               
> /*      */               try {
> /*  795 */                 exprFilter = xpath.compile("//SpotFilterCollection/Filter[@feature]");
> /*  796 */               } catch (XPathExpressionException e) {
> /*      */                 
> /*  798 */                 e.printStackTrace();
> /*      */               } 
> /*      */ 
> /*      */               
> /*      */               try {
> /*  803 */                 exprTrackerSettings = xpath
> /*  804 */                   .compile("//Settings/TrackerSettings[@TRACKER_NAME]");
> /*  805 */               } catch (XPathExpressionException e) {
> /*      */                 
> /*  807 */                 e.printStackTrace();
> /*      */               } 
> /*      */               
> /*      */               try {
> /*  811 */                 exprLinking = xpath
> /*  812 */                   .compile("//TrackerSettings/Linking[@LINKING_MAX_DISTANCE]");
> /*  813 */               } catch (XPathExpressionException e) {
> /*      */                 
> /*  815 */                 e.printStackTrace();
> /*      */               } 
> /*      */               
> /*      */               try {
> /*  819 */                 exprGapClosing = xpath
> /*  820 */                   .compile("//TrackerSettings/GapClosing[@MAX_FRAME_GAP]");
> /*  821 */               } catch (XPathExpressionException e) {
> /*      */                 
> /*  823 */                 e.printStackTrace();
> /*      */               } 
> /*      */               
> /*      */               try {
> /*  827 */                 exprSplitting = xpath
> /*  828 */                   .compile("//TrackerSettings/TrackSplitting[@SPLITTING_MAX_DISTANCE]");
> /*  829 */               } catch (XPathExpressionException e) {
> /*      */                 
> /*  831 */                 e.printStackTrace();
> /*      */               } 
> /*      */               
> /*      */               try {
> /*  835 */                 exprMerging = xpath
> /*  836 */                   .compile("//TrackerSettings/TrackMerging[@MERGING_MAX_DISTANCE]");
> /*  837 */               } catch (XPathExpressionException e) {
> /*      */                 
> /*  839 */                 e.printStackTrace();
> /*      */               } 
> /*      */               
> /*      */               try {
> /*  843 */                 exprTrackFilter = xpath.compile("//TrackFilterCollection/Filter[@feature]");
> /*  844 */               } catch (XPathExpressionException e) {
> /*      */                 
> /*  846 */                 e.printStackTrace();
> /*      */               } 
> /*      */               
> /*  849 */               NodeList nlBasicSettings = null;
> /*  850 */               NodeList nlDetectorSettings = null;
> /*  851 */               NodeList nlInitialSpotFilter = null;
> /*  852 */               NodeList nlFilter = null;
> /*  853 */               NodeList nlTrackerSettings = null;
> /*  854 */               NodeList nlLinking = null;
> /*  855 */               NodeList nlGapClosing = null;
> /*  856 */               NodeList nlSplitting = null;
> /*  857 */               NodeList nlMerging = null;
> /*  858 */               NodeList nlTrackFilter = null;
> /*  859 */               NodeList nlLinkingP = null;
> /*      */ 
> /*      */               
> /*      */               try {
> /*  863 */                 nlBasicSettings = (NodeList)exprBasicSettings.evaluate(doc, XPathConstants.NODESET);
> /*  864 */                 nlDetectorSettings = (NodeList)exprDetectorSettings.evaluate(doc, XPathConstants.NODESET);
> /*  865 */                 nlInitialSpotFilter = (NodeList)exprInitialSpotFilter.evaluate(doc, XPathConstants.NODESET);
> /*  866 */                 nlFilter = (NodeList)exprFilter.evaluate(doc, XPathConstants.NODESET);
> /*  867 */                 nlTrackerSettings = (NodeList)exprTrackerSettings.evaluate(doc, XPathConstants.NODESET);
> /*  868 */                 nlLinking = (NodeList)exprLinking.evaluate(doc, XPathConstants.NODESET);
> /*  869 */                 nlGapClosing = (NodeList)exprGapClosing.evaluate(doc, XPathConstants.NODESET);
> /*  870 */                 nlSplitting = (NodeList)exprSplitting.evaluate(doc, XPathConstants.NODESET);
> /*  871 */                 nlMerging = (NodeList)exprMerging.evaluate(doc, XPathConstants.NODESET);
> /*  872 */                 nlTrackFilter = (NodeList)exprTrackFilter.evaluate(doc, XPathConstants.NODESET);
> /*  873 */                 nlLinkingP = (NodeList)exprLinkingP.evaluate(doc, XPathConstants.NODESET);
> /*      */               }
> /*  875 */               catch (XPathExpressionException e) {
> /*      */                 
> /*  877 */                 e.printStackTrace();
> /*      */               } 
> /*      */               int j;
> /*  880 */               for (j = 0; j < nlBasicSettings.getLength(); j++) {
> /*  881 */                 Node currentItem = nlBasicSettings.item(j);
> /*  882 */                 SPTBatch_.this.zstart = currentItem.getAttributes().getNamedItem("zstart").getNodeValue();
> /*  883 */                 SPTBatch_.this.zend = currentItem.getAttributes().getNamedItem("zend").getNodeValue();
> /*  884 */                 SPTBatch_.this.ystart = currentItem.getAttributes().getNamedItem("ystart").getNodeValue();
> /*  885 */                 SPTBatch_.this.yend = currentItem.getAttributes().getNamedItem("yend").getNodeValue();
> /*  886 */                 SPTBatch_.this.xstart = currentItem.getAttributes().getNamedItem("xstart").getNodeValue();
> /*  887 */                 SPTBatch_.this.xend = currentItem.getAttributes().getNamedItem("xend").getNodeValue();
> /*  888 */                 SPTBatch_.this.tstart = currentItem.getAttributes().getNamedItem("tstart").getNodeValue();
> /*  889 */                 SPTBatch_.this.tend = currentItem.getAttributes().getNamedItem("tend").getNodeValue();
> /*      */               } 
> /*  891 */               for (j = 0; j < nlDetectorSettings.getLength(); j++) {
> /*  892 */                 Node currentItem = nlDetectorSettings.item(j);
> /*  893 */                 SPTBatch_.RADIUS = currentItem.getAttributes().getNamedItem("RADIUS").getNodeValue();
> /*  894 */                 SPTBatch_.this.THRESHOLD = currentItem.getAttributes().getNamedItem("THRESHOLD").getNodeValue();
> /*  895 */                 SPTBatch_.this.TARGET_CHANNEL = currentItem.getAttributes().getNamedItem("TARGET_CHANNEL").getNodeValue();
> /*  896 */                 SPTBatch_.this.DO_SUBPIXEL_LOCALIZATION = currentItem.getAttributes().getNamedItem("DO_SUBPIXEL_LOCALIZATION")
> /*  897 */                   .getNodeValue();
> /*  898 */                 SPTBatch_.this.DO_MEDIAN_FILTERING = currentItem.getAttributes().getNamedItem("DO_MEDIAN_FILTERING")
> /*  899 */                   .getNodeValue();
> /*  900 */                 SPTBatch_.this.DETECTOR_NAME = currentItem.getAttributes().getNamedItem("DETECTOR_NAME").getNodeValue();
> /*  901 */                 if (SPTBatch_.this.DETECTOR_NAME.equals("BLOCK_LOG_DETECTOR"))
> /*  902 */                   SPTBatch_.this.NSPLIT = currentItem.getAttributes().getNamedItem("NSPLIT").getNodeValue(); 
> /*  903 */                 if (SPTBatch_.this.DETECTOR_NAME.equals("DOWNSAMLE_LOG_DETECTOR")) {
> /*  904 */                   SPTBatch_.this.DOWNSAMPLE_FACTOR = currentItem.getAttributes().getNamedItem("DOWNSAMPLE_FACTOR")
> /*  905 */                     .getNodeValue();
> /*      */                 }
> /*      */               } 
> /*      */               
> /*  909 */               for (j = 0; j < nlLinkingP.getLength(); j++) {
> /*  910 */                 SPTBatch_.this.linkingNames = nlLinkingP.item(j).getAttributes().item(j).getNodeName();
> /*  911 */                 SPTBatch_.this.linkingValues = nlLinkingP.item(j).getAttributes().item(j).getNodeValue();
> /*      */               } 
> /*  913 */               for (j = 0; j < nlInitialSpotFilter.getLength(); j++) {
> /*  914 */                 Node currentItem = nlInitialSpotFilter.item(j);
> /*  915 */                 SPTBatch_.this.initialSpotFilter = currentItem.getAttributes().getNamedItem("value").getNodeValue();
> /*      */               } 
> /*      */               
> /*  918 */               List<String> spotFilterFeature = new ArrayList<>();
> /*  919 */               List<String> spotFilterValue = new ArrayList<>();
> /*  920 */               List<String> spotFilterAbove = new ArrayList<>();
> /*  921 */               for (int i = 0; i < nlFilter.getLength(); i++) {
> /*  922 */                 Node currentItem = nlFilter.item(i);
> /*  923 */                 spotFilterFeature.add(currentItem.getAttributes().getNamedItem("feature").getNodeValue());
> /*  924 */                 spotFilterValue.add(currentItem.getAttributes().getNamedItem("value").getNodeValue());
> /*  925 */                 spotFilterAbove.add(currentItem.getAttributes().getNamedItem("isabove").getNodeValue());
> /*      */               } 
> /*      */ 
> /*      */               
> /*  929 */               List<String> trackFilterFeature = new ArrayList<>();
> /*  930 */               List<String> trackFilterValue = new ArrayList<>();
> /*  931 */               List<String> trackFilterAbove = new ArrayList<>(); int k;
> /*  932 */               for (k = 0; k < nlTrackFilter.getLength(); k++) {
> /*  933 */                 Node currentItem = nlTrackFilter.item(k);
> /*  934 */                 trackFilterFeature.add(currentItem.getAttributes().getNamedItem("feature").getNodeValue());
> /*  935 */                 trackFilterValue.add(currentItem.getAttributes().getNamedItem("value").getNodeValue());
> /*  936 */                 trackFilterAbove.add(currentItem.getAttributes().getNamedItem("isabove").getNodeValue());
> /*      */               } 
> /*  938 */               for (k = 0; k < nlTrackerSettings.getLength(); k++) {
> /*  939 */                 Node currentItem = nlTrackerSettings.item(k);
> /*  940 */                 SPTBatch_.this.TRACKER_NAME = currentItem.getAttributes().getNamedItem("TRACKER_NAME").getNodeValue();
> /*  941 */                 SPTBatch_.this.CUTOFF_PERCENTILE = currentItem.getAttributes().getNamedItem("CUTOFF_PERCENTILE")
> /*  942 */                   .getNodeValue();
> /*  943 */                 SPTBatch_.this.BLOCKING_VALUE = currentItem.getAttributes().getNamedItem("BLOCKING_VALUE").getNodeValue();
> /*  944 */                 SPTBatch_.this.ALTERNATIVE_LINKING_COST_FACTOR = currentItem.getAttributes()
> /*  945 */                   .getNamedItem("ALTERNATIVE_LINKING_COST_FACTOR").getNodeValue();
> /*      */               } 
> /*  947 */               for (k = 0; k < nlLinking.getLength(); k++) {
> /*  948 */                 Node currentItem = nlLinking.item(k);
> /*  949 */                 SPTBatch_.this.LINKING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("LINKING_MAX_DISTANCE")
> /*  950 */                   .getNodeValue();
> /*      */               } 
> /*  952 */               for (k = 0; k < nlGapClosing.getLength(); k++) {
> /*  953 */                 Node currentItem = nlGapClosing.item(k);
> /*  954 */                 SPTBatch_.this.MAX_FRAME_GAP = currentItem.getAttributes().getNamedItem("MAX_FRAME_GAP").getNodeValue();
> /*  955 */                 SPTBatch_.this.MAX_DISTANCE = currentItem.getAttributes().getNamedItem("GAP_CLOSING_MAX_DISTANCE")
> /*  956 */                   .getNodeValue();
> /*  957 */                 SPTBatch_.this.ALLOW_GAP_CLOSING = currentItem.getAttributes().getNamedItem("ALLOW_GAP_CLOSING")
> /*  958 */                   .getNodeValue();
> /*      */               } 
> /*      */               
> /*  961 */               for (k = 0; k < nlSplitting.getLength(); k++) {
> /*  962 */                 Node currentItem = nlSplitting.item(k);
> /*  963 */                 SPTBatch_.this.SPLITTING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("SPLITTING_MAX_DISTANCE")
> /*  964 */                   .getNodeValue();
> /*  965 */                 SPTBatch_.this.ALLOW_TRACK_SPLITTING = currentItem.getAttributes().getNamedItem("ALLOW_TRACK_SPLITTING")
> /*  966 */                   .getNodeValue();
> /*      */               } 
> /*  968 */               for (k = 0; k < nlMerging.getLength(); k++) {
> /*  969 */                 Node currentItem = nlMerging.item(k);
> /*  970 */                 SPTBatch_.this.MERGING_MAX_DISTANCE = currentItem.getAttributes().getNamedItem("MERGING_MAX_DISTANCE")
> /*  971 */                   .getNodeValue();
> /*  972 */                 SPTBatch_.this.ALLOW_TRACK_MERGING = currentItem.getAttributes().getNamedItem("ALLOW_TRACK_MERGING")
> /*  973 */                   .getNodeValue();
> /*      */               } 
> /*      */               
> /*  976 */               SPTBatch_.this.settings = new Settings(SPTBatch_.imps);
> /*  977 */               SPTBatch_.taskOutput.append(SPTBatch_.this.settings.toStringImageInfo());
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */               
> /*  995 */               if (SPTBatch_.this.DETECTOR_NAME.equals("LOG_DETECTOR")) {
> /*  996 */                 SPTBatch_.this.settings.detectorFactory = (SpotDetectorFactoryBase)new LogDetectorFactory();
> /*  997 */                 SPTBatch_.this.settings.detectorSettings = SPTBatch_.this.settings.detectorFactory.getDefaultSettings();
> /*  998 */                 SPTBatch_.this.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", 
> /*  999 */                     Boolean.valueOf(Boolean.parseBoolean(SPTBatch_.this.DO_SUBPIXEL_LOCALIZATION)));
> /* 1000 */                 SPTBatch_.this.settings.detectorSettings.put("RADIUS", Double.valueOf(Double.parseDouble(SPTBatch_.RADIUS)));
> /* 1001 */                 SPTBatch_.this.settings.detectorSettings.put("TARGET_CHANNEL", 
> /* 1002 */                     Integer.valueOf(Integer.parseInt(SPTBatch_.this.TARGET_CHANNEL)));
> /* 1003 */                 SPTBatch_.this.settings.detectorSettings.put("THRESHOLD", Double.valueOf(Double.parseDouble(SPTBatch_.this.THRESHOLD)));
> /* 1004 */                 SPTBatch_.this.settings.detectorSettings.put("DO_MEDIAN_FILTERING", 
> /* 1005 */                     Boolean.valueOf(Boolean.parseBoolean(SPTBatch_.this.DO_MEDIAN_FILTERING)));
> /* 1006 */                 if (SPTBatch_.this.initialSpotFilter != null) {
> /* 1007 */                   SPTBatch_.this.settings.initialSpotFilterValue = Double.valueOf(Double.parseDouble(SPTBatch_.this.initialSpotFilter));
> /*      */                 }
> /*      */               } 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */               
> /* 1032 */               if (SPTBatch_.this.DETECTOR_NAME.equals("DOG_DETECTOR")) {
> /*      */                 
> /* 1034 */                 SPTBatch_.this.settings.detectorFactory = (SpotDetectorFactoryBase)new DogDetectorFactory();
> /* 1035 */                 SPTBatch_.this.settings.detectorSettings.put("DO_SUBPIXEL_LOCALIZATION", 
> /* 1036 */                     Boolean.valueOf(Boolean.parseBoolean(SPTBatch_.this.DO_SUBPIXEL_LOCALIZATION)));
> /* 1037 */                 SPTBatch_.this.settings.detectorSettings.put("RADIUS", Double.valueOf(Double.parseDouble(SPTBatch_.RADIUS)));
> /* 1038 */                 SPTBatch_.this.settings.detectorSettings.put("TARGET_CHANNEL", 
> /* 1039 */                     Integer.valueOf(Integer.parseInt(SPTBatch_.this.TARGET_CHANNEL)));
> /* 1040 */                 SPTBatch_.this.settings.detectorSettings.put("THRESHOLD", Double.valueOf(Double.parseDouble(SPTBatch_.this.THRESHOLD)));
> /* 1041 */                 SPTBatch_.this.settings.detectorSettings.put("DO_MEDIAN_FILTERING", 
> /* 1042 */                     Double.valueOf(Double.parseDouble(SPTBatch_.this.DO_MEDIAN_FILTERING)));
> /* 1043 */                 if (SPTBatch_.this.initialSpotFilter != null) {
> /* 1044 */                   SPTBatch_.this.settings.initialSpotFilterValue = Double.valueOf(Double.parseDouble(SPTBatch_.this.initialSpotFilter));
> /*      */                 }
> /*      */               } 
> /* 1047 */               List<FeatureFilter> spotFilters = new ArrayList<>(); int m;
> /* 1048 */               for (m = 0; m < spotFilterFeature.size(); m++)
> /* 1049 */                 spotFilters.add(new FeatureFilter(spotFilterFeature.get(m), 
> /* 1050 */                       Double.valueOf(spotFilterValue.get(m)).doubleValue(), 
> /* 1051 */                       Boolean.valueOf(spotFilterAbove.get(m)).booleanValue())); 
> /* 1052 */               for (m = 0; m < spotFilters.size(); m++) {
> /* 1053 */                 SPTBatch_.this.settings.addSpotFilter(spotFilters.get(m));
> /*      */               }
> /* 1055 */               if (SPTBatch_.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
> /*      */                 
> /* 1057 */                 SPTBatch_.this.settings.trackerFactory = (SpotTrackerFactory)new ManualTrackerFactory();
> /* 1058 */                 SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
> /*      */               } 
> /*      */               
> /* 1061 */               if (SPTBatch_.this.TRACKER_NAME.equals("MANUAL_TRACKER")) {
> /*      */                 
> /* 1063 */                 SPTBatch_.this.settings.trackerFactory = (SpotTrackerFactory)new ManualTrackerFactory();
> /* 1064 */                 SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
> /*      */               } 
> /*      */ 
> /*      */               
> /* 1068 */               if (SPTBatch_.this.TRACKER_NAME.equals("KALMAN_TRACKER")) {
> /*      */                 
> /* 1070 */                 SPTBatch_.this.settings.trackerFactory = (SpotTrackerFactory)new KalmanTrackerFactory();
> /* 1071 */                 SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
> /* 1072 */                 SPTBatch_.this.settings.trackerSettings.put("KALMAN_SEARCH_RADIUS", 
> /* 1073 */                     Double.valueOf(Double.parseDouble(SPTBatch_.RADIUS)));
> /*      */               } 
> /*      */ 
> /*      */               
> /* 1077 */               if (SPTBatch_.this.TRACKER_NAME.equals("SIMPLE_SPARSE_LAP_TRACKER")) {
> /*      */                 
> /* 1079 */                 SPTBatch_.this.settings.trackerFactory = (SpotTrackerFactory)new SimpleSparseLAPTrackerFactory();
> /* 1080 */                 SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
> /* 1081 */                 SPTBatch_.this.settings.trackerSettings.put("LINKING_MAX_DISTANCE", 
> /* 1082 */                     Double.valueOf(Double.parseDouble(SPTBatch_.this.LINKING_MAX_DISTANCE)));
> /* 1083 */                 SPTBatch_.this.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", 
> /* 1084 */                     Double.valueOf(Double.parseDouble(SPTBatch_.this.MAX_DISTANCE)));
> /* 1085 */                 SPTBatch_.this.settings.trackerSettings.put("MAX_FRAME_GAP", 
> /* 1086 */                     Double.valueOf(Double.parseDouble(SPTBatch_.this.MAX_FRAME_GAP)));
> /*      */               } 
> /*      */ 
> /*      */               
> /* 1090 */               if (SPTBatch_.this.TRACKER_NAME.equals("SPARSE_LAP_TRACKER")) {
> /* 1091 */                 SPTBatch_.this.settings.trackerFactory = (SpotTrackerFactory)new SparseLAPTrackerFactory();
> /* 1092 */                 SPTBatch_.this.settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();
> /* 1093 */                 SPTBatch_.this.settings.trackerSettings.put("LINKING_MAX_DISTANCE", 
> /* 1094 */                     Double.valueOf(Double.parseDouble(SPTBatch_.this.LINKING_MAX_DISTANCE)));
> /* 1095 */                 Map<String, Double> linkingPenalty = 
> /* 1096 */                   (Map<String, Double>)Stream.<Object[]>of(new Object[][] { { "MEAN_INTENSITY", Double.valueOf(1.0D) }, { "QUALITY", Double.valueOf(1.0D)
> /*      */                       }
> /* 1098 */                     }).collect(Collectors.toMap(data -> (String)data[0], data -> (Double)data[1]));
> /* 1099 */                 SPTBatch_.this.settings.trackerSettings.put("ALLOW_GAP_CLOSING", 
> /* 1100 */                     Boolean.valueOf(Boolean.parseBoolean(SPTBatch_.this.ALLOW_GAP_CLOSING)));
> /* 1101 */                 if (Boolean.parseBoolean(SPTBatch_.this.ALLOW_GAP_CLOSING)) {
> /* 1102 */                   SPTBatch_.this.settings.trackerSettings.put("MAX_FRAME_GAP", 
> /* 1103 */                       Integer.valueOf(Integer.parseInt(SPTBatch_.this.MAX_FRAME_GAP)));
> /* 1104 */                   SPTBatch_.this.settings.trackerSettings.put("GAP_CLOSING_MAX_DISTANCE", 
> /* 1105 */                       Double.valueOf(Double.parseDouble(SPTBatch_.this.MAX_DISTANCE)));
> /*      */                   
> /* 1107 */                   Map map = 
> /* 1108 */                     (Map)Stream.<Object[]>of(new Object[][] { { "MEAN_INTENSITY", Double.valueOf(1.0D) }, { "QUALITY", Double.valueOf(1.0D)
> /* 1109 */                         } }).collect(Collectors.toMap(data -> (String)data[0], data -> (Double)data[1]));
> /*      */                 } 
> /*      */ 
> /*      */                 
> /* 1113 */                 SPTBatch_.this.settings.trackerSettings.put("ALLOW_TRACK_SPLITTING", 
> /* 1114 */                     Boolean.valueOf(Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_SPLITTING)));
> /* 1115 */                 if (Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_SPLITTING)) {
> /* 1116 */                   SPTBatch_.this.settings.trackerSettings.put("SPLITTING_MAX_DISTANCE", 
> /* 1117 */                       Double.valueOf(Double.parseDouble(SPTBatch_.this.SPLITTING_MAX_DISTANCE)));
> /* 1118 */                   Map map = 
> /* 1119 */                     (Map)Stream.<Object[]>of(new Object[][] { { "MEAN_INTENSITY", Double.valueOf(1.0D) }, { "QUALITY", Double.valueOf(1.0D)
> /* 1120 */                         } }).collect(Collectors.toMap(data -> (String)data[0], data -> (Double)data[1]));
> /*      */                 } 
> /*      */ 
> /*      */                 
> /* 1124 */                 SPTBatch_.this.settings.trackerSettings.put("ALLOW_TRACK_MERGING", 
> /* 1125 */                     Boolean.valueOf(Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_MERGING)));
> /* 1126 */                 if (Boolean.parseBoolean(SPTBatch_.this.ALLOW_TRACK_MERGING)) {
> /* 1127 */                   SPTBatch_.this.settings.trackerSettings.put("MERGING_MAX_DISTANCE", 
> /* 1128 */                       Double.valueOf(Double.parseDouble(SPTBatch_.this.MERGING_MAX_DISTANCE)));
> /* 1129 */                   Map map = 
> /* 1130 */                     (Map)Stream.<Object[]>of(new Object[][] { { "MEAN_INTENSITY", Double.valueOf(1.0D) }, { "QUALITY", Double.valueOf(1.0D)
> /* 1131 */                         } }).collect(Collectors.toMap(data -> (String)data[0], data -> (Double)data[1]));
> /*      */                 } 
> /*      */               } 
> /*      */ 
> /*      */               
> /* 1136 */               List<FeatureFilter> trackFilters = new ArrayList<>(); int n;
> /* 1137 */               for (n = 0; n < trackFilterFeature.size(); n++)
> /* 1138 */                 trackFilters.add(new FeatureFilter(trackFilterFeature.get(n), 
> /* 1139 */                       Double.valueOf(trackFilterValue.get(n)).doubleValue(), 
> /* 1140 */                       Boolean.valueOf(trackFilterAbove.get(n)).booleanValue())); 
> /* 1141 */               for (n = 0; n < trackFilters.size(); n++) {
> /* 1142 */                 SPTBatch_.this.settings.addTrackFilter(trackFilters.get(n));
> /*      */               }
> /* 1144 */               if (SPTBatch_.checkboxSubBg.isSelected()) {
> /* 1145 */                 SPTBatch_.slices = SPTBatch_.stack2images(SPTBatch_.impsSubBg);
> /* 1146 */                 SPTBatch_.slicesIntensityBg = new double[SPTBatch_.slices.length];
> /* 1147 */                 SPTBatch_.slicesIntensitySpot = new double[SPTBatch_.slices.length];
> /* 1148 */                 if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 0) {
> /* 1149 */                   SPTBatch_.impMaxProject = ZProjector.run(SPTBatch_.impsSubBg.duplicate(), "max");
> /* 1150 */                   SPTBatch_.impMaxProject.show();
> /* 1151 */                   SPTBatch_.roiManager = RoiManager.getInstance();
> /* 1152 */                   if (SPTBatch_.roiManager == null) {
> /* 1153 */                     SPTBatch_.roiManager = new RoiManager();
> /*      */                   }
> /* 1155 */                   SPTBatch_.roiManager.reset();
> /* 1156 */                   SPTBatch_.impMaxProject.getCanvas().addMouseListener(new MouseAdapter() {
> /*      */                         public void mouseClicked(MouseEvent e) {
> /* 1158 */                           if (e.getClickCount() == 2) {
> /*      */                             
> /* 1160 */                             Roi roi = new Roi(SPTBatch_.impMaxProject.getCanvas().offScreenX(e.getX()), 
> /* 1161 */                                 SPTBatch_.impMaxProject.getCanvas().offScreenY(e.getY()), 5, 5);
> /* 1162 */                             SPTBatch_.impMaxProject.setRoi(roi);
> /* 1163 */                             SPTBatch_.roiManager.runCommand(SPTBatch_.impMaxProject, "Show All with labels");
> /* 1164 */                             SPTBatch_.roiManager.addRoi(roi);
> /*      */                           } 
> /*      */                         }
> /*      */                       });
> /*      */ 
> /*      */                   
> /* 1170 */                   Dialog4BgSub0 userDialog = new Dialog4BgSub0("Action Required", 
> /* 1171 */                       "Please select manually areas to measure background.");
> /* 1172 */                   userDialog.show();
> /*      */                 } 
> /*      */                 
> /* 1175 */                 if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 2)
> /*      */                 {
> /*      */                   
> /* 1178 */                   for (n = 0; n < SPTBatch_.slices.length; n++) {
> /* 1179 */                     ImagePlus slicesDup = SPTBatch_.slices[n].duplicate();
> /* 1180 */                     IJ.run(slicesDup, "Auto Threshold", "method=Otsu ignore_black white");
> /* 1181 */                     slicesDup = new ImagePlus(slicesDup.getTitle(), 
> /* 1182 */                         Morphology.dilation(slicesDup.getProcessor(), Strel.Shape.DISK.fromRadius(2)));
> /* 1183 */                     IJ.run(slicesDup, "Invert LUT", "");
> /* 1184 */                     IJ.run(slicesDup, "Fill Holes", "");
> /* 1185 */                     IJ.run(slicesDup, "Invert LUT", "");
> /* 1186 */                     IJ.run(slicesDup, "Create Selection", "");
> /* 1187 */                     Roi roiToMeasure = slicesDup.getRoi();
> /* 1188 */                     IJ.run(slicesDup, "Make Inverse", "");
> /* 1189 */                     Roi roiToMeasureInv = slicesDup.getRoi();
> /* 1190 */                     SPTBatch_.slices[n].setRoi(roiToMeasure);
> /* 1191 */                     double meanDirect = (SPTBatch_.slices[n].getStatistics()).mean;
> /* 1192 */                     SPTBatch_.slices[n].setRoi(roiToMeasureInv);
> /* 1193 */                     double meanInv = (SPTBatch_.slices[n].getStatistics()).mean;
> /* 1194 */                     if (meanDirect > meanInv) {
> /* 1195 */                       SPTBatch_.slicesIntensitySpot[n] = meanDirect;
> /*      */                     } else {
> /* 1197 */                       SPTBatch_.slicesIntensitySpot[n] = meanInv;
> /*      */                     } 
> /*      */                   } 
> /*      */                 }
> /*      */                 
> /* 1202 */                 if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 3) {
> /* 1203 */                   for (n = 0; n < SPTBatch_.slices.length; n++) {
> /* 1204 */                     ImagePlus slicesCell = SPTBatch_.slices[n].duplicate();
> /* 1205 */                     IJ.run(slicesCell, "Auto Threshold", "method=Otsu ignore_black white");
> /* 1206 */                     slicesCell = new ImagePlus(slicesCell.getTitle(), 
> /* 1207 */                         Morphology.dilation(slicesCell.getProcessor(), Strel.Shape.DISK.fromRadius(2)));
> /* 1208 */                     IJ.run(slicesCell, "Invert LUT", "");
> /* 1209 */                     IJ.run(slicesCell, "Fill Holes", "");
> /* 1210 */                     IJ.run(slicesCell, "Invert LUT", "");
> /* 1211 */                     IJ.run(slicesCell, "Create Selection", "");
> /* 1212 */                     Roi roiCell = slicesCell.getRoi();
> /* 1213 */                     SPTBatch_.slices[n].setRoi(roiCell);
> /* 1214 */                     double meanDirect = (SPTBatch_.slices[n].getStatistics()).mean;
> /* 1215 */                     IJ.run(slicesCell, "Make Inverse", "");
> /* 1216 */                     Roi roiCellInv = slicesCell.getRoi();
> /* 1217 */                     SPTBatch_.slices[n].setRoi(roiCellInv);
> /* 1218 */                     double meanInv = (SPTBatch_.slices[n].getStatistics()).mean;
> /* 1219 */                     if (meanDirect > meanInv) {
> /* 1220 */                       roiCell = roiCell;
> /*      */                     } else {
> /* 1222 */                       roiCell = roiCellInv;
> /*      */                     } 
> /*      */                     
> /* 1225 */                     ImagePlus slicesSpot = SPTBatch_.slices[n].duplicate();
> /* 1226 */                     String value = String.valueOf(Double.valueOf(SPTBatch_.RADIUS).doubleValue() / 
> /* 1227 */                         (SPTBatch_.imps.getCalibration()).pixelWidth);
> /* 1228 */                     if (value.contains(","))
> /* 1229 */                       value = value.replaceAll(",", "."); 
> /* 1230 */                     IJ.run(slicesSpot, "Subtract Background...", String.format("rolling=%s", new Object[] { value }));
> /* 1231 */                     IJ.run(slicesSpot, "Auto Threshold", "method=Otsu ignore_black white");
> /* 1232 */                     IJ.run(slicesSpot, "Create Selection", "");
> /* 1233 */                     Roi roiSpots = slicesSpot.getRoi();
> /*      */                     
> /* 1235 */                     SPTBatch_.slices[n].setRoi(roiSpots);
> /* 1236 */                     double meanDirectSpots = (SPTBatch_.slices[n].getStatistics()).mean;
> /* 1237 */                     IJ.run(slicesSpot, "Make Inverse", "");
> /* 1238 */                     Roi roiSpotInv = slicesCell.getRoi();
> /* 1239 */                     SPTBatch_.slices[n].setRoi(roiCellInv);
> /* 1240 */                     double meanInvSpots = (SPTBatch_.slices[n].getStatistics()).mean;
> /* 1241 */                     if (meanDirect > meanInv) {
> /* 1242 */                       roiSpots = roiSpots;
> /*      */                     } else {
> /* 1244 */                       roiSpots = roiSpotInv;
> /*      */                     } 
> /*      */                     
> /* 1247 */                     ShapeRoi shapeRoi = (new ShapeRoi(roiCell)).xor(new ShapeRoi(roiSpots));
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                     
> /* 1258 */                     SPTBatch_.slices[n].setRoi((Roi)shapeRoi);
> /* 1259 */                     SPTBatch_.slicesIntensitySpot[n] = (SPTBatch_.slices[n].getStatistics()).mean - 
> /* 1260 */                       (SPTBatch_.slices[n].getStatistics()).stdDev;
> /*      */                   } 
> /*      */                 }
> /* 1263 */                 if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 4)
> /*      */                 {
> /*      */                   
> /* 1266 */                   for (n = 0; n < SPTBatch_.slices.length; n++) {
> /* 1267 */                     ImagePlus slicesDup = SPTBatch_.slices[n].duplicate();
> /* 1268 */                     IJ.run(slicesDup, "Auto Threshold", "method=Otsu ignore_black white");
> /* 1269 */                     slicesDup = new ImagePlus(slicesDup.getTitle(), 
> /* 1270 */                         Morphology.dilation(slicesDup.getProcessor(), Strel.Shape.DISK.fromRadius(2)));
> /* 1271 */                     IJ.run(slicesDup, "Invert LUT", "");
> /* 1272 */                     IJ.run(slicesDup, "Fill Holes", "");
> /* 1273 */                     IJ.run(slicesDup, "Invert LUT", "");
> /* 1274 */                     IJ.run(slicesDup, "Create Selection", "");
> /*      */                     
> /* 1276 */                     Roi roiToMeasure = slicesDup.getRoi();
> /* 1277 */                     ImagePlus sliceDup2 = SPTBatch_.slices[n].duplicate();
> /* 1278 */                     sliceDup2.setRoi(roiToMeasure);
> /* 1279 */                     IJ.run(sliceDup2, "Clear Outside", "");
> /* 1280 */                     BackgroundSubtracter bgSubt = new BackgroundSubtracter();
> /* 1281 */                     ImageProcessor ip = sliceDup2.getProcessor();
> /* 1282 */                     sliceDup2.getProcessor().resetMinAndMax();
> /* 1283 */                     boolean isRGB = sliceDup2.getProcessor() instanceof ColorProcessor;
> /* 1284 */                     boolean calledAsPlugin = true;
> /* 1285 */                     double radius = Double.valueOf(SPTBatch_.RADIUS).doubleValue() / 
> /* 1286 */                       (SPTBatch_.imps.getCalibration()).pixelWidth;
> /* 1287 */                     boolean lightBackground = false;
> /* 1288 */                     boolean separateColors = false;
> /* 1289 */                     boolean createBackground = false;
> /* 1290 */                     boolean useParaboloid = false;
> /* 1291 */                     boolean doPresmooth = false;
> /* 1292 */                     boolean previewing = false;
> /* 1293 */                     boolean correctCorners = true;
> /* 1294 */                     SPTBatch_.slicesIntensitySpot[n] = bgSubt.rollingBallBackground(ip, radius, createBackground, 
> /* 1295 */                         lightBackground, useParaboloid, doPresmooth, correctCorners);
> /*      */                   } 
> /*      */                 }
> /*      */               } 
> /*      */ 
> /*      */ 
> /*      */               
> /* 1302 */               SPTBatch_.this.settings.addAllAnalyzers();
> /* 1303 */               SPTBatch_.model = new Model();
> /* 1304 */               SPTBatch_.this.trackmate = new TrackMate(SPTBatch_.model, SPTBatch_.this.settings);
> /* 1305 */               Boolean ok = Boolean.valueOf(SPTBatch_.this.trackmate.checkInput());
> /* 1306 */               if (ok != Boolean.TRUE) {
> /* 1307 */                 SPTBatch_.taskOutput.append(SPTBatch_.this.trackmate.getErrorMessage());
> /*      */               }
> /* 1309 */               ok = Boolean.valueOf(SPTBatch_.this.trackmate.process());
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */               
> /* 1328 */               SPTBatch_.selectionModel = new SelectionModel(SPTBatch_.model);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */               
> /* 1351 */               SPTBatch_.model.setLogger(Logger.IJ_LOGGER);
> /* 1352 */               SpotCollection spots = SPTBatch_.model.getSpots();
> /* 1353 */               SPTBatch_.taskOutput.append(spots.toString());
> /* 1354 */               FeatureModel fm = SPTBatch_.model.getFeatureModel();
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */               
> /* 1359 */               SPTBatch_.this.tcg = new PerTrackFeatureColorGenerator(SPTBatch_.model, "TRACK_INDEX", null, null, 
> /* 1360 */                   Colormap.Turbo, 0.0D, 1.0D);
> /* 1361 */               SPTBatch_.taskOutput.append("\n\nSETTINGS:");
> /* 1362 */               SPTBatch_.taskOutput.append(SPTBatch_.this.settings.toString());
> /*      */               
> /* 1364 */               SPTBatch_.taskOutput.append(SPTBatch_.model.toString());
> /* 1365 */               SPTBatch_.taskOutput.append("Found" + SPTBatch_.model.getTrackModel().nTracks(true) + " tracks.");
> /* 1366 */               SPTBatch_.taskOutput.append(SPTBatch_.this.settings.toStringFeatureAnalyzersInfo());
> /*      */               
> /* 1368 */               Integer firstFrame = null;
> /* 1369 */               Integer lastFrame = null;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */               
> /* 1380 */               SPTBatch_.this.ds = DisplaySettingsIO.readUserDefault();
> /* 1381 */               SPTBatch_.this.ds.setSpotShowName(SPTBatch_.checkDispSpotName.isSelected());
> /* 1382 */               SPTBatch_.this.ds.setSpotVisible(SPTBatch_.checkDispSpots.isSelected());
> /* 1383 */               SPTBatch_.this.ds.setSpotColorBy(DisplaySettings.TrackMateObject.TRACKS, "TRACK_INDEX");
> /* 1384 */               SPTBatch_.this.ds.setTrackVisible(SPTBatch_.checkDispTracks.isSelected());
> /* 1385 */               SPTBatch_.this.ds.setTrackColorBy(DisplaySettings.TrackMateObject.TRACKS, "TRACK_INDEX");
> /* 1386 */               if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 0)
> /* 1387 */                 SPTBatch_.this.ds.setTrackDisplayMode(DisplaySettings.TrackDisplayMode.FULL); 
> /* 1388 */               if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 1)
> /* 1389 */                 SPTBatch_.this.ds.setTrackDisplayMode(DisplaySettings.TrackDisplayMode.LOCAL); 
> /* 1390 */               if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 2)
> /* 1391 */                 SPTBatch_.this.ds.setTrackDisplayMode(DisplaySettings.TrackDisplayMode.LOCAL_BACKWARD); 
> /* 1392 */               if (SPTBatch_.this.comboDispTracks.getSelectedIndex() == 3)
> /* 1393 */                 SPTBatch_.this.ds.setTrackDisplayMode(DisplaySettings.TrackDisplayMode.LOCAL_FORWARD); 
> /* 1394 */               SPTBatch_.this.displayer = new HyperStackDisplayer(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.imps, SPTBatch_.this.ds);
> /* 1395 */               SPTBatch_.this.displayer.render();
> /* 1396 */               SPTBatch_.this.displayer.refresh();
> /*      */               
> /* 1398 */               if (SPTBatch_.imps.getNFrames() > 1) {
> /* 1399 */                 firstFrame = Integer.valueOf(Math.max(1, Math.min(SPTBatch_.imps.getNFrames(), 1)));
> /* 1400 */                 lastFrame = Integer.valueOf(Math.min(SPTBatch_.imps.getNFrames(), Math.max(SPTBatch_.imps.getNFrames(), 1)));
> /*      */               } 
> /* 1402 */               if (SPTBatch_.imps.getNSlices() > 1) {
> /* 1403 */                 firstFrame = Integer.valueOf(Math.max(1, Math.min(SPTBatch_.imps.getNSlices(), 1)));
> /* 1404 */                 lastFrame = Integer.valueOf(Math.min(SPTBatch_.imps.getNSlices(), Math.max(SPTBatch_.imps.getNSlices(), 1)));
> /*      */               } 
> /*      */               
> /* 1407 */               SPTBatch_.taskOutput.append(
> /* 1408 */                   "Capturing TrackMate overlay from frame " + firstFrame + " to " + lastFrame + ".\n");
> /* 1409 */               Rectangle bounds = SPTBatch_.this.displayer.getImp().getCanvas().getBounds();
> /* 1410 */               Integer width = Integer.valueOf(bounds.width);
> /* 1411 */               Integer height = Integer.valueOf(bounds.height);
> /* 1412 */               Integer nCaptures = Integer.valueOf(lastFrame.intValue() - firstFrame.intValue() + 1);
> /* 1413 */               ImageStack stack = new ImageStack(width.intValue(), height.intValue());
> /* 1414 */               Integer channel = Integer.valueOf(SPTBatch_.this.displayer.getImp().getChannel());
> /* 1415 */               Integer slice = Integer.valueOf(SPTBatch_.this.displayer.getImp().getSlice());
> /* 1416 */               SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(true);
> /* 1417 */               for (int frame = firstFrame.intValue(); frame <= lastFrame.intValue(); frame++) {
> /*      */                 
> /* 1419 */                 SPTBatch_.this.displayer.getImp().setPositionWithoutUpdate(channel.intValue(), slice.intValue(), frame);
> /* 1420 */                 BufferedImage bi = new BufferedImage(width.intValue(), height.intValue(), 2);
> /* 1421 */                 SPTBatch_.this.displayer.getImp().getCanvas().paint(bi.getGraphics());
> /* 1422 */                 ColorProcessor cp = new ColorProcessor(bi);
> /* 1423 */                 Integer index = Integer.valueOf(SPTBatch_.this.displayer.getImp().getStackIndex(channel.intValue(), slice.intValue(), frame));
> /* 1424 */                 stack.addSlice(SPTBatch_.this.displayer.getImp().getImageStack().getSliceLabel(index.intValue()), (ImageProcessor)cp);
> /*      */               } 
> /* 1426 */               SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(false);
> /* 1427 */               SPTBatch_.this.capture = new ImagePlus("TrackMate capture of " + SPTBatch_.this.displayer.getImp().getShortTitle(), stack);
> /*      */               
> /* 1429 */               SPTBatch_.transferCalibration(SPTBatch_.this.displayer.getImp(), SPTBatch_.this.capture);
> /* 1430 */               SPTBatch_.taskOutput.append(" done.\n");
> /*      */ 
> /*      */               
> /* 1433 */               if (SPTBatch_.checkboxRoi.isSelected() == Boolean.TRUE.booleanValue()) {
> /*      */                 
> /* 1435 */                 double dx = (SPTBatch_.imps.getCalibration()).pixelWidth;
> /* 1436 */                 double dy = (SPTBatch_.imps.getCalibration()).pixelHeight;
> /* 1437 */                 double dz = (SPTBatch_.imps.getCalibration()).pixelDepth;
> /* 1438 */                 RoiManager roiManager = RoiManager.getInstance();
> /* 1439 */                 if (roiManager == null) {
> /* 1440 */                   roiManager = new RoiManager();
> /*      */                 }
> /* 1442 */                 roiManager.reset();
> /* 1443 */                 List<Spot> spotsRoi = new ArrayList<>(SPTBatch_.this.trackmate.getModel().getSpots().getNSpots(true));
> /* 1444 */                 for (Integer trackID : SPTBatch_.this.trackmate.getModel().getTrackModel().trackIDs(true))
> /* 1445 */                   spotsRoi.addAll(SPTBatch_.this.trackmate.getModel().getTrackModel().trackSpots(trackID)); 
> /* 1446 */                 for (int s = 0; s < spotsRoi.size(); s++) {
> /* 1447 */                   OvalRoi ovalRoi; SpotRoi sroi = ((Spot)spotsRoi.get(s)).getRoi();
> /*      */                   
> /* 1449 */                   if (sroi != null) {
> /* 1450 */                     double[] xs = sroi.toPolygonX(dx, 0.0D, ((Spot)spotsRoi.get(s)).getDoublePosition(0), 1.0D);
> /* 1451 */                     double[] ys = sroi.toPolygonY(dy, 0.0D, ((Spot)spotsRoi.get(s)).getDoublePosition(1), 1.0D);
> /* 1452 */                     float[] xp = SPTBatch_.toFloat(xs);
> /* 1453 */                     float[] yp = SPTBatch_.toFloat(ys);
> /* 1454 */                     PolygonRoi polygonRoi = new PolygonRoi(xp, yp, 2);
> /*      */                   } else {
> /* 1456 */                     double diameter = 2.0D * ((Spot)spotsRoi.get(s)).getFeature("RADIUS").doubleValue() / dx;
> /* 1457 */                     double xs = ((Spot)spotsRoi.get(s)).getDoublePosition(0) / dx - diameter / 2.0D + 0.5D;
> /* 1458 */                     double ys = ((Spot)spotsRoi.get(s)).getDoublePosition(1) / dy - diameter / 2.0D + 0.5D;
> /* 1459 */                     ovalRoi = new OvalRoi(xs, ys, diameter, diameter);
> /*      */                   } 
> /*      */                   
> /* 1462 */                   int z = 1 + (int)Math.round(((Spot)spotsRoi.get(s)).getDoublePosition(2) / dz);
> /* 1463 */                   int i1 = 1 + ((Spot)spotsRoi.get(s)).getFeature("FRAME").intValue();
> /* 1464 */                   ovalRoi.setPosition(0, z, i1);
> /* 1465 */                   ovalRoi.setName(((Spot)spotsRoi.get(s)).getName());
> /* 1466 */                   roiManager.addRoi((Roi)ovalRoi);
> /*      */                 } 
> /*      */                 
> /* 1469 */                 if ((roiManager.getRoisAsArray()).length != 0) {
> /* 1470 */                   roiManager.runCommand("Save", 
> /* 1471 */                       SPTBatch_.directSPT + File.separator + SPTBatch_.imps.getShortTitle() + "_" + "RoiSet.zip");
> /*      */                 }
> /* 1473 */                 roiManager.close();
> /*      */               } 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */               
> /* 1496 */               if (SPTBatch_.checkbox2.isSelected() == Boolean.TRUE.booleanValue()) {
> /*      */                 
> /* 1498 */                 SPTBatch_.taskOutput.append(SPTBatch_.model.toString());
> /* 1499 */                 ISBIChallengeExporterModified.exportToFile(SPTBatch_.model, SPTBatch_.this.settings, new File(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + 
> /* 1500 */                       File.separator + "TrackMate_" + SPTBatch_.imps.getShortTitle() + ".xml"));
> /*      */ 
> /*      */ 
> /*      */                 
> /* 1504 */                 SPTBatch_.taskOutput.append("\nDone.");
> /*      */               } 
> /*      */               
> /* 1507 */               if (SPTBatch_.this.enableST == "ST") {
> /* 1508 */                 Model model = SPTBatch_.this.trackmate.getModel();
> /* 1509 */                 Settings settings = SPTBatch_.this.trackmate.getSettings();
> /* 1510 */                 SpotCollection spots1 = model.getSpots();
> /* 1511 */                 int nFrames = spots1.keySet().size();
> /* 1512 */                 double[][] data = new double[2][nFrames];
> /* 1513 */                 int indexx = 0;
> /* 1514 */                 for (Iterator<Integer> iterator = spots1.keySet().iterator(); iterator.hasNext(); ) { int i1 = ((Integer)iterator.next()).intValue();
> /* 1515 */                   data[1][indexx] = spots1.getNSpots(i1, true);
> /* 1516 */                   if (data[1][indexx] > 0.0D) {
> /* 1517 */                     data[0][indexx] = ((Spot)spots1.iterable(i1, false).iterator().next())
> /* 1518 */                       .getFeature("POSITION_T").doubleValue();
> /*      */                   } else {
> /* 1520 */                     data[0][indexx] = i1 * settings.dt;
> /*      */                   } 
> /* 1522 */                   indexx++; }
> /*      */ 
> /*      */                 
> /* 1525 */                 String xAxisLabel = "Time (" + SPTBatch_.this.trackmate.getModel().getTimeUnits() + ")";
> /* 1526 */                 String yAxisLabel = "N spots";
> /* 1527 */                 String title = "Nspots vs Time for " + (SPTBatch_.this.trackmate.getSettings()).imp.getShortTitle();
> /* 1528 */                 DefaultXYDataset dataset = new DefaultXYDataset();
> /* 1529 */                 dataset.addSeries("Nspots", data);
> /*      */                 
> /* 1531 */                 SPTBatch_.this.chart = ChartFactory.createXYLineChart(title, xAxisLabel, yAxisLabel, (XYDataset)dataset, 
> /* 1532 */                     PlotOrientation.VERTICAL, true, true, false);
> /* 1533 */                 SPTBatch_.this.chart.getTitle().setFont(Fonts.FONT);
> /* 1534 */                 SPTBatch_.this.chart.getLegend().setItemFont(Fonts.SMALL_FONT);
> /* 1535 */                 ExportableChartPanel exportableChartPanel = new ExportableChartPanel(SPTBatch_.this.chart);
> /*      */               } 
> /*      */ 
> /*      */               
> /* 1539 */               if (SPTBatch_.checkbox1.isSelected() == Boolean.TRUE.booleanValue()) {
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                 
> /* 1546 */                 if (SPTBatch_.this.enableSpotTable.equals("spotTable")) {
> /*      */ 
> /*      */ 
> /*      */                   
> /* 1550 */                   TablePanel<Spot> spotTable = SPTBatch_.this.createSpotTable(SPTBatch_.model, SPTBatch_.this.ds);
> /* 1551 */                   JTable spotJTable = spotTable.getTable();
> /* 1552 */                   TablePanel<Integer> trackTable = SPTBatch_.this.createTrackTable(SPTBatch_.model, SPTBatch_.this.ds);
> /* 1553 */                   SPTBatch_.trackJTable = trackTable.getTable();
> /* 1554 */                   SPTBatch_.nOfTracks = new ArrayList<>();
> /* 1555 */                   for (int t = 0; t < SPTBatch_.trackJTable.getModel().getRowCount(); t++)
> /* 1556 */                     SPTBatch_.nOfTracks.add(Integer.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(t, 2).toString())); 
> /* 1557 */                   SPTBatch_.this.indexes = new ArrayList<>();
> /* 1558 */                   Set<Integer> trackIDs = SPTBatch_.model.getTrackModel().trackIDs(true);
> /* 1559 */                   Set<Spot> track = null;
> /* 1560 */                   int counter = 0;
> /*      */                   
> /* 1562 */                   for (int i1 = 0; i1 < SPTBatch_.nOfTracks.size(); i1++) {
> /* 1563 */                     ArrayList<Float> framesByTrack = new ArrayList<>();
> /* 1564 */                     ArrayList<Float> framesByTrackSort = new ArrayList<>();
> /*      */                     
> /* 1566 */                     for (int r = 0; r < spotJTable.getRowCount(); r++) {
> /*      */                       
> /* 1568 */                       if (spotJTable.getModel().getValueAt(r, 2).toString()
> /* 1569 */                         .equals(String.valueOf(((Integer)SPTBatch_.nOfTracks.get(i1)).intValue()))) {
> /* 1570 */                         framesByTrack
> /* 1571 */                           .add(Float.valueOf(spotJTable.getModel().getValueAt(r, 8).toString()));
> /* 1572 */                         framesByTrackSort
> /* 1573 */                           .add(Float.valueOf(spotJTable.getModel().getValueAt(r, 8).toString()));
> /*      */                       } 
> /*      */                     } 
> /*      */ 
> /*      */ 
> /*      */                     
> /* 1579 */                     Collections.sort(framesByTrackSort);
> /*      */                     
> /* 1581 */                     for (int z = 0; z < framesByTrackSort.size(); z++) {
> /* 1582 */                       counter++;
> /* 1583 */                       if (i1 == 0)
> /* 1584 */                         SPTBatch_.this.indexes.add(Integer.valueOf(framesByTrack.indexOf(framesByTrackSort.get(z)))); 
> /* 1585 */                       if (i1 != 0) {
> /* 1586 */                         SPTBatch_.this.indexes.add(
> /* 1587 */                             Integer.valueOf(counter - 1 + framesByTrack.indexOf(framesByTrackSort.get(z)) - z));
> /*      */                       }
> /*      */                     } 
> /*      */                   } 
> /*      */ 
> /*      */                   
> /* 1593 */                   if (SPTBatch_.checkboxSubBg.isSelected()) {
> /*      */                     
> /* 1595 */                     SPTBatch_.columnNamesSpot = new String[] { "LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", 
> /* 1596 */                         "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", 
> /* 1597 */                         "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", 
> /* 1598 */                         "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", 
> /* 1599 */                         "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1", "Intensity-Bg Subtract" };
> /*      */                     
> /* 1601 */                     String[][] rowDataSpot = new String[SPTBatch_.this.indexes.size()][SPTBatch_.columnNamesSpot.length];
> /*      */                     int r;
> /* 1603 */                     for (r = 0; r < SPTBatch_.this.indexes.size(); r++) {
> /* 1604 */                       rowDataSpot[r][SPTBatch_.columnNamesSpot.length - 1] = "";
> /* 1605 */                       for (int c = 0; c < spotJTable.getModel().getColumnCount(); c++) {
> /* 1606 */                         rowDataSpot[r][c] = String.valueOf(
> /* 1607 */                             spotJTable.getModel().getValueAt(((Integer)SPTBatch_.this.indexes.get(r)).intValue(), c));
> /*      */                       }
> /*      */                     } 
> /*      */                     
> /* 1611 */                     if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 1) {
> /* 1612 */                       for (r = 0; r < rowDataSpot.length; r++) {
> /* 1613 */                         rowDataSpot[r][SPTBatch_.columnNamesSpot.length - 1] = 
> /* 1614 */                           String.valueOf(Double.valueOf(rowDataSpot[r][12].toString()).doubleValue() - 
> /* 1615 */                             Double.valueOf(rowDataSpot[r][19].toString()).doubleValue() * 
> /* 1616 */                             Double.valueOf(rowDataSpot[r][17].toString()).doubleValue());
> /*      */                       }
> /* 1618 */                       DefaultTableModel tableModel = new DefaultTableModel((Object[][])rowDataSpot, (Object[])SPTBatch_.columnNamesSpot);
> /* 1619 */                       SPTBatch_.tableSpot = new JTable(tableModel);
> /*      */                     } 
> /*      */                     
> /* 1622 */                     if (SPTBatch_.this.comboSubBg.getSelectedIndex() == 0 || SPTBatch_.this.comboSubBg.getSelectedIndex() == 2 || 
> /* 1623 */                       SPTBatch_.this.comboSubBg.getSelectedIndex() == 3 || SPTBatch_.this.comboSubBg.getSelectedIndex() == 4) {
> /*      */                       
> /* 1625 */                       for (r = 0; r < spotJTable.getModel().getRowCount(); r++) {
> /* 1626 */                         for (int i2 = 0; i2 < SPTBatch_.slicesIntensitySpot.length; i2++) {
> /* 1627 */                           if (Integer.valueOf(rowDataSpot[r][8].toString())
> /* 1628 */                             .equals(Integer.valueOf(i2)) == Boolean.TRUE.booleanValue())
> /* 1629 */                             rowDataSpot[r][SPTBatch_.columnNamesSpot.length - 1] = 
> /* 1630 */                               String.valueOf(Double.valueOf(rowDataSpot[r][12].toString()).doubleValue() - 
> /* 1631 */                                 Double.valueOf(SPTBatch_.slicesIntensitySpot[i2]).doubleValue()); 
> /*      */                         } 
> /*      */                       } 
> /* 1634 */                       SPTBatch_.tableSpot = new JTable((Object[][])rowDataSpot, (Object[])SPTBatch_.columnNamesSpot);
> /*      */                     } 
> /*      */ 
> /*      */                     
> /* 1638 */                     SPTBatch_.this.exportToCSV(rowDataSpot, SPTBatch_.columnNamesSpot, 
> /* 1639 */                         new File(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + SPTBatch_.imps.getShortTitle() + 
> /* 1640 */                           "_" + "Spots in tracks statistics" + ".csv"));
> /* 1641 */                     ResultsTable rtSpotPerImage = new ResultsTable();
> /* 1642 */                     for (int x = 0; x < rowDataSpot.length; x++) {
> /* 1643 */                       for (int i2 = 0; i2 < (rowDataSpot[x]).length; i2++)
> /* 1644 */                         rtSpotPerImage.setValue(SPTBatch_.columnNamesSpot[i2], x, rowDataSpot[x][i2]); 
> /* 1645 */                     }  SPTBatch_.this.rtSpots[SPTBatch_.i] = rtSpotPerImage;
> /*      */                   } 
> /* 1647 */                   if (!SPTBatch_.checkboxSubBg.isSelected()) {
> /*      */                     
> /* 1649 */                     SPTBatch_.columnNamesSpot = new String[] { "LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", 
> /* 1650 */                         "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", 
> /* 1651 */                         "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", 
> /* 1652 */                         "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", 
> /* 1653 */                         "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1" };
> /*      */                     
> /* 1655 */                     String[][] rowDataSpot = new String[SPTBatch_.this.indexes.size()][SPTBatch_.columnNamesSpot.length];
> /*      */                     
> /* 1657 */                     for (int r = 0; r < SPTBatch_.this.indexes.size(); r++) {
> /* 1658 */                       for (int c = 0; c < spotJTable.getModel().getColumnCount(); c++)
> /* 1659 */                         rowDataSpot[r][c] = String.valueOf(
> /* 1660 */                             spotJTable.getModel().getValueAt(((Integer)SPTBatch_.this.indexes.get(r)).intValue(), c)); 
> /* 1661 */                     }  SPTBatch_.tableSpot = new JTable((Object[][])rowDataSpot, (Object[])SPTBatch_.columnNamesSpot);
> /* 1662 */                     SPTBatch_.this.exportToCSV(rowDataSpot, SPTBatch_.columnNamesSpot, 
> /* 1663 */                         new File(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + SPTBatch_.imps.getShortTitle() + 
> /* 1664 */                           "_" + "Spots in tracks statistics" + ".csv"));
> /* 1665 */                     ResultsTable rtSpotPerImage = new ResultsTable();
> /* 1666 */                     for (int x = 0; x < rowDataSpot.length; x++) {
> /* 1667 */                       for (int i2 = 0; i2 < (rowDataSpot[x]).length; i2++)
> /* 1668 */                         rtSpotPerImage.setValue(SPTBatch_.columnNamesSpot[i2], x, rowDataSpot[x][i2]); 
> /* 1669 */                     }  SPTBatch_.this.rtSpots[SPTBatch_.i] = rtSpotPerImage;
> /*      */                   } 
> /*      */                 } 
> /*      */ 
> /*      */                 
> /* 1674 */                 if (SPTBatch_.this.enableLinkTable.equals("linkTable")) {
> /*      */                   
> /* 1676 */                   TablePanel<DefaultWeightedEdge> edgeTable = SPTBatch_.this.createEdgeTable(SPTBatch_.model, SPTBatch_.this.ds);
> /* 1677 */                   SPTBatch_.linkJTable = edgeTable.getTable();
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                   
> /*      */                   try {
> /* 1685 */                     edgeTable.exportToCsv(new File(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + 
> /* 1686 */                           SPTBatch_.imps.getShortTitle() + "_" + "Links in tracks statistics" + ".csv"));
> /* 1687 */                   } catch (IOException e) {
> /*      */                     
> /* 1689 */                     e.printStackTrace();
> /*      */                   } 
> /*      */                 } 
> /*      */                 
> /* 1693 */                 if (SPTBatch_.checkExcludeTracks.isSelected()) {
> /* 1694 */                   Roi mainRoi; SPTBatch_.this.excludeTrack = new ArrayList<>();
> /* 1695 */                   SPTBatch_.impMainRoi = ZProjector.run(SPTBatch_.impsSubBg.duplicate(), "max");
> /* 1696 */                   ImagePlus impToMeasure = SPTBatch_.impMainRoi.duplicate();
> /* 1697 */                   IJ.run(SPTBatch_.impMainRoi, "Auto Threshold", "method=Otsu ignore_black white");
> /* 1698 */                   SPTBatch_.impMainRoi = new ImagePlus(SPTBatch_.impMainRoi.getTitle(), 
> /* 1699 */                       Morphology.dilation(SPTBatch_.impMainRoi.getProcessor(), Strel.Shape.DISK.fromRadius(2)));
> /* 1700 */                   IJ.run(SPTBatch_.impMainRoi, "Invert LUT", "");
> /* 1701 */                   IJ.run(SPTBatch_.impMainRoi, "Fill Holes", "");
> /* 1702 */                   IJ.run(SPTBatch_.impMainRoi, "Invert LUT", "");
> /* 1703 */                   IJ.run(SPTBatch_.impMainRoi, "Create Selection", "");
> /* 1704 */                   Roi roiToMeasure = SPTBatch_.impMainRoi.getRoi();
> /* 1705 */                   IJ.run(SPTBatch_.impMainRoi, "Make Inverse", "");
> /* 1706 */                   Roi roiToMeasureInv = SPTBatch_.impMainRoi.getRoi();
> /* 1707 */                   impToMeasure.setRoi(roiToMeasure);
> /* 1708 */                   double meanDirect = (SPTBatch_.impMainRoi.getStatistics()).mean;
> /* 1709 */                   impToMeasure.setRoi(roiToMeasureInv);
> /* 1710 */                   double meanInv = (SPTBatch_.impMainRoi.getStatistics()).mean;
> /*      */                   
> /* 1712 */                   if (meanDirect > meanInv) {
> /* 1713 */                     mainRoi = roiToMeasure;
> /*      */                   } else {
> /* 1715 */                     mainRoi = roiToMeasureInv;
> /*      */                   } 
> /* 1717 */                   for (int i1 = 0; i1 < SPTBatch_.trackJTable.getRowCount(); i1++) {
> /* 1718 */                     if (mainRoi
> /* 1719 */                       .contains(
> /*      */                         
> /* 1721 */                         (int)IJ.getImage().getCalibration().getRawX(Double.parseDouble(SPTBatch_.trackJTable.getModel()
> /* 1722 */                             .getValueAt(i1, 
> /* 1723 */                               SPTBatch_.trackJTable.convertColumnIndexToModel(13))
> /* 1724 */                             .toString())), 
> /*      */                         
> /* 1726 */                         (int)IJ.getImage().getCalibration().getRawY(Double.parseDouble(SPTBatch_.trackJTable.getModel()
> /* 1727 */                             .getValueAt(i1, 
> /* 1728 */                               SPTBatch_.trackJTable.convertColumnIndexToModel(14))
> /* 1729 */                             .toString()))) == Boolean.TRUE.booleanValue()) {
> /* 1730 */                       SPTBatch_.this.excludeTrack.add(Boolean.valueOf(true));
> /*      */                     } else {
> /*      */                       
> /* 1733 */                       SPTBatch_.this.excludeTrack.add(Boolean.valueOf(false));
> /*      */                     } 
> /*      */                   } 
> /*      */                 } 
> /*      */                 
> /* 1738 */                 if (SPTBatch_.this.enableTrackTable.equals("trackTable")) {
> /*      */ 
> /*      */                   
> /* 1741 */                   Thread tracksThread = new Thread(new Runnable() {
> /*      */                         public void run() {
> /* 1743 */                           if (SPTBatch_.checkboxSubBg.isSelected()) {
> /* 1744 */                             TablePanel<Integer> trackTable = SPTBatch_.null.access$8(SPTBatch_.null.this).createTrackTable(SPTBatch_.model, (SPTBatch_.null.access$8(SPTBatch_.null.this)).ds);
> /* 1745 */                             SPTBatch_.trackJTable = trackTable.getTable();
> /*      */                             
> /* 1747 */                             if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE.booleanValue() && 
> /* 1748 */                               SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE.booleanValue())
> /* 1749 */                               SPTBatch_.columnNamesTrack = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", 
> /* 1750 */                                   "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", 
> /* 1751 */                                   "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", 
> /* 1752 */                                   "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", 
> /* 1753 */                                   "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", 
> /* 1754 */                                   "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", 
> /* 1755 */                                   "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", 
> /* 1756 */                                   "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", 
> /* 1757 */                                   "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", 
> /* 1758 */                                   "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", 
> /* 1759 */                                   "MSD timelag=3", "MSD", "Intensity-Bg Subtract", 
> /* 1760 */                                   "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + 
> /* 1761 */                                   ")", 
> /* 1762 */                                   "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", 
> /* 1763 */                                   "Movement", "sMSS", "sMSS Movement" }; 
> /* 1764 */                             if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE.booleanValue() && 
> /* 1765 */                               SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 1766 */                               SPTBatch_.columnNamesTrack = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", 
> /* 1767 */                                   "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", 
> /* 1768 */                                   "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", 
> /* 1769 */                                   "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", 
> /* 1770 */                                   "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", 
> /* 1771 */                                   "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", 
> /* 1772 */                                   "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", 
> /* 1773 */                                   "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", 
> /* 1774 */                                   "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", 
> /* 1775 */                                   "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", 
> /* 1776 */                                   "MSD timelag=3", "MSD", "Intensity-Bg Subtract", 
> /* 1777 */                                   "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + 
> /* 1778 */                                   ")", 
> /* 1779 */                                   "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", 
> /* 1780 */                                   "Movement", "sMSS", "sMSS Movement", "Track within Cell" };
> /*      */                             }
> /* 1782 */                             if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE.booleanValue() && 
> /* 1783 */                               SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE.booleanValue())
> /* 1784 */                               SPTBatch_.columnNamesTrack = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", 
> /* 1785 */                                   "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", 
> /* 1786 */                                   "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", 
> /* 1787 */                                   "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", 
> /* 1788 */                                   "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", 
> /* 1789 */                                   "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", 
> /* 1790 */                                   "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", 
> /* 1791 */                                   "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", 
> /* 1792 */                                   "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", 
> /* 1793 */                                   "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", 
> /* 1794 */                                   "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Diffusion Coef.", 
> /* 1795 */                                   "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", 
> /* 1796 */                                   "sMSS Movement" }; 
> /* 1797 */                             if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE.booleanValue() && 
> /* 1798 */                               SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 1799 */                               SPTBatch_.columnNamesTrack = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", 
> /* 1800 */                                   "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", 
> /* 1801 */                                   "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", 
> /* 1802 */                                   "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", 
> /* 1803 */                                   "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", 
> /* 1804 */                                   "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", 
> /* 1805 */                                   "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", 
> /* 1806 */                                   "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", 
> /* 1807 */                                   "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", 
> /* 1808 */                                   "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", 
> /* 1809 */                                   "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Diffusion Coef.", 
> /* 1810 */                                   "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", 
> /* 1811 */                                   "sMSS Movement", "Track within Cell" };
> /*      */                             }
> /* 1813 */                             String[][] rowDataTrack = new String[SPTBatch_.trackJTable
> /* 1814 */                                 .getRowCount()][SPTBatch_.columnNamesTrack.length];
> /* 1815 */                             for (int j = 0; j < SPTBatch_.trackJTable.getRowCount(); j++) {
> /* 1816 */                               rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 1] = "";
> /* 1817 */                               for (int c = 0; c < SPTBatch_.trackJTable.getColumnCount(); c++) {
> /* 1818 */                                 rowDataTrack[j][c] = String.valueOf(SPTBatch_.trackJTable.getValueAt(j, c));
> /*      */                               }
> /*      */                             } 
> /* 1821 */                             List<Integer> nOfTracks = new ArrayList<>();
> /* 1822 */                             for (int t = 0; t < SPTBatch_.trackJTable.getRowCount(); t++) {
> /* 1823 */                               nOfTracks.add(Integer.valueOf(SPTBatch_.trackJTable.getValueAt(t, 2).toString()));
> /*      */                             }
> /*      */                             
> /* 1826 */                             List<Double> allTracks = new ArrayList<>();
> /* 1827 */                             List<Double> allTracksDef = new ArrayList<>();
> /* 1828 */                             for (int k = 0; k < nOfTracks.size(); k++) {
> /* 1829 */                               int counter = 0;
> /* 1830 */                               List<Double> perTrack = new ArrayList<>();
> /* 1831 */                               List<Double> perTrackDef = new ArrayList<>();
> /* 1832 */                               for (int m = 0; m < SPTBatch_.tableSpot.getRowCount(); m++) {
> /* 1833 */                                 if (Integer.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(m, 2).toString())
> /* 1834 */                                   .equals(nOfTracks.get(k)) == Boolean.TRUE.booleanValue())
> /*      */                                 {
> /* 1836 */                                   perTrack.add(Double.valueOf(SPTBatch_.tableSpot.getModel()
> /* 1837 */                                         .getValueAt(m, SPTBatch_.tableSpot.getColumnCount() - 1).toString()));
> /*      */                                 }
> /*      */                               } 
> /*      */ 
> /*      */                               
> /* 1842 */                               if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE.booleanValue())
> /*      */                               {
> /* 1844 */                                 for (int n = SPTBatch_.minTracksJTF; n < SPTBatch_.maxTracksJTF; n++)
> /*      */                                 {
> /* 1846 */                                   perTrackDef.add(perTrack.get(n));
> /*      */                                 }
> /*      */                               }
> /*      */                               
> /* 1850 */                               if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE.booleanValue() && 
> /* 1851 */                                 perTrackDef.size() != 0) {
> /* 1852 */                                 allTracksDef.add(Double.valueOf(perTrackDef.stream()
> /* 1853 */                                       .mapToDouble(a -> a.doubleValue()).average().getAsDouble()));
> /*      */                               }
> /* 1855 */                               if (perTrack.size() != 0)
> /* 1856 */                                 allTracks.add(Double.valueOf(
> /* 1857 */                                       perTrack.stream().mapToDouble(a -> a.doubleValue()).average().getAsDouble())); 
> /*      */                             } 
> /* 1859 */                             ComputeMSD values = new ComputeMSD();
> /* 1860 */                             values.Compute(nOfTracks, (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtSpots[SPTBatch_.i]);
> /* 1861 */                             if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE.booleanValue() && 
> /* 1862 */                               SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE.booleanValue())
> /*      */                             {
> /* 1864 */                               for (int m = 0; m < SPTBatch_.trackJTable.getRowCount(); m++) {
> /* 1865 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 13] = 
> /* 1866 */                                   String.valueOf(((Double)ComputeMSD.msd1Values.get(m)).toString());
> /* 1867 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 12] = 
> /* 1868 */                                   String.valueOf(((Double)ComputeMSD.msd2Values.get(m)).toString());
> /* 1869 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 11] = 
> /* 1870 */                                   String.valueOf(((Double)ComputeMSD.msd3Values.get(m)).toString());
> /* 1871 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 10] = 
> /* 1872 */                                   String.valueOf(((Double)ComputeMSD.msdValues.get(m)).toString());
> /* 1873 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 9] = 
> /* 1874 */                                   String.valueOf(((Double)allTracks.get(m)).toString());
> /* 1875 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 8] = 
> /* 1876 */                                   String.valueOf(((Double)ComputeMSD.diffValues.get(m)).toString());
> /* 1877 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 7] = 
> /* 1878 */                                   String.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString());
> /* 1879 */                                 if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(m, 3)
> /* 1880 */                                     .toString()).doubleValue() >= Double.valueOf(SPTBatch_.thLengthJTF).doubleValue()) {
> /* 1881 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 6] = 
> /* 1882 */                                     String.valueOf("Long");
> /*      */                                 } else {
> /* 1884 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 6] = 
> /* 1885 */                                     String.valueOf("Short");
> /*      */                                 } 
> /* 1887 */                                 if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "Diff") {
> /* 1888 */                                   if (Double.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString()).doubleValue() <= (SPTBatch_.null.access$8(SPTBatch_.null.this)).thD14JTF) {
> /* 1889 */                                     rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 5] = 
> /* 1890 */                                       String.valueOf("Immobile");
> /*      */                                   }
> /* 1892 */                                   if (Double.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString()).doubleValue() > (SPTBatch_.null.access$8(SPTBatch_.null.this)).thD14JTF)
> /* 1893 */                                     rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 5] = 
> /* 1894 */                                       String.valueOf("Mobile"); 
> /*      */                                 } 
> /* 1896 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 4] = 
> /* 1897 */                                   String.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString());
> /*      */                                 
> /* 1899 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() < 0.6D && 
> /* 1900 */                                   Double.valueOf(ComputeMSD.alphaValues.toString()).doubleValue() >= 0.0D)
> /* 1901 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 1902 */                                     String.valueOf("Confined"); 
> /* 1903 */                                 if (Double.valueOf(ComputeMSD.alphaValues.toString()).doubleValue() < 0.9D && 
> /* 1904 */                                   Double.valueOf(ComputeMSD.alphaValues.toString()).doubleValue() >= 0.6D)
> /* 1905 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 1906 */                                     String.valueOf("Anomalous"); 
> /* 1907 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() < 1.1D && 
> /* 1908 */                                   Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 0.9D)
> /* 1909 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 1910 */                                     String.valueOf("Free"); 
> /* 1911 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 1.1D) {
> /* 1912 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 1913 */                                     String.valueOf("Directed");
> /*      */                                 }
> /*      */                                 
> /* 1916 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 2] = 
> /* 1917 */                                   String.valueOf(ComputeMSD.mssValues.get(m));
> /* 1918 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() == 1.0D)
> /* 1919 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 
> /* 1920 */                                       1] = "Unidirectional Ballistic"; 
> /* 1921 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() == 0.0D)
> /* 1922 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 1] = "Immobile"; 
> /* 1923 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() >= 0.45D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() <= 0.55D)
> /* 1924 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 1] = "Free"; 
> /* 1925 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() > 0.0D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() < 0.45D)
> /* 1926 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 1] = "Confined"; 
> /* 1927 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() > 0.55D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() < 1.0D) {
> /* 1928 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 1] = "Directed";
> /*      */                                 }
> /*      */                               } 
> /*      */                             }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                             
> /* 1939 */                             if (SPTBatch_.checkTracks.isSelected() == Boolean.FALSE.booleanValue() && 
> /* 1940 */                               SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 1941 */                               for (int m = 0; m < SPTBatch_.trackJTable.getRowCount(); m++) {
> /* 1942 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 14] = 
> /* 1943 */                                   String.valueOf(((Double)ComputeMSD.msd1Values.get(m)).toString());
> /* 1944 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 13] = 
> /* 1945 */                                   String.valueOf(((Double)ComputeMSD.msd2Values.get(m)).toString());
> /* 1946 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 12] = 
> /* 1947 */                                   String.valueOf(((Double)ComputeMSD.msd3Values.get(m)).toString());
> /* 1948 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 11] = 
> /* 1949 */                                   String.valueOf(((Double)ComputeMSD.msdValues.get(m)).toString());
> /* 1950 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 10] = 
> /* 1951 */                                   String.valueOf(((Double)allTracks.get(m)).toString());
> /* 1952 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 9] = 
> /* 1953 */                                   String.valueOf(((Double)ComputeMSD.diffValues.get(m)).toString());
> /* 1954 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 8] = 
> /* 1955 */                                   String.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString());
> /*      */                                 
> /* 1957 */                                 if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(m, 3)
> /* 1958 */                                     .toString()).doubleValue() >= Double.valueOf(SPTBatch_.thLengthJTF).doubleValue()) {
> /* 1959 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 7] = 
> /* 1960 */                                     String.valueOf("Long");
> /*      */                                 } else {
> /* 1962 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 7] = 
> /* 1963 */                                     String.valueOf("Short");
> /*      */                                 } 
> /* 1965 */                                 if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "Diff") {
> /* 1966 */                                   if (Double.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString()).doubleValue() <= (SPTBatch_.null.access$8(SPTBatch_.null.this)).thD14JTF) {
> /* 1967 */                                     rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 6] = 
> /* 1968 */                                       String.valueOf("Immobile");
> /*      */                                   }
> /* 1970 */                                   if (Double.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString()).doubleValue() > (SPTBatch_.null.access$8(SPTBatch_.null.this)).thD14JTF)
> /* 1971 */                                     rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 6] = 
> /* 1972 */                                       String.valueOf("Mobile"); 
> /*      */                                 } 
> /* 1974 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 5] = 
> /* 1975 */                                   String.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString());
> /*      */                                 
> /* 1977 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() < 0.6D && 
> /* 1978 */                                   Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 0.0D)
> /* 1979 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 4] = 
> /* 1980 */                                     String.valueOf("Confined"); 
> /* 1981 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() < 0.9D && 
> /* 1982 */                                   Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 0.6D)
> /* 1983 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 4] = 
> /* 1984 */                                     String.valueOf("Anomalous"); 
> /* 1985 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() < 1.1D && 
> /* 1986 */                                   Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 0.9D)
> /* 1987 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 4] = 
> /* 1988 */                                     String.valueOf("Free"); 
> /* 1989 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 1.1D) {
> /* 1990 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 4] = 
> /* 1991 */                                     String.valueOf("Directed");
> /*      */                                 }
> /*      */                                 
> /* 1994 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 1995 */                                   String.valueOf(ComputeMSD.mssValues.get(m));
> /* 1996 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() == 1.0D)
> /* 1997 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 
> /* 1998 */                                       2] = "Unidirectional Ballistic"; 
> /* 1999 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() == 0.0D)
> /* 2000 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 2] = "Immobile"; 
> /* 2001 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() >= 0.45D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() <= 0.55D)
> /* 2002 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 2] = "Free"; 
> /* 2003 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() > 0.0D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() < 0.45D)
> /* 2004 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 2] = "Confined"; 
> /* 2005 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() > 0.55D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() < 1.0D) {
> /* 2006 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 2] = "Directed";
> /*      */                                 }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                                 
> /* 2014 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 1] = ((Boolean)(SPTBatch_.null.access$8(SPTBatch_.null.this)).excludeTrack.get(m))
> /* 2015 */                                   .toString();
> /*      */                               } 
> /*      */                             }
> /*      */                             
> /* 2019 */                             if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE.booleanValue() && 
> /* 2020 */                               SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE.booleanValue()) {
> /* 2021 */                               for (int m = 0; m < SPTBatch_.trackJTable.getRowCount(); m++) {
> /* 2022 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 14] = 
> /* 2023 */                                   String.valueOf(((Double)ComputeMSD.msd1Values.get(m)).toString());
> /* 2024 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 13] = 
> /* 2025 */                                   String.valueOf(((Double)ComputeMSD.msd2Values.get(m)).toString());
> /* 2026 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 12] = 
> /* 2027 */                                   String.valueOf(((Double)ComputeMSD.msd3Values.get(m)).toString());
> /* 2028 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 11] = 
> /* 2029 */                                   String.valueOf(((Double)ComputeMSD.msdValues.get(m)).toString());
> /* 2030 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 11] = 
> /* 2031 */                                   String.valueOf(((Double)ComputeMSD.msdValues.get(m)).toString());
> /* 2032 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 10] = 
> /* 2033 */                                   String.valueOf(((Double)allTracks.get(m)).toString());
> /* 2034 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 9] = 
> /* 2035 */                                   String.valueOf(((Double)allTracksDef.get(m)).toString());
> /* 2036 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 8] = 
> /* 2037 */                                   String.valueOf(((Double)ComputeMSD.diffValues.get(m)).toString());
> /* 2038 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 7] = 
> /* 2039 */                                   String.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString());
> /* 2040 */                                 if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(m, 3)
> /* 2041 */                                     .toString()).doubleValue() >= Double.valueOf(SPTBatch_.thLengthJTF).doubleValue()) {
> /* 2042 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 6] = 
> /* 2043 */                                     String.valueOf("Long");
> /*      */                                 } else {
> /* 2045 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 6] = 
> /* 2046 */                                     String.valueOf("Short");
> /*      */                                 } 
> /* 2048 */                                 if (Double.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString()).doubleValue() <= (SPTBatch_.null.access$8(SPTBatch_.null.this)).thD14JTF) {
> /* 2049 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 5] = 
> /* 2050 */                                     String.valueOf("Immobile");
> /*      */                                 }
> /* 2052 */                                 if (Double.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString()).doubleValue() > (SPTBatch_.null.access$8(SPTBatch_.null.this)).thD14JTF)
> /* 2053 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 5] = 
> /* 2054 */                                     String.valueOf("Mobile"); 
> /* 2055 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 4] = 
> /* 2056 */                                   String.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString());
> /* 2057 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() < 0.6D && 
> /* 2058 */                                   Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 0.0D)
> /* 2059 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 2060 */                                     String.valueOf("Confined"); 
> /* 2061 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() < 0.9D && 
> /* 2062 */                                   Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 0.6D)
> /* 2063 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 2064 */                                     String.valueOf("Anomalous"); 
> /* 2065 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() < 1.1D && 
> /* 2066 */                                   Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 0.9D)
> /* 2067 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 2068 */                                     String.valueOf("Free"); 
> /* 2069 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 1.1D) {
> /* 2070 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 2071 */                                     String.valueOf("Directed");
> /*      */                                 }
> /*      */ 
> /*      */                                 
> /* 2075 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 2] = 
> /* 2076 */                                   String.valueOf(ComputeMSD.mssValues.get(m));
> /* 2077 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() == 1.0D)
> /* 2078 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 
> /* 2079 */                                       1] = "Unidirectional Ballistic"; 
> /* 2080 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() == 0.0D)
> /* 2081 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 1] = "Immobile"; 
> /* 2082 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() >= 0.45D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() <= 0.55D)
> /* 2083 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 1] = "Free"; 
> /* 2084 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() > 0.0D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() < 0.45D)
> /* 2085 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 1] = "Confined"; 
> /* 2086 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() > 0.55D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() < 1.0D) {
> /* 2087 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 1] = "Directed";
> /*      */                                 }
> /*      */                               } 
> /*      */                             }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                             
> /* 2098 */                             if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE.booleanValue() && 
> /* 2099 */                               SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 2100 */                               SPTBatch_.columnNamesTrack = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", 
> /* 2101 */                                   "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", 
> /* 2102 */                                   "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", 
> /* 2103 */                                   "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", 
> /* 2104 */                                   "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", 
> /* 2105 */                                   "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", 
> /* 2106 */                                   "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", 
> /* 2107 */                                   "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", 
> /* 2108 */                                   "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", 
> /* 2109 */                                   "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", 
> /* 2110 */                                   "MSD timelag=3", "MSD", "Intensity-Bg Subtract", 
> /* 2111 */                                   "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + 
> /* 2112 */                                   ")", 
> /* 2113 */                                   "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", 
> /* 2114 */                                   "Movement", "sMSS", "sMSS Movement", "Track within Cell" };
> /*      */                               
> /* 2116 */                               for (int m = 0; m < SPTBatch_.trackJTable.getRowCount(); m++) {
> /* 2117 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 15] = 
> /* 2118 */                                   String.valueOf(((Double)ComputeMSD.msd1Values.get(m)).toString());
> /* 2119 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 14] = 
> /* 2120 */                                   String.valueOf(((Double)ComputeMSD.msd2Values.get(m)).toString());
> /* 2121 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 13] = 
> /* 2122 */                                   String.valueOf(((Double)ComputeMSD.msd3Values.get(m)).toString());
> /* 2123 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 12] = 
> /* 2124 */                                   String.valueOf(((Double)ComputeMSD.msdValues.get(m)).toString());
> /* 2125 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 11] = 
> /* 2126 */                                   String.valueOf(((Double)allTracks.get(m)).toString());
> /* 2127 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 10] = 
> /* 2128 */                                   String.valueOf(((Double)allTracksDef.get(m)).toString());
> /* 2129 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 9] = 
> /* 2130 */                                   String.valueOf(((Double)ComputeMSD.diffValues.get(m)).toString());
> /* 2131 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 8] = 
> /* 2132 */                                   String.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString());
> /* 2133 */                                 if (Double.valueOf(SPTBatch_.trackJTable.getModel().getValueAt(m, 3)
> /* 2134 */                                     .toString()).doubleValue() >= Double.valueOf(SPTBatch_.thLengthJTF).doubleValue()) {
> /* 2135 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 7] = 
> /* 2136 */                                     String.valueOf("Long");
> /*      */                                 } else {
> /* 2138 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 7] = 
> /* 2139 */                                     String.valueOf("Short");
> /*      */                                 } 
> /* 2141 */                                 if (Double.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString()).doubleValue() <= (SPTBatch_.null.access$8(SPTBatch_.null.this)).thD14JTF) {
> /* 2142 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 6] = 
> /* 2143 */                                     String.valueOf("Immobile");
> /*      */                                 }
> /* 2145 */                                 if (Double.valueOf(((Double)ComputeMSD.d14Values.get(m)).toString()).doubleValue() > (SPTBatch_.null.access$8(SPTBatch_.null.this)).thD14JTF)
> /* 2146 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 6] = 
> /* 2147 */                                     String.valueOf("Mobile"); 
> /* 2148 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 5] = 
> /* 2149 */                                   String.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString());
> /* 2150 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() < 0.6D && 
> /* 2151 */                                   Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 0.0D)
> /* 2152 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 4] = 
> /* 2153 */                                     String.valueOf("Confined"); 
> /* 2154 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() < 0.9D && 
> /* 2155 */                                   Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 0.6D)
> /* 2156 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 4] = 
> /* 2157 */                                     String.valueOf("Anomalous"); 
> /* 2158 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() < 1.1D && 
> /* 2159 */                                   Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 0.9D)
> /* 2160 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 4] = 
> /* 2161 */                                     String.valueOf("Free"); 
> /* 2162 */                                 if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(m)).toString()).doubleValue() >= 1.1D) {
> /* 2163 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 4] = 
> /* 2164 */                                     String.valueOf("Directed");
> /*      */                                 }
> /*      */ 
> /*      */                                 
> /* 2168 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 2169 */                                   String.valueOf(ComputeMSD.mssValues.get(m));
> /* 2170 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() == 1.0D)
> /* 2171 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 
> /* 2172 */                                       2] = "Unidirectional Ballistic"; 
> /* 2173 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() == 0.0D)
> /* 2174 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 2] = "Immobile"; 
> /* 2175 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() >= 0.45D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() <= 0.55D)
> /* 2176 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 2] = "Free"; 
> /* 2177 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() > 0.0D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() < 0.45D)
> /* 2178 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 2] = "Confined"; 
> /* 2179 */                                 if (((Double)ComputeMSD.mssValues.get(m)).doubleValue() > 0.55D && ((Double)ComputeMSD.mssValues.get(m)).doubleValue() < 1.0D) {
> /* 2180 */                                   rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 2] = "Directed";
> /*      */                                 }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                                 
> /* 2188 */                                 rowDataTrack[m][SPTBatch_.columnNamesTrack.length - 1] = ((Boolean)(SPTBatch_.null.access$8(SPTBatch_.null.this)).excludeTrack.get(m))
> /* 2189 */                                   .toString();
> /*      */                               } 
> /*      */                             } 
> /*      */ 
> /*      */                             
> /* 2194 */                             (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage = new ResultsTable();
> /* 2195 */                             for (int x = 0; x < rowDataTrack.length; x++) {
> /* 2196 */                               for (int y = 0; y < (rowDataTrack[x]).length; y++)
> /* 2197 */                                 (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.setValue(SPTBatch_.columnNamesTrack[y], x, rowDataTrack[x][y]); 
> /*      */                             }  try {
> /* 2199 */                               (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.saveAs(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + 
> /* 2200 */                                   SPTBatch_.imps.getShortTitle() + "_" + "Tracks statistics" + ".csv");
> /* 2201 */                             } catch (IOException e) {
> /*      */                               
> /* 2203 */                               e.printStackTrace();
> /*      */                             } 
> /* 2205 */                             (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTracks[SPTBatch_.i] = (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage;
> /*      */                           } 
> /*      */                           
> /* 2208 */                           if (!SPTBatch_.checkboxSubBg.isSelected()) {
> /* 2209 */                             TablePanel<Integer> trackTable = SPTBatch_.null.access$8(SPTBatch_.null.this).createTrackTable(SPTBatch_.model, (SPTBatch_.null.access$8(SPTBatch_.null.this)).ds);
> /* 2210 */                             ComputeMSD values = new ComputeMSD();
> /* 2211 */                             values.Compute(SPTBatch_.nOfTracks, (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtSpots[SPTBatch_.i]);
> /* 2212 */                             JTable trackJTable = trackTable.getTable();
> /* 2213 */                             SPTBatch_.columnNamesTrack = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", 
> /* 2214 */                                 "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", 
> /* 2215 */                                 "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", 
> /* 2216 */                                 "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", 
> /* 2217 */                                 "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", 
> /* 2218 */                                 "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", 
> /* 2219 */                                 "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", 
> /* 2220 */                                 "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", 
> /* 2221 */                                 "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", 
> /* 2222 */                                 "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", 
> /* 2223 */                                 "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", 
> /* 2224 */                                 "Movement", "sMSS", "sMSS Movement" };
> /* 2225 */                             String[][] rowDataTrack = new String[trackJTable.getModel()
> /* 2226 */                                 .getRowCount()][SPTBatch_.columnNamesTrack.length];
> /*      */                             int j;
> /* 2228 */                             for (j = 0; j < trackJTable.getModel().getRowCount(); j++) {
> /* 2229 */                               for (int c = 0; c < trackJTable.getModel().getColumnCount(); c++)
> /* 2230 */                                 rowDataTrack[j][c] = 
> /* 2231 */                                   String.valueOf(trackJTable.getModel().getValueAt(j, c)); 
> /* 2232 */                             }  for (j = 0; j < trackJTable.getModel().getRowCount(); j++) {
> /* 2233 */                               rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 12] = 
> /* 2234 */                                 String.valueOf(((Double)ComputeMSD.msd1Values.get(j)).toString());
> /* 2235 */                               rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 11] = 
> /* 2236 */                                 String.valueOf(((Double)ComputeMSD.msd2Values.get(j)).toString());
> /* 2237 */                               rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 10] = 
> /* 2238 */                                 String.valueOf(((Double)ComputeMSD.msd3Values.get(j)).toString());
> /* 2239 */                               rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 9] = 
> /* 2240 */                                 String.valueOf(((Double)ComputeMSD.msdValues.get(j)).toString());
> /* 2241 */                               rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 8] = 
> /* 2242 */                                 String.valueOf(((Double)ComputeMSD.diffValues.get(j)).toString());
> /* 2243 */                               rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 7] = 
> /* 2244 */                                 String.valueOf(((Double)ComputeMSD.d14Values.get(j)).toString());
> /* 2245 */                               if (Double.valueOf(trackJTable.getModel().getValueAt(j, 3)
> /* 2246 */                                   .toString()).doubleValue() >= Double.valueOf(SPTBatch_.thLengthJTF).doubleValue()) {
> /* 2247 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Long");
> /*      */                               } else {
> /* 2249 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 6] = String.valueOf("Short");
> /*      */                               } 
> /*      */                               
> /* 2252 */                               if (Double.valueOf(((Double)ComputeMSD.d14Values.get(j)).toString()).doubleValue() <= (SPTBatch_.null.access$8(SPTBatch_.null.this)).thD14JTF) {
> /* 2253 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 5] = 
> /* 2254 */                                   String.valueOf("Immobile");
> /*      */                               }
> /* 2256 */                               if (Double.valueOf(((Double)ComputeMSD.d14Values.get(j)).toString()).doubleValue() > (SPTBatch_.null.access$8(SPTBatch_.null.this)).thD14JTF)
> /* 2257 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 5] = String.valueOf("Mobile"); 
> /* 2258 */                               rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 4] = 
> /* 2259 */                                 String.valueOf(((Double)ComputeMSD.alphaValues.get(j)).toString());
> /* 2260 */                               if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(j)).toString()).doubleValue() < 0.6D && 
> /* 2261 */                                 Double.valueOf(((Double)ComputeMSD.alphaValues.get(j)).toString()).doubleValue() >= 0.0D)
> /* 2262 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 2263 */                                   String.valueOf("Confined"); 
> /* 2264 */                               if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(j)).toString()).doubleValue() < 0.9D && 
> /* 2265 */                                 Double.valueOf(((Double)ComputeMSD.alphaValues.get(j)).toString()).doubleValue() >= 0.6D)
> /* 2266 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 2267 */                                   String.valueOf("Anomalous"); 
> /* 2268 */                               if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(j)).toString()).doubleValue() < 1.1D && 
> /* 2269 */                                 Double.valueOf(((Double)ComputeMSD.alphaValues.get(j)).toString()).doubleValue() >= 0.9D)
> /* 2270 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 3] = String.valueOf("Free"); 
> /* 2271 */                               if (Double.valueOf(((Double)ComputeMSD.alphaValues.get(j)).toString()).doubleValue() >= 1.1D) {
> /* 2272 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 3] = 
> /* 2273 */                                   String.valueOf("Directed");
> /*      */                               }
> /*      */ 
> /*      */                               
> /* 2277 */                               rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 2] = 
> /* 2278 */                                 String.valueOf(ComputeMSD.mssValues.get(j));
> /* 2279 */                               if (((Double)ComputeMSD.mssValues.get(j)).doubleValue() == 1.0D)
> /* 2280 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 
> /* 2281 */                                     1] = "Unidirectional Ballistic"; 
> /* 2282 */                               if (((Double)ComputeMSD.mssValues.get(j)).doubleValue() == 0.0D)
> /* 2283 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 1] = "Immobile"; 
> /* 2284 */                               if (((Double)ComputeMSD.mssValues.get(j)).doubleValue() >= 0.45D && ((Double)ComputeMSD.mssValues.get(j)).doubleValue() <= 0.55D)
> /* 2285 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 1] = "Free"; 
> /* 2286 */                               if (((Double)ComputeMSD.mssValues.get(j)).doubleValue() > 0.0D && ((Double)ComputeMSD.mssValues.get(j)).doubleValue() < 0.45D)
> /* 2287 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 1] = "Confined"; 
> /* 2288 */                               if (((Double)ComputeMSD.mssValues.get(j)).doubleValue() > 0.55D && ((Double)ComputeMSD.mssValues.get(j)).doubleValue() < 1.0D) {
> /* 2289 */                                 rowDataTrack[j][SPTBatch_.columnNamesTrack.length - 1] = "Directed";
> /*      */                               }
> /*      */                             } 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                             
> /* 2300 */                             (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage = new ResultsTable();
> /* 2301 */                             for (int x = 0; x < rowDataTrack.length; x++) {
> /* 2302 */                               for (int y = 0; y < (rowDataTrack[x]).length; y++)
> /* 2303 */                                 (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.setValue(SPTBatch_.columnNamesTrack[y], x, rowDataTrack[x][y]); 
> /*      */                             }  try {
> /* 2305 */                               (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.saveAs(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + 
> /* 2306 */                                   SPTBatch_.imps.getShortTitle() + "_" + "Tracks statistics" + ".csv");
> /* 2307 */                             } catch (IOException e) {
> /*      */                               
> /* 2309 */                               e.printStackTrace();
> /*      */                             } 
> /* 2311 */                             (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTracks[SPTBatch_.i] = (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage;
> /*      */                           } 
> /*      */ 
> /*      */                           
> /* 2315 */                           String[][] rowData = new String[4][(SPTBatch_.null.access$8(SPTBatch_.null.this)).columnsMovements.length];
> /* 2316 */                           int totalTracks = 0;
> /* 2317 */                           int longTracks = 0;
> /* 2318 */                           int longConfined = 0;
> /* 2319 */                           int longUniBal = 0;
> /* 2320 */                           int longFree = 0;
> /* 2321 */                           int longDirect = 0;
> /* 2322 */                           int immob = 0;
> /* 2323 */                           int shortTracks = 0;
> /* 2324 */                           int shortConfined = 0;
> /* 2325 */                           int shortAnom = 0;
> /* 2326 */                           int shortFree = 0;
> /* 2327 */                           int shortDirect = 0;
> /*      */                           
> /* 2329 */                           for (int r = 0; r < (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.size(); r++) {
> /* 2330 */                             if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE.booleanValue()) {
> /* 2331 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, 
> /* 2332 */                                   r) != null)
> /* 2333 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2334 */                                   .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r)
> /* 2335 */                                   .equals("Long"))
> /* 2336 */                                   longTracks++;  
> /* 2337 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, 
> /* 2338 */                                   r) != null)
> /* 2339 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2340 */                                   .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r)
> /* 2341 */                                   .equals("Short"))
> /* 2342 */                                   shortTracks++;  
> /* 2343 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn(), 
> /* 2344 */                                   r) != null)
> /* 2345 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2346 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r) != null)
> /* 2347 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn(), r)
> /* 2348 */                                     .equals("Confined") && 
> /* 2349 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2350 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r)
> /* 2351 */                                     .equals("Long"))
> /* 2352 */                                     longConfined++;   
> /* 2353 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 2, 
> /* 2354 */                                   r) != null)
> /* 2355 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2356 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r) != null)
> /* 2357 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2358 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 2, r)
> /* 2359 */                                     .equals("Confined") && 
> /* 2360 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2361 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r)
> /* 2362 */                                     .equals("Short")) {
> /* 2363 */                                     shortConfined++;
> /*      */                                   }  
> /* 2365 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 2, 
> /* 2366 */                                   r) != null)
> /* 2367 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2368 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r) != null)
> /* 2369 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2370 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 2, r)
> /* 2371 */                                     .equals("Unidirectional Ballistic") && 
> /* 2372 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2373 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r)
> /* 2374 */                                     .equals("Long"))
> /* 2375 */                                     longUniBal++;   
> /* 2376 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 2, 
> /* 2377 */                                   r) != null)
> /* 2378 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2379 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r) != null)
> /* 2380 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2381 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 2, r)
> /* 2382 */                                     .equals("Anomalous") && 
> /* 2383 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2384 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r)
> /* 2385 */                                     .equals("Short"))
> /* 2386 */                                     shortAnom++;   
> /* 2387 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn(), 
> /* 2388 */                                   r) != null)
> /* 2389 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2390 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r) != null)
> /* 2391 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn(), r)
> /* 2392 */                                     .equals("Free") && 
> /* 2393 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2394 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r)
> /* 2395 */                                     .equals("Long"))
> /* 2396 */                                     longFree++;   
> /* 2397 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 2, 
> /* 2398 */                                   r) != null)
> /* 2399 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2400 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r) != null)
> /* 2401 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2402 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 2, r)
> /* 2403 */                                     .equals("Free") && 
> /* 2404 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2405 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r)
> /* 2406 */                                     .equals("Short"))
> /* 2407 */                                     shortFree++;   
> /* 2408 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn(), 
> /* 2409 */                                   r) != null)
> /* 2410 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2411 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r) != null)
> /* 2412 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn(), r)
> /* 2413 */                                     .equals("Directed") && 
> /* 2414 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2415 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r)
> /* 2416 */                                     .equals("Long"))
> /* 2417 */                                     longDirect++;   
> /* 2418 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 2, 
> /* 2419 */                                   r) != null)
> /* 2420 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2421 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r) != null)
> /* 2422 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2423 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 2, r)
> /* 2424 */                                     .equals("Directed") && 
> /* 2425 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2426 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r)
> /* 2427 */                                     .equals("Short"))
> /* 2428 */                                     shortDirect++;   
> /* 2429 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 4, 
> /* 2430 */                                   r) != null)
> /* 2431 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2432 */                                   .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 4, r)
> /* 2433 */                                   .equals("Immobile"))
> /* 2434 */                                   immob++;  
> /*      */                             } 
> /* 2436 */                             if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 2437 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, 
> /* 2438 */                                   r) != null)
> /* 2439 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2440 */                                   .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r)
> /* 2441 */                                   .equals("Long"))
> /* 2442 */                                   longTracks++;  
> /* 2443 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, 
> /* 2444 */                                   r) != null)
> /* 2445 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2446 */                                   .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r)
> /* 2447 */                                   .equals("Short"))
> /* 2448 */                                   shortTracks++;  
> /* 2449 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 1, 
> /* 2450 */                                   r) != null)
> /* 2451 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2452 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r) != null)
> /* 2453 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2454 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 1, r)
> /* 2455 */                                     .equals("Confined") && 
> /* 2456 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2457 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r)
> /* 2458 */                                     .equals("Long"))
> /* 2459 */                                     longConfined++;   
> /* 2460 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 3, 
> /* 2461 */                                   r) != null)
> /* 2462 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2463 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r) != null)
> /* 2464 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2465 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 3, r)
> /* 2466 */                                     .equals("Confined") && 
> /* 2467 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2468 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r)
> /* 2469 */                                     .equals("Short")) {
> /* 2470 */                                     shortConfined++;
> /*      */                                   }  
> /* 2472 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 3, 
> /* 2473 */                                   r) != null)
> /* 2474 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2475 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r) != null)
> /* 2476 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2477 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 3, r)
> /* 2478 */                                     .equals("Unidirectional Ballistic") && 
> /* 2479 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2480 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r)
> /* 2481 */                                     .equals("Long"))
> /* 2482 */                                     longUniBal++;   
> /* 2483 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 3, 
> /* 2484 */                                   r) != null)
> /* 2485 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2486 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r) != null)
> /* 2487 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2488 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 3, r)
> /* 2489 */                                     .equals("Anomalous") && 
> /* 2490 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2491 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r)
> /* 2492 */                                     .equals("Short"))
> /* 2493 */                                     shortAnom++;   
> /* 2494 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 1, 
> /* 2495 */                                   r) != null)
> /* 2496 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2497 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r) != null)
> /* 2498 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2499 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 1, r)
> /* 2500 */                                     .equals("Free") && 
> /* 2501 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2502 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r)
> /* 2503 */                                     .equals("Long"))
> /* 2504 */                                     longFree++;   
> /* 2505 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 3, 
> /* 2506 */                                   r) != null)
> /* 2507 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2508 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r) != null)
> /* 2509 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2510 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 3, r)
> /* 2511 */                                     .equals("Free") && 
> /* 2512 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2513 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r)
> /* 2514 */                                     .equals("Short"))
> /* 2515 */                                     shortFree++;   
> /* 2516 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 1, 
> /* 2517 */                                   r) != null)
> /* 2518 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2519 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r) != null)
> /* 2520 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2521 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 1, r)
> /* 2522 */                                     .equals("Directed") && 
> /* 2523 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2524 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r)
> /* 2525 */                                     .equals("Long"))
> /* 2526 */                                     longDirect++;   
> /* 2527 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 3, 
> /* 2528 */                                   r) != null)
> /* 2529 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue(
> /* 2530 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r) != null)
> /* 2531 */                                   if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2532 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 3, r)
> /* 2533 */                                     .equals("Directed") && 
> /* 2534 */                                     (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2535 */                                     .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 6, r)
> /* 2536 */                                     .equals("Short"))
> /* 2537 */                                     shortDirect++;   
> /* 2538 */                               if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, 
> /* 2539 */                                   r) != null) {
> /* 2540 */                                 if ((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage
> /* 2541 */                                   .getStringValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.getLastColumn() - 5, r)
> /* 2542 */                                   .equals("Immobile")) {
> /* 2543 */                                   immob++;
> /*      */                                 }
> /*      */                               }
> /*      */                             } 
> /*      */                           } 
> /* 2548 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).totalTracksDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).totalTracksDef + (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.size();
> /* 2549 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).longTracksDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).longTracksDef + longTracks;
> /* 2550 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).longConfinedDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).longConfinedDef + longConfined;
> /* 2551 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).longUniBalDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).longUniBalDef + longUniBal;
> /* 2552 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).longFreeDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).longFreeDef + longFree;
> /* 2553 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).longDirectDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).longDirectDef + longDirect;
> /* 2554 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).shortTracksDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).shortTracksDef + shortTracks;
> /* 2555 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).shortConfinedDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).shortConfinedDef + shortConfined;
> /* 2556 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).shortAnomDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).shortAnomDef + shortAnom;
> /* 2557 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).shortFreeDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).shortFreeDef + shortFree;
> /* 2558 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).shortDirectDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).shortDirectDef + shortDirect;
> /* 2559 */                           (SPTBatch_.null.access$8(SPTBatch_.null.this)).immobDef = (SPTBatch_.null.access$8(SPTBatch_.null.this)).immobDef + immob;
> /*      */                           
> /* 2561 */                           rowData[0][0] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTrackPerImage.size());
> /* 2562 */                           rowData[1][0] = String.valueOf("");
> /* 2563 */                           rowData[2][0] = String.valueOf("");
> /* 2564 */                           rowData[3][0] = String.valueOf("");
> /* 2565 */                           rowData[0][1] = String.valueOf(longTracks);
> /* 2566 */                           rowData[1][1] = String.valueOf(" ");
> /* 2567 */                           rowData[2][1] = String.valueOf("Short Tracks");
> /* 2568 */                           rowData[3][1] = String.valueOf(shortTracks);
> /* 2569 */                           rowData[0][2] = String.valueOf(longConfined);
> /* 2570 */                           rowData[1][2] = String.valueOf(" ");
> /* 2571 */                           rowData[2][2] = String.valueOf("Short Confined");
> /* 2572 */                           rowData[3][2] = String.valueOf(shortConfined);
> /* 2573 */                           rowData[0][3] = String.valueOf(longUniBal);
> /* 2574 */                           rowData[1][3] = String.valueOf(" ");
> /* 2575 */                           rowData[2][3] = String.valueOf("Short Anomalous");
> /* 2576 */                           rowData[3][3] = String.valueOf(shortAnom);
> /* 2577 */                           rowData[0][4] = String.valueOf(longFree);
> /* 2578 */                           rowData[1][4] = String.valueOf(" ");
> /* 2579 */                           rowData[2][4] = String.valueOf("Short Free");
> /* 2580 */                           rowData[3][4] = String.valueOf(shortFree);
> /* 2581 */                           rowData[0][5] = String.valueOf(longDirect);
> /* 2582 */                           rowData[1][5] = String.valueOf(" ");
> /* 2583 */                           rowData[2][5] = String.valueOf("Short Direct");
> /* 2584 */                           rowData[3][5] = String.valueOf(shortDirect);
> /* 2585 */                           rowData[0][6] = String.valueOf(immob);
> /* 2586 */                           rowData[1][6] = String.valueOf("");
> /* 2587 */                           rowData[2][6] = String.valueOf("");
> /* 2588 */                           rowData[3][6] = String.valueOf("");
> /*      */                           
> /* 2590 */                           ResultsTable rtTrackSum = new ResultsTable();
> /* 2591 */                           for (int i = 0; i < rowData.length; i++) {
> /* 2592 */                             for (int c = 0; c < (rowData[i]).length; c++)
> /* 2593 */                               rtTrackSum.setValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).columnsMovements[c], i, rowData[i][c]); 
> /*      */                           } 
> /*      */                           try {
> /* 2596 */                             rtTrackSum.saveAs(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + 
> /* 2597 */                                 SPTBatch_.imps.getShortTitle() + "_" + "SummaryTracks" + ".csv");
> /* 2598 */                           } catch (IOException e) {
> /*      */                             
> /* 2600 */                             e.printStackTrace();
> /*      */                           } 
> /*      */ 
> /*      */                           
> /* 2604 */                           if (SPTBatch_.checkPBS.isSelected())
> /* 2605 */                             (new PhotobleachingSpotPlot()).Compute(); 
> /*      */                         }
> /*      */                       });
> /* 2608 */                   tracksThread.start();
> /*      */                 } 
> /* 2610 */                 if (SPTBatch_.this.enableBranchTable.equals("branchTable")) {
> /* 2611 */                   TablePanel<SPTBatch_.Branch> branchTable = SPTBatch_.createBranchTable(SPTBatch_.model, SPTBatch_.selectionModel);
> /*      */                   
> /*      */                   try {
> /* 2614 */                     branchTable.exportToCsv(new File(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + 
> /* 2615 */                           SPTBatch_.imps.getShortTitle() + "_" + "Branch analysis" + ".csv"));
> /* 2616 */                   } catch (IOException e) {
> /*      */                     
> /* 2618 */                     e.printStackTrace();
> /*      */                   } 
> /*      */                 } 
> /*      */               } 
> /*      */ 
> /*      */               
> /* 2624 */               if (SPTBatch_.checkboxSP.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 2625 */                 SPTBatch_.directChemo = new File(String.valueOf(SPTBatch_.directImages.getAbsolutePath()) + File.separator + "Chemotaxis_Analysis");
> /*      */                 
> /* 2627 */                 if (!SPTBatch_.directChemo.exists()) {
> /* 2628 */                   SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directChemo.getName());
> /* 2629 */                   boolean result = false;
> /*      */                   
> /*      */                   try {
> /* 2632 */                     SPTBatch_.directChemo.mkdir();
> /* 2633 */                     result = true;
> /* 2634 */                   } catch (SecurityException securityException) {}
> /*      */ 
> /*      */                   
> /* 2637 */                   if (result) {
> /* 2638 */                     SPTBatch_.taskOutput.append("DIR created");
> /*      */                   }
> /*      */                 } 
> /*      */ 
> /*      */                 
> /* 2643 */                 TablePanel<Spot> spotTable = SPTBatch_.this.createSpotTable(SPTBatch_.model, SPTBatch_.this.ds);
> /* 2644 */                 JTable spotJTable = spotTable.getTable();
> /* 2645 */                 ArrayList<Float> importedData = new ArrayList<>();
> /*      */                 
> /* 2647 */                 Set<Integer> trackIDs = SPTBatch_.model.getTrackModel().trackIDs(true);
> /* 2648 */                 Set<Spot> track = null;
> /* 2649 */                 for (Integer id : trackIDs) {
> /*      */                   
> /* 2651 */                   track = SPTBatch_.model.getTrackModel().trackSpots(id);
> /* 2652 */                   ArrayList<Float> framesByTrack = new ArrayList<>();
> /* 2653 */                   ArrayList<Float> xByTrack = new ArrayList<>();
> /* 2654 */                   ArrayList<Float> yByTrack = new ArrayList<>();
> /* 2655 */                   ArrayList<Float> framesByTrackSort = new ArrayList<>();
> /* 2656 */                   ArrayList<Float> xByTrackSort = new ArrayList<>();
> /* 2657 */                   ArrayList<Float> yByTrackSort = new ArrayList<>();
> /* 2658 */                   ArrayList<Float> trackID = new ArrayList<>();
> /* 2659 */                   ArrayList<Integer> indexes = new ArrayList<>();
> /* 2660 */                   for (Spot spot : track) {
> /* 2661 */                     trackID.add(Float.valueOf(Float.valueOf(id.intValue()).floatValue() + Float.valueOf("1.0").floatValue()));
> /* 2662 */                     framesByTrack.add(Float.valueOf(spot.getFeature("FRAME").toString()));
> /* 2663 */                     xByTrack.add(Float.valueOf(spot.getFeature("POSITION_X").toString()));
> /* 2664 */                     yByTrack.add(Float.valueOf(spot.getFeature("POSITION_Y").toString()));
> /* 2665 */                     framesByTrackSort.add(Float.valueOf(spot.getFeature("FRAME").toString()));
> /*      */                   } 
> /*      */                   
> /* 2668 */                   Collections.sort(framesByTrackSort);
> /* 2669 */                   for (int z = 0; z < framesByTrackSort.size(); z++)
> /* 2670 */                     indexes.add(Integer.valueOf(framesByTrack.indexOf(framesByTrackSort.get(z)))); 
> /* 2671 */                   for (int i1 = 0; i1 < indexes.size(); i1++) {
> /* 2672 */                     importedData.add(trackID.get(i1));
> /* 2673 */                     importedData.add(Float.valueOf(((Float)framesByTrackSort.get(i1)).floatValue() + Float.valueOf("1.0").floatValue()));
> /* 2674 */                     importedData.add(xByTrack.get(((Integer)indexes.get(i1)).intValue()));
> /* 2675 */                     importedData.add(yByTrack.get(((Integer)indexes.get(i1)).intValue()));
> /*      */                   } 
> /*      */                 } 
> /*      */ 
> /*      */ 
> /*      */                 
> /* 2681 */                 Chemotaxis_ToolModified chemotool = new Chemotaxis_ToolModified(importedData);
> /* 2682 */                 chemotool.run("");
> /*      */               } 
> /*      */               
> /* 2685 */               if (SPTBatch_.checkboxDiff.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 2686 */                 SPTBatch_.directDiff = new File(
> /* 2687 */                     String.valueOf(SPTBatch_.directImages.getAbsolutePath()) + File.separator + "Trajectory_Classifier");
> /*      */                 
> /* 2689 */                 if (!SPTBatch_.directDiff.exists()) {
> /* 2690 */                   SPTBatch_.taskOutput.append("creating directory: " + SPTBatch_.directDiff.getName());
> /* 2691 */                   boolean result = false;
> /*      */                   
> /*      */                   try {
> /* 2694 */                     SPTBatch_.directDiff.mkdir();
> /* 2695 */                     result = true;
> /* 2696 */                   } catch (SecurityException securityException) {}
> /*      */ 
> /*      */                   
> /* 2699 */                   if (result) {
> /* 2700 */                     SPTBatch_.taskOutput.append("DIR created");
> /*      */                   }
> /*      */                 } 
> /*      */                 
> /* 2704 */                 TraJClassifierTest_ tc = new TraJClassifierTest_();
> /* 2705 */                 tc.run("");
> /*      */               } 
> /*      */ 
> /*      */               
> /* 2709 */               if (SPTBatch_.checkboxMSD.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 2710 */                 TrackProcessorMSD_Modified msdPlot = new TrackProcessorMSD_Modified();
> /* 2711 */                 msdPlot.Compute(SPTBatch_.nOfTracks, SPTBatch_.this.rtSpots[SPTBatch_.i]);
> /*      */               } 
> /*      */               
> /* 2714 */               if (SPTBatch_.checkCluster.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 2715 */                 ClusterSizeAnalysis clusterAnal = new ClusterSizeAnalysis();
> /*      */                 
> /* 2717 */                 DefaultCategoryDataset barDatasetCount = new DefaultCategoryDataset();
> /* 2718 */                 DefaultCategoryDataset barDatasetPercet = new DefaultCategoryDataset();
> /* 2719 */                 int counter1 = 0, counter2 = 0, counter3 = 0, counter4 = 0, counter5 = 0, counter6 = 0;
> /* 2720 */                 int counter7 = 0, counter8 = 0, counter9 = 0, counter10 = 0;
> /* 2721 */                 for (int r = 0; r < SPTBatch_.nOfTracks.size(); r++) {
> /* 2722 */                   int counter = 0;
> /* 2723 */                   List<Double> perTrack = new ArrayList<>();
> /* 2724 */                   for (int t = 0; t < SPTBatch_.tableSpot.getRowCount(); t++) {
> /* 2725 */                     if (Integer.valueOf(SPTBatch_.tableSpot.getModel().getValueAt(t, 2).toString())
> /* 2726 */                       .equals(SPTBatch_.nOfTracks.get(r)) == Boolean.TRUE.booleanValue())
> /*      */                     {
> /* 2728 */                       perTrack.add(Double.valueOf(SPTBatch_.tableSpot.getModel()
> /* 2729 */                             .getValueAt(t, SPTBatch_.tableSpot.getColumnCount() - 1).toString()));
> /*      */                     }
> /*      */                   } 
> /*      */ 
> /*      */                   
> /* 2734 */                   clusterAnal.Compute(perTrack, SPTBatch_.nOfTracks.get(r));
> /*      */ 
> /*      */                   
> /* 2737 */                   double[] values = new double[perTrack.size()];
> /* 2738 */                   for (int i1 = 0; i1 < perTrack.size(); i1++)
> /* 2739 */                     values[i1] = ((Double)perTrack.get(i1)).doubleValue(); 
> /* 2740 */                   GaussianMixtureModified gm2 = GaussianMixtureModified.fit(values);
> /*      */                   
> /* 2742 */                   if (gm2.components.length == 1) {
> /* 2743 */                     counter1++;
> /*      */                   }
> /* 2745 */                   if (gm2.components.length == 2) {
> /* 2746 */                     counter2++;
> /*      */                   }
> /* 2748 */                   if (gm2.components.length == 3) {
> /* 2749 */                     counter3++;
> /*      */                   }
> /* 2751 */                   if (gm2.components.length == 4) {
> /* 2752 */                     counter4++;
> /*      */                   }
> /* 2754 */                   if (gm2.components.length == 5) {
> /* 2755 */                     counter5++;
> /*      */                   }
> /* 2757 */                   if (gm2.components.length == 6) {
> /* 2758 */                     counter6++;
> /*      */                   }
> /* 2760 */                   if (gm2.components.length == 7) {
> /* 2761 */                     counter7++;
> /*      */                   }
> /* 2763 */                   if (gm2.components.length == 8) {
> /* 2764 */                     counter8++;
> /*      */                   }
> /* 2766 */                   if (gm2.components.length == 9) {
> /* 2767 */                     counter9++;
> /*      */                   }
> /* 2769 */                   if (gm2.components.length == 10) {
> /* 2770 */                     counter10++;
> /*      */                   }
> /*      */                 } 
> /*      */ 
> /*      */                 
> /* 2775 */                 barDatasetCount.setValue(counter1, "receptors/particle", "1");
> /* 2776 */                 barDatasetCount.setValue(counter2, "receptors/particle", "2");
> /* 2777 */                 barDatasetCount.setValue(counter3, "receptors/particle", "3");
> /* 2778 */                 barDatasetCount.setValue(counter4, "receptors/particle", "4");
> /* 2779 */                 barDatasetCount.setValue(counter5, "receptors/particle", "5");
> /* 2780 */                 barDatasetCount.setValue(counter6, "receptors/particle", "6");
> /* 2781 */                 barDatasetCount.setValue(counter7, "receptors/particle", "7");
> /* 2782 */                 barDatasetCount.setValue(counter8, "receptors/particle", "8");
> /* 2783 */                 barDatasetCount.setValue(counter9, "receptors/particle", "9");
> /* 2784 */                 barDatasetCount.setValue(counter10, "receptors/particle", "10");
> /* 2785 */                 JFreeChart chartCount = ChartFactory.createBarChart("Count of receptors/particle", 
> /* 2786 */                     "receptors/particle", "Count", (CategoryDataset)barDatasetCount, PlotOrientation.VERTICAL, false, true, 
> /* 2787 */                     false);
> /*      */                 
> /* 2789 */                 if (SPTBatch_.nOfTracks.size() != 0) {
> /* 2790 */                   barDatasetPercet.setValue((counter1 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "1");
> /* 2791 */                   barDatasetPercet.setValue((counter2 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "2");
> /* 2792 */                   barDatasetPercet.setValue((counter3 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "3");
> /* 2793 */                   barDatasetPercet.setValue((counter4 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "4");
> /* 2794 */                   barDatasetPercet.setValue((counter5 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "5");
> /* 2795 */                   barDatasetPercet.setValue((counter6 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "6");
> /* 2796 */                   barDatasetPercet.setValue((counter7 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "7");
> /* 2797 */                   barDatasetPercet.setValue((counter8 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "8");
> /* 2798 */                   barDatasetPercet.setValue((counter9 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "9");
> /* 2799 */                   barDatasetPercet.setValue((counter10 * 100 / SPTBatch_.nOfTracks.size()), "receptors/particle", "10");
> /*      */                 } 
> /* 2801 */                 if (SPTBatch_.nOfTracks.size() != 0) {
> /*      */                   
> /* 2803 */                   barDatasetPercet.setValue(0.0D, "receptors/particle", "1");
> /* 2804 */                   barDatasetPercet.setValue(0.0D, "receptors/particle", "2");
> /* 2805 */                   barDatasetPercet.setValue(0.0D, "receptors/particle", "3");
> /* 2806 */                   barDatasetPercet.setValue(0.0D, "receptors/particle", "4");
> /* 2807 */                   barDatasetPercet.setValue(0.0D, "receptors/particle", "5");
> /* 2808 */                   barDatasetPercet.setValue(0.0D, "receptors/particle", "6");
> /* 2809 */                   barDatasetPercet.setValue(0.0D, "receptors/particle", "7");
> /* 2810 */                   barDatasetPercet.setValue(0.0D, "receptors/particle", "8");
> /* 2811 */                   barDatasetPercet.setValue(0.0D, "receptors/particle", "9");
> /* 2812 */                   barDatasetPercet.setValue(0.0D, "receptors/particle", "10");
> /*      */                 } 
> /*      */                 
> /* 2815 */                 JFreeChart chartPercet = ChartFactory.createBarChart("Percentage of receptors/particle", 
> /* 2816 */                     "receptors/particle", "Percentage-(%)", (CategoryDataset)barDatasetPercet, PlotOrientation.VERTICAL, 
> /* 2817 */                     false, true, false);
> /* 2818 */                 DecimalFormat pctFormat = new DecimalFormat("##.00%");
> /* 2819 */                 pctFormat.setMultiplier(1);
> /* 2820 */                 NumberFormat percent = NumberFormat.getPercentInstance();
> /* 2821 */                 percent.setMaximumFractionDigits(2);
> /* 2822 */                 StandardCategoryItemLabelGenerator standardCategoryItemLabelGenerator1 = new StandardCategoryItemLabelGenerator("{2}", 
> /* 2823 */                     NumberFormat.getInstance(), percent);
> /* 2824 */                 StandardCategoryItemLabelGenerator standardCategoryItemLabelGenerator2 = new StandardCategoryItemLabelGenerator("{2}", 
> /* 2825 */                     pctFormat);
> /*      */                 
> /* 2827 */                 CategoryPlot plotCount = chartCount.getCategoryPlot();
> /* 2828 */                 CategoryPlot plotPercent = chartPercet.getCategoryPlot();
> /* 2829 */                 CategoryItemRenderer rendererCount = plotCount.getRenderer();
> /* 2830 */                 CategoryItemRenderer rendererPercent = plotPercent.getRenderer();
> /*      */                 
> /* 2832 */                 NumberAxis rangeAxisCount = (NumberAxis)plotCount.getRangeAxis();
> /* 2833 */                 NumberAxis rangeAxisPercent = (NumberAxis)plotPercent.getRangeAxis();
> /* 2834 */                 rangeAxisPercent.setNumberFormatOverride(pctFormat);
> /* 2835 */                 rangeAxisCount.setAutoRangeIncludesZero(true);
> /* 2836 */                 rangeAxisPercent.setAutoRangeIncludesZero(true);
> /* 2837 */                 rendererCount.setDefaultItemLabelGenerator((CategoryItemLabelGenerator)standardCategoryItemLabelGenerator1);
> /* 2838 */                 rendererCount.setDefaultItemLabelFont(new Font("SansSerif", 0, 12));
> /*      */                 
> /* 2840 */                 rendererCount.setDefaultItemLabelsVisible(true);
> /* 2841 */                 rendererPercent.setDefaultItemLabelGenerator((CategoryItemLabelGenerator)standardCategoryItemLabelGenerator2);
> /* 2842 */                 rendererPercent.setDefaultItemLabelFont(new Font("SansSerif", 0, 12));
> /*      */                 
> /* 2844 */                 rendererPercent.setDefaultItemLabelsVisible(true);
> /*      */                 
> /*      */                 try {
> /* 2847 */                   ChartUtils.saveChartAsPNG(
> /* 2848 */                       new File(String.valueOf(SPTBatch_.directCluster.getAbsolutePath()) + File.separator + 
> /* 2849 */                         SPTBatch_.imps.getShortTitle() + "_ReceptorsPerParticle_Count" + ".png"), 
> /* 2850 */                       chartCount, 500, 400);
> /* 2851 */                 } catch (IOException e) {
> /*      */                   
> /* 2853 */                   e.printStackTrace();
> /*      */                 } 
> /*      */                 
> /*      */                 try {
> /* 2857 */                   ChartUtils.saveChartAsPNG(
> /* 2858 */                       new File(String.valueOf(SPTBatch_.directCluster.getAbsolutePath()) + File.separator + 
> /* 2859 */                         SPTBatch_.imps.getShortTitle() + 
> /* 2860 */                         "_ReceptorsPerParticle_Percentage" + ".png"), 
> /* 2861 */                       chartPercet, 500, 400);
> /* 2862 */                 } catch (IOException e) {
> /*      */                   
> /* 2864 */                   e.printStackTrace();
> /*      */                 } 
> /*      */               } 
> /*      */ 
> /*      */               
> /* 2869 */               if (SPTBatch_.checkboxPlot.isSelected() == Boolean.TRUE.booleanValue()) {
> /*      */ 
> /*      */ 
> /*      */                 
> /* 2873 */                 List<Spot> spots1 = new ArrayList<>(SPTBatch_.this.trackmate.getModel().getSpots().getNSpots(true));
> /* 2874 */                 Set<String> ySelectedSpotSet = new HashSet<>();
> /* 2875 */                 ySelectedSpotSet.add(SPTBatch_.this.ySelectedSpot);
> /* 2876 */                 for (Integer trackID : SPTBatch_.this.trackmate.getModel().getTrackModel().trackIDs(true)) {
> /* 2877 */                   spots1.addAll(SPTBatch_.this.trackmate.getModel().getTrackModel().trackSpots(trackID));
> /*      */                 }
> /* 2879 */                 if (SPTBatch_.ESP.isSelected() && SPTBatch_.this.xSelectedSpot != null && ySelectedSpotSet != null) {
> /* 2880 */                   JFreeChart chart = null;
> /* 2881 */                   XYPlot xYPlot = null;
> /* 2882 */                   Dimension xDimension = (Dimension)SPTBatch_.model.getFeatureModel()
> /* 2883 */                     .getSpotFeatureDimensions().get(SPTBatch_.this.xSelectedSpot);
> /* 2884 */                   Map<String, Dimension> yDimensions = SPTBatch_.model.getFeatureModel()
> /* 2885 */                     .getSpotFeatureDimensions();
> /* 2886 */                   Map<String, String> featureNames = SPTBatch_.model.getFeatureModel().getSpotFeatureNames();
> /*      */                   
> /* 2888 */                   String str = String.valueOf(featureNames.get(SPTBatch_.this.xSelectedSpot)) + " (" + 
> /* 2889 */                     TMUtils.getUnitsFor(xDimension, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits()) + 
> /* 2890 */                     ")";
> /*      */ 
> /*      */                   
> /* 2893 */                   Set<Dimension> set = (Set)SPTBatch_.this.getUniqueValues((Iterable)ySelectedSpotSet, 
> /* 2894 */                       (Map)yDimensions);
> /*      */ 
> /*      */                   
> /* 2897 */                   ArrayList<ExportableChartPanel> arrayList = new ArrayList<>(set.size());
> /* 2898 */                   for (Dimension dimension : set) {
> /*      */ 
> /*      */                     
> /* 2901 */                     String yAxisLabel = TMUtils.getUnitsFor(dimension, SPTBatch_.model.getSpaceUnits(), 
> /* 2902 */                         SPTBatch_.model.getTimeUnits());
> /*      */ 
> /*      */                     
> /* 2905 */                     List<String> featuresThisDimension = (List)SPTBatch_.getCommonKeys((V)dimension, (Iterable)ySelectedSpotSet, 
> /* 2906 */                         (Map)yDimensions);
> /*      */ 
> /*      */                     
> /* 2909 */                     String title = SPTBatch_.this.buildPlotTitle(featuresThisDimension, featureNames, SPTBatch_.this.xSelectedSpot);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                     
> /* 2914 */                     SpotCollectionDataset spotCollectionDataset = new SpotCollectionDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, 
> /* 2915 */                         SPTBatch_.this.xSelectedSpot, featuresThisDimension, spots1, true);
> /*      */                     
> /* 2917 */                     XYItemRenderer renderer = spotCollectionDataset.getRenderer();
> /*      */ 
> /*      */                     
> /* 2920 */                     chart = ChartFactory.createXYLineChart(title, str, yAxisLabel, (XYDataset)spotCollectionDataset, 
> /* 2921 */                         PlotOrientation.VERTICAL, true, true, false);
> /* 2922 */                     chart.getTitle().setFont(Fonts.FONT);
> /* 2923 */                     chart.getLegend().setItemFont(Fonts.SMALL_FONT);
> /* 2924 */                     chart.setBackgroundPaint(new Color(220, 220, 220));
> /* 2925 */                     chart.setBorderVisible(false);
> /* 2926 */                     chart.getLegend().setBackgroundPaint(new Color(220, 220, 220));
> /*      */ 
> /*      */                     
> /* 2929 */                     xYPlot = chart.getXYPlot();
> /* 2930 */                     xYPlot.setRenderer(renderer);
> /* 2931 */                     xYPlot.getRangeAxis().setLabelFont(Fonts.FONT);
> /* 2932 */                     xYPlot.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
> /* 2933 */                     xYPlot.getDomainAxis().setLabelFont(Fonts.FONT);
> /* 2934 */                     xYPlot.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
> /* 2935 */                     xYPlot.setOutlineVisible(false);
> /* 2936 */                     xYPlot.setDomainCrosshairVisible(false);
> /* 2937 */                     xYPlot.setDomainGridlinesVisible(false);
> /* 2938 */                     xYPlot.setRangeCrosshairVisible(false);
> /* 2939 */                     xYPlot.setRangeGridlinesVisible(false);
> /* 2940 */                     xYPlot.setBackgroundAlpha(0.0F);
> /*      */ 
> /*      */                     
> /* 2943 */                     ((NumberAxis)xYPlot.getRangeAxis()).setAutoRangeIncludesZero(false);
> /*      */ 
> /*      */                     
> /* 2946 */                     xYPlot.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
> /* 2947 */                     xYPlot.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
> /*      */                   } 
> /*      */ 
> /*      */                   
> /*      */                   try {
> /* 2952 */                     ChartUtils.saveChartAsPNG(
> /* 2953 */                         new File(SPTBatch_.directSPT + File.separator + SPTBatch_.imps.getShortTitle() + "_" + 
> /* 2954 */                           SPTBatch_.this.xSelectedSpot + "-" + SPTBatch_.this.ySelectedSpot + ".png"), 
> /* 2955 */                         xYPlot.getChart(), 500, 270);
> /* 2956 */                   } catch (IOException e) {
> /*      */                     
> /* 2958 */                     e.printStackTrace();
> /*      */                   } 
> /*      */                 } 
> /*      */ 
> /*      */ 
> /*      */                 
> /* 2964 */                 List<DefaultWeightedEdge> edges = new ArrayList<>();
> /* 2965 */                 Set<String> ySelectedLinkSet = new HashSet<>();
> /* 2966 */                 ySelectedLinkSet.add(SPTBatch_.this.ySelectedLink);
> /* 2967 */                 for (Integer trackID : SPTBatch_.this.trackmate.getModel().getTrackModel().trackIDs(true)) {
> /* 2968 */                   edges.addAll(SPTBatch_.this.trackmate.getModel().getTrackModel().trackEdges(trackID));
> /*      */                 }
> /*      */                 
> /* 2971 */                 if (SPTBatch_.ELP.isSelected() && SPTBatch_.this.xSelectedLink != null && ySelectedLinkSet != null) {
> /*      */                   
> /* 2973 */                   JFreeChart chart = null;
> /* 2974 */                   XYPlot xYPlot = null;
> /* 2975 */                   Dimension xDimension = (Dimension)SPTBatch_.model.getFeatureModel()
> /* 2976 */                     .getEdgeFeatureDimensions().get(SPTBatch_.this.xSelectedLink);
> /* 2977 */                   Map<String, Dimension> yDimensions = SPTBatch_.model.getFeatureModel()
> /* 2978 */                     .getEdgeFeatureDimensions();
> /* 2979 */                   Map<String, String> featureNames = SPTBatch_.model.getFeatureModel().getEdgeFeatureNames();
> /*      */                   
> /* 2981 */                   String str = String.valueOf(featureNames.get(SPTBatch_.this.xSelectedLink)) + " (" + 
> /* 2982 */                     TMUtils.getUnitsFor(xDimension, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits()) + 
> /* 2983 */                     ")";
> /*      */ 
> /*      */                   
> /* 2986 */                   Set<Dimension> set = (Set)SPTBatch_.this.getUniqueValues((Iterable)ySelectedLinkSet, 
> /* 2987 */                       (Map)yDimensions);
> /*      */ 
> /*      */                   
> /* 2990 */                   ArrayList<ExportableChartPanel> arrayList = new ArrayList<>(set.size());
> /* 2991 */                   for (Dimension dimension : set) {
> /*      */ 
> /*      */                     
> /* 2994 */                     String yAxisLabel = TMUtils.getUnitsFor(dimension, SPTBatch_.model.getSpaceUnits(), 
> /* 2995 */                         SPTBatch_.model.getTimeUnits());
> /*      */ 
> /*      */                     
> /* 2998 */                     List<String> featuresThisDimension = (List)SPTBatch_.getCommonKeys((V)dimension, (Iterable)ySelectedLinkSet, 
> /* 2999 */                         (Map)yDimensions);
> /*      */ 
> /*      */                     
> /* 3002 */                     String title = SPTBatch_.this.buildPlotTitle(featuresThisDimension, featureNames, SPTBatch_.this.xSelectedLink);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                     
> /* 3007 */                     EdgeCollectionDataset edgeCollectionDataset = new EdgeCollectionDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, 
> /* 3008 */                         SPTBatch_.this.xSelectedLink, featuresThisDimension, edges, true);
> /* 3009 */                     XYItemRenderer renderer = edgeCollectionDataset.getRenderer();
> /*      */ 
> /*      */                     
> /* 3012 */                     chart = ChartFactory.createXYLineChart(title, str, yAxisLabel, (XYDataset)edgeCollectionDataset, 
> /* 3013 */                         PlotOrientation.VERTICAL, true, true, false);
> /* 3014 */                     chart.getTitle().setFont(Fonts.FONT);
> /* 3015 */                     chart.getLegend().setItemFont(Fonts.SMALL_FONT);
> /* 3016 */                     chart.setBackgroundPaint(new Color(220, 220, 220));
> /* 3017 */                     chart.setBorderVisible(false);
> /* 3018 */                     chart.getLegend().setBackgroundPaint(new Color(220, 220, 220));
> /*      */ 
> /*      */                     
> /* 3021 */                     xYPlot = chart.getXYPlot();
> /* 3022 */                     xYPlot.setRenderer(renderer);
> /* 3023 */                     xYPlot.getRangeAxis().setLabelFont(Fonts.FONT);
> /* 3024 */                     xYPlot.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
> /* 3025 */                     xYPlot.getDomainAxis().setLabelFont(Fonts.FONT);
> /* 3026 */                     xYPlot.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
> /* 3027 */                     xYPlot.setOutlineVisible(false);
> /* 3028 */                     xYPlot.setDomainCrosshairVisible(false);
> /* 3029 */                     xYPlot.setDomainGridlinesVisible(false);
> /* 3030 */                     xYPlot.setRangeCrosshairVisible(false);
> /* 3031 */                     xYPlot.setRangeGridlinesVisible(false);
> /* 3032 */                     xYPlot.setBackgroundAlpha(0.0F);
> /*      */ 
> /*      */                     
> /* 3035 */                     ((NumberAxis)xYPlot.getRangeAxis()).setAutoRangeIncludesZero(false);
> /*      */ 
> /*      */                     
> /* 3038 */                     xYPlot.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
> /* 3039 */                     xYPlot.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
> /*      */                   } 
> /*      */                   
> /*      */                   try {
> /* 3043 */                     ChartUtils.saveChartAsPNG(
> /* 3044 */                         new File(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + SPTBatch_.imps.getShortTitle() + 
> /* 3045 */                           "_" + SPTBatch_.this.xSelectedLink + "-" + SPTBatch_.this.ySelectedLink + ".png"), 
> /* 3046 */                         xYPlot.getChart(), 500, 270);
> /* 3047 */                   } catch (IOException e) {
> /*      */                     
> /* 3049 */                     e.printStackTrace();
> /*      */                   } 
> /*      */                 } 
> /*      */ 
> /*      */ 
> /*      */                 
> /* 3055 */                 Set<String> ySelectedTrackSet = new HashSet<>();
> /* 3056 */                 ySelectedTrackSet.add(SPTBatch_.this.ySelectedTrack);
> /*      */                 
> /* 3058 */                 if (SPTBatch_.ETP.isSelected() && SPTBatch_.this.xSelectedTrack != null && ySelectedTrackSet != null) {
> /* 3059 */                   SPTBatch_.this.tracksID = new ArrayList<>(SPTBatch_.this.trackmate.getModel().getTrackModel().unsortedTrackIDs(true));
> /* 3060 */                   JFreeChart chart = null;
> /* 3061 */                   XYPlot xYPlot = null;
> /* 3062 */                   Dimension xDimension = (Dimension)SPTBatch_.model.getFeatureModel()
> /* 3063 */                     .getTrackFeatureDimensions().get(SPTBatch_.this.xSelectedTrack);
> /* 3064 */                   Map<String, Dimension> yDimensions = SPTBatch_.model.getFeatureModel()
> /* 3065 */                     .getTrackFeatureDimensions();
> /* 3066 */                   Map<String, String> featureNames = SPTBatch_.model.getFeatureModel().getTrackFeatureNames();
> /*      */                   
> /* 3068 */                   String str = String.valueOf(featureNames.get(SPTBatch_.this.xSelectedTrack)) + " (" + 
> /* 3069 */                     TMUtils.getUnitsFor(xDimension, SPTBatch_.model.getSpaceUnits(), SPTBatch_.model.getTimeUnits()) + 
> /* 3070 */                     ")";
> /*      */ 
> /*      */                   
> /* 3073 */                   Set<Dimension> set = (Set)SPTBatch_.this.getUniqueValues((Iterable)ySelectedTrackSet, 
> /* 3074 */                       (Map)yDimensions);
> /*      */ 
> /*      */                   
> /* 3077 */                   ArrayList<ExportableChartPanel> arrayList = new ArrayList<>(set.size());
> /* 3078 */                   for (Dimension dimension : set) {
> /*      */ 
> /*      */                     
> /* 3081 */                     String yAxisLabel = TMUtils.getUnitsFor(dimension, SPTBatch_.model.getSpaceUnits(), 
> /* 3082 */                         SPTBatch_.model.getTimeUnits());
> /*      */ 
> /*      */                     
> /* 3085 */                     List<String> featuresThisDimension = (List)SPTBatch_.getCommonKeys((V)dimension, (Iterable)ySelectedTrackSet, 
> /* 3086 */                         (Map)yDimensions);
> /*      */ 
> /*      */                     
> /* 3089 */                     String title = SPTBatch_.this.buildPlotTitle(featuresThisDimension, featureNames, 
> /* 3090 */                         SPTBatch_.this.xSelectedTrack);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                     
> /* 3095 */                     TrackCollectionDataset trackCollectionDataset = new TrackCollectionDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, 
> /* 3096 */                         SPTBatch_.this.xSelectedTrack, featuresThisDimension, SPTBatch_.this.tracksID);
> /* 3097 */                     XYItemRenderer renderer = trackCollectionDataset.getRenderer();
> /*      */ 
> /*      */                     
> /* 3100 */                     chart = ChartFactory.createXYLineChart(title, str, yAxisLabel, (XYDataset)trackCollectionDataset, 
> /* 3101 */                         PlotOrientation.VERTICAL, true, true, false);
> /* 3102 */                     chart.getTitle().setFont(Fonts.FONT);
> /* 3103 */                     chart.getLegend().setItemFont(Fonts.SMALL_FONT);
> /* 3104 */                     chart.setBackgroundPaint(new Color(220, 220, 220));
> /* 3105 */                     chart.setBorderVisible(false);
> /* 3106 */                     chart.getLegend().setBackgroundPaint(new Color(220, 220, 220));
> /*      */ 
> /*      */                     
> /* 3109 */                     xYPlot = chart.getXYPlot();
> /* 3110 */                     xYPlot.setRenderer(renderer);
> /* 3111 */                     xYPlot.getRangeAxis().setLabelFont(Fonts.FONT);
> /* 3112 */                     xYPlot.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
> /* 3113 */                     xYPlot.getDomainAxis().setLabelFont(Fonts.FONT);
> /* 3114 */                     xYPlot.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
> /* 3115 */                     xYPlot.setOutlineVisible(false);
> /* 3116 */                     xYPlot.setDomainCrosshairVisible(false);
> /* 3117 */                     xYPlot.setDomainGridlinesVisible(false);
> /* 3118 */                     xYPlot.setRangeCrosshairVisible(false);
> /* 3119 */                     xYPlot.setRangeGridlinesVisible(false);
> /* 3120 */                     xYPlot.setBackgroundAlpha(0.0F);
> /*      */ 
> /*      */                     
> /* 3123 */                     ((NumberAxis)xYPlot.getRangeAxis()).setAutoRangeIncludesZero(false);
> /*      */ 
> /*      */                     
> /* 3126 */                     xYPlot.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
> /* 3127 */                     xYPlot.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
> /*      */                   } 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                   
> /*      */                   try {
> /* 3135 */                     ChartUtils.saveChartAsPNG(
> /* 3136 */                         new File(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + SPTBatch_.imps.getShortTitle() + 
> /* 3137 */                           "_" + SPTBatch_.this.xSelectedTrack + "-" + SPTBatch_.this.ySelectedTrack + ".png"), 
> /* 3138 */                         xYPlot.getChart(), 500, 270);
> /* 3139 */                   } catch (IOException e) {
> /*      */                     
> /* 3141 */                     e.printStackTrace();
> /*      */                   } 
> /*      */                 } 
> /*      */ 
> /*      */                 
> /* 3146 */                 int maxFrame = spots.keySet().stream().mapToInt(Integer::intValue).max().getAsInt();
> /* 3147 */                 int[] nSpots = new int[maxFrame + 1];
> /* 3148 */                 double[] time = new double[maxFrame + 1];
> /* 3149 */                 XYPlot plot = null;
> /* 3150 */                 for (int i1 = 0; i1 <= maxFrame; i1++) {
> /* 3151 */                   nSpots[i1] = spots.getNSpots(i1, true);
> /* 3152 */                   time[i1] = i1 * SPTBatch_.this.settings.dt;
> /*      */                 } 
> /* 3154 */                 SPTBatch_.NSpotPerFrameDataset dataset = new SPTBatch_.NSpotPerFrameDataset(SPTBatch_.model, SPTBatch_.selectionModel, SPTBatch_.this.ds, time, 
> /* 3155 */                     nSpots);
> /* 3156 */                 String yFeature = "N spots";
> /* 3157 */                 Map<String, Dimension> dimMap = new HashMap<>(2);
> /* 3158 */                 dimMap.put("N spots", Dimension.NONE);
> /* 3159 */                 dimMap.put("POSITION_T", Dimension.TIME);
> /* 3160 */                 Map<String, String> nameMap = new HashMap<>(2);
> /* 3161 */                 nameMap.put("N spots", "N spots");
> /* 3162 */                 nameMap.put("POSITION_T", "T");
> /*      */ 
> /*      */                 
> /* 3165 */                 String xAxisLabel = String.valueOf(nameMap.get("POSITION_T")) + " (" + 
> /* 3166 */                   TMUtils.getUnitsFor(Dimension.TIME, SPTBatch_.model.getSpaceUnits(), 
> /* 3167 */                     SPTBatch_.model.getTimeUnits()) + 
> /* 3168 */                   ")";
> /*      */ 
> /*      */                 
> /* 3171 */                 Set<Dimension> dimensions = (Set)SPTBatch_.this.getUniqueValues(
> /* 3172 */                     (Iterable)Collections.singletonList("N spots"), (Map)dimMap);
> /*      */ 
> /*      */                 
> /* 3175 */                 ArrayList<ExportableChartPanel> chartPanels = new ArrayList<>(dimensions.size());
> /* 3176 */                 for (Dimension dimension : dimensions) {
> /*      */ 
> /*      */                   
> /* 3179 */                   String yAxisLabel = TMUtils.getUnitsFor(dimension, SPTBatch_.model.getSpaceUnits(), 
> /* 3180 */                       SPTBatch_.model.getTimeUnits());
> /*      */ 
> /*      */                   
> /* 3183 */                   List<String> featuresThisDimension = (List)SPTBatch_.getCommonKeys((V)dimension, 
> /* 3184 */                       (Iterable)Collections.singletonList("N spots"), (Map)dimMap);
> /*      */ 
> /*      */                   
> /* 3187 */                   String title = SPTBatch_.this.buildPlotTitle(featuresThisDimension, nameMap, "POSITION_T");
> /*      */ 
> /*      */                   
> /* 3190 */                   XYItemRenderer renderer = dataset.getRenderer();
> /*      */ 
> /*      */                   
> /* 3193 */                   JFreeChart chart = ChartFactory.createXYLineChart(title, xAxisLabel, yAxisLabel, 
> /* 3194 */                       (XYDataset)dataset, PlotOrientation.VERTICAL, true, true, false);
> /* 3195 */                   chart.getTitle().setFont(Fonts.FONT);
> /* 3196 */                   chart.getLegend().setItemFont(Fonts.SMALL_FONT);
> /* 3197 */                   chart.setBackgroundPaint(new Color(220, 220, 220));
> /* 3198 */                   chart.setBorderVisible(false);
> /* 3199 */                   chart.getLegend().setBackgroundPaint(new Color(220, 220, 220));
> /*      */ 
> /*      */                   
> /* 3202 */                   plot = chart.getXYPlot();
> /* 3203 */                   plot.setRenderer(renderer);
> /* 3204 */                   plot.getRangeAxis().setLabelFont(Fonts.FONT);
> /* 3205 */                   plot.getRangeAxis().setTickLabelFont(Fonts.SMALL_FONT);
> /* 3206 */                   plot.getDomainAxis().setLabelFont(Fonts.FONT);
> /* 3207 */                   plot.getDomainAxis().setTickLabelFont(Fonts.SMALL_FONT);
> /* 3208 */                   plot.setOutlineVisible(false);
> /* 3209 */                   plot.setDomainCrosshairVisible(false);
> /* 3210 */                   plot.setDomainGridlinesVisible(false);
> /* 3211 */                   plot.setRangeCrosshairVisible(false);
> /* 3212 */                   plot.setRangeGridlinesVisible(false);
> /* 3213 */                   plot.setBackgroundAlpha(0.0F);
> /*      */ 
> /*      */                   
> /* 3216 */                   ((NumberAxis)plot.getRangeAxis()).setAutoRangeIncludesZero(false);
> /*      */ 
> /*      */                   
> /* 3219 */                   plot.getRangeAxis().setTickLabelInsets(new RectangleInsets(20.0D, 10.0D, 20.0D, 10.0D));
> /* 3220 */                   plot.getDomainAxis().setTickLabelInsets(new RectangleInsets(10.0D, 20.0D, 10.0D, 20.0D));
> /*      */                 } 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                 
> /*      */                 try {
> /* 3230 */                   ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + 
> /* 3231 */                         SPTBatch_.imps.getShortTitle() + "_" + "Nspotsvs.Time" + ".png"), plot.getChart(), 500, 
> /* 3232 */                       270);
> /* 3233 */                 } catch (IOException e) {
> /*      */                   
> /* 3235 */                   e.printStackTrace();
> /*      */                 } 
> /*      */               } 
> /*      */ 
> /*      */               
> /* 3240 */               if (SPTBatch_.checkbox4.isSelected() == Boolean.TRUE.booleanValue()) {
> /*      */                 
> /* 3242 */                 if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.FALSE.booleanValue()) {
> /* 3243 */                   IJ.saveAs(SPTBatch_.this.capture, "Tiff", String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]);
> /*      */                 }
> /* 3245 */                 if (SPTBatch_.checkExcludeTracks.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 3246 */                   for (int r = 0; r < SPTBatch_.this.excludeTrack.size(); r++) {
> /* 3247 */                     int trackID = Integer.parseInt(SPTBatch_.trackJTable.getValueAt(r, 2).toString());
> /* 3248 */                     SPTBatch_.this.trackmate.getModel().beginUpdate();
> /*      */                     try {
> /* 3250 */                       SPTBatch_.this.trackmate.getModel().setTrackVisibility(Integer.valueOf(trackID), ((Boolean)SPTBatch_.this.excludeTrack.get(r)).booleanValue());
> /*      */                     } finally {
> /* 3252 */                       SPTBatch_.this.trackmate.getModel().endUpdate();
> /*      */                     } 
> /*      */                     
> /* 3255 */                     SPTBatch_.this.displayer.render();
> /* 3256 */                     SPTBatch_.this.displayer.refresh();
> /*      */                   } 
> /*      */                   
> /* 3259 */                   if (SPTBatch_.imps.getNFrames() > 1) {
> /* 3260 */                     firstFrame = Integer.valueOf(Math.max(1, Math.min(SPTBatch_.imps.getNFrames(), 1)));
> /* 3261 */                     lastFrame = Integer.valueOf(Math.min(SPTBatch_.imps.getNFrames(), Math.max(SPTBatch_.imps.getNFrames(), 1)));
> /*      */                   } 
> /* 3263 */                   if (SPTBatch_.imps.getNSlices() > 1) {
> /* 3264 */                     firstFrame = Integer.valueOf(Math.max(1, Math.min(SPTBatch_.imps.getNSlices(), 1)));
> /* 3265 */                     lastFrame = Integer.valueOf(Math.min(SPTBatch_.imps.getNSlices(), Math.max(SPTBatch_.imps.getNSlices(), 1)));
> /*      */                   } 
> /*      */                   
> /* 3268 */                   SPTBatch_.taskOutput.append("Capturing TrackMate overlay from frame " + firstFrame + " to " + 
> /* 3269 */                       lastFrame + ".\n");
> /* 3270 */                   bounds = SPTBatch_.this.displayer.getImp().getCanvas().getBounds();
> /* 3271 */                   width = Integer.valueOf(bounds.width);
> /* 3272 */                   height = Integer.valueOf(bounds.height);
> /* 3273 */                   nCaptures = Integer.valueOf(lastFrame.intValue() - firstFrame.intValue() + 1);
> /* 3274 */                   stack = new ImageStack(width.intValue(), height.intValue());
> /* 3275 */                   channel = Integer.valueOf(SPTBatch_.this.displayer.getImp().getChannel());
> /* 3276 */                   slice = Integer.valueOf(SPTBatch_.this.displayer.getImp().getSlice());
> /* 3277 */                   SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(true);
> /* 3278 */                   for (int i1 = firstFrame.intValue(); i1 <= lastFrame.intValue(); i1++) {
> /*      */                     
> /* 3280 */                     SPTBatch_.this.displayer.getImp().setPositionWithoutUpdate(channel.intValue(), slice.intValue(), i1);
> /* 3281 */                     BufferedImage bi = new BufferedImage(width.intValue(), height.intValue(), 2);
> /* 3282 */                     SPTBatch_.this.displayer.getImp().getCanvas().paint(bi.getGraphics());
> /* 3283 */                     ColorProcessor cp = new ColorProcessor(bi);
> /* 3284 */                     Integer index = Integer.valueOf(SPTBatch_.this.displayer.getImp().getStackIndex(channel.intValue(), slice.intValue(), i1));
> /* 3285 */                     stack.addSlice(SPTBatch_.this.displayer.getImp().getImageStack().getSliceLabel(index.intValue()), (ImageProcessor)cp);
> /*      */                   } 
> /* 3287 */                   SPTBatch_.this.displayer.getImp().getCanvas().hideZoomIndicator(false);
> /* 3288 */                   SPTBatch_.this.capture = new ImagePlus("TrackMate capture of " + SPTBatch_.this.displayer.getImp().getShortTitle(), 
> /* 3289 */                       stack);
> /*      */                   
> /* 3291 */                   SPTBatch_.transferCalibration(SPTBatch_.this.displayer.getImp(), SPTBatch_.this.capture);
> /* 3292 */                   IJ.saveAs(SPTBatch_.this.capture, "Tiff", String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + SPTBatch_.this.imageTitles[SPTBatch_.i]);
> /*      */                 } 
> /*      */               } 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */               
> /* 3300 */               if (SPTBatch_.checkbox3.isSelected() == Boolean.TRUE.booleanValue()) {
> /*      */                 try {
> /* 3302 */                   FileWriter writer = new FileWriter(String.valueOf(SPTBatch_.directSPT.getAbsolutePath()) + File.separator + "Log" + 
> /* 3303 */                       "_" + SPTBatch_.this.imageTitles[SPTBatch_.i].replaceAll("\\.tif+$", "") + ".txt");
> /* 3304 */                   SPTBatch_.taskOutput.write(writer);
> /* 3305 */                   writer.close();
> /* 3306 */                 } catch (IOException iOException) {}
> /*      */               }
> /*      */               
> /* 3309 */               SPTBatch_.imps.hide();
> /*      */             } 
> /* 3311 */             if (SPTBatch_.this.enableTrackTable.equals("trackTable")) {
> /* 3312 */               Thread trackSummary = new Thread(new Runnable() {
> /*      */                     public void run() {
> /* 3314 */                       String[][] rowDataDef = new String[4][(SPTBatch_.null.access$8(SPTBatch_.null.this)).columnsMovements.length];
> /* 3315 */                       rowDataDef[0][0] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).totalTracksDef);
> /* 3316 */                       rowDataDef[1][0] = String.valueOf("");
> /* 3317 */                       rowDataDef[2][0] = String.valueOf("");
> /* 3318 */                       rowDataDef[3][0] = String.valueOf("");
> /* 3319 */                       rowDataDef[0][1] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).longTracksDef);
> /* 3320 */                       rowDataDef[1][1] = String.valueOf(" ");
> /* 3321 */                       rowDataDef[2][1] = String.valueOf("Short Tracks");
> /* 3322 */                       rowDataDef[3][1] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).shortTracksDef);
> /* 3323 */                       rowDataDef[0][2] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).longConfinedDef);
> /* 3324 */                       rowDataDef[1][2] = String.valueOf(" ");
> /* 3325 */                       rowDataDef[2][2] = String.valueOf("Short Confined");
> /* 3326 */                       rowDataDef[3][2] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).shortConfinedDef);
> /* 3327 */                       rowDataDef[0][3] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).longUniBalDef);
> /* 3328 */                       rowDataDef[1][3] = String.valueOf(" ");
> /* 3329 */                       rowDataDef[2][3] = String.valueOf("Short Anomalous");
> /* 3330 */                       rowDataDef[3][3] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).shortAnomDef);
> /* 3331 */                       rowDataDef[0][4] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).longFreeDef);
> /* 3332 */                       rowDataDef[1][4] = String.valueOf(" ");
> /* 3333 */                       rowDataDef[2][4] = String.valueOf("Short Free");
> /* 3334 */                       rowDataDef[3][4] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).shortFreeDef);
> /* 3335 */                       rowDataDef[0][5] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).longDirectDef);
> /* 3336 */                       rowDataDef[1][5] = String.valueOf(" ");
> /* 3337 */                       rowDataDef[2][5] = String.valueOf("Short Direct");
> /* 3338 */                       rowDataDef[3][5] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).shortDirectDef);
> /* 3339 */                       rowDataDef[0][6] = String.valueOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).immobDef);
> /* 3340 */                       rowDataDef[1][6] = String.valueOf("");
> /* 3341 */                       rowDataDef[2][6] = String.valueOf("");
> /* 3342 */                       rowDataDef[3][6] = String.valueOf("");
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */                       
> /* 3354 */                       ResultsTable rtTrackSummary = new ResultsTable();
> /* 3355 */                       for (int r = 0; r < rowDataDef.length; r++) {
> /* 3356 */                         for (int c = 0; c < (rowDataDef[r]).length; c++)
> /* 3357 */                           rtTrackSummary.setValue((SPTBatch_.null.access$8(SPTBatch_.null.this)).columnsMovements[c], r, rowDataDef[r][c]); 
> /*      */                       } 
> /*      */                       try {
> /* 3360 */                         rtTrackSummary.saveAs(String.valueOf(SPTBatch_.directSummary.getAbsolutePath()) + File.separator + 
> /* 3361 */                             "SummaryTracks_Condition" + ".csv");
> /* 3362 */                       } catch (IOException e) {
> /*      */                         
> /* 3364 */                         e.printStackTrace();
> /*      */                       } 
> /*      */                     }
> /*      */                   });
> /* 3368 */               trackSummary.start();
> /*      */             } 
> /* 3370 */             if (SPTBatch_.checkSummary.isSelected()) {
> /* 3371 */               Thread trackSummaryCols = new Thread(new Runnable() {
> /*      */                     public void run() {
> /* 3373 */                       for (int x = 0; x < (SPTBatch_.null.access$8(SPTBatch_.null.this)).selectedItems.size(); x++) {
> /* 3374 */                         if (summaryColsWindow.combo.getSelectedIndex() == 0) {
> /* 3375 */                           ResultsTable rtSpotSum = new ResultsTable();
> /* 3376 */                           for (int y = 0; y < (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtSpots.length; y++) {
> /* 3377 */                             for (int z = 0; z < (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtSpots[y].size(); z++)
> /* 3378 */                               rtSpotSum.setValue(listOfFiles[y].getName(), z, 
> /* 3379 */                                   (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtSpots[y].getStringValue(
> /* 3380 */                                     Arrays.<String>asList(summaryColsWindow.columnNamesSpot)
> /* 3381 */                                     .indexOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).selectedItems.get(x)), 
> /* 3382 */                                     z)); 
> /*      */                           }  try {
> /* 3384 */                             rtSpotSum.saveAs(String.valueOf(SPTBatch_.directSummary.getAbsolutePath()) + File.separator + 
> /* 3385 */                                 (String)(SPTBatch_.null.access$8(SPTBatch_.null.this)).selectedItems.get(x) + "_" + "SummaryCols_Spots" + ".csv");
> /* 3386 */                           } catch (IOException e1) {
> /*      */                             
> /* 3388 */                             e1.printStackTrace();
> /*      */                           } 
> /*      */                         } 
> /* 3391 */                         if (summaryColsWindow.combo.getSelectedIndex() == 1) {
> /* 3392 */                           ResultsTable rtLinkSum = new ResultsTable();
> /* 3393 */                           for (int y = 0; y < (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtLinks.length; y++) {
> /* 3394 */                             for (int z = 0; z < (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtLinks[y].size(); z++)
> /* 3395 */                               rtLinkSum.setValue(listOfFiles[y].getName(), z, 
> /* 3396 */                                   (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtLinks[y].getStringValue(
> /* 3397 */                                     Arrays.<String>asList(summaryColsWindow.columnNamesLinks)
> /* 3398 */                                     .indexOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).selectedItems.get(x)), 
> /* 3399 */                                     z)); 
> /*      */                           }  try {
> /* 3401 */                             rtLinkSum.saveAs(String.valueOf(SPTBatch_.directSummary.getAbsolutePath()) + File.separator + 
> /* 3402 */                                 (String)(SPTBatch_.null.access$8(SPTBatch_.null.this)).selectedItems.get(x) + "_" + "SummaryCols_Links" + ".csv");
> /* 3403 */                           } catch (IOException e1) {
> /*      */                             
> /* 3405 */                             e1.printStackTrace();
> /*      */                           } 
> /*      */                         } 
> /* 3408 */                         if (summaryColsWindow.combo.getSelectedIndex() == 2) {
> /* 3409 */                           ResultsTable rtTrackSum = new ResultsTable();
> /* 3410 */                           for (int y = 0; y < (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTracks.length; y++) {
> /* 3411 */                             for (int z = 0; z < (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTracks[y].size(); z++)
> /* 3412 */                               rtTrackSum.setValue(listOfFiles[y].getName(), z, 
> /* 3413 */                                   (SPTBatch_.null.access$8(SPTBatch_.null.this)).rtTracks[y].getStringValue(
> /* 3414 */                                     Arrays.<String>asList(summaryColsWindow.columnNamesTracks)
> /* 3415 */                                     .indexOf((SPTBatch_.null.access$8(SPTBatch_.null.this)).selectedItems.get(x)), 
> /* 3416 */                                     z)); 
> /*      */                           }  try {
> /* 3418 */                             rtTrackSum.saveAs(String.valueOf(SPTBatch_.directSummary.getAbsolutePath()) + File.separator + 
> /* 3419 */                                 (String)(SPTBatch_.null.access$8(SPTBatch_.null.this)).selectedItems.get(x) + "_" + "SummaryCols_Tracks" + ".csv");
> /* 3420 */                           } catch (IOException e1) {
> /*      */                             
> /* 3422 */                             e1.printStackTrace();
> /*      */                           } 
> /*      */                         } 
> /*      */                       } 
> /*      */                     }
> /*      */                   });
> /*      */ 
> /*      */               
> /* 3430 */               trackSummaryCols.start();
> /*      */             } 
> /*      */             
> /* 3433 */             SPTBatch_.this.enableSpotTable.equals("spotTable");
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */             
> /* 3444 */             SPTBatch_.this.enableLinkTable.equals("linkTable");
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */             
> /* 3455 */             SPTBatch_.this.enableTrackTable.equals("trackTable");
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */             
> /* 3468 */             SPTBatch_.taskOutput.append("              FINISHED!!!");
> /* 3469 */             frameAnalyzer.setVisible(false);
> /*      */           }
> /*      */         });
> /*      */ 
> /*      */ 
> /*      */     
> /* 3475 */     this.finishButton.addActionListener(new ActionListener()
> /*      */         {
> /*      */           public void actionPerformed(ActionEvent event) {
> /* 3478 */             if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 3479 */               SPTBatch_.minTracksJTF = Integer.valueOf(SPTBatch_.minTracks.getText()).intValue();
> /* 3480 */               SPTBatch_.maxTracksJTF = Integer.valueOf(SPTBatch_.maxTracks.getText()).intValue();
> /* 3481 */               SPTBatch_.thLengthJTF = Integer.valueOf(SPTBatch_.thLength.getText()).intValue();
> /* 3482 */               if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "DIff") {
> /* 3483 */                 SPTBatch_.this.thD14JTF = Double.valueOf(SPTBatch_.thD14.getText()).doubleValue();
> /*      */               }
> /*      */             } 
> /* 3486 */             SPTBatch_.mainProcess.start();
> /*      */           }
> /*      */         });
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   private static final void transferCalibration(ImagePlus from, ImagePlus to) {
> /* 3494 */     Calibration fc = from.getCalibration();
> /* 3495 */     Calibration tc = to.getCalibration();
> /*      */     
> /* 3497 */     tc.setUnit(fc.getUnit());
> /* 3498 */     tc.setTimeUnit(fc.getTimeUnit());
> /* 3499 */     tc.frameInterval = fc.frameInterval;
> /*      */     
> /* 3501 */     double mag = from.getCanvas().getMagnification();
> /* 3502 */     fc.pixelWidth /= mag;
> /* 3503 */     fc.pixelHeight /= mag;
> /* 3504 */     tc.pixelDepth = fc.pixelDepth;
> /*      */   }
> /*      */   
> /*      */   class LabelWizardPanel extends JWizardPanel {
> /*      */     public LabelWizardPanel(JWizardComponents wizardComponents, String label) {
> /* 3509 */       super(wizardComponents);
> /* 3510 */       SPTBatch_.this.backButton = wizardComponents.getBackButton();
> /* 3511 */       SPTBatch_.this.backButton.setText("");
> /* 3512 */       ImageIcon iconBack = SPTBatch_.this.createImageIcon("img_71224.png");
> /* 3513 */       Icon iconBackCell = new ImageIcon(iconBack.getImage().getScaledInstance(12, 12, 4));
> /* 3514 */       SPTBatch_.this.backButton.setIcon(iconBackCell);
> /* 3515 */       SPTBatch_.this.backButton.setToolTipText("Click chemotool button to back the previous wizard.");
> /*      */       
> /* 3517 */       SPTBatch_.this.nextButton = wizardComponents.getNextButton();
> /* 3518 */       SPTBatch_.this.nextButton.setText("");
> /* 3519 */       ImageIcon iconNext = SPTBatch_.this.createImageIcon("img_174455.png");
> /* 3520 */       Icon iconNextCell = new ImageIcon(iconNext.getImage().getScaledInstance(12, 12, 4));
> /* 3521 */       SPTBatch_.this.nextButton.setIcon(iconNextCell);
> /* 3522 */       SPTBatch_.this.nextButton.setToolTipText("Click chemotool button to go to the next wizard.");
> /*      */       
> /* 3524 */       SPTBatch_.this.finishButton = wizardComponents.getFinishButton();
> /* 3525 */       SPTBatch_.this.finishButton.setText("");
> /* 3526 */       ImageIcon iconFinish = SPTBatch_.this.createImageIcon("ojala.png");
> /* 3527 */       Icon iconFinishCell = new ImageIcon(iconFinish.getImage().getScaledInstance(12, 12, 4));
> /* 3528 */       SPTBatch_.this.finishButton.setIcon(iconFinishCell);
> /* 3529 */       SPTBatch_.this.finishButton.setToolTipText("Click chemotool button to finish your settings selection.");
> /*      */       
> /* 3531 */       JButton cancelButton = wizardComponents.getCancelButton();
> /* 3532 */       cancelButton.setText("");
> /* 3533 */       ImageIcon iconCancel = SPTBatch_.this.createImageIcon("delete.png");
> /* 3534 */       Icon iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(12, 12, 4));
> /* 3535 */       cancelButton.setIcon(iconCancelCell);
> /* 3536 */       cancelButton.setToolTipText("Click chemotool button to cancel chemotool process.");
> /*      */       
> /* 3538 */       setLayout(new GridBagLayout());
> /* 3539 */       add(new JLabel(label), new GridBagConstraints(0, 0, 1, 1, 0.0D, 0.0D, 10, 
> /* 3540 */             1, new Insets(0, 0, 0, 0), 0, 0));
> /* 3541 */       final TextField textXML = new TextField(20);
> /*      */       
> /* 3543 */       textXML.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_TRANSF_PATH, ""));
> /* 3544 */       GridBagLayout layoutXML = (GridBagLayout)getLayout();
> /* 3545 */       GridBagConstraints constraintsXML = layoutXML.getConstraints(textXML);
> /* 3546 */       JButton buttonXML = new JButton("");
> /* 3547 */       ImageIcon iconXML = SPTBatch_.this.createImageIcon("browse.png");
> /* 3548 */       Icon iconXMLCell = new ImageIcon(iconXML.getImage().getScaledInstance(15, 15, 4));
> /* 3549 */       buttonXML.setIcon(iconXMLCell);
> /* 3550 */       ImageIcon iconBrowse = SPTBatch_.this.createImageIcon("browse.png");
> /* 3551 */       Icon iconBrowseCell = new ImageIcon(iconBrowse.getImage().getScaledInstance(15, 15, 4));
> /* 3552 */       buttonXML.setIcon(iconBrowseCell);
> /* 3553 */       DirectoryListener listenerXML = new DirectoryListener("Browse for " + label, textXML, 
> /* 3554 */           2);
> /* 3555 */       buttonXML.addActionListener(listenerXML);
> /* 3556 */       Panel panelXML = new Panel();
> /* 3557 */       panelXML.setLayout(new FlowLayout(0));
> /* 3558 */       JLabel loadLabel = new JLabel("  Load TrackMate .XML file: ");
> /* 3559 */       loadLabel.setFont(new Font("Verdana", 1, 12));
> /* 3560 */       panelXML.add(loadLabel);
> /* 3561 */       panelXML.add(textXML);
> /* 3562 */       panelXML.add(buttonXML);
> /* 3563 */       layoutXML.setConstraints(panelXML, constraintsXML);
> /* 3564 */       final TextField textImg = new TextField(20);
> /*      */       
> /* 3566 */       textImg.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_IMAGES_PATH, ""));
> /* 3567 */       GridBagLayout layoutImg = (GridBagLayout)getLayout();
> /* 3568 */       GridBagConstraints constraintsImg = layoutImg.getConstraints(textImg);
> /* 3569 */       JButton buttonImg = new JButton("");
> /* 3570 */       ImageIcon iconIM = SPTBatch_.this.createImageIcon("browse.png");
> /* 3571 */       Icon iconIMCell = new ImageIcon(iconIM.getImage().getScaledInstance(15, 15, 4));
> /* 3572 */       buttonImg.setIcon(iconIMCell);
> /* 3573 */       ImageIcon iconB = SPTBatch_.this.createImageIcon("browse.png");
> /* 3574 */       Icon iconBCell = new ImageIcon(iconB.getImage().getScaledInstance(15, 15, 4));
> /* 3575 */       buttonImg.setIcon(iconBCell);
> /* 3576 */       DirectoryListener listenerImg = new DirectoryListener("Browse for " + label, textImg, 
> /* 3577 */           2);
> /* 3578 */       buttonImg.addActionListener(listenerImg);
> /* 3579 */       Panel panelImg = new Panel();
> /* 3580 */       panelImg.setLayout(new FlowLayout(0));
> /* 3581 */       JLabel directLabel = new JLabel("  Movie Files Directory:   ");
> /* 3582 */       directLabel.setFont(new Font("Verdana", 1, 12));
> /* 3583 */       panelImg.add(directLabel);
> /* 3584 */       panelImg.add(textImg);
> /* 3585 */       panelImg.add(buttonImg);
> /* 3586 */       layoutImg.setConstraints(panelImg, constraintsImg);
> /* 3587 */       JPanel mainPanel = new JPanel();
> /* 3588 */       mainPanel.setLayout(new BoxLayout(mainPanel, 1));
> /* 3589 */       mainPanel.add(Box.createVerticalStrut(15));
> /* 3590 */       mainPanel.add(panelXML);
> /* 3591 */       mainPanel.add(Box.createVerticalStrut(20));
> /* 3592 */       mainPanel.add(panelImg);
> /* 3593 */       mainPanel.add(Box.createVerticalStrut(15));
> /* 3594 */       mainPanel.setBorder(BorderFactory.createTitledBorder(""));
> /* 3595 */       add(mainPanel);
> /* 3596 */       setPanelTitle("");
> /* 3597 */       SPTBatch_.this.nextButton.addActionListener(new ActionListener() {
> /*      */             public void actionPerformed(ActionEvent event) {
> /* 3599 */               SPTBatch_.pref1.put((SPTBatch_.LabelWizardPanel.access$0(SPTBatch_.LabelWizardPanel.this)).TRACKMATE_TRANSF_PATH, textXML.getText());
> /* 3600 */               SPTBatch_.pref1.put((SPTBatch_.LabelWizardPanel.access$0(SPTBatch_.LabelWizardPanel.this)).TRACKMATE_IMAGES_PATH, textImg.getText());
> /* 3601 */               SPTBatch_.pref1.put((SPTBatch_.LabelWizardPanel.access$0(SPTBatch_.LabelWizardPanel.this)).TRACKMATE_MIN_SPOT, SPTBatch_.minTracks.getText());
> /* 3602 */               SPTBatch_.pref1.put((SPTBatch_.LabelWizardPanel.access$0(SPTBatch_.LabelWizardPanel.this)).TRACKMATE_MAX_SPOT, SPTBatch_.maxTracks.getText());
> /* 3603 */               SPTBatch_.pref1.put((SPTBatch_.LabelWizardPanel.access$0(SPTBatch_.LabelWizardPanel.this)).TRACKMATE_LENGTH_TH, SPTBatch_.thLength.getText());
> /* 3604 */               SPTBatch_.pref1.put((SPTBatch_.LabelWizardPanel.access$0(SPTBatch_.LabelWizardPanel.this)).TRACKMATE_DIFF_TH, SPTBatch_.thD14.getText());
> /*      */ 
> /*      */ 
> /*      */               
> /* 3608 */               if (SPTBatch_.checkboxDiff.isSelected()) {
> /* 3609 */                 SPTBatch_.pref1.put(SPTBatch_.TRACKMATE_MIN_TRACK, traJParametersWindow.minLengthText.getText());
> /* 3610 */                 SPTBatch_.pref1.put(SPTBatch_.TRACKMATE_WINDOW, traJParametersWindow.windowText.getText());
> /* 3611 */                 SPTBatch_.pref1.put(SPTBatch_.TRACKMATE_MIN_SEGMENT, traJParametersWindow.minSegText.getText());
> /*      */               } 
> /*      */             }
> /*      */           });
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   class FirstWizardPanel
> /*      */     extends LabelWizardPanel
> /*      */   {
> /*      */     public FirstWizardPanel(JWizardComponents wizardComponents) {
> /* 3623 */       super(wizardComponents, "");
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   class ChooserWizardPanel
> /*      */     extends JWizardPanel
> /*      */   {
> /*      */     private ButtonGroup bg;
> /*      */ 
> /*      */     
> /*      */     public ChooserWizardPanel(JWizardComponents wizardComponents) {
> /* 3635 */       super(wizardComponents, "");
> /* 3636 */       init();
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     private void init() {
> /* 3646 */       setLayout(new GridBagLayout());
> /*      */       
> /* 3648 */       CheckableItem[] items = { new CheckableItem("Spots", true), new CheckableItem("Links", true), 
> /* 3649 */           new CheckableItem("Tracks", true), new CheckableItem("Branch Analysis", true) };
> /*      */       
> /* 3651 */       SPTBatch_.checkbox1 = new JCheckBox("  Analysis/Statistics Results. ");
> /* 3652 */       SPTBatch_.checkbox1.setSelected(true);
> /* 3653 */       SPTBatch_.checkboxDiff = new JCheckBox("  TraJ: Trajectory Classifier. ");
> /* 3654 */       SPTBatch_.checkboxDiff.setSelected(true);
> /* 3655 */       SPTBatch_.this.trajButton = new JButton("Tune Parameters");
> /* 3656 */       SPTBatch_.checkboxSubBg = new JCheckBox(" Subtract Background :  ");
> /* 3657 */       SPTBatch_.checkboxSubBg.setSelected(false);
> /* 3658 */       SPTBatch_.checkExcludeTracks = new JCheckBox(" Exclude tracks outside cell  ");
> /* 3659 */       SPTBatch_.checkExcludeTracks.setSelected(false);
> /* 3660 */       SPTBatch_.checkPBS = new JCheckBox("Photobleaching step Analysis.");
> /* 3661 */       SPTBatch_.checkPBS.setSelected(true);
> /* 3662 */       SPTBatch_.checkSummary = new JCheckBox("");
> /* 3663 */       SPTBatch_.checkSummary.setSelected(true);
> /* 3664 */       SPTBatch_.this.summaryButton = new JButton("Summary Outputs");
> /* 3665 */       JPanel summPanel = new JPanel(new FlowLayout(0));
> /* 3666 */       summPanel.add(SPTBatch_.checkSummary);
> /* 3667 */       summPanel.add(SPTBatch_.this.summaryButton);
> /* 3668 */       JPanel panelPBS = new JPanel(new FlowLayout(0));
> /* 3669 */       panelPBS.add(SPTBatch_.checkPBS);
> /* 3670 */       SPTBatch_.this.comboSubBg = new JComboBox();
> /* 3671 */       SPTBatch_.this.comboSubBg = new JComboBox();
> /* 3672 */       SPTBatch_.this.comboSubBg.addItem("Subtract Bg 1");
> /* 3673 */       SPTBatch_.this.comboSubBg.addItem("Subtract Bg 2");
> /* 3674 */       SPTBatch_.this.comboSubBg.addItem("Subtract Bg 3");
> /* 3675 */       SPTBatch_.this.comboSubBg.addItem("Subtract Bg 4");
> /* 3676 */       SPTBatch_.this.comboSubBg.addItem("Subtract Bg 5");
> /* 3677 */       SPTBatch_.this.comboSubBg.setEnabled(false);
> /* 3678 */       SPTBatch_.checkboxMSD = new JCheckBox("  MSD and MSS Plots ");
> /* 3679 */       SPTBatch_.checkboxMSD.setSelected(true);
> /* 3680 */       SPTBatch_.checkCluster = new JCheckBox(" Cluster Size Analysis ");
> /* 3681 */       SPTBatch_.checkCluster.setSelected(true);
> /* 3682 */       SPTBatch_.checkMonomer = new JCheckBox(" Monomeric Protein Intensity ");
> /* 3683 */       SPTBatch_.checkMonomer.setSelected(true);
> /* 3684 */       SPTBatch_.checkbox2 = new JCheckBox();
> /* 3685 */       SPTBatch_.checkbox2.setText(" Tracks to .XML file ");
> /* 3686 */       SPTBatch_.checkbox2.setSelected(true);
> /* 3687 */       SPTBatch_.checkbox3 = new JCheckBox();
> /* 3688 */       SPTBatch_.checkbox3.setText("  Log to .TXT file ");
> /* 3689 */       SPTBatch_.checkbox3.setSelected(true);
> /* 3690 */       SPTBatch_.checkbox4 = new JCheckBox();
> /* 3691 */       SPTBatch_.checkbox4.setText("  Track-Overlays as .TIF images");
> /* 3692 */       SPTBatch_.checkbox4.setSelected(true);
> /* 3693 */       SPTBatch_.checkboxRoi = new JCheckBox();
> /* 3694 */       SPTBatch_.checkboxRoi.setText("  Track-Rois as RoiSet.zip");
> /* 3695 */       SPTBatch_.checkboxRoi.setSelected(true);
> /* 3696 */       SPTBatch_.checkboxPlot = new JCheckBox();
> /* 3697 */       SPTBatch_.checkboxPlot.setText("  Plots as .PNG file");
> /* 3698 */       SPTBatch_.checkboxPlot.setSelected(true);
> /* 3699 */       SPTBatch_.checkboxSP = new JCheckBox();
> /* 3700 */       SPTBatch_.checkboxSP.setText("  Chemotaxis Analysis Data");
> /* 3701 */       SPTBatch_.checkboxSP.setSelected(true);
> /* 3702 */       SPTBatch_.chemoScaling = new JTextField("Set Axis Scaling...");
> /* 3703 */       SPTBatch_.chemoScaling.setEnabled(true);
> /* 3704 */       SPTBatch_.monomerField = new JTextField("value...");
> /* 3705 */       SPTBatch_.monomerField.setEnabled(true);
> /*      */ 
> /*      */ 
> /*      */       
> /* 3709 */       SPTBatch_.this.comboP = new CheckedComboBox(new DefaultComboBoxModel<>(items));
> /* 3710 */       SPTBatch_.this.comboP.setOpaque(true);
> /* 3711 */       SPTBatch_.this.comboP.setToolTipText("Select an analysis for export csv file");
> /* 3712 */       SPTBatch_.this.comboP.setSelectedItem(items[0]);
> /*      */       
> /* 3714 */       if (items[0].isSelected())
> /* 3715 */         SPTBatch_.this.enableSpotTable = "spotTable"; 
> /* 3716 */       if (items[1].isSelected())
> /* 3717 */         SPTBatch_.this.enableLinkTable = "linkTable"; 
> /* 3718 */       if (items[2].isSelected())
> /* 3719 */         SPTBatch_.this.enableTrackTable = "trackTable"; 
> /* 3720 */       if (items[3].isSelected()) {
> /* 3721 */         SPTBatch_.this.enableBranchTable = "branchTable";
> /*      */       }
> /* 3723 */       removeAll();
> /* 3724 */       final TextField textCsv = new TextField(20);
> /* 3725 */       textCsv.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_CSV_PATH, ""));
> /* 3726 */       SPTBatch_.csvPath = textCsv.getText();
> /*      */       
> /* 3728 */       GridBagLayout layoutCsv = (GridBagLayout)getLayout();
> /* 3729 */       GridBagConstraints constraintsCsv = layoutCsv.getConstraints(textCsv);
> /* 3730 */       SPTBatch_.this.buttonCsv = new JButton("");
> /* 3731 */       ImageIcon iconCsv = SPTBatch_.this.createImageIcon("browse.png");
> /* 3732 */       Icon iconCsvCell = new ImageIcon(iconCsv.getImage().getScaledInstance(15, 15, 4));
> /* 3733 */       SPTBatch_.this.buttonCsv.setIcon(iconCsvCell);
> /* 3734 */       DirectoryListener listenerCsv = new DirectoryListener("Browse for ", textCsv, 
> /* 3735 */           2);
> /* 3736 */       SPTBatch_.this.buttonCsv.addActionListener(listenerCsv);
> /*      */       
> /* 3738 */       final Panel panelCsv = new Panel();
> /* 3739 */       panelCsv.setLayout(new FlowLayout(0, 0, 0));
> /* 3740 */       layoutCsv.setConstraints(panelCsv, constraintsCsv);
> /* 3741 */       panelCsv.add(SPTBatch_.checkbox1);
> /* 3742 */       panelCsv.add((Component)SPTBatch_.this.comboP);
> /*      */       
> /* 3744 */       JPanel panelBox = new JPanel();
> /* 3745 */       JPanel panelOptions = new JPanel(new FlowLayout(0));
> /* 3746 */       JPanel panelOptions1 = new JPanel(new FlowLayout(0));
> /* 3747 */       panelOptions.add(Box.createHorizontalStrut(35));
> /* 3748 */       panelOptions1.add(Box.createHorizontalStrut(35));
> /* 3749 */       panelBox.setLayout(new BoxLayout(panelBox, 1));
> /*      */       
> /* 3751 */       SPTBatch_.checkTracks = new JCheckBox("Spot Range in Track: ");
> /* 3752 */       SPTBatch_.checkTracks.setSelected(false);
> /* 3753 */       SPTBatch_.minTracks = new JTextField("Min", 3);
> /* 3754 */       SPTBatch_.minTracks.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_MIN_SPOT, ""));
> /* 3755 */       SPTBatch_.minTracks.setEnabled(false);
> /* 3756 */       SPTBatch_.maxTracks = new JTextField("Max", 3);
> /* 3757 */       SPTBatch_.maxTracks.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_MAX_SPOT, ""));
> /* 3758 */       SPTBatch_.maxTracks.setEnabled(false);
> /* 3759 */       panelOptions1.add(SPTBatch_.checkTracks);
> /* 3760 */       panelOptions1.add(SPTBatch_.minTracks);
> /* 3761 */       panelOptions1.add(new JLabel("-"));
> /* 3762 */       panelOptions1.add(SPTBatch_.maxTracks);
> /* 3763 */       SPTBatch_.checkDispSpots = new JCheckBox("Spots Visible ");
> /* 3764 */       SPTBatch_.checkDispSpots.setSelected(true);
> /* 3765 */       SPTBatch_.checkDispSpotName = new JCheckBox("Spots Name Visible ");
> /* 3766 */       SPTBatch_.checkDispSpotName.setSelected(true);
> /* 3767 */       SPTBatch_.checkDispTracks = new JCheckBox("Tracks Visible: ");
> /* 3768 */       SPTBatch_.checkDispTracks.setSelected(true);
> /* 3769 */       SPTBatch_.this.comboDispTracks = new JComboBox();
> /* 3770 */       SPTBatch_.this.comboDispTracks.addItem("FULL");
> /* 3771 */       SPTBatch_.this.comboDispTracks.addItem("LOCAL");
> /* 3772 */       SPTBatch_.this.comboDispTracks.addItem("LOCAL_BACKWARD");
> /* 3773 */       SPTBatch_.this.comboDispTracks.addItem("LOCAL_FORWARD");
> /* 3774 */       SPTBatch_.this.comboDispTracks.setSelectedIndex(0);
> /* 3775 */       JPanel panelSpotTrackDisp = new JPanel(new FlowLayout(0));
> /* 3776 */       panelSpotTrackDisp.add(SPTBatch_.checkDispSpots);
> /* 3777 */       panelSpotTrackDisp.add(SPTBatch_.checkDispSpotName);
> /* 3778 */       panelSpotTrackDisp.add(SPTBatch_.checkDispTracks);
> /* 3779 */       panelSpotTrackDisp.add(SPTBatch_.this.comboDispTracks);
> /* 3780 */       JLabel thLengthLabel = new JLabel("-Length Threshold: ");
> /* 3781 */       SPTBatch_.thLength = new JTextField("Length", 3);
> /* 3782 */       SPTBatch_.thLength.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_LENGTH_TH, ""));
> /* 3783 */       JLabel thD14Label = new JLabel("-Diff.Threshold: ");
> /* 3784 */       SPTBatch_.thD14 = new JTextField("Diff", 3);
> /* 3785 */       SPTBatch_.thD14.setText(SPTBatch_.pref1.get(SPTBatch_.this.TRACKMATE_DIFF_TH, ""));
> /* 3786 */       JPanel panelLengthD14 = new JPanel(new FlowLayout(0));
> /* 3787 */       panelLengthD14.add(thLengthLabel);
> /* 3788 */       panelLengthD14.add(SPTBatch_.thLength);
> /* 3789 */       panelLengthD14.add(thD14Label);
> /* 3790 */       panelLengthD14.add(SPTBatch_.thD14);
> /* 3791 */       JPanel panelSubBg = new JPanel(new FlowLayout(0, 0, 0));
> /* 3792 */       panelSubBg.add(SPTBatch_.checkboxSubBg);
> /* 3793 */       panelSubBg.add(SPTBatch_.this.comboSubBg);
> /* 3794 */       panelSubBg.add(SPTBatch_.checkExcludeTracks);
> /*      */       
> /* 3796 */       panelBox.add(panelOptions);
> /* 3797 */       panelBox.add(Box.createVerticalStrut(3));
> /* 3798 */       panelBox.add(panelOptions1);
> /* 3799 */       panelBox.add(Box.createVerticalStrut(3));
> /* 3800 */       panelBox.add(panelLengthD14);
> /* 3801 */       panelBox.add(Box.createVerticalStrut(3));
> /* 3802 */       panelBox.add(panelSpotTrackDisp);
> /* 3803 */       panelBox.add(Box.createVerticalStrut(3));
> /* 3804 */       panelBox.add(panelPBS);
> /* 3805 */       panelBox.add(Box.createVerticalStrut(3));
> /* 3806 */       panelBox.add(panelSubBg);
> /* 3807 */       panelBox.add(Box.createVerticalStrut(3));
> /* 3808 */       panelBox.add(summPanel);
> /* 3809 */       Panel panelOut = new Panel();
> /* 3810 */       panelOut.setLayout(new FlowLayout(0, 0, 0));
> /* 3811 */       panelOut.add(SPTBatch_.checkbox4);
> /* 3812 */       GridBagLayout layoutXMLL = (GridBagLayout)getLayout();
> /*      */       
> /* 3814 */       Panel panelXMLL = new Panel();
> /* 3815 */       panelXMLL.setLayout(new FlowLayout(0, 0, 0));
> /* 3816 */       panelXMLL.add(SPTBatch_.checkbox2);
> /* 3817 */       GridBagLayout layoutTxt = (GridBagLayout)getLayout();
> /* 3818 */       Panel panelTxt = new Panel();
> /* 3819 */       panelTxt.setLayout(new FlowLayout(0, 0, 0));
> /* 3820 */       panelTxt.add(SPTBatch_.checkbox3);
> /* 3821 */       final JPanel panelExport = new JPanel();
> /* 3822 */       JLabel labelExport = new JLabel();
> /* 3823 */       labelExport.setText(" Choose a directory to export files:    ");
> /* 3824 */       labelExport.setFont(new Font("Verdana", 1, 12));
> /* 3825 */       panelExport.setLayout(new FlowLayout(0, 0, 0));
> /* 3826 */       panelExport.add(labelExport);
> /* 3827 */       panelExport.add(textCsv);
> /* 3828 */       panelExport.add(SPTBatch_.this.buttonCsv);
> /* 3829 */       JPanel panelDiff = new JPanel(new FlowLayout(0, 0, 0));
> /* 3830 */       panelDiff.add(SPTBatch_.checkboxDiff);
> /* 3831 */       panelDiff.add(SPTBatch_.this.trajButton);
> /* 3832 */       JPanel panelMSD = new JPanel(new FlowLayout(0, 0, 0));
> /* 3833 */       panelMSD.add(SPTBatch_.checkboxMSD);
> /* 3834 */       JPanel panelCluster = new JPanel(new FlowLayout(0, 0, 0));
> /* 3835 */       panelCluster.add(SPTBatch_.checkCluster);
> /* 3836 */       panelCluster.add(SPTBatch_.checkMonomer);
> /* 3837 */       panelCluster.add(SPTBatch_.monomerField);
> /* 3838 */       JPanel panelExport2 = new JPanel(new BorderLayout());
> /* 3839 */       panelExport2.add(panelExport, "East");
> /* 3840 */       Panel panelRoi = new Panel();
> /* 3841 */       panelRoi.setLayout(new FlowLayout(0, 0, 0));
> /* 3842 */       panelRoi.add(SPTBatch_.checkboxRoi);
> /* 3843 */       Panel panelPlot = new Panel();
> /* 3844 */       panelPlot.setLayout(new FlowLayout(0, 0, 0));
> /* 3845 */       panelPlot.add(SPTBatch_.checkboxPlot);
> /* 3846 */       Panel panelSP = new Panel();
> /* 3847 */       panelSP.setLayout(new FlowLayout(0, 0, 0));
> /* 3848 */       panelSP.add(SPTBatch_.checkboxSP);
> /* 3849 */       panelSP.add(SPTBatch_.chemoScaling);
> /*      */       
> /* 3851 */       JLabel labelExport1 = new JLabel("   Tuneable Options: ");
> /* 3852 */       labelExport1.setFont(new Font("Verdana", 1, 12));
> /* 3853 */       JPanel panelExport1 = new JPanel(new FlowLayout(0));
> /* 3854 */       panelExport1.add(labelExport1);
> /* 3855 */       JPanel mainPanel2 = new JPanel();
> /* 3856 */       mainPanel2.setBorder(BorderFactory.createTitledBorder(""));
> /* 3857 */       mainPanel2.setLayout(new BoxLayout(mainPanel2, 1));
> /*      */       
> /* 3859 */       mainPanel2.add(Box.createVerticalStrut(3));
> /* 3860 */       mainPanel2.add(new JSeparator(0));
> /* 3861 */       mainPanel2.add(panelExport1);
> /* 3862 */       mainPanel2.add(new JSeparator(0));
> /* 3863 */       mainPanel2.add(Box.createVerticalStrut(8));
> /* 3864 */       mainPanel2.add(panelCsv);
> /* 3865 */       mainPanel2.add(Box.createVerticalStrut(5));
> /* 3866 */       mainPanel2.add(Box.createHorizontalStrut(15));
> /* 3867 */       mainPanel2.add(panelBox);
> /* 3868 */       mainPanel2.add(Box.createVerticalStrut(5));
> /* 3869 */       mainPanel2.add(panelDiff);
> /* 3870 */       mainPanel2.add(Box.createVerticalStrut(5));
> /* 3871 */       mainPanel2.add(panelMSD);
> /* 3872 */       mainPanel2.add(Box.createVerticalStrut(5));
> /* 3873 */       mainPanel2.add(panelCluster);
> /* 3874 */       mainPanel2.add(Box.createVerticalStrut(5));
> /* 3875 */       mainPanel2.add(panelXMLL);
> /* 3876 */       mainPanel2.add(Box.createVerticalStrut(5));
> /* 3877 */       mainPanel2.add(panelTxt);
> /* 3878 */       mainPanel2.add(Box.createVerticalStrut(5));
> /* 3879 */       mainPanel2.add(panelOut);
> /* 3880 */       mainPanel2.add(Box.createVerticalStrut(5));
> /* 3881 */       mainPanel2.add(panelRoi);
> /* 3882 */       mainPanel2.add(Box.createVerticalStrut(5));
> /* 3883 */       mainPanel2.add(panelPlot);
> /* 3884 */       mainPanel2.add(Box.createVerticalStrut(5));
> /* 3885 */       mainPanel2.add(panelSP);
> /* 3886 */       mainPanel2.add(Box.createVerticalStrut(15));
> /* 3887 */       mainPanel2.add(new JSeparator(0));
> /* 3888 */       mainPanel2.add(Box.createVerticalStrut(3));
> /* 3889 */       mainPanel2.add(panelExport2);
> /* 3890 */       mainPanel2.setBorder(BorderFactory.createTitledBorder(""));
> /* 3891 */       SPTBatch_.this.comboP.setEnabled(true);
> /* 3892 */       textCsv.setEnabled(true);
> /* 3893 */       SPTBatch_.this.buttonCsv.setEnabled(true);
> /* 3894 */       panelExport2.setEnabled(true);
> /* 3895 */       SPTBatch_.checkbox4.addItemListener(new ItemListener()
> /*      */           {
> /*      */             public void itemStateChanged(ItemEvent e) {
> /* 3898 */               if (e.getStateChange() == 1) {
> /* 3899 */                 SPTBatch_.checkExcludeTracks.setSelected(true);
> /*      */               }
> /*      */               
> /* 3902 */               if (e.getStateChange() == 2) {
> /* 3903 */                 SPTBatch_.checkExcludeTracks.setSelected(false);
> /*      */               }
> /*      */             }
> /*      */           });
> /* 3907 */       SPTBatch_.checkDispSpots.addItemListener(new ItemListener()
> /*      */           {
> /*      */             public void itemStateChanged(ItemEvent e) {
> /* 3910 */               if (e.getStateChange() == 1) {
> /* 3911 */                 SPTBatch_.checkDispSpotName.setSelected(true);
> /*      */               }
> /*      */               
> /* 3914 */               if (e.getStateChange() == 2) {
> /* 3915 */                 SPTBatch_.checkDispSpotName.setSelected(false);
> /*      */               }
> /*      */             }
> /*      */           });
> /* 3919 */       SPTBatch_.checkSummary.addItemListener(new ItemListener()
> /*      */           {
> /*      */             public void itemStateChanged(ItemEvent e) {
> /* 3922 */               if (e.getStateChange() == 1) {
> /* 3923 */                 (SPTBatch_.ChooserWizardPanel.access$0(SPTBatch_.ChooserWizardPanel.this)).summaryButton.setEnabled(true);
> /*      */               }
> /*      */ 
> /*      */               
> /* 3927 */               if (e.getStateChange() == 2) {
> /* 3928 */                 (SPTBatch_.ChooserWizardPanel.access$0(SPTBatch_.ChooserWizardPanel.this)).summaryButton.setEnabled(false);
> /*      */               }
> /*      */             }
> /*      */           });
> /* 3932 */       SPTBatch_.checkboxDiff.addItemListener(new ItemListener()
> /*      */           {
> /*      */             public void itemStateChanged(ItemEvent e) {
> /* 3935 */               if (e.getStateChange() == 1) {
> /* 3936 */                 (SPTBatch_.ChooserWizardPanel.access$0(SPTBatch_.ChooserWizardPanel.this)).trajButton.setEnabled(true);
> /*      */               }
> /*      */               
> /* 3939 */               if (e.getStateChange() == 2) {
> /* 3940 */                 (SPTBatch_.ChooserWizardPanel.access$0(SPTBatch_.ChooserWizardPanel.this)).trajButton.setEnabled(false);
> /*      */               }
> /*      */             }
> /*      */           });
> /* 3944 */       SPTBatch_.checkDispTracks.addItemListener(new ItemListener()
> /*      */           {
> /*      */             public void itemStateChanged(ItemEvent e) {
> /* 3947 */               if (e.getStateChange() == 1) {
> /* 3948 */                 (SPTBatch_.ChooserWizardPanel.access$0(SPTBatch_.ChooserWizardPanel.this)).comboDispTracks.setEnabled(true);
> /*      */               }
> /*      */               
> /* 3951 */               if (e.getStateChange() == 2) {
> /* 3952 */                 (SPTBatch_.ChooserWizardPanel.access$0(SPTBatch_.ChooserWizardPanel.this)).comboDispTracks.setEnabled(false);
> /*      */               }
> /*      */             }
> /*      */           });
> /* 3956 */       SPTBatch_.checkTracks.addItemListener(new ItemListener()
> /*      */           {
> /*      */             public void itemStateChanged(ItemEvent e) {
> /* 3959 */               if (e.getStateChange() == 1) {
> /* 3960 */                 SPTBatch_.minTracks.setEnabled(true);
> /* 3961 */                 SPTBatch_.maxTracks.setEnabled(true);
> /*      */               } 
> /*      */               
> /* 3964 */               if (e.getStateChange() == 2) {
> /* 3965 */                 SPTBatch_.minTracks.setEnabled(false);
> /* 3966 */                 SPTBatch_.maxTracks.setEnabled(false);
> /*      */               } 
> /*      */             }
> /*      */           });
> /* 3970 */       SPTBatch_.checkMonomer.addItemListener(new ItemListener()
> /*      */           {
> /*      */             public void itemStateChanged(ItemEvent e) {
> /* 3973 */               if (e.getStateChange() == 1) {
> /* 3974 */                 SPTBatch_.monomerField.setEnabled(true);
> /*      */               }
> /* 3976 */               if (e.getStateChange() == 2) {
> /* 3977 */                 SPTBatch_.monomerField.setEnabled(false);
> /*      */               }
> /*      */             }
> /*      */           });
> /* 3981 */       SPTBatch_.checkboxSubBg.addItemListener(new ItemListener()
> /*      */           {
> /*      */             public void itemStateChanged(ItemEvent e) {
> /* 3984 */               if (e.getStateChange() == 1) {
> /* 3985 */                 (SPTBatch_.ChooserWizardPanel.access$0(SPTBatch_.ChooserWizardPanel.this)).comboSubBg.setEnabled(true);
> /*      */               }
> /* 3987 */               if (e.getStateChange() == 2)
> /* 3988 */                 (SPTBatch_.ChooserWizardPanel.access$0(SPTBatch_.ChooserWizardPanel.this)).comboSubBg.setEnabled(false); 
> /*      */             }
> /*      */           });
> /* 3991 */       SPTBatch_.checkbox1.addItemListener(new ItemListener()
> /*      */           {
> /*      */             public void itemStateChanged(ItemEvent e) {
> /* 3994 */               Component[] com = panelCsv.getComponents();
> /* 3995 */               Component[] comExport = panelExport.getComponents();
> /* 3996 */               if (e.getStateChange() == 1) {
> /* 3997 */                 int a; for (a = 1; a < com.length; a++)
> /* 3998 */                   com[a].setEnabled(true); 
> /* 3999 */                 for (a = 0; a < comExport.length; a++) {
> /* 4000 */                   comExport[a].setEnabled(true);
> /*      */                 }
> /*      */               } 
> /* 4003 */               if (e.getStateChange() == 2) {
> /* 4004 */                 for (int a = 1; a < com.length; a++) {
> /* 4005 */                   com[a].setEnabled(false);
> /*      */                 }
> /*      */               }
> /*      */             }
> /*      */           });
> /* 4010 */       SPTBatch_.checkboxSP.addItemListener(new ItemListener()
> /*      */           {
> /*      */             public void itemStateChanged(ItemEvent e) {
> /* 4013 */               if (e.getStateChange() == 1) {
> /* 4014 */                 SPTBatch_.chemoScaling.setEnabled(true);
> /*      */               }
> /*      */ 
> /*      */               
> /* 4018 */               if (e.getStateChange() == 2) {
> /* 4019 */                 SPTBatch_.chemoScaling.setEnabled(false);
> /*      */               }
> /*      */             }
> /*      */           });
> /*      */ 
> /*      */       
> /* 4025 */       SPTBatch_.this.summaryButton.addActionListener(new ActionListener() {
> /*      */             public void actionPerformed(ActionEvent event) {
> /* 4027 */               if (SPTBatch_.checkSummary.isSelected()) {
> /* 4028 */                 if (SPTBatch_.checkTracks.isSelected() == Boolean.TRUE.booleanValue()) {
> /* 4029 */                   SPTBatch_.minTracksJTF = Integer.valueOf(SPTBatch_.minTracks.getText()).intValue();
> /* 4030 */                   SPTBatch_.maxTracksJTF = Integer.valueOf(SPTBatch_.maxTracks.getText()).intValue();
> /* 4031 */                   SPTBatch_.thLengthJTF = Integer.valueOf(SPTBatch_.thLength.getText()).intValue();
> /* 4032 */                   if (SPTBatch_.thD14.getText() != null || SPTBatch_.thD14.getText() != "DIff") {
> /* 4033 */                     (SPTBatch_.ChooserWizardPanel.access$0(SPTBatch_.ChooserWizardPanel.this)).thD14JTF = Double.valueOf(SPTBatch_.thD14.getText()).doubleValue();
> /*      */                   }
> /*      */                 } 
> /* 4036 */                 (new summaryColsWindow()).run("");
> /*      */               } 
> /*      */             }
> /*      */           });
> /*      */       
> /* 4041 */       SPTBatch_.this.trajButton.addActionListener(new ActionListener() {
> /*      */             public void actionPerformed(ActionEvent event) {
> /* 4043 */               if (SPTBatch_.checkboxDiff.isSelected()) {
> /* 4044 */                 (new traJParametersWindow()).run("");
> /*      */               }
> /*      */             }
> /*      */           });
> /*      */       
> /* 4049 */       SPTBatch_.this.finishButton.addActionListener(new ActionListener() {
> /*      */             public void actionPerformed(ActionEvent event) {
> /* 4051 */               SPTBatch_.csvPath = textCsv.getText();
> /* 4052 */               SPTBatch_.pref1.put((SPTBatch_.ChooserWizardPanel.access$0(SPTBatch_.ChooserWizardPanel.this)).TRACKMATE_CSV_PATH, textCsv.getText());
> /*      */             }
> /*      */           });
> /*      */ 
> /*      */       
> /* 4057 */       add(mainPanel2);
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public void update() {
> /* 4063 */       if (SPTBatch_.checkboxPlot.isSelected() == Boolean.FALSE.booleanValue())
> /* 4064 */         setNextButtonEnabled(false); 
> /* 4065 */       if (SPTBatch_.checkboxPlot.isSelected() == Boolean.TRUE.booleanValue())
> /* 4066 */         setNextButtonEnabled(true); 
> /* 4067 */       setFinishButtonEnabled(true);
> /* 4068 */       setBackButtonEnabled(false);
> /*      */     }
> /*      */     
> /*      */     public void next() {
> /* 4072 */       switchPanel(3);
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public void back() {
> /* 4078 */       switchPanel(4);
> /*      */     }
> /*      */   }
> /*      */   
> /*      */   class OptionWizardPanel
> /*      */     extends LabelWizardPanel {
> /*      */     public OptionWizardPanel(JWizardComponents wizardComponents, String option) {
> /* 4085 */       super(wizardComponents, "");
> /* 4086 */       setPanelTitle("  Check options to export Tracking results");
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     public void update1() {
> /* 4091 */       setNextButtonEnabled(false);
> /* 4092 */       setFinishButtonEnabled(true);
> /* 4093 */       setBackButtonEnabled(true);
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     public void next() {
> /* 4098 */       switchPanel(4);
> /*      */     }
> /*      */     
> /*      */     public void back() {
> /* 4102 */       switchPanel(1);
> /* 4103 */       if (SPTBatch_.this.itemCheckPlot == 1)
> /* 4104 */         switchPanel(4); 
> /* 4105 */       if (SPTBatch_.this.itemPlot2 == 1)
> /* 4106 */         switchPanel(4); 
> /* 4107 */       if (SPTBatch_.this.itemPlot2 == 1 && SPTBatch_.this.itemCheckPlot == 1) {
> /* 4108 */         switchPanel(4);
> /*      */       }
> /*      */     }
> /*      */     
> /*      */     public void finish() {
> /* 4113 */       switchPanel(2);
> /*      */     }
> /*      */   }
> /*      */   
> /*      */   class LastWizardPanel extends LabelWizardPanel {
> /*      */     public LastWizardPanel(JWizardComponents wizardComponents) {
> /* 4119 */       super(wizardComponents, "");
> /* 4120 */       setPanelTitle("");
> /* 4121 */       update();
> /* 4122 */       removeAll();
> /*      */       
> /* 4124 */       JTabbedPane tabbedPane = new JTabbedPane();
> /* 4125 */       ImageIcon iconSpot = SPTBatch_.this.createImageIcon(
> /* 4126 */           "5441165-point-of-light-png-104-images-in-collection-page-1-point-of-light-png-320_320_preview.png");
> /* 4127 */       Icon iconSpotCell = new ImageIcon(iconSpot.getImage().getScaledInstance(12, 12, 4));
> /* 4128 */       ImageIcon iconLink = SPTBatch_.this.createImageIcon("link.png");
> /* 4129 */       Icon iconLinkCell = new ImageIcon(iconLink.getImage().getScaledInstance(16, 16, 4));
> /* 4130 */       ImageIcon iconTrack = SPTBatch_.this.createImageIcon("track.jpg");
> /* 4131 */       Icon iconTrackCell = new ImageIcon(iconTrack.getImage().getScaledInstance(16, 16, 4));
> /*      */       
> /* 4133 */       JComponent panel1 = SPTBatch_.this.makeTextPanel("");
> /* 4134 */       JComponent panelX = SPTBatch_.this.makeTextPanel("");
> /* 4135 */       JComponent panelY = SPTBatch_.this.makeTextPanel("");
> /* 4136 */       panelY.setLayout(new FlowLayout(0));
> /* 4137 */       JLabel xSpot = new JLabel();
> /* 4138 */       xSpot.setText(" Spot-Feature for X axis:   ");
> /* 4139 */       xSpot.setFont(new Font("Verdana", 1, 12));
> /* 4140 */       JLabel ySpot = new JLabel();
> /* 4141 */       ySpot.setText(" Spot-Feature for Y axis:   ");
> /* 4142 */       ySpot.setFont(new Font("Verdana", 1, 12));
> /* 4143 */       SPTBatch_.this.comboSpotsX = new JComboBox();
> /* 4144 */       SPTBatch_.this.comboSpotsY = new JComboBox();
> /* 4145 */       Object[] spotItems = null;
> /*      */       
> /* 4147 */       spotItems = new Object[] { "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T\tFRAME", 
> /* 4148 */           "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", 
> /* 4149 */           "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", 
> /* 4150 */           "CONTRAST_CH1", "SNR_CH1" };
> /* 4151 */       for (int i = 0; i < spotItems.length; i++) {
> /* 4152 */         SPTBatch_.this.comboSpotsX.addItem(spotItems[i]);
> /* 4153 */         SPTBatch_.this.comboSpotsY.addItem(spotItems[i]);
> /*      */       } 
> /*      */       
> /* 4156 */       panelX.setLayout(new FlowLayout(0));
> /* 4157 */       panelX.add(Box.createVerticalStrut(10));
> /* 4158 */       panelX.add(xSpot);
> /* 4159 */       panelX.add(Box.createVerticalStrut(5));
> /* 4160 */       panelX.add(SPTBatch_.this.comboSpotsX);
> /* 4161 */       panelY.add(ySpot);
> /* 4162 */       panelY.add(Box.createVerticalStrut(5));
> /* 4163 */       panelY.add(SPTBatch_.this.comboSpotsY);
> /* 4164 */       panel1.setLayout(new BoxLayout(panel1, 1));
> /* 4165 */       panel1.add(panelX);
> /* 4166 */       panel1.add(panelY);
> /* 4167 */       JPanel panelESP = new JPanel(new FlowLayout(1));
> /* 4168 */       panelESP.setBorder(BorderFactory.createLoweredBevelBorder());
> /* 4169 */       SPTBatch_.ESP = new JCheckBox("  Export User-Defined Spot Plot.");
> /* 4170 */       panelESP.add(SPTBatch_.ESP);
> /* 4171 */       panel1.add(Box.createVerticalStrut(15));
> /* 4172 */       panel1.add(panelESP);
> /* 4173 */       panel1.setBorder(BorderFactory.createTitledBorder(""));
> /* 4174 */       tabbedPane.addTab("Spots", iconSpotCell, panel1, "Select the X-Y Spot features to plot.");
> /* 4175 */       tabbedPane.setMnemonicAt(0, 49);
> /*      */       
> /* 4177 */       JComponent panel2 = SPTBatch_.this.makeTextPanel("");
> /* 4178 */       JComponent panelLinkX = SPTBatch_.this.makeTextPanel("");
> /* 4179 */       JComponent panelLinkY = SPTBatch_.this.makeTextPanel("");
> /* 4180 */       panelLinkX.setLayout(new FlowLayout(0));
> /* 4181 */       panelLinkY.setLayout(new FlowLayout(0));
> /* 4182 */       JLabel xLink = new JLabel();
> /* 4183 */       xLink.setText(" Link-Feature for X axis:   ");
> /* 4184 */       xLink.setFont(new Font("Verdana", 1, 12));
> /* 4185 */       JLabel yLink = new JLabel();
> /* 4186 */       yLink.setText(" Link-Feature for Y axis:   ");
> /* 4187 */       yLink.setFont(new Font("Verdana", 1, 12));
> /* 4188 */       SPTBatch_.this.comboLinkX = new JComboBox();
> /* 4189 */       SPTBatch_.this.comboLinkY = new JComboBox();
> /* 4190 */       Object[] edgeItems = { "SPOT_SOURCE_ID", "SPOT_TARGET_ID", "LINK_COST", 
> /* 4191 */           "DIRECTIONAL_CHANGE_RATE", "SPEED", "DISPLACEMENT", "EDGE_TIME", "EDGE_X_LOCATION", 
> /* 4192 */           "EDGE_Y_LOCATION", "EDGE_Z_LOCATION" };
> /* 4193 */       for (int j = 0; j < edgeItems.length; j++) {
> /* 4194 */         SPTBatch_.this.comboLinkX.addItem(edgeItems[j]);
> /* 4195 */         SPTBatch_.this.comboLinkY.addItem(edgeItems[j]);
> /*      */       } 
> /*      */       
> /* 4198 */       panelLinkX.setLayout(new FlowLayout(0));
> /* 4199 */       panelLinkX.add(Box.createVerticalStrut(10));
> /* 4200 */       panelLinkX.add(xLink);
> /* 4201 */       panelLinkX.add(Box.createVerticalStrut(5));
> /* 4202 */       panelLinkX.add(SPTBatch_.this.comboLinkX);
> /* 4203 */       panelLinkY.add(yLink);
> /* 4204 */       panelLinkY.add(Box.createVerticalStrut(5));
> /* 4205 */       panelLinkY.add(SPTBatch_.this.comboLinkY);
> /* 4206 */       panel2.setLayout(new BoxLayout(panel2, 1));
> /* 4207 */       panel2.add(panelLinkX);
> /* 4208 */       panel2.add(panelLinkY);
> /* 4209 */       JPanel panelELP = new JPanel(new FlowLayout(1));
> /* 4210 */       panelELP.setBorder(BorderFactory.createLoweredBevelBorder());
> /* 4211 */       SPTBatch_.ELP = new JCheckBox("  Export User-Defined Links Plot.");
> /* 4212 */       panelELP.add(SPTBatch_.ELP);
> /* 4213 */       panel2.add(Box.createVerticalStrut(15));
> /* 4214 */       panel2.add(panelELP);
> /* 4215 */       panel2.setBorder(BorderFactory.createTitledBorder(""));
> /* 4216 */       tabbedPane.addTab("Links", iconLinkCell, panel2, "Select the  X-Y Link features to plot.");
> /* 4217 */       tabbedPane.setMnemonicAt(1, 50);
> /*      */       
> /* 4219 */       JComponent panel3 = SPTBatch_.this.makeTextPanel("");
> /* 4220 */       JComponent panelTrackX = SPTBatch_.this.makeTextPanel("");
> /* 4221 */       JComponent panelTrackY = SPTBatch_.this.makeTextPanel("");
> /* 4222 */       panelTrackX.setLayout(new FlowLayout(0));
> /* 4223 */       panelTrackY.setLayout(new FlowLayout(0));
> /* 4224 */       JLabel xTrack = new JLabel();
> /* 4225 */       xTrack.setText(" Track-Feature for X axis:   ");
> /* 4226 */       xTrack.setFont(new Font("Verdana", 1, 12));
> /* 4227 */       JLabel yTrack = new JLabel();
> /* 4228 */       yTrack.setText(" Track-Feature for Y axis:   ");
> /* 4229 */       yTrack.setFont(new Font("Verdana", 1, 12));
> /* 4230 */       SPTBatch_.this.comboTrackX = new JComboBox();
> /* 4231 */       SPTBatch_.this.comboTrackY = new JComboBox();
> /* 4232 */       Object[] trackItems = null;
> /*      */       
> /* 4234 */       trackItems = new Object[] { "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", 
> /* 4235 */           "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", 
> /* 4236 */           "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", 
> /* 4237 */           "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", 
> /* 4238 */           "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", 
> /* 4239 */           "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE" };
> /* 4240 */       for (int k = 0; k < trackItems.length; k++) {
> /* 4241 */         SPTBatch_.this.comboTrackX.addItem(trackItems[k]);
> /* 4242 */         SPTBatch_.this.comboTrackY.addItem(trackItems[k]);
> /*      */       } 
> /*      */       
> /* 4245 */       panelTrackX.setLayout(new FlowLayout(0));
> /* 4246 */       panelTrackX.add(Box.createVerticalStrut(10));
> /* 4247 */       panelTrackX.add(xTrack);
> /* 4248 */       panelTrackX.add(Box.createVerticalStrut(5));
> /* 4249 */       panelTrackX.add(SPTBatch_.this.comboTrackX);
> /* 4250 */       panelTrackY.add(yTrack);
> /* 4251 */       panelTrackY.add(Box.createVerticalStrut(5));
> /* 4252 */       panelTrackY.add(SPTBatch_.this.comboTrackY);
> /* 4253 */       panel3.setLayout(new BoxLayout(panel3, 1));
> /* 4254 */       panel3.add(panelTrackX);
> /* 4255 */       panel3.add(panelTrackY);
> /* 4256 */       JPanel panelETP = new JPanel(new FlowLayout(1));
> /* 4257 */       panelETP.setBorder(BorderFactory.createLoweredBevelBorder());
> /* 4258 */       SPTBatch_.ETP = new JCheckBox("  Export User-Defined Tracks Plot.");
> /* 4259 */       panelETP.add(SPTBatch_.ETP);
> /* 4260 */       panel3.add(Box.createVerticalStrut(15));
> /* 4261 */       panel3.add(panelETP);
> /* 4262 */       panel3.setBorder(BorderFactory.createTitledBorder(""));
> /*      */       
> /* 4264 */       tabbedPane.addTab("Tracks", iconTrackCell, panel3, "Select the  X-Y Track features to plot.");
> /* 4265 */       tabbedPane.setMnemonicAt(2, 51);
> /* 4266 */       tabbedPane.setPreferredSize(new Dimension(450, 250));
> /* 4267 */       add(tabbedPane);
> /*      */ 
> /*      */       
> /* 4270 */       tabbedPane.setTabLayoutPolicy(1);
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     public void update() {
> /* 4275 */       setNextButtonEnabled(false);
> /* 4276 */       if (SPTBatch_.this.itemCheckPlot == 1) {
> /* 4277 */         setNextButtonEnabled(false);
> /*      */       }
> /* 4279 */       setFinishButtonEnabled(true);
> /* 4280 */       setBackButtonEnabled(true);
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public void next() {}
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public void back() {
> /* 4292 */       switchPanel(0);
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     public void finish() {
> /* 4297 */       switchPanel(2);
> /*      */     }
> /*      */   }
> /*      */   
> /*      */   protected ImageIcon createImageIcon(String path) {
> /* 4302 */     URL imgURL = getClass().getResource(path);
> /* 4303 */     if (imgURL != null) {
> /* 4304 */       return new ImageIcon(imgURL);
> /*      */     }
> /* 4306 */     System.err.println("Couldn't find file: " + path);
> /* 4307 */     return null;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   private Image getScaledImage(Image srcImg, int w, int h) {
> /* 4312 */     BufferedImage resizedImg = new BufferedImage(w, h, 1);
> /* 4313 */     Graphics2D g2 = resizedImg.createGraphics();
> /* 4314 */     g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
> /* 4315 */     g2.drawImage(srcImg, 0, 0, w, h, null);
> /* 4316 */     g2.dispose();
> /* 4317 */     return resizedImg;
> /*      */   }
> /*      */   
> /*      */   protected JComponent makeTextPanel(String text) {
> /* 4321 */     JPanel panel = new JPanel(false);
> /* 4322 */     JLabel filler = new JLabel(text);
> /* 4323 */     filler.setHorizontalAlignment(0);
> /* 4324 */     panel.setLayout(new GridLayout(1, 1));
> /* 4325 */     panel.add(filler);
> /* 4326 */     return panel;
> /*      */   }
> /*      */   
> /*      */   private static final class EdgeSourceSpotFrameComparator
> /*      */     implements Comparator<DefaultWeightedEdge> {
> /*      */     private final Model model;
> /*      */     
> /*      */     public EdgeSourceSpotFrameComparator(Model model) {
> /* 4334 */       this.model = model;
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     public int compare(DefaultWeightedEdge e1, DefaultWeightedEdge e2) {
> /* 4339 */       double t1 = this.model.getTrackModel().getEdgeSource(e1).getFeature("FRAME").doubleValue();
> /* 4340 */       double t2 = this.model.getTrackModel().getEdgeSource(e2).getFeature("FRAME").doubleValue();
> /* 4341 */       if (t1 < t2) {
> /* 4342 */         return -1;
> /*      */       }
> /* 4344 */       if (t1 > t2) {
> /* 4345 */         return 1;
> /*      */       }
> /* 4347 */       return 0;
> /*      */     }
> /*      */   }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /*      */   public static ImagePlus[] openBF(String multiSeriesFileName, boolean splitC, boolean splitT, boolean splitZ, boolean autoScale, boolean crop, boolean allSeries) {
> /* 4355 */     ImagePlus[] imps = null;
> /*      */     try {
> /* 4357 */       ImporterOptions options = new ImporterOptions();
> /* 4358 */       options.setId(multiSeriesFileName);
> /* 4359 */       options.setSplitChannels(splitC);
> /* 4360 */       options.setSplitTimepoints(splitT);
> /* 4361 */       options.setSplitFocalPlanes(splitZ);
> /* 4362 */       options.setAutoscale(autoScale);
> /* 4363 */       options.setStackFormat("Hyperstack");
> /* 4364 */       options.setStackOrder("XYCZT");
> /* 4365 */       options.setCrop(crop);
> /* 4366 */       options.setOpenAllSeries(allSeries);
> /*      */       
> /* 4368 */       ImportProcess process = new ImportProcess(options);
> /* 4369 */       if (!process.execute())
> /* 4370 */         return null; 
> /* 4371 */       DisplayHandler displayHandler = new DisplayHandler(process);
> /* 4372 */       if (options != null && options.isShowOMEXML()) {
> /* 4373 */         displayHandler.displayOMEXML();
> /*      */       }
> /* 4375 */       List<ImagePlus> impsList = (new ImagePlusReaderModified(process)).readImages(false);
> /* 4376 */       imps = impsList.<ImagePlus>toArray(new ImagePlus[0]);
> /* 4377 */       if (options != null && options.showROIs()) {
> /* 4378 */         displayHandler.displayROIs(imps);
> /*      */       }
> /* 4380 */       if (!options.isVirtual()) {
> /* 4381 */         process.getReader().close();
> /*      */       }
> /*      */     }
> /* 4384 */     catch (Exception e) {
> /*      */       
> /* 4386 */       return null;
> /*      */     } 
> /* 4388 */     return imps;
> /*      */   }
> /*      */   
> /*      */   private final TablePanel<Spot> createSpotTable(Model model, DisplaySettings ds) {
> /* 4392 */     List<Spot> objects = new ArrayList<>();
> /* 4393 */     for (Integer trackID : model.getTrackModel().unsortedTrackIDs(true))
> /* 4394 */       objects.addAll(model.getTrackModel().trackSpots(trackID)); 
> /* 4395 */     List<String> features = new ArrayList<>(model.getFeatureModel().getSpotFeatures());
> /* 4396 */     Map<String, String> featureNames = model.getFeatureModel().getSpotFeatureNames();
> /* 4397 */     Map<String, String> featureShortNames = model.getFeatureModel().getSpotFeatureShortNames();
> /* 4398 */     Map<String, String> featureUnits = new HashMap<>();
> /* 4399 */     for (String feature : features) {
> /* 4400 */       Dimension dimension = (Dimension)model.getFeatureModel().getSpotFeatureDimensions()
> /* 4401 */         .get(feature);
> /* 4402 */       String units = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
> /* 4403 */       featureUnits.put(feature, units);
> /*      */     } 
> /* 4405 */     Map<String, Boolean> isInts = model.getFeatureModel().getSpotFeatureIsInt();
> /* 4406 */     Map<String, String> infoTexts = new HashMap<>();
> /* 4407 */     Function<Spot, String> labelGenerator = spot -> spot.getName();
> /* 4408 */     BiConsumer<Spot, String> labelSetter = (spot, label) -> spot.setName(label);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /* 4413 */     String SPOT_ID = "ID";
> /* 4414 */     features.add(0, "ID");
> /* 4415 */     featureNames.put("ID", "Spot ID");
> /* 4416 */     featureShortNames.put("ID", "Spot ID");
> /* 4417 */     featureUnits.put("ID", "");
> /* 4418 */     isInts.put("ID", Boolean.TRUE);
> /* 4419 */     infoTexts.put("ID", "The id of the spot.");
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /* 4424 */     String TRACK_ID = "TRACK_ID";
> /* 4425 */     features.add(1, "TRACK_ID");
> /* 4426 */     featureNames.put("TRACK_ID", "Track ID");
> /* 4427 */     featureShortNames.put("TRACK_ID", "Track ID");
> /* 4428 */     featureUnits.put("TRACK_ID", "");
> /* 4429 */     isInts.put("TRACK_ID", Boolean.TRUE);
> /* 4430 */     infoTexts.put("TRACK_ID", "The id of the track this spot belongs to.");
> /*      */     
> /* 4432 */     BiFunction<Spot, String, Double> featureFun = (spot, feature) -> {
> /*      */         if (feature.equals("TRACK_ID")) {
> /*      */           Integer trackID = paramModel.getTrackModel().trackIDOf(spot);
> /*      */           
> /*      */           return (trackID == null) ? null : Double.valueOf(trackID.doubleValue());
> /*      */         } 
> /*      */         
> /*      */         return feature.equals("ID") ? Double.valueOf(spot.ID()) : spot.getFeature(feature);
> /*      */       };
> /*      */     
> /* 4442 */     BiConsumer<Spot, Color> colorSetter = (spot, color) -> spot.putFeature("MANUAL_SPOT_COLOR", Double.valueOf(color.getRGB()));
> /*      */ 
> /*      */     
> /* 4445 */     Supplier<FeatureColorGenerator<Spot>> coloring = () -> FeatureUtils.createSpotColorGenerator(paramModel, paramDisplaySettings);
> /*      */     
> /* 4447 */     TablePanel<Spot> table = new TablePanel(objects, features, featureFun, featureNames, featureShortNames, 
> /* 4448 */         featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter, 
> /* 4449 */         "MANUAL_SPOT_COLOR", colorSetter);
> /*      */     
> /* 4451 */     return table;
> /*      */   }
> /*      */   
> /*      */   private final TablePanel<DefaultWeightedEdge> createEdgeTable(Model model, DisplaySettings ds) {
> /* 4455 */     List<DefaultWeightedEdge> objects = new ArrayList<>();
> /* 4456 */     for (Integer trackID : model.getTrackModel().unsortedTrackIDs(true))
> /* 4457 */       objects.addAll(model.getTrackModel().trackEdges(trackID)); 
> /* 4458 */     List<String> features = new ArrayList<>(model.getFeatureModel().getEdgeFeatures());
> /* 4459 */     Map<String, String> featureNames = model.getFeatureModel().getEdgeFeatureNames();
> /* 4460 */     Map<String, String> featureShortNames = model.getFeatureModel().getEdgeFeatureShortNames();
> /* 4461 */     Map<String, String> featureUnits = new HashMap<>();
> /* 4462 */     for (String feature : features) {
> /* 4463 */       Dimension dimension = (Dimension)model.getFeatureModel().getEdgeFeatureDimensions()
> /* 4464 */         .get(feature);
> /* 4465 */       String units = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
> /* 4466 */       featureUnits.put(feature, units);
> /*      */     } 
> /* 4468 */     Map<String, Boolean> isInts = model.getFeatureModel().getEdgeFeatureIsInt();
> /* 4469 */     Map<String, String> infoTexts = new HashMap<>();
> /* 4470 */     Function<DefaultWeightedEdge, String> labelGenerator = edge -> String.format("%s  %s", new Object[] { paramModel.getTrackModel().getEdgeSource(edge).getName(), paramModel.getTrackModel().getEdgeTarget(edge).getName() });
> /*      */ 
> /*      */     
> /* 4473 */     BiConsumer<DefaultWeightedEdge, String> labelSetter = null;
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /* 4478 */     String TRACK_ID = "TRACK_ID";
> /* 4479 */     features.add(0, "TRACK_ID");
> /* 4480 */     featureNames.put("TRACK_ID", "Track ID");
> /* 4481 */     featureShortNames.put("TRACK_ID", "Track ID");
> /* 4482 */     featureUnits.put("TRACK_ID", "");
> /* 4483 */     isInts.put("TRACK_ID", Boolean.TRUE);
> /* 4484 */     infoTexts.put("TRACK_ID", "The id of the track this spot belongs to.");
> /*      */     
> /* 4486 */     BiFunction<DefaultWeightedEdge, String, Double> featureFun = (edge, feature) -> {
> /*      */         if (feature.equals("TRACK_ID")) {
> /*      */           Integer trackID = paramModel.getTrackModel().trackIDOf(edge);
> /*      */           
> /*      */           return (trackID == null) ? null : Double.valueOf(trackID.doubleValue());
> /*      */         } 
> /*      */         return paramModel.getFeatureModel().getEdgeFeature(edge, feature);
> /*      */       };
> /* 4494 */     BiConsumer<DefaultWeightedEdge, Color> colorSetter = (edge, color) -> paramModel.getFeatureModel().putEdgeFeature(edge, "MANUAL_EGE_COLOR", Double.valueOf(color.getRGB()));
> /*      */ 
> /*      */     
> /* 4497 */     Supplier<FeatureColorGenerator<DefaultWeightedEdge>> coloring = () -> FeatureUtils.createTrackColorGenerator(paramModel, paramDisplaySettings);
> /*      */ 
> /*      */     
> /* 4500 */     TablePanel<DefaultWeightedEdge> table = new TablePanel(objects, features, featureFun, featureNames, 
> /* 4501 */         featureShortNames, featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter, 
> /* 4502 */         "MANUAL_EGE_COLOR", colorSetter);
> /*      */     
> /* 4504 */     return table;
> /*      */   }
> /*      */   
> /*      */   private final TablePanel<Integer> createTrackTable(Model model, DisplaySettings ds) {
> /* 4508 */     List<Integer> objects = new ArrayList<>(model.getTrackModel().trackIDs(true));
> /* 4509 */     List<String> features = new ArrayList<>(model.getFeatureModel().getTrackFeatures());
> /* 4510 */     BiFunction<Integer, String, Double> featureFun = (trackID, feature) -> paramModel.getFeatureModel().getTrackFeature(trackID, feature);
> /*      */     
> /* 4512 */     Map<String, String> featureNames = model.getFeatureModel().getTrackFeatureNames();
> /* 4513 */     Map<String, String> featureShortNames = model.getFeatureModel().getTrackFeatureShortNames();
> /* 4514 */     Map<String, String> featureUnits = new HashMap<>();
> /* 4515 */     for (String feature : features) {
> /* 4516 */       Dimension dimension = (Dimension)model.getFeatureModel().getTrackFeatureDimensions()
> /* 4517 */         .get(feature);
> /* 4518 */       String units = TMUtils.getUnitsFor(dimension, model.getSpaceUnits(), model.getTimeUnits());
> /* 4519 */       featureUnits.put(feature, units);
> /*      */     } 
> /* 4521 */     Map<String, Boolean> isInts = model.getFeatureModel().getTrackFeatureIsInt();
> /* 4522 */     Map<String, String> infoTexts = new HashMap<>();
> /* 4523 */     Function<Integer, String> labelGenerator = id -> paramModel.getTrackModel().name(id);
> /* 4524 */     BiConsumer<Integer, String> labelSetter = (id, label) -> paramModel.getTrackModel().setName(id, label);
> /*      */     
> /* 4526 */     Supplier<FeatureColorGenerator<Integer>> coloring = () -> FeatureUtils.createWholeTrackColorGenerator(paramModel, paramDisplaySettings);
> /*      */ 
> /*      */     
> /* 4529 */     TablePanel<Integer> table = new TablePanel(objects, features, featureFun, featureNames, 
> /* 4530 */         featureShortNames, featureUnits, isInts, infoTexts, coloring, labelGenerator, labelSetter);
> /*      */     
> /* 4532 */     return table;
> /*      */   }
> /*      */   
> /*      */   public static final TablePanel<Branch> createBranchTable(Model model, SelectionModel selectionModel) {
> /* 4536 */     Logger logger = model.getLogger();
> /*      */     
> /* 4538 */     taskOutput.append("Generating track branches analysis.\n");
> /* 4539 */     int ntracks = model.getTrackModel().nTracks(true);
> /* 4540 */     if (ntracks == 0) {
> /* 4541 */       taskOutput.append("No visible track found. Aborting.\n");
> /*      */     }
> /* 4543 */     TimeDirectedNeighborIndex neighborIndex = model.getTrackModel().getDirectedNeighborIndex();
> /*      */     
> /* 4545 */     List<Branch> brs = new ArrayList<>();
> /* 4546 */     for (Integer trackID : model.getTrackModel().unsortedTrackIDs(true)) {
> /* 4547 */       ConvexBranchesDecomposition.TrackBranchDecomposition branchDecomposition = ConvexBranchesDecomposition.processTrack(trackID, 
> /* 4548 */           model.getTrackModel(), neighborIndex, true, false);
> /* 4549 */       SimpleDirectedGraph<List<Spot>, DefaultEdge> branchGraph = 
> /* 4550 */         ConvexBranchesDecomposition.buildBranchGraph(branchDecomposition);
> /*      */       
> /* 4552 */       Map<Branch, Set<List<Spot>>> successorMap = new HashMap<>();
> /* 4553 */       Map<Branch, Set<List<Spot>>> predecessorMap = new HashMap<>();
> /* 4554 */       Map<List<Spot>, Branch> branchMap = new HashMap<>();
> /*      */       
> /* 4556 */       for (List<Spot> branch : (Iterable<List<Spot>>)branchGraph.vertexSet()) {
> /* 4557 */         double meanV; Branch br = new Branch();
> /* 4558 */         branchMap.put(branch, br);
> /*      */ 
> /*      */         
> /* 4561 */         br.trackName = model.getTrackModel().name(trackID);
> /* 4562 */         br.putFeature("TRACK_ID", Double.valueOf(trackID.intValue()));
> /*      */ 
> /*      */         
> /* 4565 */         Spot first = branch.get(0);
> /* 4566 */         br.first = first;
> /* 4567 */         br.putFeature("FIRST", Double.valueOf(first.ID()));
> /*      */         
> /* 4569 */         Spot last = branch.get(branch.size() - 1);
> /* 4570 */         br.last = last;
> /* 4571 */         br.putFeature("LAST", Double.valueOf(last.ID()));
> /*      */ 
> /*      */         
> /* 4574 */         br.putFeature("DELTA_T", Double.valueOf(br.dt()));
> /*      */ 
> /*      */         
> /* 4577 */         double distanceTraveled = Math.sqrt(br.last.squareDistanceTo((RealLocalizable)br.first));
> /* 4578 */         br.putFeature("DISTANCE", Double.valueOf(distanceTraveled));
> /*      */ 
> /*      */ 
> /*      */         
> /* 4582 */         if (branch.size() < 2) {
> /* 4583 */           meanV = Double.NaN;
> /*      */         } else {
> /* 4585 */           Iterator<Spot> it = branch.iterator();
> /* 4586 */           Spot previous = it.next();
> /* 4587 */           double sum = 0.0D;
> /* 4588 */           while (it.hasNext()) {
> /* 4589 */             Spot next = it.next();
> /* 4590 */             double dr = Math.sqrt(next.squareDistanceTo((RealLocalizable)previous));
> /* 4591 */             sum += dr;
> /* 4592 */             previous = next;
> /*      */           } 
> /* 4594 */           meanV = sum / (branch.size() - 1);
> /*      */         } 
> /* 4596 */         br.putFeature("MEAN_VELOCITY", Double.valueOf(meanV));
> /*      */ 
> /*      */         
> /* 4599 */         Set<DefaultEdge> incomingEdges = branchGraph.incomingEdgesOf(branch);
> /* 4600 */         Set<List<Spot>> predecessors = new HashSet<>(incomingEdges.size());
> /* 4601 */         for (DefaultEdge edge : incomingEdges) {
> /* 4602 */           List<Spot> predecessorBranch = (List<Spot>)branchGraph.getEdgeSource(edge);
> /* 4603 */           predecessors.add(predecessorBranch);
> /*      */         } 
> /*      */ 
> /*      */         
> /* 4607 */         Set<DefaultEdge> outgoingEdges = branchGraph.outgoingEdgesOf(branch);
> /* 4608 */         Set<List<Spot>> successors = new HashSet<>(outgoingEdges.size());
> /* 4609 */         for (DefaultEdge edge : outgoingEdges) {
> /* 4610 */           List<Spot> successorBranch = (List<Spot>)branchGraph.getEdgeTarget(edge);
> /* 4611 */           successors.add(successorBranch);
> /*      */         } 
> /*      */         
> /* 4614 */         successorMap.put(br, successors);
> /* 4615 */         predecessorMap.put(br, predecessors);
> /*      */       } 
> /*      */       
> /* 4618 */       for (Branch br : successorMap.keySet()) {
> /* 4619 */         Set<List<Spot>> succs = successorMap.get(br);
> /* 4620 */         Set<Branch> succBrs = new HashSet<>(succs.size());
> /* 4621 */         for (List<Spot> branch : succs) {
> /* 4622 */           Branch succBr = branchMap.get(branch);
> /* 4623 */           succBrs.add(succBr);
> /*      */         } 
> /* 4625 */         br.successors = succBrs;
> /* 4626 */         br.putFeature("N_SUCCESSORS", Double.valueOf(succBrs.size()));
> /*      */         
> /* 4628 */         Set<List<Spot>> preds = predecessorMap.get(br);
> /* 4629 */         Set<Branch> predBrs = new HashSet<>(preds.size());
> /* 4630 */         for (List<Spot> branch : preds) {
> /* 4631 */           Branch predBr = branchMap.get(branch);
> /* 4632 */           predBrs.add(predBr);
> /*      */         } 
> /* 4634 */         br.predecessors = predBrs;
> /* 4635 */         br.putFeature("N_PREDECESSORS", Double.valueOf(predBrs.size()));
> /*      */       } 
> /*      */       
> /* 4638 */       brs.addAll(successorMap.keySet());
> /*      */     } 
> /* 4640 */     Collections.sort(brs);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /* 4646 */     Iterable<Branch> objects = brs;
> /* 4647 */     BiFunction<Branch, String, Double> featureFun = (br, feature) -> br.getFeature(feature);
> /* 4648 */     Map<String, String> featureUnits = new HashMap<>();
> /* 4649 */     BRANCH_FEATURES_DIMENSIONS.forEach((f, d) -> {
> /*      */         
> /* 4651 */         }); Map<String, String> infoTexts = new HashMap<>();
> /* 4652 */     Function<Branch, String> labelGenerator = b -> b.toString();
> /* 4653 */     BiConsumer<Branch, String> labelSetter = null;
> /* 4654 */     Supplier<FeatureColorGenerator<Branch>> colorSupplier = () -> ();
> /*      */     
> /* 4656 */     TablePanel<Branch> table = new TablePanel(objects, BRANCH_FEATURES, featureFun, BRANCH_FEATURES_NAMES, 
> /* 4657 */         BRANCH_FEATURES_SHORTNAMES, featureUnits, BRANCH_FEATURES_ISINTS, infoTexts, colorSupplier, 
> /* 4658 */         labelGenerator, labelSetter);
> /*      */     
> /* 4660 */     return table;
> /*      */   }
> /*      */   public static class Branch implements Comparable<Branch> { private final Map<String, Double> features; private String trackName; private Spot first; private Spot last; private Set<Branch> predecessors; private Set<Branch> successors;
> /*      */     
> /*      */     public Branch() {
> /* 4665 */       this.features = new HashMap<>();
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public String toString() {
> /* 4679 */       return String.valueOf(this.trackName) + ": " + this.first + "  " + this.last;
> /*      */     }
> /*      */     
> /*      */     double dt() {
> /* 4683 */       return this.last.diffTo(this.first, "POSITION_T");
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final Double getFeature(String feature) {
> /* 4694 */       return this.features.get(feature);
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public final void putFeature(String feature, Double value) {
> /* 4705 */       this.features.put(feature, value);
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public int compareTo(Branch o) {
> /* 4714 */       if (this.predecessors.size() != o.predecessors.size())
> /* 4715 */         return this.predecessors.size() - o.predecessors.size(); 
> /* 4716 */       if (this.successors.size() != o.successors.size())
> /* 4717 */         return this.successors.size() - o.successors.size(); 
> /* 4718 */       if (this.first.getName().compareTo(o.first.getName()) != 0)
> /* 4719 */         return this.first.getName().compareTo(o.first.getName()); 
> /* 4720 */       return this.last.getName().compareTo(o.last.getName());
> /*      */     } }
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */   
> /* 4732 */   private static final List<String> BRANCH_FEATURES = Arrays.asList(
> /* 4733 */       new String[] { "TRACK_ID", "N_PREDECESSORS", "N_SUCCESSORS", "DELTA_T", "DISTANCE", "MEAN_VELOCITY", "FIRST", "LAST" });
> /*      */   
> /* 4735 */   private static final Map<String, String> BRANCH_FEATURES_NAMES = new HashMap<>();
> /* 4736 */   private static final Map<String, String> BRANCH_FEATURES_SHORTNAMES = new HashMap<>();
> /* 4737 */   private static final Map<String, Boolean> BRANCH_FEATURES_ISINTS = new HashMap<>();
> /* 4738 */   private static final Map<String, Dimension> BRANCH_FEATURES_DIMENSIONS = new HashMap<>();
> /*      */   static {
> /* 4740 */     BRANCH_FEATURES_NAMES.put("TRACK_ID", "Track ID");
> /* 4741 */     BRANCH_FEATURES_SHORTNAMES.put("TRACK_ID", "Track ID");
> /* 4742 */     BRANCH_FEATURES_ISINTS.put("TRACK_ID", Boolean.TRUE);
> /* 4743 */     BRANCH_FEATURES_DIMENSIONS.put("TRACK_ID", Dimension.NONE);
> /*      */     
> /* 4745 */     BRANCH_FEATURES_NAMES.put("N_PREDECESSORS", "Track ID");
> /* 4746 */     BRANCH_FEATURES_SHORTNAMES.put("N_PREDECESSORS", "N predecessors");
> /* 4747 */     BRANCH_FEATURES_ISINTS.put("N_PREDECESSORS", Boolean.TRUE);
> /* 4748 */     BRANCH_FEATURES_DIMENSIONS.put("N_PREDECESSORS", Dimension.NONE);
> /*      */     
> /* 4750 */     BRANCH_FEATURES_NAMES.put("N_SUCCESSORS", "Track ID");
> /* 4751 */     BRANCH_FEATURES_SHORTNAMES.put("N_SUCCESSORS", "N successors");
> /* 4752 */     BRANCH_FEATURES_ISINTS.put("N_SUCCESSORS", Boolean.TRUE);
> /* 4753 */     BRANCH_FEATURES_DIMENSIONS.put("N_SUCCESSORS", Dimension.NONE);
> /*      */     
> /* 4755 */     BRANCH_FEATURES_NAMES.put("DELTA_T", "Branch duration");
> /* 4756 */     BRANCH_FEATURES_SHORTNAMES.put("DELTA_T", "Delta T");
> /* 4757 */     BRANCH_FEATURES_ISINTS.put("DELTA_T", Boolean.FALSE);
> /* 4758 */     BRANCH_FEATURES_DIMENSIONS.put("DELTA_T", Dimension.TIME);
> /*      */     
> /* 4760 */     BRANCH_FEATURES_NAMES.put("DISTANCE", "Distance traveled");
> /* 4761 */     BRANCH_FEATURES_SHORTNAMES.put("DISTANCE", "Dist");
> /* 4762 */     BRANCH_FEATURES_ISINTS.put("DISTANCE", Boolean.FALSE);
> /* 4763 */     BRANCH_FEATURES_DIMENSIONS.put("DISTANCE", Dimension.LENGTH);
> /*      */     
> /* 4765 */     BRANCH_FEATURES_NAMES.put("MEAN_VELOCITY", "Mean velocity");
> /* 4766 */     BRANCH_FEATURES_SHORTNAMES.put("MEAN_VELOCITY", "Mean V");
> /* 4767 */     BRANCH_FEATURES_ISINTS.put("MEAN_VELOCITY", Boolean.FALSE);
> /* 4768 */     BRANCH_FEATURES_DIMENSIONS.put("MEAN_VELOCITY", Dimension.VELOCITY);
> /*      */     
> /* 4770 */     BRANCH_FEATURES_NAMES.put("FIRST", "First spot ID");
> /* 4771 */     BRANCH_FEATURES_SHORTNAMES.put("FIRST", "First ID");
> /* 4772 */     BRANCH_FEATURES_ISINTS.put("FIRST", Boolean.TRUE);
> /* 4773 */     BRANCH_FEATURES_DIMENSIONS.put("FIRST", Dimension.NONE);
> /*      */     
> /* 4775 */     BRANCH_FEATURES_NAMES.put("LAST", "Last spot ID");
> /* 4776 */     BRANCH_FEATURES_SHORTNAMES.put("LAST", "Last ID");
> /* 4777 */     BRANCH_FEATURES_ISINTS.put("LAST", Boolean.TRUE);
> /* 4778 */     BRANCH_FEATURES_DIMENSIONS.put("LAST", Dimension.NONE);
> /*      */   }
> /*      */   
> /*      */   private final <K, V> Set<V> getUniqueValues(Iterable<K> keys, Map<K, V> map) {
> /* 4782 */     Set<V> mapping = new LinkedHashSet<>();
> /* 4783 */     for (K key : keys) {
> /* 4784 */       mapping.add(map.get(key));
> /*      */     }
> /* 4786 */     return mapping;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   private static final <K, V> List<K> getCommonKeys(V targetValue, Iterable<K> keys, Map<K, V> map) {
> /* 4791 */     ArrayList<K> foundKeys = new ArrayList<>();
> /* 4792 */     for (K key : keys) {
> /* 4793 */       if (map.get(key).equals(targetValue))
> /* 4794 */         foundKeys.add(key); 
> /*      */     } 
> /* 4796 */     return foundKeys;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   private final String buildPlotTitle(Iterable<String> lYFeatures, Map<String, String> featureNames, String xSelectedSpot) {
> /* 4801 */     StringBuilder sb = new StringBuilder("Plot of ");
> /* 4802 */     Iterator<String> it = lYFeatures.iterator();
> /* 4803 */     sb.append(featureNames.get(it.next()));
> /* 4804 */     while (it.hasNext()) {
> /* 4805 */       sb.append(", ");
> /* 4806 */       sb.append(featureNames.get(it.next()));
> /*      */     } 
> /* 4808 */     sb.append(" vs ");
> /* 4809 */     sb.append(featureNames.get(xSelectedSpot));
> /* 4810 */     sb.append(".");
> /* 4811 */     return sb.toString();
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   private static class NSpotPerFrameDataset
> /*      */     extends ModelDataset
> /*      */   {
> /*      */     private static final long serialVersionUID = 1L;
> /*      */     
> /*      */     private final double[] time;
> /*      */     private final int[] nspots;
> /*      */     
> /*      */     public NSpotPerFrameDataset(Model model, SelectionModel selectionModel, DisplaySettings ds, double[] time, int[] nspots) {
> /* 4824 */       super(model, selectionModel, ds, "POSITION_T", Collections.singletonList("N spots"));
> /* 4825 */       this.time = time;
> /* 4826 */       this.nspots = nspots;
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     public int getItemCount(int series) {
> /* 4831 */       return this.nspots.length;
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     public Number getX(int series, int item) {
> /* 4836 */       return Double.valueOf(this.time[item]);
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     public Number getY(int series, int item) {
> /* 4841 */       return Double.valueOf(this.nspots[item]);
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     public String getSeriesKey(int series) {
> /* 4846 */       return this.yFeatures.get(series);
> /*      */     }
> /*      */ 
> /*      */     
> /*      */     public String getItemLabel(int item) {
> /* 4851 */       return item;
> /*      */     }
> /*      */ 
> /*      */ 
> /*      */     
> /*      */     public void setItemLabel(int item, String label) {}
> /*      */ 
> /*      */     
> /*      */     public XYItemRenderer getRenderer() {
> /* 4860 */       return (XYItemRenderer)new XYLineAndShapeRenderer(true, true);
> /*      */     }
> /*      */   }
> /*      */   
> /*      */   private static final float[] toFloat(double[] d) {
> /* 4865 */     float[] f = new float[d.length];
> /* 4866 */     for (int i = 0; i < f.length; i++)
> /* 4867 */       f[i] = (float)d[i]; 
> /* 4868 */     return f;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public ImagePlus renderND(HyperStackDisplayer displayer, DisplaySettings ds) {
> /* 4873 */     Roi initialROI = displayer.getImp().getRoi();
> /* 4874 */     if (initialROI != null) {
> /* 4875 */       displayer.getImp().killRoi();
> /*      */     }
> /* 4877 */     Overlay overlay = displayer.getImp().getOverlay();
> /* 4878 */     if (overlay == null) {
> /* 4879 */       overlay = new Overlay();
> /* 4880 */       displayer.getImp().setOverlay(overlay);
> /*      */     } 
> /* 4882 */     overlay.clear();
> /*      */     
> /* 4884 */     if (initialROI != null) {
> /* 4885 */       displayer.getImp().getOverlay().add(initialROI);
> /*      */     }
> /* 4887 */     if (displayer != null)
> /* 4888 */       displayer.getImp().updateAndDraw(); 
> /* 4889 */     displayer.getImp().setOpenAsHyperStack(true);
> /*      */ 
> /*      */ 
> /*      */     
> /* 4893 */     displayer.getImp().getOverlay().add((Roi)new SpotOverlay(model, displayer.getImp(), ds));
> /* 4894 */     displayer.getImp().getOverlay().add((Roi)new TrackOverlay(model, displayer.getImp(), ds));
> /* 4895 */     displayer.getImp().updateAndDraw();
> /*      */     
> /* 4897 */     return displayer.getImp();
> /*      */   }
> /*      */   
> /*      */   public static ImagePlus[] stack2images(ImagePlus imp) {
> /* 4901 */     String sLabel = imp.getTitle();
> /* 4902 */     String sImLabel = "";
> /* 4903 */     ImageStack stack = imp.getStack();
> /*      */     
> /* 4905 */     int sz = stack.getSize();
> /* 4906 */     int currentSlice = imp.getCurrentSlice();
> /*      */     
> /* 4908 */     DecimalFormat df = new DecimalFormat("0000");
> /* 4909 */     ImagePlus[] arrayOfImages = new ImagePlus[imp.getStack().getSize()];
> /* 4910 */     for (int n = 1; n <= sz; n++) {
> /* 4911 */       imp.setSlice(n);
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */       
> /* 4916 */       ImageProcessor ip = imp.getProcessor();
> /* 4917 */       ImageProcessor newip = ip.createProcessor(ip.getWidth(), ip.getHeight());
> /* 4918 */       newip.setPixels(ip.getPixelsCopy());
> /*      */ 
> /*      */       
> /* 4921 */       sImLabel = imp.getStack().getSliceLabel(n);
> /* 4922 */       if (sImLabel == null || sImLabel.length() < 1) {
> /* 4923 */         sImLabel = "slice" + df.format(n) + "_" + sLabel;
> /*      */       }
> /*      */       
> /* 4926 */       ImagePlus im = new ImagePlus(sImLabel, newip);
> /* 4927 */       im.setCalibration(imp.getCalibration());
> /* 4928 */       arrayOfImages[n - 1] = im;
> /*      */     } 
> /*      */ 
> /*      */ 
> /*      */ 
> /*      */     
> /* 4934 */     imp.setSlice(currentSlice);
> /* 4935 */     if (imp.isProcessor()) {
> /* 4936 */       ImageProcessor ip = imp.getProcessor();
> /* 4937 */       ip.setPixels(ip.getPixels());
> /*      */     } 
> /* 4939 */     imp.setSlice(currentSlice);
> /* 4940 */     return arrayOfImages;
> /*      */   }
> /*      */ 
> /*      */   
> /*      */   public void exportToCSV(String[][] rowData, String[] titles, File file) {
> /*      */     try {
> /*      */       try {
> /* 4947 */         FileWriter excel = new FileWriter(file); int i;
> /* 4948 */         for (i = 0; i < titles.length; i++) {
> /* 4949 */           excel.write(String.valueOf(titles[i]) + ",");
> /*      */         }
> /* 4951 */         excel.write("\n");
> /* 4952 */         for (i = 0; i < rowData.length; i++) {
> /* 4953 */           for (int j = 0; j < (rowData[i]).length; j++) {
> /* 4954 */             if (j == 11)
> /* 4955 */               excel.write(" ,"); 
> /* 4956 */             if (j != 11) {
> /*      */               
> /* 4958 */               if (rowData[i][j].toString() != null || rowData[i][j].toString() != " ") {
> /* 4959 */                 excel.write(String.valueOf(rowData[i][j].toString()) + ",");
> /*      */               }
> /* 4961 */               if (rowData[i][j].toString() == null || rowData[i][j].toString() == " ") {
> /* 4962 */                 excel.write(" ,");
> /*      */               }
> /*      */             } 
> /*      */           } 
> /*      */           
> /* 4967 */           excel.write("\n");
> /*      */         } 
> /*      */         
> /* 4970 */         excel.close();
> /*      */       }
> /* 4972 */       catch (IOException iOException) {}
> /*      */     
> /*      */     }
> /* 4975 */     catch (NullPointerException nullPointerException) {}
> /*      */   }
> /*      */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/SPTBatch_.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: STScatterPlot$1.java
Only in jd-gui: STScatterPlot$2.java
Only in jd-gui: STScatterPlot$3.java
Only in jd-gui: STScatterPlot$4.java
Only in jd-gui: STScatterPlot$5.java
diff -r TrackAnalyzer_/STScatterPlot.java jd-gui/STScatterPlot.java
1,727c1,883
< import java.awt.BasicStroke;
< import java.awt.Color;
< import java.awt.Dimension;
< import java.awt.Font;
< import java.awt.Paint;
< import java.awt.Shape;
< import java.util.ArrayList;
< import java.util.Collections;
< import java.util.List;
< import javax.swing.JLabel;
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.JFreeChart;
< import org.jfree.chart.annotations.XYTitleAnnotation;
< import org.jfree.chart.axis.NumberAxis;
< import org.jfree.chart.block.BlockBorder;
< import org.jfree.chart.plot.DefaultDrawingSupplier;
< import org.jfree.chart.plot.IntervalMarker;
< import org.jfree.chart.plot.PlotOrientation;
< import org.jfree.chart.plot.XYPlot;
< import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
< import org.jfree.chart.title.TextTitle;
< import org.jfree.chart.ui.HorizontalAlignment;
< import org.jfree.chart.ui.RectangleAnchor;
< import org.jfree.chart.ui.RectangleEdge;
< import org.jfree.data.function.Function2D;
< import org.jfree.data.function.LineFunction2D;
< import org.jfree.data.function.PowerFunction2D;
< import org.jfree.data.general.DatasetUtils;
< import org.jfree.data.statistics.Regression;
< import org.jfree.data.xy.XYDataset;
< import org.jfree.data.xy.XYSeries;
< import org.jfree.data.xy.XYSeriesCollection;
< import org.jfree.ui.ApplicationFrame;
< 
< public class STScatterPlot extends ApplicationFrame {
<    private XYDataset data1;
<    List<Double> valuesDomain;
<    List<Double> valuesRange;
<    IntervalMarker markerRange;
<    IntervalMarker markerDomain;
<    String domainName;
<    String rangeName;
<    Object[][] data;
<    Color[] classColor;
<    String label1;
<    String label2;
<    XYSeriesCollection dataset;
<    static XYPlot plot;
<    ChartPanel panel;
<    XYSeries series1;
<    XYLineAndShapeRenderer renderer;
<    double maxDomain;
<    int filterOrder;
< 
<    public STScatterPlot(String title) {
<       super(title);
<    }
< 
<    public ChartPanel createChartPanelPolynomial() {
<       return null;
<    }
< 
<    public ChartPanel createScatterChartPanelInitial(String label1, String label2, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] dataCh2, Double[][] dataCh3) {
<       this.label1 = label1;
<       this.label2 = label2;
<       this.valuesDomain = valuesDomain;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.dataset = new XYSeriesCollection();
<       XYSeries series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(series1);
<       JFreeChart chart = ChartFactory.createScatterPlot("", "", "", this.dataset);
<       plot = (XYPlot)chart.getPlot();
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       this.panel = new ChartPanel(chart, false);
<       this.panel.setMaximumDrawWidth(4000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setVisible(false);
<       this.panel.setMouseWheelEnabled(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       Font font3 = new Font("Dialog", 2, 9);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       return this.panel;
<    }
< 
<    public void addScatterPlotSeriesLinear(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
<       this.valuesDomain = valuesDomain;
<       this.rangeName = rangeName;
<       this.domainName = domainName;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.classColor = classColor;
<       this.panel.removeAll();
<       this.dataset = new XYSeriesCollection();
<       this.series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(this.series1);
<       double minDomain = (Double)Collections.min(valuesDomain);
<       double maxDomain = (Double)Collections.max(valuesDomain);
<       double[] coefficients = Regression.getOLSRegression(this.dataset, 0);
<       Function2D curve = new LineFunction2D(coefficients[0], coefficients[1]);
<       XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), "Fitted Regression Line");
<       JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       plot = (XYPlot)chart.getPlot();
<       XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
<       plot.setRenderer(renderer1);
<       plot.setBackgroundPaint(new Color(255, 228, 196));
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       plot.setDataset(1, regressionData);
<       XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
<       renderer2.setSeriesPaint(0, Color.RED);
<       plot.setRenderer(1, renderer2);
<       Shape cross = new java.awt.geom.Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
<       List<String[]> featureLists = new ArrayList();
< 
<       for(int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
<          featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(i, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
<       }
< 
<       this.renderer = new XYLineAndShapeRenderer() {
<          public Paint getItemPaint(int row, int col) {
<             Paint cpaint = this.getItemColor(row, col);
<             if (cpaint == null) {
<                cpaint = super.getItemPaint(row, col);
<             }
< 
<             return (Paint)cpaint;
<          }
< 
<          public Color getItemColor(int row, int col) {
<             STScatterPlot.this.dataset.getXValue(row, col);
<             STScatterPlot.this.dataset.getYValue(row, col);
< 
<             try {
<                return classColor[col];
<             } catch (Exception var8) {
<                return null;
<             }
<          }
<       };
<       plot.setRenderer(this.renderer);
<       this.renderer.setUseOutlinePaint(true);
<       this.renderer.setSeriesShape(0, cross);
<       this.renderer.setSeriesOutlinePaint(0, Color.black);
<       this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
<       this.renderer.setSeriesLinesVisible(0, false);
<       this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
<       plot.getRangeCrosshairValue();
<       plot.getDomainCrosshairValue();
<       this.panel.setChart(chart);
<       this.panel.setMaximumDrawWidth(6000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       this.panel.setMouseWheelEnabled(true);
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       markerRange.setLabel("Low-High");
<       markerRange.setLabelFont(new Font("SansSerif", 0, 15));
<       markerRange.setLabelPaint(new Color(0, 102, 0));
<       Font font3 = new Font("Dialog", 1, 12);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       NumberAxis domain = (NumberAxis)plot.getDomainAxis();
<       NumberAxis range = (NumberAxis)plot.getRangeAxis();
<       domain.setAutoRange(true);
<       range.setAutoRange(true);
<       this.computeLinearCoefficients(chart, plot, this.dataset);
<    }
< 
<    public void addScatterPlotSeriesPower(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
<       this.valuesDomain = valuesDomain;
<       this.rangeName = rangeName;
<       this.domainName = domainName;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.classColor = classColor;
<       this.panel.removeAll();
<       this.dataset = new XYSeriesCollection();
<       this.series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(this.series1);
<       double minDomain = (Double)Collections.min(valuesDomain);
<       double maxDomain = (Double)Collections.max(valuesDomain);
<       double[] coefficients = Regression.getPowerRegression(this.dataset, 0);
<       Function2D curve = new PowerFunction2D(coefficients[0], coefficients[1]);
<       XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), "Fitted Regression Line");
<       JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       plot = (XYPlot)chart.getPlot();
<       XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
<       plot.setRenderer(renderer1);
<       plot.setBackgroundPaint(new Color(255, 228, 196));
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       plot.setDataset(1, regressionData);
<       XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
<       renderer2.setSeriesPaint(0, Color.RED);
<       plot.setRenderer(1, renderer2);
<       Shape cross = new java.awt.geom.Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
<       List<String[]> featureLists = new ArrayList();
< 
<       for(int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
<          featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(i, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
<       }
< 
<       this.renderer = new XYLineAndShapeRenderer() {
<          public Paint getItemPaint(int row, int col) {
<             Paint cpaint = this.getItemColor(row, col);
<             if (cpaint == null) {
<                cpaint = super.getItemPaint(row, col);
<             }
< 
<             return (Paint)cpaint;
<          }
< 
<          public Color getItemColor(int row, int col) {
<             STScatterPlot.this.dataset.getXValue(row, col);
<             STScatterPlot.this.dataset.getYValue(row, col);
< 
<             try {
<                return classColor[col];
<             } catch (Exception var8) {
<                return null;
<             }
<          }
<       };
<       plot.setRenderer(this.renderer);
<       this.renderer.setUseOutlinePaint(true);
<       this.renderer.setSeriesShape(0, cross);
<       this.renderer.setSeriesOutlinePaint(0, Color.black);
<       this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
<       this.renderer.setSeriesLinesVisible(0, false);
<       this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
<       plot.getRangeCrosshairValue();
<       plot.getDomainCrosshairValue();
<       this.panel.setChart(chart);
<       this.panel.setMaximumDrawWidth(6000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       markerRange.setLabel("Low-High");
<       markerRange.setLabelFont(new Font("SansSerif", 0, 15));
<       markerRange.setLabelPaint(new Color(0, 102, 0));
<       Font font3 = new Font("Dialog", 1, 12);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       NumberAxis domain = (NumberAxis)plot.getDomainAxis();
<       NumberAxis range = (NumberAxis)plot.getRangeAxis();
<       domain.setAutoRange(true);
<       range.setAutoRange(true);
<       this.computePowerCoefficients(chart, plot, this.dataset);
<    }
< 
<    public void addScatterPlotSeriesPolynomial(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor, int filterOrder) {
<       this.valuesDomain = valuesDomain;
<       this.rangeName = rangeName;
<       this.domainName = domainName;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.classColor = classColor;
<       this.filterOrder = filterOrder;
<       this.panel.removeAll();
<       this.dataset = new XYSeriesCollection();
<       this.series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(this.series1);
<       double minDomain = (Double)Collections.min(valuesDomain);
<       double maxDomain = (Double)Collections.max(valuesDomain);
<       double[] coefficients = Regression.getPolynomialRegression(this.dataset, 0, filterOrder);
<       Function2D curve = new PowerFunction2D(coefficients[0], coefficients[1]);
<       XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), "Fitted Regression Line");
<       JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       plot = (XYPlot)chart.getPlot();
<       XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
<       plot.setRenderer(renderer1);
<       plot.setBackgroundPaint(new Color(255, 228, 196));
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       plot.setDataset(1, regressionData);
<       XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
<       renderer2.setSeriesPaint(0, Color.RED);
<       plot.setRenderer(1, renderer2);
<       Shape cross = new java.awt.geom.Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
<       List<String[]> featureLists = new ArrayList();
< 
<       for(int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
<          featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(i, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
<       }
< 
<       this.renderer = new XYLineAndShapeRenderer() {
<          public Paint getItemPaint(int row, int col) {
<             Paint cpaint = this.getItemColor(row, col);
<             if (cpaint == null) {
<                cpaint = super.getItemPaint(row, col);
<             }
< 
<             return (Paint)cpaint;
<          }
< 
<          public Color getItemColor(int row, int col) {
<             STScatterPlot.this.dataset.getXValue(row, col);
<             STScatterPlot.this.dataset.getYValue(row, col);
< 
<             try {
<                return classColor[col];
<             } catch (Exception var8) {
<                return null;
<             }
<          }
<       };
<       plot.setRenderer(this.renderer);
<       this.renderer.setUseOutlinePaint(true);
<       this.renderer.setSeriesShape(0, cross);
<       this.renderer.setSeriesOutlinePaint(0, Color.black);
<       this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
<       this.renderer.setSeriesLinesVisible(0, false);
<       this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
<       plot.getRangeCrosshairValue();
<       plot.getDomainCrosshairValue();
<       this.panel.setChart(chart);
<       this.panel.setMaximumDrawWidth(6000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       markerRange.setLabel("Low-High");
<       markerRange.setLabelFont(new Font("SansSerif", 0, 15));
<       markerRange.setLabelPaint(new Color(0, 102, 0));
<       Font font3 = new Font("Dialog", 1, 12);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       NumberAxis domain = (NumberAxis)plot.getDomainAxis();
<       NumberAxis range = (NumberAxis)plot.getRangeAxis();
<       domain.setAutoRange(true);
<       range.setAutoRange(true);
<       this.computePolynomialCoefficients(chart, plot, this.dataset, filterOrder);
<    }
< 
<    public void addScatterPlotSeriesLogarithmic(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
<       this.valuesDomain = valuesDomain;
<       this.rangeName = rangeName;
<       this.domainName = domainName;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.classColor = classColor;
<       this.filterOrder = this.filterOrder;
<       this.panel.removeAll();
<       this.dataset = new XYSeriesCollection();
<       this.series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(this.series1);
<       double minDomain = (Double)Collections.min(valuesDomain);
<       double maxDomain = (Double)Collections.max(valuesDomain);
<       double[] coefficients = RegressionLE_.getLogarithmicRegression(this.dataset, 0);
<       Function2D curve = new LogarithmicFunction2D(coefficients[0], coefficients[1]);
<       XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), "Fitted Regression Line");
<       JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       plot = (XYPlot)chart.getPlot();
<       XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
<       plot.setRenderer(renderer1);
<       plot.setBackgroundPaint(new Color(255, 228, 196));
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       plot.setDataset(1, regressionData);
<       XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
<       renderer2.setSeriesPaint(0, Color.RED);
<       plot.setRenderer(1, renderer2);
<       Shape cross = new java.awt.geom.Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
<       List<String[]> featureLists = new ArrayList();
< 
<       for(int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
<          featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(i, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
<       }
< 
<       this.renderer = new XYLineAndShapeRenderer() {
<          public Paint getItemPaint(int row, int col) {
<             Paint cpaint = this.getItemColor(row, col);
<             if (cpaint == null) {
<                cpaint = super.getItemPaint(row, col);
<             }
< 
<             return (Paint)cpaint;
<          }
< 
<          public Color getItemColor(int row, int col) {
<             STScatterPlot.this.dataset.getXValue(row, col);
<             STScatterPlot.this.dataset.getYValue(row, col);
< 
<             try {
<                return classColor[col];
<             } catch (Exception var8) {
<                return null;
<             }
<          }
<       };
<       plot.setRenderer(this.renderer);
<       this.renderer.setUseOutlinePaint(true);
<       this.renderer.setSeriesShape(0, cross);
<       this.renderer.setSeriesOutlinePaint(0, Color.black);
<       this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
<       this.renderer.setSeriesLinesVisible(0, false);
<       this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
<       plot.getRangeCrosshairValue();
<       plot.getDomainCrosshairValue();
<       this.panel.setChart(chart);
<       this.panel.setMaximumDrawWidth(6000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       markerRange.setLabel("Low-High");
<       markerRange.setLabelFont(new Font("SansSerif", 0, 15));
<       markerRange.setLabelPaint(new Color(0, 102, 0));
<       Font font3 = new Font("Dialog", 1, 12);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       NumberAxis domain = (NumberAxis)plot.getDomainAxis();
<       NumberAxis range = (NumberAxis)plot.getRangeAxis();
<       domain.setAutoRange(true);
<       range.setAutoRange(true);
<       this.computeLogarithmicCoefficients(chart, plot, this.dataset, this.filterOrder);
<    }
< 
<    public void addScatterPlotSeriesExponential(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
<       this.valuesDomain = valuesDomain;
<       this.rangeName = rangeName;
<       this.domainName = domainName;
<       this.valuesRange = valuesRange;
<       this.markerRange = markerRange;
<       this.markerDomain = markerDomain;
<       this.classColor = classColor;
<       this.filterOrder = this.filterOrder;
<       this.panel.removeAll();
<       this.dataset = new XYSeriesCollection();
<       this.series1 = new XYSeries("");
< 
<       for(int i = 0; i < valuesDomain.size(); ++i) {
<          this.series1.add((Number)valuesDomain.get(i), (Number)valuesRange.get(i));
<       }
< 
<       this.dataset.addSeries(this.series1);
<       double minDomain = (Double)Collections.min(valuesDomain);
<       double maxDomain = (Double)Collections.max(valuesDomain);
<       double[] coefficients = RegressionLE_.getExponentialRegression(this.dataset, 0);
<       Function2D curve = new ExponentialFunction2D(coefficients[0], coefficients[1]);
<       XYDataset regressionData = DatasetUtils.sampleFunction2D(curve, minDomain, maxDomain, valuesDomain.size(), "Fitted Regression Line");
<       JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, this.dataset, PlotOrientation.VERTICAL, true, true, false);
<       plot = (XYPlot)chart.getPlot();
<       XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
<       plot.setRenderer(renderer1);
<       plot.setBackgroundPaint(new Color(255, 228, 196));
<       Paint[] paintArray = new Paint[]{new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true)};
<       plot.setDrawingSupplier(new DefaultDrawingSupplier(paintArray, DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
<       plot.setDataset(1, regressionData);
<       XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
<       renderer2.setSeriesPaint(0, Color.RED);
<       plot.setRenderer(1, renderer2);
<       Shape cross = new java.awt.geom.Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
<       List<String[]> featureLists = new ArrayList();
< 
<       for(int i = 0; i < ColorEditorSpot.tableC.getModel().getRowCount(); ++i) {
<          featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(i, ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "").split("<br>"));
<       }
< 
<       this.renderer = new XYLineAndShapeRenderer() {
<          public Paint getItemPaint(int row, int col) {
<             Paint cpaint = this.getItemColor(row, col);
<             if (cpaint == null) {
<                cpaint = super.getItemPaint(row, col);
<             }
< 
<             return (Paint)cpaint;
<          }
< 
<          public Color getItemColor(int row, int col) {
<             STScatterPlot.this.dataset.getXValue(row, col);
<             STScatterPlot.this.dataset.getYValue(row, col);
< 
<             try {
<                return classColor[col];
<             } catch (Exception var8) {
<                return null;
<             }
<          }
<       };
<       plot.setRenderer(this.renderer);
<       this.renderer.setUseOutlinePaint(true);
<       this.renderer.setSeriesShape(0, cross);
<       this.renderer.setSeriesOutlinePaint(0, Color.black);
<       this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
<       this.renderer.setSeriesLinesVisible(0, false);
<       this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
<       plot.getRangeCrosshairValue();
<       plot.getDomainCrosshairValue();
<       this.panel.setChart(chart);
<       this.panel.setMaximumDrawWidth(6000);
<       this.panel.setPreferredSize(new Dimension(450, 300));
<       chart.setBackgroundPaint(new Color(255, 255, 255, 0));
<       plot.setBackgroundPaint(new Color(255, 255, 255, 0));
<       chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
<       this.panel.setMouseWheelEnabled(true);
<       chart.getLegend().setVisible(true);
<       plot.addRangeMarker(markerRange);
<       plot.addDomainMarker(markerDomain);
<       markerRange.setLabel("Low-High");
<       markerRange.setLabelFont(new Font("SansSerif", 0, 15));
<       markerRange.setLabelPaint(new Color(0, 102, 0));
<       Font font3 = new Font("Dialog", 1, 12);
<       plot.getDomainAxis().setLabelFont(font3);
<       plot.getRangeAxis().setLabelFont(font3);
<       plot.getRangeAxis().setTickLabelFont(font3);
<       plot.getDomainAxis().setTickLabelFont(font3);
<       NumberAxis domain = (NumberAxis)plot.getDomainAxis();
<       NumberAxis range = (NumberAxis)plot.getRangeAxis();
<       domain.setAutoRange(true);
<       range.setAutoRange(true);
<       this.computeExponentialCoefficients(chart, plot, this.dataset, this.filterOrder);
<    }
< 
<    private void computeLinearCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset) {
<       Function2D retVal = null;
<       double r2 = 0.0D;
<       double[] coefficients = null;
< 
<       try {
<          coefficients = RegressionLE_.getOLSRegression(dataset, 0);
<          new LineFunction2D(coefficients[0], coefficients[1]);
<          r2 = coefficients[2];
<       } catch (Exception var15) {
<          System.err.println(var15.getMessage());
<       }
< 
<       double intercept = coefficients[0];
<       double slope = coefficients[1];
<       String linearEquation;
<       if (intercept >= 0.0D) {
<          linearEquation = "y = " + String.format("%.2f", slope) + "x + " + String.format("%.2f", intercept);
<       } else {
<          linearEquation = "y = " + String.format("%.2f", slope) + "x - " + Math.abs(intercept);
<       }
< 
<       TextTitle tt = new TextTitle(linearEquation + "\nR = " + String.format("%.2f", r2));
<       tt.setTextAlignment(HorizontalAlignment.RIGHT);
<       tt.setFont(chart.getLegend().getItemFont());
<       tt.setBackgroundPaint(new Color(200, 200, 255, 100));
<       tt.setFrame(new BlockBorder(Color.white));
<       tt.setPosition(RectangleEdge.BOTTOM);
<       XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, tt, RectangleAnchor.BOTTOM_RIGHT);
<       r2Annotation.setMaxWidth(0.48D);
<       plot.addAnnotation(r2Annotation);
<    }
< 
<    private void computePowerCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset) {
<       Function2D retVal = null;
<       double r2 = 0.0D;
<       double[] coefficients = null;
< 
<       try {
<          coefficients = RegressionLE_.getPowerRegression(dataset, 0);
<          if (coefficients[2] > r2) {
<             new PowerFunction2D(coefficients[0], coefficients[1]);
<             r2 = coefficients[2];
<          }
<       } catch (Exception var15) {
<          System.err.println(var15.getMessage());
<       }
< 
<       double intercept = coefficients[0];
<       double slope = coefficients[1];
<       String linearEquation;
<       if (intercept >= 0.0D) {
<          linearEquation = "y = " + String.format("%.2f", slope) + "x^ " + String.format("%.2f", intercept);
<       } else {
<          linearEquation = "y = " + String.format("%.2f", slope) + "x^ -" + Math.abs(intercept);
<       }
< 
<       TextTitle tt = new TextTitle(linearEquation + "\nR = " + String.format("%.2f", r2));
<       tt.setTextAlignment(HorizontalAlignment.RIGHT);
<       tt.setFont(chart.getLegend().getItemFont());
<       tt.setBackgroundPaint(new Color(200, 200, 255, 100));
<       tt.setFrame(new BlockBorder(Color.white));
<       tt.setPosition(RectangleEdge.BOTTOM);
<       XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, tt, RectangleAnchor.BOTTOM_RIGHT);
<       r2Annotation.setMaxWidth(0.48D);
<       plot.addAnnotation(r2Annotation);
<    }
< 
<    private void computePolynomialCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset, int filterOrder) {
<       double[] coefficients = Regression.getPolynomialRegression(dataset, 0, filterOrder);
<       double r2 = coefficients[coefficients.length - 1];
<       String polynomialEquation = "";
< 
<       for(int i = coefficients.length - 1; i >= 0; --i) {
<          if (i == 0) {
<             polynomialEquation = polynomialEquation + String.format("%.2f", coefficients[i]);
<          } else if (i == 1) {
<             polynomialEquation = polynomialEquation + String.format("%.2f", coefficients[i]) + "*x+";
<          } else if (i > 1) {
<             polynomialEquation = polynomialEquation + String.format("%.2f", coefficients[i]) + "*x^" + i + "+";
<          }
<       }
< 
<       TextTitle tt = new TextTitle("y = " + polynomialEquation + "\nR = " + String.format("%.2f", r2));
<       tt.setTextAlignment(HorizontalAlignment.RIGHT);
<       tt.setFont(chart.getLegend().getItemFont());
<       tt.setBackgroundPaint(new Color(200, 200, 255, 100));
<       tt.setFrame(new BlockBorder(Color.white));
<       tt.setPosition(RectangleEdge.BOTTOM);
<       XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, tt, RectangleAnchor.BOTTOM_RIGHT);
<       r2Annotation.setMaxWidth(0.48D);
<       plot.addAnnotation(r2Annotation);
<    }
< 
<    private void computeLogarithmicCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset, int filterOrder) {
<       Function2D retVal = null;
<       double r2 = 0.0D;
<       double[] coefficients = null;
< 
<       try {
<          coefficients = RegressionLE_.getLogarithmicRegression(dataset, 0);
<          if (coefficients[2] > r2) {
<             new LogarithmicFunction2D(coefficients[0], coefficients[1]);
<             r2 = coefficients[2];
<          }
<       } catch (Exception var12) {
<          System.err.println(var12.getMessage());
<       }
< 
<       String logarithmicEquation = "y = " + String.format("%.2f", coefficients[0]) + " + " + "( " + String.format("%.2f", coefficients[1]) + " * ln(x) ) ";
<       TextTitle tt = new TextTitle("y = " + logarithmicEquation + "\nR = " + String.format("%.2f", r2));
<       tt.setTextAlignment(HorizontalAlignment.RIGHT);
<       tt.setFont(chart.getLegend().getItemFont());
<       tt.setBackgroundPaint(new Color(200, 200, 255, 100));
<       tt.setFrame(new BlockBorder(Color.white));
<       tt.setPosition(RectangleEdge.BOTTOM);
<       XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, tt, RectangleAnchor.BOTTOM_RIGHT);
<       r2Annotation.setMaxWidth(0.48D);
<       plot.addAnnotation(r2Annotation);
<    }
< 
<    private void computeExponentialCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset, int filterOrder) {
<       Function2D retVal = null;
<       double r2 = 0.0D;
<       double[] coefficients = null;
< 
<       try {
<          coefficients = RegressionLE_.getExponentialRegression(dataset, 0);
<          if (coefficients[2] > r2) {
<             new LogarithmicFunction2D(coefficients[0], coefficients[1]);
<             r2 = coefficients[2];
<          }
<       } catch (Exception var12) {
<          System.err.println(var12.getMessage());
<       }
< 
<       String exponentialEquation = "y = " + String.format("%.2f", coefficients[0]) + " * " + "( e^(" + String.format("%.2f", coefficients[1]) + " * x) ) ";
<       TextTitle tt = new TextTitle("y = " + exponentialEquation + "\nR = " + String.format("%.2f", r2));
<       tt.setTextAlignment(HorizontalAlignment.RIGHT);
<       tt.setFont(chart.getLegend().getItemFont());
<       tt.setBackgroundPaint(new Color(200, 200, 255, 100));
<       tt.setFrame(new BlockBorder(Color.white));
<       tt.setPosition(RectangleEdge.BOTTOM);
<       XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, tt, RectangleAnchor.BOTTOM_RIGHT);
<       r2Annotation.setMaxWidth(0.48D);
<       plot.addAnnotation(r2Annotation);
<    }
< }
---
> /*     */ import java.awt.BasicStroke;
> /*     */ import java.awt.Color;
> /*     */ import java.awt.Dimension;
> /*     */ import java.awt.Font;
> /*     */ import java.awt.Paint;
> /*     */ import java.awt.Shape;
> /*     */ import java.awt.geom.Ellipse2D;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.Collections;
> /*     */ import java.util.List;
> /*     */ import javax.swing.JLabel;
> /*     */ import org.jfree.chart.ChartFactory;
> /*     */ import org.jfree.chart.ChartPanel;
> /*     */ import org.jfree.chart.JFreeChart;
> /*     */ import org.jfree.chart.annotations.XYAnnotation;
> /*     */ import org.jfree.chart.annotations.XYTitleAnnotation;
> /*     */ import org.jfree.chart.axis.NumberAxis;
> /*     */ import org.jfree.chart.block.BlockBorder;
> /*     */ import org.jfree.chart.block.BlockFrame;
> /*     */ import org.jfree.chart.plot.DefaultDrawingSupplier;
> /*     */ import org.jfree.chart.plot.DrawingSupplier;
> /*     */ import org.jfree.chart.plot.IntervalMarker;
> /*     */ import org.jfree.chart.plot.Marker;
> /*     */ import org.jfree.chart.plot.PlotOrientation;
> /*     */ import org.jfree.chart.plot.XYPlot;
> /*     */ import org.jfree.chart.renderer.xy.XYItemRenderer;
> /*     */ import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
> /*     */ import org.jfree.chart.title.TextTitle;
> /*     */ import org.jfree.chart.title.Title;
> /*     */ import org.jfree.chart.ui.HorizontalAlignment;
> /*     */ import org.jfree.chart.ui.RectangleAnchor;
> /*     */ import org.jfree.chart.ui.RectangleEdge;
> /*     */ import org.jfree.data.function.Function2D;
> /*     */ import org.jfree.data.function.LineFunction2D;
> /*     */ import org.jfree.data.function.PowerFunction2D;
> /*     */ import org.jfree.data.general.DatasetUtils;
> /*     */ import org.jfree.data.statistics.Regression;
> /*     */ import org.jfree.data.xy.XYDataset;
> /*     */ import org.jfree.data.xy.XYSeries;
> /*     */ import org.jfree.data.xy.XYSeriesCollection;
> /*     */ import org.jfree.ui.ApplicationFrame;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class STScatterPlot
> /*     */   extends ApplicationFrame
> /*     */ {
> /*     */   private XYDataset data1;
> /*     */   List<Double> valuesDomain;
> /*     */   List<Double> valuesRange;
> /*     */   IntervalMarker markerRange;
> /*     */   IntervalMarker markerDomain;
> /*     */   String domainName;
> /*     */   String rangeName;
> /*     */   Object[][] data;
> /*     */   Color[] classColor;
> /*     */   String label1;
> /*     */   String label2;
> /*     */   XYSeriesCollection dataset;
> /*     */   static XYPlot plot;
> /*     */   ChartPanel panel;
> /*     */   XYSeries series1;
> /*     */   XYLineAndShapeRenderer renderer;
> /*     */   double maxDomain;
> /*     */   int filterOrder;
> /*     */   
> /*     */   public STScatterPlot(String title) {
> /*  71 */     super(title);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public ChartPanel createChartPanelPolynomial() {
> /*  76 */     return null;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ChartPanel createScatterChartPanelInitial(String label1, String label2, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] dataCh2, Double[][] dataCh3) {
> /*  88 */     this.label1 = label1;
> /*  89 */     this.label2 = label2;
> /*  90 */     this.valuesDomain = valuesDomain;
> /*  91 */     this.valuesRange = valuesRange;
> /*  92 */     this.markerRange = markerRange;
> /*  93 */     this.markerDomain = markerDomain;
> /*     */     
> /*  95 */     this.dataset = new XYSeriesCollection();
> /*  96 */     XYSeries series1 = new XYSeries("");
> /*  97 */     for (int i = 0; i < valuesDomain.size(); i++)
> /*  98 */       series1.add(valuesDomain.get(i), valuesRange.get(i)); 
> /*  99 */     this.dataset.addSeries(series1);
> /*     */ 
> /*     */     
> /* 102 */     JFreeChart chart = ChartFactory.createScatterPlot("", "", "", (XYDataset)this.dataset);
> /*     */ 
> /*     */     
> /* 105 */     plot = (XYPlot)chart.getPlot();
> /* 106 */     Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
> /* 107 */     plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, 
> /* 108 */           DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, 
> /* 109 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, 
> /* 110 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
> /* 111 */     this.panel = new ChartPanel(chart, false);
> /* 112 */     this.panel.setMaximumDrawWidth(4000);
> /* 113 */     this.panel.setPreferredSize(new Dimension(450, 300));
> /* 114 */     chart.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 115 */     plot.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 116 */     chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 117 */     chart.getLegend().setVisible(false);
> /* 118 */     this.panel.setMouseWheelEnabled(true);
> /* 119 */     plot.addRangeMarker((Marker)markerRange);
> /* 120 */     plot.addDomainMarker((Marker)markerDomain);
> /*     */     
> /* 122 */     Font font3 = new Font("Dialog", 2, 9);
> /* 123 */     plot.getDomainAxis().setLabelFont(font3);
> /* 124 */     plot.getRangeAxis().setLabelFont(font3);
> /* 125 */     plot.getRangeAxis().setTickLabelFont(font3);
> /* 126 */     plot.getDomainAxis().setTickLabelFont(font3);
> /* 127 */     return this.panel;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void addScatterPlotSeriesLinear(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
> /* 134 */     this.valuesDomain = valuesDomain;
> /* 135 */     this.rangeName = rangeName;
> /* 136 */     this.domainName = domainName;
> /* 137 */     this.valuesRange = valuesRange;
> /* 138 */     this.markerRange = markerRange;
> /* 139 */     this.markerDomain = markerDomain;
> /*     */ 
> /*     */     
> /* 142 */     this.classColor = classColor;
> /*     */     
> /* 144 */     this.panel.removeAll();
> /* 145 */     this.dataset = new XYSeriesCollection();
> /* 146 */     this.series1 = new XYSeries("");
> /* 147 */     for (int i = 0; i < valuesDomain.size(); i++)
> /* 148 */       this.series1.add(valuesDomain.get(i), valuesRange.get(i)); 
> /* 149 */     this.dataset.addSeries(this.series1);
> /* 150 */     double minDomain = ((Double)Collections.<Double>min(valuesDomain)).doubleValue();
> /* 151 */     double maxDomain = ((Double)Collections.<Double>max(valuesDomain)).doubleValue();
> /* 152 */     double[] coefficients = Regression.getOLSRegression((XYDataset)this.dataset, 0);
> /* 153 */     LineFunction2D lineFunction2D = new LineFunction2D(coefficients[0], coefficients[1]);
> /* 154 */     XYDataset regressionData = DatasetUtils.sampleFunction2D((Function2D)lineFunction2D, minDomain, maxDomain, valuesDomain.size(), 
> /* 155 */         "Fitted Regression Line");
> /*     */     
> /* 157 */     JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, (XYDataset)this.dataset, PlotOrientation.VERTICAL, 
> /* 158 */         true, true, false);
> /*     */     
> /* 160 */     plot = (XYPlot)chart.getPlot();
> /* 161 */     XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
> /* 162 */     plot.setRenderer((XYItemRenderer)renderer1);
> /* 163 */     plot.setBackgroundPaint(new Color(255, 228, 196));
> /* 164 */     Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
> /* 165 */     plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, 
> /* 166 */           DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, 
> /* 167 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, 
> /* 168 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
> /* 169 */     plot.setDataset(1, regressionData);
> /* 170 */     XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
> /* 171 */     renderer2.setSeriesPaint(0, Color.RED);
> /* 172 */     plot.setRenderer(1, (XYItemRenderer)renderer2);
> /* 173 */     Shape cross = new Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
> /* 174 */     List<String[]> featureLists = (List)new ArrayList<>();
> /* 175 */     for (int j = 0; j < ColorEditorSpot.tableC.getModel().getRowCount(); j++) {
> /* 176 */       featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(j, 
> /* 177 */             ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "")
> /* 178 */           .split("<br>"));
> /*     */     }
> /* 180 */     this.renderer = new XYLineAndShapeRenderer()
> /*     */       {
> /*     */         public Paint getItemPaint(int row, int col) {
> /* 183 */           Paint cpaint = getItemColor(row, col);
> /* 184 */           if (cpaint == null) {
> /* 185 */             cpaint = super.getItemPaint(row, col);
> /*     */           }
> /* 187 */           return cpaint;
> /*     */         }
> /*     */         
> /*     */         public Color getItemColor(int row, int col) {
> /* 191 */           double x = STScatterPlot.this.dataset.getXValue(row, col);
> /* 192 */           double y = STScatterPlot.this.dataset.getYValue(row, col);
> /*     */           
> /*     */           try {
> /* 195 */             return classColor[col];
> /* 196 */           } catch (Exception exception) {
> /*     */ 
> /*     */ 
> /*     */             
> /* 200 */             return null;
> /*     */           } 
> /*     */         }
> /*     */       };
> /*     */     
> /* 205 */     plot.setRenderer((XYItemRenderer)this.renderer);
> /* 206 */     this.renderer.setUseOutlinePaint(true);
> /* 207 */     this.renderer.setSeriesShape(0, cross);
> /* 208 */     this.renderer.setSeriesOutlinePaint(0, Color.black);
> /* 209 */     this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
> /* 210 */     this.renderer.setSeriesLinesVisible(0, false);
> /* 211 */     this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
> /* 212 */     plot.getRangeCrosshairValue();
> /* 213 */     plot.getDomainCrosshairValue();
> /*     */ 
> /*     */     
> /* 216 */     this.panel.setChart(chart);
> /* 217 */     this.panel.setMaximumDrawWidth(6000);
> /* 218 */     this.panel.setPreferredSize(new Dimension(450, 300));
> /* 219 */     this.panel.setMouseWheelEnabled(true);
> /* 220 */     chart.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 221 */     plot.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 222 */     chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 223 */     this.panel.setMouseWheelEnabled(true);
> /* 224 */     chart.getLegend().setVisible(true);
> /* 225 */     plot.addRangeMarker((Marker)markerRange);
> /* 226 */     plot.addDomainMarker((Marker)markerDomain);
> /* 227 */     markerRange.setLabel("Low-High");
> /* 228 */     markerRange.setLabelFont(new Font("SansSerif", 0, 15));
> /* 229 */     markerRange.setLabelPaint(new Color(0, 102, 0));
> /*     */     
> /* 231 */     Font font3 = new Font("Dialog", 1, 12);
> /* 232 */     plot.getDomainAxis().setLabelFont(font3);
> /* 233 */     plot.getRangeAxis().setLabelFont(font3);
> /* 234 */     plot.getRangeAxis().setTickLabelFont(font3);
> /* 235 */     plot.getDomainAxis().setTickLabelFont(font3);
> /*     */     
> /* 237 */     NumberAxis domain = (NumberAxis)plot.getDomainAxis();
> /*     */     
> /* 239 */     NumberAxis range = (NumberAxis)plot.getRangeAxis();
> /*     */     
> /* 241 */     domain.setAutoRange(true);
> /* 242 */     range.setAutoRange(true);
> /* 243 */     computeLinearCoefficients(chart, plot, this.dataset);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void addScatterPlotSeriesPower(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
> /* 251 */     this.valuesDomain = valuesDomain;
> /* 252 */     this.rangeName = rangeName;
> /* 253 */     this.domainName = domainName;
> /* 254 */     this.valuesRange = valuesRange;
> /* 255 */     this.markerRange = markerRange;
> /* 256 */     this.markerDomain = markerDomain;
> /*     */ 
> /*     */     
> /* 259 */     this.classColor = classColor;
> /* 260 */     this.panel.removeAll();
> /* 261 */     this.dataset = new XYSeriesCollection();
> /* 262 */     this.series1 = new XYSeries("");
> /* 263 */     for (int i = 0; i < valuesDomain.size(); i++)
> /* 264 */       this.series1.add(valuesDomain.get(i), valuesRange.get(i)); 
> /* 265 */     this.dataset.addSeries(this.series1);
> /*     */     
> /* 267 */     double minDomain = ((Double)Collections.<Double>min(valuesDomain)).doubleValue();
> /* 268 */     double maxDomain = ((Double)Collections.<Double>max(valuesDomain)).doubleValue();
> /* 269 */     double[] coefficients = Regression.getPowerRegression((XYDataset)this.dataset, 0);
> /* 270 */     PowerFunction2D powerFunction2D = new PowerFunction2D(coefficients[0], coefficients[1]);
> /* 271 */     XYDataset regressionData = DatasetUtils.sampleFunction2D((Function2D)powerFunction2D, minDomain, maxDomain, valuesDomain.size(), 
> /* 272 */         "Fitted Regression Line");
> /*     */     
> /* 274 */     JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, (XYDataset)this.dataset, PlotOrientation.VERTICAL, 
> /* 275 */         true, true, false);
> /*     */     
> /* 277 */     plot = (XYPlot)chart.getPlot();
> /* 278 */     XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
> /* 279 */     plot.setRenderer((XYItemRenderer)renderer1);
> /* 280 */     plot.setBackgroundPaint(new Color(255, 228, 196));
> /* 281 */     Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
> /* 282 */     plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, 
> /* 283 */           DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, 
> /* 284 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, 
> /* 285 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
> /* 286 */     plot.setDataset(1, regressionData);
> /* 287 */     XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
> /* 288 */     renderer2.setSeriesPaint(0, Color.RED);
> /* 289 */     plot.setRenderer(1, (XYItemRenderer)renderer2);
> /* 290 */     Shape cross = new Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
> /* 291 */     List<String[]> featureLists = (List)new ArrayList<>();
> /* 292 */     for (int j = 0; j < ColorEditorSpot.tableC.getModel().getRowCount(); j++) {
> /* 293 */       featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(j, 
> /* 294 */             ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "")
> /* 295 */           .split("<br>"));
> /*     */     }
> /* 297 */     this.renderer = new XYLineAndShapeRenderer()
> /*     */       {
> /*     */         public Paint getItemPaint(int row, int col) {
> /* 300 */           Paint cpaint = getItemColor(row, col);
> /* 301 */           if (cpaint == null) {
> /* 302 */             cpaint = super.getItemPaint(row, col);
> /*     */           }
> /* 304 */           return cpaint;
> /*     */         }
> /*     */         
> /*     */         public Color getItemColor(int row, int col) {
> /* 308 */           double x = STScatterPlot.this.dataset.getXValue(row, col);
> /* 309 */           double y = STScatterPlot.this.dataset.getYValue(row, col);
> /*     */           
> /*     */           try {
> /* 312 */             return classColor[col];
> /* 313 */           } catch (Exception exception) {
> /*     */ 
> /*     */ 
> /*     */             
> /* 317 */             return null;
> /*     */           } 
> /*     */         }
> /*     */       };
> /*     */     
> /* 322 */     plot.setRenderer((XYItemRenderer)this.renderer);
> /* 323 */     this.renderer.setUseOutlinePaint(true);
> /* 324 */     this.renderer.setSeriesShape(0, cross);
> /* 325 */     this.renderer.setSeriesOutlinePaint(0, Color.black);
> /* 326 */     this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
> /* 327 */     this.renderer.setSeriesLinesVisible(0, false);
> /* 328 */     this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
> /* 329 */     plot.getRangeCrosshairValue();
> /* 330 */     plot.getDomainCrosshairValue();
> /*     */ 
> /*     */     
> /* 333 */     this.panel.setChart(chart);
> /* 334 */     this.panel.setMaximumDrawWidth(6000);
> /* 335 */     this.panel.setPreferredSize(new Dimension(450, 300));
> /* 336 */     chart.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 337 */     plot.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 338 */     chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 339 */     this.panel.setMouseWheelEnabled(true);
> /* 340 */     chart.getLegend().setVisible(true);
> /* 341 */     plot.addRangeMarker((Marker)markerRange);
> /* 342 */     plot.addDomainMarker((Marker)markerDomain);
> /* 343 */     markerRange.setLabel("Low-High");
> /* 344 */     markerRange.setLabelFont(new Font("SansSerif", 0, 15));
> /* 345 */     markerRange.setLabelPaint(new Color(0, 102, 0));
> /*     */     
> /* 347 */     Font font3 = new Font("Dialog", 1, 12);
> /* 348 */     plot.getDomainAxis().setLabelFont(font3);
> /* 349 */     plot.getRangeAxis().setLabelFont(font3);
> /* 350 */     plot.getRangeAxis().setTickLabelFont(font3);
> /* 351 */     plot.getDomainAxis().setTickLabelFont(font3);
> /*     */     
> /* 353 */     NumberAxis domain = (NumberAxis)plot.getDomainAxis();
> /*     */     
> /* 355 */     NumberAxis range = (NumberAxis)plot.getRangeAxis();
> /*     */     
> /* 357 */     domain.setAutoRange(true);
> /* 358 */     range.setAutoRange(true);
> /* 359 */     computePowerCoefficients(chart, plot, this.dataset);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void addScatterPlotSeriesPolynomial(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor, int filterOrder) {
> /* 367 */     this.valuesDomain = valuesDomain;
> /* 368 */     this.rangeName = rangeName;
> /* 369 */     this.domainName = domainName;
> /* 370 */     this.valuesRange = valuesRange;
> /* 371 */     this.markerRange = markerRange;
> /* 372 */     this.markerDomain = markerDomain;
> /*     */ 
> /*     */     
> /* 375 */     this.classColor = classColor;
> /* 376 */     this.filterOrder = filterOrder;
> /*     */     
> /* 378 */     this.panel.removeAll();
> /* 379 */     this.dataset = new XYSeriesCollection();
> /* 380 */     this.series1 = new XYSeries("");
> /* 381 */     for (int i = 0; i < valuesDomain.size(); i++)
> /* 382 */       this.series1.add(valuesDomain.get(i), valuesRange.get(i)); 
> /* 383 */     this.dataset.addSeries(this.series1);
> /* 384 */     double minDomain = ((Double)Collections.<Double>min(valuesDomain)).doubleValue();
> /* 385 */     double maxDomain = ((Double)Collections.<Double>max(valuesDomain)).doubleValue();
> /*     */     
> /* 387 */     double[] coefficients = Regression.getPolynomialRegression((XYDataset)this.dataset, 0, filterOrder);
> /* 388 */     PowerFunction2D powerFunction2D = new PowerFunction2D(coefficients[0], coefficients[1]);
> /* 389 */     XYDataset regressionData = DatasetUtils.sampleFunction2D((Function2D)powerFunction2D, minDomain, maxDomain, valuesDomain.size(), 
> /* 390 */         "Fitted Regression Line");
> /*     */     
> /* 392 */     JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, (XYDataset)this.dataset, PlotOrientation.VERTICAL, 
> /* 393 */         true, true, false);
> /*     */     
> /* 395 */     plot = (XYPlot)chart.getPlot();
> /* 396 */     XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
> /* 397 */     plot.setRenderer((XYItemRenderer)renderer1);
> /* 398 */     plot.setBackgroundPaint(new Color(255, 228, 196));
> /* 399 */     Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
> /* 400 */     plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, 
> /* 401 */           DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, 
> /* 402 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, 
> /* 403 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
> /* 404 */     plot.setDataset(1, regressionData);
> /* 405 */     XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
> /* 406 */     renderer2.setSeriesPaint(0, Color.RED);
> /* 407 */     plot.setRenderer(1, (XYItemRenderer)renderer2);
> /* 408 */     Shape cross = new Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
> /* 409 */     List<String[]> featureLists = (List)new ArrayList<>();
> /* 410 */     for (int j = 0; j < ColorEditorSpot.tableC.getModel().getRowCount(); j++) {
> /* 411 */       featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(j, 
> /* 412 */             ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "")
> /* 413 */           .split("<br>"));
> /*     */     }
> /* 415 */     this.renderer = new XYLineAndShapeRenderer()
> /*     */       {
> /*     */         public Paint getItemPaint(int row, int col) {
> /* 418 */           Paint cpaint = getItemColor(row, col);
> /* 419 */           if (cpaint == null) {
> /* 420 */             cpaint = super.getItemPaint(row, col);
> /*     */           }
> /* 422 */           return cpaint;
> /*     */         }
> /*     */         
> /*     */         public Color getItemColor(int row, int col) {
> /* 426 */           double x = STScatterPlot.this.dataset.getXValue(row, col);
> /* 427 */           double y = STScatterPlot.this.dataset.getYValue(row, col);
> /*     */           
> /*     */           try {
> /* 430 */             return classColor[col];
> /* 431 */           } catch (Exception exception) {
> /*     */ 
> /*     */ 
> /*     */             
> /* 435 */             return null;
> /*     */           } 
> /*     */         }
> /*     */       };
> /*     */     
> /* 440 */     plot.setRenderer((XYItemRenderer)this.renderer);
> /* 441 */     this.renderer.setUseOutlinePaint(true);
> /* 442 */     this.renderer.setSeriesShape(0, cross);
> /* 443 */     this.renderer.setSeriesOutlinePaint(0, Color.black);
> /* 444 */     this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
> /* 445 */     this.renderer.setSeriesLinesVisible(0, false);
> /* 446 */     this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
> /* 447 */     plot.getRangeCrosshairValue();
> /* 448 */     plot.getDomainCrosshairValue();
> /*     */ 
> /*     */     
> /* 451 */     this.panel.setChart(chart);
> /* 452 */     this.panel.setMaximumDrawWidth(6000);
> /* 453 */     this.panel.setPreferredSize(new Dimension(450, 300));
> /* 454 */     chart.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 455 */     plot.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 456 */     chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 457 */     this.panel.setMouseWheelEnabled(true);
> /* 458 */     chart.getLegend().setVisible(true);
> /* 459 */     plot.addRangeMarker((Marker)markerRange);
> /* 460 */     plot.addDomainMarker((Marker)markerDomain);
> /* 461 */     markerRange.setLabel("Low-High");
> /* 462 */     markerRange.setLabelFont(new Font("SansSerif", 0, 15));
> /* 463 */     markerRange.setLabelPaint(new Color(0, 102, 0));
> /*     */     
> /* 465 */     Font font3 = new Font("Dialog", 1, 12);
> /* 466 */     plot.getDomainAxis().setLabelFont(font3);
> /* 467 */     plot.getRangeAxis().setLabelFont(font3);
> /* 468 */     plot.getRangeAxis().setTickLabelFont(font3);
> /* 469 */     plot.getDomainAxis().setTickLabelFont(font3);
> /*     */     
> /* 471 */     NumberAxis domain = (NumberAxis)plot.getDomainAxis();
> /*     */     
> /* 473 */     NumberAxis range = (NumberAxis)plot.getRangeAxis();
> /*     */     
> /* 475 */     domain.setAutoRange(true);
> /* 476 */     range.setAutoRange(true);
> /* 477 */     computePolynomialCoefficients(chart, plot, this.dataset, filterOrder);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void addScatterPlotSeriesLogarithmic(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
> /* 485 */     this.valuesDomain = valuesDomain;
> /* 486 */     this.rangeName = rangeName;
> /* 487 */     this.domainName = domainName;
> /* 488 */     this.valuesRange = valuesRange;
> /* 489 */     this.markerRange = markerRange;
> /* 490 */     this.markerDomain = markerDomain;
> /*     */ 
> /*     */     
> /* 493 */     this.classColor = classColor;
> /* 494 */     this.filterOrder = this.filterOrder;
> /*     */     
> /* 496 */     this.panel.removeAll();
> /* 497 */     this.dataset = new XYSeriesCollection();
> /* 498 */     this.series1 = new XYSeries("");
> /* 499 */     for (int i = 0; i < valuesDomain.size(); i++)
> /* 500 */       this.series1.add(valuesDomain.get(i), valuesRange.get(i)); 
> /* 501 */     this.dataset.addSeries(this.series1);
> /* 502 */     double minDomain = ((Double)Collections.<Double>min(valuesDomain)).doubleValue();
> /* 503 */     double maxDomain = ((Double)Collections.<Double>max(valuesDomain)).doubleValue();
> /* 504 */     double[] coefficients = RegressionLE_.getLogarithmicRegression((XYDataset)this.dataset, 0);
> /* 505 */     LogarithmicFunction2D logarithmicFunction2D = new LogarithmicFunction2D(coefficients[0], coefficients[1]);
> /* 506 */     XYDataset regressionData = DatasetUtils.sampleFunction2D((Function2D)logarithmicFunction2D, minDomain, maxDomain, valuesDomain.size(), 
> /* 507 */         "Fitted Regression Line");
> /*     */     
> /* 509 */     JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, (XYDataset)this.dataset, PlotOrientation.VERTICAL, 
> /* 510 */         true, true, false);
> /*     */     
> /* 512 */     plot = (XYPlot)chart.getPlot();
> /* 513 */     XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
> /* 514 */     plot.setRenderer((XYItemRenderer)renderer1);
> /* 515 */     plot.setBackgroundPaint(new Color(255, 228, 196));
> /* 516 */     Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
> /* 517 */     plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, 
> /* 518 */           DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, 
> /* 519 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, 
> /* 520 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
> /* 521 */     plot.setDataset(1, regressionData);
> /* 522 */     XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
> /* 523 */     renderer2.setSeriesPaint(0, Color.RED);
> /* 524 */     plot.setRenderer(1, (XYItemRenderer)renderer2);
> /* 525 */     Shape cross = new Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
> /* 526 */     List<String[]> featureLists = (List)new ArrayList<>();
> /* 527 */     for (int j = 0; j < ColorEditorSpot.tableC.getModel().getRowCount(); j++) {
> /* 528 */       featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(j, 
> /* 529 */             ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "")
> /* 530 */           .split("<br>"));
> /*     */     }
> /* 532 */     this.renderer = new XYLineAndShapeRenderer()
> /*     */       {
> /*     */         public Paint getItemPaint(int row, int col) {
> /* 535 */           Paint cpaint = getItemColor(row, col);
> /* 536 */           if (cpaint == null) {
> /* 537 */             cpaint = super.getItemPaint(row, col);
> /*     */           }
> /* 539 */           return cpaint;
> /*     */         }
> /*     */         
> /*     */         public Color getItemColor(int row, int col) {
> /* 543 */           double x = STScatterPlot.this.dataset.getXValue(row, col);
> /* 544 */           double y = STScatterPlot.this.dataset.getYValue(row, col);
> /*     */           
> /*     */           try {
> /* 547 */             return classColor[col];
> /* 548 */           } catch (Exception exception) {
> /*     */ 
> /*     */ 
> /*     */             
> /* 552 */             return null;
> /*     */           } 
> /*     */         }
> /*     */       };
> /*     */     
> /* 557 */     plot.setRenderer((XYItemRenderer)this.renderer);
> /* 558 */     this.renderer.setUseOutlinePaint(true);
> /* 559 */     this.renderer.setSeriesShape(0, cross);
> /* 560 */     this.renderer.setSeriesOutlinePaint(0, Color.black);
> /* 561 */     this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
> /* 562 */     this.renderer.setSeriesLinesVisible(0, false);
> /* 563 */     this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
> /* 564 */     plot.getRangeCrosshairValue();
> /* 565 */     plot.getDomainCrosshairValue();
> /*     */ 
> /*     */     
> /* 568 */     this.panel.setChart(chart);
> /* 569 */     this.panel.setMaximumDrawWidth(6000);
> /* 570 */     this.panel.setPreferredSize(new Dimension(450, 300));
> /* 571 */     chart.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 572 */     plot.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 573 */     chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 574 */     this.panel.setMouseWheelEnabled(true);
> /* 575 */     chart.getLegend().setVisible(true);
> /* 576 */     plot.addRangeMarker((Marker)markerRange);
> /* 577 */     plot.addDomainMarker((Marker)markerDomain);
> /* 578 */     markerRange.setLabel("Low-High");
> /* 579 */     markerRange.setLabelFont(new Font("SansSerif", 0, 15));
> /* 580 */     markerRange.setLabelPaint(new Color(0, 102, 0));
> /*     */     
> /* 582 */     Font font3 = new Font("Dialog", 1, 12);
> /* 583 */     plot.getDomainAxis().setLabelFont(font3);
> /* 584 */     plot.getRangeAxis().setLabelFont(font3);
> /* 585 */     plot.getRangeAxis().setTickLabelFont(font3);
> /* 586 */     plot.getDomainAxis().setTickLabelFont(font3);
> /*     */     
> /* 588 */     NumberAxis domain = (NumberAxis)plot.getDomainAxis();
> /*     */     
> /* 590 */     NumberAxis range = (NumberAxis)plot.getRangeAxis();
> /*     */     
> /* 592 */     domain.setAutoRange(true);
> /* 593 */     range.setAutoRange(true);
> /* 594 */     computeLogarithmicCoefficients(chart, plot, this.dataset, this.filterOrder);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void addScatterPlotSeriesExponential(String domainName, String rangeName, List<Double> valuesDomain, List<Double> valuesRange, IntervalMarker markerRange, IntervalMarker markerDomain, Object[][] data, final Color[] classColor) {
> /* 602 */     this.valuesDomain = valuesDomain;
> /* 603 */     this.rangeName = rangeName;
> /* 604 */     this.domainName = domainName;
> /* 605 */     this.valuesRange = valuesRange;
> /* 606 */     this.markerRange = markerRange;
> /* 607 */     this.markerDomain = markerDomain;
> /*     */ 
> /*     */     
> /* 610 */     this.classColor = classColor;
> /* 611 */     this.filterOrder = this.filterOrder;
> /*     */     
> /* 613 */     this.panel.removeAll();
> /* 614 */     this.dataset = new XYSeriesCollection();
> /* 615 */     this.series1 = new XYSeries("");
> /* 616 */     for (int i = 0; i < valuesDomain.size(); i++)
> /* 617 */       this.series1.add(valuesDomain.get(i), valuesRange.get(i)); 
> /* 618 */     this.dataset.addSeries(this.series1);
> /*     */     
> /* 620 */     double minDomain = ((Double)Collections.<Double>min(valuesDomain)).doubleValue();
> /* 621 */     double maxDomain = ((Double)Collections.<Double>max(valuesDomain)).doubleValue();
> /* 622 */     double[] coefficients = RegressionLE_.getExponentialRegression((XYDataset)this.dataset, 0);
> /* 623 */     ExponentialFunction2D exponentialFunction2D = new ExponentialFunction2D(coefficients[0], coefficients[1]);
> /* 624 */     XYDataset regressionData = DatasetUtils.sampleFunction2D((Function2D)exponentialFunction2D, minDomain, maxDomain, valuesDomain.size(), 
> /* 625 */         "Fitted Regression Line");
> /*     */     
> /* 627 */     JFreeChart chart = ChartFactory.createScatterPlot("", domainName, rangeName, (XYDataset)this.dataset, PlotOrientation.VERTICAL, 
> /* 628 */         true, true, false);
> /*     */     
> /* 630 */     plot = (XYPlot)chart.getPlot();
> /* 631 */     XYLineAndShapeRenderer renderer1 = new XYLineAndShapeRenderer(false, true);
> /* 632 */     plot.setRenderer((XYItemRenderer)renderer1);
> /* 633 */     plot.setBackgroundPaint(new Color(255, 228, 196));
> /* 634 */     Paint[] paintArray = { new Color(-2130771968, true), new Color(-2147418368, true), new Color(-2147483393, true) };
> /* 635 */     plot.setDrawingSupplier((DrawingSupplier)new DefaultDrawingSupplier(paintArray, 
> /* 636 */           DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE, 
> /* 637 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE, DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE, 
> /* 638 */           DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE, DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
> /* 639 */     plot.setDataset(1, regressionData);
> /* 640 */     XYLineAndShapeRenderer renderer2 = new XYLineAndShapeRenderer(true, false);
> /* 641 */     renderer2.setSeriesPaint(0, Color.RED);
> /* 642 */     plot.setRenderer(1, (XYItemRenderer)renderer2);
> /* 643 */     Shape cross = new Ellipse2D.Double(0.0D, 0.0D, 5.0D, 5.0D);
> /* 644 */     List<String[]> featureLists = (List)new ArrayList<>();
> /* 645 */     for (int j = 0; j < ColorEditorSpot.tableC.getModel().getRowCount(); j++) {
> /* 646 */       featureLists.add(((JLabel)ColorEditorSpot.tableC.getModel().getValueAt(j, 
> /* 647 */             ColorEditorSpot.tableC.convertColumnIndexToModel(2))).getText().replace("<html>", "")
> /* 648 */           .split("<br>"));
> /*     */     }
> /* 650 */     this.renderer = new XYLineAndShapeRenderer()
> /*     */       {
> /*     */         public Paint getItemPaint(int row, int col) {
> /* 653 */           Paint cpaint = getItemColor(row, col);
> /* 654 */           if (cpaint == null) {
> /* 655 */             cpaint = super.getItemPaint(row, col);
> /*     */           }
> /* 657 */           return cpaint;
> /*     */         }
> /*     */         
> /*     */         public Color getItemColor(int row, int col) {
> /* 661 */           double x = STScatterPlot.this.dataset.getXValue(row, col);
> /* 662 */           double y = STScatterPlot.this.dataset.getYValue(row, col);
> /*     */           
> /*     */           try {
> /* 665 */             return classColor[col];
> /* 666 */           } catch (Exception exception) {
> /*     */ 
> /*     */ 
> /*     */             
> /* 670 */             return null;
> /*     */           } 
> /*     */         }
> /*     */       };
> /*     */     
> /* 675 */     plot.setRenderer((XYItemRenderer)this.renderer);
> /* 676 */     this.renderer.setUseOutlinePaint(true);
> /* 677 */     this.renderer.setSeriesShape(0, cross);
> /* 678 */     this.renderer.setSeriesOutlinePaint(0, Color.black);
> /* 679 */     this.renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0F));
> /* 680 */     this.renderer.setSeriesLinesVisible(0, false);
> /* 681 */     this.renderer.setSeriesPaint(0, Color.LIGHT_GRAY);
> /* 682 */     plot.getRangeCrosshairValue();
> /* 683 */     plot.getDomainCrosshairValue();
> /*     */ 
> /*     */     
> /* 686 */     this.panel.setChart(chart);
> /* 687 */     this.panel.setMaximumDrawWidth(6000);
> /* 688 */     this.panel.setPreferredSize(new Dimension(450, 300));
> /* 689 */     chart.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 690 */     plot.setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 691 */     chart.getLegend().setBackgroundPaint(new Color(255, 255, 255, 0));
> /* 692 */     this.panel.setMouseWheelEnabled(true);
> /* 693 */     chart.getLegend().setVisible(true);
> /* 694 */     plot.addRangeMarker((Marker)markerRange);
> /* 695 */     plot.addDomainMarker((Marker)markerDomain);
> /* 696 */     markerRange.setLabel("Low-High");
> /* 697 */     markerRange.setLabelFont(new Font("SansSerif", 0, 15));
> /* 698 */     markerRange.setLabelPaint(new Color(0, 102, 0));
> /*     */     
> /* 700 */     Font font3 = new Font("Dialog", 1, 12);
> /* 701 */     plot.getDomainAxis().setLabelFont(font3);
> /* 702 */     plot.getRangeAxis().setLabelFont(font3);
> /* 703 */     plot.getRangeAxis().setTickLabelFont(font3);
> /* 704 */     plot.getDomainAxis().setTickLabelFont(font3);
> /*     */     
> /* 706 */     NumberAxis domain = (NumberAxis)plot.getDomainAxis();
> /*     */     
> /* 708 */     NumberAxis range = (NumberAxis)plot.getRangeAxis();
> /*     */     
> /* 710 */     domain.setAutoRange(true);
> /* 711 */     range.setAutoRange(true);
> /* 712 */     computeExponentialCoefficients(chart, plot, this.dataset, this.filterOrder);
> /*     */   }
> /*     */   
> /*     */   private void computeLinearCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset) {
> /*     */     String linearEquation;
> /* 717 */     Function2D retVal = null;
> /* 718 */     double r2 = 0.0D;
> /* 719 */     double[] coefficients = null;
> /*     */ 
> /*     */     
> /*     */     try {
> /* 723 */       coefficients = RegressionLE_.getOLSRegression((XYDataset)dataset, 0);
> /* 724 */       LineFunction2D lineFunction2D = new LineFunction2D(coefficients[0], coefficients[1]);
> /* 725 */       r2 = coefficients[2];
> /* 726 */     } catch (Exception e) {
> /* 727 */       System.err.println(e.getMessage());
> /*     */     } 
> /* 729 */     double intercept = coefficients[0];
> /* 730 */     double slope = coefficients[1];
> /*     */     
> /* 732 */     if (intercept >= 0.0D) {
> /* 733 */       linearEquation = "y = " + String.format("%.2f", new Object[] { Double.valueOf(slope) }) + "x + " + String.format("%.2f", new Object[] { Double.valueOf(intercept) });
> /*     */     } else {
> /* 735 */       linearEquation = "y = " + String.format("%.2f", new Object[] { Double.valueOf(slope) }) + "x - " + Math.abs(intercept);
> /*     */     } 
> /*     */     
> /* 738 */     TextTitle tt = new TextTitle(String.valueOf(linearEquation) + "\nR = " + String.format("%.2f", new Object[] { Double.valueOf(r2) }));
> /* 739 */     tt.setTextAlignment(HorizontalAlignment.RIGHT);
> /* 740 */     tt.setFont(chart.getLegend().getItemFont());
> /* 741 */     tt.setBackgroundPaint(new Color(200, 200, 255, 100));
> /* 742 */     tt.setFrame((BlockFrame)new BlockBorder(Color.white));
> /* 743 */     tt.setPosition(RectangleEdge.BOTTOM);
> /*     */     
> /* 745 */     XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, (Title)tt, RectangleAnchor.BOTTOM_RIGHT);
> /* 746 */     r2Annotation.setMaxWidth(0.48D);
> /* 747 */     plot.addAnnotation((XYAnnotation)r2Annotation);
> /*     */   }
> /*     */   private void computePowerCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset) {
> /*     */     String linearEquation;
> /* 751 */     Function2D retVal = null;
> /* 752 */     double r2 = 0.0D;
> /* 753 */     double[] coefficients = null;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     try {
> /* 759 */       coefficients = RegressionLE_.getPowerRegression((XYDataset)dataset, 0);
> /* 760 */       if (coefficients[2] > r2) {
> /* 761 */         PowerFunction2D powerFunction2D = new PowerFunction2D(coefficients[0], coefficients[1]);
> /* 762 */         r2 = coefficients[2];
> /*     */       } 
> /* 764 */     } catch (Exception e) {
> /* 765 */       System.err.println(e.getMessage());
> /*     */     } 
> /* 767 */     double intercept = coefficients[0];
> /* 768 */     double slope = coefficients[1];
> /*     */     
> /* 770 */     if (intercept >= 0.0D) {
> /* 771 */       linearEquation = "y = " + String.format("%.2f", new Object[] { Double.valueOf(slope) }) + "x^ " + String.format("%.2f", new Object[] { Double.valueOf(intercept) });
> /*     */     } else {
> /* 773 */       linearEquation = "y = " + String.format("%.2f", new Object[] { Double.valueOf(slope) }) + "x^ -" + Math.abs(intercept);
> /*     */     } 
> /*     */     
> /* 776 */     TextTitle tt = new TextTitle(String.valueOf(linearEquation) + "\nR = " + String.format("%.2f", new Object[] { Double.valueOf(r2) }));
> /* 777 */     tt.setTextAlignment(HorizontalAlignment.RIGHT);
> /* 778 */     tt.setFont(chart.getLegend().getItemFont());
> /* 779 */     tt.setBackgroundPaint(new Color(200, 200, 255, 100));
> /* 780 */     tt.setFrame((BlockFrame)new BlockBorder(Color.white));
> /* 781 */     tt.setPosition(RectangleEdge.BOTTOM);
> /*     */     
> /* 783 */     XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, (Title)tt, RectangleAnchor.BOTTOM_RIGHT);
> /* 784 */     r2Annotation.setMaxWidth(0.48D);
> /* 785 */     plot.addAnnotation((XYAnnotation)r2Annotation);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private void computePolynomialCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset, int filterOrder) {
> /* 791 */     double[] coefficients = Regression.getPolynomialRegression((XYDataset)dataset, 0, filterOrder);
> /* 792 */     double r2 = coefficients[coefficients.length - 1];
> /* 793 */     String polynomialEquation = "";
> /* 794 */     for (int i = coefficients.length - 1; i >= 0; i--) {
> /* 795 */       if (i == 0) {
> /* 796 */         polynomialEquation = String.valueOf(polynomialEquation) + String.format("%.2f", new Object[] { Double.valueOf(coefficients[i]) });
> /*     */       }
> /* 798 */       else if (i == 1) {
> /* 799 */         polynomialEquation = String.valueOf(polynomialEquation) + String.format("%.2f", new Object[] { Double.valueOf(coefficients[i]) }) + "*x+";
> /* 800 */       } else if (i > 1) {
> /* 801 */         polynomialEquation = String.valueOf(polynomialEquation) + String.format("%.2f", new Object[] { Double.valueOf(coefficients[i]) }) + "*x^" + i + "+";
> /*     */       } 
> /*     */     } 
> /*     */ 
> /*     */     
> /* 806 */     TextTitle tt = new TextTitle("y = " + polynomialEquation + "\nR = " + String.format("%.2f", new Object[] { Double.valueOf(r2) }));
> /* 807 */     tt.setTextAlignment(HorizontalAlignment.RIGHT);
> /* 808 */     tt.setFont(chart.getLegend().getItemFont());
> /* 809 */     tt.setBackgroundPaint(new Color(200, 200, 255, 100));
> /* 810 */     tt.setFrame((BlockFrame)new BlockBorder(Color.white));
> /* 811 */     tt.setPosition(RectangleEdge.BOTTOM);
> /*     */     
> /* 813 */     XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, (Title)tt, RectangleAnchor.BOTTOM_RIGHT);
> /* 814 */     r2Annotation.setMaxWidth(0.48D);
> /* 815 */     plot.addAnnotation((XYAnnotation)r2Annotation);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   private void computeLogarithmicCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset, int filterOrder) {
> /* 820 */     Function2D retVal = null;
> /* 821 */     double r2 = 0.0D;
> /* 822 */     double[] coefficients = null;
> /*     */     
> /*     */     try {
> /* 825 */       coefficients = RegressionLE_.getLogarithmicRegression((XYDataset)dataset, 0);
> /* 826 */       if (coefficients[2] > r2) {
> /* 827 */         LogarithmicFunction2D logarithmicFunction2D = new LogarithmicFunction2D(coefficients[0], coefficients[1]);
> /* 828 */         r2 = coefficients[2];
> /*     */       } 
> /* 830 */     } catch (Exception e) {
> /* 831 */       System.err.println(e.getMessage());
> /*     */     } 
> /* 833 */     String logarithmicEquation = "y = " + String.format("%.2f", new Object[] { Double.valueOf(coefficients[0]) }) + " + " + "( " + 
> /* 834 */       String.format("%.2f", new Object[] { Double.valueOf(coefficients[1]) }) + " * ln(x) ) ";
> /*     */     
> /* 836 */     TextTitle tt = new TextTitle("y = " + logarithmicEquation + "\nR = " + String.format("%.2f", new Object[] { Double.valueOf(r2) }));
> /* 837 */     tt.setTextAlignment(HorizontalAlignment.RIGHT);
> /* 838 */     tt.setFont(chart.getLegend().getItemFont());
> /* 839 */     tt.setBackgroundPaint(new Color(200, 200, 255, 100));
> /* 840 */     tt.setFrame((BlockFrame)new BlockBorder(Color.white));
> /* 841 */     tt.setPosition(RectangleEdge.BOTTOM);
> /*     */     
> /* 843 */     XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, (Title)tt, RectangleAnchor.BOTTOM_RIGHT);
> /* 844 */     r2Annotation.setMaxWidth(0.48D);
> /* 845 */     plot.addAnnotation((XYAnnotation)r2Annotation);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   private void computeExponentialCoefficients(JFreeChart chart, XYPlot plot, XYSeriesCollection dataset, int filterOrder) {
> /* 850 */     Function2D retVal = null;
> /* 851 */     double r2 = 0.0D;
> /* 852 */     double[] coefficients = null;
> /*     */     
> /*     */     try {
> /* 855 */       coefficients = RegressionLE_.getExponentialRegression((XYDataset)dataset, 0);
> /* 856 */       if (coefficients[2] > r2) {
> /* 857 */         LogarithmicFunction2D logarithmicFunction2D = new LogarithmicFunction2D(coefficients[0], coefficients[1]);
> /* 858 */         r2 = coefficients[2];
> /*     */       } 
> /* 860 */     } catch (Exception e) {
> /* 861 */       System.err.println(e.getMessage());
> /*     */     } 
> /* 863 */     String exponentialEquation = "y = " + String.format("%.2f", new Object[] { Double.valueOf(coefficients[0]) }) + " * " + "( e^(" + 
> /* 864 */       String.format("%.2f", new Object[] { Double.valueOf(coefficients[1]) }) + " * x) ) ";
> /*     */     
> /* 866 */     TextTitle tt = new TextTitle("y = " + exponentialEquation + "\nR = " + String.format("%.2f", new Object[] { Double.valueOf(r2) }));
> /* 867 */     tt.setTextAlignment(HorizontalAlignment.RIGHT);
> /* 868 */     tt.setFont(chart.getLegend().getItemFont());
> /* 869 */     tt.setBackgroundPaint(new Color(200, 200, 255, 100));
> /* 870 */     tt.setFrame((BlockFrame)new BlockBorder(Color.white));
> /* 871 */     tt.setPosition(RectangleEdge.BOTTOM);
> /*     */     
> /* 873 */     XYTitleAnnotation r2Annotation = new XYTitleAnnotation(0.98D, 0.02D, (Title)tt, RectangleAnchor.BOTTOM_RIGHT);
> /* 874 */     r2Annotation.setMaxWidth(0.48D);
> /* 875 */     plot.addAnnotation((XYAnnotation)r2Annotation);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/STScatterPlot.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: summaryColsWindow$1.java
Only in jd-gui: summaryColsWindow$2.java
diff -r TrackAnalyzer_/summaryColsWindow.java jd-gui/summaryColsWindow.java
1,133c1,178
< import checkable.CheckableItem;
< import checkable.CheckedComboBox;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import javax.swing.BoxLayout;
< import javax.swing.DefaultComboBoxModel;
< import javax.swing.JButton;
< import javax.swing.JComboBox;
< import javax.swing.JFrame;
< import javax.swing.JLabel;
< import javax.swing.JPanel;
< 
< public class summaryColsWindow {
<    static JButton okButton;
<    static JFrame frame;
<    public static CheckedComboBox comboSpots;
<    public static CheckedComboBox comboLinks;
<    public static CheckedComboBox comboTracks;
<    static String[] columnNamesSpot = null;
<    static String[] columnNamesLinks = null;
<    static String[] columnNamesTracks = null;
<    public static CheckableItem[] itemsSpots;
<    public static CheckableItem[] itemsLinks;
<    public static CheckableItem[] itemsTracks;
<    static int indexSLT;
<    static JComboBox combo;
< 
<    public void run(String args) {
<       frame = new JFrame("Configure Summary Outputs");
<       frame.setSize(200, 150);
<       frame.setDefaultCloseOperation(2);
<       JPanel panel = new JPanel();
<       frame.add(panel);
<       placeComponents(panel);
<       frame.setVisible(true);
<    }
< 
<    private static void placeComponents(final JPanel panel) {
<       panel.setLayout(new BoxLayout(panel, 1));
<       JLabel paramLabel = new JLabel("Parameters: ");
<       panel.add(paramLabel);
<       combo = new JComboBox();
<       combo.addItem("Spots");
<       combo.addItem("Links");
<       combo.addItem("Tracks");
<       combo.setSelectedIndex(2);
<       combo.setBounds(50, 50, 90, 20);
<       if (SPTBatch_.checkboxSubBg.isSelected()) {
<          columnNamesSpot = new String[]{"LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1", "Intensity-Bg Subtract"};
<       }
< 
<       if (!SPTBatch_.checkboxSubBg.isSelected()) {
<          columnNamesSpot = new String[]{"LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1"};
<       }
< 
<       itemsSpots = new CheckableItem[columnNamesSpot.length];
<       columnNamesLinks = new String[]{"TRACK_ID", "SPOT_SOURCE_ID", "SPOT_TARGET_ID", "LINK_COST", "DIRECTIONAL_CHANGE_RATE", "SPEED", "DISPLACEMENT", "EDGE_TIME", "EDGE_X_LOCATION", "EDGE_Y_LOCATION", "EDGE_Z_LOCATION", "MANUAL_EGE_COLOR"};
<       itemsLinks = new CheckableItem[columnNamesLinks.length];
<       if (SPTBatch_.checkboxSubBg.isSelected()) {
<          if (SPTBatch_.checkTracks.isSelected()) {
<             columnNamesTracks = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + ")", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<          }
< 
<          if (!SPTBatch_.checkTracks.isSelected()) {
<             columnNamesTracks = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<          }
<       }
< 
<       if (!SPTBatch_.checkboxSubBg.isSelected()) {
<          columnNamesTracks = new String[]{"LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement"};
<       }
< 
<       itemsTracks = new CheckableItem[columnNamesTracks.length];
< 
<       int i;
<       for(i = 0; i < columnNamesSpot.length; ++i) {
<          itemsSpots[i] = new CheckableItem(columnNamesSpot[i], false);
<       }
< 
<       for(i = 0; i < columnNamesLinks.length; ++i) {
<          itemsLinks[i] = new CheckableItem(columnNamesLinks[i], false);
<       }
< 
<       for(i = 0; i < columnNamesTracks.length; ++i) {
<          itemsTracks[i] = new CheckableItem(columnNamesTracks[i], false);
<       }
< 
<       comboSpots = new CheckedComboBox(new DefaultComboBoxModel(itemsSpots));
<       comboSpots.setOpaque(true);
<       comboSpots.setToolTipText("Select parameter to build the summary for links.");
<       comboSpots.setSelectedItem(itemsSpots[0]);
<       comboLinks = new CheckedComboBox(new DefaultComboBoxModel(itemsLinks));
<       comboLinks.setOpaque(true);
<       comboLinks.setToolTipText("Select parameter to build the summary for links.");
<       comboLinks.setSelectedItem(itemsLinks[0]);
<       comboTracks = new CheckedComboBox(new DefaultComboBoxModel(itemsTracks));
<       comboTracks.setOpaque(true);
<       comboTracks.setToolTipText("Select parameter to build the summary for tracks.");
<       comboTracks.setSelectedItem(itemsTracks[0]);
<       panel.add(combo);
<       JLabel columnParamLabel = new JLabel("Column Parameter: ");
<       panel.add(columnParamLabel);
<       okButton = new JButton("OK");
<       okButton.setBounds(10, 80, 80, 25);
<       panel.add(okButton);
<       okButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent event) {
<             summaryColsWindow.indexSLT = summaryColsWindow.combo.getSelectedIndex();
<             summaryColsWindow.frame.setVisible(false);
<          }
<       });
<       combo.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent e) {
<             if (panel.getComponents().length == 5) {
<                panel.remove(3);
<             }
< 
<             if (summaryColsWindow.combo.getSelectedIndex() == 0) {
<                panel.add(summaryColsWindow.comboSpots, 3);
<             }
< 
<             if (summaryColsWindow.combo.getSelectedIndex() == 1) {
<                panel.add(summaryColsWindow.comboLinks, 3);
<             }
< 
<             if (summaryColsWindow.combo.getSelectedIndex() == 2) {
<                panel.add(summaryColsWindow.comboTracks, 3);
<             }
< 
<          }
<       });
<    }
< }
---
> /*     */ import checkable.CheckableItem;
> /*     */ import checkable.CheckedComboBox;
> /*     */ import java.awt.Component;
> /*     */ import java.awt.event.ActionEvent;
> /*     */ import java.awt.event.ActionListener;
> /*     */ import javax.swing.BoxLayout;
> /*     */ import javax.swing.DefaultComboBoxModel;
> /*     */ import javax.swing.JButton;
> /*     */ import javax.swing.JComboBox;
> /*     */ import javax.swing.JFrame;
> /*     */ import javax.swing.JLabel;
> /*     */ import javax.swing.JPanel;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class summaryColsWindow
> /*     */ {
> /*     */   static JButton okButton;
> /*     */   static JFrame frame;
> /*     */   public static CheckedComboBox comboSpots;
> /*     */   public static CheckedComboBox comboLinks;
> /*     */   public static CheckedComboBox comboTracks;
> /*  25 */   static String[] columnNamesSpot = null; static String[] columnNamesLinks = null; static String[] columnNamesTracks = null;
> /*     */   
> /*     */   public static CheckableItem[] itemsSpots;
> /*     */   
> /*     */   public static CheckableItem[] itemsLinks;
> /*     */   public static CheckableItem[] itemsTracks;
> /*     */   static int indexSLT;
> /*     */   static JComboBox combo;
> /*     */   
> /*     */   public void run(String args) {
> /*  35 */     frame = new JFrame("Configure Summary Outputs");
> /*  36 */     frame.setSize(200, 150);
> /*  37 */     frame.setDefaultCloseOperation(2);
> /*     */     
> /*  39 */     JPanel panel = new JPanel();
> /*  40 */     frame.add(panel);
> /*  41 */     placeComponents(panel);
> /*     */     
> /*  43 */     frame.setVisible(true);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   private static void placeComponents(final JPanel panel) {
> /*  49 */     panel.setLayout(new BoxLayout(panel, 1));
> /*     */     
> /*  51 */     JLabel paramLabel = new JLabel("Parameters: ");
> /*  52 */     panel.add(paramLabel);
> /*     */     
> /*  54 */     combo = new JComboBox();
> /*  55 */     combo.addItem("Spots");
> /*  56 */     combo.addItem("Links");
> /*  57 */     combo.addItem("Tracks");
> /*  58 */     combo.setSelectedIndex(2);
> /*  59 */     combo.setBounds(50, 50, 90, 20);
> /*  60 */     if (SPTBatch_.checkboxSubBg.isSelected())
> /*     */     {
> /*  62 */       columnNamesSpot = new String[] { "LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", 
> /*  63 */           "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", 
> /*  64 */           "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", 
> /*  65 */           "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1", "Intensity-Bg Subtract" };
> /*     */     }
> /*  67 */     if (!SPTBatch_.checkboxSubBg.isSelected())
> /*     */     {
> /*  69 */       columnNamesSpot = new String[] { "LABEL", "ID", "TRACK_ID", "QUALITY", "POSITION_X", "POSITION_Y", 
> /*  70 */           "POSITION_Z", "POSITION_T", "FRAME", "RADIUS", "VISIBILITY", "MANUAL_SPOT_COLOR", 
> /*  71 */           "MEAN_INTENSITY_CH1", "MEDIAN_INTENSITY_CH1", "MIN_INTENSITY_CH1", "MAX_INTENSITY_CH1", 
> /*  72 */           "TOTAL_INTENSITY_CH1", "STD_INTENSITY_CH1", "CONTRAST_CH1", "SNR_CH1" };
> /*     */     }
> /*  74 */     itemsSpots = new CheckableItem[columnNamesSpot.length];
> /*  75 */     columnNamesLinks = new String[] { "TRACK_ID", "SPOT_SOURCE_ID", "SPOT_TARGET_ID", "LINK_COST", 
> /*  76 */         "DIRECTIONAL_CHANGE_RATE", "SPEED", "DISPLACEMENT", "EDGE_TIME", "EDGE_X_LOCATION", "EDGE_Y_LOCATION", 
> /*  77 */         "EDGE_Z_LOCATION", "MANUAL_EGE_COLOR" };
> /*  78 */     itemsLinks = new CheckableItem[columnNamesLinks.length];
> /*  79 */     if (SPTBatch_.checkboxSubBg.isSelected()) {
> /*     */       
> /*  81 */       if (SPTBatch_.checkTracks.isSelected()) {
> /*  82 */         columnNamesTracks = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", 
> /*  83 */             "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", 
> /*  84 */             "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", 
> /*  85 */             "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", 
> /*  86 */             "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", 
> /*  87 */             "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", 
> /*  88 */             "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", 
> /*  89 */             "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", 
> /*  90 */             "Intensity-Bg Subtract (" + SPTBatch_.minTracksJTF + "-" + SPTBatch_.maxTracksJTF + ")", 
> /*  91 */             "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", 
> /*  92 */             "sMSS Movement" };
> /*     */       }
> /*  94 */       if (!SPTBatch_.checkTracks.isSelected())
> /*  95 */         columnNamesTracks = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", 
> /*  96 */             "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", 
> /*  97 */             "TRACK_START", "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", 
> /*  98 */             "TRACK_Z_LOCATION", "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", 
> /*  99 */             "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", 
> /* 100 */             "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", "MEAN_STRAIGHT_LINE_SPEED", 
> /* 101 */             "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", "MSD timelag=1", 
> /* 102 */             "MSD timelag=2", "MSD timelag=3", "MSD", "Intensity-Bg Subtract", 
> /* 103 */             "Diffusion Coef.", "D1-4", "Track Length", "Motility", "Alpha", "Movement", "sMSS", 
> /* 104 */             "sMSS Movement" }; 
> /*     */     } 
> /* 106 */     if (!SPTBatch_.checkboxSubBg.isSelected()) {
> /* 107 */       columnNamesTracks = new String[] { "LABEL", "TRACK_INDEX", "TRACK_ID", "NUMBER_SPOTS", "NUMBER_GAPS", 
> /* 108 */           "NUMBER_SPLITS", "NUMBER_MERGES", "NUMBER_COMPLEX", "LONGEST_GAP", "TRACK_DURATION", "TRACK_START", 
> /* 109 */           "TRACK_STOP", "TRACK_DISPLACEMENT", "TRACK_X_LOCATION", "TRACK_Y_LOCATION", "TRACK_Z_LOCATION", 
> /* 110 */           "TRACK_MEAN_SPEED", "TRACK_MAX_SPEED", "TRACK_MIN_SPEED", "TRACK_MEDIAN_SPEED", "TRACK_STD_SPEED", 
> /* 111 */           "TRACK_MEAN_QUALITY", "TOTAL_DISTANCE_TRAVELED", "MAX_DISTANCE_TRAVELED", "CONFINMENT_RATIO", 
> /* 112 */           "MEAN_STRAIGHT_LINE_SPEED", "LINEARITY_OF_FORWARD_PROGRESSION", "MEAN_DIRECTIONAL_CHANGE_RATE", 
> /* 113 */           "MSD timelag=1", "MSD timelag=2", "MSD timelag=3", "MSD", "Diffusion Coef.", "D1-4", 
> /* 114 */           "Track Length", "Motility", "Alpha", "Movement", "sMSS", "sMSS Movement" };
> /*     */     }
> /* 116 */     itemsTracks = new CheckableItem[columnNamesTracks.length]; int i;
> /* 117 */     for (i = 0; i < columnNamesSpot.length; i++) {
> /* 118 */       itemsSpots[i] = new CheckableItem(columnNamesSpot[i], false);
> /*     */     }
> /* 120 */     for (i = 0; i < columnNamesLinks.length; i++) {
> /* 121 */       itemsLinks[i] = new CheckableItem(columnNamesLinks[i], false);
> /*     */     }
> /* 123 */     for (i = 0; i < columnNamesTracks.length; i++) {
> /* 124 */       itemsTracks[i] = new CheckableItem(columnNamesTracks[i], false);
> /*     */     }
> /* 126 */     comboSpots = new CheckedComboBox(new DefaultComboBoxModel<>(itemsSpots));
> /* 127 */     comboSpots.setOpaque(true);
> /* 128 */     comboSpots.setToolTipText("Select parameter to build the summary for links.");
> /* 129 */     comboSpots.setSelectedItem(itemsSpots[0]);
> /*     */     
> /* 131 */     comboLinks = new CheckedComboBox(new DefaultComboBoxModel<>(itemsLinks));
> /* 132 */     comboLinks.setOpaque(true);
> /* 133 */     comboLinks.setToolTipText("Select parameter to build the summary for links.");
> /* 134 */     comboLinks.setSelectedItem(itemsLinks[0]);
> /*     */     
> /* 136 */     comboTracks = new CheckedComboBox(new DefaultComboBoxModel<>(itemsTracks));
> /* 137 */     comboTracks.setOpaque(true);
> /* 138 */     comboTracks.setToolTipText("Select parameter to build the summary for tracks.");
> /* 139 */     comboTracks.setSelectedItem(itemsTracks[0]);
> /*     */     
> /* 141 */     panel.add(combo);
> /*     */     
> /* 143 */     JLabel columnParamLabel = new JLabel("Column Parameter: ");
> /* 144 */     panel.add(columnParamLabel);
> /*     */     
> /* 146 */     okButton = new JButton("OK");
> /* 147 */     okButton.setBounds(10, 80, 80, 25);
> /* 148 */     panel.add(okButton);
> /* 149 */     okButton.addActionListener(new ActionListener() {
> /*     */           public void actionPerformed(ActionEvent event) {
> /* 151 */             summaryColsWindow.indexSLT = summaryColsWindow.combo.getSelectedIndex();
> /* 152 */             summaryColsWindow.frame.setVisible(false);
> /*     */           }
> /*     */         });
> /*     */     
> /* 156 */     combo.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent e) {
> /* 159 */             if ((panel.getComponents()).length == 5)
> /* 160 */               panel.remove(3); 
> /* 161 */             if (summaryColsWindow.combo.getSelectedIndex() == 0) {
> /* 162 */               panel.add((Component)summaryColsWindow.comboSpots, 3);
> /*     */             }
> /* 164 */             if (summaryColsWindow.combo.getSelectedIndex() == 1) {
> /* 165 */               panel.add((Component)summaryColsWindow.comboLinks, 3);
> /*     */             }
> /* 167 */             if (summaryColsWindow.combo.getSelectedIndex() == 2)
> /* 168 */               panel.add((Component)summaryColsWindow.comboTracks, 3); 
> /*     */           }
> /*     */         });
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/summaryColsWindow.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: TrackAnalyzer_$1$1.java
Only in jd-gui: TrackAnalyzer_$1.java
Only in jd-gui: TrackAnalyzer_$2$1.java
Only in jd-gui: TrackAnalyzer_$2.java
diff -r TrackAnalyzer_/TrackAnalyzer_.java jd-gui/TrackAnalyzer_.java
1,211c1,237
< import ij.measure.Measurements;
< import ij.plugin.PlugIn;
< import java.awt.Component;
< import java.awt.FlowLayout;
< import java.awt.Font;
< import java.awt.Panel;
< import java.awt.TextField;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.WindowEvent;
< import java.net.URL;
< import java.util.prefs.Preferences;
< import javax.swing.BoxLayout;
< import javax.swing.Icon;
< import javax.swing.ImageIcon;
< import javax.swing.JButton;
< import javax.swing.JFrame;
< import javax.swing.JLabel;
< import javax.swing.JPanel;
< import javax.swing.UIManager;
< import javax.swing.UnsupportedLookAndFeelException;
< import javax.swing.UIManager.LookAndFeelInfo;
< import jwizardcomponent.JWizardPanel;
< import jwizardcomponent.Utilities;
< import jwizardcomponent.frame.JWizardFrame;
< 
< public class TrackAnalyzer_ implements PlugIn, Measurements {
<    static String SLTDISPLAYER_XML_PATH;
<    static String SLTDISPLAYER_IMAGES_PATH;
<    static String xmlPath;
<    static String imagesPath;
<    Preferences prefXml;
<    Preferences prefImages;
<    JPanel panelInitial;
<    JFrame frame;
<    JWizardFrame wizard;
<    JWizardPanel panel;
<    public static final int PANEL_FIRST = 0;
<    public static final int PANEL_CHOOSER = 1;
<    public static final int PANEL_OPTION_A = 2;
<    public static final int PANEL_OPTION_B = 3;
<    public static final int PANEL_LAST = 4;
<    public static TextField textXml;
<    public static TextField textImages;
<    Thread sptViewer;
<    Thread sptBatch;
< 
<    public void run(String arg0) {
<       JFrame.setDefaultLookAndFeelDecorated(true);
< 
<       try {
<          LookAndFeelInfo[] var5;
<          int var4 = (var5 = UIManager.getInstalledLookAndFeels()).length;
< 
<          for(int var3 = 0; var3 < var4; ++var3) {
<             LookAndFeelInfo info = var5[var3];
<             if ("Nimbus".equals(info.getName())) {
<                UIManager.setLookAndFeel(info.getClassName());
<                break;
<             }
<          }
<       } catch (UnsupportedLookAndFeelException var19) {
<       } catch (ClassNotFoundException var20) {
<       } catch (InstantiationException var21) {
<       } catch (IllegalAccessException var22) {
<       }
< 
<       this.prefXml = Preferences.userRoot();
<       this.prefImages = Preferences.userRoot();
<       SLTDISPLAYER_XML_PATH = "xml_path";
<       SLTDISPLAYER_IMAGES_PATH = "images_path";
<       JButton buttonBrowse1 = new JButton("");
<       JButton buttonBrowse2 = new JButton("");
<       ImageIcon iconBrowse = this.createImageIcon("images/browse.png");
<       Icon iconBrowseCell = new ImageIcon(iconBrowse.getImage().getScaledInstance(15, 15, 4));
<       buttonBrowse1.setIcon(iconBrowseCell);
<       this.panelInitial = new JPanel();
<       this.panelInitial.setLayout(new BoxLayout(this.panelInitial, 1));
<       textXml = new TextField(20);
<       textXml.setText(this.prefXml.get(SLTDISPLAYER_XML_PATH, ""));
<       textImages = new TextField(20);
<       textImages.setText(this.prefImages.get(SLTDISPLAYER_IMAGES_PATH, ""));
<       JLabel labelXml = new JLabel("  Load TrackMate .XML file: ");
<       labelXml.setFont(new Font("Verdana", 1, 12));
<       JLabel labelImages = new JLabel("  Load movies to be analyzed:   ");
<       labelImages.setFont(new Font("Verdana", 1, 12));
<       DirectoryListener listenerXml = new DirectoryListener("Browse for TrackMate XML file...  ", textXml, 2);
<       DirectoryListener listenerImages = new DirectoryListener("Browse for movies...  ", textImages, 2);
<       buttonBrowse2.setIcon(iconBrowseCell);
<       buttonBrowse1.addActionListener(listenerXml);
<       buttonBrowse2.addActionListener(listenerImages);
<       Panel panelXml = new Panel();
<       panelXml.setLayout(new FlowLayout(0));
<       panelXml.add(labelXml);
<       panelXml.add(textXml);
<       panelXml.add(buttonBrowse1);
<       Panel panelImages = new Panel();
<       panelImages.setLayout(new FlowLayout(0));
<       panelImages.add(labelImages);
<       panelImages.add(textImages);
<       panelImages.add(buttonBrowse2);
<       JButton okButton = new JButton("SPT-Viewer");
<       ImageIcon iconOk = this.createImageIcon("images/viewer.png");
<       Icon iconOkCell = new ImageIcon(iconOk.getImage().getScaledInstance(15, 15, 4));
<       okButton.setIcon(iconOkCell);
<       JButton cancelButton = new JButton("SPT-Batch");
<       ImageIcon iconCancel = this.createImageIcon("images/batch.png");
<       Icon iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(15, 15, 4));
<       cancelButton.setIcon(iconCancelCell);
<       Panel panelOkCancel = new Panel();
<       panelOkCancel.setLayout(new FlowLayout(1));
<       panelOkCancel.add(okButton);
<       panelOkCancel.add(cancelButton);
<       this.panelInitial.add(panelXml);
<       this.panelInitial.add(panelImages);
<       this.panelInitial.add(panelOkCancel);
<       this.createFrame();
<       okButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent event) {
<             TrackAnalyzer_.this.sptViewer = new Thread(new Runnable() {
<                public void run() {
<                   TrackAnalyzer_.xmlPath = TrackAnalyzer_.textXml.getText();
<                   TrackAnalyzer_.imagesPath = TrackAnalyzer_.textImages.getText();
<                   TrackAnalyzer_.this.prefXml.put(TrackAnalyzer_.SLTDISPLAYER_XML_PATH, TrackAnalyzer_.textXml.getText());
<                   TrackAnalyzer_.this.prefImages.put(TrackAnalyzer_.SLTDISPLAYER_IMAGES_PATH, TrackAnalyzer_.textImages.getText());
<                   TrackAnalyzer_.this.frame.dispatchEvent(new WindowEvent(TrackAnalyzer_.this.frame, 201));
<                   TrackAnalyzer_.this.wizard = new JWizardFrame();
<                   TrackAnalyzer_.this.wizard.setTitle("SLT Viewer: ANALYSIS");
<                   TrackAnalyzer_.this.panel = new FirstWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents());
<                   TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(0, TrackAnalyzer_.this.panel);
<                   TrackAnalyzer_.this.panel = new ChooserWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents());
<                   TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(1, TrackAnalyzer_.this.panel);
<                   TrackAnalyzer_.this.panel = new OptionWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents(), "A");
<                   TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(2, TrackAnalyzer_.this.panel);
<                   TrackAnalyzer_.this.panel = new OptionWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents(), "B");
<                   TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(3, TrackAnalyzer_.this.panel);
<                   TrackAnalyzer_.this.panel = new LastWizardPanel(TrackAnalyzer_.this.wizard.getWizardComponents());
<                   TrackAnalyzer_.this.wizard.getWizardComponents().addWizardPanel(4, TrackAnalyzer_.this.panel);
<                   Component[] components = null;
< 
<                   try {
<                      components = TrackAnalyzer_.this.wizard.getWizardComponents().getFinishButton().getParent().getComponents();
<                   } catch (Exception var11) {
<                      var11.printStackTrace();
<                   }
< 
<                   TrackAnalyzer_.this.wizard.getWizardComponents().getFinishButton().getParent().remove(components[2]);
<                   JButton backButton = TrackAnalyzer_.this.wizard.getWizardComponents().getBackButton();
<                   backButton.setText("");
<                   ImageIcon iconBack = TrackAnalyzer_.this.createImageIcon("images/next.png");
<                   Icon backCell = new ImageIcon(iconBack.getImage().getScaledInstance(20, 22, 4));
<                   backButton.setIcon(backCell);
<                   backButton.setToolTipText("Click this button to back on wizard.");
<                   JButton nextButton = TrackAnalyzer_.this.wizard.getWizardComponents().getNextButton();
<                   nextButton.setText("");
<                   ImageIcon iconNext = TrackAnalyzer_.this.createImageIcon("images/back.png");
<                   Icon nextCell = new ImageIcon(iconNext.getImage().getScaledInstance(20, 22, 4));
<                   nextButton.setIcon(nextCell);
<                   nextButton.setToolTipText("Click this button to switch wizard.");
<                   JButton cancelButton = TrackAnalyzer_.this.wizard.getWizardComponents().getCancelButton();
<                   cancelButton.setText("");
<                   ImageIcon iconCancel = TrackAnalyzer_.this.createImageIcon("images/cancel.png");
<                   Icon cancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(20, 22, 4));
<                   cancelButton.setIcon(cancelCell);
<                   cancelButton.setToolTipText("Click this button to cancel the process.");
<                   TrackAnalyzer_.this.wizard.setSize(630, 1000);
<                   Utilities.centerComponentOnScreen(TrackAnalyzer_.this.wizard);
<                   TrackAnalyzer_.this.wizard.setVisible(true);
<                }
<             });
<             TrackAnalyzer_.this.sptViewer.start();
<          }
<       });
<       cancelButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent event) {
<             TrackAnalyzer_.this.sptBatch = new Thread(new Runnable() {
<                public void run() {
<                   TrackAnalyzer_.xmlPath = TrackAnalyzer_.textXml.getText();
<                   TrackAnalyzer_.imagesPath = TrackAnalyzer_.textImages.getText();
<                   TrackAnalyzer_.this.prefXml.put(TrackAnalyzer_.SLTDISPLAYER_XML_PATH, TrackAnalyzer_.textXml.getText());
<                   TrackAnalyzer_.this.prefImages.put(TrackAnalyzer_.SLTDISPLAYER_IMAGES_PATH, TrackAnalyzer_.textImages.getText());
<                   SPTBatch_ sptBatch = new SPTBatch_(TrackAnalyzer_.xmlPath, TrackAnalyzer_.imagesPath);
<                   sptBatch.run("");
<                   TrackAnalyzer_.this.frame.dispatchEvent(new WindowEvent(TrackAnalyzer_.this.frame, 201));
<                }
<             });
<             TrackAnalyzer_.this.sptBatch.start();
<          }
<       });
<    }
< 
<    public void createFrame() {
<       this.frame = new JFrame("TrackAnalyzer");
<       this.frame.setDefaultCloseOperation(2);
<       this.frame.setSize(400, 500);
<       this.frame.setResizable(false);
<       this.frame.getContentPane().add(this.panelInitial);
<       this.frame.pack();
<       this.frame.setVisible(true);
<    }
< 
<    protected ImageIcon createImageIcon(String path) {
<       URL img = TrackAnalyzer_.class.getResource(path);
<       if (img != null) {
<          return new ImageIcon(img);
<       } else {
<          System.err.println("Couldn't find file: " + path);
<          return null;
<       }
<    }
< }
---
> /*     */ import ij.measure.Measurements;
> /*     */ import ij.plugin.PlugIn;
> /*     */ import java.awt.Component;
> /*     */ import java.awt.FlowLayout;
> /*     */ import java.awt.Font;
> /*     */ import java.awt.Panel;
> /*     */ import java.awt.TextField;
> /*     */ import java.awt.event.ActionEvent;
> /*     */ import java.awt.event.ActionListener;
> /*     */ import java.awt.event.WindowEvent;
> /*     */ import java.net.URL;
> /*     */ import java.util.prefs.Preferences;
> /*     */ import javax.swing.BoxLayout;
> /*     */ import javax.swing.Icon;
> /*     */ import javax.swing.ImageIcon;
> /*     */ import javax.swing.JButton;
> /*     */ import javax.swing.JFrame;
> /*     */ import javax.swing.JLabel;
> /*     */ import javax.swing.JPanel;
> /*     */ import javax.swing.UIManager;
> /*     */ import javax.swing.UnsupportedLookAndFeelException;
> /*     */ import jwizardcomponent.JWizardPanel;
> /*     */ import jwizardcomponent.Utilities;
> /*     */ import jwizardcomponent.frame.JWizardFrame;
> /*     */ 
> /*     */ 
> /*     */ public class TrackAnalyzer_
> /*     */   implements PlugIn, Measurements
> /*     */ {
> /*     */   static String SLTDISPLAYER_XML_PATH;
> /*     */   static String SLTDISPLAYER_IMAGES_PATH;
> /*     */   static String xmlPath;
> /*     */   static String imagesPath;
> /*     */   Preferences prefXml;
> /*     */   Preferences prefImages;
> /*     */   JPanel panelInitial;
> /*     */   JFrame frame;
> /*     */   JWizardFrame wizard;
> /*     */   JWizardPanel panel;
> /*     */   public static final int PANEL_FIRST = 0;
> /*     */   public static final int PANEL_CHOOSER = 1;
> /*     */   public static final int PANEL_OPTION_A = 2;
> /*     */   public static final int PANEL_OPTION_B = 3;
> /*     */   public static final int PANEL_LAST = 4;
> /*     */   public static TextField textXml;
> /*     */   public static TextField textImages;
> /*     */   Thread sptViewer;
> /*     */   Thread sptBatch;
> /*     */   
> /*     */   public void run(String arg0) {
> /*  51 */     JFrame.setDefaultLookAndFeelDecorated(true); try {
> /*     */       byte b; int i; UIManager.LookAndFeelInfo[] arrayOfLookAndFeelInfo;
> /*  53 */       for (i = (arrayOfLookAndFeelInfo = UIManager.getInstalledLookAndFeels()).length, b = 0; b < i; ) { UIManager.LookAndFeelInfo info = arrayOfLookAndFeelInfo[b];
> /*  54 */         if ("Nimbus".equals(info.getName())) {
> /*  55 */           UIManager.setLookAndFeel(info.getClassName()); break;
> /*     */         } 
> /*     */         b++; }
> /*     */     
> /*  59 */     } catch (UnsupportedLookAndFeelException unsupportedLookAndFeelException) {
> /*     */     
> /*  61 */     } catch (ClassNotFoundException classNotFoundException) {
> /*     */     
> /*  63 */     } catch (InstantiationException instantiationException) {
> /*     */     
> /*  65 */     } catch (IllegalAccessException illegalAccessException) {}
> /*     */ 
> /*     */ 
> /*     */     
> /*  69 */     this.prefXml = Preferences.userRoot();
> /*  70 */     this.prefImages = Preferences.userRoot();
> /*  71 */     SLTDISPLAYER_XML_PATH = "xml_path";
> /*  72 */     SLTDISPLAYER_IMAGES_PATH = "images_path";
> /*     */     
> /*  74 */     JButton buttonBrowse1 = new JButton("");
> /*  75 */     JButton buttonBrowse2 = new JButton("");
> /*  76 */     ImageIcon iconBrowse = createImageIcon("images/browse.png");
> /*  77 */     Icon iconBrowseCell = new ImageIcon(iconBrowse.getImage().getScaledInstance(15, 15, 4));
> /*  78 */     buttonBrowse1.setIcon(iconBrowseCell);
> /*  79 */     this.panelInitial = new JPanel();
> /*  80 */     this.panelInitial.setLayout(new BoxLayout(this.panelInitial, 1));
> /*     */     
> /*  82 */     textXml = new TextField(20);
> /*  83 */     textXml.setText(this.prefXml.get(SLTDISPLAYER_XML_PATH, ""));
> /*  84 */     textImages = new TextField(20);
> /*  85 */     textImages.setText(this.prefImages.get(SLTDISPLAYER_IMAGES_PATH, ""));
> /*  86 */     JLabel labelXml = new JLabel("  Load TrackMate .XML file: ");
> /*  87 */     labelXml.setFont(new Font("Verdana", 1, 12));
> /*  88 */     JLabel labelImages = new JLabel("  Load movies to be analyzed:   ");
> /*  89 */     labelImages.setFont(new Font("Verdana", 1, 12));
> /*  90 */     DirectoryListener listenerXml = new DirectoryListener("Browse for TrackMate XML file...  ", textXml, 
> /*  91 */         2);
> /*  92 */     DirectoryListener listenerImages = new DirectoryListener("Browse for movies...  ", textImages, 
> /*  93 */         2);
> /*  94 */     buttonBrowse2.setIcon(iconBrowseCell);
> /*  95 */     buttonBrowse1.addActionListener(listenerXml);
> /*  96 */     buttonBrowse2.addActionListener(listenerImages);
> /*     */     
> /*  98 */     Panel panelXml = new Panel();
> /*  99 */     panelXml.setLayout(new FlowLayout(0));
> /* 100 */     panelXml.add(labelXml);
> /* 101 */     panelXml.add(textXml);
> /* 102 */     panelXml.add(buttonBrowse1);
> /* 103 */     Panel panelImages = new Panel();
> /* 104 */     panelImages.setLayout(new FlowLayout(0));
> /* 105 */     panelImages.add(labelImages);
> /* 106 */     panelImages.add(textImages);
> /* 107 */     panelImages.add(buttonBrowse2);
> /* 108 */     JButton okButton = new JButton("SPT-Viewer");
> /* 109 */     ImageIcon iconOk = createImageIcon("images/viewer.png");
> /* 110 */     Icon iconOkCell = new ImageIcon(iconOk.getImage().getScaledInstance(15, 15, 4));
> /* 111 */     okButton.setIcon(iconOkCell);
> /* 112 */     JButton cancelButton = new JButton("SPT-Batch");
> /* 113 */     ImageIcon iconCancel = createImageIcon("images/batch.png");
> /* 114 */     Icon iconCancelCell = new ImageIcon(iconCancel.getImage().getScaledInstance(15, 15, 4));
> /* 115 */     cancelButton.setIcon(iconCancelCell);
> /* 116 */     Panel panelOkCancel = new Panel();
> /* 117 */     panelOkCancel.setLayout(new FlowLayout(1));
> /* 118 */     panelOkCancel.add(okButton);
> /* 119 */     panelOkCancel.add(cancelButton);
> /* 120 */     this.panelInitial.add(panelXml);
> /* 121 */     this.panelInitial.add(panelImages);
> /* 122 */     this.panelInitial.add(panelOkCancel);
> /* 123 */     createFrame();
> /* 124 */     okButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent event) {
> /* 127 */             TrackAnalyzer_.this.sptViewer = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 129 */                     TrackAnalyzer_.xmlPath = TrackAnalyzer_.textXml.getText();
> /* 130 */                     TrackAnalyzer_.imagesPath = TrackAnalyzer_.textImages.getText();
> /* 131 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).prefXml.put(TrackAnalyzer_.SLTDISPLAYER_XML_PATH, TrackAnalyzer_.textXml.getText());
> /* 132 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).prefImages.put(TrackAnalyzer_.SLTDISPLAYER_IMAGES_PATH, TrackAnalyzer_.textImages.getText());
> /* 133 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).frame.dispatchEvent(new WindowEvent((TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).frame, 201));
> /* 134 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard = new JWizardFrame();
> /* 135 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.setTitle("SLT Viewer: ANALYSIS");
> /*     */                     
> /* 137 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).panel = new FirstWizardPanel((TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents());
> /* 138 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents().addWizardPanel(0, (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).panel);
> /*     */                     
> /* 140 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).panel = new ChooserWizardPanel((TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents());
> /* 141 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents().addWizardPanel(1, (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).panel);
> /*     */                     
> /* 143 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).panel = new OptionWizardPanel((TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents(), "A");
> /* 144 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents().addWizardPanel(2, (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).panel);
> /*     */                     
> /* 146 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).panel = new OptionWizardPanel((TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents(), "B");
> /* 147 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents().addWizardPanel(3, (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).panel);
> /*     */                     
> /* 149 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).panel = new LastWizardPanel((TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents());
> /* 150 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents().addWizardPanel(4, (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).panel);
> /* 151 */                     Component[] components = null;
> /*     */                     try {
> /* 153 */                       components = (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents().getFinishButton().getParent().getComponents();
> /* 154 */                     } catch (Exception e) {
> /*     */                       
> /* 156 */                       e.printStackTrace();
> /*     */                     } 
> /*     */                     
> /* 159 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents().getFinishButton().getParent().remove(components[2]);
> /* 160 */                     JButton backButton = (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents().getBackButton();
> /* 161 */                     backButton.setText("");
> /* 162 */                     ImageIcon iconBack = TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this).createImageIcon("images/next.png");
> /* 163 */                     Icon backCell = new ImageIcon(
> /* 164 */                         iconBack.getImage().getScaledInstance(20, 22, 4));
> /* 165 */                     backButton.setIcon(backCell);
> /* 166 */                     backButton.setToolTipText("Click this button to back on wizard.");
> /* 167 */                     JButton nextButton = (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents().getNextButton();
> /* 168 */                     nextButton.setText("");
> /* 169 */                     ImageIcon iconNext = TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this).createImageIcon("images/back.png");
> /* 170 */                     Icon nextCell = new ImageIcon(
> /* 171 */                         iconNext.getImage().getScaledInstance(20, 22, 4));
> /* 172 */                     nextButton.setIcon(nextCell);
> /* 173 */                     nextButton.setToolTipText("Click this button to switch wizard.");
> /* 174 */                     JButton cancelButton = (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.getWizardComponents().getCancelButton();
> /* 175 */                     cancelButton.setText("");
> /* 176 */                     ImageIcon iconCancel = TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this).createImageIcon("images/cancel.png");
> /* 177 */                     Icon cancelCell = new ImageIcon(
> /* 178 */                         iconCancel.getImage().getScaledInstance(20, 22, 4));
> /* 179 */                     cancelButton.setIcon(cancelCell);
> /* 180 */                     cancelButton.setToolTipText("Click this button to cancel the process.");
> /* 181 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.setSize(630, 1000);
> /* 182 */                     Utilities.centerComponentOnScreen((Component)(TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard);
> /*     */                     
> /* 184 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).wizard.setVisible(true);
> /*     */                   }
> /*     */                 });
> /* 187 */             TrackAnalyzer_.this.sptViewer.start();
> /*     */           }
> /*     */         });
> /*     */     
> /* 191 */     cancelButton.addActionListener(new ActionListener()
> /*     */         {
> /*     */           public void actionPerformed(ActionEvent event) {
> /* 194 */             TrackAnalyzer_.this.sptBatch = new Thread(new Runnable() {
> /*     */                   public void run() {
> /* 196 */                     TrackAnalyzer_.xmlPath = TrackAnalyzer_.textXml.getText();
> /* 197 */                     TrackAnalyzer_.imagesPath = TrackAnalyzer_.textImages.getText();
> /* 198 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).prefXml.put(TrackAnalyzer_.SLTDISPLAYER_XML_PATH, TrackAnalyzer_.textXml.getText());
> /* 199 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).prefImages.put(TrackAnalyzer_.SLTDISPLAYER_IMAGES_PATH, TrackAnalyzer_.textImages.getText());
> /* 200 */                     SPTBatch_ sptBatch = new SPTBatch_(TrackAnalyzer_.xmlPath, TrackAnalyzer_.imagesPath);
> /* 201 */                     sptBatch.run("");
> /* 202 */                     (TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).frame.dispatchEvent(new WindowEvent((TrackAnalyzer_.null.access$0(TrackAnalyzer_.null.this)).frame, 201));
> /*     */                   }
> /*     */                 });
> /* 205 */             TrackAnalyzer_.this.sptBatch.start();
> /*     */           }
> /*     */         });
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void createFrame() {
> /* 213 */     this.frame = new JFrame("TrackAnalyzer");
> /* 214 */     this.frame.setDefaultCloseOperation(2);
> /* 215 */     this.frame.setSize(400, 500);
> /* 216 */     this.frame.setResizable(false);
> /* 217 */     this.frame.getContentPane().add(this.panelInitial);
> /* 218 */     this.frame.pack();
> /* 219 */     this.frame.setVisible(true);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   protected ImageIcon createImageIcon(String path) {
> /* 224 */     URL img = TrackAnalyzer_.class.getResource(path);
> /* 225 */     if (img != null) {
> /* 226 */       return new ImageIcon(img);
> /*     */     }
> /* 228 */     System.err.println("Couldn't find file: " + path);
> /* 229 */     return null;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/TrackAnalyzer_.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/TrackProcessorMSD_Modified.java jd-gui/TrackProcessorMSD_Modified.java
1,178c1,220
< import fiji.plugin.trackmate.Spot;
< import fiji.plugin.trackmate.gui.displaysettings.Colormap;
< import fiji.plugin.trackmate.visualization.PerTrackFeatureColorGenerator;
< import ij.measure.ResultsTable;
< import java.awt.Color;
< import java.awt.Point;
< import java.awt.event.KeyEvent;
< import java.awt.event.MouseEvent;
< import java.awt.geom.Rectangle2D;
< import java.awt.geom.Rectangle2D.Float;
< import java.io.File;
< import java.io.IOException;
< import java.util.ArrayList;
< import java.util.Iterator;
< import java.util.List;
< import javax.swing.JButton;
< import javax.swing.JCheckBox;
< import javax.swing.JLabel;
< import javax.swing.JPanel;
< import javax.swing.JTextField;
< import org.jfree.chart.ChartFactory;
< import org.jfree.chart.ChartPanel;
< import org.jfree.chart.ChartUtils;
< import org.jfree.chart.JFreeChart;
< import org.jfree.chart.plot.PlotOrientation;
< import org.jfree.chart.plot.XYPlot;
< import org.jfree.chart.renderer.xy.XYItemRenderer;
< import org.jfree.data.xy.XYSeries;
< import org.jfree.data.xy.XYSeriesCollection;
< 
< public class TrackProcessorMSD_Modified {
<    JFreeChart chart;
<    JCheckBox displayLegendCheckBox = new JCheckBox("Display legend.", false);
<    JCheckBox displayGraphInSequenceCheckBox = new JCheckBox("Display graph on sequence.", false);
<    JButton useRoiAsBoundsForChartButton = new JButton("place graph in ROI #1");
<    JCheckBox forceAllSequenceGraphWidthCheckBox = new JCheckBox("Force graph width.", false);
<    JCheckBox useRealScalesBox = new JCheckBox("use real scales", false);
<    JPanel chartpanel = new JPanel();
<    JTextField scaleTextField = new JTextField("1.0");
<    JButton exportButton = new JButton("export to console");
<    JButton exportExcelButton = new JButton("export to excel");
<    Rectangle2D chartRectangleInSequence = new Float(250.0F, 20.0F, 490.0F, 240.0F);
<    JLabel outLabel = new JLabel();
< 
<    public TrackProcessorMSD_Modified() {
<       this.chartpanel.add(new ChartPanel(this.chart, 500, 300, 500, 300, 500, 300, false, false, true, true, true, true));
<    }
< 
<    public void Compute(List<Integer> nOfTracks, ResultsTable rtSpots) {
<       XYSeriesCollection xyDataset = new XYSeriesCollection();
<       XYSeries series = null;
<       List<List<Double>> imported2SpotX = new ArrayList();
<       List<List<Double>> imported2SpotY = new ArrayList();
<       List<List<Double>> imported2SpotT = new ArrayList();
<       List<Integer> trackName = new ArrayList();
< 
<       for(int id = 0; id < nOfTracks.size(); ++id) {
<          trackName.add((Integer)nOfTracks.get(id));
<          List<Double> imported1SpotX = new ArrayList();
<          List<Double> imported1SpotY = new ArrayList();
<          List<Double> imported1SpotT = new ArrayList();
< 
<          for(int i = 0; i < rtSpots.size(); ++i) {
<             if (rtSpots.getStringValue(2, i).equals(String.valueOf((Integer)nOfTracks.get(id))) == Boolean.TRUE) {
<                imported1SpotX.add(Double.valueOf(rtSpots.getStringValue(4, i)));
<                imported1SpotY.add(Double.valueOf(rtSpots.getStringValue(5, i)));
<                imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(7, i)));
<             }
<          }
< 
<          imported2SpotX.add(imported1SpotX);
<          imported2SpotY.add(imported1SpotY);
<          imported2SpotT.add(imported1SpotT);
<       }
< 
<       String TitleString = "";
<       String TitleString2 = "";
<       String TitleString3 = "";
< 
<       for(int i = 0; i < imported2SpotX.size(); ++i) {
<          series = new XYSeries("Track " + i);
<          if (SPTBatch_.imps.getCalibration().getXUnit() != "pixel") {
<             TitleString = "Mean Square Displacement";
<             TitleString2 = "Delta (s)";
<             TitleString3 = "MSD (" + SPTBatch_.imps.getCalibration().getXUnit() + "^2)";
<          }
< 
<          if (SPTBatch_.imps.getCalibration().getXUnit() == "pixel") {
<             TitleString = "Mean Square Displacement";
<             TitleString2 = "Delta (frame)";
<             TitleString3 = "MSD (pixel^2)";
<          }
< 
<          double frameInterval = (Double)((List)imported2SpotT.get(i)).get(2) - (Double)((List)imported2SpotT.get(i)).get(1);
<          int nMSD = ((List)imported2SpotX.get(i)).size();
<          int[] tau = new int[nMSD - 1];
<          double[] msdArray = new double[tau.length];
< 
<          for(int z = 0; z < nMSD - 1 - 1 + 1; ++z) {
<             tau[z] = 1 + z;
<          }
< 
<          double msd = -1.0D;
< 
<          for(int dt = 0; dt < tau.length; ++dt) {
<             double N = 0.0D;
<             msd = 0.0D;
< 
<             for(int j = tau[dt]; j < ((List)imported2SpotX.get(i)).size(); ++j) {
<                msd = msd + Math.pow((Double)((List)imported2SpotX.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotX.get(i)).get(j), 2.0D) + Math.pow((Double)((List)imported2SpotY.get(i)).get(j - tau[dt]) - (Double)((List)imported2SpotY.get(i)).get(j), 2.0D);
<                ++N;
<             }
< 
<             msd /= N;
<             msdArray[dt] = msd;
<             series.add((double)tau[dt] * frameInterval, msd);
<          }
< 
<          xyDataset.addSeries(series);
<       }
< 
<       this.chart = ChartFactory.createXYLineChart(TitleString, TitleString2, TitleString3, xyDataset, PlotOrientation.VERTICAL, this.displayLegendCheckBox.isSelected(), true, false);
<       XYPlot plot = (XYPlot)this.chart.getPlot();
<       plot.setBackgroundPaint(Color.white);
<       plot.setDomainGridlinesVisible(true);
<       plot.setRangeGridlinesVisible(true);
<       plot.setDomainMinorGridlinePaint(Color.GRAY);
<       plot.setDomainGridlinePaint(Color.DARK_GRAY);
<       plot.setRangeMinorGridlinePaint(Color.GRAY);
<       plot.setRangeGridlinePaint(Color.DARK_GRAY);
<       this.chartpanel.removeAll();
<       if (this.chart != null) {
<          XYItemRenderer renderer = ((XYPlot)this.chart.getPlot()).getRenderer();
<          Iterator var33 = nOfTracks.iterator();
< 
<          while(var33.hasNext()) {
<             Integer id = (Integer)var33.next();
<             PerTrackFeatureColorGenerator tcg = new PerTrackFeatureColorGenerator(SPTBatch_.model, "TRACK_INDEX", (Color)null, (Color)null, Colormap.Turbo, 0.0D, 1.0D);
<             renderer.setSeriesPaint(id, tcg.colorOf(id));
<          }
<       }
< 
<       this.chartpanel.add(new ChartPanel(this.chart, 400, 300, 400, 300, 400, 300, false, false, true, true, true, true));
<       this.chartpanel.updateUI();
<       if (SPTBatch_.checkboxDiff.isSelected() == Boolean.TRUE) {
<          try {
<             ChartUtils.saveChartAsPNG(new File(SPTBatch_.directDiff.getAbsolutePath() + File.separator + "MSD_curve_" + SPTBatch_.imps.getShortTitle() + ".png"), this.chart, 500, 400);
<          } catch (IOException var25) {
<             var25.printStackTrace();
<          }
<       }
< 
<       if (SPTBatch_.checkboxDiff.isSelected() == Boolean.FALSE) {
<          try {
<             ChartUtils.saveChartAsPNG(new File(SPTBatch_.directImages.getAbsolutePath() + File.separator + "MSD_curve_" + SPTBatch_.imps.getShortTitle() + ".png"), this.chart, 500, 400);
<          } catch (IOException var24) {
<             var24.printStackTrace();
<          }
<       }
< 
<    }
< 
<    private static double scaledSquaredDistance(Spot spotSource, Spot spotTarget, double sx, double sy, double sz) {
<       return Math.pow((spotSource.getFeature("POSITION_X") - spotTarget.getFeature("POSITION_X")) * sx, 2.0D) + Math.pow((spotSource.getFeature("POSITION_Y") - spotTarget.getFeature("POSITION_Y")) * sy, 2.0D);
<    }
< 
<    public void keyPressed(Point p, KeyEvent e) {
<    }
< 
<    public void mouseClick(Point p, MouseEvent e) {
<    }
< 
<    public void mouseDrag(Point p, MouseEvent e) {
<    }
< 
<    public void mouseMove(Point p, MouseEvent e) {
<    }
< }
---
> /*     */ import fiji.plugin.trackmate.Spot;
> /*     */ import fiji.plugin.trackmate.gui.displaysettings.Colormap;
> /*     */ import fiji.plugin.trackmate.visualization.PerTrackFeatureColorGenerator;
> /*     */ import ij.measure.ResultsTable;
> /*     */ import java.awt.Color;
> /*     */ import java.awt.Component;
> /*     */ import java.awt.Point;
> /*     */ import java.awt.event.KeyEvent;
> /*     */ import java.awt.event.MouseEvent;
> /*     */ import java.awt.geom.Rectangle2D;
> /*     */ import java.io.File;
> /*     */ import java.io.IOException;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.List;
> /*     */ import javax.swing.JButton;
> /*     */ import javax.swing.JCheckBox;
> /*     */ import javax.swing.JLabel;
> /*     */ import javax.swing.JPanel;
> /*     */ import javax.swing.JTextField;
> /*     */ import org.jfree.chart.ChartFactory;
> /*     */ import org.jfree.chart.ChartPanel;
> /*     */ import org.jfree.chart.ChartUtils;
> /*     */ import org.jfree.chart.JFreeChart;
> /*     */ import org.jfree.chart.plot.PlotOrientation;
> /*     */ import org.jfree.chart.plot.XYPlot;
> /*     */ import org.jfree.chart.renderer.xy.XYItemRenderer;
> /*     */ import org.jfree.data.xy.XYDataset;
> /*     */ import org.jfree.data.xy.XYSeries;
> /*     */ import org.jfree.data.xy.XYSeriesCollection;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class TrackProcessorMSD_Modified
> /*     */ {
> /*     */   JFreeChart chart;
> /*  51 */   JCheckBox displayLegendCheckBox = new JCheckBox("Display legend.", false);
> /*  52 */   JCheckBox displayGraphInSequenceCheckBox = new JCheckBox("Display graph on sequence.", false);
> /*  53 */   JButton useRoiAsBoundsForChartButton = new JButton("place graph in ROI #1");
> /*  54 */   JCheckBox forceAllSequenceGraphWidthCheckBox = new JCheckBox("Force graph width.", false);
> /*  55 */   JCheckBox useRealScalesBox = new JCheckBox("use real scales", false);
> /*  56 */   JPanel chartpanel = new JPanel();
> /*  57 */   JTextField scaleTextField = new JTextField("1.0");
> /*  58 */   JButton exportButton = new JButton("export to console");
> /*  59 */   JButton exportExcelButton = new JButton("export to excel");
> /*     */ 
> /*     */   
> /*     */   Rectangle2D chartRectangleInSequence;
> /*     */ 
> /*     */   
> /*     */   JLabel outLabel;
> /*     */ 
> /*     */   
> /*     */   public void Compute(List<Integer> nOfTracks, ResultsTable rtSpots) {
> /*  69 */     XYSeriesCollection xyDataset = new XYSeriesCollection();
> /*  70 */     XYSeries series = null;
> /*  71 */     List<List<Double>> imported2SpotX = new ArrayList<>();
> /*  72 */     List<List<Double>> imported2SpotY = new ArrayList<>();
> /*  73 */     List<List<Double>> imported2SpotT = new ArrayList<>();
> /*  74 */     List<Integer> trackName = new ArrayList<>();
> /*     */     
> /*  76 */     for (int id = 0; id < nOfTracks.size(); id++) {
> /*  77 */       trackName.add(nOfTracks.get(id));
> /*  78 */       List<Double> imported1SpotX = new ArrayList<>();
> /*  79 */       List<Double> imported1SpotY = new ArrayList<>();
> /*  80 */       List<Double> imported1SpotT = new ArrayList<>();
> /*  81 */       for (int j = 0; j < rtSpots.size(); j++) {
> /*  82 */         if (rtSpots.getStringValue(2, j).equals(String.valueOf(((Integer)nOfTracks.get(id)).intValue())) == Boolean.TRUE.booleanValue()) {
> /*  83 */           imported1SpotX.add(Double.valueOf(rtSpots.getStringValue(4, j)));
> /*  84 */           imported1SpotY.add(Double.valueOf(rtSpots.getStringValue(5, j)));
> /*  85 */           imported1SpotT.add(Double.valueOf(rtSpots.getStringValue(7, j)));
> /*     */         } 
> /*     */       } 
> /*     */ 
> /*     */       
> /*  90 */       imported2SpotX.add(imported1SpotX);
> /*  91 */       imported2SpotY.add(imported1SpotY);
> /*  92 */       imported2SpotT.add(imported1SpotT);
> /*     */     } 
> /*     */ 
> /*     */     
> /*  96 */     String TitleString = "";
> /*  97 */     String TitleString2 = "";
> /*  98 */     String TitleString3 = "";
> /*     */     
> /* 100 */     for (int i = 0; i < imported2SpotX.size(); i++) {
> /* 101 */       series = new XYSeries("Track " + i);
> /*     */       
> /* 103 */       if (SPTBatch_.imps.getCalibration().getXUnit() != "pixel") {
> /* 104 */         TitleString = "Mean Square Displacement";
> /* 105 */         TitleString2 = "Delta (s)";
> /* 106 */         TitleString3 = "MSD (" + SPTBatch_.imps.getCalibration().getXUnit() + "^2)";
> /*     */       } 
> /*     */       
> /* 109 */       if (SPTBatch_.imps.getCalibration().getXUnit() == "pixel") {
> /* 110 */         TitleString = "Mean Square Displacement";
> /* 111 */         TitleString2 = "Delta (frame)";
> /* 112 */         TitleString3 = "MSD (pixel^2)";
> /*     */       } 
> /*     */ 
> /*     */       
> /* 116 */       double frameInterval = ((Double)((List<Double>)imported2SpotT.get(i)).get(2)).doubleValue() - ((Double)((List<Double>)imported2SpotT.get(i)).get(1)).doubleValue();
> /* 117 */       int nMSD = ((List)imported2SpotX.get(i)).size();
> /* 118 */       int[] tau = new int[nMSD - 1];
> /* 119 */       double[] msdArray = new double[tau.length];
> /* 120 */       for (int z = 0; z < nMSD - 1 - 1 + 1; z++)
> /* 121 */         tau[z] = 1 + z; 
> /* 122 */       double msd = -1.0D;
> /* 123 */       for (int dt = 0; dt < tau.length; dt++) {
> /* 124 */         double N = 0.0D;
> /* 125 */         msd = 0.0D;
> /* 126 */         for (int j = tau[dt]; j < ((List)imported2SpotX.get(i)).size(); j++) {
> /* 127 */           msd = msd + 
> /* 128 */             Math.pow(((Double)((List<Double>)imported2SpotX.get(i)).get(j - tau[dt])).doubleValue() - (
> /* 129 */               (Double)((List<Double>)imported2SpotX.get(i)).get(j)).doubleValue(), 2.0D) + 
> /* 130 */             Math.pow(((Double)((List<Double>)imported2SpotY.get(i)).get(j - tau[dt])).doubleValue() - (
> /* 131 */               (Double)((List<Double>)imported2SpotY.get(i)).get(j)).doubleValue(), 2.0D);
> /* 132 */           N++;
> /*     */         } 
> /*     */         
> /* 135 */         msd /= N;
> /* 136 */         msdArray[dt] = msd;
> /* 137 */         series.add(tau[dt] * frameInterval, msd);
> /*     */       } 
> /*     */ 
> /*     */ 
> /*     */       
> /* 142 */       xyDataset.addSeries(series);
> /*     */     } 
> /*     */     
> /* 145 */     this.chart = ChartFactory.createXYLineChart(TitleString, 
> /* 146 */         TitleString2, 
> /* 147 */         TitleString3, 
> /* 148 */         (XYDataset)xyDataset, 
> /* 149 */         PlotOrientation.VERTICAL, this.displayLegendCheckBox.isSelected(), 
> /* 150 */         true, 
> /* 151 */         false);
> /*     */     
> /* 153 */     XYPlot plot = (XYPlot)this.chart.getPlot();
> /* 154 */     plot.setBackgroundPaint(Color.white);
> /* 155 */     plot.setDomainGridlinesVisible(true);
> /* 156 */     plot.setRangeGridlinesVisible(true);
> /* 157 */     plot.setDomainMinorGridlinePaint(Color.GRAY);
> /* 158 */     plot.setDomainGridlinePaint(Color.DARK_GRAY);
> /* 159 */     plot.setRangeMinorGridlinePaint(Color.GRAY);
> /* 160 */     plot.setRangeGridlinePaint(Color.DARK_GRAY);
> /* 161 */     this.chartpanel.removeAll();
> /*     */     
> /* 163 */     if (this.chart != null) {
> /*     */       
> /* 165 */       XYItemRenderer renderer = ((XYPlot)this.chart.getPlot()).getRenderer();
> /* 166 */       for (Integer integer : nOfTracks) {
> /* 167 */         PerTrackFeatureColorGenerator tcg = new PerTrackFeatureColorGenerator(SPTBatch_.model, 
> /* 168 */             "TRACK_INDEX", null, null, Colormap.Turbo, 0.0D, 1.0D);
> /* 169 */         renderer.setSeriesPaint(integer.intValue(), tcg.colorOf(integer));
> /*     */       } 
> /*     */     } 
> /* 172 */     this.chartpanel.add((Component)new ChartPanel(this.chart, 400, 300, 400, 300, 400, 300, false, false, true, true, true, true));
> /*     */     
> /* 174 */     this.chartpanel.updateUI();
> /* 175 */     if (SPTBatch_.checkboxDiff.isSelected() == Boolean.TRUE.booleanValue()) {
> /*     */       try {
> /* 177 */         ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directDiff.getAbsolutePath()) + File.separator + 
> /* 178 */               "MSD_curve_" + SPTBatch_.imps.getShortTitle() + ".png"), this.chart, 500, 400);
> /* 179 */       } catch (IOException e) {
> /*     */         
> /* 181 */         e.printStackTrace();
> /*     */       } 
> /*     */     }
> /* 184 */     if (SPTBatch_.checkboxDiff.isSelected() == Boolean.FALSE.booleanValue())
> /*     */       try {
> /* 186 */         ChartUtils.saveChartAsPNG(new File(String.valueOf(SPTBatch_.directImages.getAbsolutePath()) + File.separator + 
> /* 187 */               "MSD_curve_" + SPTBatch_.imps.getShortTitle() + ".png"), this.chart, 500, 400);
> /* 188 */       } catch (IOException e) {
> /*     */         
> /* 190 */         e.printStackTrace();
> /*     */       }  
> /*     */   }
> /*     */   
> /*     */   public TrackProcessorMSD_Modified() {
> /* 195 */     this.chartRectangleInSequence = new Rectangle2D.Float(250.0F, 20.0F, 490.0F, 240.0F);
> /*     */     
> /* 197 */     this.outLabel = new JLabel();
> /*     */     this.chartpanel.add((Component)new ChartPanel(this.chart, 500, 300, 500, 300, 500, 300, false, false, true, true, true, true));
> /*     */   } private static double scaledSquaredDistance(Spot spotSource, Spot spotTarget, double sx, double sy, double sz) {
> /* 200 */     return 
> /* 201 */       Math.pow((spotSource.getFeature("POSITION_X").doubleValue() - 
> /* 202 */         spotTarget.getFeature("POSITION_X").doubleValue()) * sx, 2.0D) + 
> /* 203 */       Math.pow((spotSource.getFeature("POSITION_Y").doubleValue() - 
> /* 204 */         spotTarget.getFeature("POSITION_Y").doubleValue()) * sy, 2.0D);
> /*     */   }
> /*     */   
> /*     */   public void keyPressed(Point p, KeyEvent e) {}
> /*     */   
> /*     */   public void mouseClick(Point p, MouseEvent e) {}
> /*     */   
> /*     */   public void mouseDrag(Point p, MouseEvent e) {}
> /*     */   
> /*     */   public void mouseMove(Point p, MouseEvent e) {}
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/TrackProcessorMSD_Modified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/traJ/TrajectoryModified.java jd-gui/traJ/TrajectoryModified.java
1,146c1,167
< package traJ;
< 
< import features.AbstractTrajectoryFeatureModified;
< import java.util.ArrayList;
< import vecmath.Point3dModified;
< 
< public class TrajectoryModified extends ArrayList<Point3dModified> {
<    private static final long serialVersionUID = 1L;
<    private int dimension;
<    private int relativeStartTimepoint;
<    private long id;
<    private static long idCounter = 1L;
<    private String type = "";
<    private ArrayList<AbstractTrajectoryFeatureModified> features;
< 
<    public TrajectoryModified(int dimension) {
<       this.dimension = dimension;
<       this.relativeStartTimepoint = 0;
<       this.id = (long)(idCounter++);
<       this.features = new ArrayList();
<    }
< 
<    public TrajectoryModified(int dimension, int relativeStartTimepoint) {
<       this.dimension = dimension;
<       this.relativeStartTimepoint = relativeStartTimepoint;
<       this.id = (long)(idCounter++);
<       this.features = new ArrayList();
<    }
< 
<    public TrajectoryModified() {
<       this.relativeStartTimepoint = 0;
<       this.features = new ArrayList();
<    }
< 
<    public TrajectoryModified subList(int fromIndex, int toIndex) {
<       TrajectoryModified t = new TrajectoryModified(this.dimension);
< 
<       for(int i = fromIndex; i < toIndex; ++i) {
<          t.add((Point3dModified)this.get(i));
<       }
< 
<       return t;
<    }
< 
<    public ArrayList<AbstractTrajectoryFeatureModified> getFeatures() {
<       return this.features;
<    }
< 
<    public void addFeature(AbstractTrajectoryFeatureModified feature) {
<       this.features.add(feature);
<    }
< 
<    public TrajectoryModified getCopy() {
<       TrajectoryModified t = new TrajectoryModified(this.dimension);
< 
<       for(int i = 0; i < this.size(); ++i) {
<          t.add((Point3dModified)t.get(i));
<       }
< 
<       return t;
<    }
< 
<    public double[][] getPositionsAsArray() {
<       double[][] posAsArr = new double[this.size()][3];
< 
<       for(int i = 0; i < this.size(); ++i) {
<          if (this.get(i) != null) {
<             posAsArr[i][0] = ((Point3dModified)this.get(i)).x;
<             posAsArr[i][1] = ((Point3dModified)this.get(i)).y;
<             posAsArr[i][2] = ((Point3dModified)this.get(i)).z;
<          } else {
<             posAsArr[i] = null;
<          }
<       }
< 
<       return posAsArr;
<    }
< 
<    public String toString() {
<       String result = "";
< 
<       for(int i = 0; i < this.size(); ++i) {
<          result = result + " x: " + ((Point3dModified)this.get(i)).x + " y: " + ((Point3dModified)this.get(i)).y + " z: " + ((Point3dModified)this.get(i)).z + "\n";
<       }
< 
<       return result;
<    }
< 
<    public boolean add(Point3dModified e) {
<       return super.add(e);
<    }
< 
<    public void scale(double v) {
<       for(int i = 0; i < this.size(); ++i) {
<          ((Point3dModified)this.get(i)).scale(v);
<       }
< 
<    }
< 
<    public void offset(double x, double y, double z) {
<       for(int i = 0; i < this.size(); ++i) {
<          ((Point3dModified)this.get(i)).add(new Point3dModified(x, y, z));
<       }
< 
<    }
< 
<    public boolean add(double x, double y, double z) {
<       return super.add(new Point3dModified(x, y, z));
<    }
< 
<    public int getDimension() {
<       return this.dimension;
<    }
< 
<    public void setDimension(int dimension) {
<       this.dimension = dimension;
<    }
< 
<    public long getID() {
<       return this.id;
<    }
< 
<    public void setID(int id) {
<       this.id = (long)id;
<    }
< 
<    public int getRelativeStartTimepoint() {
<       return this.relativeStartTimepoint;
<    }
< 
<    public void setRelativStartTimepoint(int timepoint) {
<       this.relativeStartTimepoint = timepoint;
<    }
< 
<    public void setType(String type) {
<       this.type = type;
<    }
< 
<    public String getType() {
<       return this.type;
<    }
< 
<    public static void restIDCounter() {
<       idCounter = 1L;
<    }
< }
---
> /*     */ package traJ;
> /*     */ 
> /*     */ import features.AbstractTrajectoryFeatureModified;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.List;
> /*     */ import vecmath.Point3dModified;
> /*     */ import vecmath.Tuple3dModified;
> /*     */ 
> /*     */ public class TrajectoryModified
> /*     */   extends ArrayList<Point3dModified> {
> /*     */   private static final long serialVersionUID = 1L;
> /*     */   private int dimension;
> /*     */   private int relativeStartTimepoint;
> /*     */   private long id;
> /*  15 */   private static long idCounter = 1L;
> /*  16 */   private String type = "";
> /*     */   private ArrayList<AbstractTrajectoryFeatureModified> features;
> /*     */   
> /*     */   public TrajectoryModified(int dimension) {
> /*  20 */     this.dimension = dimension;
> /*  21 */     this.relativeStartTimepoint = 0;
> /*  22 */     this.id = idCounter++;
> /*  23 */     this.features = new ArrayList<>();
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public TrajectoryModified(int dimension, int relativeStartTimepoint) {
> /*  28 */     this.dimension = dimension;
> /*  29 */     this.relativeStartTimepoint = relativeStartTimepoint;
> /*  30 */     this.id = idCounter++;
> /*  31 */     this.features = new ArrayList<>();
> /*     */   }
> /*     */   
> /*     */   public TrajectoryModified() {
> /*  35 */     this.relativeStartTimepoint = 0;
> /*  36 */     this.features = new ArrayList<>();
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public TrajectoryModified subList(int fromIndex, int toIndex) {
> /*  41 */     TrajectoryModified t = new TrajectoryModified(this.dimension);
> /*     */     
> /*  43 */     for (int i = fromIndex; i < toIndex; i++) {
> /*  44 */       t.add(get(i));
> /*     */     }
> /*  46 */     return t;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public ArrayList<AbstractTrajectoryFeatureModified> getFeatures() {
> /*  51 */     return this.features;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void addFeature(AbstractTrajectoryFeatureModified feature) {
> /*  57 */     this.features.add(feature);
> /*     */   }
> /*     */   
> /*     */   public TrajectoryModified getCopy() {
> /*  61 */     TrajectoryModified t = new TrajectoryModified(this.dimension);
> /*  62 */     for (int i = 0; i < size(); i++) {
> /*  63 */       t.add(t.get(i));
> /*     */     }
> /*  65 */     return t;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double[][] getPositionsAsArray() {
> /*  70 */     double[][] posAsArr = new double[size()][3];
> /*  71 */     for (int i = 0; i < size(); i++) {
> /*  72 */       if (get(i) != null) {
> /*  73 */         posAsArr[i][0] = (get(i)).x;
> /*  74 */         posAsArr[i][1] = (get(i)).y;
> /*  75 */         posAsArr[i][2] = (get(i)).z;
> /*     */       } else {
> /*  77 */         posAsArr[i] = null;
> /*     */       } 
> /*     */     } 
> /*  80 */     return posAsArr;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /*  85 */     String result = "";
> /*  86 */     for (int i = 0; i < size(); i++) {
> /*  87 */       result = String.valueOf(result) + " x: " + (get(i)).x + " y: " + (get(i)).y + " z: " + (get(i)).z + "\n";
> /*     */     }
> /*  89 */     return result;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public boolean add(Point3dModified e) {
> /*  94 */     return super.add(e);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void scale(double v) {
> /*  99 */     for (int i = 0; i < size(); i++) {
> /* 100 */       get(i).scale(v);
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void offset(double x, double y, double z) {
> /* 107 */     for (int i = 0; i < size(); i++) {
> /* 108 */       get(i).add((Tuple3dModified)new Point3dModified(x, y, z));
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public boolean add(double x, double y, double z) {
> /* 114 */     return super.add(new Point3dModified(x, y, z));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int getDimension() {
> /* 120 */     return this.dimension;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void setDimension(int dimension) {
> /* 125 */     this.dimension = dimension;
> /*     */   }
> /*     */   
> /*     */   public long getID() {
> /* 129 */     return this.id;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void setID(int id) {
> /* 134 */     this.id = id;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public int getRelativeStartTimepoint() {
> /* 139 */     return this.relativeStartTimepoint;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void setRelativStartTimepoint(int timepoint) {
> /* 144 */     this.relativeStartTimepoint = timepoint;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public void setType(String type) {
> /* 149 */     this.type = type;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public String getType() {
> /* 154 */     return this.type;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public static void restIDCounter() {
> /* 159 */     idCounter = 1L;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/traJ/TrajectoryModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/traJ/TrajectoryUtilModified.java jd-gui/traJ/TrajectoryUtilModified.java
1,33c1,181
< package traJ;
< 
< import java.util.List;
< import vecmath.Point3dModified;
< 
< public class TrajectoryUtilModified {
<    public static TrajectoryModified resample(TrajectoryModified t, int n) {
<       TrajectoryModified t1 = new TrajectoryModified(2);
< 
<       for(int i = 0; i < t.size(); i += n) {
<          t1.add((Point3dModified)t.get(i));
<       }
< 
<       return t1;
<    }
< 
<    public static boolean isZero(double v) {
<       return Math.abs(v) < Math.pow(10.0D, -14.0D);
<    }
< 
<    public static TrajectoryModified getTrajectoryByID(List<? extends TrajectoryModified> t, int id) {
<       TrajectoryModified track = null;
< 
<       for(int i = 0; i < t.size(); ++i) {
<          if (((TrajectoryModified)t.get(i)).getID() == (long)id) {
<             track = (TrajectoryModified)t.get(i);
<             break;
<          }
<       }
< 
<       return track;
<    }
< }
---
> /*     */ package traJ;
> /*     */ 
> /*     */ import java.util.List;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class TrajectoryUtilModified
> /*     */ {
> /*     */   public static TrajectoryModified resample(TrajectoryModified t, int n) {
> /* 105 */     TrajectoryModified t1 = new TrajectoryModified(2);
> /*     */     
> /* 107 */     for (int i = 0; i < t.size(); i += n) {
> /* 108 */       t1.add(t.get(i));
> /*     */     }
> /*     */     
> /* 111 */     return t1;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static boolean isZero(double v) {
> /* 121 */     return (Math.abs(v) < Math.pow(10.0D, -14.0D));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public static TrajectoryModified getTrajectoryByID(List<? extends TrajectoryModified> t, int id) {
> /* 166 */     TrajectoryModified track = null;
> /* 167 */     for (int i = 0; i < t.size(); i++) {
> /* 168 */       if (((TrajectoryModified)t.get(i)).getID() == id) {
> /* 169 */         track = t.get(i);
> /*     */         break;
> /*     */       } 
> /*     */     } 
> /* 173 */     return track;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/traJ/TrajectoryUtilModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/traJ/TrajectoryValidIndexTimelagIteratorModified.java jd-gui/traJ/TrajectoryValidIndexTimelagIteratorModified.java
1,61c1,82
< package traJ;
< 
< import java.util.Iterator;
< 
< public class TrajectoryValidIndexTimelagIteratorModified implements Iterator<Integer> {
<    private TrajectoryModified t;
<    private int timelag;
<    boolean overlap = true;
<    int currentIndex;
< 
<    public TrajectoryValidIndexTimelagIteratorModified(TrajectoryModified t, int timelag) {
<       this.t = t;
<       this.timelag = timelag;
<       this.overlap = true;
<       this.currentIndex = 0;
<    }
< 
<    public TrajectoryValidIndexTimelagIteratorModified(TrajectoryModified t, int timelag, boolean overlap) {
<       this.t = t;
<       this.timelag = timelag;
<       this.overlap = overlap;
<       this.currentIndex = 0;
<    }
< 
<    public boolean hasNext() {
<       for(int i = this.currentIndex; i < this.t.size(); ++i) {
<          if (i + this.timelag >= this.t.size()) {
<             return false;
<          }
< 
<          if (this.t.get(i) != null && this.t.get(i + this.timelag) != null) {
<             return true;
<          }
<       }
< 
<       return false;
<    }
< 
<    public Integer next() {
<       for(int i = this.currentIndex; i < this.t.size(); ++i) {
<          if (i + this.timelag >= this.t.size()) {
<             return null;
<          }
< 
<          if (this.t.get(i) != null && this.t.get(i + this.timelag) != null) {
<             if (this.overlap) {
<                this.currentIndex = i + 1;
<             } else {
<                this.currentIndex = i + this.timelag;
<             }
< 
<             return i;
<          }
<       }
< 
<       return null;
<    }
< 
<    public void remove() {
<    }
< }
---
> /*    */ package traJ;
> /*    */ 
> /*    */ import java.util.Iterator;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class TrajectoryValidIndexTimelagIteratorModified
> /*    */   implements Iterator<Integer>
> /*    */ {
> /*    */   private TrajectoryModified t;
> /*    */   private int timelag;
> /*    */   boolean overlap = true;
> /*    */   int currentIndex;
> /*    */   
> /*    */   public TrajectoryValidIndexTimelagIteratorModified(TrajectoryModified t, int timelag) {
> /* 22 */     this.t = t;
> /* 23 */     this.timelag = timelag;
> /* 24 */     this.overlap = true;
> /* 25 */     this.currentIndex = 0;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TrajectoryValidIndexTimelagIteratorModified(TrajectoryModified t, int timelag, boolean overlap) {
> /* 34 */     this.t = t;
> /* 35 */     this.timelag = timelag;
> /* 36 */     this.overlap = overlap;
> /* 37 */     this.currentIndex = 0;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public boolean hasNext() {
> /* 42 */     for (int i = this.currentIndex; i < this.t.size(); i++) {
> /* 43 */       if (i + this.timelag >= this.t.size()) {
> /* 44 */         return false;
> /*    */       }
> /* 46 */       if (this.t.get(i) != null && this.t.get(i + this.timelag) != null) {
> /* 47 */         return true;
> /*    */       }
> /*    */     } 
> /* 50 */     return false;
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public Integer next() {
> /* 57 */     for (int i = this.currentIndex; i < this.t.size(); i++) {
> /* 58 */       if (i + this.timelag >= this.t.size()) {
> /* 59 */         return null;
> /*    */       }
> /* 61 */       if (this.t.get(i) != null && this.t.get(i + this.timelag) != null) {
> /* 62 */         if (this.overlap) {
> /* 63 */           this.currentIndex = i + 1;
> /*    */         } else {
> /*    */           
> /* 66 */           this.currentIndex = i + this.timelag;
> /*    */         } 
> /* 68 */         return Integer.valueOf(i);
> /*    */       } 
> /*    */     } 
> /*    */     
> /* 72 */     return null;
> /*    */   }
> /*    */   
> /*    */   public void remove() {}
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/traJ/TrajectoryValidIndexTimelagIteratorModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/TraJClassifierTest_.java jd-gui/TraJClassifierTest_.java
1,729c1,817
< import DiffusionCoefficientEstimator.AbstractDiffusionCoefficientEstimatorModified;
< import DiffusionCoefficientEstimator.CovarianceDiffusionCoefficientEstimatorModified;
< import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
< import de.biomedical_imaging.ij.trajectory_classifier.TraJResultsTable;
< import drift.StaticDriftCalculatorModified;
< import features.AbstractTrajectoryFeatureModified;
< import features.ActiveTransportParametersFeatureModified;
< import features.Asymmetry3FeatureModified;
< import features.CenterOfGravityFeatureModified;
< import features.ConfinedDiffusionParametersFeatureModified;
< import features.EfficiencyFeatureModified;
< import features.FractalDimensionFeatureModified;
< import features.GaussianityFeautureModified;
< import features.KurtosisFeatureModified;
< import features.MSDRatioFeatureModified;
< import features.MeanSpeedFeatureModified;
< import features.PowerLawFeatureModified;
< import features.StraightnessFeatureModified;
< import features.TrappedProbabilityFeatureModified;
< import fiji.plugin.trackmate.Spot;
< import ij.IJ;
< import ij.gui.Overlay;
< import ij.gui.Roi;
< import ij.gui.TextRoi;
< import ij.measure.ResultsTable;
< import ij.plugin.PlugIn;
< import java.awt.Color;
< import java.awt.Font;
< import java.awt.font.FontRenderContext;
< import java.awt.geom.AffineTransform;
< import java.io.File;
< import java.io.FileOutputStream;
< import java.io.InputStream;
< import java.text.DecimalFormat;
< import java.text.DecimalFormatSymbols;
< import java.text.NumberFormat;
< import java.util.ArrayList;
< import java.util.Collections;
< import java.util.HashMap;
< import java.util.HashSet;
< import java.util.Iterator;
< import java.util.List;
< import java.util.Locale;
< import java.util.Set;
< import org.apache.commons.math3.stat.StatUtils;
< import traJ.TrajectoryModified;
< import trajectory_classifier.ExportImportToolsModified;
< import trajectory_classifier.RRFClassifierRenjinModified;
< import trajectory_classifier.SubtrajectoryModified;
< import trajectory_classifier.VisualizationUtilsModified;
< import trajectory_classifier.WeightedWindowedClassificationProcessModified;
< import vecmath.Point3dModified;
< 
< public class TraJClassifierTest_ implements PlugIn {
<    static double timelag;
<    double minTrackLength;
<    int windowSizeClassification;
<    int minSegmentLength;
<    double pixelsize;
<    int resampleRate;
<    boolean showID;
<    boolean showOverviewClasses;
<    boolean removeGlobalDrift;
<    boolean useReducedModelConfinedMotion;
<    int ommittedTrajectories;
<    public static TraJClassifierTest_ instance;
<    ArrayList<SubtrajectoryModified> classifiedSegments;
<    ArrayList<TrajectoryModified> tracksToClassify;
<    ArrayList<TrajectoryModified> parentTrajectories;
< 
<    public TraJClassifierTest_() {
<       instance = this;
<    }
< 
<    public static TraJClassifierTest_ getInstance() {
<       if (instance == null) {
<          instance = new TraJClassifierTest_();
<       }
< 
<       return instance;
<    }
< 
<    public void run(String arg) {
<       String modelpath = "";
< 
<       try {
<          modelpath = this.ExportResource("/randomForestModel.RData");
<       } catch (Exception var47) {
<          var47.printStackTrace();
<       }
< 
<       List<Integer> trackSize = null;
<       Set classes;
<       ArrayList prois;
<       ArrayList dcEstim;
<       int i;
<       TrajectoryModified track;
<       int i;
<       int subPosCount;
<       if (!arg.contains("DEBUG")) {
<          this.tracksToClassify = new ArrayList();
<          TrajectoryModified.restIDCounter();
<          List<List<Spot>> imported2Spot = new ArrayList();
<          Set<Integer> trackIDs = SPTBatch_.model.getTrackModel().trackIDs(true);
<          trackSize = new ArrayList();
<          Iterator var7 = trackIDs.iterator();
< 
<          while(var7.hasNext()) {
<             Integer id = (Integer)var7.next();
<             List<Spot> imported1Spot = new ArrayList();
<             classes = SPTBatch_.model.getTrackModel().trackSpots(id);
<             trackSize.add(classes.size());
<             ArrayList<Float> framesByTrack = new ArrayList();
<             prois = new ArrayList();
<             ArrayList<Float> trackID = new ArrayList();
<             ArrayList<Integer> indexes = new ArrayList();
<             dcEstim = new ArrayList();
<             Iterator var16 = classes.iterator();
< 
<             while(var16.hasNext()) {
<                Spot spot = (Spot)var16.next();
<                trackID.add((float)id);
<                framesByTrack.add(Float.valueOf(spot.getFeature("FRAME").toString()));
<                prois.add(Float.valueOf(spot.getFeature("FRAME").toString()));
<                dcEstim.add(spot);
<             }
< 
<             Collections.sort(prois);
< 
<             for(subPosCount = 0; subPosCount < prois.size(); ++subPosCount) {
<                indexes.add(framesByTrack.indexOf(prois.get(subPosCount)));
<             }
< 
<             for(subPosCount = 0; subPosCount < indexes.size(); ++subPosCount) {
<                imported1Spot.add((Spot)dcEstim.get((Integer)indexes.get(subPosCount)));
<             }
< 
<             imported2Spot.add(imported1Spot);
<          }
< 
<          for(i = 0; i < imported2Spot.size(); ++i) {
<             track = new TrajectoryModified(2);
<             boolean firstPosition = true;
< 
<             for(i = 0; i < ((List)imported2Spot.get(i)).size(); ++i) {
<                double x = ((Spot)((List)imported2Spot.get(i)).get(i)).getFeature("POSITION_X");
<                double y = ((Spot)((List)imported2Spot.get(i)).get(i)).getFeature("POSITION_Y");
<                int time = ((Spot)((List)imported2Spot.get(i)).get(i)).getFeature("FRAME").intValue();
<                if (firstPosition) {
<                   track.setRelativStartTimepoint(time);
<                   firstPosition = false;
<                }
< 
<                track.add(x, y, 0.0D);
<             }
< 
<             this.tracksToClassify.add(track);
<          }
<       }
< 
<       int maxNumberOfPositions = 0;
< 
<       for(int i = 0; i < this.tracksToClassify.size(); ++i) {
<          if (((TrajectoryModified)this.tracksToClassify.get(i)).size() > maxNumberOfPositions) {
<             maxNumberOfPositions = ((TrajectoryModified)this.tracksToClassify.get(i)).size();
<          }
<       }
< 
<       boolean visualize = true;
<       if (traJParametersWindow.keyWord == "keyword") {
<          this.minTrackLength = (double)Integer.valueOf(traJParametersWindow.minLengthTextS);
<          this.windowSizeClassification = Integer.valueOf(traJParametersWindow.windowTextS);
<          this.minSegmentLength = Integer.valueOf(traJParametersWindow.minSegTextS);
<       } else {
<          this.minTrackLength = 10.0D;
<          this.windowSizeClassification = 5;
<          this.minSegmentLength = 5;
<       }
< 
<       this.resampleRate = 1;
<       if (SPTBatch_.imps.getCalibration().getXUnit() == "pixel") {
<          this.pixelsize = SPTBatch_.imps.getCalibration().pixelWidth;
<       }
< 
<       if (SPTBatch_.imps.getCalibration().getXUnit() != "pixel") {
<          this.pixelsize = 0.0D;
<       }
< 
<       timelag = SPTBatch_.fps;
<       this.useReducedModelConfinedMotion = false;
<       this.showID = true;
<       this.showOverviewClasses = true;
<       this.removeGlobalDrift = false;
<       if (this.pixelsize > 1.0E-6D) {
<          for(i = 0; i < this.tracksToClassify.size(); ++i) {
<             ((TrajectoryModified)this.tracksToClassify.get(i)).scale(this.pixelsize);
<          }
<       }
< 
<       for(i = 0; i < this.tracksToClassify.size(); ++i) {
<          track = (TrajectoryModified)this.tracksToClassify.get(i);
<          int changesCounter = 0;
< 
<          for(i = 1; i < track.size(); ++i) {
<             if (((Point3dModified)track.get(i)).distance((Point3dModified)track.get(i - 1)) > Math.pow(10.0D, -12.0D)) {
<                ++changesCounter;
<             }
<          }
< 
<          if (1.0D * (double)changesCounter / (double)track.size() < 0.5D) {
<             this.tracksToClassify.remove(i);
<             ++this.ommittedTrajectories;
<             --i;
<          }
<       }
< 
<       HashMap<String, Color> mapTypeToColor = new HashMap();
<       mapTypeToColor.put("DIRECTED/ACTIVE", Color.MAGENTA);
<       mapTypeToColor.put("NORM. DIFFUSION", Color.RED);
<       mapTypeToColor.put("CONFINED", Color.YELLOW);
<       mapTypeToColor.put("SUBDIFFUSION", Color.GREEN);
<       this.parentTrajectories = new ArrayList();
<       Iterator var58 = this.tracksToClassify.iterator();
< 
<       while(var58.hasNext()) {
<          track = (TrajectoryModified)var58.next();
<          if ((double)track.size() > this.minTrackLength) {
<             this.parentTrajectories.add(track);
<          }
<       }
< 
<       StaticDriftCalculatorModified<TrajectoryModified> dcalc = new StaticDriftCalculatorModified();
<       if (this.parentTrajectories.isEmpty() == Boolean.FALSE) {
<          this.classifiedSegments = this.classifyAndSegment((ArrayList)this.parentTrajectories, modelpath, this.windowSizeClassification, this.minSegmentLength, 10, this.resampleRate);
<          int y;
<          if (visualize) {
<             Overlay ov = new Overlay();
<             i = 0;
< 
<             while(true) {
<                if (i >= this.classifiedSegments.size()) {
<                   if (this.showOverviewClasses) {
<                      classes = mapTypeToColor.keySet();
<                      Iterator<String> it = classes.iterator();
<                      y = 5;
<                      float fsize = 20.0F;
<                      AffineTransform affinetransform = new AffineTransform();
<                      FontRenderContext frc = new FontRenderContext(affinetransform, true, true);
<                      subPosCount = (int)IJ.getImage().getProcessor().getFont().getStringBounds("Norm. Diffusion", frc).getWidth();
< 
<                      for(Font f = IJ.getImage().getProcessor().getFont(); 1.0D * (double)subPosCount / (double)IJ.getImage().getWidth() > 0.08D; subPosCount = (int)f.getStringBounds("Norm. Diffusion", frc).getWidth()) {
<                         --fsize;
<                         f = f.deriveFont(fsize);
<                      }
< 
<                      TextRoi.setFont("TimesRoman", (int)fsize, 0);
< 
<                      while(it.hasNext()) {
<                         String type = (String)it.next();
<                         TextRoi troi = new TextRoi(5, y, type);
<                         troi.setFillColor(Color.DARK_GRAY);
<                         troi.setStrokeColor((Color)mapTypeToColor.get(type));
<                         ov.add(troi);
<                         y += 20;
<                      }
<                   }
< 
<                   IJ.getImage().setOverlay(ov);
<                   IJ.getImage().updateAndRepaintWindow();
<                   break;
<                }
< 
<                SubtrajectoryModified tr = (SubtrajectoryModified)this.classifiedSegments.get(i);
<                prois = null;
<                if (this.pixelsize > 1.0E-6D) {
<                   prois = VisualizationUtilsModified.generateVisualizationRoisFromTrack(tr, (Color)mapTypeToColor.get(tr.getType()), this.showID, this.pixelsize);
<                } else {
<                   prois = VisualizationUtilsModified.generateVisualizationRoisFromTrack(tr, (Color)mapTypeToColor.get(tr.getType()), this.showID, IJ.getImage().getCalibration().pixelWidth);
<                }
< 
<                Iterator var69 = prois.iterator();
< 
<                while(var69.hasNext()) {
<                   Roi r = (Roi)var69.next();
<                   ov.add(r);
<                }
< 
<                ++i;
<             }
<          }
< 
<          HashMap<String, TraJResultsTable> rtables = new HashMap();
<          rtables.put("DIRECTED/ACTIVE", new TraJResultsTable());
<          rtables.put("NORM. DIFFUSION", new TraJResultsTable());
<          rtables.put("SUBDIFFUSION", new TraJResultsTable());
<          rtables.put("CONFINED", new TraJResultsTable());
<          double sumConf = 0.0D;
< 
<          for(y = 0; y < this.classifiedSegments.size(); ++y) {
<             IJ.showProgress(y, this.classifiedSegments.size());
<             SubtrajectoryModified t = (SubtrajectoryModified)this.classifiedSegments.get(y);
<             TraJResultsTable rt = (TraJResultsTable)rtables.get(t.getType());
<             if (rt == null) {
<                SPTBatch_.taskOutput.append("Type: " + t.getType());
<                ExportImportToolsModified eit = new ExportImportToolsModified();
<                ArrayList<TrajectoryModified> hlp = new ArrayList();
<                eit.exportTrajectoryDataAsCSV(hlp, SPTBatch_.csvPath + File.separator + "bad" + ".csv");
<                SPTBatch_.taskOutput.append(t.toString());
<             }
< 
<             rt.incrementCounter();
<             rt.addValue("PARENT-ID", (double)t.getParent().getID());
<             rt.addValue("ID", (double)t.getID());
<             rt.addValue("LENGTH", (double)t.size());
<             rt.addValue("START", (double)t.getRelativeStartTimepoint());
<             rt.addValue("END", (double)(t.getRelativeStartTimepoint() + t.size() - 1));
<             rt.addValue("CLASS", t.getType());
<             dcEstim = null;
<             double dc = 0.0D;
<             DecimalFormatSymbols otherSymbols = new DecimalFormatSymbols(Locale.ENGLISH);
<             NumberFormat formatter = new DecimalFormat("0.###E0", otherSymbols);
<             double goodness = 0.0D;
<             double alphaGoodness = 0.0D;
<             double[] res;
<             String var24;
<             switch((var24 = t.getType()).hashCode()) {
<             case -1768066899:
<                if (var24.equals("DIRECTED/ACTIVE")) {
<                   ActiveTransportParametersFeatureModified apf = new ActiveTransportParametersFeatureModified(t, timelag);
<                   res = apf.evaluate();
<                   rt.addValue("(FIT) D", formatter.format(res[0]));
<                   rt.addValue("(FIT) Velocity", res[1]);
<                   goodness = res[2];
<                }
<                break;
<             case -568951419:
<                if (var24.equals("SUBDIFFUSION")) {
<                   PowerLawFeatureModified pwf = new PowerLawFeatureModified(t, 1.0D / timelag, 1, t.size() / 3);
<                   res = pwf.evaluate();
<                   dc = res[1];
<                   rt.addValue("(FIT) D", formatter.format(dc));
<                   goodness = res[2];
<                }
<                break;
<             case 160958711:
<                if (var24.equals("NORM. DIFFUSION")) {
<                   AbstractTrajectoryFeatureModified dcEstim = new RegressionDiffusionCoefficientEstimatorModified(t, 1.0D / timelag, 1, t.size() / 3);
<                   res = dcEstim.evaluate();
<                   dc = res[0];
<                   rt.addValue("(FIT) D", formatter.format(dc));
<                   goodness = res[3];
<                }
<                break;
<             case 202494376:
<                if (var24.equals("CONFINED")) {
<                   AbstractDiffusionCoefficientEstimatorModified dcEst = new RegressionDiffusionCoefficientEstimatorModified(t, 1.0D / timelag, 1, 3);
<                   ConfinedDiffusionParametersFeatureModified confp = new ConfinedDiffusionParametersFeatureModified(t, timelag, this.useReducedModelConfinedMotion, dcEst);
<                   double[] p = confp.evaluate();
<                   dc = p[1];
<                   if (this.useReducedModelConfinedMotion) {
<                      rt.addValue("(FIT) CONF. RADIUS", Math.sqrt(p[0]));
<                      rt.addValue("(FIT) D", formatter.format(p[1]));
<                      goodness = p[2];
<                   } else {
<                      rt.addValue("(FIT) CONF. RADIUS", Math.sqrt(p[0]));
<                      rt.addValue("(FIT) A [CONF. SHAPE]", p[2]);
<                      rt.addValue("(FIT) B (CONF SHAPE)", p[3]);
<                      rt.addValue("(FIT) D", formatter.format(p[1]));
<                      goodness = p[4];
<                   }
<                }
<             }
< 
<             AbstractTrajectoryFeatureModified pwf = new PowerLawFeatureModified(t, 1.0D / timelag, 1, t.size() / 3);
<             res = pwf.evaluate();
<             double alpha = res[0];
<             alphaGoodness = res[2];
<             AbstractTrajectoryFeatureModified f = new CenterOfGravityFeatureModified(t);
<             double cog_x = f.evaluate()[0];
<             double cog_y = f.evaluate()[1];
<             rt.addValue("X (COG)", cog_x);
<             rt.addValue("Y (COG)", cog_y);
<             if (!t.getType().equals("NONE")) {
<                FractalDimensionFeatureModified fdf = new FractalDimensionFeatureModified(t);
<                double v = fdf.evaluate()[0];
<                rt.addValue("FRACT. DIM.", v);
<                TrappedProbabilityFeatureModified trapped = new TrappedProbabilityFeatureModified(t);
<                v = trapped.evaluate()[0];
<                rt.addValue("TRAPPEDNESS", v);
<                EfficiencyFeatureModified eff = new EfficiencyFeatureModified(t);
<                v = eff.evaluate()[0];
<                rt.addValue("EFFICENCY", v);
<                StraightnessFeatureModified straight = new StraightnessFeatureModified(t);
<                v = straight.evaluate()[0];
<                rt.addValue("STRAIGHTNESS", v);
<                MeanSpeedFeatureModified msfeature = new MeanSpeedFeatureModified(t, timelag);
<                v = msfeature.evaluate()[1];
<                rt.addValue("SPEED", v);
<                KurtosisFeatureModified kurt = new KurtosisFeatureModified(t);
<                v = kurt.evaluate()[0];
<                rt.addValue("KURTOSIS", v);
<                rt.addValue("(FIT) ALPHA", alpha);
<                GaussianityFeautureModified gauss = new GaussianityFeautureModified(t, 1);
<                v = gauss.evaluate()[0];
<                rt.addValue("GAUSSIANITY", v);
<                Asymmetry3FeatureModified asym3 = new Asymmetry3FeatureModified(t);
<                v = asym3.evaluate()[0];
<                rt.addValue("Asymmetry", v);
<                MSDRatioFeatureModified msdratio = new MSDRatioFeatureModified(t, 1, 5);
<                v = msdratio.evaluate()[0];
<                rt.addValue("MSDRatio", v);
<                CovarianceDiffusionCoefficientEstimatorModified cest = new CovarianceDiffusionCoefficientEstimatorModified(t, 1.0D / timelag);
<                res = cest.evaluate();
<                rt.addValue("Loc. noise_sigma", (res[1] + res[2]) / 2.0D);
<                rt.addValue("Fit Goodness", goodness);
<                rt.addValue("Alpha Fit Goodness", alphaGoodness);
<                double conf = t.getConfidence();
<                sumConf += conf;
<                rt.addValue("Confidence", conf);
<             }
<          }
< 
<          Iterator<String> rtIt = rtables.keySet().iterator();
<          ResultsTable parents = new TraJResultsTable(true);
< 
<          for(int i = 0; i < this.parentTrajectories.size(); ++i) {
<             parents.incrementCounter();
<             TrajectoryModified t = (TrajectoryModified)this.parentTrajectories.get(i);
<             parents.addValue("ID", (double)t.getID());
<             parents.addValue("LENGTH", (double)t.size());
<             parents.addValue("START", (double)t.getRelativeStartTimepoint());
<             parents.addValue("END", (double)(t.getRelativeStartTimepoint() + t.size() - 1));
<             subPosCount = 0;
<             int subSegCount = 0;
<             int normPosCount = 0;
<             int normSegCount = 0;
<             int directedPosCount = 0;
<             int directSegCount = 0;
<             int confPosCount = 0;
<             int confSegCount = 0;
<             ArrayList<SubtrajectoryModified> sameParent = SubtrajectoryModified.getTracksWithSameParant(this.classifiedSegments, t.getID());
<             Iterator var99 = sameParent.iterator();
< 
<             while(var99.hasNext()) {
<                SubtrajectoryModified sub = (SubtrajectoryModified)var99.next();
<                String var101;
<                switch((var101 = sub.getType()).hashCode()) {
<                case -1768066899:
<                   if (var101.equals("DIRECTED/ACTIVE")) {
<                      directedPosCount += sub.size();
<                      ++directSegCount;
<                   }
<                   break;
<                case -568951419:
<                   if (var101.equals("SUBDIFFUSION")) {
<                      subPosCount += sub.size();
<                      ++subSegCount;
<                   }
<                   break;
<                case 160958711:
<                   if (var101.equals("NORM. DIFFUSION")) {
<                      normPosCount += sub.size();
<                      ++normSegCount;
<                   }
<                   break;
<                case 202494376:
<                   if (var101.equals("CONFINED")) {
<                      confPosCount += sub.size();
<                      ++confSegCount;
<                   }
<                }
<             }
< 
<             parents.addValue("#SEG_NORM", (double)normSegCount);
<             parents.addValue("#POS_NORM", (double)normPosCount);
<             parents.addValue("#SEG_SUB", (double)subSegCount);
<             parents.addValue("#POS_SUB", (double)subPosCount);
<             parents.addValue("#SEG_CONF", (double)confSegCount);
<             parents.addValue("#POS_CONF", (double)confPosCount);
<             parents.addValue("#SEG_DIRECTED", (double)directSegCount);
<             parents.addValue("#POS_DIRECTED", (double)directedPosCount);
<          }
< 
<          String trajVersion = TrajectoryModified.class.getPackage().getImplementationVersion();
<          double[] drift = dcalc.calculateDrift(this.parentTrajectories);
<          ResultsTable overall = new ResultsTable();
<          overall.incrementCounter();
<          overall.addValue("Mean confindence", sumConf / (double)this.classifiedSegments.size());
<          overall.addValue("Drift x", drift[0]);
<          overall.addValue("Drift y", drift[1]);
<          overall.addValue("Omitted segments", (double)this.ommittedTrajectories);
<          overall.addValue("Min. track length", this.minTrackLength);
<          overall.addValue("Window size", (double)(this.windowSizeClassification * 2));
<          overall.addValue("Min. segment length", (double)this.minSegmentLength);
<          overall.addValue("Resamplerate", (double)this.resampleRate);
<          overall.addValue("Pixelsize", this.pixelsize);
<          overall.addValue("Framerate", 1.0D / timelag);
<          overall.addValue("Reduced conf. model", Boolean.toString(this.useReducedModelConfinedMotion));
<          overall.addValue("Remove global drift", Boolean.toString(this.removeGlobalDrift));
<          overall.addValue("TraJ library version", trajVersion);
<          overall.save(SPTBatch_.directDiff + File.separator + "Settings & Miscellaneous" + SPTBatch_.imps.getShortTitle() + ".xls");
<          parents.save(SPTBatch_.directDiff + File.separator + "Parents_" + SPTBatch_.imps.getShortTitle() + ".xls");
<          rtIt = rtables.keySet().iterator();
< 
<          while(rtIt.hasNext()) {
<             String rt = (String)rtIt.next();
<             if (rt.equals("DIRECTED/ACTIVE") == Boolean.TRUE) {
<                ((TraJResultsTable)rtables.get(rt)).save(SPTBatch_.directDiff + File.separator + "DIRECTED_ACTIVE" + "_trajectories_" + SPTBatch_.imps.getShortTitle() + ".xls");
<             } else {
<                ((TraJResultsTable)rtables.get(rt)).save(SPTBatch_.directDiff + File.separator + rt + "_trajectories_" + SPTBatch_.imps.getShortTitle() + ".xls");
<             }
<          }
<       }
< 
<    }
< 
<    public ArrayList<SubtrajectoryModified> classifyAndSegment(TrajectoryModified trackToClassify, String modelpath, int windowSizeClassification, int minSegmentLength, int modeFilterLength, int resampleRate) {
<       ArrayList<TrajectoryModified> help = new ArrayList();
<       help.add(trackToClassify);
<       return this.classifyAndSegment(help, modelpath, windowSizeClassification, minSegmentLength, modeFilterLength, resampleRate);
<    }
< 
<    public ArrayList<SubtrajectoryModified> classifyAndSegment(ArrayList<TrajectoryModified> tracksToClassify, String modelpath, int windowSizeClassification, int minSegmentLength, int modeFilterLength, int resampleRate) {
<       ArrayList<SubtrajectoryModified> classified = new ArrayList();
<       int j = 0;
<       RRFClassifierRenjinModified rrf = new RRFClassifierRenjinModified(modelpath, (double)resampleRate * timelag);
<       rrf.start();
<       WeightedWindowedClassificationProcessModified wcp = new WeightedWindowedClassificationProcessModified();
<       int subidcounter = 1;
< 
<       boolean var26;
<       for(Iterator var13 = tracksToClassify.iterator(); var13.hasNext(); var26 = false) {
<          TrajectoryModified track = (TrajectoryModified)var13.next();
<          ++j;
<          IJ.showProgress(j, tracksToClassify.size());
<          String[] classes = wcp.windowedClassification(track, rrf, windowSizeClassification, resampleRate);
<          double[] classConfidence = wcp.getPositionConfidence();
<          classes = movingMode(classes, modeFilterLength);
<          double sumConf = 0.0D;
<          int Nconf = 0;
<          SubtrajectoryModified tr = new SubtrajectoryModified(track, 2);
<          tr.setID(subidcounter);
<          ++subidcounter;
<          tr.add(((Point3dModified)track.get(0)).x, ((Point3dModified)track.get(0)).y, 0.0D);
<          sumConf += classConfidence[0];
<          int Nconf = Nconf + 1;
<          String prevCls = classes[0];
<          int start = track.getRelativeStartTimepoint();
<          tr.setRelativStartTimepoint(start);
<          tr.setType(prevCls);
< 
<          for(int i = 1; i < classes.length; ++i) {
<             if (prevCls == classes[i]) {
<                tr.add(((Point3dModified)track.get(i)).x, ((Point3dModified)track.get(i)).y, 0.0D);
<                sumConf += classConfidence[i];
<                ++Nconf;
<             } else {
<                tr.setConfidence(sumConf / (double)Nconf);
<                classified.add(tr);
<                tr = new SubtrajectoryModified(track, 2);
<                tr.setID(subidcounter);
<                ++subidcounter;
<                tr.setRelativStartTimepoint(start + i);
<                tr.add(((Point3dModified)track.get(i)).x, ((Point3dModified)track.get(i)).y, 0.0D);
<                sumConf = classConfidence[i];
<                Nconf = 1;
<                prevCls = classes[i];
<                tr.setType(prevCls);
<             }
<          }
< 
<          tr.setConfidence(sumConf / (double)Nconf);
<          classified.add(tr);
<          sumConf = 0.0D;
<       }
< 
<       rrf.stop();
< 
<       for(int i = 0; i < classified.size(); ++i) {
<          if (((SubtrajectoryModified)classified.get(i)).size() < minSegmentLength) {
<             classified.remove(i);
<             --i;
<          }
<       }
< 
<       return classified;
<    }
< 
<    public double getTimelag() {
<       return timelag;
<    }
< 
<    public static String[] movingMode(String[] types, int n) {
<       ArrayList<String> ltypes = new ArrayList();
< 
<       for(int i = 0; i < types.length; ++i) {
<          ltypes.add(types[i]);
<       }
< 
<       return movingMode(ltypes, n);
<    }
< 
<    public static String[] movingMode(ArrayList<String> types, int n) {
<       int windowsize = 2 * n + 1;
<       HashSet<String> uniqueTypes = new HashSet();
<       uniqueTypes.addAll(types);
<       HashMap<String, Integer> mapTypeToInt = new HashMap();
<       HashMap<Integer, String> mapIntToType = new HashMap();
<       Iterator<String> it = uniqueTypes.iterator();
< 
<       for(int key = 0; it.hasNext(); ++key) {
<          String type = (String)it.next();
<          mapTypeToInt.put(type, key);
<          mapIntToType.put(key, type);
<       }
< 
<       String[] medTypes = new String[types.size()];
< 
<       int i;
<       for(i = 0; i < n; ++i) {
<          medTypes[i] = (String)types.get(i);
<       }
< 
<       for(i = types.size() - n; i < types.size(); ++i) {
<          medTypes[i] = (String)types.get(i);
<       }
< 
<       for(i = 0; i < types.size() - windowsize + 1; ++i) {
<          List<String> sub = types.subList(i, i + windowsize - 1);
<          double[] values = new double[sub.size()];
< 
<          for(int j = 0; j < sub.size(); ++j) {
<             values[j] = (double)(Integer)mapTypeToInt.get(sub.get(j));
<          }
< 
<          medTypes[i + n] = (String)mapIntToType.get((int)StatUtils.mode(values)[0]);
<       }
< 
<       return medTypes;
<    }
< 
<    public ArrayList<SubtrajectoryModified> getClassifiedTrajectories() {
<       return this.classifiedSegments;
<    }
< 
<    public ArrayList<TrajectoryModified> getParentTrajectories() {
<       return this.parentTrajectories;
<    }
< 
<    public String ExportResource(String resourceName) throws Exception {
<       InputStream stream = null;
<       FileOutputStream resStreamOut = null;
< 
<       String tmpFolder;
<       try {
<          stream = this.getClass().getResourceAsStream(resourceName);
<          if (stream == null) {
<             IJ.error("Cannot get resource \"" + resourceName + "\" from Jar file.");
<             throw new Exception("Cannot get resource \"" + resourceName + "\" from Jar file.");
<          }
< 
<          byte[] buffer = new byte[4096];
<          File folderDir = new File(IJ.getDirectory("temp") + "/.trajclassifier");
<          if (!folderDir.exists()) {
<             folderDir.mkdir();
<          }
< 
<          tmpFolder = folderDir.getPath().replace('\\', '/');
<          resStreamOut = new FileOutputStream(tmpFolder + resourceName);
< 
<          int readBytes;
<          while((readBytes = stream.read(buffer)) > 0) {
<             resStreamOut.write(buffer, 0, readBytes);
<          }
<       } catch (Exception var11) {
<          IJ.error(var11.getMessage());
<          throw var11;
<       } finally {
<          stream.close();
<          resStreamOut.close();
<       }
< 
<       return tmpFolder + resourceName;
<    }
< 
<    public void setTracksToClassify(ArrayList<TrajectoryModified> t) {
<       this.tracksToClassify = t;
<    }
< 
<    public double getMinTrackLength() {
<       return this.minTrackLength;
<    }
< 
<    public void setMinTrackLength(double minTrackLength) {
<       this.minTrackLength = minTrackLength;
<    }
< 
<    public double getPixelsize() {
<       return this.pixelsize;
<    }
< 
<    public void setPixelsize(double pixelsize) {
<       this.pixelsize = pixelsize;
<    }
< 
<    public boolean isShowID() {
<       return this.showID;
<    }
< 
<    public void setShowID(boolean showID) {
<       this.showID = showID;
<    }
< 
<    public int getWindowSizeClassification() {
<       return this.windowSizeClassification;
<    }
< 
<    public boolean isUseReducedModelConfinedMotion() {
<       return this.useReducedModelConfinedMotion;
<    }
< 
<    public void setTimelag(double timelag) {
<       TraJClassifierTest_.timelag = timelag;
<    }
< 
<    public void setWindowSizeClassification(int windowSizeClassification) {
<       this.windowSizeClassification = windowSizeClassification;
<    }
< }
---
> /*     */ import DiffusionCoefficientEstimator.AbstractDiffusionCoefficientEstimatorModified;
> /*     */ import DiffusionCoefficientEstimator.CovarianceDiffusionCoefficientEstimatorModified;
> /*     */ import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
> /*     */ import de.biomedical_imaging.ij.trajectory_classifier.TraJResultsTable;
> /*     */ import drift.StaticDriftCalculatorModified;
> /*     */ import features.AbstractTrajectoryFeatureModified;
> /*     */ import features.ActiveTransportParametersFeatureModified;
> /*     */ import features.Asymmetry3FeatureModified;
> /*     */ import features.CenterOfGravityFeatureModified;
> /*     */ import features.ConfinedDiffusionParametersFeatureModified;
> /*     */ import features.EfficiencyFeatureModified;
> /*     */ import features.FractalDimensionFeatureModified;
> /*     */ import features.GaussianityFeautureModified;
> /*     */ import features.KurtosisFeatureModified;
> /*     */ import features.MSDRatioFeatureModified;
> /*     */ import features.MeanSpeedFeatureModified;
> /*     */ import features.PowerLawFeatureModified;
> /*     */ import features.StraightnessFeatureModified;
> /*     */ import features.TrappedProbabilityFeatureModified;
> /*     */ import fiji.plugin.trackmate.Spot;
> /*     */ import ij.IJ;
> /*     */ import ij.gui.Overlay;
> /*     */ import ij.gui.Roi;
> /*     */ import ij.gui.TextRoi;
> /*     */ import ij.measure.ResultsTable;
> /*     */ import ij.plugin.PlugIn;
> /*     */ import java.awt.Color;
> /*     */ import java.awt.Font;
> /*     */ import java.awt.font.FontRenderContext;
> /*     */ import java.awt.geom.AffineTransform;
> /*     */ import java.io.File;
> /*     */ import java.io.FileOutputStream;
> /*     */ import java.io.InputStream;
> /*     */ import java.io.OutputStream;
> /*     */ import java.text.DecimalFormat;
> /*     */ import java.text.DecimalFormatSymbols;
> /*     */ import java.text.NumberFormat;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.Collections;
> /*     */ import java.util.HashMap;
> /*     */ import java.util.HashSet;
> /*     */ import java.util.Iterator;
> /*     */ import java.util.List;
> /*     */ import java.util.Locale;
> /*     */ import java.util.Set;
> /*     */ import org.apache.commons.math3.stat.StatUtils;
> /*     */ import traJ.TrajectoryModified;
> /*     */ import trajectory_classifier.AbstractClassifierModified;
> /*     */ import trajectory_classifier.ExportImportToolsModified;
> /*     */ import trajectory_classifier.RRFClassifierRenjinModified;
> /*     */ import trajectory_classifier.SubtrajectoryModified;
> /*     */ import trajectory_classifier.VisualizationUtilsModified;
> /*     */ import trajectory_classifier.WeightedWindowedClassificationProcessModified;
> /*     */ import vecmath.Point3dModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class TraJClassifierTest_
> /*     */   implements PlugIn
> /*     */ {
> /*     */   static double timelag;
> /*     */   double minTrackLength;
> /*     */   int windowSizeClassification;
> /*     */   int minSegmentLength;
> /*     */   double pixelsize;
> /*     */   int resampleRate;
> /*     */   boolean showID;
> /*     */   boolean showOverviewClasses;
> /*     */   boolean removeGlobalDrift;
> /*     */   boolean useReducedModelConfinedMotion;
> /*     */   int ommittedTrajectories;
> /*     */   public static TraJClassifierTest_ instance;
> /*     */   ArrayList<SubtrajectoryModified> classifiedSegments;
> /*     */   ArrayList<TrajectoryModified> tracksToClassify;
> /*     */   ArrayList<TrajectoryModified> parentTrajectories;
> /*     */   
> /*     */   public TraJClassifierTest_() {
> /*  92 */     instance = this;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public static TraJClassifierTest_ getInstance() {
> /*  97 */     if (instance == null) {
> /*  98 */       instance = new TraJClassifierTest_();
> /*     */     }
> /* 100 */     return instance;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void run(String arg) {
> /* 108 */     String modelpath = "";
> /*     */     try {
> /* 110 */       modelpath = ExportResource("/randomForestModel.RData");
> /* 111 */     } catch (Exception e) {
> /*     */       
> /* 113 */       e.printStackTrace();
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 119 */     List<Integer> trackSize = null;
> /* 120 */     if (!arg.contains("DEBUG")) {
> /* 121 */       this.tracksToClassify = new ArrayList<>();
> /* 122 */       TrajectoryModified.restIDCounter();
> /*     */       
> /* 124 */       List<List<Spot>> imported2Spot = new ArrayList<>();
> /* 125 */       Set<Integer> trackIDs = SPTBatch_.model.getTrackModel().trackIDs(true);
> /* 126 */       trackSize = new ArrayList<>();
> /*     */       
> /* 128 */       for (Integer id : trackIDs) {
> /* 129 */         List<Spot> imported1Spot = new ArrayList<>();
> /* 130 */         Set<Spot> track = SPTBatch_.model.getTrackModel().trackSpots(id);
> /* 131 */         trackSize.add(Integer.valueOf(track.size()));
> /* 132 */         ArrayList<Float> framesByTrack = new ArrayList<>();
> /* 133 */         ArrayList<Float> framesByTrackSort = new ArrayList<>();
> /* 134 */         ArrayList<Float> trackID = new ArrayList<>();
> /* 135 */         ArrayList<Integer> indexes = new ArrayList<>();
> /* 136 */         List<Spot> spots = new ArrayList<>();
> /* 137 */         for (Spot spot : track) {
> /* 138 */           trackID.add(Float.valueOf(id.intValue()));
> /* 139 */           framesByTrack.add(Float.valueOf(spot.getFeature("FRAME").toString()));
> /* 140 */           framesByTrackSort.add(Float.valueOf(spot.getFeature("FRAME").toString()));
> /* 141 */           spots.add(spot);
> /*     */         } 
> /*     */         
> /* 144 */         Collections.sort(framesByTrackSort);
> /* 145 */         for (int z = 0; z < framesByTrackSort.size(); z++)
> /* 146 */           indexes.add(Integer.valueOf(framesByTrack.indexOf(framesByTrackSort.get(z)))); 
> /* 147 */         for (int y = 0; y < indexes.size(); y++) {
> /* 148 */           imported1Spot.add(spots.get(((Integer)indexes.get(y)).intValue()));
> /*     */         }
> /* 150 */         imported2Spot.add(imported1Spot);
> /*     */       } 
> /*     */ 
> /*     */       
> /* 154 */       for (int k = 0; k < imported2Spot.size(); k++) {
> /* 155 */         TrajectoryModified t = new TrajectoryModified(2);
> /* 156 */         boolean firstPosition = true;
> /* 157 */         for (int m = 0; m < ((List)imported2Spot.get(k)).size(); m++) {
> /* 158 */           double x = ((Spot)((List<Spot>)imported2Spot.get(k)).get(m)).getFeature("POSITION_X").doubleValue();
> /* 159 */           double y = ((Spot)((List<Spot>)imported2Spot.get(k)).get(m)).getFeature("POSITION_Y").doubleValue();
> /* 160 */           int time = ((Spot)((List<Spot>)imported2Spot.get(k)).get(m)).getFeature("FRAME").intValue();
> /* 161 */           if (firstPosition) {
> /* 162 */             t.setRelativStartTimepoint(time);
> /* 163 */             firstPosition = false;
> /*     */           } 
> /* 165 */           t.add(x, y, 0.0D);
> /*     */         } 
> /*     */         
> /* 168 */         this.tracksToClassify.add(t);
> /*     */       } 
> /*     */     } 
> /*     */ 
> /*     */     
> /* 173 */     int maxNumberOfPositions = 0;
> /* 174 */     for (int i = 0; i < this.tracksToClassify.size(); i++) {
> /* 175 */       if (((TrajectoryModified)this.tracksToClassify.get(i)).size() > maxNumberOfPositions) {
> /* 176 */         maxNumberOfPositions = ((TrajectoryModified)this.tracksToClassify.get(i)).size();
> /*     */       }
> /*     */     } 
> /* 179 */     boolean visualize = true;
> /*     */     
> /* 181 */     if (traJParametersWindow.keyWord == "keyword") {
> /* 182 */       this.minTrackLength = Integer.valueOf(traJParametersWindow.minLengthTextS).intValue();
> /* 183 */       this.windowSizeClassification = Integer.valueOf(traJParametersWindow.windowTextS).intValue();
> /* 184 */       this.minSegmentLength = Integer.valueOf(traJParametersWindow.minSegTextS).intValue();
> /*     */     } else {
> /*     */       
> /* 187 */       this.minTrackLength = 10.0D;
> /* 188 */       this.windowSizeClassification = 5;
> /* 189 */       this.minSegmentLength = 5;
> /*     */     } 
> /* 191 */     this.resampleRate = 1;
> /* 192 */     if (SPTBatch_.imps.getCalibration().getXUnit() == "pixel")
> /* 193 */       this.pixelsize = (SPTBatch_.imps.getCalibration()).pixelWidth; 
> /* 194 */     if (SPTBatch_.imps.getCalibration().getXUnit() != "pixel") {
> /* 195 */       this.pixelsize = 0.0D;
> /*     */     }
> /* 197 */     timelag = SPTBatch_.fps;
> /* 198 */     this.useReducedModelConfinedMotion = false;
> /* 199 */     this.showID = true;
> /* 200 */     this.showOverviewClasses = true;
> /* 201 */     this.removeGlobalDrift = false;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 206 */     if (this.pixelsize > 1.0E-6D) {
> /* 207 */       for (int k = 0; k < this.tracksToClassify.size(); k++) {
> /* 208 */         ((TrajectoryModified)this.tracksToClassify.get(k)).scale(this.pixelsize);
> /*     */       }
> /*     */     }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 218 */     for (int j = 0; j < this.tracksToClassify.size(); j++) {
> /* 219 */       TrajectoryModified t = this.tracksToClassify.get(j);
> /* 220 */       int changesCounter = 0;
> /* 221 */       for (int k = 1; k < t.size(); k++) {
> /*     */         
> /* 223 */         if (((Point3dModified)t.get(k)).distance((Point3dModified)t.get(k - 1)) > Math.pow(10.0D, -12.0D)) {
> /* 224 */           changesCounter++;
> /*     */         }
> /*     */       } 
> /* 227 */       if (1.0D * changesCounter / t.size() < 0.5D) {
> /* 228 */         this.tracksToClassify.remove(j);
> /* 229 */         this.ommittedTrajectories++;
> /* 230 */         j--;
> /*     */       } 
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 238 */     HashMap<String, Color> mapTypeToColor = new HashMap<>();
> /* 239 */     mapTypeToColor.put("DIRECTED/ACTIVE", Color.MAGENTA);
> /* 240 */     mapTypeToColor.put("NORM. DIFFUSION", Color.RED);
> /* 241 */     mapTypeToColor.put("CONFINED", Color.YELLOW);
> /* 242 */     mapTypeToColor.put("SUBDIFFUSION", Color.GREEN);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 247 */     this.parentTrajectories = new ArrayList<>();
> /* 248 */     for (TrajectoryModified track : this.tracksToClassify) {
> /* 249 */       if (track.size() > this.minTrackLength) {
> /* 250 */         this.parentTrajectories.add(track);
> /*     */       }
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 257 */     StaticDriftCalculatorModified<TrajectoryModified> dcalc = new StaticDriftCalculatorModified();
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 267 */     if (this.parentTrajectories.isEmpty() == Boolean.FALSE.booleanValue()) {
> /*     */       
> /* 269 */       this.classifiedSegments = classifyAndSegment(this.parentTrajectories, modelpath, this.windowSizeClassification, 
> /* 270 */           this.minSegmentLength, 10, this.resampleRate);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */       
> /* 275 */       if (visualize) {
> /*     */         
> /* 277 */         Overlay ov = new Overlay();
> /* 278 */         for (int n = 0; n < this.classifiedSegments.size(); n++) {
> /* 279 */           SubtrajectoryModified tr = this.classifiedSegments.get(n);
> /*     */           
> /* 281 */           ArrayList<Roi> prois = null;
> /* 282 */           if (this.pixelsize > 1.0E-6D) {
> /* 283 */             prois = VisualizationUtilsModified.generateVisualizationRoisFromTrack(tr, 
> /* 284 */                 mapTypeToColor.get(tr.getType()), this.showID, this.pixelsize);
> /*     */           } else {
> /*     */             
> /* 287 */             prois = VisualizationUtilsModified.generateVisualizationRoisFromTrack(tr, 
> /* 288 */                 mapTypeToColor.get(tr.getType()), this.showID, (IJ.getImage().getCalibration()).pixelWidth);
> /*     */           } 
> /* 290 */           for (Roi r : prois) {
> /* 291 */             ov.add(r);
> /*     */           }
> /*     */         } 
> /*     */ 
> /*     */         
> /* 296 */         if (this.showOverviewClasses) {
> /* 297 */           Set<String> classes = mapTypeToColor.keySet();
> /*     */           
> /* 299 */           Iterator<String> it = classes.iterator();
> /* 300 */           int y = 5;
> /*     */           
> /* 302 */           float fsize = 20.0F;
> /* 303 */           AffineTransform affinetransform = new AffineTransform();
> /* 304 */           FontRenderContext frc = new FontRenderContext(affinetransform, true, true);
> /* 305 */           int width = 
> /* 306 */             (int)IJ.getImage().getProcessor().getFont().getStringBounds("Norm. Diffusion", frc).getWidth();
> /* 307 */           Font f = IJ.getImage().getProcessor().getFont();
> /* 308 */           while (1.0D * width / IJ.getImage().getWidth() > 0.08D) {
> /* 309 */             fsize--;
> /* 310 */             f = f.deriveFont(fsize);
> /* 311 */             width = (int)f.getStringBounds("Norm. Diffusion", frc).getWidth();
> /*     */           } 
> /*     */           
> /* 314 */           TextRoi.setFont("TimesRoman", (int)fsize, 0);
> /* 315 */           while (it.hasNext()) {
> /* 316 */             String type = it.next();
> /* 317 */             TextRoi troi = new TextRoi(5, y, type);
> /* 318 */             troi.setFillColor(Color.DARK_GRAY);
> /* 319 */             troi.setStrokeColor(mapTypeToColor.get(type));
> /* 320 */             ov.add((Roi)troi);
> /* 321 */             y += 20;
> /*     */           } 
> /*     */         } 
> /*     */ 
> /*     */         
> /* 326 */         IJ.getImage().setOverlay(ov);
> /* 327 */         IJ.getImage().updateAndRepaintWindow();
> /*     */       } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */       
> /* 334 */       HashMap<String, TraJResultsTable> rtables = new HashMap<>();
> /* 335 */       rtables.put("DIRECTED/ACTIVE", new TraJResultsTable());
> /* 336 */       rtables.put("NORM. DIFFUSION", new TraJResultsTable());
> /* 337 */       rtables.put("SUBDIFFUSION", new TraJResultsTable());
> /* 338 */       rtables.put("CONFINED", new TraJResultsTable());
> /*     */       
> /* 340 */       double sumConf = 0.0D;
> /* 341 */       for (int k = 0; k < this.classifiedSegments.size(); k++) {
> /* 342 */         RegressionDiffusionCoefficientEstimatorModified regressionDiffusionCoefficientEstimatorModified1; ActiveTransportParametersFeatureModified apf; RegressionDiffusionCoefficientEstimatorModified regressionDiffusionCoefficientEstimatorModified2; ConfinedDiffusionParametersFeatureModified confp; double[] p; PowerLawFeatureModified pwf; IJ.showProgress(k, this.classifiedSegments.size());
> /* 343 */         SubtrajectoryModified t = this.classifiedSegments.get(k);
> /* 344 */         TraJResultsTable rt = rtables.get(t.getType());
> /*     */         
> /* 346 */         if (rt == null) {
> /* 347 */           SPTBatch_.taskOutput.append("Type: " + t.getType());
> /* 348 */           ExportImportToolsModified eit = new ExportImportToolsModified();
> /* 349 */           ArrayList<TrajectoryModified> hlp = new ArrayList<>();
> /* 350 */           eit.exportTrajectoryDataAsCSV(hlp, String.valueOf(SPTBatch_.csvPath) + File.separator + "bad" + ".csv");
> /* 351 */           SPTBatch_.taskOutput.append(t.toString());
> /*     */         } 
> /*     */         
> /* 354 */         rt.incrementCounter();
> /* 355 */         rt.addValue("PARENT-ID", t.getParent().getID());
> /* 356 */         rt.addValue("ID", t.getID());
> /* 357 */         rt.addValue("LENGTH", t.size());
> /* 358 */         rt.addValue("START", t.getRelativeStartTimepoint());
> /* 359 */         rt.addValue("END", (t.getRelativeStartTimepoint() + t.size() - 1));
> /* 360 */         rt.addValue("CLASS", t.getType());
> /*     */         
> /* 362 */         AbstractTrajectoryFeatureModified dcEstim = null;
> /* 363 */         double dc = 0.0D;
> /* 364 */         DecimalFormatSymbols otherSymbols = new DecimalFormatSymbols(Locale.ENGLISH);
> /* 365 */         NumberFormat formatter = new DecimalFormat("0.###E0", otherSymbols);
> /*     */         
> /* 367 */         double goodness = 0.0D;
> /* 368 */         double alphaGoodness = 0.0D; String str;
> /* 369 */         switch ((str = t.getType()).hashCode()) { case -1768066899: if (!str.equals("DIRECTED/ACTIVE")) {
> /*     */               break;
> /*     */             }
> /* 372 */             apf = new ActiveTransportParametersFeatureModified((TrajectoryModified)t, 
> /* 373 */                 timelag);
> /* 374 */             res = apf.evaluate();
> /* 375 */             rt.addValue("(FIT) D", formatter.format(res[0]));
> /* 376 */             rt.addValue("(FIT) Velocity", res[1]);
> /* 377 */             goodness = res[2];
> /*     */             break;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */           
> /*     */           case -568951419:
> /*     */             if (!str.equals("SUBDIFFUSION")) {
> /*     */               break;
> /*     */             }
> /* 408 */             pwf = new PowerLawFeatureModified((TrajectoryModified)t, 1.0D / timelag, 1, t.size() / 3);
> /* 409 */             res = pwf.evaluate();
> /* 410 */             dc = res[1];
> /*     */             
> /* 412 */             rt.addValue("(FIT) D", formatter.format(dc));
> /* 413 */             goodness = res[2]; break;
> /*     */           case 160958711:
> /*     */             if (!str.equals("NORM. DIFFUSION"))
> /*     */               break;  regressionDiffusionCoefficientEstimatorModified1 = new RegressionDiffusionCoefficientEstimatorModified((TrajectoryModified)t, 1.0D / timelag, 1, t.size() / 3); res = regressionDiffusionCoefficientEstimatorModified1.evaluate(); dc = res[0]; rt.addValue("(FIT) D", formatter.format(dc)); goodness = res[3]; break;
> /*     */           case 202494376:
> /*     */             if (!str.equals("CONFINED"))
> /* 419 */               break;  regressionDiffusionCoefficientEstimatorModified2 = new RegressionDiffusionCoefficientEstimatorModified((TrajectoryModified)t, 1.0D / timelag, 1, 3); confp = new ConfinedDiffusionParametersFeatureModified((TrajectoryModified)t, timelag, this.useReducedModelConfinedMotion, (AbstractDiffusionCoefficientEstimatorModified)regressionDiffusionCoefficientEstimatorModified2); p = confp.evaluate(); dc = p[1]; if (this.useReducedModelConfinedMotion) { rt.addValue("(FIT) CONF. RADIUS", Math.sqrt(p[0])); rt.addValue("(FIT) D", formatter.format(p[1])); goodness = p[2]; break; }  rt.addValue("(FIT) CONF. RADIUS", Math.sqrt(p[0])); rt.addValue("(FIT) A [CONF. SHAPE]", p[2]); rt.addValue("(FIT) B (CONF SHAPE)", p[3]); rt.addValue("(FIT) D", formatter.format(p[1])); goodness = p[4]; break; }  PowerLawFeatureModified powerLawFeatureModified1 = new PowerLawFeatureModified((TrajectoryModified)t, 1.0D / timelag, 1, t.size() / 3);
> /* 420 */         double[] res = powerLawFeatureModified1.evaluate();
> /* 421 */         double alpha = res[0];
> /* 422 */         alphaGoodness = res[2];
> /*     */         
> /* 424 */         CenterOfGravityFeatureModified centerOfGravityFeatureModified = new CenterOfGravityFeatureModified((TrajectoryModified)t);
> /* 425 */         double cog_x = centerOfGravityFeatureModified.evaluate()[0];
> /* 426 */         double cog_y = centerOfGravityFeatureModified.evaluate()[1];
> /* 427 */         rt.addValue("X (COG)", cog_x);
> /* 428 */         rt.addValue("Y (COG)", cog_y);
> /*     */         
> /* 430 */         if (!t.getType().equals("NONE")) {
> /* 431 */           FractalDimensionFeatureModified fdf = new FractalDimensionFeatureModified((TrajectoryModified)t);
> /* 432 */           double v = fdf.evaluate()[0];
> /*     */           
> /* 434 */           rt.addValue("FRACT. DIM.", v);
> /*     */           
> /* 436 */           TrappedProbabilityFeatureModified trapped = new TrappedProbabilityFeatureModified((TrajectoryModified)t);
> /* 437 */           v = trapped.evaluate()[0];
> /* 438 */           rt.addValue("TRAPPEDNESS", v);
> /*     */           
> /* 440 */           EfficiencyFeatureModified eff = new EfficiencyFeatureModified((TrajectoryModified)t);
> /* 441 */           v = eff.evaluate()[0];
> /* 442 */           rt.addValue("EFFICENCY", v);
> /*     */           
> /* 444 */           StraightnessFeatureModified straight = new StraightnessFeatureModified((TrajectoryModified)t);
> /* 445 */           v = straight.evaluate()[0];
> /* 446 */           rt.addValue("STRAIGHTNESS", v);
> /*     */           
> /* 448 */           MeanSpeedFeatureModified msfeature = new MeanSpeedFeatureModified((TrajectoryModified)t, timelag);
> /* 449 */           v = msfeature.evaluate()[1];
> /* 450 */           rt.addValue("SPEED", v);
> /*     */           
> /* 452 */           KurtosisFeatureModified kurt = new KurtosisFeatureModified((TrajectoryModified)t);
> /* 453 */           v = kurt.evaluate()[0];
> /* 454 */           rt.addValue("KURTOSIS", v);
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */           
> /* 459 */           rt.addValue("(FIT) ALPHA", alpha);
> /*     */           
> /* 461 */           GaussianityFeautureModified gauss = new GaussianityFeautureModified((TrajectoryModified)t, 1);
> /* 462 */           v = gauss.evaluate()[0];
> /* 463 */           rt.addValue("GAUSSIANITY", v);
> /*     */           
> /* 465 */           Asymmetry3FeatureModified asym3 = new Asymmetry3FeatureModified((TrajectoryModified)t);
> /* 466 */           v = asym3.evaluate()[0];
> /* 467 */           rt.addValue("Asymmetry", v);
> /*     */           
> /* 469 */           MSDRatioFeatureModified msdratio = new MSDRatioFeatureModified((TrajectoryModified)t, 1, 5);
> /* 470 */           v = msdratio.evaluate()[0];
> /* 471 */           rt.addValue("MSDRatio", v);
> /*     */           
> /* 473 */           CovarianceDiffusionCoefficientEstimatorModified cest = new CovarianceDiffusionCoefficientEstimatorModified(
> /* 474 */               (TrajectoryModified)t, 1.0D / timelag);
> /* 475 */           res = cest.evaluate();
> /* 476 */           rt.addValue("Loc. noise_sigma", (res[1] + res[2]) / 2.0D);
> /* 477 */           rt.addValue("Fit Goodness", goodness);
> /* 478 */           rt.addValue("Alpha Fit Goodness", alphaGoodness);
> /* 479 */           double conf = t.getConfidence();
> /* 480 */           sumConf += conf;
> /* 481 */           rt.addValue("Confidence", conf);
> /*     */         } 
> /*     */       } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */       
> /* 491 */       Iterator<String> rtIt = rtables.keySet().iterator();
> /*     */       
> /* 493 */       TraJResultsTable traJResultsTable = new TraJResultsTable(true);
> /*     */       
> /* 495 */       for (int m = 0; m < this.parentTrajectories.size(); m++) {
> /* 496 */         traJResultsTable.incrementCounter();
> /* 497 */         TrajectoryModified t = this.parentTrajectories.get(m);
> /* 498 */         traJResultsTable.addValue("ID", t.getID());
> /* 499 */         traJResultsTable.addValue("LENGTH", t.size());
> /* 500 */         traJResultsTable.addValue("START", t.getRelativeStartTimepoint());
> /* 501 */         traJResultsTable.addValue("END", (t.getRelativeStartTimepoint() + t.size() - 1));
> /* 502 */         int subPosCount = 0;
> /* 503 */         int subSegCount = 0;
> /* 504 */         int normPosCount = 0;
> /* 505 */         int normSegCount = 0;
> /* 506 */         int directedPosCount = 0;
> /* 507 */         int directSegCount = 0;
> /* 508 */         int confPosCount = 0;
> /* 509 */         int confSegCount = 0;
> /*     */         
> /* 511 */         ArrayList<SubtrajectoryModified> sameParent = 
> /* 512 */           SubtrajectoryModified.getTracksWithSameParant(this.classifiedSegments, t.getID());
> /* 513 */         for (SubtrajectoryModified sub : sameParent)
> /* 514 */         { String str; switch ((str = sub.getType()).hashCode()) { case -1768066899: if (!str.equals("DIRECTED/ACTIVE"))
> /*     */                 continue; 
> /* 516 */               directedPosCount += sub.size();
> /* 517 */               directSegCount++;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */             
> /*     */             case -568951419:
> /*     */               if (!str.equals("SUBDIFFUSION")) {
> /*     */                 continue;
> /*     */               }
> /* 528 */               subPosCount += sub.size();
> /* 529 */               subSegCount++;
> /*     */             case 160958711:
> /*     */               if (!str.equals("NORM. DIFFUSION"))
> /*     */                 continue;  normPosCount += sub.size(); normSegCount++;
> /*     */             case 202494376:
> /*     */               if (!str.equals("CONFINED"))
> /* 535 */                 continue;  confPosCount += sub.size(); confSegCount++; }  }  traJResultsTable.addValue("#SEG_NORM", normSegCount);
> /* 536 */         traJResultsTable.addValue("#POS_NORM", normPosCount);
> /* 537 */         traJResultsTable.addValue("#SEG_SUB", subSegCount);
> /* 538 */         traJResultsTable.addValue("#POS_SUB", subPosCount);
> /* 539 */         traJResultsTable.addValue("#SEG_CONF", confSegCount);
> /* 540 */         traJResultsTable.addValue("#POS_CONF", confPosCount);
> /* 541 */         traJResultsTable.addValue("#SEG_DIRECTED", directSegCount);
> /* 542 */         traJResultsTable.addValue("#POS_DIRECTED", directedPosCount);
> /*     */       } 
> /*     */       
> /* 545 */       String trajVersion = TrajectoryModified.class.getPackage().getImplementationVersion();
> /* 546 */       double[] drift = dcalc.calculateDrift(this.parentTrajectories);
> /* 547 */       ResultsTable overall = new ResultsTable();
> /* 548 */       overall.incrementCounter();
> /* 549 */       overall.addValue("Mean confindence", sumConf / this.classifiedSegments.size());
> /* 550 */       overall.addValue("Drift x", drift[0]);
> /* 551 */       overall.addValue("Drift y", drift[1]);
> /* 552 */       overall.addValue("Omitted segments", this.ommittedTrajectories);
> /* 553 */       overall.addValue("Min. track length", this.minTrackLength);
> /* 554 */       overall.addValue("Window size", (this.windowSizeClassification * 2));
> /* 555 */       overall.addValue("Min. segment length", this.minSegmentLength);
> /* 556 */       overall.addValue("Resamplerate", this.resampleRate);
> /* 557 */       overall.addValue("Pixelsize", this.pixelsize);
> /* 558 */       overall.addValue("Framerate", 1.0D / timelag);
> /* 559 */       overall.addValue("Reduced conf. model", Boolean.toString(this.useReducedModelConfinedMotion));
> /* 560 */       overall.addValue("Remove global drift", Boolean.toString(this.removeGlobalDrift));
> /* 561 */       overall.addValue("TraJ library version", trajVersion);
> /* 562 */       overall.save(SPTBatch_.directDiff + File.separator + "Settings & Miscellaneous" + 
> /* 563 */           SPTBatch_.imps.getShortTitle() + ".xls");
> /*     */ 
> /*     */       
> /* 566 */       traJResultsTable.save(SPTBatch_.directDiff + File.separator + "Parents_" + SPTBatch_.imps.getShortTitle() + ".xls");
> /*     */       
> /* 568 */       rtIt = rtables.keySet().iterator();
> /* 569 */       while (rtIt.hasNext()) {
> /* 570 */         String rt = rtIt.next();
> /* 571 */         if (rt.equals("DIRECTED/ACTIVE") == Boolean.TRUE.booleanValue()) {
> /* 572 */           ((TraJResultsTable)rtables.get(rt)).save(SPTBatch_.directDiff + File.separator + "DIRECTED_ACTIVE" + "_trajectories_" + 
> /* 573 */               SPTBatch_.imps.getShortTitle() + ".xls"); continue;
> /*     */         } 
> /* 575 */         ((TraJResultsTable)rtables.get(rt)).save(SPTBatch_.directDiff + File.separator + rt + "_trajectories_" + 
> /* 576 */             SPTBatch_.imps.getShortTitle() + ".xls");
> /*     */       } 
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ArrayList<SubtrajectoryModified> classifyAndSegment(TrajectoryModified trackToClassify, String modelpath, int windowSizeClassification, int minSegmentLength, int modeFilterLength, int resampleRate) {
> /* 586 */     ArrayList<TrajectoryModified> help = new ArrayList<>();
> /* 587 */     help.add(trackToClassify);
> /* 588 */     return classifyAndSegment(help, modelpath, windowSizeClassification, minSegmentLength, modeFilterLength, 
> /* 589 */         resampleRate);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public ArrayList<SubtrajectoryModified> classifyAndSegment(ArrayList<TrajectoryModified> tracksToClassify, String modelpath, int windowSizeClassification, int minSegmentLength, int modeFilterLength, int resampleRate) {
> /* 595 */     ArrayList<SubtrajectoryModified> classified = new ArrayList<>();
> /* 596 */     int j = 0;
> /* 597 */     RRFClassifierRenjinModified rrf = new RRFClassifierRenjinModified(modelpath, resampleRate * timelag);
> /* 598 */     rrf.start();
> /*     */     
> /* 600 */     WeightedWindowedClassificationProcessModified wcp = new WeightedWindowedClassificationProcessModified();
> /* 601 */     int subidcounter = 1;
> /* 602 */     for (TrajectoryModified track : tracksToClassify) {
> /* 603 */       j++;
> /* 604 */       IJ.showProgress(j, tracksToClassify.size());
> /* 605 */       TrajectoryModified mTrack = track;
> /*     */       
> /* 607 */       String[] classes = wcp.windowedClassification(mTrack, (AbstractClassifierModified)rrf, windowSizeClassification, resampleRate);
> /*     */       
> /* 609 */       double[] classConfidence = wcp.getPositionConfidence();
> /*     */       
> /* 611 */       classes = movingMode(classes, modeFilterLength);
> /* 612 */       double sumConf = 0.0D;
> /* 613 */       int Nconf = 0;
> /* 614 */       SubtrajectoryModified tr = new SubtrajectoryModified(track, 2);
> /*     */       
> /* 616 */       tr.setID(subidcounter);
> /* 617 */       subidcounter++;
> /* 618 */       tr.add(((Point3dModified)track.get(0)).x, ((Point3dModified)track.get(0)).y, 0.0D);
> /* 619 */       sumConf += classConfidence[0];
> /* 620 */       Nconf++;
> /* 621 */       String prevCls = classes[0];
> /* 622 */       int start = track.getRelativeStartTimepoint();
> /* 623 */       tr.setRelativStartTimepoint(start);
> /* 624 */       tr.setType(prevCls);
> /*     */       
> /* 626 */       for (int k = 1; k < classes.length; k++) {
> /* 627 */         if (prevCls == classes[k]) {
> /* 628 */           tr.add(((Point3dModified)track.get(k)).x, ((Point3dModified)track.get(k)).y, 0.0D);
> /* 629 */           sumConf += classConfidence[k];
> /* 630 */           Nconf++;
> /*     */         } else {
> /*     */           
> /* 633 */           tr.setConfidence(sumConf / Nconf);
> /* 634 */           classified.add(tr);
> /* 635 */           tr = new SubtrajectoryModified(track, 2);
> /* 636 */           tr.setID(subidcounter);
> /* 637 */           subidcounter++;
> /* 638 */           tr.setRelativStartTimepoint(start + k);
> /* 639 */           tr.add(((Point3dModified)track.get(k)).x, ((Point3dModified)track.get(k)).y, 0.0D);
> /* 640 */           sumConf = classConfidence[k];
> /* 641 */           Nconf = 1;
> /* 642 */           prevCls = classes[k];
> /* 643 */           tr.setType(prevCls);
> /*     */         } 
> /*     */       } 
> /* 646 */       tr.setConfidence(sumConf / Nconf);
> /* 647 */       classified.add(tr);
> /* 648 */       sumConf = 0.0D;
> /* 649 */       Nconf = 0;
> /*     */     } 
> /*     */     
> /* 652 */     rrf.stop();
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 659 */     for (int i = 0; i < classified.size(); i++) {
> /* 660 */       if (((SubtrajectoryModified)classified.get(i)).size() < minSegmentLength) {
> /* 661 */         classified.remove(i);
> /* 662 */         i--;
> /*     */       } 
> /*     */     } 
> /* 665 */     return classified;
> /*     */   }
> /*     */   
> /*     */   public double getTimelag() {
> /* 669 */     return timelag;
> /*     */   }
> /*     */   
> /*     */   public static String[] movingMode(String[] types, int n) {
> /* 673 */     ArrayList<String> ltypes = new ArrayList<>();
> /* 674 */     for (int i = 0; i < types.length; i++) {
> /* 675 */       ltypes.add(types[i]);
> /*     */     }
> /* 677 */     return movingMode(ltypes, n);
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public static String[] movingMode(ArrayList<String> types, int n) {
> /* 682 */     int windowsize = 2 * n + 1;
> /* 683 */     HashSet<String> uniqueTypes = new HashSet<>();
> /* 684 */     uniqueTypes.addAll(types);
> /* 685 */     HashMap<String, Integer> mapTypeToInt = new HashMap<>();
> /* 686 */     HashMap<Integer, String> mapIntToType = new HashMap<>();
> /* 687 */     Iterator<String> it = uniqueTypes.iterator();
> /* 688 */     int key = 0;
> /* 689 */     while (it.hasNext()) {
> /* 690 */       String type = it.next();
> /* 691 */       mapTypeToInt.put(type, Integer.valueOf(key));
> /* 692 */       mapIntToType.put(Integer.valueOf(key), type);
> /* 693 */       key++;
> /*     */     } 
> /*     */     
> /* 696 */     String[] medTypes = new String[types.size()];
> /*     */     int i;
> /* 698 */     for (i = 0; i < n; i++) {
> /* 699 */       medTypes[i] = types.get(i);
> /*     */     }
> /* 701 */     for (i = types.size() - n; i < types.size(); i++) {
> /* 702 */       medTypes[i] = types.get(i);
> /*     */     }
> /*     */     
> /* 705 */     for (i = 0; i < types.size() - windowsize + 1; i++) {
> /* 706 */       List<String> sub = types.subList(i, i + windowsize - 1);
> /* 707 */       double[] values = new double[sub.size()];
> /* 708 */       for (int j = 0; j < sub.size(); j++) {
> /* 709 */         values[j] = ((Integer)mapTypeToInt.get(sub.get(j))).intValue();
> /*     */       }
> /*     */       
> /* 712 */       medTypes[i + n] = mapIntToType.get(Integer.valueOf((int)StatUtils.mode(values)[0]));
> /*     */     } 
> /* 714 */     return medTypes;
> /*     */   }
> /*     */   
> /*     */   public ArrayList<SubtrajectoryModified> getClassifiedTrajectories() {
> /* 718 */     return this.classifiedSegments;
> /*     */   }
> /*     */   
> /*     */   public ArrayList<TrajectoryModified> getParentTrajectories() {
> /* 722 */     return this.parentTrajectories;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String ExportResource(String resourceName) throws Exception {
> /*     */     String tmpFolder;
> /* 733 */     InputStream stream = null;
> /* 734 */     OutputStream resStreamOut = null;
> /*     */     
> /*     */     try {
> /* 737 */       stream = getClass().getResourceAsStream(resourceName);
> /*     */       
> /* 739 */       if (stream == null) {
> /* 740 */         IJ.error("Cannot get resource \"" + resourceName + "\" from Jar file.");
> /* 741 */         throw new Exception("Cannot get resource \"" + resourceName + "\" from Jar file.");
> /*     */       } 
> /*     */ 
> /*     */       
> /* 745 */       byte[] buffer = new byte[4096];
> /* 746 */       File folderDir = new File(String.valueOf(IJ.getDirectory("temp")) + "/.trajclassifier");
> /*     */ 
> /*     */       
> /* 749 */       if (!folderDir.exists()) {
> /* 750 */         folderDir.mkdir();
> /*     */       }
> /* 752 */       tmpFolder = folderDir.getPath().replace('\\', '/');
> /* 753 */       resStreamOut = new FileOutputStream(String.valueOf(tmpFolder) + resourceName); int readBytes;
> /* 754 */       while ((readBytes = stream.read(buffer)) > 0) {
> /* 755 */         resStreamOut.write(buffer, 0, readBytes);
> /*     */       }
> /* 757 */     } catch (Exception ex) {
> /* 758 */       Exception exception1; IJ.error(exception1.getMessage());
> /* 759 */       throw exception1;
> /*     */     } finally {
> /* 761 */       stream.close();
> /* 762 */       resStreamOut.close();
> /* 763 */     }  return 
> /*     */       
> /* 765 */       String.valueOf(tmpFolder) + resourceName;
> /*     */   }
> /*     */   
> /*     */   public void setTracksToClassify(ArrayList<TrajectoryModified> t) {
> /* 769 */     this.tracksToClassify = t;
> /*     */   }
> /*     */   
> /*     */   public double getMinTrackLength() {
> /* 773 */     return this.minTrackLength;
> /*     */   }
> /*     */   
> /*     */   public void setMinTrackLength(double minTrackLength) {
> /* 777 */     this.minTrackLength = minTrackLength;
> /*     */   }
> /*     */   
> /*     */   public double getPixelsize() {
> /* 781 */     return this.pixelsize;
> /*     */   }
> /*     */   
> /*     */   public void setPixelsize(double pixelsize) {
> /* 785 */     this.pixelsize = pixelsize;
> /*     */   }
> /*     */   
> /*     */   public boolean isShowID() {
> /* 789 */     return this.showID;
> /*     */   }
> /*     */   
> /*     */   public void setShowID(boolean showID) {
> /* 793 */     this.showID = showID;
> /*     */   }
> /*     */   
> /*     */   public int getWindowSizeClassification() {
> /* 797 */     return this.windowSizeClassification;
> /*     */   }
> /*     */   
> /*     */   public boolean isUseReducedModelConfinedMotion() {
> /* 801 */     return this.useReducedModelConfinedMotion;
> /*     */   }
> /*     */   
> /*     */   public void setTimelag(double timelag) {
> /* 805 */     TraJClassifierTest_.timelag = timelag;
> /*     */   }
> /*     */   
> /*     */   public void setWindowSizeClassification(int windowSizeClassification) {
> /* 809 */     this.windowSizeClassification = windowSizeClassification;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/TraJClassifierTest_.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/trajectory_classifier/AbstractClassifierModified.java jd-gui/trajectory_classifier/AbstractClassifierModified.java
7,11c7,16
<    public abstract String classify(TrajectoryModified var1);
< 
<    public abstract void start();
< 
<    public abstract void stop();
---
>   public abstract String classify(TrajectoryModified paramTrajectoryModified);
>   
>   public abstract void start();
>   
>   public abstract void stop();
>   
>   public abstract String[] classify(ArrayList<TrajectoryModified> paramArrayList);
>   
>   public abstract double[] getConfindence();
> }
13d17
<    public abstract String[] classify(ArrayList<TrajectoryModified> var1);
15,16c19,22
<    public abstract double[] getConfindence();
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/trajectory_classifier/AbstractClassifierModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/trajectory_classifier/ExportImportToolsModified.java jd-gui/trajectory_classifier/ExportImportToolsModified.java
1,77c1,84
< package trajectory_classifier;
< 
< import com.opencsv.CSVReader;
< import com.opencsv.CSVWriter;
< import java.io.FileReader;
< import java.io.FileWriter;
< import java.io.IOException;
< import java.util.ArrayList;
< import traJ.TrajectoryModified;
< import vecmath.Point3dModified;
< 
< public class ExportImportToolsModified {
<    public void exportTrajectoryDataAsCSV(ArrayList<? extends TrajectoryModified> tracks, String path) {
<       String[] nextLine = null;
< 
<       try {
<          CSVWriter writer = new CSVWriter(new FileWriter(path, false));
<          nextLine = new String[]{"ID", "X", "Y", "CLASS"};
<          writer.writeNext(nextLine);
< 
<          for(int i = 0; i < tracks.size(); ++i) {
<             TrajectoryModified t = (TrajectoryModified)tracks.get(i);
< 
<             for(int j = 0; j < t.size(); ++j) {
<                nextLine = new String[]{"" + t.getID(), "" + ((Point3dModified)t.get(j)).x, "" + ((Point3dModified)t.get(j)).y, t.getType()};
<                writer.writeNext(nextLine);
<             }
<          }
< 
<          writer.close();
<       } catch (IOException var8) {
<          var8.printStackTrace();
<       }
< 
<    }
< 
<    public ArrayList<TrajectoryModified> importTrajectoryDataFromCSV(String path) {
<       ArrayList tracks = new ArrayList();
< 
<       try {
<          CSVReader reader = new CSVReader(new FileReader(path));
<          reader.readNext();
<          TrajectoryModified t = null;
<          int lastID = -1;
< 
<          String[] nextLine;
<          while((nextLine = reader.readNext()) != null) {
<             int nextID = Integer.parseInt(nextLine[0]);
<             double nextX = Double.parseDouble(nextLine[1]);
<             double nextY = Double.parseDouble(nextLine[2]);
<             String nextClass = nextLine[3];
<             if (nextID == lastID) {
<                System.out.println();
<                t.add(nextX, nextY, 0.0D);
<                lastID = nextID;
<             } else {
<                if (t != null) {
<                   tracks.add(t);
<                }
< 
<                t = new TrajectoryModified(2);
<                t.setID(nextID);
<                t.setType(nextClass);
<                t.add(nextX, nextY, 0.0D);
<                lastID = nextID;
<             }
<          }
< 
<          tracks.add(t);
<          reader.close();
<       } catch (IOException var13) {
<          var13.printStackTrace();
<       }
< 
<       return tracks;
<    }
< }
---
> /*    */ package trajectory_classifier;
> /*    */ 
> /*    */ import com.opencsv.CSVReader;
> /*    */ import com.opencsv.CSVWriter;
> /*    */ import java.io.FileReader;
> /*    */ import java.io.FileWriter;
> /*    */ import java.io.IOException;
> /*    */ import java.util.ArrayList;
> /*    */ import traJ.TrajectoryModified;
> /*    */ import vecmath.Point3dModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class ExportImportToolsModified
> /*    */ {
> /*    */   public void exportTrajectoryDataAsCSV(ArrayList<? extends TrajectoryModified> tracks, String path) {
> /* 18 */     String[] nextLine = null;
> /*    */     try {
> /* 20 */       CSVWriter writer = new CSVWriter(new FileWriter(path, false));
> /* 21 */       nextLine = new String[] { "ID", "X", "Y", "CLASS" };
> /* 22 */       writer.writeNext(nextLine);
> /*    */       
> /* 24 */       for (int i = 0; i < tracks.size(); i++) {
> /* 25 */         TrajectoryModified t = tracks.get(i);
> /* 26 */         for (int j = 0; j < t.size(); j++) {
> /* 27 */           nextLine = new String[] { t.getID(), ((Point3dModified)t.get(j)).x, ((Point3dModified)t.get(j)).y, t.getType() };
> /* 28 */           writer.writeNext(nextLine);
> /*    */         } 
> /*    */       } 
> /* 31 */       writer.close();
> /*    */     }
> /* 33 */     catch (IOException e) {
> /*    */       
> /* 35 */       e.printStackTrace();
> /*    */     } 
> /*    */   }
> /*    */   
> /*    */   public ArrayList<TrajectoryModified> importTrajectoryDataFromCSV(String path) {
> /* 40 */     ArrayList<TrajectoryModified> tracks = new ArrayList<>();
> /*    */     try {
> /* 42 */       CSVReader reader = new CSVReader(new FileReader(path));
> /*    */       
> /* 44 */       reader.readNext();
> /* 45 */       TrajectoryModified t = null;
> /* 46 */       int lastID = -1; String[] nextLine;
> /* 47 */       while ((nextLine = reader.readNext()) != null) {
> /* 48 */         int nextID = Integer.parseInt(nextLine[0]);
> /* 49 */         double nextX = Double.parseDouble(nextLine[1]);
> /* 50 */         double nextY = Double.parseDouble(nextLine[2]);
> /* 51 */         String nextClass = nextLine[3];
> /* 52 */         if (nextID == lastID) {
> /* 53 */           System.out.println();
> /* 54 */           t.add(nextX, nextY, 0.0D);
> /* 55 */           lastID = nextID; continue;
> /*    */         } 
> /* 57 */         if (t != null) {
> /* 58 */           tracks.add(t);
> /*    */         }
> /* 60 */         t = new TrajectoryModified(2);
> /* 61 */         t.setID(nextID);
> /* 62 */         t.setType(nextClass);
> /* 63 */         t.add(nextX, nextY, 0.0D);
> /* 64 */         lastID = nextID;
> /*    */       } 
> /*    */       
> /* 67 */       tracks.add(t);
> /* 68 */       reader.close();
> /*    */     
> /*    */     }
> /* 71 */     catch (IOException e) {
> /*    */       
> /* 73 */       e.printStackTrace();
> /*    */     } 
> /*    */     
> /* 76 */     return tracks;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/trajectory_classifier/ExportImportToolsModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/trajectory_classifier/FeatureWorkerModified.java jd-gui/trajectory_classifier/FeatureWorkerModified.java
1,91c1,51
< package trajectory_classifier;
< 
< import features.AbstractTrajectoryFeatureModified;
< 
< public class FeatureWorkerModified extends Thread {
<    double[] result;
<    AbstractTrajectoryFeatureModified c;
<    FeatureWorkerModified.EVALTYPE ev;
<    int resIndex;
<    // $FF: synthetic field
<    private static int[] $SWITCH_TABLE$trajectory_classifier$FeatureWorkerModified$EVALTYPE;
< 
<    public FeatureWorkerModified(double[] result, int resIndex, AbstractTrajectoryFeatureModified c, FeatureWorkerModified.EVALTYPE ev) {
<       this.result = result;
<       this.c = c;
<       this.ev = ev;
<       this.resIndex = resIndex;
<    }
< 
<    public void run() {
<       double[] res;
<       switch($SWITCH_TABLE$trajectory_classifier$FeatureWorkerModified$EVALTYPE()[this.ev.ordinal()]) {
<       case 1:
<          res = this.c.getValue();
<          this.result[this.resIndex] = res[0];
<          break;
<       case 2:
<          res = this.c.getValue();
<          this.result[this.resIndex] = res[1];
<          break;
<       case 3:
<          res = this.c.getValue();
<          this.result[this.resIndex] = res[0] / res[1];
<          break;
<       case 4:
<          res = this.c.getValue();
<          this.result[this.resIndex] = res[1] / res[0];
<          break;
<       case 5:
<          res = this.c.getValue();
<          this.result[this.resIndex] = res[1] / res[2];
<       }
< 
<    }
< 
<    // $FF: synthetic method
<    static int[] $SWITCH_TABLE$trajectory_classifier$FeatureWorkerModified$EVALTYPE() {
<       int[] var10000 = $SWITCH_TABLE$trajectory_classifier$FeatureWorkerModified$EVALTYPE;
<       if (var10000 != null) {
<          return var10000;
<       } else {
<          int[] var0 = new int[FeatureWorkerModified.EVALTYPE.values().length];
< 
<          try {
<             var0[FeatureWorkerModified.EVALTYPE.FIRST.ordinal()] = 1;
<          } catch (NoSuchFieldError var5) {
<          }
< 
<          try {
<             var0[FeatureWorkerModified.EVALTYPE.RATIO_01.ordinal()] = 3;
<          } catch (NoSuchFieldError var4) {
<          }
< 
<          try {
<             var0[FeatureWorkerModified.EVALTYPE.RATIO_10.ordinal()] = 4;
<          } catch (NoSuchFieldError var3) {
<          }
< 
<          try {
<             var0[FeatureWorkerModified.EVALTYPE.RATIO_12.ordinal()] = 5;
<          } catch (NoSuchFieldError var2) {
<          }
< 
<          try {
<             var0[FeatureWorkerModified.EVALTYPE.SECOND.ordinal()] = 2;
<          } catch (NoSuchFieldError var1) {
<          }
< 
<          $SWITCH_TABLE$trajectory_classifier$FeatureWorkerModified$EVALTYPE = var0;
<          return var0;
<       }
<    }
< 
<    static enum EVALTYPE {
<       FIRST,
<       SECOND,
<       RATIO_01,
<       RATIO_10,
<       RATIO_12;
<    }
< }
---
> /*    */ package trajectory_classifier;public class FeatureWorkerModified extends Thread { double[] result;
> /*    */   AbstractTrajectoryFeatureModified c;
> /*    */   EVALTYPE ev;
> /*    */   int resIndex;
> /*    */   
> /*  6 */   enum EVALTYPE { FIRST, SECOND, RATIO_01, RATIO_10, RATIO_12; }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public FeatureWorkerModified(double[] result, int resIndex, AbstractTrajectoryFeatureModified c, EVALTYPE ev) {
> /* 14 */     this.result = result;
> /* 15 */     this.c = c;
> /* 16 */     this.ev = ev;
> /* 17 */     this.resIndex = resIndex;
> /*    */   }
> /*    */ 
> /*    */   
> /*    */   public void run() {
> /*    */     double[] res;
> /* 23 */     switch (this.ev) {
> /*    */       case null:
> /* 25 */         res = this.c.getValue();
> /* 26 */         this.result[this.resIndex] = res[0];
> /*    */         break;
> /*    */       case SECOND:
> /* 29 */         res = this.c.getValue();
> /* 30 */         this.result[this.resIndex] = res[1];
> /*    */         break;
> /*    */       case RATIO_01:
> /* 33 */         res = this.c.getValue();
> /* 34 */         this.result[this.resIndex] = res[0] / res[1];
> /*    */         break;
> /*    */       case RATIO_10:
> /* 37 */         res = this.c.getValue();
> /* 38 */         this.result[this.resIndex] = res[1] / res[0];
> /*    */         break;
> /*    */       case RATIO_12:
> /* 41 */         res = this.c.getValue();
> /* 42 */         this.result[this.resIndex] = res[1] / res[2];
> /*    */         break;
> /*    */     } 
> /*    */   } }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/trajectory_classifier/FeatureWorkerModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/trajectory_classifier/RRFClassifierRenjinModified.java jd-gui/trajectory_classifier/RRFClassifierRenjinModified.java
1,170c1,226
< package trajectory_classifier;
< 
< import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
< import features.Asymmetry3FeatureModified;
< import features.EfficiencyFeatureModified;
< import features.FractalDimensionFeatureModified;
< import features.GaussianityFeautureModified;
< import features.KurtosisFeatureModified;
< import features.MSDRatioFeatureModified;
< import features.PowerLawFeatureModified;
< import features.StraightnessFeatureModified;
< import features.TrappedProbabilityFeatureModified;
< import java.util.ArrayList;
< import java.util.Arrays;
< import java.util.concurrent.ExecutorService;
< import java.util.concurrent.Executors;
< import java.util.concurrent.TimeUnit;
< import javax.script.ScriptEngine;
< import javax.script.ScriptEngineManager;
< import javax.script.ScriptException;
< import org.renjin.eval.EvalException;
< import org.renjin.parser.ParseException;
< import org.renjin.sexp.DoubleVector;
< import org.renjin.sexp.StringVector;
< import traJ.TrajectoryModified;
< 
< public class RRFClassifierRenjinModified extends AbstractClassifierModified {
<    ScriptEngine engine = null;
<    private String pathToModel;
<    private double[] confindence;
<    private double timelag;
< 
<    public RRFClassifierRenjinModified(String pathToModel, double timelag) {
<       this.pathToModel = pathToModel;
<       this.timelag = timelag;
<    }
< 
<    public void setTimelag(double timelag) {
<       this.timelag = timelag;
<    }
< 
<    public String classify(TrajectoryModified t) {
<       ArrayList<TrajectoryModified> tracks = new ArrayList();
<       tracks.add(t);
<       return this.classify(tracks)[0];
<    }
< 
<    public void start() {
<       ScriptEngineManager manager = new ScriptEngineManager();
<       this.engine = manager.getEngineByName("Renjin");
< 
<       try {
<          this.engine.eval("library(randomForest)");
<          this.engine.eval("library(plyr)");
<          this.engine.eval("load(\"" + this.pathToModel + "\")");
<       } catch (ScriptException var3) {
<          var3.printStackTrace();
<       }
< 
<       if (this.engine == null) {
<          throw new RuntimeException("Renjin Script Engine not found on the classpath.");
<       }
<    }
< 
<    public void stop() {
<       this.engine = null;
<    }
< 
<    public String[] classify(ArrayList<TrajectoryModified> tracks) {
<       int N = tracks.size();
<       String[] result = new String[N];
<       double[] fd = new double[N];
<       double[] power = new double[N];
<       Arrays.fill(power, -1.0D);
<       double[] asym3 = new double[N];
<       double[] efficiency = new double[N];
<       double[] kurtosis = new double[N];
<       double[] msdratio = new double[N];
<       double[] straightness = new double[N];
<       double[] trappedness = new double[N];
<       double[] gaussianity = new double[N];
<       double[] pwrDCs = new double[N];
<       Arrays.fill(power, -1.0D);
<       int cores = Runtime.getRuntime().availableProcessors();
<       ExecutorService pool = Executors.newFixedThreadPool(cores);
< 
<       for(int i = 0; i < tracks.size(); ++i) {
<          TrajectoryModified t = (TrajectoryModified)tracks.get(i);
<          FractalDimensionFeatureModified fdF = new FractalDimensionFeatureModified(t);
<          pool.submit(new FeatureWorkerModified(fd, i, fdF, FeatureWorkerModified.EVALTYPE.FIRST));
<          double initDC = 0.0D;
<          double initAlpha = 0.0D;
<          if (i - 1 > 0 && power[i - 1] > 0.0D && pwrDCs[i - 1] > 0.0D) {
<             initDC = pwrDCs[i - 1];
<             initAlpha = power[i - 1];
<          } else {
<             RegressionDiffusionCoefficientEstimatorModified regest = new RegressionDiffusionCoefficientEstimatorModified(t, 1.0D / this.timelag, 1, 3);
<             initDC = regest.evaluate()[0];
<             initAlpha = 0.5D;
<          }
< 
<          PowerLawFeatureModified pwf = new PowerLawFeatureModified(t, 1.0D / this.timelag, 1, t.size() / 3, initAlpha, initDC);
<          pool.submit(new FeatureWorkerModified(power, i, pwf, FeatureWorkerModified.EVALTYPE.FIRST));
<          pool.submit(new FeatureWorkerModified(pwrDCs, i, pwf, FeatureWorkerModified.EVALTYPE.SECOND));
<          Asymmetry3FeatureModified asymf3 = new Asymmetry3FeatureModified(t);
<          pool.submit(new FeatureWorkerModified(asym3, i, asymf3, FeatureWorkerModified.EVALTYPE.FIRST));
<          EfficiencyFeatureModified eff = new EfficiencyFeatureModified(t);
<          pool.submit(new FeatureWorkerModified(efficiency, i, eff, FeatureWorkerModified.EVALTYPE.FIRST));
<          KurtosisFeatureModified kurtf = new KurtosisFeatureModified(t);
<          pool.submit(new FeatureWorkerModified(kurtosis, i, kurtf, FeatureWorkerModified.EVALTYPE.FIRST));
<          MSDRatioFeatureModified msdr = new MSDRatioFeatureModified(t, 1, 5);
<          pool.submit(new FeatureWorkerModified(msdratio, i, msdr, FeatureWorkerModified.EVALTYPE.FIRST));
<          StraightnessFeatureModified straight = new StraightnessFeatureModified(t);
<          pool.submit(new FeatureWorkerModified(straightness, i, straight, FeatureWorkerModified.EVALTYPE.FIRST));
<          TrappedProbabilityFeatureModified trappf = new TrappedProbabilityFeatureModified(t);
<          pool.submit(new FeatureWorkerModified(trappedness, i, trappf, FeatureWorkerModified.EVALTYPE.FIRST));
<          GaussianityFeautureModified gaussf = new GaussianityFeautureModified(t, 1);
<          pool.submit(new FeatureWorkerModified(gaussianity, i, gaussf, FeatureWorkerModified.EVALTYPE.FIRST));
<       }
< 
<       pool.shutdown();
< 
<       try {
<          pool.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
<       } catch (InterruptedException var34) {
<          var34.printStackTrace();
<       }
< 
<       try {
<          this.engine.put("fd", fd);
<          this.engine.put("power", power);
<          this.engine.put("asymmetry3", asym3);
<          this.engine.put("efficiency", efficiency);
<          this.engine.put("kurtosis", kurtosis);
<          this.engine.put("msdratio", msdratio);
<          this.engine.put("straightness", straightness);
<          this.engine.put("trappedness", trappedness);
<          this.engine.put("gaussianity", gaussianity);
<          this.engine.eval("data<-data.frame(FD=fd,POWER=power,MSD.R=msdratio,ASYM3=asymmetry3,EFFICENCY=efficiency, KURT=kurtosis,STRAIGHTNESS=straightness,TRAPPED=trappedness,GAUSS=gaussianity)");
<          this.engine.eval("features.predict <- predict(model,data,type=\"prob\")");
<          this.engine.eval("fprob<-features.predict");
<          if (tracks.size() > 1) {
<             this.engine.eval("probs <- as.vector(apply(fprob[1:nrow(fprob),],1,max))");
<             this.engine.eval("indexmax <- as.vector(apply(fprob[1:nrow(fprob),],1,which.max))");
<          } else {
<             this.engine.eval("probs <- max(fprob)");
<             this.engine.eval("indexmax <- which.max(fprob)");
<          }
< 
<          this.engine.eval("mynames <- colnames(fprob)");
<          this.engine.eval("maxclass <- mynames[indexmax]");
<          StringVector res = (StringVector)this.engine.eval("maxclass");
<          result = res.toArray();
<          DoubleVector confi = (DoubleVector)this.engine.eval("probs");
<          this.confindence = confi.toDoubleArray();
<       } catch (ParseException var31) {
<          System.out.println("R script parse error: " + var31.getMessage());
<       } catch (ScriptException var32) {
<          var32.printStackTrace();
<       } catch (EvalException var33) {
<          var33.printStackTrace();
<       }
< 
<       return result;
<    }
< 
<    public double[] getConfindence() {
<       return this.confindence;
<    }
< }
---
> /*     */ package trajectory_classifier;
> /*     */ 
> /*     */ import DiffusionCoefficientEstimator.RegressionDiffusionCoefficientEstimatorModified;
> /*     */ import features.AbstractTrajectoryFeatureModified;
> /*     */ import features.Asymmetry3FeatureModified;
> /*     */ import features.EfficiencyFeatureModified;
> /*     */ import features.FractalDimensionFeatureModified;
> /*     */ import features.GaussianityFeautureModified;
> /*     */ import features.KurtosisFeatureModified;
> /*     */ import features.MSDRatioFeatureModified;
> /*     */ import features.PowerLawFeatureModified;
> /*     */ import features.StraightnessFeatureModified;
> /*     */ import features.TrappedProbabilityFeatureModified;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.Arrays;
> /*     */ import java.util.concurrent.ExecutorService;
> /*     */ import java.util.concurrent.Executors;
> /*     */ import java.util.concurrent.TimeUnit;
> /*     */ import javax.script.ScriptEngine;
> /*     */ import javax.script.ScriptEngineManager;
> /*     */ import javax.script.ScriptException;
> /*     */ import org.renjin.eval.EvalException;
> /*     */ import org.renjin.parser.ParseException;
> /*     */ import org.renjin.sexp.DoubleVector;
> /*     */ import org.renjin.sexp.StringVector;
> /*     */ import traJ.TrajectoryModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class RRFClassifierRenjinModified
> /*     */   extends AbstractClassifierModified
> /*     */ {
> /*  36 */   ScriptEngine engine = null;
> /*     */   private String pathToModel;
> /*     */   private double[] confindence;
> /*     */   private double timelag;
> /*     */   
> /*     */   public RRFClassifierRenjinModified(String pathToModel, double timelag) {
> /*  42 */     this.pathToModel = pathToModel;
> /*  43 */     this.timelag = timelag;
> /*     */   }
> /*     */   
> /*     */   public void setTimelag(double timelag) {
> /*  47 */     this.timelag = timelag;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public String classify(TrajectoryModified t) {
> /*  52 */     ArrayList<TrajectoryModified> tracks = new ArrayList<>();
> /*  53 */     tracks.add(t);
> /*     */     
> /*  55 */     return classify(tracks)[0];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void start() {
> /*  63 */     ScriptEngineManager manager = new ScriptEngineManager();
> /*     */     
> /*  65 */     this.engine = manager.getEngineByName("Renjin");
> /*     */     try {
> /*  67 */       this.engine.eval("library(randomForest)");
> /*  68 */       this.engine.eval("library(plyr)");
> /*  69 */       this.engine.eval("load(\"" + this.pathToModel + "\")");
> /*  70 */     } catch (ScriptException e) {
> /*  71 */       e.printStackTrace();
> /*     */     } 
> /*     */ 
> /*     */     
> /*  75 */     if (this.engine == null) {
> /*  76 */       throw new RuntimeException("Renjin Script Engine not found on the classpath.");
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void stop() {
> /*  83 */     this.engine = null;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String[] classify(ArrayList<TrajectoryModified> tracks) {
> /*  90 */     int N = tracks.size();
> /*     */     
> /*  92 */     String[] result = new String[N];
> /*  93 */     double[] fd = new double[N];
> /*  94 */     double[] power = new double[N];
> /*  95 */     Arrays.fill(power, -1.0D);
> /*  96 */     double[] asym3 = new double[N];
> /*  97 */     double[] efficiency = new double[N];
> /*  98 */     double[] kurtosis = new double[N];
> /*  99 */     double[] msdratio = new double[N];
> /* 100 */     double[] straightness = new double[N];
> /* 101 */     double[] trappedness = new double[N];
> /* 102 */     double[] gaussianity = new double[N];
> /* 103 */     double[] pwrDCs = new double[N];
> /* 104 */     Arrays.fill(power, -1.0D);
> /* 105 */     int cores = Runtime.getRuntime().availableProcessors();
> /* 106 */     ExecutorService pool = Executors.newFixedThreadPool(cores);
> /*     */     
> /* 108 */     for (int i = 0; i < tracks.size(); i++) {
> /* 109 */       TrajectoryModified t = tracks.get(i);
> /*     */       
> /* 111 */       FractalDimensionFeatureModified fdF = new FractalDimensionFeatureModified(t);
> /* 112 */       pool.submit(new FeatureWorkerModified(fd, i, (AbstractTrajectoryFeatureModified)fdF, FeatureWorkerModified.EVALTYPE.FIRST));
> /* 113 */       double initDC = 0.0D;
> /* 114 */       double initAlpha = 0.0D;
> /* 115 */       if (i - 1 > 0 && power[i - 1] > 0.0D && pwrDCs[i - 1] > 0.0D) {
> /* 116 */         initDC = pwrDCs[i - 1];
> /* 117 */         initAlpha = power[i - 1];
> /*     */       } else {
> /*     */         
> /* 120 */         RegressionDiffusionCoefficientEstimatorModified regest = new RegressionDiffusionCoefficientEstimatorModified(
> /* 121 */             t, 1.0D / this.timelag, 1, 3);
> /* 122 */         initDC = regest.evaluate()[0];
> /* 123 */         initAlpha = 0.5D;
> /*     */       } 
> /*     */       
> /* 126 */       PowerLawFeatureModified pwf = new PowerLawFeatureModified(t, 1.0D / this.timelag, 1, t.size() / 3, initAlpha, 
> /* 127 */           initDC);
> /* 128 */       pool.submit(new FeatureWorkerModified(power, i, (AbstractTrajectoryFeatureModified)pwf, FeatureWorkerModified.EVALTYPE.FIRST));
> /* 129 */       pool.submit(new FeatureWorkerModified(pwrDCs, i, (AbstractTrajectoryFeatureModified)pwf, FeatureWorkerModified.EVALTYPE.SECOND));
> /*     */       
> /* 131 */       Asymmetry3FeatureModified asymf3 = new Asymmetry3FeatureModified(t);
> /* 132 */       pool.submit(new FeatureWorkerModified(asym3, i, (AbstractTrajectoryFeatureModified)asymf3, FeatureWorkerModified.EVALTYPE.FIRST));
> /*     */       
> /* 134 */       EfficiencyFeatureModified eff = new EfficiencyFeatureModified(t);
> /* 135 */       pool.submit(new FeatureWorkerModified(efficiency, i, (AbstractTrajectoryFeatureModified)eff, FeatureWorkerModified.EVALTYPE.FIRST));
> /*     */       
> /* 137 */       KurtosisFeatureModified kurtf = new KurtosisFeatureModified(t);
> /* 138 */       pool.submit(new FeatureWorkerModified(kurtosis, i, (AbstractTrajectoryFeatureModified)kurtf, FeatureWorkerModified.EVALTYPE.FIRST));
> /*     */       
> /* 140 */       MSDRatioFeatureModified msdr = new MSDRatioFeatureModified(t, 1, 5);
> /* 141 */       pool.submit(new FeatureWorkerModified(msdratio, i, (AbstractTrajectoryFeatureModified)msdr, FeatureWorkerModified.EVALTYPE.FIRST));
> /*     */       
> /* 143 */       StraightnessFeatureModified straight = new StraightnessFeatureModified(t);
> /* 144 */       pool.submit(new FeatureWorkerModified(straightness, i, (AbstractTrajectoryFeatureModified)straight, FeatureWorkerModified.EVALTYPE.FIRST));
> /*     */       
> /* 146 */       TrappedProbabilityFeatureModified trappf = new TrappedProbabilityFeatureModified(t);
> /* 147 */       pool.submit(new FeatureWorkerModified(trappedness, i, (AbstractTrajectoryFeatureModified)trappf, FeatureWorkerModified.EVALTYPE.FIRST));
> /*     */       
> /* 149 */       GaussianityFeautureModified gaussf = new GaussianityFeautureModified(t, 1);
> /* 150 */       pool.submit(new FeatureWorkerModified(gaussianity, i, (AbstractTrajectoryFeatureModified)gaussf, FeatureWorkerModified.EVALTYPE.FIRST));
> /*     */     } 
> /*     */     
> /* 153 */     pool.shutdown();
> /*     */     
> /*     */     try {
> /* 156 */       pool.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
> /* 157 */     } catch (InterruptedException e) {
> /* 158 */       e.printStackTrace();
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*     */     try {
> /* 173 */       this.engine.put("fd", fd);
> /* 174 */       this.engine.put("power", power);
> /* 175 */       this.engine.put("asymmetry3", asym3);
> /* 176 */       this.engine.put("efficiency", efficiency);
> /* 177 */       this.engine.put("kurtosis", kurtosis);
> /* 178 */       this.engine.put("msdratio", msdratio);
> /* 179 */       this.engine.put("straightness", straightness);
> /* 180 */       this.engine.put("trappedness", trappedness);
> /* 181 */       this.engine.put("gaussianity", gaussianity);
> /*     */       
> /* 183 */       this.engine.eval("data<-data.frame(FD=fd,POWER=power,MSD.R=msdratio,ASYM3=asymmetry3,EFFICENCY=efficiency, KURT=kurtosis,STRAIGHTNESS=straightness,TRAPPED=trappedness,GAUSS=gaussianity)");
> /*     */ 
> /*     */ 
> /*     */       
> /* 187 */       this.engine.eval("features.predict <- predict(model,data,type=\"prob\")");
> /* 188 */       this.engine.eval("fprob<-features.predict");
> /*     */       
> /* 190 */       if (tracks.size() > 1) {
> /* 191 */         this.engine.eval("probs <- as.vector(apply(fprob[1:nrow(fprob),],1,max))");
> /* 192 */         this.engine.eval("indexmax <- as.vector(apply(fprob[1:nrow(fprob),],1,which.max))");
> /*     */       } else {
> /* 194 */         this.engine.eval("probs <- max(fprob)");
> /* 195 */         this.engine.eval("indexmax <- which.max(fprob)");
> /*     */       } 
> /* 197 */       this.engine.eval("mynames <- colnames(fprob)");
> /* 198 */       this.engine.eval("maxclass <- mynames[indexmax]");
> /* 199 */       StringVector res = (StringVector)this.engine.eval("maxclass");
> /* 200 */       result = res.toArray();
> /* 201 */       DoubleVector confi = (DoubleVector)this.engine.eval("probs");
> /* 202 */       this.confindence = confi.toDoubleArray();
> /* 203 */     } catch (ParseException e) {
> /* 204 */       System.out.println("R script parse error: " + e.getMessage());
> /* 205 */     } catch (ScriptException e) {
> /*     */       
> /* 207 */       e.printStackTrace();
> /* 208 */     } catch (EvalException e) {
> /* 209 */       e.printStackTrace();
> /*     */     } 
> /*     */     
> /* 212 */     return result;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] getConfindence() {
> /* 218 */     return this.confindence;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/trajectory_classifier/RRFClassifierRenjinModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/trajectory_classifier/SubtrajectoryModified.java jd-gui/trajectory_classifier/SubtrajectoryModified.java
1,47c1,56
< package trajectory_classifier;
< 
< import java.util.ArrayList;
< import java.util.Iterator;
< import traJ.TrajectoryModified;
< 
< public class SubtrajectoryModified extends TrajectoryModified {
<    private static final long serialVersionUID = 3846588503781023924L;
<    private TrajectoryModified parent;
<    private double confidence;
< 
<    public SubtrajectoryModified(TrajectoryModified parent, int dimension) {
<       super(dimension);
<       this.parent = parent;
<    }
< 
<    public SubtrajectoryModified(TrajectoryModified parent, int dimension, int relativeStartPoint) {
<       super(dimension, relativeStartPoint);
<       this.parent = parent;
<    }
< 
<    public TrajectoryModified getParent() {
<       return this.parent;
<    }
< 
<    public static ArrayList<SubtrajectoryModified> getTracksWithSameParant(ArrayList<SubtrajectoryModified> tracks, long parentid) {
<       ArrayList<SubtrajectoryModified> res = new ArrayList();
<       Iterator var5 = tracks.iterator();
< 
<       while(var5.hasNext()) {
<          SubtrajectoryModified sub = (SubtrajectoryModified)var5.next();
<          if (sub.getParent().getID() == parentid) {
<             res.add(sub);
<          }
<       }
< 
<       return res;
<    }
< 
<    public void setConfidence(double confidence) {
<       this.confidence = confidence;
<    }
< 
<    public double getConfidence() {
<       return this.confidence;
<    }
< }
---
> /*    */ package trajectory_classifier;
> /*    */ 
> /*    */ import java.util.ArrayList;
> /*    */ import traJ.TrajectoryModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class SubtrajectoryModified
> /*    */   extends TrajectoryModified
> /*    */ {
> /*    */   private static final long serialVersionUID = 3846588503781023924L;
> /*    */   private TrajectoryModified parent;
> /*    */   private double confidence;
> /*    */   
> /*    */   public SubtrajectoryModified(TrajectoryModified parent, int dimension) {
> /* 18 */     super(dimension);
> /* 19 */     this.parent = parent;
> /*    */   }
> /*    */   
> /*    */   public SubtrajectoryModified(TrajectoryModified parent, int dimension, int relativeStartPoint) {
> /* 23 */     super(dimension, relativeStartPoint);
> /* 24 */     this.parent = parent;
> /*    */   }
> /*    */   
> /*    */   public TrajectoryModified getParent() {
> /* 28 */     return this.parent;
> /*    */   }
> /*    */   
> /*    */   public static ArrayList<SubtrajectoryModified> getTracksWithSameParant(ArrayList<SubtrajectoryModified> tracks, long parentid) {
> /* 32 */     ArrayList<SubtrajectoryModified> res = new ArrayList<>();
> /*    */     
> /* 34 */     for (SubtrajectoryModified sub : tracks) {
> /* 35 */       if (sub.getParent().getID() == parentid) {
> /* 36 */         res.add(sub);
> /*    */       }
> /*    */     } 
> /*    */     
> /* 40 */     return res;
> /*    */   }
> /*    */   
> /*    */   public void setConfidence(double confidence) {
> /* 44 */     this.confidence = confidence;
> /*    */   }
> /*    */   
> /*    */   public double getConfidence() {
> /* 48 */     return this.confidence;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/trajectory_classifier/SubtrajectoryModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/trajectory_classifier/VisualizationUtilsModified.java jd-gui/trajectory_classifier/VisualizationUtilsModified.java
1,49c1,66
< package trajectory_classifier;
< 
< import ij.gui.PolygonRoi;
< import ij.gui.Roi;
< import ij.gui.TextRoi;
< import ij.process.FloatPolygon;
< import java.awt.Color;
< import java.util.ArrayList;
< import vecmath.Point3dModified;
< 
< public class VisualizationUtilsModified {
<    public static ArrayList<Roi> generateVisualizationRoisFromTrack(SubtrajectoryModified t, Color c, boolean showID) {
<       return generateVisualizationRoisFromTrack(t, c, showID, 1.0D);
<    }
< 
<    public static ArrayList<Roi> generateVisualizationRoisFromTrack(SubtrajectoryModified t, Color c, boolean showID, double pixelsize) {
<       ArrayList<Roi> proi = new ArrayList();
<       FloatPolygon p = new FloatPolygon();
<       double sumx = 0.0D;
<       double sumy = 0.0D;
<       TextRoi.setFont("TimesRoman", 5, 0);
< 
<       for(int i = 0; i < t.getParent().size(); ++i) {
<          int to = t.size();
<          if (i < t.size()) {
<             sumx += ((Point3dModified)t.get(i)).x / pixelsize;
<             sumy += ((Point3dModified)t.get(i)).y / pixelsize;
<             p.addPoint(((Point3dModified)t.get(i)).x / pixelsize, ((Point3dModified)t.get(i)).y / pixelsize);
<             to = i + 1;
<          }
< 
<          PolygonRoi pr = new PolygonRoi(new FloatPolygon(p.xpoints, p.ypoints, to), 6);
<          pr.setStrokeColor(c);
<          pr.setPosition(t.getRelativeStartTimepoint() + i + 1);
<          proi.add(pr);
<          if (showID) {
<             long parentID = t.getParent().getID();
<             TextRoi troi = new TextRoi(sumx / (double)to, sumy / (double)to, " " + parentID + ":" + t.getID() + " ");
<             troi.setPosition(t.getRelativeStartTimepoint() + i + 1);
<             troi.setFillColor(Color.BLACK);
<             troi.setStrokeColor(c);
<             troi.setAntialiased(true);
<             proi.add(troi);
<          }
<       }
< 
<       return proi;
<    }
< }
---
> /*    */ package trajectory_classifier;
> /*    */ 
> /*    */ import ij.gui.PolygonRoi;
> /*    */ import ij.gui.Roi;
> /*    */ import ij.gui.TextRoi;
> /*    */ import ij.process.FloatPolygon;
> /*    */ import java.awt.Color;
> /*    */ import java.util.ArrayList;
> /*    */ import vecmath.Point3dModified;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class VisualizationUtilsModified
> /*    */ {
> /*    */   public static ArrayList<Roi> generateVisualizationRoisFromTrack(SubtrajectoryModified t, Color c, boolean showID) {
> /* 21 */     return generateVisualizationRoisFromTrack(t, c, showID, 1.0D);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public static ArrayList<Roi> generateVisualizationRoisFromTrack(SubtrajectoryModified t, Color c, boolean showID, double pixelsize) {
> /* 27 */     ArrayList<Roi> proi = new ArrayList<>();
> /* 28 */     FloatPolygon p = new FloatPolygon();
> /* 29 */     double sumx = 0.0D;
> /* 30 */     double sumy = 0.0D;
> /* 31 */     TextRoi.setFont("TimesRoman", 5, 0);
> /* 32 */     for (int i = 0; i < t.getParent().size(); i++) {
> /* 33 */       int to = t.size();
> /* 34 */       if (i < t.size()) {
> /*    */         
> /* 36 */         sumx += ((Point3dModified)t.get(i)).x / pixelsize;
> /* 37 */         sumy += ((Point3dModified)t.get(i)).y / pixelsize;
> /* 38 */         p.addPoint(((Point3dModified)t.get(i)).x / pixelsize, ((Point3dModified)t.get(i)).y / pixelsize);
> /*    */         
> /* 40 */         to = i + 1;
> /*    */       } 
> /*    */       
> /* 43 */       PolygonRoi pr = new PolygonRoi(new FloatPolygon(p.xpoints, p.ypoints, to), 6);
> /* 44 */       pr.setStrokeColor(c);
> /* 45 */       pr.setPosition(t.getRelativeStartTimepoint() + i + 1);
> /* 46 */       proi.add(pr);
> /*    */       
> /* 48 */       if (showID) {
> /* 49 */         long parentID = t.getParent().getID();
> /* 50 */         TextRoi troi = new TextRoi(sumx / to, sumy / to, " " + parentID + ":" + t.getID() + " ");
> /* 51 */         troi.setPosition(t.getRelativeStartTimepoint() + i + 1);
> /* 52 */         troi.setFillColor(Color.BLACK);
> /* 53 */         troi.setStrokeColor(c);
> /* 54 */         troi.setAntialiased(true);
> /* 55 */         proi.add(troi);
> /*    */       } 
> /*    */     } 
> /* 58 */     return proi;
> /*    */   }
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/trajectory_classifier/VisualizationUtilsModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/trajectory_classifier/WeightedWindowedClassificationProcessModified.java jd-gui/trajectory_classifier/WeightedWindowedClassificationProcessModified.java
1,144c1,185
< package trajectory_classifier;
< 
< import ij.IJ;
< import java.util.ArrayList;
< import java.util.Arrays;
< import java.util.HashMap;
< import java.util.HashSet;
< import java.util.Iterator;
< import traJ.TrajectoryModified;
< import traJ.TrajectoryUtilModified;
< 
< public class WeightedWindowedClassificationProcessModified {
<    private double[] posConfidence = null;
<    private double numberOmittedSegments = 0.0D;
< 
<    public String[] windowedClassification(TrajectoryModified t, AbstractClassifierModified c, int n, int rate) {
<       int windowsize = 2 * n + 1;
<       int increment = 1;
<       ArrayList<TrajectoryModified> tracks = new ArrayList();
< 
<       for(int i = 0; i < t.size() - windowsize + increment; i += increment) {
<          TrajectoryModified sub = t.subList(i, i + windowsize - 1);
<          if (rate > 1) {
<             sub = TrajectoryUtilModified.resample(sub, rate);
<          }
< 
<          tracks.add(sub);
<       }
< 
<       String[] res = c.classify(tracks);
<       double[] confidence = c.getConfindence();
< 
<       for(int i = 0; i < res.length; ++i) {
<          if (res[i] == null) {
<             return null;
<          }
<       }
< 
<       String[] types = this.applyWeightening(res, confidence, n, t.size());
<       return types;
<    }
< 
<    public double[] getPositionConfidence() {
<       return this.posConfidence;
<    }
< 
<    protected String[] applyWeightening(String[] res, double[] confidence, int n, int tracklength) {
<       String[] types = new String[tracklength];
<       this.posConfidence = new double[tracklength];
<       ArrayList<String> restypes = new ArrayList();
< 
<       for(int i = 0; i < res.length; ++i) {
<          restypes.add(res[i]);
<       }
< 
<       HashSet<String> uniqueTypes = new HashSet();
<       uniqueTypes.addAll(restypes);
<       HashMap<String, Integer> mapTypeToInt = new HashMap();
<       HashMap<Integer, String> mapIntToType = new HashMap();
<       Iterator<String> it = uniqueTypes.iterator();
< 
<       int key;
<       for(key = 0; it.hasNext(); ++key) {
<          String type = (String)it.next();
<          mapTypeToInt.put(type, key);
<          mapIntToType.put(key, type);
<       }
< 
<       ArrayList<Double[]> weightes = new ArrayList();
<       ArrayList<Integer[]> Nvotes = new ArrayList();
< 
<       int i;
<       for(i = 0; i < tracklength; ++i) {
<          Double[] h = new Double[key];
<          Arrays.fill(h, new Double(0.0D));
<          weightes.add(h);
<          Integer[] h1 = new Integer[key];
<          Arrays.fill(h1, new Integer(0));
<          Nvotes.add(h1);
<       }
< 
<       int mode1;
<       for(i = 0; i < res.length; ++i) {
<          for(int j = i; j < i + 2 * n + 1; ++j) {
<             mode1 = (Integer)mapTypeToInt.get(res[i]);
< 
<             try {
<                ((Double[])weightes.get(j))[mode1] = ((Double[])weightes.get(j))[mode1] + confidence[i];
<                ((Integer[])Nvotes.get(j))[mode1] = ((Integer[])Nvotes.get(j))[mode1] + 1;
<             } catch (Exception var22) {
<                IJ.log("Res: " + res[i] + " j: " + j + " i: " + i + " weigthes size " + weightes.size());
<             }
<          }
<       }
< 
<       for(i = 0; i < types.length; ++i) {
<          if (((Double[])weightes.get(i)).length > 0) {
<             double[] result = this.getHighest((Double[])weightes.get(i));
<             mode1 = (int)result[0];
<             double maxv = result[1];
<             double wConf = maxv / (double)((Integer[])Nvotes.get(i))[mode1];
<             String mode = (String)mapIntToType.get(mode1);
<             types[i] = mode;
<             this.posConfidence[i] = wConf;
<          }
<       }
< 
<       return types;
<    }
< 
<    private double[] getHighest(Double[] weightes) {
<       double max = 0.0D;
<       int maxindex = 0;
< 
<       for(int i = 0; i < weightes.length; ++i) {
<          if (weightes[i] > max) {
<             max = weightes[i];
<             maxindex = i;
<          }
<       }
< 
<       return new double[]{(double)maxindex, max};
<    }
< 
<    public double[] arrListToArray(ArrayList<Integer> l) {
<       double[] a = new double[l.size()];
< 
<       for(int i = 0; i < l.size(); ++i) {
<          a[i] = (double)(Integer)l.get(i);
<       }
< 
<       return a;
<    }
< 
<    public int[] arrListToArrayInt(ArrayList<Integer> l) {
<       int[] a = new int[l.size()];
< 
<       for(int i = 0; i < l.size(); ++i) {
<          a[i] = (Integer)l.get(i);
<       }
< 
<       return a;
<    }
< }
---
> /*     */ package trajectory_classifier;
> /*     */ 
> /*     */ import ij.IJ;
> /*     */ import java.util.ArrayList;
> /*     */ import java.util.Arrays;
> /*     */ import java.util.HashMap;
> /*     */ import java.util.HashSet;
> /*     */ import java.util.Iterator;
> /*     */ import traJ.TrajectoryModified;
> /*     */ import traJ.TrajectoryUtilModified;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class WeightedWindowedClassificationProcessModified
> /*     */ {
> /*  35 */   private double[] posConfidence = null;
> /*  36 */   private double numberOmittedSegments = 0.0D;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String[] windowedClassification(TrajectoryModified t, AbstractClassifierModified c, int n, int rate) {
> /*  46 */     int windowsize = 2 * n + 1;
> /*     */     
> /*  48 */     int increment = 1;
> /*  49 */     ArrayList<TrajectoryModified> tracks = new ArrayList<>();
> /*  50 */     for (int i = 0; i < t.size() - windowsize + increment; i += increment) {
> /*  51 */       TrajectoryModified sub = t.subList(i, i + windowsize - 1);
> /*  52 */       if (rate > 1) {
> /*  53 */         sub = TrajectoryUtilModified.resample(sub, rate);
> /*     */       }
> /*  55 */       tracks.add(sub);
> /*     */     } 
> /*  57 */     String[] res = c.classify(tracks);
> /*  58 */     double[] confidence = c.getConfindence();
> /*  59 */     for (int j = 0; j < res.length; j++) {
> /*  60 */       if (res[j] == null) {
> /*  61 */         return null;
> /*     */       }
> /*     */     } 
> /*     */     
> /*  65 */     String[] types = applyWeightening(res, confidence, n, t.size());
> /*  66 */     return types;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   public double[] getPositionConfidence() {
> /*  71 */     return this.posConfidence;
> /*     */   }
> /*     */ 
> /*     */   
> /*     */   protected String[] applyWeightening(String[] res, double[] confidence, int n, int tracklength) {
> /*  76 */     String[] types = new String[tracklength];
> /*  77 */     this.posConfidence = new double[tracklength];
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /*  84 */     ArrayList<String> restypes = new ArrayList<>();
> /*  85 */     for (int i = 0; i < res.length; i++) {
> /*  86 */       restypes.add(res[i]);
> /*     */     }
> /*     */     
> /*  89 */     HashSet<String> uniqueTypes = new HashSet<>();
> /*  90 */     uniqueTypes.addAll(restypes);
> /*  91 */     HashMap<String, Integer> mapTypeToInt = new HashMap<>();
> /*  92 */     HashMap<Integer, String> mapIntToType = new HashMap<>();
> /*  93 */     Iterator<String> it = uniqueTypes.iterator();
> /*  94 */     int key = 0;
> /*  95 */     while (it.hasNext()) {
> /*  96 */       String type = it.next();
> /*  97 */       mapTypeToInt.put(type, Integer.valueOf(key));
> /*  98 */       mapIntToType.put(Integer.valueOf(key), type);
> /*  99 */       key++;
> /*     */     } 
> /*     */     
> /* 102 */     ArrayList<Double[]> weightes = (ArrayList)new ArrayList<>();
> /* 103 */     ArrayList<Integer[]> Nvotes = (ArrayList)new ArrayList<>(); int j;
> /* 104 */     for (j = 0; j < tracklength; j++) {
> /* 105 */       Double[] h = new Double[key];
> /* 106 */       Arrays.fill((Object[])h, new Double(0.0D));
> /* 107 */       weightes.add(h);
> /*     */       
> /* 109 */       Integer[] h1 = new Integer[key];
> /* 110 */       Arrays.fill((Object[])h1, new Integer(0));
> /* 111 */       Nvotes.add(h1);
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */     
> /* 116 */     for (j = 0; j < res.length; j++) {
> /* 117 */       for (int k = j; k < j + 2 * n + 1; k++) {
> /* 118 */         int typ = ((Integer)mapTypeToInt.get(res[j])).intValue();
> /*     */         
> /*     */         try {
> /* 121 */           ((Double[])weightes.get(k))[typ] = Double.valueOf(((Double[])weightes.get(k))[typ].doubleValue() + confidence[j]);
> /* 122 */           ((Integer[])Nvotes.get(k))[typ] = Integer.valueOf(((Integer[])Nvotes.get(k))[typ].intValue() + 1);
> /*     */         }
> /* 124 */         catch (Exception e) {
> /*     */           
> /* 126 */           IJ.log("Res: " + res[j] + " j: " + k + " i: " + j + " weigthes size " + weightes.size());
> /*     */         } 
> /*     */       } 
> /*     */     } 
> /*     */     
> /* 131 */     for (j = 0; j < types.length; j++) {
> /* 132 */       if (((Double[])weightes.get(j)).length > 0) {
> /* 133 */         double[] result = getHighest(weightes.get(j));
> /* 134 */         int mode1 = (int)result[0];
> /* 135 */         double maxv = result[1];
> /* 136 */         double wConf = maxv / ((Integer[])Nvotes.get(j))[mode1].intValue();
> /* 137 */         String mode = mapIntToType.get(Integer.valueOf(mode1));
> /* 138 */         types[j] = mode;
> /* 139 */         this.posConfidence[j] = wConf;
> /*     */       } 
> /*     */     } 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */     
> /* 147 */     return types;
> /*     */   }
> /*     */   
> /*     */   private double[] getHighest(Double[] weightes) {
> /* 151 */     double max = 0.0D;
> /* 152 */     int maxindex = 0;
> /* 153 */     for (int i = 0; i < weightes.length; i++) {
> /* 154 */       if (weightes[i].doubleValue() > max) {
> /* 155 */         max = weightes[i].doubleValue();
> /* 156 */         maxindex = i;
> /*     */       } 
> /*     */     } 
> /* 159 */     return new double[] { maxindex, max };
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double[] arrListToArray(ArrayList<Integer> l) {
> /* 165 */     double[] a = new double[l.size()];
> /* 166 */     for (int i = 0; i < l.size(); i++) {
> /* 167 */       a[i] = ((Integer)l.get(i)).intValue();
> /*     */     }
> /* 169 */     return a;
> /*     */   }
> /*     */   
> /*     */   public int[] arrListToArrayInt(ArrayList<Integer> l) {
> /* 173 */     int[] a = new int[l.size()];
> /* 174 */     for (int i = 0; i < l.size(); i++) {
> /* 175 */       a[i] = ((Integer)l.get(i)).intValue();
> /*     */     }
> /* 177 */     return a;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/trajectory_classifier/WeightedWindowedClassificationProcessModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
Only in jd-gui: traJParametersWindow$1.java
diff -r TrackAnalyzer_/traJParametersWindow.java jd-gui/traJParametersWindow.java
1,8c1,73
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import javax.swing.BoxLayout;
< import javax.swing.JButton;
< import javax.swing.JFrame;
< import javax.swing.JLabel;
< import javax.swing.JPanel;
< import javax.swing.JTextField;
---
> /*    */ import java.awt.event.ActionEvent;
> /*    */ import java.awt.event.ActionListener;
> /*    */ import javax.swing.BoxLayout;
> /*    */ import javax.swing.JButton;
> /*    */ import javax.swing.JFrame;
> /*    */ import javax.swing.JLabel;
> /*    */ import javax.swing.JPanel;
> /*    */ import javax.swing.JTextField;
> /*    */ 
> /*    */ public class traJParametersWindow
> /*    */ {
> /*    */   static JButton okButton;
> /*    */   static String minLengthTextS;
> /*    */   static String windowTextS;
> /*    */   static String minSegTextS;
> /*    */   static String keyWord;
> /*    */   static JFrame frame;
> /*    */   static JTextField minLengthText;
> /*    */   static JTextField windowText;
> /*    */   static JTextField minSegText;
> /*    */   
> /*    */   public void run(String args) {
> /* 23 */     frame = new JFrame("TraJ Classifier Parameters");
> /* 24 */     frame.setSize(200, 200);
> /* 25 */     frame.setDefaultCloseOperation(2);
> /*    */     
> /* 27 */     JPanel panel = new JPanel();
> /* 28 */     frame.add(panel);
> /* 29 */     placeComponents(panel);
> /*    */     
> /* 31 */     frame.setVisible(true);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   private static void placeComponents(JPanel panel) {
> /* 37 */     panel.setLayout(new BoxLayout(panel, 1));
> /*    */     
> /* 39 */     JLabel minLengthLabel = new JLabel("Min. Tracklength: ");
> /* 40 */     panel.add(minLengthLabel);
> /*    */     
> /* 42 */     minLengthText = new JTextField("10", 5);
> /* 43 */     minLengthText.setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_MIN_TRACK, ""));
> /* 44 */     panel.add(minLengthText);
> /*    */     
> /* 46 */     JLabel windowLabel = new JLabel("Windowsize (SPOT positions): ");
> /* 47 */     panel.add(windowLabel);
> /*    */     
> /* 49 */     windowText = new JTextField("5", 5);
> /* 50 */     windowText.setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_WINDOW, ""));
> /* 51 */     panel.add(windowText);
> /*    */     
> /* 53 */     JLabel minSegLabel = new JLabel("Min.Segment Length: ");
> /* 54 */     panel.add(minSegLabel);
> /*    */     
> /* 56 */     minSegText = new JTextField("5", 5);
> /* 57 */     minSegText.setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_MIN_SEGMENT, ""));
> /* 58 */     panel.add(minSegText);
> /*    */     
> /* 60 */     okButton = new JButton("OK");
> /* 61 */     okButton.setBounds(10, 80, 80, 25);
> /* 62 */     panel.add(okButton);
> /* 63 */     okButton.addActionListener(new ActionListener() {
> /*    */           public void actionPerformed(ActionEvent event) {
> /* 65 */             traJParametersWindow.keyWord = "keyword";
> /* 66 */             traJParametersWindow.minLengthTextS = traJParametersWindow.minLengthText.getText();
> /* 67 */             traJParametersWindow.windowTextS = traJParametersWindow.windowText.getText();
> /* 68 */             traJParametersWindow.minSegTextS = traJParametersWindow.minSegText.getText();
> /* 69 */             traJParametersWindow.frame.setVisible(false);
> /*    */           }
> /*    */         });
> /*    */   }
> /*    */ }
10,19d74
< public class traJParametersWindow {
<    static JButton okButton;
<    static String minLengthTextS;
<    static String windowTextS;
<    static String minSegTextS;
<    static String keyWord;
<    static JFrame frame;
<    static JTextField minLengthText;
<    static JTextField windowText;
<    static JTextField minSegText;
21,61c76,79
<    public void run(String args) {
<       frame = new JFrame("TraJ Classifier Parameters");
<       frame.setSize(200, 200);
<       frame.setDefaultCloseOperation(2);
<       JPanel panel = new JPanel();
<       frame.add(panel);
<       placeComponents(panel);
<       frame.setVisible(true);
<    }
< 
<    private static void placeComponents(JPanel panel) {
<       panel.setLayout(new BoxLayout(panel, 1));
<       JLabel minLengthLabel = new JLabel("Min. Tracklength: ");
<       panel.add(minLengthLabel);
<       minLengthText = new JTextField("10", 5);
<       minLengthText.setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_MIN_TRACK, ""));
<       panel.add(minLengthText);
<       JLabel windowLabel = new JLabel("Windowsize (SPOT positions): ");
<       panel.add(windowLabel);
<       windowText = new JTextField("5", 5);
<       windowText.setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_WINDOW, ""));
<       panel.add(windowText);
<       JLabel minSegLabel = new JLabel("Min.Segment Length: ");
<       panel.add(minSegLabel);
<       minSegText = new JTextField("5", 5);
<       minSegText.setText(SPTBatch_.pref1.get(SPTBatch_.TRACKMATE_MIN_SEGMENT, ""));
<       panel.add(minSegText);
<       okButton = new JButton("OK");
<       okButton.setBounds(10, 80, 80, 25);
<       panel.add(okButton);
<       okButton.addActionListener(new ActionListener() {
<          public void actionPerformed(ActionEvent event) {
<             traJParametersWindow.keyWord = "keyword";
<             traJParametersWindow.minLengthTextS = traJParametersWindow.minLengthText.getText();
<             traJParametersWindow.windowTextS = traJParametersWindow.windowText.getText();
<             traJParametersWindow.minSegTextS = traJParametersWindow.minSegText.getText();
<             traJParametersWindow.frame.setVisible(false);
<          }
<       });
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/traJParametersWindow.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Color3b.java jd-gui/vecmath/Color3b.java
1,44c1,154
< package vecmath;
< 
< import java.awt.Color;
< import java.io.Serializable;
< 
< public class Color3b extends Tuple3b implements Serializable {
<    static final long serialVersionUID = 6632576088353444794L;
< 
<    public Color3b(byte c1, byte c2, byte c3) {
<       super(c1, c2, c3);
<    }
< 
<    public Color3b(byte[] c) {
<       super(c);
<    }
< 
<    public Color3b(Color3b c1) {
<       super((Tuple3b)c1);
<    }
< 
<    public Color3b(Tuple3b t1) {
<       super(t1);
<    }
< 
<    public Color3b(Color color) {
<       super((byte)color.getRed(), (byte)color.getGreen(), (byte)color.getBlue());
<    }
< 
<    public Color3b() {
<    }
< 
<    public final void set(Color color) {
<       this.x = (byte)color.getRed();
<       this.y = (byte)color.getGreen();
<       this.z = (byte)color.getBlue();
<    }
< 
<    public final Color get() {
<       int r = this.x & 255;
<       int g = this.y & 255;
<       int b = this.z & 255;
<       return new Color(r, g, b);
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.awt.Color;
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Color3b
> /*     */   extends Tuple3b
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = 6632576088353444794L;
> /*     */   
> /*     */   public Color3b(byte c1, byte c2, byte c3) {
> /*  59 */     super(c1, c2, c3);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color3b(byte[] c) {
> /*  68 */     super(c);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color3b(Color3b c1) {
> /*  77 */     super(c1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color3b(Tuple3b t1) {
> /*  86 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color3b(Color color) {
> /* 104 */     super((byte)color.getRed(), (byte)color.getGreen(), (byte)color.getBlue());
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color3b() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Color color) {
> /* 127 */     this.x = (byte)color.getRed();
> /* 128 */     this.y = (byte)color.getGreen();
> /* 129 */     this.z = (byte)color.getBlue();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final Color get() {
> /* 142 */     int r = this.x & 0xFF;
> /* 143 */     int g = this.y & 0xFF;
> /* 144 */     int b = this.z & 0xFF;
> /*     */     
> /* 146 */     return new Color(r, g, b);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Color3b.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Color3f.java jd-gui/vecmath/Color3f.java
1,48c1,158
< package vecmath;
< 
< import java.awt.Color;
< import java.io.Serializable;
< 
< public class Color3f extends Tuple3f implements Serializable {
<    static final long serialVersionUID = -1861792981817493659L;
< 
<    public Color3f(float x, float y, float z) {
<       super(x, y, z);
<    }
< 
<    public Color3f(float[] v) {
<       super(v);
<    }
< 
<    public Color3f(Color3f v1) {
<       super((Tuple3f)v1);
<    }
< 
<    public Color3f(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public Color3f(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public Color3f(Color color) {
<       super((float)color.getRed() / 255.0F, (float)color.getGreen() / 255.0F, (float)color.getBlue() / 255.0F);
<    }
< 
<    public Color3f() {
<    }
< 
<    public final void set(Color color) {
<       this.x = (float)color.getRed() / 255.0F;
<       this.y = (float)color.getGreen() / 255.0F;
<       this.z = (float)color.getBlue() / 255.0F;
<    }
< 
<    public final Color get() {
<       int r = Math.round(this.x * 255.0F);
<       int g = Math.round(this.y * 255.0F);
<       int b = Math.round(this.z * 255.0F);
<       return new Color(r, g, b);
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.awt.Color;
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Color3f
> /*     */   extends Tuple3f
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = -1861792981817493659L;
> /*     */   
> /*     */   public Color3f(float x, float y, float z) {
> /*  54 */     super(x, y, z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color3f(float[] v) {
> /*  63 */     super(v);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color3f(Color3f v1) {
> /*  72 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color3f(Tuple3f t1) {
> /*  81 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color3f(Tuple3dModified t1) {
> /*  90 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color3f(Color color) {
> /* 108 */     super(color.getRed() / 255.0F, color.getGreen() / 255.0F, color.getBlue() / 255.0F);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color3f() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Color color) {
> /* 131 */     this.x = color.getRed() / 255.0F;
> /* 132 */     this.y = color.getGreen() / 255.0F;
> /* 133 */     this.z = color.getBlue() / 255.0F;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final Color get() {
> /* 146 */     int r = Math.round(this.x * 255.0F);
> /* 147 */     int g = Math.round(this.y * 255.0F);
> /* 148 */     int b = Math.round(this.z * 255.0F);
> /*     */     
> /* 150 */     return new Color(r, g, b);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Color3f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Color4b.java jd-gui/vecmath/Color4b.java
1,46c1,160
< package vecmath;
< 
< import java.awt.Color;
< import java.io.Serializable;
< 
< public class Color4b extends Tuple4b implements Serializable {
<    static final long serialVersionUID = -105080578052502155L;
< 
<    public Color4b(byte b1, byte b2, byte b3, byte b4) {
<       super(b1, b2, b3, b4);
<    }
< 
<    public Color4b(byte[] c) {
<       super(c);
<    }
< 
<    public Color4b(Color4b c1) {
<       super((Tuple4b)c1);
<    }
< 
<    public Color4b(Tuple4b t1) {
<       super(t1);
<    }
< 
<    public Color4b(Color color) {
<       super((byte)color.getRed(), (byte)color.getGreen(), (byte)color.getBlue(), (byte)color.getAlpha());
<    }
< 
<    public Color4b() {
<    }
< 
<    public final void set(Color color) {
<       this.x = (byte)color.getRed();
<       this.y = (byte)color.getGreen();
<       this.z = (byte)color.getBlue();
<       this.w = (byte)color.getAlpha();
<    }
< 
<    public final Color get() {
<       int r = this.x & 255;
<       int g = this.y & 255;
<       int b = this.z & 255;
<       int a = this.w & 255;
<       return new Color(r, g, b, a);
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.awt.Color;
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Color4b
> /*     */   extends Tuple4b
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = -105080578052502155L;
> /*     */   
> /*     */   public Color4b(byte b1, byte b2, byte b3, byte b4) {
> /*  60 */     super(b1, b2, b3, b4);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color4b(byte[] c) {
> /*  69 */     super(c);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color4b(Color4b c1) {
> /*  79 */     super(c1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color4b(Tuple4b t1) {
> /*  89 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color4b(Color color) {
> /* 108 */     super((byte)color.getRed(), (byte)color.getGreen(), (byte)color.getBlue(), (byte)color.getAlpha());
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color4b() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Color color) {
> /* 131 */     this.x = (byte)color.getRed();
> /* 132 */     this.y = (byte)color.getGreen();
> /* 133 */     this.z = (byte)color.getBlue();
> /* 134 */     this.w = (byte)color.getAlpha();
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final Color get() {
> /* 147 */     int r = this.x & 0xFF;
> /* 148 */     int g = this.y & 0xFF;
> /* 149 */     int b = this.z & 0xFF;
> /* 150 */     int a = this.w & 0xFF;
> /*     */     
> /* 152 */     return new Color(r, g, b, a);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Color4b.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Color4f.java jd-gui/vecmath/Color4f.java
1,50c1,163
< package vecmath;
< 
< import java.awt.Color;
< import java.io.Serializable;
< 
< public class Color4f extends Tuple4f implements Serializable {
<    static final long serialVersionUID = 8577680141580006740L;
< 
<    public Color4f(float x, float y, float z, float w) {
<       super(x, y, z, w);
<    }
< 
<    public Color4f(float[] c) {
<       super(c);
<    }
< 
<    public Color4f(Color4f c1) {
<       super((Tuple4f)c1);
<    }
< 
<    public Color4f(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public Color4f(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public Color4f(Color color) {
<       super((float)color.getRed() / 255.0F, (float)color.getGreen() / 255.0F, (float)color.getBlue() / 255.0F, (float)color.getAlpha() / 255.0F);
<    }
< 
<    public Color4f() {
<    }
< 
<    public final void set(Color color) {
<       this.x = (float)color.getRed() / 255.0F;
<       this.y = (float)color.getGreen() / 255.0F;
<       this.z = (float)color.getBlue() / 255.0F;
<       this.w = (float)color.getAlpha() / 255.0F;
<    }
< 
<    public final Color get() {
<       int r = Math.round(this.x * 255.0F);
<       int g = Math.round(this.y * 255.0F);
<       int b = Math.round(this.z * 255.0F);
<       int a = Math.round(this.w * 255.0F);
<       return new Color(r, g, b, a);
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.awt.Color;
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Color4f
> /*     */   extends Tuple4f
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = 8577680141580006740L;
> /*     */   
> /*     */   public Color4f(float x, float y, float z, float w) {
> /*  56 */     super(x, y, z, w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color4f(float[] c) {
> /*  65 */     super(c);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color4f(Color4f c1) {
> /*  74 */     super(c1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color4f(Tuple4f t1) {
> /*  83 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color4f(Tuple4d t1) {
> /*  92 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color4f(Color color) {
> /* 111 */     super(color.getRed() / 255.0F, color.getGreen() / 255.0F, color.getBlue() / 255.0F, color.getAlpha() / 255.0F);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Color4f() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Color color) {
> /* 134 */     this.x = color.getRed() / 255.0F;
> /* 135 */     this.y = color.getGreen() / 255.0F;
> /* 136 */     this.z = color.getBlue() / 255.0F;
> /* 137 */     this.w = color.getAlpha() / 255.0F;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final Color get() {
> /* 150 */     int r = Math.round(this.x * 255.0F);
> /* 151 */     int g = Math.round(this.y * 255.0F);
> /* 152 */     int b = Math.round(this.z * 255.0F);
> /* 153 */     int a = Math.round(this.w * 255.0F);
> /*     */     
> /* 155 */     return new Color(r, g, b, a);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Color4f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/MismatchedSizeException.java jd-gui/vecmath/MismatchedSizeException.java
1c1,50
< package vecmath;
---
> /*    */ package vecmath;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class MismatchedSizeException
> /*    */   extends RuntimeException
> /*    */ {
> /*    */   public MismatchedSizeException() {}
> /*    */   
> /*    */   public MismatchedSizeException(String str) {
> /* 48 */     super(str);
> /*    */   }
> /*    */ }
3,5d51
< public class MismatchedSizeException extends RuntimeException {
<    public MismatchedSizeException() {
<    }
7,10c53,56
<    public MismatchedSizeException(String str) {
<       super(str);
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/MismatchedSizeException.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/package-info.java jd-gui/vecmath/package-info.java
3,5c3,7
< // $FF: synthetic class
< interface package-info {
< }
---
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/package-info.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Point2d.java jd-gui/vecmath/Point2d.java
1,54c1,162
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Point2d extends Tuple2d implements Serializable {
<    static final long serialVersionUID = 1133748791492571954L;
< 
<    public Point2d(double x, double y) {
<       super(x, y);
<    }
< 
<    public Point2d(double[] p) {
<       super(p);
<    }
< 
<    public Point2d(Point2d p1) {
<       super((Tuple2d)p1);
<    }
< 
<    public Point2d(Point2f p1) {
<       super((Tuple2f)p1);
<    }
< 
<    public Point2d(Tuple2d t1) {
<       super(t1);
<    }
< 
<    public Point2d(Tuple2f t1) {
<       super(t1);
<    }
< 
<    public Point2d() {
<    }
< 
<    public final double distanceSquared(Point2d p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       return dx * dx + dy * dy;
<    }
< 
<    public final double distance(Point2d p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       return Math.sqrt(dx * dx + dy * dy);
<    }
< 
<    public final double distanceL1(Point2d p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y);
<    }
< 
<    public final double distanceLinf(Point2d p1) {
<       return Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Point2d
> /*     */   extends Tuple2d
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = 1133748791492571954L;
> /*     */   
> /*     */   public Point2d(double x, double y) {
> /*  47 */     super(x, y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2d(double[] p) {
> /*  57 */     super(p);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2d(Point2d p1) {
> /*  67 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2d(Point2f p1) {
> /*  77 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2d(Tuple2d t1) {
> /*  87 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2d(Tuple2f t1) {
> /*  97 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2d() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double distanceSquared(Point2d p1) {
> /* 117 */     double dx = this.x - p1.x;
> /* 118 */     double dy = this.y - p1.y;
> /* 119 */     return dx * dx + dy * dy;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double distance(Point2d p1) {
> /* 130 */     double dx = this.x - p1.x;
> /* 131 */     double dy = this.y - p1.y;
> /* 132 */     return Math.sqrt(dx * dx + dy * dy);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double distanceL1(Point2d p1) {
> /* 143 */     return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double distanceLinf(Point2d p1) {
> /* 154 */     return Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Point2d.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Point2f.java jd-gui/vecmath/Point2f.java
1,54c1,163
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Point2f extends Tuple2f implements Serializable {
<    static final long serialVersionUID = -4801347926528714435L;
< 
<    public Point2f(float x, float y) {
<       super(x, y);
<    }
< 
<    public Point2f(float[] p) {
<       super(p);
<    }
< 
<    public Point2f(Point2f p1) {
<       super((Tuple2f)p1);
<    }
< 
<    public Point2f(Point2d p1) {
<       super((Tuple2d)p1);
<    }
< 
<    public Point2f(Tuple2d t1) {
<       super(t1);
<    }
< 
<    public Point2f(Tuple2f t1) {
<       super(t1);
<    }
< 
<    public Point2f() {
<    }
< 
<    public final float distanceSquared(Point2f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       return dx * dx + dy * dy;
<    }
< 
<    public final float distance(Point2f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       return (float)Math.sqrt((double)(dx * dx + dy * dy));
<    }
< 
<    public final float distanceL1(Point2f p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y);
<    }
< 
<    public final float distanceLinf(Point2f p1) {
<       return Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Point2f
> /*     */   extends Tuple2f
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = -4801347926528714435L;
> /*     */   
> /*     */   public Point2f(float x, float y) {
> /*  47 */     super(x, y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2f(float[] p) {
> /*  57 */     super(p);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2f(Point2f p1) {
> /*  67 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2f(Point2d p1) {
> /*  76 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2f(Tuple2d t1) {
> /*  87 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2f(Tuple2f t1) {
> /*  98 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point2f() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distanceSquared(Point2f p1) {
> /* 118 */     float dx = this.x - p1.x;
> /* 119 */     float dy = this.y - p1.y;
> /* 120 */     return dx * dx + dy * dy;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distance(Point2f p1) {
> /* 131 */     float dx = this.x - p1.x;
> /* 132 */     float dy = this.y - p1.y;
> /* 133 */     return (float)Math.sqrt((dx * dx + dy * dy));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distanceL1(Point2f p1) {
> /* 144 */     return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distanceLinf(Point2f p1) {
> /* 155 */     return Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Point2f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Point2i.java jd-gui/vecmath/Point2i.java
1,22c1,76
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Point2i extends Tuple2i implements Serializable {
<    static final long serialVersionUID = 9208072376494084954L;
< 
<    public Point2i(int x, int y) {
<       super(x, y);
<    }
< 
<    public Point2i(int[] t) {
<       super(t);
<    }
< 
<    public Point2i(Tuple2i t1) {
<       super(t1);
<    }
< 
<    public Point2i() {
<    }
< }
---
> /*    */ package vecmath;
> /*    */ 
> /*    */ import java.io.Serializable;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class Point2i
> /*    */   extends Tuple2i
> /*    */   implements Serializable
> /*    */ {
> /*    */   static final long serialVersionUID = 9208072376494084954L;
> /*    */   
> /*    */   public Point2i(int x, int y) {
> /* 47 */     super(x, y);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public Point2i(int[] t) {
> /* 56 */     super(t);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public Point2i(Tuple2i t1) {
> /* 66 */     super(t1);
> /*    */   }
> /*    */   
> /*    */   public Point2i() {}
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Point2i.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Point3dModified.java jd-gui/vecmath/Point3dModified.java
1,64c1,191
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Point3dModified extends Tuple3dModified implements Serializable {
<    static final long serialVersionUID = 5718062286069042927L;
< 
<    public Point3dModified(double x, double y, double z) {
<       super(x, y, z);
<    }
< 
<    public Point3dModified(double[] p) {
<       super(p);
<    }
< 
<    public Point3dModified(Point3dModified p1) {
<       super((Tuple3dModified)p1);
<    }
< 
<    public Point3dModified(Point3f p1) {
<       super((Tuple3f)p1);
<    }
< 
<    public Point3dModified(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public Point3dModified(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public Point3dModified() {
<    }
< 
<    public final double distanceSquared(Point3dModified p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       double dz = this.z - p1.z;
<       return dx * dx + dy * dy + dz * dz;
<    }
< 
<    public double distance(Point3dModified p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       double dz = this.z - p1.z;
<       return Math.sqrt(dx * dx + dy * dy + dz * dz);
<    }
< 
<    public final double distanceL1(Point3dModified p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z);
<    }
< 
<    public final double distanceLinf(Point3dModified p1) {
<       double tmp = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<       return Math.max(tmp, Math.abs(this.z - p1.z));
<    }
< 
<    public final void project(Point4d p1) {
<       double oneOw = 1.0D / p1.w;
<       this.x = p1.x * oneOw;
<       this.y = p1.y * oneOw;
<       this.z = p1.z * oneOw;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Point3dModified
> /*     */   extends Tuple3dModified
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = 5718062286069042927L;
> /*     */   
> /*     */   public Point3dModified(double x, double y, double z) {
> /*  48 */     super(x, y, z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3dModified(double[] p) {
> /*  58 */     super(p);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3dModified(Point3dModified p1) {
> /*  68 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3dModified(Point3f p1) {
> /*  78 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3dModified(Tuple3f t1) {
> /*  88 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3dModified(Tuple3dModified t1) {
> /*  98 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3dModified() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double distanceSquared(Point3dModified p1) {
> /* 120 */     double dx = this.x - p1.x;
> /* 121 */     double dy = this.y - p1.y;
> /* 122 */     double dz = this.z - p1.z;
> /* 123 */     return dx * dx + dy * dy + dz * dz;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public double distance(Point3dModified p1) {
> /* 136 */     double dx = this.x - p1.x;
> /* 137 */     double dy = this.y - p1.y;
> /* 138 */     double dz = this.z - p1.z;
> /* 139 */     return Math.sqrt(dx * dx + dy * dy + dz * dz);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double distanceL1(Point3dModified p1) {
> /* 151 */     return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + 
> /* 152 */       Math.abs(this.z - p1.z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double distanceLinf(Point3dModified p1) {
> /* 165 */     double tmp = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
> /*     */     
> /* 167 */     return Math.max(tmp, Math.abs(this.z - p1.z));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void project(Point4d p1) {
> /* 180 */     double oneOw = 1.0D / p1.w;
> /* 181 */     this.x = p1.x * oneOw;
> /* 182 */     this.y = p1.y * oneOw;
> /* 183 */     this.z = p1.z * oneOw;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Point3dModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Point3f.java jd-gui/vecmath/Point3f.java
1,64c1,194
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Point3f extends Tuple3f implements Serializable {
<    static final long serialVersionUID = -8689337816398030143L;
< 
<    public Point3f(float x, float y, float z) {
<       super(x, y, z);
<    }
< 
<    public Point3f(float[] p) {
<       super(p);
<    }
< 
<    public Point3f(Point3f p1) {
<       super((Tuple3f)p1);
<    }
< 
<    public Point3f(Point3dModified p1) {
<       super((Tuple3dModified)p1);
<    }
< 
<    public Point3f(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public Point3f(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public Point3f() {
<    }
< 
<    public final float distanceSquared(Point3f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       float dz = this.z - p1.z;
<       return dx * dx + dy * dy + dz * dz;
<    }
< 
<    public final float distance(Point3f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       float dz = this.z - p1.z;
<       return (float)Math.sqrt((double)(dx * dx + dy * dy + dz * dz));
<    }
< 
<    public final float distanceL1(Point3f p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z);
<    }
< 
<    public final float distanceLinf(Point3f p1) {
<       float tmp = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<       return Math.max(tmp, Math.abs(this.z - p1.z));
<    }
< 
<    public final void project(Point4f p1) {
<       float oneOw = 1.0F / p1.w;
<       this.x = p1.x * oneOw;
<       this.y = p1.y * oneOw;
<       this.z = p1.z * oneOw;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Point3f
> /*     */   extends Tuple3f
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = -8689337816398030143L;
> /*     */   
> /*     */   public Point3f(float x, float y, float z) {
> /*  49 */     super(x, y, z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3f(float[] p) {
> /*  59 */     super(p);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3f(Point3f p1) {
> /*  69 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3f(Point3dModified p1) {
> /*  79 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3f(Tuple3f t1) {
> /*  89 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3f(Tuple3dModified t1) {
> /*  99 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point3f() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distanceSquared(Point3f p1) {
> /* 122 */     float dx = this.x - p1.x;
> /* 123 */     float dy = this.y - p1.y;
> /* 124 */     float dz = this.z - p1.z;
> /* 125 */     return dx * dx + dy * dy + dz * dz;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distance(Point3f p1) {
> /* 138 */     float dx = this.x - p1.x;
> /* 139 */     float dy = this.y - p1.y;
> /* 140 */     float dz = this.z - p1.z;
> /* 141 */     return (float)Math.sqrt((dx * dx + dy * dy + dz * dz));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distanceL1(Point3f p1) {
> /* 154 */     return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distanceLinf(Point3f p1) {
> /* 168 */     float tmp = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
> /* 169 */     return Math.max(tmp, Math.abs(this.z - p1.z));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void project(Point4f p1) {
> /* 183 */     float oneOw = 1.0F / p1.w;
> /* 184 */     this.x = p1.x * oneOw;
> /* 185 */     this.y = p1.y * oneOw;
> /* 186 */     this.z = p1.z * oneOw;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Point3f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Point3i.java jd-gui/vecmath/Point3i.java
1,22c1,78
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Point3i extends Tuple3i implements Serializable {
<    static final long serialVersionUID = 6149289077348153921L;
< 
<    public Point3i(int x, int y, int z) {
<       super(x, y, z);
<    }
< 
<    public Point3i(int[] t) {
<       super(t);
<    }
< 
<    public Point3i(Tuple3i t1) {
<       super(t1);
<    }
< 
<    public Point3i() {
<    }
< }
---
> /*    */ package vecmath;
> /*    */ 
> /*    */ import java.io.Serializable;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class Point3i
> /*    */   extends Tuple3i
> /*    */   implements Serializable
> /*    */ {
> /*    */   static final long serialVersionUID = 6149289077348153921L;
> /*    */   
> /*    */   public Point3i(int x, int y, int z) {
> /* 49 */     super(x, y, z);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public Point3i(int[] t) {
> /* 58 */     super(t);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public Point3i(Tuple3i t1) {
> /* 68 */     super(t1);
> /*    */   }
> /*    */   
> /*    */   public Point3i() {}
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Point3i.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Point4d.java jd-gui/vecmath/Point4d.java
1,79c1,226
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Point4d extends Tuple4d implements Serializable {
<    static final long serialVersionUID = 1733471895962736949L;
< 
<    public Point4d(double x, double y, double z, double w) {
<       super(x, y, z, w);
<    }
< 
<    public Point4d(double[] p) {
<       super(p);
<    }
< 
<    public Point4d(Point4d p1) {
<       super((Tuple4d)p1);
<    }
< 
<    public Point4d(Point4f p1) {
<       super((Tuple4f)p1);
<    }
< 
<    public Point4d(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public Point4d(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public Point4d(Tuple3dModified t1) {
<       super(t1.x, t1.y, t1.z, 1.0D);
<    }
< 
<    public Point4d() {
<    }
< 
<    public final void set(Tuple3dModified t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = 1.0D;
<    }
< 
<    public final double distanceSquared(Point4d p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       double dz = this.z - p1.z;
<       double dw = this.w - p1.w;
<       return dx * dx + dy * dy + dz * dz + dw * dw;
<    }
< 
<    public final double distance(Point4d p1) {
<       double dx = this.x - p1.x;
<       double dy = this.y - p1.y;
<       double dz = this.z - p1.z;
<       double dw = this.w - p1.w;
<       return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
<    }
< 
<    public final double distanceL1(Point4d p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z) + Math.abs(this.w - p1.w);
<    }
< 
<    public final double distanceLinf(Point4d p1) {
<       double t1 = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<       double t2 = Math.max(Math.abs(this.z - p1.z), Math.abs(this.w - p1.w));
<       return Math.max(t1, t2);
<    }
< 
<    public final void project(Point4d p1) {
<       double oneOw = 1.0D / p1.w;
<       this.x = p1.x * oneOw;
<       this.y = p1.y * oneOw;
<       this.z = p1.z * oneOw;
<       this.w = 1.0D;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Point4d
> /*     */   extends Tuple4d
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = 1733471895962736949L;
> /*     */   
> /*     */   public Point4d(double x, double y, double z, double w) {
> /*  50 */     super(x, y, z, w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4d(double[] p) {
> /*  60 */     super(p);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4d(Point4d p1) {
> /*  70 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4d(Point4f p1) {
> /*  80 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4d(Tuple4f t1) {
> /*  90 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4d(Tuple4d t1) {
> /* 100 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4d(Tuple3dModified t1) {
> /* 114 */     super(t1.x, t1.y, t1.z, 1.0D);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4d() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple3dModified t1) {
> /* 136 */     this.x = t1.x;
> /* 137 */     this.y = t1.y;
> /* 138 */     this.z = t1.z;
> /* 139 */     this.w = 1.0D;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double distanceSquared(Point4d p1) {
> /* 152 */     double dx = this.x - p1.x;
> /* 153 */     double dy = this.y - p1.y;
> /* 154 */     double dz = this.z - p1.z;
> /* 155 */     double dw = this.w - p1.w;
> /* 156 */     return dx * dx + dy * dy + dz * dz + dw * dw;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double distance(Point4d p1) {
> /* 169 */     double dx = this.x - p1.x;
> /* 170 */     double dy = this.y - p1.y;
> /* 171 */     double dz = this.z - p1.z;
> /* 172 */     double dw = this.w - p1.w;
> /* 173 */     return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double distanceL1(Point4d p1) {
> /* 185 */     return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + 
> /* 186 */       Math.abs(this.z - p1.z) + Math.abs(this.w - p1.w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double distanceLinf(Point4d p1) {
> /* 198 */     double t1 = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
> /* 199 */     double t2 = Math.max(Math.abs(this.z - p1.z), Math.abs(this.w - p1.w));
> /*     */     
> /* 201 */     return Math.max(t1, t2);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void project(Point4d p1) {
> /* 214 */     double oneOw = 1.0D / p1.w;
> /* 215 */     p1.x *= oneOw;
> /* 216 */     p1.y *= oneOw;
> /* 217 */     p1.z *= oneOw;
> /* 218 */     this.w = 1.0D;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Point4d.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Point4f.java jd-gui/vecmath/Point4f.java
1,79c1,229
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Point4f extends Tuple4f implements Serializable {
<    static final long serialVersionUID = 4643134103185764459L;
< 
<    public Point4f(float x, float y, float z, float w) {
<       super(x, y, z, w);
<    }
< 
<    public Point4f(float[] p) {
<       super(p);
<    }
< 
<    public Point4f(Point4f p1) {
<       super((Tuple4f)p1);
<    }
< 
<    public Point4f(Point4d p1) {
<       super((Tuple4d)p1);
<    }
< 
<    public Point4f(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public Point4f(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public Point4f(Tuple3f t1) {
<       super(t1.x, t1.y, t1.z, 1.0F);
<    }
< 
<    public Point4f() {
<    }
< 
<    public final void set(Tuple3f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = 1.0F;
<    }
< 
<    public final float distanceSquared(Point4f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       float dz = this.z - p1.z;
<       float dw = this.w - p1.w;
<       return dx * dx + dy * dy + dz * dz + dw * dw;
<    }
< 
<    public final float distance(Point4f p1) {
<       float dx = this.x - p1.x;
<       float dy = this.y - p1.y;
<       float dz = this.z - p1.z;
<       float dw = this.w - p1.w;
<       return (float)Math.sqrt((double)(dx * dx + dy * dy + dz * dz + dw * dw));
<    }
< 
<    public final float distanceL1(Point4f p1) {
<       return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z) + Math.abs(this.w - p1.w);
<    }
< 
<    public final float distanceLinf(Point4f p1) {
<       float t1 = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
<       float t2 = Math.max(Math.abs(this.z - p1.z), Math.abs(this.w - p1.w));
<       return Math.max(t1, t2);
<    }
< 
<    public final void project(Point4f p1) {
<       float oneOw = 1.0F / p1.w;
<       this.x = p1.x * oneOw;
<       this.y = p1.y * oneOw;
<       this.z = p1.z * oneOw;
<       this.w = 1.0F;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Point4f
> /*     */   extends Tuple4f
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = 4643134103185764459L;
> /*     */   
> /*     */   public Point4f(float x, float y, float z, float w) {
> /*  50 */     super(x, y, z, w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4f(float[] p) {
> /*  60 */     super(p);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4f(Point4f p1) {
> /*  70 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4f(Point4d p1) {
> /*  80 */     super(p1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4f(Tuple4f t1) {
> /*  90 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4f(Tuple4d t1) {
> /* 100 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4f(Tuple3f t1) {
> /* 114 */     super(t1.x, t1.y, t1.z, 1.0F);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Point4f() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple3f t1) {
> /* 136 */     this.x = t1.x;
> /* 137 */     this.y = t1.y;
> /* 138 */     this.z = t1.z;
> /* 139 */     this.w = 1.0F;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distanceSquared(Point4f p1) {
> /* 152 */     float dx = this.x - p1.x;
> /* 153 */     float dy = this.y - p1.y;
> /* 154 */     float dz = this.z - p1.z;
> /* 155 */     float dw = this.w - p1.w;
> /* 156 */     return dx * dx + dy * dy + dz * dz + dw * dw;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distance(Point4f p1) {
> /* 169 */     float dx = this.x - p1.x;
> /* 170 */     float dy = this.y - p1.y;
> /* 171 */     float dz = this.z - p1.z;
> /* 172 */     float dw = this.w - p1.w;
> /* 173 */     return (float)Math.sqrt((dx * dx + dy * dy + dz * dz + dw * dw));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distanceL1(Point4f p1) {
> /* 186 */     return Math.abs(this.x - p1.x) + Math.abs(this.y - p1.y) + Math.abs(this.z - p1.z) + Math.abs(this.w - p1.w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float distanceLinf(Point4f p1) {
> /* 200 */     float t1 = Math.max(Math.abs(this.x - p1.x), Math.abs(this.y - p1.y));
> /* 201 */     float t2 = Math.max(Math.abs(this.z - p1.z), Math.abs(this.w - p1.w));
> /*     */     
> /* 203 */     return Math.max(t1, t2);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void project(Point4f p1) {
> /* 217 */     float oneOw = 1.0F / p1.w;
> /* 218 */     p1.x *= oneOw;
> /* 219 */     p1.y *= oneOw;
> /* 220 */     p1.z *= oneOw;
> /* 221 */     this.w = 1.0F;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Point4f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Point4i.java jd-gui/vecmath/Point4i.java
1,22c1,79
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Point4i extends Tuple4i implements Serializable {
<    static final long serialVersionUID = 620124780244617983L;
< 
<    public Point4i(int x, int y, int z, int w) {
<       super(x, y, z, w);
<    }
< 
<    public Point4i(int[] t) {
<       super(t);
<    }
< 
<    public Point4i(Tuple4i t1) {
<       super(t1);
<    }
< 
<    public Point4i() {
<    }
< }
---
> /*    */ package vecmath;
> /*    */ 
> /*    */ import java.io.Serializable;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class Point4i
> /*    */   extends Tuple4i
> /*    */   implements Serializable
> /*    */ {
> /*    */   static final long serialVersionUID = 620124780244617983L;
> /*    */   
> /*    */   public Point4i(int x, int y, int z, int w) {
> /* 50 */     super(x, y, z, w);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public Point4i(int[] t) {
> /* 59 */     super(t);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public Point4i(Tuple4i t1) {
> /* 69 */     super(t1);
> /*    */   }
> /*    */   
> /*    */   public Point4i() {}
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Point4i.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/SingularMatrixException.java jd-gui/vecmath/SingularMatrixException.java
1c1,48
< package vecmath;
---
> /*    */ package vecmath;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class SingularMatrixException
> /*    */   extends RuntimeException
> /*    */ {
> /*    */   public SingularMatrixException() {}
> /*    */   
> /*    */   public SingularMatrixException(String str) {
> /* 46 */     super(str);
> /*    */   }
> /*    */ }
3,5d49
< public class SingularMatrixException extends RuntimeException {
<    public SingularMatrixException() {
<    }
7,10c51,54
<    public SingularMatrixException(String str) {
<       super(str);
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/SingularMatrixException.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/TexCoord2f.java jd-gui/vecmath/TexCoord2f.java
1,26c1,87
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class TexCoord2f extends Tuple2f implements Serializable {
<    static final long serialVersionUID = 7998248474800032487L;
< 
<    public TexCoord2f(float x, float y) {
<       super(x, y);
<    }
< 
<    public TexCoord2f(float[] v) {
<       super(v);
<    }
< 
<    public TexCoord2f(TexCoord2f v1) {
<       super((Tuple2f)v1);
<    }
< 
<    public TexCoord2f(Tuple2f t1) {
<       super(t1);
<    }
< 
<    public TexCoord2f() {
<    }
< }
---
> /*    */ package vecmath;
> /*    */ 
> /*    */ import java.io.Serializable;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class TexCoord2f
> /*    */   extends Tuple2f
> /*    */   implements Serializable
> /*    */ {
> /*    */   static final long serialVersionUID = 7998248474800032487L;
> /*    */   
> /*    */   public TexCoord2f(float x, float y) {
> /* 47 */     super(x, y);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TexCoord2f(float[] v) {
> /* 57 */     super(v);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TexCoord2f(TexCoord2f v1) {
> /* 67 */     super(v1);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TexCoord2f(Tuple2f t1) {
> /* 77 */     super(t1);
> /*    */   }
> /*    */   
> /*    */   public TexCoord2f() {}
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/TexCoord2f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/TexCoord3f.java jd-gui/vecmath/TexCoord3f.java
1,30c1,99
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class TexCoord3f extends Tuple3f implements Serializable {
<    static final long serialVersionUID = -3517736544731446513L;
< 
<    public TexCoord3f(float x, float y, float z) {
<       super(x, y, z);
<    }
< 
<    public TexCoord3f(float[] v) {
<       super(v);
<    }
< 
<    public TexCoord3f(TexCoord3f v1) {
<       super((Tuple3f)v1);
<    }
< 
<    public TexCoord3f(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public TexCoord3f(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public TexCoord3f() {
<    }
< }
---
> /*    */ package vecmath;
> /*    */ 
> /*    */ import java.io.Serializable;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class TexCoord3f
> /*    */   extends Tuple3f
> /*    */   implements Serializable
> /*    */ {
> /*    */   static final long serialVersionUID = -3517736544731446513L;
> /*    */   
> /*    */   public TexCoord3f(float x, float y, float z) {
> /* 49 */     super(x, y, z);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TexCoord3f(float[] v) {
> /* 59 */     super(v);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TexCoord3f(TexCoord3f v1) {
> /* 69 */     super(v1);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TexCoord3f(Tuple3f t1) {
> /* 79 */     super(t1);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TexCoord3f(Tuple3dModified t1) {
> /* 89 */     super(t1);
> /*    */   }
> /*    */   
> /*    */   public TexCoord3f() {}
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/TexCoord3f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/TexCoord4f.java jd-gui/vecmath/TexCoord4f.java
1,30c1,101
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class TexCoord4f extends Tuple4f implements Serializable {
<    static final long serialVersionUID = -3517736544731446513L;
< 
<    public TexCoord4f(float x, float y, float z, float w) {
<       super(x, y, z, w);
<    }
< 
<    public TexCoord4f(float[] v) {
<       super(v);
<    }
< 
<    public TexCoord4f(TexCoord4f v1) {
<       super((Tuple4f)v1);
<    }
< 
<    public TexCoord4f(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public TexCoord4f(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public TexCoord4f() {
<    }
< }
---
> /*    */ package vecmath;
> /*    */ 
> /*    */ import java.io.Serializable;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ public class TexCoord4f
> /*    */   extends Tuple4f
> /*    */   implements Serializable
> /*    */ {
> /*    */   static final long serialVersionUID = -3517736544731446513L;
> /*    */   
> /*    */   public TexCoord4f(float x, float y, float z, float w) {
> /* 51 */     super(x, y, z, w);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TexCoord4f(float[] v) {
> /* 61 */     super(v);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TexCoord4f(TexCoord4f v1) {
> /* 71 */     super(v1);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TexCoord4f(Tuple4f t1) {
> /* 81 */     super(t1);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   public TexCoord4f(Tuple4d t1) {
> /* 91 */     super(t1);
> /*    */   }
> /*    */   
> /*    */   public TexCoord4f() {}
> /*    */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/TexCoord4f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Tuple2d.java jd-gui/vecmath/Tuple2d.java
1,285c1,609
< package vecmath;
< 
< import java.io.Serializable;
< 
< public abstract class Tuple2d implements Serializable, Cloneable {
<    static final long serialVersionUID = 6205762482756093838L;
<    public double x;
<    public double y;
< 
<    public Tuple2d(double x, double y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public Tuple2d(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public Tuple2d(Tuple2d t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public Tuple2d(Tuple2f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<    }
< 
<    public Tuple2d() {
<       this.x = 0.0D;
<       this.y = 0.0D;
<    }
< 
<    public final void set(double x, double y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public final void set(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public final void set(Tuple2d t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public final void set(Tuple2f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<    }
< 
<    public final void get(double[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<    }
< 
<    public final void add(Tuple2d t1, Tuple2d t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<    }
< 
<    public final void add(Tuple2d t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<    }
< 
<    public final void sub(Tuple2d t1, Tuple2d t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<    }
< 
<    public final void sub(Tuple2d t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<    }
< 
<    public final void negate(Tuple2d t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<    }
< 
<    public final void scale(double s, Tuple2d t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<    }
< 
<    public final void scale(double s) {
<       this.x *= s;
<       this.y *= s;
<    }
< 
<    public final void scaleAdd(double s, Tuple2d t1, Tuple2d t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<    }
< 
<    public final void scaleAdd(double s, Tuple2d t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashDoubleBits(bits, this.x);
<       bits = VecMathUtil.hashDoubleBits(bits, this.y);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    public boolean equals(Tuple2d t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple2d t2 = (Tuple2d)t1;
<          return this.x == t2.x && this.y == t2.y;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple2d t1, double epsilon) {
<       double diff = this.x - t1.x;
<       if (Double.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Double.isNaN(diff)) {
<             return false;
<          } else {
<             return !((diff < 0.0D ? -diff : diff) > epsilon);
<          }
<       }
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ")";
<    }
< 
<    public final void clamp(double min, double max, Tuple2d t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMin(double min, Tuple2d t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMax(double max, Tuple2d t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void absolute(Tuple2d t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<    }
< 
<    public final void clamp(double min, double max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMin(double min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMax(double max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<    }
< 
<    public final void interpolate(Tuple2d t1, Tuple2d t2, double alpha) {
<       this.x = (1.0D - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0D - alpha) * t1.y + alpha * t2.y;
<    }
< 
<    public final void interpolate(Tuple2d t1, double alpha) {
<       this.x = (1.0D - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0D - alpha) * this.y + alpha * t1.y;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final double getX() {
<       return this.x;
<    }
< 
<    public final void setX(double x) {
<       this.x = x;
<    }
< 
<    public final double getY() {
<       return this.y;
<    }
< 
<    public final void setY(double y) {
<       this.y = y;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class Tuple2d
> /*     */   implements Serializable, Cloneable
> /*     */ {
> /*     */   static final long serialVersionUID = 6205762482756093838L;
> /*     */   public double x;
> /*     */   public double y;
> /*     */   
> /*     */   public Tuple2d(double x, double y) {
> /*  57 */     this.x = x;
> /*  58 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple2d(double[] t) {
> /*  68 */     this.x = t[0];
> /*  69 */     this.y = t[1];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple2d(Tuple2d t1) {
> /*  79 */     this.x = t1.x;
> /*  80 */     this.y = t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple2d(Tuple2f t1) {
> /*  90 */     this.x = t1.x;
> /*  91 */     this.y = t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple2d() {
> /*  99 */     this.x = 0.0D;
> /* 100 */     this.y = 0.0D;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(double x, double y) {
> /* 111 */     this.x = x;
> /* 112 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(double[] t) {
> /* 123 */     this.x = t[0];
> /* 124 */     this.y = t[1];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple2d t1) {
> /* 134 */     this.x = t1.x;
> /* 135 */     this.y = t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple2f t1) {
> /* 145 */     this.x = t1.x;
> /* 146 */     this.y = t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(double[] t) {
> /* 155 */     t[0] = this.x;
> /* 156 */     t[1] = this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple2d t1, Tuple2d t2) {
> /* 167 */     t1.x += t2.x;
> /* 168 */     t1.y += t2.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple2d t1) {
> /* 178 */     this.x += t1.x;
> /* 179 */     this.y += t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple2d t1, Tuple2d t2) {
> /* 191 */     t1.x -= t2.x;
> /* 192 */     t1.y -= t2.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple2d t1) {
> /* 203 */     this.x -= t1.x;
> /* 204 */     this.y -= t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate(Tuple2d t1) {
> /* 214 */     this.x = -t1.x;
> /* 215 */     this.y = -t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate() {
> /* 224 */     this.x = -this.x;
> /* 225 */     this.y = -this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(double s, Tuple2d t1) {
> /* 237 */     this.x = s * t1.x;
> /* 238 */     this.y = s * t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(double s) {
> /* 249 */     this.x *= s;
> /* 250 */     this.y *= s;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(double s, Tuple2d t1, Tuple2d t2) {
> /* 263 */     this.x = s * t1.x + t2.x;
> /* 264 */     this.y = s * t1.y + t2.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(double s, Tuple2d t1) {
> /* 276 */     this.x = s * this.x + t1.x;
> /* 277 */     this.y = s * this.y + t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int hashCode() {
> /* 292 */     long bits = 1L;
> /* 293 */     bits = VecMathUtil.hashDoubleBits(bits, this.x);
> /* 294 */     bits = VecMathUtil.hashDoubleBits(bits, this.y);
> /* 295 */     return VecMathUtil.hashFinish(bits);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Tuple2d t1) {
> /*     */     try {
> /* 308 */       return (this.x == t1.x && this.y == t1.y);
> /*     */     } catch (NullPointerException e2) {
> /* 310 */       return false;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object t1) {
> /*     */     
> /* 325 */     try { Tuple2d t2 = (Tuple2d)t1;
> /* 326 */       return (this.x == t2.x && this.y == t2.y); }
> /*     */     catch (NullPointerException e2)
> /* 328 */     { return false; }
> /* 329 */     catch (ClassCastException e1) { return false; }
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean epsilonEquals(Tuple2d t1, double epsilon) {
> /* 346 */     double diff = this.x - t1.x;
> /* 347 */     if (Double.isNaN(diff)) return false; 
> /* 348 */     if (((diff < 0.0D) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 350 */     diff = this.y - t1.y;
> /* 351 */     if (Double.isNaN(diff)) return false; 
> /* 352 */     if (((diff < 0.0D) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 354 */     return true;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 365 */     return "(" + this.x + ", " + this.y + ")";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(double min, double max, Tuple2d t) {
> /* 378 */     if (t.x > max) {
> /* 379 */       this.x = max;
> /* 380 */     } else if (t.x < min) {
> /* 381 */       this.x = min;
> /*     */     } else {
> /* 383 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 386 */     if (t.y > max) {
> /* 387 */       this.y = max;
> /* 388 */     } else if (t.y < min) {
> /* 389 */       this.y = min;
> /*     */     } else {
> /* 391 */       this.y = t.y;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(double min, Tuple2d t) {
> /* 405 */     if (t.x < min) {
> /* 406 */       this.x = min;
> /*     */     } else {
> /* 408 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 411 */     if (t.y < min) {
> /* 412 */       this.y = min;
> /*     */     } else {
> /* 414 */       this.y = t.y;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(double max, Tuple2d t) {
> /* 428 */     if (t.x > max) {
> /* 429 */       this.x = max;
> /*     */     } else {
> /* 431 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 434 */     if (t.y > max) {
> /* 435 */       this.y = max;
> /*     */     } else {
> /* 437 */       this.y = t.y;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute(Tuple2d t) {
> /* 450 */     this.x = Math.abs(t.x);
> /* 451 */     this.y = Math.abs(t.y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(double min, double max) {
> /* 463 */     if (this.x > max) {
> /* 464 */       this.x = max;
> /* 465 */     } else if (this.x < min) {
> /* 466 */       this.x = min;
> /*     */     } 
> /*     */     
> /* 469 */     if (this.y > max) {
> /* 470 */       this.y = max;
> /* 471 */     } else if (this.y < min) {
> /* 472 */       this.y = min;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(double min) {
> /* 484 */     if (this.x < min) this.x = min; 
> /* 485 */     if (this.y < min) this.y = min;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(double max) {
> /* 495 */     if (this.x > max) this.x = max; 
> /* 496 */     if (this.y > max) this.y = max;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute() {
> /* 505 */     this.x = Math.abs(this.x);
> /* 506 */     this.y = Math.abs(this.y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void interpolate(Tuple2d t1, Tuple2d t2, double alpha) {
> /* 519 */     this.x = (1.0D - alpha) * t1.x + alpha * t2.x;
> /* 520 */     this.y = (1.0D - alpha) * t1.y + alpha * t2.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void interpolate(Tuple2d t1, double alpha) {
> /* 532 */     this.x = (1.0D - alpha) * this.x + alpha * t1.x;
> /* 533 */     this.y = (1.0D - alpha) * this.y + alpha * t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object clone() {
> /*     */     try {
> /* 549 */       return super.clone();
> /* 550 */     } catch (CloneNotSupportedException e) {
> /*     */       
> /* 552 */       throw new InternalError();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double getX() {
> /* 565 */     return this.x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setX(double x) {
> /* 577 */     this.x = x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double getY() {
> /* 589 */     return this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setY(double y) {
> /* 601 */     this.y = y;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Tuple2d.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Tuple2f.java jd-gui/vecmath/Tuple2f.java
1,285c1,613
< package vecmath;
< 
< import java.io.Serializable;
< 
< public abstract class Tuple2f implements Serializable, Cloneable {
<    static final long serialVersionUID = 9011180388985266884L;
<    public float x;
<    public float y;
< 
<    public Tuple2f(float x, float y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public Tuple2f(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public Tuple2f(Tuple2f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public Tuple2f(Tuple2d t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<    }
< 
<    public Tuple2f() {
<       this.x = 0.0F;
<       this.y = 0.0F;
<    }
< 
<    public final void set(float x, float y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public final void set(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public final void set(Tuple2f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public final void set(Tuple2d t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<    }
< 
<    public final void get(float[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<    }
< 
<    public final void add(Tuple2f t1, Tuple2f t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<    }
< 
<    public final void add(Tuple2f t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<    }
< 
<    public final void sub(Tuple2f t1, Tuple2f t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<    }
< 
<    public final void sub(Tuple2f t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<    }
< 
<    public final void negate(Tuple2f t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<    }
< 
<    public final void scale(float s, Tuple2f t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<    }
< 
<    public final void scale(float s) {
<       this.x *= s;
<       this.y *= s;
<    }
< 
<    public final void scaleAdd(float s, Tuple2f t1, Tuple2f t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<    }
< 
<    public final void scaleAdd(float s, Tuple2f t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashFloatBits(bits, this.x);
<       bits = VecMathUtil.hashFloatBits(bits, this.y);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    public boolean equals(Tuple2f t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple2f t2 = (Tuple2f)t1;
<          return this.x == t2.x && this.y == t2.y;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple2f t1, float epsilon) {
<       float diff = this.x - t1.x;
<       if (Float.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Float.isNaN(diff)) {
<             return false;
<          } else {
<             return !((diff < 0.0F ? -diff : diff) > epsilon);
<          }
<       }
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ")";
<    }
< 
<    public final void clamp(float min, float max, Tuple2f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMin(float min, Tuple2f t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMax(float max, Tuple2f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void absolute(Tuple2f t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<    }
< 
<    public final void clamp(float min, float max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMin(float min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMax(float max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<    }
< 
<    public final void interpolate(Tuple2f t1, Tuple2f t2, float alpha) {
<       this.x = (1.0F - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0F - alpha) * t1.y + alpha * t2.y;
<    }
< 
<    public final void interpolate(Tuple2f t1, float alpha) {
<       this.x = (1.0F - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0F - alpha) * this.y + alpha * t1.y;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final float getX() {
<       return this.x;
<    }
< 
<    public final void setX(float x) {
<       this.x = x;
<    }
< 
<    public final float getY() {
<       return this.y;
<    }
< 
<    public final void setY(float y) {
<       this.y = y;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class Tuple2f
> /*     */   implements Serializable, Cloneable
> /*     */ {
> /*     */   static final long serialVersionUID = 9011180388985266884L;
> /*     */   public float x;
> /*     */   public float y;
> /*     */   
> /*     */   public Tuple2f(float x, float y) {
> /*  57 */     this.x = x;
> /*  58 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple2f(float[] t) {
> /*  68 */     this.x = t[0];
> /*  69 */     this.y = t[1];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple2f(Tuple2f t1) {
> /*  79 */     this.x = t1.x;
> /*  80 */     this.y = t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple2f(Tuple2d t1) {
> /*  90 */     this.x = (float)t1.x;
> /*  91 */     this.y = (float)t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple2f() {
> /* 100 */     this.x = 0.0F;
> /* 101 */     this.y = 0.0F;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(float x, float y) {
> /* 112 */     this.x = x;
> /* 113 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(float[] t) {
> /* 124 */     this.x = t[0];
> /* 125 */     this.y = t[1];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple2f t1) {
> /* 135 */     this.x = t1.x;
> /* 136 */     this.y = t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple2d t1) {
> /* 146 */     this.x = (float)t1.x;
> /* 147 */     this.y = (float)t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(float[] t) {
> /* 157 */     t[0] = this.x;
> /* 158 */     t[1] = this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple2f t1, Tuple2f t2) {
> /* 169 */     t1.x += t2.x;
> /* 170 */     t1.y += t2.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple2f t1) {
> /* 180 */     this.x += t1.x;
> /* 181 */     this.y += t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple2f t1, Tuple2f t2) {
> /* 193 */     t1.x -= t2.x;
> /* 194 */     t1.y -= t2.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple2f t1) {
> /* 205 */     this.x -= t1.x;
> /* 206 */     this.y -= t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate(Tuple2f t1) {
> /* 216 */     this.x = -t1.x;
> /* 217 */     this.y = -t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate() {
> /* 226 */     this.x = -this.x;
> /* 227 */     this.y = -this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(float s, Tuple2f t1) {
> /* 239 */     this.x = s * t1.x;
> /* 240 */     this.y = s * t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(float s) {
> /* 251 */     this.x *= s;
> /* 252 */     this.y *= s;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(float s, Tuple2f t1, Tuple2f t2) {
> /* 265 */     this.x = s * t1.x + t2.x;
> /* 266 */     this.y = s * t1.y + t2.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(float s, Tuple2f t1) {
> /* 278 */     this.x = s * this.x + t1.x;
> /* 279 */     this.y = s * this.y + t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int hashCode() {
> /* 294 */     long bits = 1L;
> /* 295 */     bits = VecMathUtil.hashFloatBits(bits, this.x);
> /* 296 */     bits = VecMathUtil.hashFloatBits(bits, this.y);
> /* 297 */     return VecMathUtil.hashFinish(bits);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Tuple2f t1) {
> /*     */     try {
> /* 310 */       return (this.x == t1.x && this.y == t1.y);
> /*     */     } catch (NullPointerException e2) {
> /* 312 */       return false;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object t1) {
> /*     */     
> /* 327 */     try { Tuple2f t2 = (Tuple2f)t1;
> /* 328 */       return (this.x == t2.x && this.y == t2.y); }
> /*     */     catch (NullPointerException e2)
> /* 330 */     { return false; }
> /* 331 */     catch (ClassCastException e1) { return false; }
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean epsilonEquals(Tuple2f t1, float epsilon) {
> /* 348 */     float diff = this.x - t1.x;
> /* 349 */     if (Float.isNaN(diff)) return false; 
> /* 350 */     if (((diff < 0.0F) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 352 */     diff = this.y - t1.y;
> /* 353 */     if (Float.isNaN(diff)) return false; 
> /* 354 */     if (((diff < 0.0F) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 356 */     return true;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 367 */     return "(" + this.x + ", " + this.y + ")";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(float min, float max, Tuple2f t) {
> /* 380 */     if (t.x > max) {
> /* 381 */       this.x = max;
> /* 382 */     } else if (t.x < min) {
> /* 383 */       this.x = min;
> /*     */     } else {
> /* 385 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 388 */     if (t.y > max) {
> /* 389 */       this.y = max;
> /* 390 */     } else if (t.y < min) {
> /* 391 */       this.y = min;
> /*     */     } else {
> /* 393 */       this.y = t.y;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(float min, Tuple2f t) {
> /* 407 */     if (t.x < min) {
> /* 408 */       this.x = min;
> /*     */     } else {
> /* 410 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 413 */     if (t.y < min) {
> /* 414 */       this.y = min;
> /*     */     } else {
> /* 416 */       this.y = t.y;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(float max, Tuple2f t) {
> /* 430 */     if (t.x > max) {
> /* 431 */       this.x = max;
> /*     */     } else {
> /* 433 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 436 */     if (t.y > max) {
> /* 437 */       this.y = max;
> /*     */     } else {
> /* 439 */       this.y = t.y;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute(Tuple2f t) {
> /* 452 */     this.x = Math.abs(t.x);
> /* 453 */     this.y = Math.abs(t.y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(float min, float max) {
> /* 465 */     if (this.x > max) {
> /* 466 */       this.x = max;
> /* 467 */     } else if (this.x < min) {
> /* 468 */       this.x = min;
> /*     */     } 
> /*     */     
> /* 471 */     if (this.y > max) {
> /* 472 */       this.y = max;
> /* 473 */     } else if (this.y < min) {
> /* 474 */       this.y = min;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(float min) {
> /* 486 */     if (this.x < min) this.x = min; 
> /* 487 */     if (this.y < min) this.y = min;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(float max) {
> /* 497 */     if (this.x > max) this.x = max; 
> /* 498 */     if (this.y > max) this.y = max;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute() {
> /* 507 */     this.x = Math.abs(this.x);
> /* 508 */     this.y = Math.abs(this.y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void interpolate(Tuple2f t1, Tuple2f t2, float alpha) {
> /* 521 */     this.x = (1.0F - alpha) * t1.x + alpha * t2.x;
> /* 522 */     this.y = (1.0F - alpha) * t1.y + alpha * t2.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void interpolate(Tuple2f t1, float alpha) {
> /* 536 */     this.x = (1.0F - alpha) * this.x + alpha * t1.x;
> /* 537 */     this.y = (1.0F - alpha) * this.y + alpha * t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object clone() {
> /*     */     try {
> /* 553 */       return super.clone();
> /* 554 */     } catch (CloneNotSupportedException e) {
> /*     */       
> /* 556 */       throw new InternalError();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float getX() {
> /* 569 */     return this.x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setX(float x) {
> /* 581 */     this.x = x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float getY() {
> /* 593 */     return this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setY(float y) {
> /* 605 */     this.y = y;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Tuple2f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Tuple2i.java jd-gui/vecmath/Tuple2i.java
1,246c1,510
< package vecmath;
< 
< import java.io.Serializable;
< 
< public abstract class Tuple2i implements Serializable, Cloneable {
<    static final long serialVersionUID = -3555701650170169638L;
<    public int x;
<    public int y;
< 
<    public Tuple2i(int x, int y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public Tuple2i(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public Tuple2i(Tuple2i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public Tuple2i() {
<       this.x = 0;
<       this.y = 0;
<    }
< 
<    public final void set(int x, int y) {
<       this.x = x;
<       this.y = y;
<    }
< 
<    public final void set(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<    }
< 
<    public final void set(Tuple2i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<    }
< 
<    public final void get(int[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<    }
< 
<    public final void get(Tuple2i t) {
<       t.x = this.x;
<       t.y = this.y;
<    }
< 
<    public final void add(Tuple2i t1, Tuple2i t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<    }
< 
<    public final void add(Tuple2i t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<    }
< 
<    public final void sub(Tuple2i t1, Tuple2i t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<    }
< 
<    public final void sub(Tuple2i t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<    }
< 
<    public final void negate(Tuple2i t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<    }
< 
<    public final void scale(int s, Tuple2i t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<    }
< 
<    public final void scale(int s) {
<       this.x *= s;
<       this.y *= s;
<    }
< 
<    public final void scaleAdd(int s, Tuple2i t1, Tuple2i t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<    }
< 
<    public final void scaleAdd(int s, Tuple2i t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ")";
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple2i t2 = (Tuple2i)t1;
<          return this.x == t2.x && this.y == t2.y;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = 31L * bits + (long)this.x;
<       bits = 31L * bits + (long)this.y;
<       return (int)(bits ^ bits >> 32);
<    }
< 
<    public final void clamp(int min, int max, Tuple2i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMin(int min, Tuple2i t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void clampMax(int max, Tuple2i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<    }
< 
<    public final void absolute(Tuple2i t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<    }
< 
<    public final void clamp(int min, int max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMin(int min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<    }
< 
<    public final void clampMax(int max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final int getX() {
<       return this.x;
<    }
< 
<    public final void setX(int x) {
<       this.x = x;
<    }
< 
<    public final int getY() {
<       return this.y;
<    }
< 
<    public final void setY(int y) {
<       this.y = y;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class Tuple2i
> /*     */   implements Serializable, Cloneable
> /*     */ {
> /*     */   static final long serialVersionUID = -3555701650170169638L;
> /*     */   public int x;
> /*     */   public int y;
> /*     */   
> /*     */   public Tuple2i(int x, int y) {
> /*  58 */     this.x = x;
> /*  59 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple2i(int[] t) {
> /*  68 */     this.x = t[0];
> /*  69 */     this.y = t[1];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple2i(Tuple2i t1) {
> /*  79 */     this.x = t1.x;
> /*  80 */     this.y = t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple2i() {
> /*  88 */     this.x = 0;
> /*  89 */     this.y = 0;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(int x, int y) {
> /* 100 */     this.x = x;
> /* 101 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(int[] t) {
> /* 111 */     this.x = t[0];
> /* 112 */     this.y = t[1];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple2i t1) {
> /* 121 */     this.x = t1.x;
> /* 122 */     this.y = t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(int[] t) {
> /* 131 */     t[0] = this.x;
> /* 132 */     t[1] = this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(Tuple2i t) {
> /* 141 */     t.x = this.x;
> /* 142 */     t.y = this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple2i t1, Tuple2i t2) {
> /* 152 */     t1.x += t2.x;
> /* 153 */     t1.y += t2.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple2i t1) {
> /* 162 */     this.x += t1.x;
> /* 163 */     this.y += t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple2i t1, Tuple2i t2) {
> /* 174 */     t1.x -= t2.x;
> /* 175 */     t1.y -= t2.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple2i t1) {
> /* 185 */     this.x -= t1.x;
> /* 186 */     this.y -= t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate(Tuple2i t1) {
> /* 195 */     this.x = -t1.x;
> /* 196 */     this.y = -t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate() {
> /* 204 */     this.x = -this.x;
> /* 205 */     this.y = -this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(int s, Tuple2i t1) {
> /* 216 */     this.x = s * t1.x;
> /* 217 */     this.y = s * t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(int s) {
> /* 227 */     this.x *= s;
> /* 228 */     this.y *= s;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(int s, Tuple2i t1, Tuple2i t2) {
> /* 240 */     this.x = s * t1.x + t2.x;
> /* 241 */     this.y = s * t1.y + t2.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(int s, Tuple2i t1) {
> /* 252 */     this.x = s * this.x + t1.x;
> /* 253 */     this.y = s * this.y + t1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 264 */     return "(" + this.x + ", " + this.y + ")";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object t1) {
> /*     */     try {
> /* 277 */       Tuple2i t2 = (Tuple2i)t1;
> /* 278 */       return (this.x == t2.x && this.y == t2.y);
> /*     */     }
> /* 280 */     catch (NullPointerException e2) {
> /* 281 */       return false;
> /*     */     }
> /* 283 */     catch (ClassCastException e1) {
> /* 284 */       return false;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int hashCode() {
> /* 299 */     long bits = 1L;
> /* 300 */     bits = 31L * bits + this.x;
> /* 301 */     bits = 31L * bits + this.y;
> /* 302 */     return (int)(bits ^ bits >> 32L);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(int min, int max, Tuple2i t) {
> /* 314 */     if (t.x > max) {
> /* 315 */       this.x = max;
> /* 316 */     } else if (t.x < min) {
> /* 317 */       this.x = min;
> /*     */     } else {
> /* 319 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 322 */     if (t.y > max) {
> /* 323 */       this.y = max;
> /* 324 */     } else if (t.y < min) {
> /* 325 */       this.y = min;
> /*     */     } else {
> /* 327 */       this.y = t.y;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(int min, Tuple2i t) {
> /* 339 */     if (t.x < min) {
> /* 340 */       this.x = min;
> /*     */     } else {
> /* 342 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 345 */     if (t.y < min) {
> /* 346 */       this.y = min;
> /*     */     } else {
> /* 348 */       this.y = t.y;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(int max, Tuple2i t) {
> /* 360 */     if (t.x > max) {
> /* 361 */       this.x = max;
> /*     */     } else {
> /* 363 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 366 */     if (t.y > max) {
> /* 367 */       this.y = max;
> /*     */     } else {
> /* 369 */       this.y = t.y;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute(Tuple2i t) {
> /* 380 */     this.x = Math.abs(t.x);
> /* 381 */     this.y = Math.abs(t.y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(int min, int max) {
> /* 391 */     if (this.x > max) {
> /* 392 */       this.x = max;
> /* 393 */     } else if (this.x < min) {
> /* 394 */       this.x = min;
> /*     */     } 
> /*     */     
> /* 397 */     if (this.y > max) {
> /* 398 */       this.y = max;
> /* 399 */     } else if (this.y < min) {
> /* 400 */       this.y = min;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(int min) {
> /* 410 */     if (this.x < min) {
> /* 411 */       this.x = min;
> /*     */     }
> /* 413 */     if (this.y < min) {
> /* 414 */       this.y = min;
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(int max) {
> /* 423 */     if (this.x > max) {
> /* 424 */       this.x = max;
> /*     */     }
> /* 426 */     if (this.y > max) {
> /* 427 */       this.y = max;
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute() {
> /* 435 */     this.x = Math.abs(this.x);
> /* 436 */     this.y = Math.abs(this.y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object clone() {
> /*     */     try {
> /* 450 */       return super.clone();
> /* 451 */     } catch (CloneNotSupportedException e) {
> /*     */       
> /* 453 */       throw new InternalError();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final int getX() {
> /* 466 */     return this.x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setX(int x) {
> /* 478 */     this.x = x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final int getY() {
> /* 490 */     return this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setY(int y) {
> /* 502 */     this.y = y;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Tuple2i.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Tuple3b.java jd-gui/vecmath/Tuple3b.java
1,117c1,322
< package vecmath;
< 
< import java.io.Serializable;
< 
< public abstract class Tuple3b implements Serializable, Cloneable {
<    static final long serialVersionUID = -483782685323607044L;
<    public byte x;
<    public byte y;
<    public byte z;
< 
<    public Tuple3b(byte b1, byte b2, byte b3) {
<       this.x = b1;
<       this.y = b2;
<       this.z = b3;
<    }
< 
<    public Tuple3b(byte[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public Tuple3b(Tuple3b t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public Tuple3b() {
<       this.x = 0;
<       this.y = 0;
<       this.z = 0;
<    }
< 
<    public String toString() {
<       return "(" + (this.x & 255) + ", " + (this.y & 255) + ", " + (this.z & 255) + ")";
<    }
< 
<    public final void get(byte[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<    }
< 
<    public final void get(Tuple3b t1) {
<       t1.x = this.x;
<       t1.y = this.y;
<       t1.z = this.z;
<    }
< 
<    public final void set(Tuple3b t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public final void set(byte[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public boolean equals(Tuple3b t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple3b t2 = (Tuple3b)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public int hashCode() {
<       return (this.x & 255) << 0 | (this.y & 255) << 8 | (this.z & 255) << 16;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final byte getX() {
<       return this.x;
<    }
< 
<    public final void setX(byte x) {
<       this.x = x;
<    }
< 
<    public final byte getY() {
<       return this.y;
<    }
< 
<    public final void setY(byte y) {
<       this.y = y;
<    }
< 
<    public final byte getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(byte z) {
<       this.z = z;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class Tuple3b
> /*     */   implements Serializable, Cloneable
> /*     */ {
> /*     */   static final long serialVersionUID = -483782685323607044L;
> /*     */   public byte x;
> /*     */   public byte y;
> /*     */   public byte z;
> /*     */   
> /*     */   public Tuple3b(byte b1, byte b2, byte b3) {
> /*  72 */     this.x = b1;
> /*  73 */     this.y = b2;
> /*  74 */     this.z = b3;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3b(byte[] t) {
> /*  84 */     this.x = t[0];
> /*  85 */     this.y = t[1];
> /*  86 */     this.z = t[2];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3b(Tuple3b t1) {
> /*  96 */     this.x = t1.x;
> /*  97 */     this.y = t1.y;
> /*  98 */     this.z = t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3b() {
> /* 107 */     this.x = 0;
> /* 108 */     this.y = 0;
> /* 109 */     this.z = 0;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 120 */     return "(" + (this.x & 0xFF) + 
> /* 121 */       ", " + (this.y & 0xFF) + 
> /* 122 */       ", " + (this.z & 0xFF) + ")";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(byte[] t) {
> /* 134 */     t[0] = this.x;
> /* 135 */     t[1] = this.y;
> /* 136 */     t[2] = this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(Tuple3b t1) {
> /* 147 */     t1.x = this.x;
> /* 148 */     t1.y = this.y;
> /* 149 */     t1.z = this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple3b t1) {
> /* 160 */     this.x = t1.x;
> /* 161 */     this.y = t1.y;
> /* 162 */     this.z = t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(byte[] t) {
> /* 173 */     this.x = t[0];
> /* 174 */     this.y = t[1];
> /* 175 */     this.z = t[2];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Tuple3b t1) {
> /*     */     try {
> /* 188 */       return (this.x == t1.x && this.y == t1.y && this.z == t1.z);
> /*     */     } catch (NullPointerException e2) {
> /* 190 */       return false;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object t1) {
> /*     */     
> /* 204 */     try { Tuple3b t2 = (Tuple3b)t1;
> /* 205 */       return (this.x == t2.x && this.y == t2.y && this.z == t2.z); }
> /*     */     catch (NullPointerException e2)
> /* 207 */     { return false; }
> /* 208 */     catch (ClassCastException e1) { return false; }
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int hashCode() {
> /* 222 */     return (this.x & 0xFF) << 0 | (
> /* 223 */       this.y & 0xFF) << 8 | (
> /* 224 */       this.z & 0xFF) << 16;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object clone() {
> /*     */     try {
> /* 239 */       return super.clone();
> /* 240 */     } catch (CloneNotSupportedException e) {
> /*     */       
> /* 242 */       throw new InternalError();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final byte getX() {
> /* 255 */     return this.x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setX(byte x) {
> /* 267 */     this.x = x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final byte getY() {
> /* 279 */     return this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setY(byte y) {
> /* 291 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final byte getZ() {
> /* 302 */     return this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setZ(byte z) {
> /* 314 */     this.z = z;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Tuple3b.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Tuple3dModified.java jd-gui/vecmath/Tuple3dModified.java
1,411c1,762
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Tuple3dModified implements Serializable, Cloneable {
<    static final long serialVersionUID = 5542096614926168415L;
<    public double x;
<    public double y;
<    public double z;
< 
<    public Tuple3dModified(double x, double y, double z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public Tuple3dModified(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public Tuple3dModified(Tuple3dModified t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public Tuple3dModified(Tuple3f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<       this.z = (double)t1.z;
<    }
< 
<    public Tuple3dModified() {
<       this.x = 0.0D;
<       this.y = 0.0D;
<       this.z = 0.0D;
<    }
< 
<    public final void set(double x, double y, double z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public final void set(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public final void set(Tuple3dModified t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public final void set(Tuple3f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<       this.z = (double)t1.z;
<    }
< 
<    public final void get(double[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<    }
< 
<    public final void get(Tuple3dModified t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<    }
< 
<    public final void add(Tuple3dModified t1, Tuple3dModified t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<    }
< 
<    public final void add(Tuple3dModified t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<    }
< 
<    public final void sub(Tuple3dModified t1, Tuple3dModified t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<    }
< 
<    public final void sub(Tuple3dModified t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<    }
< 
<    public final void negate(Tuple3dModified t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<    }
< 
<    public final void scale(double s, Tuple3dModified t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<    }
< 
<    public final void scale(double s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<    }
< 
<    public final void scaleAdd(double s, Tuple3dModified t1, Tuple3dModified t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<    }
< 
<    /** @deprecated */
<    public final void scaleAdd(double s, Tuple3f t1) {
<       this.scaleAdd(s, (Tuple3dModified)(new Point3dModified(t1)));
<    }
< 
<    public final void scaleAdd(double s, Tuple3dModified t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ")";
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashDoubleBits(bits, this.x);
<       bits = VecMathUtil.hashDoubleBits(bits, this.y);
<       bits = VecMathUtil.hashDoubleBits(bits, this.z);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    public boolean equals(Tuple3dModified t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple3dModified t2 = (Tuple3dModified)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z;
<       } catch (ClassCastException var3) {
<          return false;
<       } catch (NullPointerException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple3dModified t1, double epsilon) {
<       double diff = this.x - t1.x;
<       if (Double.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Double.isNaN(diff)) {
<             return false;
<          } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
<             return false;
<          } else {
<             diff = this.z - t1.z;
<             if (Double.isNaN(diff)) {
<                return false;
<             } else {
<                return !((diff < 0.0D ? -diff : diff) > epsilon);
<             }
<          }
<       }
<    }
< 
<    /** @deprecated */
<    public final void clamp(float min, float max, Tuple3dModified t) {
<       this.clamp((double)min, (double)max, t);
<    }
< 
<    public final void clamp(double min, double max, Tuple3dModified t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMin(float min, Tuple3dModified t) {
<       this.clampMin((double)min, t);
<    }
< 
<    public final void clampMin(double min, Tuple3dModified t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMax(float max, Tuple3dModified t) {
<       this.clampMax((double)max, t);
<    }
< 
<    public final void clampMax(double max, Tuple3dModified t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple3dModified t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<    }
< 
<    /** @deprecated */
<    public final void clamp(float min, float max) {
<       this.clamp((double)min, (double)max);
<    }
< 
<    public final void clamp(double min, double max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMin(float min) {
<       this.clampMin((double)min);
<    }
< 
<    public final void clampMin(double min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMax(float max) {
<       this.clampMax((double)max);
<    }
< 
<    public final void clampMax(double max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<    }
< 
<    /** @deprecated */
<    public final void interpolate(Tuple3dModified t1, Tuple3dModified t2, float alpha) {
<       this.interpolate(t1, t2, (double)alpha);
<    }
< 
<    public final void interpolate(Tuple3dModified t1, Tuple3dModified t2, double alpha) {
<       this.x = (1.0D - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0D - alpha) * t1.y + alpha * t2.y;
<       this.z = (1.0D - alpha) * t1.z + alpha * t2.z;
<    }
< 
<    /** @deprecated */
<    public final void interpolate(Tuple3dModified t1, float alpha) {
<       this.interpolate(t1, (double)alpha);
<    }
< 
<    public final void interpolate(Tuple3dModified t1, double alpha) {
<       this.x = (1.0D - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0D - alpha) * this.y + alpha * t1.y;
<       this.z = (1.0D - alpha) * this.z + alpha * t1.z;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final double getX() {
<       return this.x;
<    }
< 
<    public final void setX(double x) {
<       this.x = x;
<    }
< 
<    public final double getY() {
<       return this.y;
<    }
< 
<    public final void setY(double y) {
<       this.y = y;
<    }
< 
<    public final double getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(double z) {
<       this.z = z;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Tuple3dModified
> /*     */   implements Serializable, Cloneable
> /*     */ {
> /*     */   static final long serialVersionUID = 5542096614926168415L;
> /*     */   public double x;
> /*     */   public double y;
> /*     */   public double z;
> /*     */   
> /*     */   public Tuple3dModified(double x, double y, double z) {
> /*  63 */     this.x = x;
> /*  64 */     this.y = y;
> /*  65 */     this.z = z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3dModified(double[] t) {
> /*  74 */     this.x = t[0];
> /*  75 */     this.y = t[1];
> /*  76 */     this.z = t[2];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3dModified(Tuple3dModified t1) {
> /*  85 */     this.x = t1.x;
> /*  86 */     this.y = t1.y;
> /*  87 */     this.z = t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3dModified(Tuple3f t1) {
> /*  96 */     this.x = t1.x;
> /*  97 */     this.y = t1.y;
> /*  98 */     this.z = t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3dModified() {
> /* 106 */     this.x = 0.0D;
> /* 107 */     this.y = 0.0D;
> /* 108 */     this.z = 0.0D;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(double x, double y, double z) {
> /* 119 */     this.x = x;
> /* 120 */     this.y = y;
> /* 121 */     this.z = z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(double[] t) {
> /* 131 */     this.x = t[0];
> /* 132 */     this.y = t[1];
> /* 133 */     this.z = t[2];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple3dModified t1) {
> /* 142 */     this.x = t1.x;
> /* 143 */     this.y = t1.y;
> /* 144 */     this.z = t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple3f t1) {
> /* 153 */     this.x = t1.x;
> /* 154 */     this.y = t1.y;
> /* 155 */     this.z = t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(double[] t) {
> /* 165 */     t[0] = this.x;
> /* 166 */     t[1] = this.y;
> /* 167 */     t[2] = this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(Tuple3dModified t) {
> /* 177 */     t.x = this.x;
> /* 178 */     t.y = this.y;
> /* 179 */     t.z = this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple3dModified t1, Tuple3dModified t2) {
> /* 190 */     t1.x += t2.x;
> /* 191 */     t1.y += t2.y;
> /* 192 */     t1.z += t2.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple3dModified t1) {
> /* 202 */     this.x += t1.x;
> /* 203 */     this.y += t1.y;
> /* 204 */     this.z += t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple3dModified t1, Tuple3dModified t2) {
> /* 215 */     t1.x -= t2.x;
> /* 216 */     t1.y -= t2.y;
> /* 217 */     t1.z -= t2.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple3dModified t1) {
> /* 227 */     this.x -= t1.x;
> /* 228 */     this.y -= t1.y;
> /* 229 */     this.z -= t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate(Tuple3dModified t1) {
> /* 239 */     this.x = -t1.x;
> /* 240 */     this.y = -t1.y;
> /* 241 */     this.z = -t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate() {
> /* 250 */     this.x = -this.x;
> /* 251 */     this.y = -this.y;
> /* 252 */     this.z = -this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(double s, Tuple3dModified t1) {
> /* 264 */     this.x = s * t1.x;
> /* 265 */     this.y = s * t1.y;
> /* 266 */     this.z = s * t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(double s) {
> /* 277 */     this.x *= s;
> /* 278 */     this.y *= s;
> /* 279 */     this.z *= s;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(double s, Tuple3dModified t1, Tuple3dModified t2) {
> /* 292 */     this.x = s * t1.x + t2.x;
> /* 293 */     this.y = s * t1.y + t2.y;
> /* 294 */     this.z = s * t1.z + t2.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(double s, Tuple3f t1) {
> /* 302 */     scaleAdd(s, new Point3dModified(t1));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(double s, Tuple3dModified t1) {
> /* 313 */     this.x = s * this.x + t1.x;
> /* 314 */     this.y = s * this.y + t1.y;
> /* 315 */     this.z = s * this.z + t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 327 */     return "(" + this.x + ", " + this.y + ", " + this.z + ")";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int hashCode() {
> /* 341 */     long bits = 1L;
> /* 342 */     bits = VecMathUtil.hashDoubleBits(bits, this.x);
> /* 343 */     bits = VecMathUtil.hashDoubleBits(bits, this.y);
> /* 344 */     bits = VecMathUtil.hashDoubleBits(bits, this.z);
> /* 345 */     return VecMathUtil.hashFinish(bits);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Tuple3dModified t1) {
> /*     */     try {
> /* 358 */       return (this.x == t1.x && this.y == t1.y && this.z == t1.z);
> /*     */     } catch (NullPointerException e2) {
> /* 360 */       return false;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object t1) {
> /*     */     
> /* 374 */     try { Tuple3dModified t2 = (Tuple3dModified)t1;
> /* 375 */       return (this.x == t2.x && this.y == t2.y && this.z == t2.z); }
> /*     */     catch (ClassCastException e1)
> /* 377 */     { return false; }
> /* 378 */     catch (NullPointerException e2) { return false; }
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean epsilonEquals(Tuple3dModified t1, double epsilon) {
> /* 395 */     double diff = this.x - t1.x;
> /* 396 */     if (Double.isNaN(diff)) return false; 
> /* 397 */     if (((diff < 0.0D) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 399 */     diff = this.y - t1.y;
> /* 400 */     if (Double.isNaN(diff)) return false; 
> /* 401 */     if (((diff < 0.0D) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 403 */     diff = this.z - t1.z;
> /* 404 */     if (Double.isNaN(diff)) return false; 
> /* 405 */     if (((diff < 0.0D) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 407 */     return true;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(float min, float max, Tuple3dModified t) {
> /* 416 */     clamp(min, max, t);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(double min, double max, Tuple3dModified t) {
> /* 428 */     if (t.x > max) {
> /* 429 */       this.x = max;
> /* 430 */     } else if (t.x < min) {
> /* 431 */       this.x = min;
> /*     */     } else {
> /* 433 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 436 */     if (t.y > max) {
> /* 437 */       this.y = max;
> /* 438 */     } else if (t.y < min) {
> /* 439 */       this.y = min;
> /*     */     } else {
> /* 441 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 444 */     if (t.z > max) {
> /* 445 */       this.z = max;
> /* 446 */     } else if (t.z < min) {
> /* 447 */       this.z = min;
> /*     */     } else {
> /* 449 */       this.z = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(float min, Tuple3dModified t) {
> /* 459 */     clampMin(min, t);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(double min, Tuple3dModified t) {
> /* 470 */     if (t.x < min) {
> /* 471 */       this.x = min;
> /*     */     } else {
> /* 473 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 476 */     if (t.y < min) {
> /* 477 */       this.y = min;
> /*     */     } else {
> /* 479 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 482 */     if (t.z < min) {
> /* 483 */       this.z = min;
> /*     */     } else {
> /* 485 */       this.z = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(float max, Tuple3dModified t) {
> /* 495 */     clampMax(max, t);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(double max, Tuple3dModified t) {
> /* 506 */     if (t.x > max) {
> /* 507 */       this.x = max;
> /*     */     } else {
> /* 509 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 512 */     if (t.y > max) {
> /* 513 */       this.y = max;
> /*     */     } else {
> /* 515 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 518 */     if (t.z > max) {
> /* 519 */       this.z = max;
> /*     */     } else {
> /* 521 */       this.z = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute(Tuple3dModified t) {
> /* 534 */     this.x = Math.abs(t.x);
> /* 535 */     this.y = Math.abs(t.y);
> /* 536 */     this.z = Math.abs(t.z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(float min, float max) {
> /* 545 */     clamp(min, max);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(double min, double max) {
> /* 555 */     if (this.x > max) {
> /* 556 */       this.x = max;
> /* 557 */     } else if (this.x < min) {
> /* 558 */       this.x = min;
> /*     */     } 
> /*     */     
> /* 561 */     if (this.y > max) {
> /* 562 */       this.y = max;
> /* 563 */     } else if (this.y < min) {
> /* 564 */       this.y = min;
> /*     */     } 
> /*     */     
> /* 567 */     if (this.z > max) {
> /* 568 */       this.z = max;
> /* 569 */     } else if (this.z < min) {
> /* 570 */       this.z = min;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(float min) {
> /* 580 */     clampMin(min);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(double min) {
> /* 589 */     if (this.x < min) this.x = min; 
> /* 590 */     if (this.y < min) this.y = min; 
> /* 591 */     if (this.z < min) this.z = min;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(float max) {
> /* 600 */     clampMax(max);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(double max) {
> /* 609 */     if (this.x > max) this.x = max; 
> /* 610 */     if (this.y > max) this.y = max; 
> /* 611 */     if (this.z > max) this.z = max;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute() {
> /* 620 */     this.x = Math.abs(this.x);
> /* 621 */     this.y = Math.abs(this.y);
> /* 622 */     this.z = Math.abs(this.z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void interpolate(Tuple3dModified t1, Tuple3dModified t2, float alpha) {
> /* 630 */     interpolate(t1, t2, alpha);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void interpolate(Tuple3dModified t1, Tuple3dModified t2, double alpha) {
> /* 642 */     this.x = (1.0D - alpha) * t1.x + alpha * t2.x;
> /* 643 */     this.y = (1.0D - alpha) * t1.y + alpha * t2.y;
> /* 644 */     this.z = (1.0D - alpha) * t1.z + alpha * t2.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void interpolate(Tuple3dModified t1, float alpha) {
> /* 652 */     interpolate(t1, alpha);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void interpolate(Tuple3dModified t1, double alpha) {
> /* 663 */     this.x = (1.0D - alpha) * this.x + alpha * t1.x;
> /* 664 */     this.y = (1.0D - alpha) * this.y + alpha * t1.y;
> /* 665 */     this.z = (1.0D - alpha) * this.z + alpha * t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object clone() {
> /*     */     try {
> /* 680 */       return super.clone();
> /* 681 */     } catch (CloneNotSupportedException e) {
> /*     */       
> /* 683 */       throw new InternalError();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double getX() {
> /* 695 */     return this.x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setX(double x) {
> /* 707 */     this.x = x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double getY() {
> /* 719 */     return this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setY(double y) {
> /* 731 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double getZ() {
> /* 742 */     return this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setZ(double z) {
> /* 754 */     this.z = z;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Tuple3dModified.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Tuple3f.java jd-gui/vecmath/Tuple3f.java
1,366c1,717
< package vecmath;
< 
< import java.io.Serializable;
< 
< public abstract class Tuple3f implements Serializable, Cloneable {
<    static final long serialVersionUID = 5019834619484343712L;
<    public float x;
<    public float y;
<    public float z;
< 
<    public Tuple3f(float x, float y, float z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public Tuple3f(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public Tuple3f(Tuple3f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public Tuple3f(Tuple3dModified t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<       this.z = (float)t1.z;
<    }
< 
<    public Tuple3f() {
<       this.x = 0.0F;
<       this.y = 0.0F;
<       this.z = 0.0F;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ")";
<    }
< 
<    public final void set(float x, float y, float z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public final void set(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public final void set(Tuple3f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public final void set(Tuple3dModified t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<       this.z = (float)t1.z;
<    }
< 
<    public final void get(float[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<    }
< 
<    public final void get(Tuple3f t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<    }
< 
<    public final void add(Tuple3f t1, Tuple3f t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<    }
< 
<    public final void add(Tuple3f t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<    }
< 
<    public final void sub(Tuple3f t1, Tuple3f t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<    }
< 
<    public final void sub(Tuple3f t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<    }
< 
<    public final void negate(Tuple3f t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<    }
< 
<    public final void scale(float s, Tuple3f t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<    }
< 
<    public final void scale(float s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<    }
< 
<    public final void scaleAdd(float s, Tuple3f t1, Tuple3f t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<    }
< 
<    public final void scaleAdd(float s, Tuple3f t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<    }
< 
<    public boolean equals(Tuple3f t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple3f t2 = (Tuple3f)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple3f t1, float epsilon) {
<       float diff = this.x - t1.x;
<       if (Float.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Float.isNaN(diff)) {
<             return false;
<          } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
<             return false;
<          } else {
<             diff = this.z - t1.z;
<             if (Float.isNaN(diff)) {
<                return false;
<             } else {
<                return !((diff < 0.0F ? -diff : diff) > epsilon);
<             }
<          }
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashFloatBits(bits, this.x);
<       bits = VecMathUtil.hashFloatBits(bits, this.y);
<       bits = VecMathUtil.hashFloatBits(bits, this.z);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    public final void clamp(float min, float max, Tuple3f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void clampMin(float min, Tuple3f t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void clampMax(float max, Tuple3f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple3f t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<    }
< 
<    public final void clamp(float min, float max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    public final void clampMin(float min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    public final void clampMax(float max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<    }
< 
<    public final void interpolate(Tuple3f t1, Tuple3f t2, float alpha) {
<       this.x = (1.0F - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0F - alpha) * t1.y + alpha * t2.y;
<       this.z = (1.0F - alpha) * t1.z + alpha * t2.z;
<    }
< 
<    public final void interpolate(Tuple3f t1, float alpha) {
<       this.x = (1.0F - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0F - alpha) * this.y + alpha * t1.y;
<       this.z = (1.0F - alpha) * this.z + alpha * t1.z;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final float getX() {
<       return this.x;
<    }
< 
<    public final void setX(float x) {
<       this.x = x;
<    }
< 
<    public final float getY() {
<       return this.y;
<    }
< 
<    public final void setY(float y) {
<       this.y = y;
<    }
< 
<    public final float getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(float z) {
<       this.z = z;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class Tuple3f
> /*     */   implements Serializable, Cloneable
> /*     */ {
> /*     */   static final long serialVersionUID = 5019834619484343712L;
> /*     */   public float x;
> /*     */   public float y;
> /*     */   public float z;
> /*     */   
> /*     */   public Tuple3f(float x, float y, float z) {
> /*  63 */     this.x = x;
> /*  64 */     this.y = y;
> /*  65 */     this.z = z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3f(float[] t) {
> /*  75 */     this.x = t[0];
> /*  76 */     this.y = t[1];
> /*  77 */     this.z = t[2];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3f(Tuple3f t1) {
> /*  87 */     this.x = t1.x;
> /*  88 */     this.y = t1.y;
> /*  89 */     this.z = t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3f(Tuple3dModified t1) {
> /*  99 */     this.x = (float)t1.x;
> /* 100 */     this.y = (float)t1.y;
> /* 101 */     this.z = (float)t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3f() {
> /* 110 */     this.x = 0.0F;
> /* 111 */     this.y = 0.0F;
> /* 112 */     this.z = 0.0F;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 123 */     return "(" + this.x + ", " + this.y + ", " + this.z + ")";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(float x, float y, float z) {
> /* 135 */     this.x = x;
> /* 136 */     this.y = y;
> /* 137 */     this.z = z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(float[] t) {
> /* 148 */     this.x = t[0];
> /* 149 */     this.y = t[1];
> /* 150 */     this.z = t[2];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple3f t1) {
> /* 160 */     this.x = t1.x;
> /* 161 */     this.y = t1.y;
> /* 162 */     this.z = t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple3dModified t1) {
> /* 172 */     this.x = (float)t1.x;
> /* 173 */     this.y = (float)t1.y;
> /* 174 */     this.z = (float)t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(float[] t) {
> /* 184 */     t[0] = this.x;
> /* 185 */     t[1] = this.y;
> /* 186 */     t[2] = this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(Tuple3f t) {
> /* 196 */     t.x = this.x;
> /* 197 */     t.y = this.y;
> /* 198 */     t.z = this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple3f t1, Tuple3f t2) {
> /* 209 */     t1.x += t2.x;
> /* 210 */     t1.y += t2.y;
> /* 211 */     t1.z += t2.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple3f t1) {
> /* 221 */     this.x += t1.x;
> /* 222 */     this.y += t1.y;
> /* 223 */     this.z += t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple3f t1, Tuple3f t2) {
> /* 235 */     t1.x -= t2.x;
> /* 236 */     t1.y -= t2.y;
> /* 237 */     t1.z -= t2.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple3f t1) {
> /* 248 */     this.x -= t1.x;
> /* 249 */     this.y -= t1.y;
> /* 250 */     this.z -= t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate(Tuple3f t1) {
> /* 260 */     this.x = -t1.x;
> /* 261 */     this.y = -t1.y;
> /* 262 */     this.z = -t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate() {
> /* 271 */     this.x = -this.x;
> /* 272 */     this.y = -this.y;
> /* 273 */     this.z = -this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(float s, Tuple3f t1) {
> /* 285 */     this.x = s * t1.x;
> /* 286 */     this.y = s * t1.y;
> /* 287 */     this.z = s * t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(float s) {
> /* 298 */     this.x *= s;
> /* 299 */     this.y *= s;
> /* 300 */     this.z *= s;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(float s, Tuple3f t1, Tuple3f t2) {
> /* 313 */     this.x = s * t1.x + t2.x;
> /* 314 */     this.y = s * t1.y + t2.y;
> /* 315 */     this.z = s * t1.z + t2.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(float s, Tuple3f t1) {
> /* 328 */     this.x = s * this.x + t1.x;
> /* 329 */     this.y = s * this.y + t1.y;
> /* 330 */     this.z = s * this.z + t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Tuple3f t1) {
> /*     */     try {
> /* 344 */       return (this.x == t1.x && this.y == t1.y && this.z == t1.z);
> /*     */     } catch (NullPointerException e2) {
> /* 346 */       return false;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object t1) {
> /*     */     
> /* 359 */     try { Tuple3f t2 = (Tuple3f)t1;
> /* 360 */       return (this.x == t2.x && this.y == t2.y && this.z == t2.z); }
> /*     */     catch (NullPointerException e2)
> /* 362 */     { return false; }
> /* 363 */     catch (ClassCastException e1) { return false; }
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean epsilonEquals(Tuple3f t1, float epsilon) {
> /* 380 */     float diff = this.x - t1.x;
> /* 381 */     if (Float.isNaN(diff)) return false; 
> /* 382 */     if (((diff < 0.0F) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 384 */     diff = this.y - t1.y;
> /* 385 */     if (Float.isNaN(diff)) return false; 
> /* 386 */     if (((diff < 0.0F) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 388 */     diff = this.z - t1.z;
> /* 389 */     if (Float.isNaN(diff)) return false; 
> /* 390 */     if (((diff < 0.0F) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 392 */     return true;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int hashCode() {
> /* 407 */     long bits = 1L;
> /* 408 */     bits = VecMathUtil.hashFloatBits(bits, this.x);
> /* 409 */     bits = VecMathUtil.hashFloatBits(bits, this.y);
> /* 410 */     bits = VecMathUtil.hashFloatBits(bits, this.z);
> /* 411 */     return VecMathUtil.hashFinish(bits);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(float min, float max, Tuple3f t) {
> /* 425 */     if (t.x > max) {
> /* 426 */       this.x = max;
> /* 427 */     } else if (t.x < min) {
> /* 428 */       this.x = min;
> /*     */     } else {
> /* 430 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 433 */     if (t.y > max) {
> /* 434 */       this.y = max;
> /* 435 */     } else if (t.y < min) {
> /* 436 */       this.y = min;
> /*     */     } else {
> /* 438 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 441 */     if (t.z > max) {
> /* 442 */       this.z = max;
> /* 443 */     } else if (t.z < min) {
> /* 444 */       this.z = min;
> /*     */     } else {
> /* 446 */       this.z = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(float min, Tuple3f t) {
> /* 460 */     if (t.x < min) {
> /* 461 */       this.x = min;
> /*     */     } else {
> /* 463 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 466 */     if (t.y < min) {
> /* 467 */       this.y = min;
> /*     */     } else {
> /* 469 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 472 */     if (t.z < min) {
> /* 473 */       this.z = min;
> /*     */     } else {
> /* 475 */       this.z = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(float max, Tuple3f t) {
> /* 489 */     if (t.x > max) {
> /* 490 */       this.x = max;
> /*     */     } else {
> /* 492 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 495 */     if (t.y > max) {
> /* 496 */       this.y = max;
> /*     */     } else {
> /* 498 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 501 */     if (t.z > max) {
> /* 502 */       this.z = max;
> /*     */     } else {
> /* 504 */       this.z = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute(Tuple3f t) {
> /* 517 */     this.x = Math.abs(t.x);
> /* 518 */     this.y = Math.abs(t.y);
> /* 519 */     this.z = Math.abs(t.z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(float min, float max) {
> /* 531 */     if (this.x > max) {
> /* 532 */       this.x = max;
> /* 533 */     } else if (this.x < min) {
> /* 534 */       this.x = min;
> /*     */     } 
> /*     */     
> /* 537 */     if (this.y > max) {
> /* 538 */       this.y = max;
> /* 539 */     } else if (this.y < min) {
> /* 540 */       this.y = min;
> /*     */     } 
> /*     */     
> /* 543 */     if (this.z > max) {
> /* 544 */       this.z = max;
> /* 545 */     } else if (this.z < min) {
> /* 546 */       this.z = min;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(float min) {
> /* 558 */     if (this.x < min) this.x = min; 
> /* 559 */     if (this.y < min) this.y = min; 
> /* 560 */     if (this.z < min) this.z = min;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(float max) {
> /* 571 */     if (this.x > max) this.x = max; 
> /* 572 */     if (this.y > max) this.y = max; 
> /* 573 */     if (this.z > max) this.z = max;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute() {
> /* 583 */     this.x = Math.abs(this.x);
> /* 584 */     this.y = Math.abs(this.y);
> /* 585 */     this.z = Math.abs(this.z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void interpolate(Tuple3f t1, Tuple3f t2, float alpha) {
> /* 599 */     this.x = (1.0F - alpha) * t1.x + alpha * t2.x;
> /* 600 */     this.y = (1.0F - alpha) * t1.y + alpha * t2.y;
> /* 601 */     this.z = (1.0F - alpha) * t1.z + alpha * t2.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void interpolate(Tuple3f t1, float alpha) {
> /* 615 */     this.x = (1.0F - alpha) * this.x + alpha * t1.x;
> /* 616 */     this.y = (1.0F - alpha) * this.y + alpha * t1.y;
> /* 617 */     this.z = (1.0F - alpha) * this.z + alpha * t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object clone() {
> /*     */     try {
> /* 634 */       return super.clone();
> /* 635 */     } catch (CloneNotSupportedException e) {
> /*     */       
> /* 637 */       throw new InternalError();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float getX() {
> /* 650 */     return this.x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setX(float x) {
> /* 662 */     this.x = x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float getY() {
> /* 674 */     return this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setY(float y) {
> /* 686 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float getZ() {
> /* 697 */     return this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setZ(float z) {
> /* 709 */     this.z = z;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Tuple3f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Tuple3i.java jd-gui/vecmath/Tuple3i.java
1,311c1,594
< package vecmath;
< 
< import java.io.Serializable;
< 
< public abstract class Tuple3i implements Serializable, Cloneable {
<    static final long serialVersionUID = -732740491767276200L;
<    public int x;
<    public int y;
<    public int z;
< 
<    public Tuple3i(int x, int y, int z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public Tuple3i(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public Tuple3i(Tuple3i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public Tuple3i() {
<       this.x = 0;
<       this.y = 0;
<       this.z = 0;
<    }
< 
<    public final void set(int x, int y, int z) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<    }
< 
<    public final void set(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<    }
< 
<    public final void set(Tuple3i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<    }
< 
<    public final void get(int[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<    }
< 
<    public final void get(Tuple3i t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<    }
< 
<    public final void add(Tuple3i t1, Tuple3i t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<    }
< 
<    public final void add(Tuple3i t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<    }
< 
<    public final void sub(Tuple3i t1, Tuple3i t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<    }
< 
<    public final void sub(Tuple3i t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<    }
< 
<    public final void negate(Tuple3i t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<    }
< 
<    public final void scale(int s, Tuple3i t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<    }
< 
<    public final void scale(int s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<    }
< 
<    public final void scaleAdd(int s, Tuple3i t1, Tuple3i t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<    }
< 
<    public final void scaleAdd(int s, Tuple3i t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ")";
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple3i t2 = (Tuple3i)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = 31L * bits + (long)this.x;
<       bits = 31L * bits + (long)this.y;
<       bits = 31L * bits + (long)this.z;
<       return (int)(bits ^ bits >> 32);
<    }
< 
<    public final void clamp(int min, int max, Tuple3i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void clampMin(int min, Tuple3i t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void clampMax(int max, Tuple3i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple3i t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<    }
< 
<    public final void clamp(int min, int max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    public final void clampMin(int min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<    }
< 
<    public final void clampMax(int max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final int getX() {
<       return this.x;
<    }
< 
<    public final void setX(int x) {
<       this.x = x;
<    }
< 
<    public final int getY() {
<       return this.y;
<    }
< 
<    public final void setY(int y) {
<       this.y = y;
<    }
< 
<    public final int getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(int z) {
<       this.z = z;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class Tuple3i
> /*     */   implements Serializable, Cloneable
> /*     */ {
> /*     */   static final long serialVersionUID = -732740491767276200L;
> /*     */   public int x;
> /*     */   public int y;
> /*     */   public int z;
> /*     */   
> /*     */   public Tuple3i(int x, int y, int z) {
> /*  64 */     this.x = x;
> /*  65 */     this.y = y;
> /*  66 */     this.z = z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3i(int[] t) {
> /*  75 */     this.x = t[0];
> /*  76 */     this.y = t[1];
> /*  77 */     this.z = t[2];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3i(Tuple3i t1) {
> /*  87 */     this.x = t1.x;
> /*  88 */     this.y = t1.y;
> /*  89 */     this.z = t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple3i() {
> /*  97 */     this.x = 0;
> /*  98 */     this.y = 0;
> /*  99 */     this.z = 0;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(int x, int y, int z) {
> /* 111 */     this.x = x;
> /* 112 */     this.y = y;
> /* 113 */     this.z = z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(int[] t) {
> /* 123 */     this.x = t[0];
> /* 124 */     this.y = t[1];
> /* 125 */     this.z = t[2];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple3i t1) {
> /* 134 */     this.x = t1.x;
> /* 135 */     this.y = t1.y;
> /* 136 */     this.z = t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(int[] t) {
> /* 145 */     t[0] = this.x;
> /* 146 */     t[1] = this.y;
> /* 147 */     t[2] = this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(Tuple3i t) {
> /* 156 */     t.x = this.x;
> /* 157 */     t.y = this.y;
> /* 158 */     t.z = this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple3i t1, Tuple3i t2) {
> /* 168 */     t1.x += t2.x;
> /* 169 */     t1.y += t2.y;
> /* 170 */     t1.z += t2.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple3i t1) {
> /* 179 */     this.x += t1.x;
> /* 180 */     this.y += t1.y;
> /* 181 */     this.z += t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple3i t1, Tuple3i t2) {
> /* 192 */     t1.x -= t2.x;
> /* 193 */     t1.y -= t2.y;
> /* 194 */     t1.z -= t2.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple3i t1) {
> /* 204 */     this.x -= t1.x;
> /* 205 */     this.y -= t1.y;
> /* 206 */     this.z -= t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate(Tuple3i t1) {
> /* 215 */     this.x = -t1.x;
> /* 216 */     this.y = -t1.y;
> /* 217 */     this.z = -t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate() {
> /* 225 */     this.x = -this.x;
> /* 226 */     this.y = -this.y;
> /* 227 */     this.z = -this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(int s, Tuple3i t1) {
> /* 238 */     this.x = s * t1.x;
> /* 239 */     this.y = s * t1.y;
> /* 240 */     this.z = s * t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(int s) {
> /* 250 */     this.x *= s;
> /* 251 */     this.y *= s;
> /* 252 */     this.z *= s;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(int s, Tuple3i t1, Tuple3i t2) {
> /* 264 */     this.x = s * t1.x + t2.x;
> /* 265 */     this.y = s * t1.y + t2.y;
> /* 266 */     this.z = s * t1.z + t2.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(int s, Tuple3i t1) {
> /* 277 */     this.x = s * this.x + t1.x;
> /* 278 */     this.y = s * this.y + t1.y;
> /* 279 */     this.z = s * this.z + t1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 290 */     return "(" + this.x + ", " + this.y + ", " + this.z + ")";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object t1) {
> /*     */     try {
> /* 303 */       Tuple3i t2 = (Tuple3i)t1;
> /* 304 */       return (this.x == t2.x && this.y == t2.y && this.z == t2.z);
> /*     */     }
> /* 306 */     catch (NullPointerException e2) {
> /* 307 */       return false;
> /*     */     }
> /* 309 */     catch (ClassCastException e1) {
> /* 310 */       return false;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int hashCode() {
> /* 325 */     long bits = 1L;
> /* 326 */     bits = 31L * bits + this.x;
> /* 327 */     bits = 31L * bits + this.y;
> /* 328 */     bits = 31L * bits + this.z;
> /* 329 */     return (int)(bits ^ bits >> 32L);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(int min, int max, Tuple3i t) {
> /* 341 */     if (t.x > max) {
> /* 342 */       this.x = max;
> /* 343 */     } else if (t.x < min) {
> /* 344 */       this.x = min;
> /*     */     } else {
> /* 346 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 349 */     if (t.y > max) {
> /* 350 */       this.y = max;
> /* 351 */     } else if (t.y < min) {
> /* 352 */       this.y = min;
> /*     */     } else {
> /* 354 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 357 */     if (t.z > max) {
> /* 358 */       this.z = max;
> /* 359 */     } else if (t.z < min) {
> /* 360 */       this.z = min;
> /*     */     } else {
> /* 362 */       this.z = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(int min, Tuple3i t) {
> /* 374 */     if (t.x < min) {
> /* 375 */       this.x = min;
> /*     */     } else {
> /* 377 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 380 */     if (t.y < min) {
> /* 381 */       this.y = min;
> /*     */     } else {
> /* 383 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 386 */     if (t.z < min) {
> /* 387 */       this.z = min;
> /*     */     } else {
> /* 389 */       this.z = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(int max, Tuple3i t) {
> /* 401 */     if (t.x > max) {
> /* 402 */       this.x = max;
> /*     */     } else {
> /* 404 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 407 */     if (t.y > max) {
> /* 408 */       this.y = max;
> /*     */     } else {
> /* 410 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 413 */     if (t.z > max) {
> /* 414 */       this.z = max;
> /*     */     } else {
> /* 416 */       this.z = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute(Tuple3i t) {
> /* 427 */     this.x = Math.abs(t.x);
> /* 428 */     this.y = Math.abs(t.y);
> /* 429 */     this.z = Math.abs(t.z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(int min, int max) {
> /* 439 */     if (this.x > max) {
> /* 440 */       this.x = max;
> /* 441 */     } else if (this.x < min) {
> /* 442 */       this.x = min;
> /*     */     } 
> /*     */     
> /* 445 */     if (this.y > max) {
> /* 446 */       this.y = max;
> /* 447 */     } else if (this.y < min) {
> /* 448 */       this.y = min;
> /*     */     } 
> /*     */     
> /* 451 */     if (this.z > max) {
> /* 452 */       this.z = max;
> /* 453 */     } else if (this.z < min) {
> /* 454 */       this.z = min;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(int min) {
> /* 464 */     if (this.x < min) {
> /* 465 */       this.x = min;
> /*     */     }
> /* 467 */     if (this.y < min) {
> /* 468 */       this.y = min;
> /*     */     }
> /* 470 */     if (this.z < min) {
> /* 471 */       this.z = min;
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(int max) {
> /* 480 */     if (this.x > max) {
> /* 481 */       this.x = max;
> /*     */     }
> /* 483 */     if (this.y > max) {
> /* 484 */       this.y = max;
> /*     */     }
> /* 486 */     if (this.z > max) {
> /* 487 */       this.z = max;
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute() {
> /* 495 */     this.x = Math.abs(this.x);
> /* 496 */     this.y = Math.abs(this.y);
> /* 497 */     this.z = Math.abs(this.z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object clone() {
> /*     */     try {
> /* 512 */       return super.clone();
> /* 513 */     } catch (CloneNotSupportedException e) {
> /*     */       
> /* 515 */       throw new InternalError();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final int getX() {
> /* 528 */     return this.x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setX(int x) {
> /* 540 */     this.x = x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final int getY() {
> /* 552 */     return this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setY(int y) {
> /* 564 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final int getZ() {
> /* 574 */     return this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setZ(int z) {
> /* 586 */     this.z = z;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Tuple3i.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Tuple4b.java jd-gui/vecmath/Tuple4b.java
1,134c1,363
< package vecmath;
< 
< import java.io.Serializable;
< 
< public abstract class Tuple4b implements Serializable, Cloneable {
<    static final long serialVersionUID = -8226727741811898211L;
<    public byte x;
<    public byte y;
<    public byte z;
<    public byte w;
< 
<    public Tuple4b(byte b1, byte b2, byte b3, byte b4) {
<       this.x = b1;
<       this.y = b2;
<       this.z = b3;
<       this.w = b4;
<    }
< 
<    public Tuple4b(byte[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public Tuple4b(Tuple4b t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public Tuple4b() {
<       this.x = 0;
<       this.y = 0;
<       this.z = 0;
<       this.w = 0;
<    }
< 
<    public String toString() {
<       return "(" + (this.x & 255) + ", " + (this.y & 255) + ", " + (this.z & 255) + ", " + (this.w & 255) + ")";
<    }
< 
<    public final void get(byte[] b) {
<       b[0] = this.x;
<       b[1] = this.y;
<       b[2] = this.z;
<       b[3] = this.w;
<    }
< 
<    public final void get(Tuple4b t1) {
<       t1.x = this.x;
<       t1.y = this.y;
<       t1.z = this.z;
<       t1.w = this.w;
<    }
< 
<    public final void set(Tuple4b t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public final void set(byte[] b) {
<       this.x = b[0];
<       this.y = b[1];
<       this.z = b[2];
<       this.w = b[3];
<    }
< 
<    public boolean equals(Tuple4b t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z && this.w == t1.w;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple4b t2 = (Tuple4b)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public int hashCode() {
<       return (this.x & 255) << 0 | (this.y & 255) << 8 | (this.z & 255) << 16 | (this.w & 255) << 24;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final byte getX() {
<       return this.x;
<    }
< 
<    public final void setX(byte x) {
<       this.x = x;
<    }
< 
<    public final byte getY() {
<       return this.y;
<    }
< 
<    public final void setY(byte y) {
<       this.y = y;
<    }
< 
<    public final byte getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(byte z) {
<       this.z = z;
<    }
< 
<    public final byte getW() {
<       return this.w;
<    }
< 
<    public final void setW(byte w) {
<       this.w = w;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class Tuple4b
> /*     */   implements Serializable, Cloneable
> /*     */ {
> /*     */   static final long serialVersionUID = -8226727741811898211L;
> /*     */   public byte x;
> /*     */   public byte y;
> /*     */   public byte z;
> /*     */   public byte w;
> /*     */   
> /*     */   public Tuple4b(byte b1, byte b2, byte b3, byte b4) {
> /*  78 */     this.x = b1;
> /*  79 */     this.y = b2;
> /*  80 */     this.z = b3;
> /*  81 */     this.w = b4;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4b(byte[] t) {
> /*  91 */     this.x = t[0];
> /*  92 */     this.y = t[1];
> /*  93 */     this.z = t[2];
> /*  94 */     this.w = t[3];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4b(Tuple4b t1) {
> /* 104 */     this.x = t1.x;
> /* 105 */     this.y = t1.y;
> /* 106 */     this.z = t1.z;
> /* 107 */     this.w = t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4b() {
> /* 116 */     this.x = 0;
> /* 117 */     this.y = 0;
> /* 118 */     this.z = 0;
> /* 119 */     this.w = 0;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 130 */     return "(" + (this.x & 0xFF) + 
> /* 131 */       ", " + (this.y & 0xFF) + 
> /* 132 */       ", " + (this.z & 0xFF) + 
> /* 133 */       ", " + (this.w & 0xFF) + ")";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(byte[] b) {
> /* 144 */     b[0] = this.x;
> /* 145 */     b[1] = this.y;
> /* 146 */     b[2] = this.z;
> /* 147 */     b[3] = this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(Tuple4b t1) {
> /* 158 */     t1.x = this.x;
> /* 159 */     t1.y = this.y;
> /* 160 */     t1.z = this.z;
> /* 161 */     t1.w = this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple4b t1) {
> /* 172 */     this.x = t1.x;
> /* 173 */     this.y = t1.y;
> /* 174 */     this.z = t1.z;
> /* 175 */     this.w = t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(byte[] b) {
> /* 186 */     this.x = b[0];
> /* 187 */     this.y = b[1];
> /* 188 */     this.z = b[2];
> /* 189 */     this.w = b[3];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Tuple4b t1) {
> /*     */     try {
> /* 201 */       return (this.x == t1.x && this.y == t1.y && 
> /* 202 */         this.z == t1.z && this.w == t1.w);
> /*     */     } catch (NullPointerException e2) {
> /* 204 */       return false;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object t1) {
> /*     */     
> /* 218 */     try { Tuple4b t2 = (Tuple4b)t1;
> /* 219 */       return (this.x == t2.x && this.y == t2.y && 
> /* 220 */         this.z == t2.z && this.w == t2.w); }
> /*     */     catch (NullPointerException e2)
> /* 222 */     { return false; }
> /* 223 */     catch (ClassCastException e1) { return false; }
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int hashCode() {
> /* 238 */     return (this.x & 0xFF) << 0 | (
> /* 239 */       this.y & 0xFF) << 8 | (
> /* 240 */       this.z & 0xFF) << 16 | (
> /* 241 */       this.w & 0xFF) << 24;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object clone() {
> /*     */     try {
> /* 256 */       return super.clone();
> /* 257 */     } catch (CloneNotSupportedException e) {
> /*     */       
> /* 259 */       throw new InternalError();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final byte getX() {
> /* 272 */     return this.x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setX(byte x) {
> /* 284 */     this.x = x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final byte getY() {
> /* 296 */     return this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setY(byte y) {
> /* 308 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final byte getZ() {
> /* 319 */     return this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setZ(byte z) {
> /* 331 */     this.z = z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final byte getW() {
> /* 343 */     return this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setW(byte w) {
> /* 355 */     this.w = w;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Tuple4b.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Tuple4d.java jd-gui/vecmath/Tuple4d.java
1,487c1,871
< package vecmath;
< 
< import java.io.Serializable;
< 
< public abstract class Tuple4d implements Serializable, Cloneable {
<    static final long serialVersionUID = -4748953690425311052L;
<    public double x;
<    public double y;
<    public double z;
<    public double w;
< 
<    public Tuple4d(double x, double y, double z, double w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public Tuple4d(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public Tuple4d(Tuple4d t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public Tuple4d(Tuple4f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<       this.z = (double)t1.z;
<       this.w = (double)t1.w;
<    }
< 
<    public Tuple4d() {
<       this.x = 0.0D;
<       this.y = 0.0D;
<       this.z = 0.0D;
<       this.w = 0.0D;
<    }
< 
<    public final void set(double x, double y, double z, double w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public final void set(double[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public final void set(Tuple4d t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public final void set(Tuple4f t1) {
<       this.x = (double)t1.x;
<       this.y = (double)t1.y;
<       this.z = (double)t1.z;
<       this.w = (double)t1.w;
<    }
< 
<    public final void get(double[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<       t[3] = this.w;
<    }
< 
<    public final void get(Tuple4d t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<       t.w = this.w;
<    }
< 
<    public final void add(Tuple4d t1, Tuple4d t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<       this.w = t1.w + t2.w;
<    }
< 
<    public final void add(Tuple4d t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<       this.w += t1.w;
<    }
< 
<    public final void sub(Tuple4d t1, Tuple4d t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<       this.w = t1.w - t2.w;
<    }
< 
<    public final void sub(Tuple4d t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<       this.w -= t1.w;
<    }
< 
<    public final void negate(Tuple4d t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<       this.w = -t1.w;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<       this.w = -this.w;
<    }
< 
<    public final void scale(double s, Tuple4d t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<       this.w = s * t1.w;
<    }
< 
<    public final void scale(double s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<       this.w *= s;
<    }
< 
<    public final void scaleAdd(double s, Tuple4d t1, Tuple4d t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<       this.w = s * t1.w + t2.w;
<    }
< 
<    /** @deprecated */
<    public final void scaleAdd(float s, Tuple4d t1) {
<       this.scaleAdd((double)s, t1);
<    }
< 
<    public final void scaleAdd(double s, Tuple4d t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<       this.w = s * this.w + t1.w;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
<    }
< 
<    public boolean equals(Tuple4d t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z && this.w == t1.w;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple4d t2 = (Tuple4d)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple4d t1, double epsilon) {
<       double diff = this.x - t1.x;
<       if (Double.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Double.isNaN(diff)) {
<             return false;
<          } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
<             return false;
<          } else {
<             diff = this.z - t1.z;
<             if (Double.isNaN(diff)) {
<                return false;
<             } else if ((diff < 0.0D ? -diff : diff) > epsilon) {
<                return false;
<             } else {
<                diff = this.w - t1.w;
<                if (Double.isNaN(diff)) {
<                   return false;
<                } else {
<                   return !((diff < 0.0D ? -diff : diff) > epsilon);
<                }
<             }
<          }
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashDoubleBits(bits, this.x);
<       bits = VecMathUtil.hashDoubleBits(bits, this.y);
<       bits = VecMathUtil.hashDoubleBits(bits, this.z);
<       bits = VecMathUtil.hashDoubleBits(bits, this.w);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    /** @deprecated */
<    public final void clamp(float min, float max, Tuple4d t) {
<       this.clamp((double)min, (double)max, t);
<    }
< 
<    public final void clamp(double min, double max, Tuple4d t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMin(float min, Tuple4d t) {
<       this.clampMin((double)min, t);
<    }
< 
<    public final void clampMin(double min, Tuple4d t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMax(float max, Tuple4d t) {
<       this.clampMax((double)max, t);
<    }
< 
<    public final void clampMax(double max, Tuple4d t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else {
<          this.w = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple4d t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<       this.w = Math.abs(t.w);
<    }
< 
<    /** @deprecated */
<    public final void clamp(float min, float max) {
<       this.clamp((double)min, (double)max);
<    }
< 
<    public final void clamp(double min, double max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       } else if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMin(float min) {
<       this.clampMin((double)min);
<    }
< 
<    public final void clampMin(double min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    /** @deprecated */
<    public final void clampMax(float max) {
<       this.clampMax((double)max);
<    }
< 
<    public final void clampMax(double max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<       this.w = Math.abs(this.w);
<    }
< 
<    /** @deprecated */
<    public void interpolate(Tuple4d t1, Tuple4d t2, float alpha) {
<       this.interpolate(t1, t2, (double)alpha);
<    }
< 
<    public void interpolate(Tuple4d t1, Tuple4d t2, double alpha) {
<       this.x = (1.0D - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0D - alpha) * t1.y + alpha * t2.y;
<       this.z = (1.0D - alpha) * t1.z + alpha * t2.z;
<       this.w = (1.0D - alpha) * t1.w + alpha * t2.w;
<    }
< 
<    /** @deprecated */
<    public void interpolate(Tuple4d t1, float alpha) {
<       this.interpolate(t1, (double)alpha);
<    }
< 
<    public void interpolate(Tuple4d t1, double alpha) {
<       this.x = (1.0D - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0D - alpha) * this.y + alpha * t1.y;
<       this.z = (1.0D - alpha) * this.z + alpha * t1.z;
<       this.w = (1.0D - alpha) * this.w + alpha * t1.w;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final double getX() {
<       return this.x;
<    }
< 
<    public final void setX(double x) {
<       this.x = x;
<    }
< 
<    public final double getY() {
<       return this.y;
<    }
< 
<    public final void setY(double y) {
<       this.y = y;
<    }
< 
<    public final double getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(double z) {
<       this.z = z;
<    }
< 
<    public final double getW() {
<       return this.w;
<    }
< 
<    public final void setW(double w) {
<       this.w = w;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class Tuple4d
> /*     */   implements Serializable, Cloneable
> /*     */ {
> /*     */   static final long serialVersionUID = -4748953690425311052L;
> /*     */   public double x;
> /*     */   public double y;
> /*     */   public double z;
> /*     */   public double w;
> /*     */   
> /*     */   public Tuple4d(double x, double y, double z, double w) {
> /*  69 */     this.x = x;
> /*  70 */     this.y = y;
> /*  71 */     this.z = z;
> /*  72 */     this.w = w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4d(double[] t) {
> /*  83 */     this.x = t[0];
> /*  84 */     this.y = t[1];
> /*  85 */     this.z = t[2];
> /*  86 */     this.w = t[3];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4d(Tuple4d t1) {
> /*  96 */     this.x = t1.x;
> /*  97 */     this.y = t1.y;
> /*  98 */     this.z = t1.z;
> /*  99 */     this.w = t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4d(Tuple4f t1) {
> /* 109 */     this.x = t1.x;
> /* 110 */     this.y = t1.y;
> /* 111 */     this.z = t1.z;
> /* 112 */     this.w = t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4d() {
> /* 121 */     this.x = 0.0D;
> /* 122 */     this.y = 0.0D;
> /* 123 */     this.z = 0.0D;
> /* 124 */     this.w = 0.0D;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(double x, double y, double z, double w) {
> /* 137 */     this.x = x;
> /* 138 */     this.y = y;
> /* 139 */     this.z = z;
> /* 140 */     this.w = w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(double[] t) {
> /* 150 */     this.x = t[0];
> /* 151 */     this.y = t[1];
> /* 152 */     this.z = t[2];
> /* 153 */     this.w = t[3];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple4d t1) {
> /* 163 */     this.x = t1.x;
> /* 164 */     this.y = t1.y;
> /* 165 */     this.z = t1.z;
> /* 166 */     this.w = t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple4f t1) {
> /* 176 */     this.x = t1.x;
> /* 177 */     this.y = t1.y;
> /* 178 */     this.z = t1.z;
> /* 179 */     this.w = t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(double[] t) {
> /* 190 */     t[0] = this.x;
> /* 191 */     t[1] = this.y;
> /* 192 */     t[2] = this.z;
> /* 193 */     t[3] = this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(Tuple4d t) {
> /* 205 */     t.x = this.x;
> /* 206 */     t.y = this.y;
> /* 207 */     t.z = this.z;
> /* 208 */     t.w = this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple4d t1, Tuple4d t2) {
> /* 219 */     t1.x += t2.x;
> /* 220 */     t1.y += t2.y;
> /* 221 */     t1.z += t2.z;
> /* 222 */     t1.w += t2.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple4d t1) {
> /* 232 */     this.x += t1.x;
> /* 233 */     this.y += t1.y;
> /* 234 */     this.z += t1.z;
> /* 235 */     this.w += t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple4d t1, Tuple4d t2) {
> /* 247 */     t1.x -= t2.x;
> /* 248 */     t1.y -= t2.y;
> /* 249 */     t1.z -= t2.z;
> /* 250 */     t1.w -= t2.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple4d t1) {
> /* 261 */     this.x -= t1.x;
> /* 262 */     this.y -= t1.y;
> /* 263 */     this.z -= t1.z;
> /* 264 */     this.w -= t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate(Tuple4d t1) {
> /* 274 */     this.x = -t1.x;
> /* 275 */     this.y = -t1.y;
> /* 276 */     this.z = -t1.z;
> /* 277 */     this.w = -t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate() {
> /* 286 */     this.x = -this.x;
> /* 287 */     this.y = -this.y;
> /* 288 */     this.z = -this.z;
> /* 289 */     this.w = -this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(double s, Tuple4d t1) {
> /* 301 */     this.x = s * t1.x;
> /* 302 */     this.y = s * t1.y;
> /* 303 */     this.z = s * t1.z;
> /* 304 */     this.w = s * t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(double s) {
> /* 315 */     this.x *= s;
> /* 316 */     this.y *= s;
> /* 317 */     this.z *= s;
> /* 318 */     this.w *= s;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(double s, Tuple4d t1, Tuple4d t2) {
> /* 331 */     this.x = s * t1.x + t2.x;
> /* 332 */     this.y = s * t1.y + t2.y;
> /* 333 */     this.z = s * t1.z + t2.z;
> /* 334 */     this.w = s * t1.w + t2.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(float s, Tuple4d t1) {
> /* 343 */     scaleAdd(s, t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(double s, Tuple4d t1) {
> /* 354 */     this.x = s * this.x + t1.x;
> /* 355 */     this.y = s * this.y + t1.y;
> /* 356 */     this.z = s * this.z + t1.z;
> /* 357 */     this.w = s * this.w + t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 369 */     return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Tuple4d t1) {
> /*     */     try {
> /* 382 */       return (this.x == t1.x && this.y == t1.y && this.z == t1.z && 
> /* 383 */         this.w == t1.w);
> /*     */     } catch (NullPointerException e2) {
> /* 385 */       return false;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object t1) {
> /*     */     
> /* 400 */     try { Tuple4d t2 = (Tuple4d)t1;
> /* 401 */       return (this.x == t2.x && this.y == t2.y && 
> /* 402 */         this.z == t2.z && this.w == t2.w); }
> /*     */     catch (NullPointerException e2)
> /* 404 */     { return false; }
> /* 405 */     catch (ClassCastException e1) { return false; }
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean epsilonEquals(Tuple4d t1, double epsilon) {
> /* 423 */     double diff = this.x - t1.x;
> /* 424 */     if (Double.isNaN(diff)) return false; 
> /* 425 */     if (((diff < 0.0D) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 427 */     diff = this.y - t1.y;
> /* 428 */     if (Double.isNaN(diff)) return false; 
> /* 429 */     if (((diff < 0.0D) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 431 */     diff = this.z - t1.z;
> /* 432 */     if (Double.isNaN(diff)) return false; 
> /* 433 */     if (((diff < 0.0D) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 435 */     diff = this.w - t1.w;
> /* 436 */     if (Double.isNaN(diff)) return false; 
> /* 437 */     if (((diff < 0.0D) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 439 */     return true;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int hashCode() {
> /* 454 */     long bits = 1L;
> /* 455 */     bits = VecMathUtil.hashDoubleBits(bits, this.x);
> /* 456 */     bits = VecMathUtil.hashDoubleBits(bits, this.y);
> /* 457 */     bits = VecMathUtil.hashDoubleBits(bits, this.z);
> /* 458 */     bits = VecMathUtil.hashDoubleBits(bits, this.w);
> /* 459 */     return VecMathUtil.hashFinish(bits);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(float min, float max, Tuple4d t) {
> /* 467 */     clamp(min, max, t);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(double min, double max, Tuple4d t) {
> /* 479 */     if (t.x > max) {
> /* 480 */       this.x = max;
> /* 481 */     } else if (t.x < min) {
> /* 482 */       this.x = min;
> /*     */     } else {
> /* 484 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 487 */     if (t.y > max) {
> /* 488 */       this.y = max;
> /* 489 */     } else if (t.y < min) {
> /* 490 */       this.y = min;
> /*     */     } else {
> /* 492 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 495 */     if (t.z > max) {
> /* 496 */       this.z = max;
> /* 497 */     } else if (t.z < min) {
> /* 498 */       this.z = min;
> /*     */     } else {
> /* 500 */       this.z = t.z;
> /*     */     } 
> /*     */     
> /* 503 */     if (t.w > max) {
> /* 504 */       this.w = max;
> /* 505 */     } else if (t.w < min) {
> /* 506 */       this.w = min;
> /*     */     } else {
> /* 508 */       this.w = t.w;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(float min, Tuple4d t) {
> /* 518 */     clampMin(min, t);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(double min, Tuple4d t) {
> /* 529 */     if (t.x < min) {
> /* 530 */       this.x = min;
> /*     */     } else {
> /* 532 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 535 */     if (t.y < min) {
> /* 536 */       this.y = min;
> /*     */     } else {
> /* 538 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 541 */     if (t.z < min) {
> /* 542 */       this.z = min;
> /*     */     } else {
> /* 544 */       this.z = t.z;
> /*     */     } 
> /*     */     
> /* 547 */     if (t.w < min) {
> /* 548 */       this.w = min;
> /*     */     } else {
> /* 550 */       this.w = t.w;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(float max, Tuple4d t) {
> /* 560 */     clampMax(max, t);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(double max, Tuple4d t) {
> /* 571 */     if (t.x > max) {
> /* 572 */       this.x = max;
> /*     */     } else {
> /* 574 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 577 */     if (t.y > max) {
> /* 578 */       this.y = max;
> /*     */     } else {
> /* 580 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 583 */     if (t.z > max) {
> /* 584 */       this.z = max;
> /*     */     } else {
> /* 586 */       this.z = t.z;
> /*     */     } 
> /*     */     
> /* 589 */     if (t.w > max) {
> /* 590 */       this.w = max;
> /*     */     } else {
> /* 592 */       this.w = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute(Tuple4d t) {
> /* 605 */     this.x = Math.abs(t.x);
> /* 606 */     this.y = Math.abs(t.y);
> /* 607 */     this.z = Math.abs(t.z);
> /* 608 */     this.w = Math.abs(t.w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(float min, float max) {
> /* 618 */     clamp(min, max);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(double min, double max) {
> /* 628 */     if (this.x > max) {
> /* 629 */       this.x = max;
> /* 630 */     } else if (this.x < min) {
> /* 631 */       this.x = min;
> /*     */     } 
> /*     */     
> /* 634 */     if (this.y > max) {
> /* 635 */       this.y = max;
> /* 636 */     } else if (this.y < min) {
> /* 637 */       this.y = min;
> /*     */     } 
> /*     */     
> /* 640 */     if (this.z > max) {
> /* 641 */       this.z = max;
> /* 642 */     } else if (this.z < min) {
> /* 643 */       this.z = min;
> /*     */     } 
> /*     */     
> /* 646 */     if (this.w > max) {
> /* 647 */       this.w = max;
> /* 648 */     } else if (this.w < min) {
> /* 649 */       this.w = min;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(float min) {
> /* 659 */     clampMin(min);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(double min) {
> /* 668 */     if (this.x < min) this.x = min; 
> /* 669 */     if (this.y < min) this.y = min; 
> /* 670 */     if (this.z < min) this.z = min; 
> /* 671 */     if (this.w < min) this.w = min;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(float max) {
> /* 679 */     clampMax(max);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(double max) {
> /* 688 */     if (this.x > max) this.x = max; 
> /* 689 */     if (this.y > max) this.y = max; 
> /* 690 */     if (this.z > max) this.z = max; 
> /* 691 */     if (this.w > max) this.w = max;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute() {
> /* 701 */     this.x = Math.abs(this.x);
> /* 702 */     this.y = Math.abs(this.y);
> /* 703 */     this.z = Math.abs(this.z);
> /* 704 */     this.w = Math.abs(this.w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void interpolate(Tuple4d t1, Tuple4d t2, float alpha) {
> /* 713 */     interpolate(t1, t2, alpha);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void interpolate(Tuple4d t1, Tuple4d t2, double alpha) {
> /* 725 */     this.x = (1.0D - alpha) * t1.x + alpha * t2.x;
> /* 726 */     this.y = (1.0D - alpha) * t1.y + alpha * t2.y;
> /* 727 */     this.z = (1.0D - alpha) * t1.z + alpha * t2.z;
> /* 728 */     this.w = (1.0D - alpha) * t1.w + alpha * t2.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void interpolate(Tuple4d t1, float alpha) {
> /* 736 */     interpolate(t1, alpha);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void interpolate(Tuple4d t1, double alpha) {
> /* 747 */     this.x = (1.0D - alpha) * this.x + alpha * t1.x;
> /* 748 */     this.y = (1.0D - alpha) * this.y + alpha * t1.y;
> /* 749 */     this.z = (1.0D - alpha) * this.z + alpha * t1.z;
> /* 750 */     this.w = (1.0D - alpha) * this.w + alpha * t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object clone() {
> /*     */     try {
> /* 765 */       return super.clone();
> /* 766 */     } catch (CloneNotSupportedException e) {
> /*     */       
> /* 768 */       throw new InternalError();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double getX() {
> /* 780 */     return this.x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setX(double x) {
> /* 792 */     this.x = x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double getY() {
> /* 804 */     return this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setY(double y) {
> /* 816 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double getZ() {
> /* 827 */     return this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setZ(double z) {
> /* 839 */     this.z = z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double getW() {
> /* 851 */     return this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setW(double w) {
> /* 863 */     this.w = w;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Tuple4d.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Tuple4f.java jd-gui/vecmath/Tuple4f.java
1,442c1,802
< package vecmath;
< 
< import java.io.Serializable;
< 
< public abstract class Tuple4f implements Serializable, Cloneable {
<    static final long serialVersionUID = 7068460319248845763L;
<    public float x;
<    public float y;
<    public float z;
<    public float w;
< 
<    public Tuple4f(float x, float y, float z, float w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public Tuple4f(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public Tuple4f(Tuple4f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public Tuple4f(Tuple4d t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<       this.z = (float)t1.z;
<       this.w = (float)t1.w;
<    }
< 
<    public Tuple4f() {
<       this.x = 0.0F;
<       this.y = 0.0F;
<       this.z = 0.0F;
<       this.w = 0.0F;
<    }
< 
<    public final void set(float x, float y, float z, float w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public final void set(float[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public final void set(Tuple4f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public final void set(Tuple4d t1) {
<       this.x = (float)t1.x;
<       this.y = (float)t1.y;
<       this.z = (float)t1.z;
<       this.w = (float)t1.w;
<    }
< 
<    public final void get(float[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<       t[3] = this.w;
<    }
< 
<    public final void get(Tuple4f t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<       t.w = this.w;
<    }
< 
<    public final void add(Tuple4f t1, Tuple4f t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<       this.w = t1.w + t2.w;
<    }
< 
<    public final void add(Tuple4f t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<       this.w += t1.w;
<    }
< 
<    public final void sub(Tuple4f t1, Tuple4f t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<       this.w = t1.w - t2.w;
<    }
< 
<    public final void sub(Tuple4f t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<       this.w -= t1.w;
<    }
< 
<    public final void negate(Tuple4f t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<       this.w = -t1.w;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<       this.w = -this.w;
<    }
< 
<    public final void scale(float s, Tuple4f t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<       this.w = s * t1.w;
<    }
< 
<    public final void scale(float s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<       this.w *= s;
<    }
< 
<    public final void scaleAdd(float s, Tuple4f t1, Tuple4f t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<       this.w = s * t1.w + t2.w;
<    }
< 
<    public final void scaleAdd(float s, Tuple4f t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<       this.w = s * this.w + t1.w;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
<    }
< 
<    public boolean equals(Tuple4f t1) {
<       try {
<          return this.x == t1.x && this.y == t1.y && this.z == t1.z && this.w == t1.w;
<       } catch (NullPointerException var3) {
<          return false;
<       }
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple4f t2 = (Tuple4f)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public boolean epsilonEquals(Tuple4f t1, float epsilon) {
<       float diff = this.x - t1.x;
<       if (Float.isNaN(diff)) {
<          return false;
<       } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
<          return false;
<       } else {
<          diff = this.y - t1.y;
<          if (Float.isNaN(diff)) {
<             return false;
<          } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
<             return false;
<          } else {
<             diff = this.z - t1.z;
<             if (Float.isNaN(diff)) {
<                return false;
<             } else if ((diff < 0.0F ? -diff : diff) > epsilon) {
<                return false;
<             } else {
<                diff = this.w - t1.w;
<                if (Float.isNaN(diff)) {
<                   return false;
<                } else {
<                   return !((diff < 0.0F ? -diff : diff) > epsilon);
<                }
<             }
<          }
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = VecMathUtil.hashFloatBits(bits, this.x);
<       bits = VecMathUtil.hashFloatBits(bits, this.y);
<       bits = VecMathUtil.hashFloatBits(bits, this.z);
<       bits = VecMathUtil.hashFloatBits(bits, this.w);
<       return VecMathUtil.hashFinish(bits);
<    }
< 
<    public final void clamp(float min, float max, Tuple4f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    public final void clampMin(float min, Tuple4f t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    public final void clampMax(float max, Tuple4f t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else {
<          this.w = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple4f t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<       this.w = Math.abs(t.w);
<    }
< 
<    public final void clamp(float min, float max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       } else if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    public final void clampMin(float min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    public final void clampMax(float max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<       this.w = Math.abs(this.w);
<    }
< 
<    public void interpolate(Tuple4f t1, Tuple4f t2, float alpha) {
<       this.x = (1.0F - alpha) * t1.x + alpha * t2.x;
<       this.y = (1.0F - alpha) * t1.y + alpha * t2.y;
<       this.z = (1.0F - alpha) * t1.z + alpha * t2.z;
<       this.w = (1.0F - alpha) * t1.w + alpha * t2.w;
<    }
< 
<    public void interpolate(Tuple4f t1, float alpha) {
<       this.x = (1.0F - alpha) * this.x + alpha * t1.x;
<       this.y = (1.0F - alpha) * this.y + alpha * t1.y;
<       this.z = (1.0F - alpha) * this.z + alpha * t1.z;
<       this.w = (1.0F - alpha) * this.w + alpha * t1.w;
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final float getX() {
<       return this.x;
<    }
< 
<    public final void setX(float x) {
<       this.x = x;
<    }
< 
<    public final float getY() {
<       return this.y;
<    }
< 
<    public final void setY(float y) {
<       this.y = y;
<    }
< 
<    public final float getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(float z) {
<       this.z = z;
<    }
< 
<    public final float getW() {
<       return this.w;
<    }
< 
<    public final void setW(float w) {
<       this.w = w;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class Tuple4f
> /*     */   implements Serializable, Cloneable
> /*     */ {
> /*     */   static final long serialVersionUID = 7068460319248845763L;
> /*     */   public float x;
> /*     */   public float y;
> /*     */   public float z;
> /*     */   public float w;
> /*     */   
> /*     */   public Tuple4f(float x, float y, float z, float w) {
> /*  69 */     this.x = x;
> /*  70 */     this.y = y;
> /*  71 */     this.z = z;
> /*  72 */     this.w = w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4f(float[] t) {
> /*  82 */     this.x = t[0];
> /*  83 */     this.y = t[1];
> /*  84 */     this.z = t[2];
> /*  85 */     this.w = t[3];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4f(Tuple4f t1) {
> /*  95 */     this.x = t1.x;
> /*  96 */     this.y = t1.y;
> /*  97 */     this.z = t1.z;
> /*  98 */     this.w = t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4f(Tuple4d t1) {
> /* 108 */     this.x = (float)t1.x;
> /* 109 */     this.y = (float)t1.y;
> /* 110 */     this.z = (float)t1.z;
> /* 111 */     this.w = (float)t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4f() {
> /* 120 */     this.x = 0.0F;
> /* 121 */     this.y = 0.0F;
> /* 122 */     this.z = 0.0F;
> /* 123 */     this.w = 0.0F;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(float x, float y, float z, float w) {
> /* 136 */     this.x = x;
> /* 137 */     this.y = y;
> /* 138 */     this.z = z;
> /* 139 */     this.w = w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(float[] t) {
> /* 150 */     this.x = t[0];
> /* 151 */     this.y = t[1];
> /* 152 */     this.z = t[2];
> /* 153 */     this.w = t[3];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple4f t1) {
> /* 163 */     this.x = t1.x;
> /* 164 */     this.y = t1.y;
> /* 165 */     this.z = t1.z;
> /* 166 */     this.w = t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple4d t1) {
> /* 176 */     this.x = (float)t1.x;
> /* 177 */     this.y = (float)t1.y;
> /* 178 */     this.z = (float)t1.z;
> /* 179 */     this.w = (float)t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(float[] t) {
> /* 189 */     t[0] = this.x;
> /* 190 */     t[1] = this.y;
> /* 191 */     t[2] = this.z;
> /* 192 */     t[3] = this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(Tuple4f t) {
> /* 202 */     t.x = this.x;
> /* 203 */     t.y = this.y;
> /* 204 */     t.z = this.z;
> /* 205 */     t.w = this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple4f t1, Tuple4f t2) {
> /* 216 */     t1.x += t2.x;
> /* 217 */     t1.y += t2.y;
> /* 218 */     t1.z += t2.z;
> /* 219 */     t1.w += t2.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple4f t1) {
> /* 229 */     this.x += t1.x;
> /* 230 */     this.y += t1.y;
> /* 231 */     this.z += t1.z;
> /* 232 */     this.w += t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple4f t1, Tuple4f t2) {
> /* 244 */     t1.x -= t2.x;
> /* 245 */     t1.y -= t2.y;
> /* 246 */     t1.z -= t2.z;
> /* 247 */     t1.w -= t2.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple4f t1) {
> /* 258 */     this.x -= t1.x;
> /* 259 */     this.y -= t1.y;
> /* 260 */     this.z -= t1.z;
> /* 261 */     this.w -= t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate(Tuple4f t1) {
> /* 271 */     this.x = -t1.x;
> /* 272 */     this.y = -t1.y;
> /* 273 */     this.z = -t1.z;
> /* 274 */     this.w = -t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate() {
> /* 283 */     this.x = -this.x;
> /* 284 */     this.y = -this.y;
> /* 285 */     this.z = -this.z;
> /* 286 */     this.w = -this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(float s, Tuple4f t1) {
> /* 298 */     this.x = s * t1.x;
> /* 299 */     this.y = s * t1.y;
> /* 300 */     this.z = s * t1.z;
> /* 301 */     this.w = s * t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(float s) {
> /* 312 */     this.x *= s;
> /* 313 */     this.y *= s;
> /* 314 */     this.z *= s;
> /* 315 */     this.w *= s;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(float s, Tuple4f t1, Tuple4f t2) {
> /* 328 */     this.x = s * t1.x + t2.x;
> /* 329 */     this.y = s * t1.y + t2.y;
> /* 330 */     this.z = s * t1.z + t2.z;
> /* 331 */     this.w = s * t1.w + t2.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(float s, Tuple4f t1) {
> /* 343 */     this.x = s * this.x + t1.x;
> /* 344 */     this.y = s * this.y + t1.y;
> /* 345 */     this.z = s * this.z + t1.z;
> /* 346 */     this.w = s * this.w + t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 358 */     return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Tuple4f t1) {
> /*     */     try {
> /* 370 */       return (this.x == t1.x && this.y == t1.y && this.z == t1.z && 
> /* 371 */         this.w == t1.w);
> /*     */     } catch (NullPointerException e2) {
> /* 373 */       return false;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object t1) {
> /*     */     
> /* 387 */     try { Tuple4f t2 = (Tuple4f)t1;
> /* 388 */       return (this.x == t2.x && this.y == t2.y && 
> /* 389 */         this.z == t2.z && this.w == t2.w); }
> /*     */     catch (NullPointerException e2)
> /* 391 */     { return false; }
> /* 392 */     catch (ClassCastException e1) { return false; }
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean epsilonEquals(Tuple4f t1, float epsilon) {
> /* 410 */     float diff = this.x - t1.x;
> /* 411 */     if (Float.isNaN(diff)) return false; 
> /* 412 */     if (((diff < 0.0F) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 414 */     diff = this.y - t1.y;
> /* 415 */     if (Float.isNaN(diff)) return false; 
> /* 416 */     if (((diff < 0.0F) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 418 */     diff = this.z - t1.z;
> /* 419 */     if (Float.isNaN(diff)) return false; 
> /* 420 */     if (((diff < 0.0F) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 422 */     diff = this.w - t1.w;
> /* 423 */     if (Float.isNaN(diff)) return false; 
> /* 424 */     if (((diff < 0.0F) ? -diff : diff) > epsilon) return false;
> /*     */     
> /* 426 */     return true;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int hashCode() {
> /* 440 */     long bits = 1L;
> /* 441 */     bits = VecMathUtil.hashFloatBits(bits, this.x);
> /* 442 */     bits = VecMathUtil.hashFloatBits(bits, this.y);
> /* 443 */     bits = VecMathUtil.hashFloatBits(bits, this.z);
> /* 444 */     bits = VecMathUtil.hashFloatBits(bits, this.w);
> /* 445 */     return VecMathUtil.hashFinish(bits);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(float min, float max, Tuple4f t) {
> /* 458 */     if (t.x > max) {
> /* 459 */       this.x = max;
> /* 460 */     } else if (t.x < min) {
> /* 461 */       this.x = min;
> /*     */     } else {
> /* 463 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 466 */     if (t.y > max) {
> /* 467 */       this.y = max;
> /* 468 */     } else if (t.y < min) {
> /* 469 */       this.y = min;
> /*     */     } else {
> /* 471 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 474 */     if (t.z > max) {
> /* 475 */       this.z = max;
> /* 476 */     } else if (t.z < min) {
> /* 477 */       this.z = min;
> /*     */     } else {
> /* 479 */       this.z = t.z;
> /*     */     } 
> /*     */     
> /* 482 */     if (t.w > max) {
> /* 483 */       this.w = max;
> /* 484 */     } else if (t.w < min) {
> /* 485 */       this.w = min;
> /*     */     } else {
> /* 487 */       this.w = t.w;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(float min, Tuple4f t) {
> /* 501 */     if (t.x < min) {
> /* 502 */       this.x = min;
> /*     */     } else {
> /* 504 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 507 */     if (t.y < min) {
> /* 508 */       this.y = min;
> /*     */     } else {
> /* 510 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 513 */     if (t.z < min) {
> /* 514 */       this.z = min;
> /*     */     } else {
> /* 516 */       this.z = t.z;
> /*     */     } 
> /*     */     
> /* 519 */     if (t.w < min) {
> /* 520 */       this.w = min;
> /*     */     } else {
> /* 522 */       this.w = t.w;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(float max, Tuple4f t) {
> /* 537 */     if (t.x > max) {
> /* 538 */       this.x = max;
> /*     */     } else {
> /* 540 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 543 */     if (t.y > max) {
> /* 544 */       this.y = max;
> /*     */     } else {
> /* 546 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 549 */     if (t.z > max) {
> /* 550 */       this.z = max;
> /*     */     } else {
> /* 552 */       this.z = t.z;
> /*     */     } 
> /*     */     
> /* 555 */     if (t.w > max) {
> /* 556 */       this.w = max;
> /*     */     } else {
> /* 558 */       this.w = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute(Tuple4f t) {
> /* 571 */     this.x = Math.abs(t.x);
> /* 572 */     this.y = Math.abs(t.y);
> /* 573 */     this.z = Math.abs(t.z);
> /* 574 */     this.w = Math.abs(t.w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(float min, float max) {
> /* 585 */     if (this.x > max) {
> /* 586 */       this.x = max;
> /* 587 */     } else if (this.x < min) {
> /* 588 */       this.x = min;
> /*     */     } 
> /*     */     
> /* 591 */     if (this.y > max) {
> /* 592 */       this.y = max;
> /* 593 */     } else if (this.y < min) {
> /* 594 */       this.y = min;
> /*     */     } 
> /*     */     
> /* 597 */     if (this.z > max) {
> /* 598 */       this.z = max;
> /* 599 */     } else if (this.z < min) {
> /* 600 */       this.z = min;
> /*     */     } 
> /*     */     
> /* 603 */     if (this.w > max) {
> /* 604 */       this.w = max;
> /* 605 */     } else if (this.w < min) {
> /* 606 */       this.w = min;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(float min) {
> /* 618 */     if (this.x < min) this.x = min; 
> /* 619 */     if (this.y < min) this.y = min; 
> /* 620 */     if (this.z < min) this.z = min; 
> /* 621 */     if (this.w < min) this.w = min;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(float max) {
> /* 632 */     if (this.x > max) this.x = max; 
> /* 633 */     if (this.y > max) this.y = max; 
> /* 634 */     if (this.z > max) this.z = max; 
> /* 635 */     if (this.w > max) this.w = max;
> /*     */   
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute() {
> /* 645 */     this.x = Math.abs(this.x);
> /* 646 */     this.y = Math.abs(this.y);
> /* 647 */     this.z = Math.abs(this.z);
> /* 648 */     this.w = Math.abs(this.w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void interpolate(Tuple4f t1, Tuple4f t2, float alpha) {
> /* 661 */     this.x = (1.0F - alpha) * t1.x + alpha * t2.x;
> /* 662 */     this.y = (1.0F - alpha) * t1.y + alpha * t2.y;
> /* 663 */     this.z = (1.0F - alpha) * t1.z + alpha * t2.z;
> /* 664 */     this.w = (1.0F - alpha) * t1.w + alpha * t2.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public void interpolate(Tuple4f t1, float alpha) {
> /* 677 */     this.x = (1.0F - alpha) * this.x + alpha * t1.x;
> /* 678 */     this.y = (1.0F - alpha) * this.y + alpha * t1.y;
> /* 679 */     this.z = (1.0F - alpha) * this.z + alpha * t1.z;
> /* 680 */     this.w = (1.0F - alpha) * this.w + alpha * t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object clone() {
> /*     */     try {
> /* 696 */       return super.clone();
> /* 697 */     } catch (CloneNotSupportedException e) {
> /*     */       
> /* 699 */       throw new InternalError();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float getX() {
> /* 711 */     return this.x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setX(float x) {
> /* 723 */     this.x = x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float getY() {
> /* 735 */     return this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setY(float y) {
> /* 747 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float getZ() {
> /* 758 */     return this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setZ(float z) {
> /* 770 */     this.z = z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float getW() {
> /* 782 */     return this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setW(float w) {
> /* 794 */     this.w = w;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Tuple4f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Tuple4i.java jd-gui/vecmath/Tuple4i.java
1,376c1,683
< package vecmath;
< 
< import java.io.Serializable;
< 
< public abstract class Tuple4i implements Serializable, Cloneable {
<    static final long serialVersionUID = 8064614250942616720L;
<    public int x;
<    public int y;
<    public int z;
<    public int w;
< 
<    public Tuple4i(int x, int y, int z, int w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public Tuple4i(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public Tuple4i(Tuple4i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public Tuple4i() {
<       this.x = 0;
<       this.y = 0;
<       this.z = 0;
<       this.w = 0;
<    }
< 
<    public final void set(int x, int y, int z, int w) {
<       this.x = x;
<       this.y = y;
<       this.z = z;
<       this.w = w;
<    }
< 
<    public final void set(int[] t) {
<       this.x = t[0];
<       this.y = t[1];
<       this.z = t[2];
<       this.w = t[3];
<    }
< 
<    public final void set(Tuple4i t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = t1.w;
<    }
< 
<    public final void get(int[] t) {
<       t[0] = this.x;
<       t[1] = this.y;
<       t[2] = this.z;
<       t[3] = this.w;
<    }
< 
<    public final void get(Tuple4i t) {
<       t.x = this.x;
<       t.y = this.y;
<       t.z = this.z;
<       t.w = this.w;
<    }
< 
<    public final void add(Tuple4i t1, Tuple4i t2) {
<       this.x = t1.x + t2.x;
<       this.y = t1.y + t2.y;
<       this.z = t1.z + t2.z;
<       this.w = t1.w + t2.w;
<    }
< 
<    public final void add(Tuple4i t1) {
<       this.x += t1.x;
<       this.y += t1.y;
<       this.z += t1.z;
<       this.w += t1.w;
<    }
< 
<    public final void sub(Tuple4i t1, Tuple4i t2) {
<       this.x = t1.x - t2.x;
<       this.y = t1.y - t2.y;
<       this.z = t1.z - t2.z;
<       this.w = t1.w - t2.w;
<    }
< 
<    public final void sub(Tuple4i t1) {
<       this.x -= t1.x;
<       this.y -= t1.y;
<       this.z -= t1.z;
<       this.w -= t1.w;
<    }
< 
<    public final void negate(Tuple4i t1) {
<       this.x = -t1.x;
<       this.y = -t1.y;
<       this.z = -t1.z;
<       this.w = -t1.w;
<    }
< 
<    public final void negate() {
<       this.x = -this.x;
<       this.y = -this.y;
<       this.z = -this.z;
<       this.w = -this.w;
<    }
< 
<    public final void scale(int s, Tuple4i t1) {
<       this.x = s * t1.x;
<       this.y = s * t1.y;
<       this.z = s * t1.z;
<       this.w = s * t1.w;
<    }
< 
<    public final void scale(int s) {
<       this.x *= s;
<       this.y *= s;
<       this.z *= s;
<       this.w *= s;
<    }
< 
<    public final void scaleAdd(int s, Tuple4i t1, Tuple4i t2) {
<       this.x = s * t1.x + t2.x;
<       this.y = s * t1.y + t2.y;
<       this.z = s * t1.z + t2.z;
<       this.w = s * t1.w + t2.w;
<    }
< 
<    public final void scaleAdd(int s, Tuple4i t1) {
<       this.x = s * this.x + t1.x;
<       this.y = s * this.y + t1.y;
<       this.z = s * this.z + t1.z;
<       this.w = s * this.w + t1.w;
<    }
< 
<    public String toString() {
<       return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
<    }
< 
<    public boolean equals(Object t1) {
<       try {
<          Tuple4i t2 = (Tuple4i)t1;
<          return this.x == t2.x && this.y == t2.y && this.z == t2.z && this.w == t2.w;
<       } catch (NullPointerException var3) {
<          return false;
<       } catch (ClassCastException var4) {
<          return false;
<       }
<    }
< 
<    public int hashCode() {
<       long bits = 1L;
<       bits = 31L * bits + (long)this.x;
<       bits = 31L * bits + (long)this.y;
<       bits = 31L * bits + (long)this.z;
<       bits = 31L * bits + (long)this.w;
<       return (int)(bits ^ bits >> 32);
<    }
< 
<    public final void clamp(int min, int max, Tuple4i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    public final void clampMin(int min, Tuple4i t) {
<       if (t.x < min) {
<          this.x = min;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y < min) {
<          this.y = min;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z < min) {
<          this.z = min;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w < min) {
<          this.w = min;
<       } else {
<          this.w = t.w;
<       }
< 
<    }
< 
<    public final void clampMax(int max, Tuple4i t) {
<       if (t.x > max) {
<          this.x = max;
<       } else {
<          this.x = t.x;
<       }
< 
<       if (t.y > max) {
<          this.y = max;
<       } else {
<          this.y = t.y;
<       }
< 
<       if (t.z > max) {
<          this.z = max;
<       } else {
<          this.z = t.z;
<       }
< 
<       if (t.w > max) {
<          this.w = max;
<       } else {
<          this.w = t.z;
<       }
< 
<    }
< 
<    public final void absolute(Tuple4i t) {
<       this.x = Math.abs(t.x);
<       this.y = Math.abs(t.y);
<       this.z = Math.abs(t.z);
<       this.w = Math.abs(t.w);
<    }
< 
<    public final void clamp(int min, int max) {
<       if (this.x > max) {
<          this.x = max;
<       } else if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       } else if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       } else if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       } else if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    public final void clampMin(int min) {
<       if (this.x < min) {
<          this.x = min;
<       }
< 
<       if (this.y < min) {
<          this.y = min;
<       }
< 
<       if (this.z < min) {
<          this.z = min;
<       }
< 
<       if (this.w < min) {
<          this.w = min;
<       }
< 
<    }
< 
<    public final void clampMax(int max) {
<       if (this.x > max) {
<          this.x = max;
<       }
< 
<       if (this.y > max) {
<          this.y = max;
<       }
< 
<       if (this.z > max) {
<          this.z = max;
<       }
< 
<       if (this.w > max) {
<          this.w = max;
<       }
< 
<    }
< 
<    public final void absolute() {
<       this.x = Math.abs(this.x);
<       this.y = Math.abs(this.y);
<       this.z = Math.abs(this.z);
<       this.w = Math.abs(this.w);
<    }
< 
<    public Object clone() {
<       try {
<          return super.clone();
<       } catch (CloneNotSupportedException var2) {
<          throw new InternalError();
<       }
<    }
< 
<    public final int getX() {
<       return this.x;
<    }
< 
<    public final void setX(int x) {
<       this.x = x;
<    }
< 
<    public final int getY() {
<       return this.y;
<    }
< 
<    public final void setY(int y) {
<       this.y = y;
<    }
< 
<    public final int getZ() {
<       return this.z;
<    }
< 
<    public final void setZ(int z) {
<       this.z = z;
<    }
< 
<    public final int getW() {
<       return this.w;
<    }
< 
<    public final void setW(int w) {
<       this.w = w;
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public abstract class Tuple4i
> /*     */   implements Serializable, Cloneable
> /*     */ {
> /*     */   static final long serialVersionUID = 8064614250942616720L;
> /*     */   public int x;
> /*     */   public int y;
> /*     */   public int z;
> /*     */   public int w;
> /*     */   
> /*     */   public Tuple4i(int x, int y, int z, int w) {
> /*  70 */     this.x = x;
> /*  71 */     this.y = y;
> /*  72 */     this.z = z;
> /*  73 */     this.w = w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4i(int[] t) {
> /*  82 */     this.x = t[0];
> /*  83 */     this.y = t[1];
> /*  84 */     this.z = t[2];
> /*  85 */     this.w = t[3];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4i(Tuple4i t1) {
> /*  95 */     this.x = t1.x;
> /*  96 */     this.y = t1.y;
> /*  97 */     this.z = t1.z;
> /*  98 */     this.w = t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Tuple4i() {
> /* 106 */     this.x = 0;
> /* 107 */     this.y = 0;
> /* 108 */     this.z = 0;
> /* 109 */     this.w = 0;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(int x, int y, int z, int w) {
> /* 122 */     this.x = x;
> /* 123 */     this.y = y;
> /* 124 */     this.z = z;
> /* 125 */     this.w = w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(int[] t) {
> /* 135 */     this.x = t[0];
> /* 136 */     this.y = t[1];
> /* 137 */     this.z = t[2];
> /* 138 */     this.w = t[3];
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple4i t1) {
> /* 147 */     this.x = t1.x;
> /* 148 */     this.y = t1.y;
> /* 149 */     this.z = t1.z;
> /* 150 */     this.w = t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(int[] t) {
> /* 159 */     t[0] = this.x;
> /* 160 */     t[1] = this.y;
> /* 161 */     t[2] = this.z;
> /* 162 */     t[3] = this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void get(Tuple4i t) {
> /* 171 */     t.x = this.x;
> /* 172 */     t.y = this.y;
> /* 173 */     t.z = this.z;
> /* 174 */     t.w = this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple4i t1, Tuple4i t2) {
> /* 184 */     t1.x += t2.x;
> /* 185 */     t1.y += t2.y;
> /* 186 */     t1.z += t2.z;
> /* 187 */     t1.w += t2.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void add(Tuple4i t1) {
> /* 196 */     this.x += t1.x;
> /* 197 */     this.y += t1.y;
> /* 198 */     this.z += t1.z;
> /* 199 */     this.w += t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple4i t1, Tuple4i t2) {
> /* 210 */     t1.x -= t2.x;
> /* 211 */     t1.y -= t2.y;
> /* 212 */     t1.z -= t2.z;
> /* 213 */     t1.w -= t2.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void sub(Tuple4i t1) {
> /* 223 */     this.x -= t1.x;
> /* 224 */     this.y -= t1.y;
> /* 225 */     this.z -= t1.z;
> /* 226 */     this.w -= t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate(Tuple4i t1) {
> /* 235 */     this.x = -t1.x;
> /* 236 */     this.y = -t1.y;
> /* 237 */     this.z = -t1.z;
> /* 238 */     this.w = -t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void negate() {
> /* 246 */     this.x = -this.x;
> /* 247 */     this.y = -this.y;
> /* 248 */     this.z = -this.z;
> /* 249 */     this.w = -this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(int s, Tuple4i t1) {
> /* 260 */     this.x = s * t1.x;
> /* 261 */     this.y = s * t1.y;
> /* 262 */     this.z = s * t1.z;
> /* 263 */     this.w = s * t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scale(int s) {
> /* 273 */     this.x *= s;
> /* 274 */     this.y *= s;
> /* 275 */     this.z *= s;
> /* 276 */     this.w *= s;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(int s, Tuple4i t1, Tuple4i t2) {
> /* 288 */     this.x = s * t1.x + t2.x;
> /* 289 */     this.y = s * t1.y + t2.y;
> /* 290 */     this.z = s * t1.z + t2.z;
> /* 291 */     this.w = s * t1.w + t2.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void scaleAdd(int s, Tuple4i t1) {
> /* 302 */     this.x = s * this.x + t1.x;
> /* 303 */     this.y = s * this.y + t1.y;
> /* 304 */     this.z = s * this.z + t1.z;
> /* 305 */     this.w = s * this.w + t1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public String toString() {
> /* 316 */     return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public boolean equals(Object t1) {
> /*     */     try {
> /* 330 */       Tuple4i t2 = (Tuple4i)t1;
> /* 331 */       return (this.x == t2.x && this.y == t2.y && 
> /* 332 */         this.z == t2.z && this.w == t2.w);
> /*     */     }
> /* 334 */     catch (NullPointerException e2) {
> /* 335 */       return false;
> /*     */     }
> /* 337 */     catch (ClassCastException e1) {
> /* 338 */       return false;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public int hashCode() {
> /* 353 */     long bits = 1L;
> /* 354 */     bits = 31L * bits + this.x;
> /* 355 */     bits = 31L * bits + this.y;
> /* 356 */     bits = 31L * bits + this.z;
> /* 357 */     bits = 31L * bits + this.w;
> /* 358 */     return (int)(bits ^ bits >> 32L);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(int min, int max, Tuple4i t) {
> /* 370 */     if (t.x > max) {
> /* 371 */       this.x = max;
> /* 372 */     } else if (t.x < min) {
> /* 373 */       this.x = min;
> /*     */     } else {
> /* 375 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 378 */     if (t.y > max) {
> /* 379 */       this.y = max;
> /* 380 */     } else if (t.y < min) {
> /* 381 */       this.y = min;
> /*     */     } else {
> /* 383 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 386 */     if (t.z > max) {
> /* 387 */       this.z = max;
> /* 388 */     } else if (t.z < min) {
> /* 389 */       this.z = min;
> /*     */     } else {
> /* 391 */       this.z = t.z;
> /*     */     } 
> /*     */     
> /* 394 */     if (t.w > max) {
> /* 395 */       this.w = max;
> /* 396 */     } else if (t.w < min) {
> /* 397 */       this.w = min;
> /*     */     } else {
> /* 399 */       this.w = t.w;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(int min, Tuple4i t) {
> /* 411 */     if (t.x < min) {
> /* 412 */       this.x = min;
> /*     */     } else {
> /* 414 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 417 */     if (t.y < min) {
> /* 418 */       this.y = min;
> /*     */     } else {
> /* 420 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 423 */     if (t.z < min) {
> /* 424 */       this.z = min;
> /*     */     } else {
> /* 426 */       this.z = t.z;
> /*     */     } 
> /*     */     
> /* 429 */     if (t.w < min) {
> /* 430 */       this.w = min;
> /*     */     } else {
> /* 432 */       this.w = t.w;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(int max, Tuple4i t) {
> /* 446 */     if (t.x > max) {
> /* 447 */       this.x = max;
> /*     */     } else {
> /* 449 */       this.x = t.x;
> /*     */     } 
> /*     */     
> /* 452 */     if (t.y > max) {
> /* 453 */       this.y = max;
> /*     */     } else {
> /* 455 */       this.y = t.y;
> /*     */     } 
> /*     */     
> /* 458 */     if (t.z > max) {
> /* 459 */       this.z = max;
> /*     */     } else {
> /* 461 */       this.z = t.z;
> /*     */     } 
> /*     */     
> /* 464 */     if (t.w > max) {
> /* 465 */       this.w = max;
> /*     */     } else {
> /* 467 */       this.w = t.z;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute(Tuple4i t) {
> /* 478 */     this.x = Math.abs(t.x);
> /* 479 */     this.y = Math.abs(t.y);
> /* 480 */     this.z = Math.abs(t.z);
> /* 481 */     this.w = Math.abs(t.w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clamp(int min, int max) {
> /* 491 */     if (this.x > max) {
> /* 492 */       this.x = max;
> /* 493 */     } else if (this.x < min) {
> /* 494 */       this.x = min;
> /*     */     } 
> /*     */     
> /* 497 */     if (this.y > max) {
> /* 498 */       this.y = max;
> /* 499 */     } else if (this.y < min) {
> /* 500 */       this.y = min;
> /*     */     } 
> /*     */     
> /* 503 */     if (this.z > max) {
> /* 504 */       this.z = max;
> /* 505 */     } else if (this.z < min) {
> /* 506 */       this.z = min;
> /*     */     } 
> /*     */     
> /* 509 */     if (this.w > max) {
> /* 510 */       this.w = max;
> /* 511 */     } else if (this.w < min) {
> /* 512 */       this.w = min;
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMin(int min) {
> /* 522 */     if (this.x < min) {
> /* 523 */       this.x = min;
> /*     */     }
> /* 525 */     if (this.y < min) {
> /* 526 */       this.y = min;
> /*     */     }
> /* 528 */     if (this.z < min) {
> /* 529 */       this.z = min;
> /*     */     }
> /* 531 */     if (this.w < min) {
> /* 532 */       this.w = min;
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void clampMax(int max) {
> /* 541 */     if (this.x > max) {
> /* 542 */       this.x = max;
> /*     */     }
> /* 544 */     if (this.y > max) {
> /* 545 */       this.y = max;
> /*     */     }
> /* 547 */     if (this.z > max) {
> /* 548 */       this.z = max;
> /*     */     }
> /* 550 */     if (this.w > max) {
> /* 551 */       this.w = max;
> /*     */     }
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void absolute() {
> /* 559 */     this.x = Math.abs(this.x);
> /* 560 */     this.y = Math.abs(this.y);
> /* 561 */     this.z = Math.abs(this.z);
> /* 562 */     this.w = Math.abs(this.w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Object clone() {
> /*     */     try {
> /* 577 */       return super.clone();
> /* 578 */     } catch (CloneNotSupportedException e) {
> /*     */       
> /* 580 */       throw new InternalError();
> /*     */     } 
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final int getX() {
> /* 594 */     return this.x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setX(int x) {
> /* 606 */     this.x = x;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final int getY() {
> /* 618 */     return this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setY(int y) {
> /* 630 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final int getZ() {
> /* 641 */     return this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setZ(int z) {
> /* 653 */     this.z = z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final int getW() {
> /* 663 */     return this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void setW(int w) {
> /* 675 */     this.w = w;
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Tuple4i.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/VecMathI18N.java jd-gui/vecmath/VecMathI18N.java
1c1,45
< package vecmath;
---
> /*    */ package vecmath;
> /*    */ 
> /*    */ import java.util.MissingResourceException;
> /*    */ import java.util.ResourceBundle;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ class VecMathI18N
> /*    */ {
> /*    */   static String getString(String key) {
> /*    */     String s;
> /*    */     try {
> /* 37 */       s = ResourceBundle.getBundle("org.scijava.vecmath.ExceptionStrings").getString(key);
> /*    */     }
> /* 39 */     catch (MissingResourceException e) {
> /* 40 */       System.err.println("VecMathI18N: Error looking up: " + key);
> /* 41 */       s = key;
> /*    */     } 
> /* 43 */     return s;
> /*    */   }
> /*    */ }
3,4d46
< import java.util.MissingResourceException;
< import java.util.ResourceBundle;
6,18c48,51
< class VecMathI18N {
<    static String getString(String key) {
<       String s;
<       try {
<          s = ResourceBundle.getBundle("org.scijava.vecmath.ExceptionStrings").getString(key);
<       } catch (MissingResourceException var3) {
<          System.err.println("VecMathI18N: Error looking up: " + key);
<          s = key;
<       }
< 
<       return s;
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/VecMathI18N.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/VecMathUtil.java jd-gui/vecmath/VecMathUtil.java
1c1,68
< package vecmath;
---
> /*    */ package vecmath;
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */ class VecMathUtil
> /*    */ {
> /*    */   static final long hashLongBits(long hash, long l) {
> /* 40 */     hash *= 31L;
> /* 41 */     return hash + l;
> /*    */   }
> /*    */   
> /*    */   static final long hashFloatBits(long hash, float f) {
> /* 45 */     hash *= 31L;
> /*    */     
> /* 47 */     if (f == 0.0F) {
> /* 48 */       return hash;
> /*    */     }
> /* 50 */     return hash + Float.floatToIntBits(f);
> /*    */   }
> /*    */   
> /*    */   static final long hashDoubleBits(long hash, double d) {
> /* 54 */     hash *= 31L;
> /*    */     
> /* 56 */     if (d == 0.0D) {
> /* 57 */       return hash;
> /*    */     }
> /* 59 */     return hash + Double.doubleToLongBits(d);
> /*    */   }
> /*    */ 
> /*    */ 
> /*    */ 
> /*    */   
> /*    */   static final int hashFinish(long hash) {
> /* 66 */     return (int)(hash ^ hash >> 32L);
> /*    */   }
> /*    */ }
3,5d69
< class VecMathUtil {
<    private VecMathUtil() {
<    }
7,25c71,74
<    static final long hashLongBits(long hash, long l) {
<       hash *= 31L;
<       return hash + l;
<    }
< 
<    static final long hashFloatBits(long hash, float f) {
<       hash *= 31L;
<       return f == 0.0F ? hash : hash + (long)Float.floatToIntBits(f);
<    }
< 
<    static final long hashDoubleBits(long hash, double d) {
<       hash *= 31L;
<       return d == 0.0D ? hash : hash + Double.doubleToLongBits(d);
<    }
< 
<    static final int hashFinish(long hash) {
<       return (int)(hash ^ hash >> 32);
<    }
< }
---
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/VecMathUtil.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Vector2d.java jd-gui/vecmath/Vector2d.java
1,71c1,184
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Vector2d extends Tuple2d implements Serializable {
<    static final long serialVersionUID = 8572646365302599857L;
< 
<    public Vector2d(double x, double y) {
<       super(x, y);
<    }
< 
<    public Vector2d(double[] v) {
<       super(v);
<    }
< 
<    public Vector2d(Vector2d v1) {
<       super((Tuple2d)v1);
<    }
< 
<    public Vector2d(Vector2f v1) {
<       super((Tuple2f)v1);
<    }
< 
<    public Vector2d(Tuple2d t1) {
<       super(t1);
<    }
< 
<    public Vector2d(Tuple2f t1) {
<       super(t1);
<    }
< 
<    public Vector2d() {
<    }
< 
<    public final double dot(Vector2d v1) {
<       return this.x * v1.x + this.y * v1.y;
<    }
< 
<    public final double length() {
<       return Math.sqrt(this.x * this.x + this.y * this.y);
<    }
< 
<    public final double lengthSquared() {
<       return this.x * this.x + this.y * this.y;
<    }
< 
<    public final void normalize(Vector2d v1) {
<       double norm = 1.0D / Math.sqrt(v1.x * v1.x + v1.y * v1.y);
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<    }
< 
<    public final void normalize() {
<       double norm = 1.0D / Math.sqrt(this.x * this.x + this.y * this.y);
<       this.x *= norm;
<       this.y *= norm;
<    }
< 
<    public final double angle(Vector2d v1) {
<       double vDot = this.dot(v1) / (this.length() * v1.length());
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return Math.acos(vDot);
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Vector2d
> /*     */   extends Tuple2d
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = 8572646365302599857L;
> /*     */   
> /*     */   public Vector2d(double x, double y) {
> /*  47 */     super(x, y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2d(double[] v) {
> /*  57 */     super(v);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2d(Vector2d v1) {
> /*  67 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2d(Vector2f v1) {
> /*  77 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2d(Tuple2d t1) {
> /*  87 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2d(Tuple2f t1) {
> /*  97 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2d() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double dot(Vector2d v1) {
> /* 116 */     return this.x * v1.x + this.y * v1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double length() {
> /* 126 */     return Math.sqrt(this.x * this.x + this.y * this.y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double lengthSquared() {
> /* 135 */     return this.x * this.x + this.y * this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize(Vector2d v1) {
> /* 146 */     double norm = 1.0D / Math.sqrt(v1.x * v1.x + v1.y * v1.y);
> /* 147 */     v1.x *= norm;
> /* 148 */     v1.y *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize() {
> /* 158 */     double norm = 
> /* 159 */       1.0D / Math.sqrt(this.x * this.x + this.y * this.y);
> /* 160 */     this.x *= norm;
> /* 161 */     this.y *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double angle(Vector2d v1) {
> /* 173 */     double vDot = dot(v1) / length() * v1.length();
> /* 174 */     if (vDot < -1.0D) vDot = -1.0D; 
> /* 175 */     if (vDot > 1.0D) vDot = 1.0D; 
> /* 176 */     return Math.acos(vDot);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Vector2d.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Vector2f.java jd-gui/vecmath/Vector2f.java
1,71c1,185
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Vector2f extends Tuple2f implements Serializable {
<    static final long serialVersionUID = -2168194326883512320L;
< 
<    public Vector2f(float x, float y) {
<       super(x, y);
<    }
< 
<    public Vector2f(float[] v) {
<       super(v);
<    }
< 
<    public Vector2f(Vector2f v1) {
<       super((Tuple2f)v1);
<    }
< 
<    public Vector2f(Vector2d v1) {
<       super((Tuple2d)v1);
<    }
< 
<    public Vector2f(Tuple2f t1) {
<       super(t1);
<    }
< 
<    public Vector2f(Tuple2d t1) {
<       super(t1);
<    }
< 
<    public Vector2f() {
<    }
< 
<    public final float dot(Vector2f v1) {
<       return this.x * v1.x + this.y * v1.y;
<    }
< 
<    public final float length() {
<       return (float)Math.sqrt((double)(this.x * this.x + this.y * this.y));
<    }
< 
<    public final float lengthSquared() {
<       return this.x * this.x + this.y * this.y;
<    }
< 
<    public final void normalize(Vector2f v1) {
<       float norm = (float)(1.0D / Math.sqrt((double)(v1.x * v1.x + v1.y * v1.y)));
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<    }
< 
<    public final void normalize() {
<       float norm = (float)(1.0D / Math.sqrt((double)(this.x * this.x + this.y * this.y)));
<       this.x *= norm;
<       this.y *= norm;
<    }
< 
<    public final float angle(Vector2f v1) {
<       double vDot = (double)(this.dot(v1) / (this.length() * v1.length()));
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return (float)Math.acos(vDot);
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Vector2f
> /*     */   extends Tuple2f
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = -2168194326883512320L;
> /*     */   
> /*     */   public Vector2f(float x, float y) {
> /*  47 */     super(x, y);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2f(float[] v) {
> /*  57 */     super(v);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2f(Vector2f v1) {
> /*  67 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2f(Vector2d v1) {
> /*  77 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2f(Tuple2f t1) {
> /*  87 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2f(Tuple2d t1) {
> /*  97 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector2f() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float dot(Vector2f v1) {
> /* 117 */     return this.x * v1.x + this.y * v1.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float length() {
> /* 127 */     return (float)Math.sqrt((this.x * this.x + this.y * this.y));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float lengthSquared() {
> /* 136 */     return this.x * this.x + this.y * this.y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize(Vector2f v1) {
> /* 147 */     float norm = (float)(1.0D / Math.sqrt((v1.x * v1.x + v1.y * v1.y)));
> /* 148 */     v1.x *= norm;
> /* 149 */     v1.y *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize() {
> /* 159 */     float norm = 
> /* 160 */       (float)(1.0D / Math.sqrt((this.x * this.x + this.y * this.y)));
> /* 161 */     this.x *= norm;
> /* 162 */     this.y *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float angle(Vector2f v1) {
> /* 174 */     double vDot = (dot(v1) / length() * v1.length());
> /* 175 */     if (vDot < -1.0D) vDot = -1.0D; 
> /* 176 */     if (vDot > 1.0D) vDot = 1.0D; 
> /* 177 */     return (float)Math.acos(vDot);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Vector2f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Vector3d.java jd-gui/vecmath/Vector3d.java
1,81c1,208
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Vector3d extends Tuple3dModified implements Serializable {
<    static final long serialVersionUID = 3761969948420550442L;
< 
<    public Vector3d(double x, double y, double z) {
<       super(x, y, z);
<    }
< 
<    public Vector3d(double[] v) {
<       super(v);
<    }
< 
<    public Vector3d(Vector3d v1) {
<       super((Tuple3dModified)v1);
<    }
< 
<    public Vector3d(Vector3f v1) {
<       super((Tuple3f)v1);
<    }
< 
<    public Vector3d(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public Vector3d(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public Vector3d() {
<    }
< 
<    public final void cross(Vector3d v1, Vector3d v2) {
<       double x = v1.y * v2.z - v1.z * v2.y;
<       double y = v2.x * v1.z - v2.z * v1.x;
<       this.z = v1.x * v2.y - v1.y * v2.x;
<       this.x = x;
<       this.y = y;
<    }
< 
<    public final void normalize(Vector3d v1) {
<       double norm = 1.0D / Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<       this.z = v1.z * norm;
<    }
< 
<    public final void normalize() {
<       double norm = 1.0D / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
<       this.x *= norm;
<       this.y *= norm;
<       this.z *= norm;
<    }
< 
<    public final double dot(Vector3d v1) {
<       return this.x * v1.x + this.y * v1.y + this.z * v1.z;
<    }
< 
<    public final double lengthSquared() {
<       return this.x * this.x + this.y * this.y + this.z * this.z;
<    }
< 
<    public final double length() {
<       return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
<    }
< 
<    public final double angle(Vector3d v1) {
<       double vDot = this.dot(v1) / (this.length() * v1.length());
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return Math.acos(vDot);
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Vector3d
> /*     */   extends Tuple3dModified
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = 3761969948420550442L;
> /*     */   
> /*     */   public Vector3d(double x, double y, double z) {
> /*  49 */     super(x, y, z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3d(double[] v) {
> /*  59 */     super(v);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3d(Vector3d v1) {
> /*  69 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3d(Vector3f v1) {
> /*  79 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3d(Tuple3f t1) {
> /*  89 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3d(Tuple3dModified t1) {
> /*  99 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3d() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void cross(Vector3d v1, Vector3d v2) {
> /* 121 */     double x = v1.y * v2.z - v1.z * v2.y;
> /* 122 */     double y = v2.x * v1.z - v2.z * v1.x;
> /* 123 */     this.z = v1.x * v2.y - v1.y * v2.x;
> /* 124 */     this.x = x;
> /* 125 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize(Vector3d v1) {
> /* 137 */     double norm = 1.0D / Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
> /* 138 */     v1.x *= norm;
> /* 139 */     v1.y *= norm;
> /* 140 */     v1.z *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize() {
> /* 151 */     double norm = 1.0D / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
> /* 152 */     this.x *= norm;
> /* 153 */     this.y *= norm;
> /* 154 */     this.z *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double dot(Vector3d v1) {
> /* 165 */     return this.x * v1.x + this.y * v1.y + this.z * v1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double lengthSquared() {
> /* 175 */     return this.x * this.x + this.y * this.y + this.z * this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double length() {
> /* 185 */     return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double angle(Vector3d v1) {
> /* 197 */     double vDot = dot(v1) / length() * v1.length();
> /* 198 */     if (vDot < -1.0D) vDot = -1.0D; 
> /* 199 */     if (vDot > 1.0D) vDot = 1.0D; 
> /* 200 */     return Math.acos(vDot);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Vector3d.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Vector3f.java jd-gui/vecmath/Vector3f.java
1,81c1,204
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Vector3f extends Tuple3f implements Serializable {
<    static final long serialVersionUID = -7031930069184524614L;
< 
<    public Vector3f(float x, float y, float z) {
<       super(x, y, z);
<    }
< 
<    public Vector3f(float[] v) {
<       super(v);
<    }
< 
<    public Vector3f(Vector3f v1) {
<       super((Tuple3f)v1);
<    }
< 
<    public Vector3f(Vector3d v1) {
<       super((Tuple3dModified)v1);
<    }
< 
<    public Vector3f(Tuple3f t1) {
<       super(t1);
<    }
< 
<    public Vector3f(Tuple3dModified t1) {
<       super(t1);
<    }
< 
<    public Vector3f() {
<    }
< 
<    public final float lengthSquared() {
<       return this.x * this.x + this.y * this.y + this.z * this.z;
<    }
< 
<    public final float length() {
<       return (float)Math.sqrt((double)(this.x * this.x + this.y * this.y + this.z * this.z));
<    }
< 
<    public final void cross(Vector3f v1, Vector3f v2) {
<       float x = v1.y * v2.z - v1.z * v2.y;
<       float y = v2.x * v1.z - v2.z * v1.x;
<       this.z = v1.x * v2.y - v1.y * v2.x;
<       this.x = x;
<       this.y = y;
<    }
< 
<    public final float dot(Vector3f v1) {
<       return this.x * v1.x + this.y * v1.y + this.z * v1.z;
<    }
< 
<    public final void normalize(Vector3f v1) {
<       float norm = (float)(1.0D / Math.sqrt((double)(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z)));
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<       this.z = v1.z * norm;
<    }
< 
<    public final void normalize() {
<       float norm = (float)(1.0D / Math.sqrt((double)(this.x * this.x + this.y * this.y + this.z * this.z)));
<       this.x *= norm;
<       this.y *= norm;
<       this.z *= norm;
<    }
< 
<    public final float angle(Vector3f v1) {
<       double vDot = (double)(this.dot(v1) / (this.length() * v1.length()));
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return (float)Math.acos(vDot);
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Vector3f
> /*     */   extends Tuple3f
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = -7031930069184524614L;
> /*     */   
> /*     */   public Vector3f(float x, float y, float z) {
> /*  49 */     super(x, y, z);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3f(float[] v) {
> /*  59 */     super(v);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3f(Vector3f v1) {
> /*  69 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3f(Vector3d v1) {
> /*  79 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3f(Tuple3f t1) {
> /*  88 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3f(Tuple3dModified t1) {
> /*  97 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector3f() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float lengthSquared() {
> /* 116 */     return this.x * this.x + this.y * this.y + this.z * this.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float length() {
> /* 125 */     return 
> /* 126 */       (float)Math.sqrt((this.x * this.x + this.y * this.y + this.z * this.z));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void cross(Vector3f v1, Vector3f v2) {
> /* 139 */     float x = v1.y * v2.z - v1.z * v2.y;
> /* 140 */     float y = v2.x * v1.z - v2.z * v1.x;
> /* 141 */     this.z = v1.x * v2.y - v1.y * v2.x;
> /* 142 */     this.x = x;
> /* 143 */     this.y = y;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float dot(Vector3f v1) {
> /* 153 */     return this.x * v1.x + this.y * v1.y + this.z * v1.z;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize(Vector3f v1) {
> /* 164 */     float norm = (float)(1.0D / Math.sqrt((v1.x * v1.x + v1.y * v1.y + v1.z * v1.z)));
> /* 165 */     v1.x *= norm;
> /* 166 */     v1.y *= norm;
> /* 167 */     v1.z *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize() {
> /* 177 */     float norm = 
> /* 178 */       (float)(1.0D / Math.sqrt((this.x * this.x + this.y * this.y + this.z * this.z)));
> /* 179 */     this.x *= norm;
> /* 180 */     this.y *= norm;
> /* 181 */     this.z *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float angle(Vector3f v1) {
> /* 193 */     double vDot = (dot(v1) / length() * v1.length());
> /* 194 */     if (vDot < -1.0D) vDot = -1.0D; 
> /* 195 */     if (vDot > 1.0D) vDot = 1.0D; 
> /* 196 */     return (float)Math.acos(vDot);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Vector3f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Vector4d.java jd-gui/vecmath/Vector4d.java
1,86c1,223
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Vector4d extends Tuple4d implements Serializable {
<    static final long serialVersionUID = 3938123424117448700L;
< 
<    public Vector4d(double x, double y, double z, double w) {
<       super(x, y, z, w);
<    }
< 
<    public Vector4d(double[] v) {
<       super(v);
<    }
< 
<    public Vector4d(Vector4d v1) {
<       super((Tuple4d)v1);
<    }
< 
<    public Vector4d(Vector4f v1) {
<       super((Tuple4f)v1);
<    }
< 
<    public Vector4d(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public Vector4d(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public Vector4d(Tuple3dModified t1) {
<       super(t1.x, t1.y, t1.z, 0.0D);
<    }
< 
<    public Vector4d() {
<    }
< 
<    public final void set(Tuple3dModified t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = 0.0D;
<    }
< 
<    public final double length() {
<       return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
<    }
< 
<    public final double lengthSquared() {
<       return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
<    }
< 
<    public final double dot(Vector4d v1) {
<       return this.x * v1.x + this.y * v1.y + this.z * v1.z + this.w * v1.w;
<    }
< 
<    public final void normalize(Vector4d v1) {
<       double norm = 1.0D / Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z + v1.w * v1.w);
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<       this.z = v1.z * norm;
<       this.w = v1.w * norm;
<    }
< 
<    public final void normalize() {
<       double norm = 1.0D / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
<       this.x *= norm;
<       this.y *= norm;
<       this.z *= norm;
<       this.w *= norm;
<    }
< 
<    public final double angle(Vector4d v1) {
<       double vDot = this.dot(v1) / (this.length() * v1.length());
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return Math.acos(vDot);
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Vector4d
> /*     */   extends Tuple4d
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = 3938123424117448700L;
> /*     */   
> /*     */   public Vector4d(double x, double y, double z, double w) {
> /*  49 */     super(x, y, z, w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4d(double[] v) {
> /*  59 */     super(v);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4d(Vector4d v1) {
> /*  68 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4d(Vector4f v1) {
> /*  77 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4d(Tuple4f t1) {
> /*  86 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4d(Tuple4d t1) {
> /*  95 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4d(Tuple3dModified t1) {
> /* 109 */     super(t1.x, t1.y, t1.z, 0.0D);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4d() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple3dModified t1) {
> /* 131 */     this.x = t1.x;
> /* 132 */     this.y = t1.y;
> /* 133 */     this.z = t1.z;
> /* 134 */     this.w = 0.0D;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double length() {
> /* 144 */     return Math.sqrt(this.x * this.x + this.y * this.y + 
> /* 145 */         this.z * this.z + this.w * this.w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double lengthSquared() {
> /* 155 */     return this.x * this.x + this.y * this.y + 
> /* 156 */       this.z * this.z + this.w * this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double dot(Vector4d v1) {
> /* 167 */     return this.x * v1.x + this.y * v1.y + this.z * v1.z + this.w * v1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize(Vector4d v1) {
> /* 179 */     double norm = 1.0D / Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z + v1.w * v1.w);
> /* 180 */     v1.x *= norm;
> /* 181 */     v1.y *= norm;
> /* 182 */     v1.z *= norm;
> /* 183 */     v1.w *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize() {
> /* 194 */     double norm = 1.0D / Math.sqrt(this.x * this.x + this.y * this.y + 
> /* 195 */         this.z * this.z + this.w * this.w);
> /* 196 */     this.x *= norm;
> /* 197 */     this.y *= norm;
> /* 198 */     this.z *= norm;
> /* 199 */     this.w *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final double angle(Vector4d v1) {
> /* 212 */     double vDot = dot(v1) / length() * v1.length();
> /* 213 */     if (vDot < -1.0D) vDot = -1.0D; 
> /* 214 */     if (vDot > 1.0D) vDot = 1.0D; 
> /* 215 */     return Math.acos(vDot);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Vector4d.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
diff -r TrackAnalyzer_/vecmath/Vector4f.java jd-gui/vecmath/Vector4f.java
1,86c1,227
< package vecmath;
< 
< import java.io.Serializable;
< 
< public class Vector4f extends Tuple4f implements Serializable {
<    static final long serialVersionUID = 8749319902347760659L;
< 
<    public Vector4f(float x, float y, float z, float w) {
<       super(x, y, z, w);
<    }
< 
<    public Vector4f(float[] v) {
<       super(v);
<    }
< 
<    public Vector4f(Vector4f v1) {
<       super((Tuple4f)v1);
<    }
< 
<    public Vector4f(Vector4d v1) {
<       super((Tuple4d)v1);
<    }
< 
<    public Vector4f(Tuple4f t1) {
<       super(t1);
<    }
< 
<    public Vector4f(Tuple4d t1) {
<       super(t1);
<    }
< 
<    public Vector4f(Tuple3f t1) {
<       super(t1.x, t1.y, t1.z, 0.0F);
<    }
< 
<    public Vector4f() {
<    }
< 
<    public final void set(Tuple3f t1) {
<       this.x = t1.x;
<       this.y = t1.y;
<       this.z = t1.z;
<       this.w = 0.0F;
<    }
< 
<    public final float length() {
<       return (float)Math.sqrt((double)(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w));
<    }
< 
<    public final float lengthSquared() {
<       return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
<    }
< 
<    public final float dot(Vector4f v1) {
<       return this.x * v1.x + this.y * v1.y + this.z * v1.z + this.w * v1.w;
<    }
< 
<    public final void normalize(Vector4f v1) {
<       float norm = (float)(1.0D / Math.sqrt((double)(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z + v1.w * v1.w)));
<       this.x = v1.x * norm;
<       this.y = v1.y * norm;
<       this.z = v1.z * norm;
<       this.w = v1.w * norm;
<    }
< 
<    public final void normalize() {
<       float norm = (float)(1.0D / Math.sqrt((double)(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)));
<       this.x *= norm;
<       this.y *= norm;
<       this.z *= norm;
<       this.w *= norm;
<    }
< 
<    public final float angle(Vector4f v1) {
<       double vDot = (double)(this.dot(v1) / (this.length() * v1.length()));
<       if (vDot < -1.0D) {
<          vDot = -1.0D;
<       }
< 
<       if (vDot > 1.0D) {
<          vDot = 1.0D;
<       }
< 
<       return (float)Math.acos(vDot);
<    }
< }
---
> /*     */ package vecmath;
> /*     */ 
> /*     */ import java.io.Serializable;
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ public class Vector4f
> /*     */   extends Tuple4f
> /*     */   implements Serializable
> /*     */ {
> /*     */   static final long serialVersionUID = 8749319902347760659L;
> /*     */   
> /*     */   public Vector4f(float x, float y, float z, float w) {
> /*  49 */     super(x, y, z, w);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4f(float[] v) {
> /*  59 */     super(v);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4f(Vector4f v1) {
> /*  69 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4f(Vector4d v1) {
> /*  79 */     super(v1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4f(Tuple4f t1) {
> /*  89 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4f(Tuple4d t1) {
> /*  99 */     super(t1);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4f(Tuple3f t1) {
> /* 113 */     super(t1.x, t1.y, t1.z, 0.0F);
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public Vector4f() {}
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void set(Tuple3f t1) {
> /* 135 */     this.x = t1.x;
> /* 136 */     this.y = t1.y;
> /* 137 */     this.z = t1.z;
> /* 138 */     this.w = 0.0F;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float length() {
> /* 148 */     return 
> /* 149 */       (float)Math.sqrt((this.x * this.x + this.y * this.y + 
> /* 150 */         this.z * this.z + this.w * this.w));
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float lengthSquared() {
> /* 159 */     return this.x * this.x + this.y * this.y + 
> /* 160 */       this.z * this.z + this.w * this.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float dot(Vector4f v1) {
> /* 170 */     return this.x * v1.x + this.y * v1.y + this.z * v1.z + this.w * v1.w;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize(Vector4f v1) {
> /* 182 */     float norm = (float)(1.0D / Math.sqrt((v1.x * v1.x + v1.y * v1.y + 
> /* 183 */         v1.z * v1.z + v1.w * v1.w)));
> /* 184 */     v1.x *= norm;
> /* 185 */     v1.y *= norm;
> /* 186 */     v1.z *= norm;
> /* 187 */     v1.w *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final void normalize() {
> /* 198 */     float norm = (float)(1.0D / Math.sqrt((this.x * this.x + this.y * this.y + 
> /* 199 */         this.z * this.z + this.w * this.w)));
> /* 200 */     this.x *= norm;
> /* 201 */     this.y *= norm;
> /* 202 */     this.z *= norm;
> /* 203 */     this.w *= norm;
> /*     */   }
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */ 
> /*     */   
> /*     */   public final float angle(Vector4f v1) {
> /* 216 */     double vDot = (dot(v1) / length() * v1.length());
> /* 217 */     if (vDot < -1.0D) vDot = -1.0D; 
> /* 218 */     if (vDot > 1.0D) vDot = 1.0D; 
> /* 219 */     return (float)Math.acos(vDot);
> /*     */   }
> /*     */ }
> 
> 
> /* Location:              /mnt/jr/work/mmellado/TrackAnalyzer/TrackAnalyzer_CNB/jar_expanded/!/vecmath/Vector4f.class
>  * Java compiler version: 8 (52.0)
>  * JD-Core Version:       1.1.3
>  */
\ No newline at end of file
